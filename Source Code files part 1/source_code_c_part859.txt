ion id of zero indicates that it is
**		not being used.
*/
typedef struct
{
	GCCObjectKey		application_protocol_key;
	unsigned short		session_id;
} GCCSessionKey;


/*
**	CapabilityType
**		T.124 supports three different rules when collapsing the capabilities
**		list.  "Logical" keeps a count of the Application Protocol Entities 
**		(APEs) that have that capability, "Unsigned Minimum" collapses to the 
**		minimum value and "Unsigned	Maximum" collapses to the maximum value.		
*/
typedef enum
{
	GCC_LOGICAL_CAPABILITY					= 1,
	GCC_UNSIGNED_MINIMUM_CAPABILITY			= 2,
	GCC_UNSIGNED_MAXIMUM_CAPABILITY			= 3
} GCCCapabilityType;
 

typedef enum
{
	GCC_STANDARD_CAPABILITY					= 0,
	GCC_NON_STANDARD_CAPABILITY				= 1
} GCCCapabilityIDType;

/*
**	CapabilityID
**		T.124 supports both standard and non-standard capabilities.  This
**		structure is used to differentiate between the two.		
*/
typedef struct 
{
    GCCCapabilityIDType		capability_id_type;
	
    union
    {
        unsigned short  	standard_capability;
        GCCObjectKey		non_standard_capability;
    } u;
} GCCCapabilityID;

/* 
**	CapabilityClass
**		This structure defines the class of capability and holds the associated
**		value. Note that Logical is not necessary.  Information associated with 
**		logical is stored in number_of_entities in the GCCApplicationCapability 
**		structure.
*/
typedef struct 
{
    GCCCapabilityType	capability_type;
    
    union 
    {
        unsigned long   unsigned_min;	
        unsigned long   unsigned_max;
    } u;
} GCCCapabilityClass;

/* 
**	GCCApplicationCapability
**		This structure holds all the data associated with a single T.124 
**		defined application capability.
*/
typedef struct
{
	GCCCapabilityID			capability_id;
	GCCCapabilityClass		capability_class;
    unsigned long   		number_of_entities;	
} GCCApplicationCapability;

/* 
**	GCCNonCollapsingCapability
*/
typedef struct
{
	GCCCapabilityID				capability_id;
	GCCOctetString	FAR	*		application_data;	/* optional */
} GCCNonCollapsingCapability;

/* 
**	GCCApplicationRecord
**		This structure holds all the data associated with a single T.124 
**		application record.  See the T.124 specification for what parameters
**		are optional.
*/
typedef struct
{
	UserID						node_id;
	unsigned short				entity_id;
	T120Boolean					is_enrolled_actively;
	T120Boolean					is_conducting_capable;
	MCSChannelType				startup_channel_type; 
	UserID						application_user_id;  			/* optional */
	unsigned short				number_of_non_collapsed_caps;
	GCCNonCollapsingCapability 
					FAR * FAR *	non_collapsed_caps_list;		/* optional */
} GCCApplicationRecord;

/* 
**	GCCApplicationRoster
**		This structure holds all the data associated with a single T.124 
**		application roster.  This includes the collapsed capabilites and
**		the complete list of application records associated with an Application
**		Protocol Entity (APE).
*/
typedef struct
{
	GCCSessionKey							session_key;
	T120Boolean 							application_roster_was_changed;
	unsigned short							number_of_records;
	GCCApplicationRecord 	FAR * FAR *		application_record_list;
	unsigned short							instance_number;
	T120Boolean 							nodes_were_added;
	T120Boolean 							nodes_were_removed;
	T120Boolean 							capabilities_were_changed;
	unsigned short							number_of_capabilities;
	GCCApplicationCapability FAR * FAR *	capabilities_list;	/* optional */		
} GCCApplicationRoster;

/*
**	GCCRegistryKey
**		This key is used to identify a specific resource used
**		by an application. This may be a particular channel or token needed
**		for control purposes.
*/
typedef struct
{
	GCCSessionKey		session_key;
	GCCOctetString		resource_id;	/* Max length is 64 */
} GCCRegistryKey;

/*
**	RegistryItemType
**		This enum is used to specify what type of registry item is contained
**		at the specified slot in the registry.
*/
typedef enum
{
	GCC_REGISTRY_CHANNEL_ID				= 1,
	GCC_REGISTRY_TOKEN_ID				= 2,
	GCC_REGISTRY_PARAMETER				= 3,
	GCC_REGISTRY_NONE					= 4
} GCCRegistryItemType;

/*
**	GCCRegistryItem
**		This structure is used to hold a single registry item.  Note that the
**		union supports all three registry types supported by GCC.
*/
typedef struct
{
	GCCRegistryItemType	item_type;
	union
	{
		ChannelID			channel_id;
		TokenID				token_id;
		GCCOctetString		parameter;		/* Max length is 64 */
	} u;
} GCCRegistryItem;


/*
**	GCCRegistryEntryOwner
**
*/
typedef struct
{
	T120Boolean		entry_is_owned;
	UserID			owner_node_id;
	unsigned short	owner_entity_id;
} GCCRegistryEntryOwner;

/*
**	GCCModificationRights
**		This enum is used when specifing what kind of rights a node has to
**		alter the contents of a registry "parameter".
*/
typedef	enum
{
	GCC_OWNER_RIGHTS					 = 0,
	GCC_SESSION_RIGHTS					 = 1,
	GCC_PUBLIC_RIGHTS					 = 2,
	GCC_NO_MODIFICATION_RIGHTS_SPECIFIED = 3
} GCCModificationRights;

/*
**	GCCAppProtocolEntity
**		This structure is used to identify a protocol entity at a remote node
**		when invoke is used.
*/
typedef	struct
{
	GCCSessionKey							session_key;
	unsigned short							number_of_expected_capabilities;
	GCCApplicationCapability FAR *	FAR *	expected_capabilities_list;
	MCSChannelType							startup_channel_type;
	T120Boolean								must_be_invoked;		
} GCCAppProtocolEntity;


/*
**	GCCMessageType
**		This section defines the messages that can be sent to the application
**		through the callback facility.  These messages correspond to the 
**		indications and confirms that are defined within T.124.
*/
typedef	enum
{
	/******************* NODE CONTROLLER CALLBACKS ***********************/
	
	/* Conference Create, Terminate related calls */
	GCC_CREATE_INDICATION					= 0,
	GCC_CREATE_CONFIRM						= 1,
	GCC_QUERY_INDICATION					= 2,
	GCC_QUERY_CONFIRM						= 3,
	GCC_JOIN_INDICATION						= 4,
	GCC_JOIN_CONFIRM						= 5,
	GCC_INVITE_INDICATION					= 6,
	GCC_INVITE_CONFIRM						= 7,
	GCC_ADD_INDICATION						= 8,
	GCC_ADD_CONFIRM							= 9,
	GCC_LOCK_INDICATION						= 10,
	GCC_LOCK_CONFIRM						= 11,
	GCC_UNLOCK_INDICATION					= 12,
	GCC_UNLOCK_CONFIRM						= 13,
	GCC_LOCK_REPORT_INDICATION				= 14,
	GCC_DISCONNECT_INDICATION				= 15,
	GCC_DISCONNECT_CONFIRM					= 16,
	GCC_TERMINATE_INDICATION				= 17,
	GCC_TERMINATE_CONFIRM					= 18,
	GCC_EJECT_USER_INDICATION				= 19,
	GCC_EJECT_USER_CONFIRM					= 20,
	GCC_TRANSFER_INDICATION					= 21,
	GCC_TRANSFER_CONFIRM					= 22,
	GCC_APPLICATION_INVOKE_INDICATION		= 23,		/* SHARED CALLBACK */
	GCC_APPLICATION_INVOKE_CONFIRM			= 24,		/* SHARED CALLBACK */
	GCC_SUB_INITIALIZED_INDICATION			= 25,

	/* Conference Roster related callbacks */
	GCC_ANNOUNCE_PRESENCE_CONFIRM			= 26,
	GCC_ROSTER_REPORT_INDICATION			= 27,		/* SHARED CALLBACK */
	GCC_ROSTER_INQUIRE_CONFIRM				= 28,		/* SHARED CALLBACK */

	/* Conductorship related callbacks */
	GCC_CONDUCT_ASSIGN_INDICATION			= 29,		/* SHARED CALLBACK */
	GCC_CONDUCT_ASSIGN_CONFIRM				= 30,
	GCC_CONDUCT_RELEASE_INDICATION			= 31,		/* SHARED CALLBACK */
	GCC_CONDUCT_RELEASE_CONFIRM				= 32,
	GCC_CONDUCT_PLEASE_INDICATION			= 33,
	GCC_CONDUCT_PLEASE_CONFIRM				= 34,
	GCC_CONDUCT_GIVE_INDICATION				= 35,
	GCC_CONDUCT_GIVE_CONFIRM				= 36,
	GCC_CONDUCT_INQUIRE_CONFIRM				= 37,		/* SHARED CALLBACK */
	GCC_CONDUCT_ASK_INDICATION				= 38,
	GCC_CONDUCT_ASK_CONFIRM					= 39,
	GCC_CONDUCT_GRANT_INDICATION			= 40,		/* SHARED CALLBACK */
	GCC_CONDUCT_GRANT_CONFIRM				= 41,

	/* Miscellaneous Node Controller callbacks */
	GCC_TIME_REMAINING_INDICATION			= 42,
	GCC_TIME_REMAINING_CONFIRM				= 43,
	GCC_TIME_INQUIRE_INDICATION				= 44,
	GCC_TIME_INQUIRE_CONFIRM				= 45,
	GCC_CONFERENCE_EXTEND_INDICATION		= 46,
	GCC_CONFERENCE_EXTEND_CONFIRM			= 47,
	GCC_ASSISTANCE_INDICATION				= 48,
	GCC_ASSISTANCE_CONFIRM					= 49,
	GCC_TEXT_MESSAGE_INDICATION				= 50,
	GCC_TEXT_MESSAGE_CONFIRM				= 51,

	/***************** USER APPLICATION CALLBACKS *******************/

	/* Application Roster related callbacks */
	GCC_PERMIT_TO_ENROLL_INDICATION			= 52,
	GCC_ENROLL_CONFIRM						= 53,
	GCC_APP_ROSTER_REPORT_INDICATION		= 54,		/* SHARED CALLBACK */
	GCC_APP_ROSTER_INQUIRE_CONFIRM			= 55,		/* SHARED CALLBACK */

	/* Application Registry related callbacks */
	GCC_REGISTER_CHANNEL_CONFIRM			= 56,
	GCC_ASSIGN_TOKEN_CONFIRM				= 57,
	GCC_RETRIEVE_ENTRY_CONFIRM				= 58,
	GCC_DELETE_ENTRY_CONFIRM				= 59,
	GCC_SET_PARAMETER_CONFIRM				= 60,
	GCC_MONITOR_INDICATION					= 61,
	GCC_MONITOR_CONFIRM						= 62,
	GCC_ALLOCATE_HANDLE_CONFIRM				= 63,


	/****************** NON-Standard Primitives **********************/

	GCC_PERMIT_TO_ANNOUNCE_PRESENCE		= 100,	/*	Node Controller Callback */	
	GCC_CONNECTION_BROKEN_INDICATION	= 101,	/*	Node Controller Callback */
	GCC_FATAL_ERROR_SAP_REMOVED			= 102,	/*	Application Callback 	 */
	GCC_STATUS_INDICATION				= 103,	/*	Node Controller Callback */
	GCC_TRANSPORT_STATUS_INDICATION		= 104	/*	Node Controller Callback */

} GCCMessageType;


/*
 *	These structures are used to hold the information included for the
 *	various callback messages.  In the case where these structures are used for 
 *	callbacks, the address of the structure is passed as the only parameter.
 */

/*********************************************************************
 *																	 *
 *			NODE CONTROLLER CALLBACK INFO STRUCTURES			 	 *
 *																	 *
 *********************************************************************/

/*
 *	GCC_CREATE_INDICATION
 *
 *	Union Choice:
 *		CreateIndicationMessage
 *			This is a pointer to a structure that contains all necessary
 *			information about the new conference that is about to be created.
 */
typedef struct
{
	GCCConferenceName				conference_name;
	GCCConferenceID					conference_id;
	GCCPassword				FAR *	convener_password;			  /* optional */
	GCCPassword				FAR *	password;					  /* optional */
	T120Boolean						conference_is_locked;
	T120Boolean						conference_is_listed;
	T120Boolean						conference_is_conductible;
	GCCTerminationMethod			termination_method;
	GCCConferencePrivileges	FAR *	conductor_privilege_list;	  /* optional */
	GCCConferencePrivileges	FAR *	conducted_mode_privilege_list;/* optional */
	GCCConferencePrivileges	FAR *	non_conducted_privilege_list; /* optional */
	GCCUnicodeString				conference_descriptor;		  /* optional */
	GCCUnicodeString				caller_identifier;			  /* optional */
	TransportAddress				calling_address;			  /* optional */
	TransportAddress				called_address;				  /* optional */
	DomainParameters		FAR *	domain_parameters;			  /* optional */
	unsigned short					number_of_user_data_members;
	GCCUserData		FAR *	FAR *	user_data_list;				  /* optional */
	ConnectionHandle				connection_handle;
	PhysicalHandle					physical_handle;
} CreateIndicationMessage;

/*
 *	GCC_CREATE_CONFIRM
 *
 *	Union Choice:
 *		CreateConfirmMessage
 *			This is a pointer to a structure that contains all necessary
 *			information about the result of a conference create request.
 *			The connection handle and physical handle will be zero on a
 *			local create.
 */
typedef struct
{
	GCCConferenceName				conference_name;
	GCCNumericString				conference_modifier;		/* optional */
	GCCConferenceID					conference_id;
	DomainParameters		FAR *	domain_parameters;			/* optional */
	unsigned short					number_of_user_data_members;
	GCCUserData		FAR *	FAR *	user_data_list;				/* optional */
	GCCResult						result;
	ConnectionHandle				connection_handle;			/* optional */
	PhysicalHandle					physical_handle;			/* optional */
} CreateConfirmMessage;

/*
 *	GCC_QUERY_INDICATION
 *
 *	Union Choice:
 *		QueryIndicationMessage
 *			This is a pointer to a structure that contains all necessary
 *			information about the conference query.
 */
typedef struct
{
	GCCResponseTag					query_response_tag;
	GCCNodeType						node_type;
	GCCAsymmetryIndicator	FAR *	asymmetry_indicator;
	TransportAddress				calling_address;			  /* optional */
	TransportAddress				called_address;				  /* optional */
	unsigned short					number_of_user_data_members;
	GCCUserData		FAR *	FAR *	user_data_list;				  /* optional */
	ConnectionHandle				connection_handle;
	PhysicalHandle					physical_handle;
} QueryIndicationMessage;

/*
 *	GCC_QUERY_CONFIRM
 *
 *	Union Choice:
 *		QueryConfirmMessage
 *			This is a pointer to a structure that contains all necessary
 *			information about the result of a conference query request.
 */
typedef struct
{
	GCCNodeType							node_type;
	GCCAsymmetryIndicator 	FAR *		asymmetry_indicator;	/* optional */
	unsigned short						number_of_descriptors;
	GCCConferenceDescriptor FAR * FAR *	conference_descriptor_list;/* optional*/
	unsigned short						number_of_user_data_members;
	GCCUserData		FAR *	FAR *		user_data_list;			/* optional */
	GCCResult							result;
	ConnectionHandle					connection_handle;
	PhysicalHandle						physical_handle;
} QueryConfirmMessage;
										    

/*
 *	GCC_JOIN_INDICATION
 *
 *	Union Choice:
 *		JoinIndicationMessage
 *			This is a pointer to a structure that contains all necessary
 *			information about the join request.
 */
typedef struct
{
	GCCResponseTag					join_response_tag;
	GCCConferenceID					conference_id;
	GCCPassword			FAR *		convener_password;			  /* optional */
	GCCChallengeRequestResponse	
							FAR	*	password_challenge;			  /* optional */
	GCCUnicodeString				caller_identifier;			  /* optional */
	TransportAddress				calling_address;			  /* optional */
	TransportAddress				called_address;				  /* optional */
	unsigned short					number_of_user_data_members;
	GCCUserData		FAR *	FAR *	user_data_list;				  /* optional */
	T120Boolean						node_is_intermediate;
	ConnectionHandle				connection_handle;
	PhysicalHandle					physical_handle;
} JoinIndicationMessage;

/*
 *	GCC_JOIN_CONFIRM
 *
 *	Union Choice:
 *		JoinConfirmMessage
 *			This is a pointer to a structure that contains all necessary
 *			information about the join confirm.
 */
typedef struct
{
	GCCConferenceName				conference_name;
	GCCNumericString				called_node_modifier;		  /* optional */
	GCCNumericString				calling_node_modifier;		  /* optional */
	GCCConferenceID					conference_id;
	GCCChallengeRequestResponse	
							FAR	*	password_challenge;			  /* optional */
	DomainParameters 		FAR *	domain_parameters;
	T120Boolean						clear_password_required;
	T120Boolean						conference_is_locked;
	T120Boolean						conference_is_listed;
	T120Boolean						conference_is_conductible;
	GCCTerminationMethod			termination_method;
	GCCConferencePrivileges	FAR *	conductor_privilege_list;	  /* optional */
	GCCConferencePrivileges FAR *	conducted_mode_privilege_list;/* optional */
	GCCConferencePrivileges FAR *	non_conducted_privilege_list; /* optional */
	GCCUnicodeString				conference_descriptor;		  /* optional */
	unsigned short					number_of_user_data_members;
	GCCUserData		FAR *	FAR *	user_data_list;				  /* optional */
	GCCResult						result;
	ConnectionHandle				connection_handle;
	PhysicalHandle					physical_handle;
} JoinConfirmMessage;

/*
 *	GCC_INVITE_INDICATION
 *
 *	Union Choice:
 *		InviteIndicationMessage
 *			This is a pointer to a structure that contains all necessary
 *			information about the invite indication.
 */
typedef struct
{
	GCCConferenceID					conference_id;
	GCCConferenceName				conference_name;
	GCCUnicodeString				caller_identifier;			  /* optional */
	TransportAddress				calling_address;			  /* optional */
	TransportAddress				called_address;				  /* optional */
	DomainParameters 		FAR *	domain_parameters;			  /* optional */
	T120Boolean						clear_password_required;
	T120Boolean						conference_is_locked;
	T120Boolean						conference_is_listed;
	T120Boolean						conference_is_conductible;
	GCCTerminationMethod			termination_method;
	GCCConferencePrivileges	FAR *	conductor_privilege_list;	  /* optional */
	GCCConferencePrivileges	FAR *	conducted_mode_privilege_list;/* optional */
	GCCConferencePrivileges	FAR *	non_conducted_privilege_list; /* optional */
	GCCUnicodeString				conference_descriptor;		  /* optional */
	unsigned short					number_of_user_data_members;
	GCCUserData		FAR *	FAR *	user_data_list;				  /* optional */
	ConnectionHandle				connection_handle;
	PhysicalHandle					physical_handle;
} InviteIndicationMessage;

/*
 *	GCC_INVITE_CONFIRM
 *
 *	Union Choice:
 *		InviteConfirmMessage
 *			This is a pointer to a structure that contains all necessary
 *			information about the invite confirm.
 */
typedef struct
{
	GCCConferenceID					conference_id;
	unsigned short					number_of_user_data_members;
	GCCUserData		FAR *	FAR *	user_data_list;				  /* optional */
	GCCResult						result;
	ConnectionHandle				connection_handle;
	PhysicalHandle					physical_handle;
} InviteConfirmMessage;

/*
 *	GCC_ADD_INDICATION
 *
 *	Union Choice:
 *		AddIndicationMessage
 */
typedef struct
{
    GCCResponseTag					add_response_tag;
	GCCConferenceID					conference_id;
	unsigned short					number_of_network_addresses;
	GCCNetworkAddress	FAR * FAR *	network_address_list;
	UserID							requesting_node_id;
	unsigned short					number_of_user_data_members;
	GCCUserData		FAR *	FAR *	user_data_list;				  /* optional */
} AddIndicationMessage;

/*
 *	GCC_ADD_CONFIRM
 *
 *	Union Choice:
 *		AddConfirmMessage
 */
typedef struct
{
	GCCConferenceID					conference_id;
	unsigned short					number_of_network_addresses;
	GCCNetworkAddress	FAR * FAR *	network_address_list;
	unsigned short					number_of_user_data_members;
	GCCUserData		FAR *	FAR *	user_data_list;				  /* optional */
	GCCResult						result;
} AddConfirmMessage;

/*
 *	GCC_LOCK_INDICATION
 *
 *	Union Choice:
 *		LockIndicationMessage
 */
typedef struct
{
	GCCConferenceID				conference_id;
	UserID						requesting_node_id;
} LockIndicationMessage;

/*
 *	GCC_LOCK_CONFIRM
 *
 *	Union Choice:
 *		LockConfirmMessage
 */
typedef struct
{
	GCCConferenceID				conference_id;
	GCCResult					result;
} LockConfirmMessage;

/*
 *	GCC_UNLOCK_INDICATION
 *
 *	Union Choice:
 *		UnlockIndicationMessage
 */
typedef struct
{
	GCCConferenceID				conference_id;
	UserID						requesting_node_id;
} UnlockIndicationMessage;

/*
 *	GCC_UNLOCK_CONFIRM
 *
 *	Union Choice:
 *		UnlockConfirmMessage
 */
typedef struct
{
	GCCConferenceID				conference_id;
	GCCResult					result;
} UnlockConfirmMessage;

/*
 *	GCC_LOCK_REPORT_INDICATION
 *
 *	Union Choice:
 *		LockReportIndicationMessage
 */
typedef struct
{
	GCCConferenceID				conference_id;
	T120Boolean					conference_is_locked;
} LockReportIndicationMessage;

/*
 *	GCC_DISCONNECT_INDICATION
 *
 *	Union Choice:
 *		DisconnectIndicationMessage
 */
typedef struct
{
	GCCConferenceID				conference_id;
	GCCReason					reason;
	UserID						disconnected_node_id;
} DisconnectIndicationMessage;

/*
 *	GCC_DISCONNECT_CONFIRM
 *
 *	Union Choice:
 *		PDisconnectConfirmMessage
 */
typedef struct
{
	GCCConferenceID				conference_id;
	GCCResult					result;
} DisconnectConfirmMessage;

/*
 *	GCC_TERMINATE_INDICATION
 *
 *	Union Choice:
 *		TerminateIndicationMessage
 */
typedef struct
{
	GCCConferenceID				conference_id;
	UserID						requesting_node_id;
	GCCReason					reason;
} TerminateIndicationMessage;

/*
 *	GCC_TERMINATE_CONFIRM
 *
 *	Union Choice:
 *		TerminateConfirmMessage
 */
typedef struct
{
	GCCConferenceID				conference_id;
	GCCResult					result;
} TerminateConfirmMessage;

/*
 *	GCC_CONNECTION_BROKEN_INDICATION
 *
 *	Union Choice:
 *		ConnectionBrokenIndicationMessage
 *
 *	Caveat: 
 *		This is a non-standard indication.
 */
typedef struct
{
	ConnectionHandle			connection_handle;
	PhysicalHandle				physical_handle;
} ConnectionBrokenIndicationMessage;


/*
 *	GCC_EJECT_USER_INDICATION
 *
 *	Union Choice:
 *		EjectUserIndicationMessage
 */
typedef struct
{
	GCCConferenceID				conference_id;
	UserID						ejected_node_id;
	GCCReason					reason;
} EjectUserIndicationMessage;

/*
 *	GCC_EJECT_USER_CONFIRM
 *
 *	Union Choice:
 *		EjectUserConfirmMessage
 */
typedef struct
{
	GCCConferenceID				conference_id;
	UserID						ejected_node_id;
	GCCResult					result;
} EjectUserConfirmMessage;

/*
 *	GCC_TRANSFER_INDICATION
 *
 *	Union Choice:
 *		TransferIndicationMessage
 */
typedef struct
{
	GCCConferenceID				conference_id;
	GCCConferenceName			destination_conference_name;
	GCCNumericString			destination_conference_modifier;  /* optional */
	unsigned short				number_of_destination_addresses;
	GCCNetworkAddress FAR *	FAR *	
								destination_address_list;
	GCCPassword			FAR *	password;						  /* optional */
} TransferIndicationMessage;

/*
 *	GCC_TRANSFER_CONFIRM
 *
 *	Union Choice:
 *		TransferConfirmMessage
 */
typedef struct
{
	GCCConferenceID				conference_id;
	GCCConferenceName			destination_conference_name;
	GCCNumericString			destination_conference_modifier;  /* optional */
	unsigned short				number_of_destination_nodes;
	UserID				FAR *	destination_node_list;
	GCCResult					result;
} TransferConfirmMessage;

/*
 *	GCC_PERMIT_TO_ANNOUNCE_PRESENCE
 *
 *	Union Choice:
 *		PermitToAnnouncePresenceMessage
 */
typedef struct
{
	GCCConferenceID		conference_id;
	UserID				node_id;
} PermitToAnnouncePresenceMessage;

/*
 *	GCC_ANNOUNCE_PRESENCE_CONFIRM
 *
 *	Union Choice:
 *		AnnouncePresenceConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	GCCResult				result;
} AnnouncePresenceConfirmMessage;

/*
 *	GCC_ROSTER_REPORT_INDICATION
 *
 *	Union Choice:
 *		ConfRosterReportIndicationMessage
 */
typedef struct
{
	GCCConferenceID					conference_id;
	GCCConferenceRoster		FAR *	conference_roster;
} ConfRosterReportIndicationMessage;

/*
 *	GCC_CONDUCT_ASSIGN_CONFIRM
 *
 *	Union Choice:
 *		ConductAssignConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	GCCResult				result;
} ConductAssignConfirmMessage;

/*
 *	GCC_CONDUCT_RELEASE_CONFIRM
 *
 *	Union Choice:
 *		ConductorReleaseConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	GCCResult				result;
} ConductReleaseConfirmMessage; 

/*
 *	GCC_CONDUCT_PLEASE_INDICATION
 *
 *	Union Choice:
 *		ConductorPleaseIndicationMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	UserID					requester_node_id;
} ConductPleaseIndicationMessage; 

/*
 *	GCC_CONDUCT_PLEASE_CONFIRM
 *
 *	Union Choice:
 *		ConductPleaseConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	GCCResult				result;
} ConductPleaseConfirmMessage;

/*
 *	GCC_CONDUCT_GIVE_INDICATION
 *
 *	Union Choice:
 *		ConductorGiveIndicationMessage
 */
typedef struct
{	    
	GCCConferenceID			conference_id;
} ConductGiveIndicationMessage;

/*
 *	GCC_CONDUCT_GIVE_CONFIRM
 *
 *	Union Choice:
 *		ConductorGiveConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	UserID					recipient_node_id;
	GCCResult				result;
} ConductGiveConfirmMessage;
 
/*
 *	GCC_CONDUCT_ASK_INDICATION
 *
 *	Union Choice:
 *		ConductPermitAskIndicationMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	T120Boolean				permission_is_granted;
	UserID					requester_node_id;
} ConductPermitAskIndicationMessage; 

/*
 *	GCC_CONDUCT_ASK_CONFIRM
 *
 *	Union Choice:
 *		ConductPermitAskConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	T120Boolean				permission_is_granted;
	GCCResult				result;
} ConductPermitAskConfirmMessage;

/*
 *	GCC_CONDUCT_GRANT_CONFIRM
 *
 *	Union Choice:
 *		ConductPermissionGrantConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	GCCResult				result;
} ConductPermitGrantConfirmMessage;
										
/*
 *	GCC_TIME_REMAINING_INDICATION
 *
 *	Union Choice:
 *		TimeRemainingIndicationMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	unsigned long			time_remaining;
	UserID					node_id;
	UserID					source_node_id;
} TimeRemainingIndicationMessage;

/*
 *	GCC_TIME_REMAINING_CONFIRM
 *
 *	Union Choice:
 *		TimeRemainingConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	GCCResult				result;
} TimeRemainingConfirmMessage;

/*
 *	GCC_TIME_INQUIRE_INDICATION
 *
 *	Union Choice:
 *		TimeInquireIndicationMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	T120Boolean				time_is_conference_wide;
	UserID					requesting_node_id;
} TimeInquireIndicationMessage;

/*
 *	GCC_TIME_INQUIRE_CONFIRM
 *
 *	Union Choice:
 *		TimeInquireConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	GCCResult				result;
} TimeInquireConfirmMessage;

/*
 *	GCC_CONFERENCE_EXTEND_INDICATION
 *
 *	Union Choice:
 *		ConferenceExtendIndicationMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	unsigned long			extension_time;
	T120Boolean				time_is_conference_wide;
	UserID					requesting_node_id;
} ConferenceExtendIndicationMessage;

/*
 *	GCC_CONFERENCE_EXTEND_CONFIRM
 *
 *	Union Choice:
 *		ConferenceExtendConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	unsigned long			extension_time;
	GCCResult				result;
} ConferenceExtendConfirmMessage;

/*
 *	GCC_ASSISTANCE_INDICATION
 *
 *	Union Choice:
 *		ConferenceAssistIndicationMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	unsigned short			number_of_user_data_members;
	GCCUserData FAR * FAR *	user_data_list;
	UserID					source_node_id;
} ConferenceAssistIndicationMessage;

/*
 *	GCC_ASSISTANCE_CONFIRM
 *
 *	Union Choice:
 *		ConferenceAssistConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	GCCResult				result;
} ConferenceAssistConfirmMessage;

/*
 *	GCC_TEXT_MESSAGE_INDICATION
 *
 *	Union Choice:
 *		TextMessageIndicationMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	GCCUnicodeString		text_message;
	UserID					source_node_id;
} TextMessageIndicationMessage;

/*
 *	GCC_TEXT_MESSAGE_CONFIRM
 *
 *	Union Choice:
 *		TextMessageConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	GCCResult				result;
} TextMessageConfirmMessage;

/*
 *	GCC_STATUS_INDICATION
 *
 *	Union Choice:
 *		GCCStatusMessage
 *			This callback is used to relay GCC status to the node controller
 */
typedef	enum
{
	GCC_STATUS_PACKET_RESOURCE_FAILURE	= 0,
	GCC_STATUS_PACKET_LENGTH_EXCEEDED   = 1,
	GCC_STATUS_CTL_SAP_RESOURCE_ERROR	= 2,
	GCC_STATUS_APP_SAP_RESOURCE_ERROR	= 3, /*	parameter = Sap Handle */
	GCC_STATUS_CONF_RESOURCE_ERROR		= 4, /*	parameter = Conference ID */
	GCC_STATUS_INCOMPATIBLE_PROTOCOL	= 5, /*	parameter = Physical Handle */
	GCC_STATUS_JOIN_FAILED_BAD_CONF_NAME= 6, /* parameter = Physical Handle */
	GCC_STATUS_JOIN_FAILED_BAD_CONVENER	= 7, /* parameter = Physical Handle */
	GCC_STATUS_JOIN_FAILED_LOCKED		= 8  /* parameter = Physical Handle */
} GCCStatusMessageType;

typedef struct
{
	GCCStatusMessageType	status_message_type;
	unsigned long			parameter;
} GCCStatusIndicationMessage;

/*
 *	GCC_SUB_INITIALIZED_INDICATION
 *
 *	Union Chice:
 *		SubInitializedIndicationMessage
 */
typedef struct
{
	ConnectionHandle		connection_handle;
	UserID					subordinate_node_id;
} SubInitializedIndicationMessage;


/*********************************************************************
 *																	 *
 *			USER APPLICATION CALLBACK INFO STRUCTURES				 *
 *																	 *
 *********************************************************************/

/*
 *	GCC_PERMIT_TO_ENROLL_INDICATION
 *
 *	Union Choice:
 *		PermitToEnrollIndicationMessage
 */
typedef struct
{
	GCCConferenceID		conference_id;
	GCCConferenceName	conference_name;
	GCCNumericString	conference_modifier;		/* optional */
	T120Boolean			permission_is_granted;
} PermitToEnrollIndicationMessage;

/*
 *	GCC_ENROLL_CONFIRM
 *
 *	Union Choice:
 *		EnrollConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	GCCSessionKey	FAR *	session_key;	
	unsigned short			entity_id;
	UserID					node_id;
	GCCResult				result;
} EnrollConfirmMessage;

/*
 *	GCC_APP_ROSTER_REPORT_INDICATION
 *
 *	Union Choice:
 *		AppRosterReportIndicationMessage
 */
typedef struct
{
	GCCConferenceID							conference_id;
	unsigned short							number_of_rosters;
	GCCApplicationRoster	FAR *	FAR *	application_roster_list;
} AppRosterReportIndicationMessage;

/*
 *	GCC_REGISTER_CHANNEL_CONFIRM
 *
 *	Union Choice:
 *		RegisterChannelConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	GCCRegistryKey			registry_key;
	GCCRegistryItem			registry_item;
	GCCRegistryEntryOwner	entry_owner;
	GCCResult				result;
} RegisterChannelConfirmMessage;

/*
 *	GCC_ASSIGN_TOKEN_CONFIRM
 *
 *	Union Choice:
 *		AssignTokenConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	GCCRegistryKey			registry_key;
	GCCRegistryItem			registry_item;
	GCCRegistryEntryOwner	entry_owner;
	GCCResult				result;
} AssignTokenConfirmMessage;

/*
 *	GCC_SET_PARAMETER_CONFIRM
 *
 *	Union Choice:
 *		SetParameterConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	GCCRegistryKey			registry_key;
	GCCRegistryItem			registry_item;
	GCCRegistryEntryOwner	entry_owner;
	GCCModificationRights	modification_rights;
	GCCResult				result;
} SetParameterConfirmMessage;

/*
 *	GCC_RETRIEVE_ENTRY_CONFIRM
 *
 *	Union Choice:
 *		RetrieveEntryConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	GCCRegistryKey			registry_key;
	GCCRegistryItem			registry_item;
	GCCRegistryEntryOwner	entry_owner;
	GCCModificationRights	modification_rights;
	GCCResult				result;
} RetrieveEntryConfirmMessage;

/*
 *	GCC_DELETE_ENTRY_CONFIRM
 *
 *	Union Choice:
 *		DeleteEntryConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	GCCRegistryKey			registry_key;
	GCCResult				result;
} DeleteEntryConfirmMessage;

/*
 *	GCC_MONITOR_INDICATION
 *
 *	Union Choice:
 *		MonitorIndicationMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	GCCRegistryKey			registry_key;
	GCCRegistryItem			registry_item;
	GCCRegistryEntryOwner	entry_owner;
	GCCModificationRights	modification_rights;
} MonitorIndicationMessage;

/*
 *	GCC_MONITOR_CONFIRM
 *
 *	Union Choice:
 *		MonitorConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	T120Boolean				delivery_is_enabled;
	GCCRegistryKey			registry_key;
	GCCResult				result;
} MonitorConfirmMessage;

/*
 *	GCC_ALLOCATE_HANDLE_CONFIRM
 *
 *	Union Choice:
 *		AllocateHandleConfirmMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	unsigned short			number_of_handles;
	unsigned long			handle_value;
	GCCResult				result;
} AllocateHandleConfirmMessage;


/*********************************************************************
 *																	 *
 *				SHARED CALLBACK INFO STRUCTURES						 *
 *		(Note that this doesn't include all the shared callbacks)    *
 *																	 *
 *********************************************************************/

/*
 *	GCC_ROSTER_INQUIRE_CONFIRM
 *
 *	Union Choice:
 *		ConfRosterInquireConfirmMessage
 */
typedef struct
{
	GCCConferenceID				conference_id;
	GCCConferenceName			conference_name;
	GCCNumericString			conference_modifier;
	GCCUnicodeString			conference_descriptor;
	GCCConferenceRoster	FAR *	conference_roster;
	GCCResult					result;
} ConfRosterInquireConfirmMessage;

/*
 *	GCC_APP_ROSTER_INQUIRE_CONFIRM
 *
 *	Union Choice:
 *		AppRosterInquireConfirmMessage
 */
typedef struct
{
	GCCConferenceID							conference_id;
	unsigned short							number_of_rosters;
	GCCApplicationRoster	FAR *	FAR *	application_roster_list;
	GCCResult								result;
} AppRosterInquireConfirmMessage;

/*
 *	GCC_CONDUCT_INQUIRE_CONFIRM
 *
 *	Union Choice:
 *		ConductorInquireConfirmMessage
 */
typedef struct
{
	GCCConferenceID				conference_id;
	T120Boolean					mode_is_conducted;
	UserID						conductor_node_id;
	T120Boolean					permission_is_granted;
	GCCResult					result;
} ConductInquireConfirmMessage;

/*
 *	GCC_CONDUCT_ASSIGN_INDICATION
 *
 *	Union Choice:
 *		ConductAssignIndicationMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	UserID					node_id;
} ConductAssignIndicationMessage; 

/*
 *	GCC_CONDUCT_RELEASE_INDICATION
 *
 *	Union Choice:
 *		ConductReleaseIndicationMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
} ConductReleaseIndicationMessage;

/*
 *	GCC_CONDUCT_GRANT_INDICATION
 *
 *	Union Choice:
 *		ConductPermitGrantIndicationMessage
 */
typedef struct
{
	GCCConferenceID			conference_id;
	unsigned short			number_granted;
	UserID			FAR *	granted_node_list;
	unsigned short			number_waiting;
	UserID			FAR *	waiting_node_list;
	T120Boolean				permission_is_granted;
} ConductPermitGrantIndicationMessage; 

/*
 *	GCC_APPLICATION_INVOKE_INDICATION
 *
 *	Union Choice:
 *		ApplicationInvokeIndicationMessage
 */
typedef struct
{
	GCCConferenceID						conference_id;
	unsigned short						number_of_app_protocol_entities;
	GCCAppProtocolEntity FAR * FAR *	app_protocol_entity_list;
	UserID								invoking_node_id;
} ApplicationInvokeIndicationMessage;

/*
 *	GCC_APPLICATION_INVOKE_CONFIRM
 *
 *	Union Choice:
 *		ApplicationInvokeConfirmMessage
 */
typedef struct
{
	GCCConferenceID						conference_id;
	unsigned short						number_of_app_protocol_entities;
	GCCAppProtocolEntity FAR * FAR *	app_protocol_entity_list;
	GCCResult							result;
} ApplicationInvokeConfirmMessage;

 

/*
 *	GCCMessage
 *		This structure defines the message that is passed from GCC to either
 *		the node controller or a user application when an indication or
 *		confirm occurs.
 */

typedef	struct
{
	GCCMessageType		message_type;
	void	FAR		*	user_defined;

	union
	{
		CreateIndicationMessage				create_indication;
		CreateConfirmMessage				create_confirm;
		QueryIndicationMessage				query_indication;
		QueryConfirmMessage					query_confirm;
		JoinIndicationMessage				join_indication;
		JoinConfirmMessage					join_confirm;
		InviteIndicationMessage				invite_indication;
		InviteConfirmMessage				invite_confirm;
		AddIndicationMessage				add_indication;
		AddConfirmMessage					add_confirm;
		LockIndicationMessage				lock_indication;
		LockConfirmMessage					lock_confirm;
		UnlockIndicationMessage				unlock_indication;
		UnlockConfirmMessage				unlock_confirm;
		LockReportIndicationMessage			lock_report_indication;
		DisconnectIndicationMessage			disconnect_indication;
		DisconnectConfirmMessage			disconnect_confirm;
		TerminateIndicationMessage			terminate_indication;
		TerminateConfirmMessage				terminate_confirm;
		ConnectionBrokenIndicationMessage	connection_broken_indication;
		EjectUserIndicationMessage			eject_user_indication;	
		EjectUserConfirmMessage				eject_user_confirm;
		TransferIndicationMessage			transfer_indication;
		TransferConfirmMessage				transfer_confirm;
		ApplicationInvokeIndicationMessage	application_invoke_indication;
		ApplicationInvokeConfirmMessage		application_invoke_confirm;
		SubInitializedIndicationMessage		conf_sub_initialized_indication;
		PermitToAnnouncePresenceMessage		permit_to_announce_presence;
		AnnouncePresenceConfirmMessage		announce_presence_confirm;
		ConfRosterReportIndicationMessage	conf_roster_report_indication;
		ConductAssignIndicationMessage		conduct_assign_indication; 
		ConductAssignConfirmMessage			conduct_assign_confirm;
		ConductReleaseIndicationMessage		conduct_release_indication; 
		ConductReleaseConfirmMessage		conduct_release_confirm; 
		ConductPleaseIndicationMessage		conduct_please_indication;
		ConductPleaseConfirmMessage			conduct_please_confirm;
		ConductGiveIndicationMessage		conduct_give_indication;
		ConductGiveConfirmMessage			conduct_give_confirm;
		ConductPermitAskIndicationMessage	conduct_permit_ask_indication; 
		ConductPermitAskConfirmMessage		conduct_permit_ask_confirm;
		ConductPermitGrantIndicationMessage	conduct_permit_grant_indication; 
		ConductPermitGrantConfirmMessage	conduct_permit_grant_confirm;
		ConductInquireConfirmMessage		conduct_inquire_confirm;
		TimeRemainingIndicationMessage		time_remaining_indication;
		TimeRemainingConfirmMessage			time_remaining_confirm;
		TimeInquireIndicationMessage		time_inquire_indication;
		TimeInquireConfirmMessage			time_inquire_confirm;
		ConferenceExtendIndicationMessage	conference_extend_indication;
		ConferenceExtendConfirmMessage		conference_extend_confirm;
		ConferenceAssistIndicationMessage	conference_assist_indication;
		ConferenceAssistConfirmMessage		conference_assist_confirm;
		TextMessageIndicationMessage		text_message_indication;
		TextMessageConfirmMessage			text_message_confirm;
		GCCStatusIndicationMessage			status_indication;
		PermitToEnrollIndicationMessage		permit_to_enroll_indication;
		EnrollConfirmMessage				enroll_confirm;
		AppRosterReportIndicationMessage	app_roster_report_indication;
		RegisterChannelConfirmMessage		register_channel_confirm;
		AssignTokenConfirmMessage			assign_token_confirm;
		SetParameterConfirmMessage			set_parameter_confirm;
		RetrieveEntryConfirmMessage			retrieve_entry_confirm;
		DeleteEntryConfirmMessage			delete_entry_confirm;
		MonitorIndicationMessage			monitor_indication;
		MonitorConfirmMessage				monitor_confirm;
		AllocateHandleConfirmMessage		allocate_handle_confirm;
		ConfRosterInquireConfirmMessage		conf_roster_inquire_confirm;
		AppRosterInquireConfirmMessage		app_roster_inquire_confirm;
		TransportStatus						transport_status;
	} u;
} GCCMessage;

/* 
 *	This is the definition for the GCC callback function. Applications
 *	writing callback routines should NOT use the typedef to define their
 *	functions.  These should be explicitly defined the way that the 
 *	typedef is defined.
 */
#define		GCC_CALLBACK_NOT_PROCESSED		0
#define		GCC_CALLBACK_PROCESSED			1
typedef	T120Boolean (CALLBACK *GCCCallBack) (GCCMessage FAR * gcc_message); 


/****************	GCC ENTRY POINTS  *******************************/
		
/*********************************************************************
 *																	 *
 *				NODE CONTROLLER ENTRY POINTS						 *
 *																	 *
 *********************************************************************/

/*
 *	These entry points are implementation specific primitives, that
 *	do not directly correspond to primitives defined in T.124.
 */
GCCError APIENTRY	GCCRegisterNodeControllerApplication (
								GCCCallBack				control_sap_callback,
								void FAR *				user_defined,
								GCCVersion				gcc_version_requested,
								unsigned short	FAR *	initialization_flags,
								unsigned long	FAR *	application_id,
								unsigned short	FAR *	capabilities_mask,
								GCCVersion		FAR	*	gcc_high_version,
								GCCVersion		FAR	*	gcc_version);
								
GCCError APIENTRY	GCCRegisterUserApplication (
								unsigned short	FAR *	initialization_flags,
								unsigned long	FAR *	application_id,
								unsigned short	FAR *	capabilities_mask,
								GCCVersion		FAR	*	gcc_version);

GCCError APIENTRY	GCCCleanup (
								unsigned long 			application_id);

GCCError APIENTRY	GCCHeartbeat (void);

GCCError APIENTRY	GCCCreateSap(
								GCCCallBack			user_defined_callback,
								void FAR *			user_defined,
								GCCSapHandle FAR *	application_sap_handle);

GCCError APIENTRY	GCCDeleteSap(
								GCCSapHandle		sap_handle);
								
GCCError APIENTRY	GCCLoadTransport (
								char FAR *			transport_identifier,
								char FAR *			transport_file_name);

GCCError APIENTRY	GCCUnloadTransport (
								char FAR *			transport_identifier);

GCCError APIENTRY	GCCResetDevice (
								char FAR *			transport_identifier,
								char FAR *			device_identifier);

/*
 *	These entry points are specific primitives that directly correspond 
 *	to primitives defined in T.124.
 *
 *	Note that an attempt was made in the prototypes to define the optional 
 *	parameters as pointers wherever possible.
 */

/**********	Conference Establishment and Termination Functions ***********/						
GCCError APIENTRY	GCCConferenceCreateRequest 	
					(
					GCCConferenceName		FAR *	conference_name,
					GCCNumericString				conference_modifier,
					GCCPassword				FAR *	convener_password,
					GCCPassword				FAR *	password,
					T120Boolean						use_password_in_the_clear,
					T120Boolean						conference_is_locked,
					T120Boolean						conference_is_listed,
					T120Boolean						conference_is_conductible,
					GCCTerminationMethod			termination_method,
					GCCConferencePrivileges	FAR *	conduct_privilege_list,
					GCCConferencePrivileges	FAR *	
												conducted_mode_privilege_list,
					GCCConferencePrivileges	FAR *	
												non_conducted_privilege_list,
					GCCUnicodeString				conference_descriptor,
					GCCUnicodeString				caller_identifier,
					TransportAddress				calling_address,
					TransportAddress				called_address,
					DomainParameters 		FAR *	domain_parameters,
					unsigned short					number_of_network_addresses,
					GCCNetworkAddress FAR *	FAR *	local_network_address_list,
					unsigned short				   	number_of_user_data_members,
					GCCUserData		FAR *	FAR *	user_data_list,
					ConnectionHandle		FAR *	connection_handle
					);
								
GCCError APIENTRY	GCCConferenceCreateResponse
					(
					GCCNumericString				conference_modifier,
					GCCConferenceID					conference_id,
					T120Boolean						use_password_in_the_clear,
					DomainParameters 		FAR *	domain_parameters,
					unsigned short					number_of_network_addresses,
					GCCNetworkAddress FAR *	FAR *	local_network_address_list,
					unsigned short				   	number_of_user_data_members,
					GCCUserData		FAR *	FAR *	user_data_list,
					GCCResult						result
					);
					
GCCError APIENTRY	GCCConferenceQueryRequest 
					(
					GCCNodeType						node_type,
					GCCAsymmetryIndicator	FAR *	asymmetry_indicator,
					TransportAddress				calling_address,
					TransportAddress				called_address,
					unsigned short				   	number_of_user_data_members,
					GCCUserData		FAR *	FAR *	user_data_list,
					ConnectionHandle		FAR *	connection_handle
					);
								
GCCError APIENTRY	GCCConferenceQueryResponse
					(
					GCCResponseTag					query_response_tag,
					GCCNodeType						node_type,
					GCCAsymmetryIndicator	FAR *	asymmetry_indicator,
					unsigned short				   	number_of_user_data_members,
					GCCUserData		FAR *	FAR *	user_data_list,
					GCCResult						result
					);

GCCError APIENTRY	GCCConferenceJoinRequest
					(
					GCCConferenceName		FAR *	conference_name,
					GCCNumericString				called_node_modifier,
					GCCNumericString				calling_node_modifier,
					GCCPassword				FAR *	convener_password,
					GCCChallengeRequestResponse	
											FAR	*	password_challenge,
					GCCUnicodeString				caller_identifier,
					TransportAddress				calling_address,
					TransportAddress				called_address,
					DomainParameters 		FAR *	domain_parameters,
					unsigned short					number_of_network_addresses,
					GCCNetworkAddress FAR * FAR *	local_network_address_list,
					unsigned short				   	number_of_user_data_members,
					GCCUserData		FAR *	FAR *	user_data_list,
					ConnectionHandle		FAR *	connection_handle
					);
					
GCCError APIENTRY	GCCConferenceJoinResponse
					(
					GCCResponseTag					join_response_tag,
					GCCChallengeRequestResponse	
											FAR	*	password_challenge,
					unsigned short				   	number_of_user_data_members,
					GCCUserData		FAR *	FAR *	user_data_list,
					GCCResult						result
					);

GCCError APIENTRY	GCCConferenceInviteRequest
					(
					GCCConferenceID					conference_id,
					GCCUnicodeString				caller_identifier,
					TransportAddress				calling_address,
					TransportAddress				called_address,
					unsigned short				   	number_of_user_data_members,
					GCCUserData		FAR *	FAR *	user_data_list,
					ConnectionHandle		FAR *	connection_handle
					);

GCCError APIENTRY	GCCConferenceInviteResponse
					(
					GCCConferenceID					conference_id,
					GCCNumericString				conference_modifier,
					DomainParameters 		FAR *	domain_parameters,
					unsigned short					number_of_network_addresses,
					GCCNetworkAddress FAR *	FAR *	local_network_address_list,
					unsigned short				   	number_of_user_data_members,
					GCCUserData		FAR *	FAR *	user_data_list,
					GCCResult						result
					);

GCCError APIENTRY	GCCConferenceAddRequest
					(
					GCCConferenceID					conference_id,
					unsigned short					number_of_network_addresses,
					GCCNetworkAddress FAR *	FAR *	network_address_list,
					UserID							adding_node,
					unsigned short				   	number_of_user_data_members,
					GCCUserData		FAR *	FAR *	user_data_list
					);

GCCError APIENTRY	GCCConferenceAddResponse
					(
					GCCResponseTag					add_response_tag,
					GCCConferenceID					conference_id,
					UserID							requesting_node,
					unsigned short				   	number_of_user_data_members,
					GCCUserData		FAR *	FAR *	user_data_list,
					GCCResult						result
					);

GCCError APIENTRY	GCCConferenceLockRequest
					(
					GCCConferenceID					conference_id
					);
						
GCCError APIENTRY	GCCConferenceLockResponse
					(
					GCCConferenceID					conference_id,
					UserID							requesting_node,
					GCCResult						result
					);

GCCError APIENTRY	GCCConferenceUnlockRequest
					(
					GCCConferenceID					conference_id
					);						             
						
GCCError APIENTRY	GCCConferenceUnlockResponse
					(
					GCCConferenceID					conference_id,
					UserID							requesting_node,
					GCCResult						result
					);

GCCError APIENTRY	GCCConferenceDisconnectRequest
					(
					GCCConferenceID					conference_id
					);

GCCError APIENTRY	GCCConferenceTerminateRequest
					(
					GCCConferenceID					conference_id,
					GCCReason						reason
					);

GCCError APIENTRY	GCCConferenceEjectUserRequest
					(
					GCCConferenceID					conference_id,
					UserID							ejected_node_id,
					GCCReason						reason
					);
						
GCCError APIENTRY	GCCConferenceTransferRequest
					(
					GCCConferenceID				conference_id,
					GCCConferenceName	FAR *	destination_conference_name,
					GCCNumericString			destination_conference_modifier,
					unsigned short				number_of_destination_addresses,
					GCCNetworkAddress FAR *	FAR *
												destination_address_list,
					unsigned short				number_of_destination_nodes,
					UserID				FAR *	destination_node_list,
					GCCPassword			FAR *	password
					);
						
/**********	Conference Roster Functions ***********/						
GCCError APIENTRY	GCCAnnouncePresenceRequest
					(
					GCCConferenceID					conference_id,
					GCCNodeType						node_type,
					GCCNodeProperties				node_properties,
					GCCUnicodeString				node_name,
					unsigned short					number_of_participants,
					GCCUnicodeString		FAR *	participant_name_list,
					GCCUnicodeString				site_information,
					unsigned short					number_of_network_addresses,
					GCCNetworkAddress FAR *	FAR *	network_address_list,
					GCCOctetString			FAR *	alternative_node_id,
					unsigned short				   	number_of_user_data_members,
					GCCUserData		FAR *	FAR *	user_data_list
					);
						
/**********	Conductorship Functions ***********/						
GCCError APIENTRY	GCCConductorAssignRequest
					(
					GCCConferenceID					conference_id
					);
							
GCCError APIENTRY	GCCConductorReleaseRequest
					(
					GCCConferenceID					conference_id
					);
							
GCCError APIENTRY	GCCConductorPleaseRequest
					(
					GCCConferenceID					conference_id
					);
							
GCCError APIENTRY	GCCConductorGiveRequest
					(
					GCCConferenceID					conference_id,
					UserID							recipient_node_id
					);

GCCError APIENTRY	GCCConductorGiveResponse
					(
					GCCConferenceID					conference_id,
					GCCResult						result
					);

GCCError APIENTRY	GCCConductorPermitGrantRequest
					(
					GCCConferenceID					conference_id,
					unsigned short					number_granted,
					UserID					FAR *	granted_node_list,
					unsigned short					number_waiting,
					UserID					FAR *	waiting_node_list
					);
						
/**********	Miscellaneous Functions ***********/						
GCCError APIENTRY	GCCConferenceTimeRemainingRequest
					(
					GCCConferenceID					conference_id,
					unsigned long					time_remaining,
					UserID							node_id
					);

GCCError APIENTRY	GCCConferenceTimeInquireRequest
					(
					GCCConferenceID					conference_id,
					T120Boolean						time_is_conference_wide
					);

GCCError APIENTRY	GCCConferenceExtendRequest
					(
					GCCConferenceID					conference_id,
					unsigned long					extension_time,
					T120Boolean						time_is_conference_wide
					);

GCCError APIENTRY	GCCConferenceAssistanceRequest
					(
					GCCConferenceID					conference_id,
					unsigned short				   	number_of_user_data_members,
					GCCUserData		FAR *	FAR *	user_data_list
					);

GCCError APIENTRY	GCCTextMessageRequest
					(
					GCCConferenceID					conference_id,
					GCCUnicodeString				text_message,
					UserID							destination_node
					);


/*********************************************************************
 *																	 *
 *				USER APPLICATION ENTRY POINTS						 *
 *																	 *
 *********************************************************************/

/*	Application Roster related function calls */
GCCError APIENTRY	GCCApplicationEnrollRequest
					(
					GCCSapHandle				sap_handle,
					GCCConferenceID				conference_id,
					GCCSessionKey	FAR *		session_key,
					T120Boolean					enroll_actively,
					UserID						application_user_id,
					T120Boolean					is_conducting_capable,
					MCSChannelType				startup_channel_type,
					unsigned short				number_of_non_collapsed_caps,
					GCCNonCollapsingCapability	FAR * FAR *	
													non_collapsed_caps_list,		
					unsigned short				number_of_collapsed_caps,
					GCCApplicationCapability	FAR * FAR *	
													collapsed_caps_list,		
					T120Boolean					application_is_enrolled
					);

/*	Application Registry related function calls */
GCCError APIENTRY	GCCRegisterChannelRequest
					(
					GCCSapHandle				sap_handle,
					GCCConferenceID				conference_id,
					GCCRegistryKey		FAR *	registry_key,
					ChannelID					channel_id
					);

GCCError APIENTRY  GCCRegistryAssignTokenRequest
					(
					GCCSapHandle				sap_handle,
					GCCConferenceID				conference_id,
					GCCRegistryKey		FAR *	registry_key
					);

GCCError APIENTRY  GCCRegistrySetParameterRequest
					(
					GCCSapHandle				sap_handle,
					GCCConferenceID				conference_id,
					GCCRegistryKey		FAR *	registry_key,
					GCCOctetString		FAR *	parameter_value,
					GCCModificationRights		modification_rights
					);

GCCError APIENTRY	GCCRegistryRetrieveEntryRequest
					(
					GCCSapHandle				sap_handle,
					GCCConferenceID				conference_id,
					GCCRegistryKey		FAR *	registry_key
					);

GCCError APIENTRY	GCCRegistryDeleteEntryRequest
					(
					GCCSapHandle				sap_handle,
					GCCConferenceID				conference_id,
					GCCRegistryKey		FAR *	registry_key
					);

GCCError APIENTRY	GCCRegistryMonitorRequest
					(
					GCCSapHandle				sap_handle,
					GCCConferenceID				conference_id,
					T120Boolean					enable_delivery,
					GCCRegistryKey		FAR *	registry_key
					);

GCCError APIENTRY	GCCRegistryAllocateHandleRequest
					(
					GCCSapHandle				sap_handle,
					GCCConferenceID				conference_id,
					unsigned short				number_of_handles
					);


/*********************************************************************
 *																	 *
 *				SHARED ENTRY POINTS						     		 *
 *																	 *
 *********************************************************************/

/*	Use Zero for the SapHandle if your are the Node Controller */
GCCError APIENTRY	GCCConferenceRosterInqRequest
					(
					GCCSapHandle				sap_handle,
					GCCConferenceID				conference_id
					);

GCCError APIENTRY	GCCApplicationRosterInqRequest
					(
					GCCSapHandle				sap_handle,
					GCCConferenceID				conference_id,
					GCCSessionKey	FAR *		session_key
					);

GCCError APIENTRY	GCCConductorInquireRequest
					(
					GCCSapHandle				sap_handle,
					GCCConferenceID				conference_id
					);

GCCError APIENTRY	GCCApplicationInvokeRequest
					(
					GCCSapHandle				sap_handle,
					GCCConferenceID				conference_id,
					unsigned short				number_of_app_protocol_entities,
					GCCAppProtocolEntity FAR * FAR *
												app_protocol_entity_list,
					unsigned short				number_of_destination_nodes,
					UserID				FAR *	list_of_destination_nodes
					);
							
GCCError APIENTRY	GCCConductorPermitAskRequest
					(
					GCCSapHandle				sap_handle,
					GCCConferenceID				conference_id,
					T120Boolean					permission_is_granted
					);
							
GCCError APIENTRY	GCCGetLocalAddress
					(
					GCCConferenceID					conference_id,
					ConnectionHandle				connection_handle,
					TransportAddress				transport_identifier,
					int	*							transport_identifier_length,
					TransportAddress				local_address,
					int	*							local_address_length
					);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\inc\wraputl.h ===
//
// uwrap.h
//
// Public interface to unicode wrappers for Win32 API
//
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//
//

#ifndef _wraputl_h_
#define _wraputl_h_
//Don't wrap on WIN64 as there is no Win9x (thankfully).
#if defined(UNICODE) && !defined(_WIN64)

//Top level unicode wrapper class
extern BOOL g_bRunningOnNT;
class CUnicodeWrapper
{
public:
    CUnicodeWrapper();
    ~CUnicodeWrapper();

    BOOL InitializeWrappers();
    BOOL CleanupWrappers();
};


#endif //defined(UNICODE) && !defined(_WIN64)
#endif //_uwrap_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\asn1\asn1.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    asn1.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Frederick Chong - June. 23rd 1998

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES = \
    $(C_DEFINES) \
    $(CLIENT_EXE_CDEFS)

#
# List of sources
#


CLIENT_SOURCES_RC = \

SOURCES_PLATFORM =
    

CLIENT_SOURCES_COMMON = \
    asncnstr.cpp \
    asnobjct.cpp \
    asnof.cpp \
    asnprimt.cpp \
    asntext.cpp \
    asnutils.cpp 
    

CLIENT_SOURCES_LAST  = \
    msasnlib.cpp

SOURCES = \
    $(CLIENT_SOURCES_RC) \
    $(SOURCES_PLATFORM) \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_LAST)

#
# Precompiled specs
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\inc\mcs.h ===
/* (C) 1996-1997 Microsoft Corp.
 *
 * file   : MCS.h
 * author : Erik Mavrinac
 *
 * description: User mode MCS node controller and user attachment interface
 *   definitions, defined in addition to the common interface functions
 *   defined in MCSCommn.h.
 */

#ifndef __MCS_H
#define __MCS_H


#include "MCSCommn.h"



/*
 *  Exported API Routines
 */

#ifdef __cplusplus
extern "C" {
#endif



// User-mode-only entry points.

MCSError APIENTRY MCSInitialize(MCSNodeControllerCallback NCCallback);

MCSError APIENTRY MCSCleanup(void);

MCSError APIENTRY MCSCreateDomain(
        HANDLE       hIca,
        HANDLE       hIcaStack,
        void         *pContext,
        DomainHandle *phDomain);

MCSError APIENTRY MCSDeleteDomain(
        HANDLE       hIca,
        DomainHandle hDomain,
        MCSReason    Reason);

MCSError APIENTRY MCSGetBufferRequest(
        UserHandle hUser,
        unsigned   Size,
        void       **ppBuffer);

MCSError APIENTRY MCSFreeBufferRequest(
        UserHandle hUser,
        void       *pBuffer);


// These functions mirror T.122 primitives.

MCSError APIENTRY MCSConnectProviderRequest(
        DomainSelector    CallingDomain,
        unsigned          CallingLength,
        DomainSelector    CalledDomain,
        unsigned          CalledLength,
        BOOL              bUpwardConnection,
        PDomainParameters pDomainParams,
        BYTE              *pUserData,
        unsigned          UserDataLength,
        DomainHandle      *phDomain,
        ConnectionHandle  *phConn);

MCSError APIENTRY MCSConnectProviderResponse(
        ConnectionHandle hConn,
        MCSResult        Result,
        BYTE             *pUserData,
        unsigned         UserDataLength);

MCSError APIENTRY MCSDisconnectProviderRequest(
        HANDLE           hIca,
        ConnectionHandle hConn,
        MCSReason        Reason);

MCSError APIENTRY MCSSendDataRequest(
        UserHandle      hUser,
        DataRequestType RequestType,
        ChannelHandle   hChannel,
        ChannelID       ChannelID,
        MCSPriority     Priority,
        Segmentation    Segmentation,
        BYTE            *pData,
        unsigned        DataLength);


// These are not implemented and may be common to kernel and user
// modes but will stay here for now. There are stubs in user mode.
MCSError APIENTRY MCSChannelConveneRequest(
        UserHandle hUser);

MCSError APIENTRY MCSChannelDisbandRequest(
        UserHandle hUser,
        ChannelID  ChannelID);

MCSError APIENTRY MCSChannelAdmitRequest(
        UserHandle hUser,
        ChannelID  ChannelID,
        UserID     *UserIDList,
        unsigned   UserIDCount);

MCSError APIENTRY MCSChannelExpelRequest(
        UserHandle hUser,
        ChannelID  ChannelID,
        UserID     *UserIDList,
        unsigned   UserIDCount);

MCSError APIENTRY MCSTokenGrabRequest(
        UserHandle hUser,
        TokenID    TokenID);

MCSError APIENTRY MCSTokenInhibitRequest(
        UserHandle hUser,
        TokenID    TokenID);

MCSError APIENTRY MCSTokenGiveRequest(
        UserHandle hUser,
        TokenID    TokenID,
        UserID     ReceiverID);

MCSError APIENTRY MCSTokenGiveResponse(
        UserHandle hUser,
        TokenID    TokenID,
        MCSResult  Result);

MCSError APIENTRY MCSTokenPleaseRequest(
        UserHandle hUser,
        TokenID    TokenID);

MCSError APIENTRY MCSTokenReleaseRequest(
        UserHandle hUser,
        TokenID    TokenID);

MCSError APIENTRY MCSTokenTestRequest(
        UserHandle hUser,
        TokenID    TokenID);



#ifdef __cplusplus
}  // End extern "C" block.
#endif



#endif  // !defined(__MCS_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\asn1\asncnstr.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asncnstr

Abstract:

    This module provides the implementation of the ASN.1 Constructed Object base
    class.

Author:

    Doug Barlow (dbarlow) 10/8/1995

Environment:

    Win32

Notes:



--*/

#include <windows.h>
#include "asnPriv.h"


//
//==============================================================================
//
//  CAsnConstructed
//

IMPLEMENT_NEW(CAsnConstructed)


/*++

CAsnConstructed:

    This is the construction routine for a CAsnConstructed.

Arguments:

    dwType is the type of the object.

    dwFlags supplies any special flags for this object.  Options are:

        fOptional implies the object is optional.
        fDelete implies the object should be deleted when its parent destructs.

    dwTag is the tag of the object.  If this is zero, the tag is taken from the
        type.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CAsnConstructed::CAsnConstructed(
    IN DWORD dwFlags,
    IN DWORD dwTag,
    IN DWORD dwType)
:   CAsnObject(dwFlags | fConstructed, dwTag, dwType)
{ /* Just make sure it's constructed. */ }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\inc\serverenum.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

    #define API_FUNCTION API_RET_TYPE far pascal

#pragma pack(1)

 struct server_info_1 {
     char	    sv1_name[CNLEN + 1];
     unsigned char   sv1_version_major;		/* Major version # of net   */
     unsigned char   sv1_version_minor;		/* Minor version # of net   */
     unsigned long   sv1_type;	     		/* Server type 		    */
     char far *	    sv1_comment; 		/* Exported server comment  */
 };	 /* server_info_1 */

 struct wksta_info_10 {
    char far *	    wki10_computername;
    char far *	    wki10_username;
    char far *	    wki10_langroup;
    unsigned char   wki10_ver_major;
    unsigned char   wki10_ver_minor;
    char far *	    wki10_logon_domain;
    char far *	    wki10_oth_domains;
};	/* wksta_info_10 */

#pragma pack()


 extern API_FUNCTION
   NetServerEnum2 ( const char far *     pszServer,
                    short                sLevel,
                    char far *           pbBuffer,
                    unsigned short       cbBuffer,
                    unsigned short far * pcEntriesRead,
                    unsigned short far * pcTotalAvail,
                    unsigned long        flServerType,
                    char far *           pszDomain );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\inc\tarray.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _TARRAY_H
#define _TARRAY_H
template< class T > class CArrayT
{
    T *m_pT;

    int m_nMaxSize;

    int m_idx;                  //current array pos

public:
    
//------------------------------------------------------------------------
    CArrayT( )
    {
        m_pT = NULL;

        m_nMaxSize = 0;

        m_idx = 0;
    }
//------------------------------------------------------------------------
// destroy the list
    ~CArrayT( )
    {
        if( m_pT != NULL )
        {
            delete[] m_pT;
        }
    }
//------------------------------------------------------------------------
// increases array size,  returns zero if the operation failed
    int GrowBy( int iSize )
    {
        if( iSize == 0 )
        {
            //
            //Grow by # number of items
            //
            iSize = 4;

        }

        if( m_pT == NULL )
        {
            m_pT = ( T * )new T[ iSize ];

            if( m_pT == NULL )
            {
                return 0;
            }

            m_nMaxSize = iSize;

            m_idx = 0;
        }
        else
        {
            T *pT;

            int nNewMaxSize = m_nMaxSize + iSize;

            pT = ( T * )new T[ nNewMaxSize ];

            if( pT == NULL )
            {
                return 0;
            }

            m_nMaxSize = nNewMaxSize;

            ZeroMemory( ( PVOID )pT , sizeof( T ) * m_nMaxSize );

            CopyMemory( pT , m_pT , sizeof( T ) * ( m_idx ) );

            if( m_pT != NULL )
            {
                delete[] m_pT;
            }

            m_pT = pT;
        }
    

        return m_nMaxSize;
    }
//------------------------------------------------------------------------
// Simply put, increase the array size if empty, and place item at the
// end of the list
    int Insert( T tItem )
    {
        if( m_pT == NULL || ( m_idx ) >= m_nMaxSize )
        {
            if( GrowBy( 0 ) == 0 )
            {
                return 0;
            }
        }


        m_pT[ m_idx ] = tItem;

        m_idx++;

        return m_idx;
    }

//------------------------------------------------------------------------
// exposes the array for direct reference
   T* ExposeArray(  )
   {
        if( m_pT != NULL )
        {
            return &m_pT[0];
        }

        return NULL;
    }
//------------------------------------------------------------------------
// Returns the number of valid entries in the array
    int GetSize( ) const
    {
        return ( m_idx );
    }

//------------------------------------------------------------------------
// Returns an item in the array, or null if not with in range
    T* GetAt( int idx ) 
    {
        if( idx < 0 || idx >= m_idx )
        {            
            return NULL;
        }

        return &m_pT[ idx ];
    }

//------------------------------------------------------------------------
// Assigns a value in the array
    int SetAt( int idx , T tItem )
    {
        if( idx < 0 || idx >= m_idx )
        {
            return -1;
        }

        m_pT[ idx ] = tItem;

        return idx;
    }

//------------------------------------------------------------------------
// Finds an item in the array ( incase one forgot the index )

    int FindItem( T tItem , BOOL& bFound )
    {
        bFound = FALSE;

        int idx = 0;

        while( idx < m_idx )
        {
            if( m_pT[ idx ] == tItem )
            {
                bFound = TRUE;
                break;
            }

            idx++;
        }

        return idx;
    }

//------------------------------------------------------------------------
// Deletes an item from the array

    int DeleteItemAt( int idx )
    {
        if( 0 > idx || idx >= m_idx )
        {
            return 0;
        }
        
        if( idx == m_idx - 1 )  //delete last item
        {
            m_idx--;
            
            return -1;
        }

        void *pvDest    =   &m_pT[ idx ];
        
        void *pvSrc     =   &m_pT[ idx + 1 ];    
        
        ULONG ulDistance =  (ULONG)( ( BYTE *)&m_pT[ m_nMaxSize - 1 ] - ( BYTE * )pvSrc ) + sizeof( T );

        if( ulDistance != 0 )
        {
            MoveMemory( pvDest , pvSrc , ulDistance );
            
            // Adjust the array status
            
            m_idx--;
        
            m_nMaxSize--;
        }


        return ulDistance;
    }
     


//------------------------------------------------------------------------
// Deletes the array of items
    int DeleteArray( )
    {
        if( m_pT != NULL )
        {
            delete[] m_pT;
        }

        m_pT = NULL;

        m_nMaxSize = 0;

        m_idx = 0;

        return 0;
    }


};

#endif //_TARRAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\inc\uwrap2.h ===
//
// uwrap2.h
//
// Phase2 Unicode wrappers for Win32 API
// (included after ATL headers are processed)
//
// Inlucde this header to redirect any W calls
// to wrappers that dynamically convert to ANSI
// and call the A versions on non-unicode platforms
//
// Unlike the shlwapi wrappers which create a DLL
// of wrapper functions, the ts uniwrappers work
// by redefining functions to call into our wrapped
// versions.
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//
//

#ifndef _uwrap2_h_
#define _uwrap2_h_
//Don't wrap on WIN64 as there is no Win9x (thankfully).
#if defined(UNICODE) && !defined(_WIN64)

//Group replacement wraps by module
//these were autogenerated by genwrap.pl

//Define this to avoid replacing, i.e just
//include the wrap function definitions.
//Need to do this in the implementation class.


// this is a hack around ATL problems:
// Wrap in two phases, second phase
// wrap is after including ATL headers
// that have member function names that conflict
// with win32 APIs.
//

#ifndef DONOT_REPLACE_WITH_WRAPPERS

#ifdef  GetClassInfo
#undef  GetClassInfo
#endif
#define GetClassInfo GetClassInfoWrapW

#ifdef  TranslateAccelerator
#undef  TranslateAccelerator
#endif
#define TranslateAccelerator TranslateAcceleratorWrapW

#ifdef  StrRetToStr
#undef  StrRetToStr
#endif
#define StrRetToStr  StrRetToStrWrapW


#endif //DONOT_REPLACE_WITH_WRAPPERS
#endif //defined(UNICODE) && !defined(_WIN64)
#endif //_uwrap2_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\inc\uwrap.h ===
//
// uwrap.h
//
// Unicode wrappers for Win32 API
//
// Inlucde this header to redirect any W calls
// to wrappers that dynamically convert to ANSI
// and call the A versions on non-unicode platforms
//
// Unlike the shlwapi wrappers which create a DLL
// of wrapper functions, the ts uniwrappers work
// by redefining functions to call into our wrapped
// versions.
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//
//

#ifndef _uwrap_h_
#define _uwrap_h_

//Do not wrap on WIN64
#if defined(UNICODE) && !defined(_WIN64)

#include "shlobj.h"
#include "winspool.h"
#include "commdlg.h"
#include "shellapi.h"
#include "winnls32.h"

//Group replacement wraps by module
//these were autogenerated by genwrap.pl

//Define this to avoid replacing, i.e just
//include the wrap function definitions.
//Need to do this in the implementation class.
#ifndef DONOT_REPLACE_WITH_WRAPPERS

//
// ADVAPI32.dll
#ifdef  RegEnumKey
#undef  RegEnumKey
#endif
#define RegEnumKey RegEnumKeyWrapW

#ifdef  RegOpenKeyEx
#undef  RegOpenKeyEx
#endif
#define RegOpenKeyEx RegOpenKeyExWrapW

#ifdef  RegEnumValue
#undef  RegEnumValue
#endif
#define RegEnumValue RegEnumValueWrapW

#ifdef  RegEnumKeyEx
#undef  RegEnumKeyEx
#endif
#define RegEnumKeyEx RegEnumKeyExWrapW

#ifdef  RegDeleteValue
#undef  RegDeleteValue
#endif
#define RegDeleteValue RegDeleteValueWrapW

#ifdef  RegCreateKeyEx
#undef  RegCreateKeyEx
#endif
#define RegCreateKeyEx RegCreateKeyExWrapW

#ifdef  RegSetValueEx
#undef  RegSetValueEx
#endif
#define RegSetValueEx RegSetValueExWrapW

#ifdef  GetUserName
#undef  GetUserName
#endif
#define GetUserName GetUserNameWrapW

#ifdef  RegQueryValueEx
#undef  RegQueryValueEx
#endif
#define RegQueryValueEx RegQueryValueExWrapW

#ifdef  GetClassInfoEx
#undef  GetClassInfoEx
#endif
#define GetClassInfoEx GetClassInfoExWrapW

//atlwin.h makes a direct call to the W version
//of this API so wrap that
#ifdef  GetClassInfoExW
#undef  GetClassInfoExW
#endif
#define GetClassInfoExW GetClassInfoExWrapW


#ifdef  UnregisterClass
#undef  UnregisterClass
#endif
#define UnregisterClass UnregisterClassWrapW

#ifdef  RegOpenKey
#undef  RegOpenKey
#endif
#define RegOpenKey RegOpenKeyWrapW

#ifdef  RegDeleteKey
#undef  RegDeleteKey
#endif
#define RegDeleteKey RegDeleteKeyWrapW

#ifdef  RegQueryInfoKey
#undef  RegQueryInfoKey
#endif
#define RegQueryInfoKey RegQueryInfoKeyWrapW

#ifdef  GetFileSecurity
#undef  GetFileSecurity
#endif
#define GetFileSecurity GetFileSecurityWrapW

#ifdef  SetFileSecurity
#undef  SetFileSecurity
#endif
#define SetFileSecurity SetFileSecurityWrapW

// KERNEL32.dll

#ifdef  CreateProcess
#undef  CreateProcess
#endif
#define CreateProcess CreateProcessWrapW

#ifdef  DeleteFile
#undef  DeleteFile
#endif
#define DeleteFile DeleteFileWrapW

#ifdef  CreateDirectory
#undef  CreateDirectory
#endif
#define CreateDirectory CreateDirectoryWrapW

#ifdef  GetCommandLine
#undef  GetCommandLine
#endif
#define GetCommandLine GetCommandLineWrapW

#ifdef  GetEnvironmentStrings
#undef  GetEnvironmentStrings
#endif
#define GetEnvironmentStrings GetEnvironmentStringsWrapW

#ifdef  FreeEnvironmentStrings
#undef  FreeEnvironmentStrings
#endif
#define FreeEnvironmentStrings FreeEnvironmentStringsWrapW

#ifdef  LCMapString
#undef  LCMapString
#endif
#define LCMapString LCMapStringWrapW

#ifdef  GetStringType
#undef  GetStringType
#endif
#define GetStringType GetStringTypeWrapW

#ifdef  CreateEvent
#undef  CreateEvent
#endif
#define CreateEvent CreateEventWrapW

#ifdef  FormatMessage
#undef  FormatMessage
#endif
#define FormatMessage FormatMessageWrapW

#ifdef  lstrcpy
#undef  lstrcpy
#endif
#define lstrcpy lstrcpyWrapW
#define lstrcpyW lstrcpyWrapW

#ifdef  lstrcpyn
#undef  lstrcpyn
#endif
#define lstrcpyn lstrcpynWrapW

#ifdef  lstrcat
#undef  lstrcat
#endif
#define lstrcat lstrcatWrapW

#ifdef  lstrcmpi
#undef  lstrcmpi
#endif
#define lstrcmpi lstrcmpiWrapW

#ifdef  FindResource
#undef  FindResource
#endif
#define FindResource FindResourceWrapW

#ifdef  GetVersionEx
#undef  GetVersionEx
#endif
#define GetVersionEx GetVersionExWrapW

#ifdef  GetTempPath
#undef  GetTempPath
#endif
#define GetTempPath GetTempPathWrapW

#ifdef  GetTempFileName
#undef  GetTempFileName
#endif
#define GetTempFileName GetTempFileNameWrapW

#ifdef  CreateFileMapping
#undef  CreateFileMapping
#endif
#define CreateFileMapping CreateFileMappingWrapW

#ifdef  CreateMutex
#undef  CreateMutex
#endif
#define CreateMutex CreateMutexWrapW

#ifdef  OutputDebugString
#undef  OutputDebugString
#endif
#define OutputDebugString OutputDebugStringWrapW

#ifdef  OutputDebugStringW
#undef  OutputDebugStringW
#endif
#define OutputDebugStringW OutputDebugStringWrapW

#ifdef  CreateFile
#undef  CreateFile
#endif
#define CreateFile CreateFileWrapW

#ifdef  ExpandEnvironmentStrings
#undef  ExpandEnvironmentStrings
#endif
#define ExpandEnvironmentStrings ExpandEnvironmentStringsWrapW

#ifdef  GetStartupInfo
#undef  GetStartupInfo
#endif
#define GetStartupInfo GetStartupInfoWrapW

#ifdef  GetModuleHandle
#undef  GetModuleHandle
#endif
#define GetModuleHandle GetModuleHandleWrapW

#ifdef  GetModuleFileName
#undef  GetModuleFileName
#endif
#define GetModuleFileName GetModuleFileNameWrapW

#ifdef  SetFileAttributes
#undef  SetFileAttributes
#endif
#define SetFileAttributes SetFileAttributesWrapW

#ifdef  GetFileAttributes
#undef  GetFileAttributes
#endif
#define GetFileAttributes GetFileAttributesWrapW

#ifdef  RemoveDirectory
#undef  RemoveDirectory
#endif
#define RemoveDirectory RemoveDirectoryWrapW

#ifdef  FindFirstFile
#undef  FindFirstFile
#endif
#define FindFirstFile FindFirstFileWrapW

#ifdef  FindNextFile
#undef  FindNextFile
#endif
#define FindNextFile FindNextFileWrapW

#ifdef  GetDiskFreeSpace
#undef  GetDiskFreeSpace
#endif
#define GetDiskFreeSpace GetDiskFreeSpaceWrapW

#ifdef  GetFullPathName
#undef  GetFullPathName
#endif
#define GetFullPathName GetFullPathNameWrapW

#ifdef  GetComputerName
#undef  GetComputerName
#endif
#define GetComputerName GetComputerNameWrapW

//RDPDR makes a direct call to the W api
#ifdef  GetComputerNameW
#undef  GetComputerNameW
#endif
#define GetComputerNameW GetComputerNameWrapW


#ifdef  CreateSemaphore
#undef  CreateSemaphore
#endif
#define CreateSemaphore CreateSemaphoreWrapW

#ifdef  GetDriveType
#undef  GetDriveType
#endif
#define GetDriveType GetDriveTypeWrapW

#ifdef  FindFirstChangeNotification
#undef  FindFirstChangeNotification
#endif
#define FindFirstChangeNotification FindFirstChangeNotificationWrapW

#ifdef  GetVolumeInformation
#undef  GetVolumeInformation
#endif
#define GetVolumeInformation GetVolumeInformationWrapW

#ifdef  MoveFile
#undef  MoveFile
#endif
#define MoveFile MoveFileWrapW

#ifdef  GetProfileString
#undef  GetProfileString
#endif
#define GetProfileString GetProfileStringWrapW

#ifdef  CreateDirectory
#undef  CreateDirectory
#endif
#define CreateDirectory CreateDirectoryWrapW

#ifdef  LoadLibrary
#undef  LoadLibrary
#endif
#define LoadLibrary LoadLibraryWrapW

#ifdef  LoadLibraryEx
#undef  LoadLibraryEx
#endif
#define LoadLibraryEx LoadLibraryExWrapW

#ifdef  GetShortPathName
#undef  GetShortPathName
#endif
#define GetShortPathName GetShortPathNameWrapW

#ifdef  GetSystemDirectory
#undef  GetSystemDirectory
#endif
#define GetSystemDirectory GetSystemDirectoryWrapW

#ifdef  DrawText
#undef  DrawText
#endif
#define DrawText DrawTextWrapW

#ifdef GetDefaultCommConfig
#undef GetDefaultCommConfig
#endif
#define GetDefaultCommConfig GetDefaultCommConfigWrapW

#ifdef GetCurrentDirectory
#undef GetCurrentDirectory
#endif
#define GetCurrentDirectory GetCurrentDirectoryWrapW

// GDI32.dll
#ifdef  CreateDC
#undef  CreateDC
#endif
#define CreateDC CreateDCWrapW

#ifdef  CreateMetaFile
#undef  CreateMetaFile
#endif
#define CreateMetaFile CreateMetaFileWrapW

#ifdef  GetObject
#undef  GetObject
#endif
#define GetObject GetObjectWrapW

#ifdef  CreateFontIndirect
#undef  CreateFontIndirect
#endif
#define CreateFontIndirect CreateFontIndirectWrapW

#ifdef  GetTextExtentPoint
#undef  GetTextExtentPoint
#endif
#define GetTextExtentPoint GetTextExtentPointWrapW


#ifdef  ExtTextOut
#undef  ExtTextOut
#endif
#define ExtTextOut ExtTextOutWrapW

#ifdef  GetTextMetrics
#undef  GetTextMetrics
#endif
#define GetTextMetrics GetTextMetricsWrapW

// USER32.dll

#ifdef  SetClassLong
#undef  SetClassLong
#endif
#define SetClassLong SetClassLongWrapW

#ifdef  SetClassLongPtr
#undef  SetClassLongPtr
#endif
#define SetClassLongPtr SetClassLongPtrWrapW

#ifdef  PeekMessage
#undef  PeekMessage
#endif
#define PeekMessage PeekMessageWrapW

#ifdef  MapVirtualKey
#undef  MapVirtualKey
#endif
#define MapVirtualKey MapVirtualKeyWrapW

#ifdef  SetWindowsHookEx
#undef  SetWindowsHookEx
#endif
#define SetWindowsHookEx SetWindowsHookExWrapW

#ifdef  PostThreadMessage
#undef  PostThreadMessage
#endif
#define PostThreadMessage PostThreadMessageWrapW

#ifdef  GetClipboardFormatName
#undef  GetClipboardFormatName
#endif
#define GetClipboardFormatName GetClipboardFormatNameWrapW

#ifdef  RegisterClipboardFormat
#undef  RegisterClipboardFormat
#endif
#define RegisterClipboardFormat RegisterClipboardFormatWrapW


#ifdef CreateDialog
#undef CreateDialog
#endif
#define CreateDialog(hInstance, lpName, hWndParent, lpDialogFunc) \
CreateDialogParamWrapW(hInstance, lpName, hWndParent, lpDialogFunc, 0L)

#ifdef CreateDialogIndirect
#undef CreateDialogIndirect
#endif
#define CreateDialogIndirect(hInstance, lpTemplate, hWndParent, lpDialogFunc) \
CreateDialogIndirectParamWrapW(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)

#ifdef  CreateDialogIndirectParam
#undef  CreateDialogIndirectParam
#endif
#define CreateDialogIndirectParam CreateDialogIndirectParamWrapW

#ifdef  DispatchMessage
#undef  DispatchMessage
#endif
#define DispatchMessage DispatchMessageWrapW

#ifdef  CreateDialogParam
#undef  CreateDialogParam
#endif
#define CreateDialogParam CreateDialogParamWrapW

#ifdef  IsDialogMessage
#undef  IsDialogMessage
#endif
#define IsDialogMessage IsDialogMessageWrapW

#ifdef  SetDlgItemText
#undef  SetDlgItemText
#endif
#define SetDlgItemText SetDlgItemTextWrapW

#ifdef  LoadImage
#undef  LoadImage
#endif
#define LoadImage LoadImageWrapW

#ifdef  GetDlgItemText
#undef  GetDlgItemText
#endif
#define GetDlgItemText GetDlgItemTextWrapW

#ifdef  SendDlgItemMessage
#undef  SendDlgItemMessage
#endif
#define SendDlgItemMessage SendDlgItemMessageWrapW

#ifdef  GetWindowText
#undef  GetWindowText
#endif
#define GetWindowText GetWindowTextWrapW

#ifdef  DialogBoxParam
#undef  DialogBoxParam
#endif
#define DialogBoxParam DialogBoxParamWrapW

#ifdef  DialogBox
#undef  DialogBox
#endif
#define DialogBox(hInstance, lpTemplate, hWndParent, lpDialogFunc) \
DialogBoxParamWrapW(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)

#ifdef  RegisterClassEx
#undef  RegisterClassEx
#endif
#define RegisterClassEx RegisterClassExWrapW

//ATL makes a direct call to the W version of this
//API so wrap it directly
#ifdef  RegisterClassExW
#undef  RegisterClassExW
#endif
#define RegisterClassExW RegisterClassExWrapW


#ifdef  LoadIcon
#undef  LoadIcon
#endif
#define LoadIcon LoadIconWrapW

#ifdef  GetWindowLong
#undef  GetWindowLong
#endif
#define GetWindowLong GetWindowLongWrapW

#ifdef  GetKeyboardLayoutName
#undef  GetKeyboardLayoutName
#endif
#define GetKeyboardLayoutName GetKeyboardLayoutNameWrapW

#ifdef  GetWindowLongPtr
#undef  GetWindowLongPtr
#endif
#define GetWindowLongPtr GetWindowLongPtrWrapW


#ifdef  CreateWindowEx
#undef  CreateWindowEx
#endif
#define CreateWindowEx CreateWindowExWrapW

//Special case CreateWindow because it's
//a macro to CreateWindowEx
#ifdef  CreateWindow
#undef  CreateWindow
#endif
#define CreateWindow(lpClassName, lpWindowName, dwStyle, x, y,\
nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam)\
CreateWindowExWrapW(0L, lpClassName, lpWindowName, dwStyle, x, y,\
nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam)


#ifdef  PostMessage
#undef  PostMessage
#endif
#define PostMessage PostMessageWrapW

#ifdef  SetWindowLong
#undef  SetWindowLong
#endif
#define SetWindowLong SetWindowLongWrapW

#ifdef  SetWindowLongPtr
#undef  SetWindowLongPtr
#endif
#define SetWindowLongPtr SetWindowLongPtrWrapW

#ifdef  SendMessage
#undef  SendMessage
#endif
#define SendMessage SendMessageWrapW

#ifdef  SetWindowText
#undef  SetWindowText
#endif
#define SetWindowText SetWindowTextWrapW

#ifdef  WinHelp
#undef  WinHelp
#endif
#define WinHelp WinHelpWrapW

#ifdef  DefWindowProc
#undef  DefWindowProc
#endif
#define DefWindowProc DefWindowProcWrapW

#ifdef  CallWindowProc
#undef  CallWindowProc
#endif
#define CallWindowProc CallWindowProcWrapW

#ifdef  MessageBox
#undef  MessageBox
#endif
#define MessageBox MessageBoxWrapW

#ifdef  LoadCursor
#undef  LoadCursor
#endif
#define LoadCursor LoadCursorWrapW

//ATL makes a direct call to LoadCursorW
#ifdef  LoadCursorW
#undef  LoadCursorW
#endif
#define LoadCursorW LoadCursorWrapW

#ifdef  ModifyMenu
#undef  ModifyMenu
#endif
#define ModifyMenu ModifyMenuWrapW

#ifdef  AppendMenu
#undef  AppendMenu
#endif
#define AppendMenu AppendMenuWrapW

#ifdef  LoadString
#undef  LoadString
#endif
#define LoadString LoadStringWrapW

#ifdef  RegisterClass
#undef  RegisterClass
#endif
#define RegisterClass RegisterClassWrapW

#ifdef  GetMessage
#undef  GetMessage
#endif
#define GetMessage GetMessageWrapW

#ifdef  LoadAccelerators
#undef  LoadAccelerators
#endif
#define LoadAccelerators LoadAcceleratorsWrapW

#ifdef  CharNext
#undef  CharNext
#endif
#define CharNext CharNextWrapW

//Some ATL code explicitly calls CharNextW
#ifdef  CharNextW
#undef  CharNextW
#endif
#define CharNextW CharNextWrapW

// SHELL32.dll
#ifdef  SHGetPathFromIDList
#undef  SHGetPathFromIDList
#endif
#define SHGetPathFromIDList SHGetPathFromIDListWrapW

#ifdef  ExtractIcon
#undef  ExtractIcon
#endif
#define ExtractIcon ExtractIconWrapW

//HACK! Remap wsprintf to the va_list version
#ifdef  wsprintfW
#undef  wsprintfW
#endif
#define wsprintfW wsprintfWrapW

#ifdef  wvsprintfW
#undef  wvsprintfW
#endif
#define wvsprintfW wvsprintfWrapW

#ifdef  SHFileOperation
#undef  SHFileOperation
#endif
#define SHFileOperation SHFileOperationWrapW

// comdlg32.dll
#ifdef  GetSaveFileName
#undef  GetSaveFileName
#endif
#define GetSaveFileName GetSaveFileNameWrapW

#ifdef  GetFileTitle
#undef  GetFileTitle
#endif
#define GetFileTitle GetFileTitleWrapW

#ifdef  GetOpenFileName
#undef  GetOpenFileName
#endif
#define GetOpenFileName GetOpenFileNameWrapW

// shell32.dll
#ifdef  SHGetFolderPath
#undef  SHGetFolderPath
#endif
#define SHGetFolderPath SHGetFolderPathWrapW

// winspool.lib
#ifdef  EnumPrinters
#undef  EnumPrinters
#endif
#define EnumPrinters EnumPrintersWrapW

#ifdef  OpenPrinter
#undef  OpenPrinter
#endif
#define OpenPrinter  OpenPrinterWrapW

#ifdef  StartDocPrinter
#undef  StartDocPrinter
#endif
#define StartDocPrinter StartDocPrinterWrapW

#ifdef  GetPrinterData
#undef  GetPrinterData
#endif
#define GetPrinterData  GetPrinterDataWrapW

#ifdef  GetPrinterDriver
#undef  GetPrinterDriver
#endif
#define GetPrinterDriver GetPrinterDriverWrapW

// this is a hack around ATL problems:
// Wrap in two phases, second phase
// wrap is after including ATL headers
// that have member function names that conflict
// with win32 APIs.
//
#ifndef DONOT_INCLUDE_SECONDPHASE_WRAPS
#include "uwrap2.h"
#endif


#endif // DONOT_REPLACE_WITH_WRAPPERS

//
// Wrapper function definitions these are identitcal to the definitions
// for the 'W' functions
//

#define DEFINE_WRAPPER_FNS
#ifdef  DEFINE_WRAPPER_FNS

//
//To create these, simply copy the 'W' version
//declaration from the windows headers and append WrapW.
//There is no automated way.
//

#ifdef __cplusplus
extern "C" {
#endif

//Advapi32.dll

LONG
APIENTRY
RegEnumKeyWrapW (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpName,
    IN DWORD cbName
    );

LONG
APIENTRY
RegOpenKeyExWrapW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    );

LONG
APIENTRY
RegEnumKeyExWrapW (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpName,
    IN OUT LPDWORD lpcbName,
    IN LPDWORD lpReserved,
    IN OUT LPWSTR lpClass,
    IN OUT LPDWORD lpcbClass,
    OUT PFILETIME lpftLastWriteTime
    );

LONG
APIENTRY
RegEnumValueWrapW (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpValueName,
    IN OUT LPDWORD lpcbValueName,
    IN LPDWORD lpReserved,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );

LONG
APIENTRY
RegDeleteValueWrapW (
    IN HKEY hKey,
    IN LPCWSTR lpValueName
    );

LONG
APIENTRY
RegCreateKeyExWrapW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD Reserved,
    IN LPWSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition
    );

LONG
APIENTRY
RegSetValueExWrapW (
    IN HKEY hKey,
    IN LPCWSTR lpValueName,
    IN DWORD Reserved,
    IN DWORD dwType,
    IN CONST BYTE* lpData,
    IN DWORD cbData
    );


LONG
APIENTRY
RegSetValueWrapW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwType,
    IN LPCWSTR lpData,
    IN DWORD cbData
    );

BOOL
WINAPI
GetUserNameWrapW (
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    );

LONG
APIENTRY
RegQueryValueExWrapW (
    IN HKEY hKey,
    IN LPCWSTR lpValueName,
    IN LPDWORD lpReserved,
    OUT LPDWORD lpType,
    IN OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );

LONG
APIENTRY
RegDeleteKeyWrapW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey
    );

LONG
APIENTRY
RegQueryInfoKeyWrapW (
    IN HKEY hKey,
    OUT LPWSTR lpClass,
    IN OUT LPDWORD lpcbClass,
    IN LPDWORD lpReserved,
    OUT LPDWORD lpcSubKeys,
    OUT LPDWORD lpcbMaxSubKeyLen,
    OUT LPDWORD lpcbMaxClassLen,
    OUT LPDWORD lpcValues,
    OUT LPDWORD lpcbMaxValueNameLen,
    OUT LPDWORD lpcbMaxValueLen,
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME lpftLastWriteTime
    );

LONG
APIENTRY
RegOpenKeyWrapW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    OUT PHKEY phkResult
    );

BOOL
WINAPI
GetFileSecurityWrapW (
    IN LPCWSTR lpFileName,
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN DWORD nLength,
    OUT LPDWORD lpnLengthNeeded
    );

BOOL
WINAPI
SetFileSecurityWrapW (
    IN LPCWSTR lpFileName,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


//Kernel32.dll
BOOL
WINAPI
DeleteFileWrapW(
    IN LPCWSTR lpFileName
    );

BOOL 
WINAPI 
CreateProcessWrapW(
    IN LPCWSTR lpApplicationName, 
    IN OUT LPWSTR lpCommandLine,
    IN LPSECURITY_ATTRIBUTES lpProcessAttributes,
    IN LPSECURITY_ATTRIBUTES lpThreadAttributes,
    IN BOOL bInheritHandles,
    IN DWORD dwCreationFlags,
    IN LPVOID lpEnvironment,
    IN LPCWSTR lpCurrentDirectory,
    IN LPSTARTUPINFOW lpStartupInfo,
    OUT LPPROCESS_INFORMATION lpProcessInformation
    );

BOOL
WINAPI
CreateDirectoryWrapW(
    IN LPCWSTR lpPathName,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

LPWSTR
WINAPI
GetCommandLineWrapW(
    VOID
    );

LPWSTR
WINAPI
GetEnvironmentStringsWrapW(
    VOID
    );

BOOL
WINAPI
FreeEnvironmentStringsWrapW(
    IN LPWSTR
    );

int
WINAPI
LCMapStringWrapW(
    IN LCID     Locale,
    IN DWORD    dwMapFlags,
    IN LPCWSTR  lpSrcStr,
    IN int      cchSrc,
    OUT LPWSTR  lpDestStr,
    IN int      cchDest);

BOOL
WINAPI
GetStringTypeWrapW(
    IN DWORD    dwInfoType,
    IN LPCWSTR  lpSrcStr,
    IN int      cchSrc,
    OUT LPWORD  lpCharType);

HANDLE
WINAPI
CreateEventWrapW(
    IN LPSECURITY_ATTRIBUTES lpEventAttributes,
    IN BOOL bManualReset,
    IN BOOL bInitialState,
    IN LPCWSTR lpName
    );

DWORD
WINAPI
FormatMessageWrapW(
    IN DWORD dwFlags,
    IN LPCVOID lpSource,
    IN DWORD dwMessageId,
    IN DWORD dwLanguageId,
    OUT LPWSTR lpBuffer,
    IN DWORD nSize,
    IN va_list *Arguments
    );

LPWSTR
WINAPI
lstrcpyWrapW(
    OUT LPWSTR lpString1,
    IN LPCWSTR lpString2
    );

LPWSTR
lstrcatWrapW(
    OUT LPWSTR pszDst,
    IN LPCWSTR pszSrc
    );

LPWSTR
lstrcpynWrapW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    );

INT
APIENTRY
lstrcmpiWrapW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );

HRSRC
WINAPI
FindResourceWrapW(
    IN HMODULE hModule,
    IN LPCWSTR lpName,
    IN LPCWSTR lpType
    );

BOOL
WINAPI
GetVersionExWrapW(
    IN OUT LPOSVERSIONINFOW lpVersionInformation
    );

DWORD
WINAPI
GetTempPathWrapW(
    IN DWORD nBufferLength,
    OUT LPWSTR lpBuffer
    );


UINT
WINAPI
GetTempFileNameWrapW(
    IN LPCWSTR lpPathName,
    IN LPCWSTR lpPrefixString,
    IN UINT uUnique,
    OUT LPWSTR lpTempFileName
    );

HANDLE
WINAPI
CreateFileMappingWrapW(
    IN HANDLE hFile,
    IN LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    IN DWORD flProtect,
    IN DWORD dwMaximumSizeHigh,
    IN DWORD dwMaximumSizeLow,
    IN LPCWSTR lpName
    );


HANDLE
WINAPI
CreateMutexWrapW(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR pwzName);

UINT
WINAPI
GetSystemDirectoryWrapW(
    OUT LPWSTR lpBuffer,
    IN UINT uSize
    );

VOID
WINAPI
OutputDebugStringWrapW(
    IN LPCWSTR lpOutputString
    );

int
WINAPI
DrawTextWrapW(
    IN HDC hDC,
    IN LPCWSTR lpString,
    IN int nCount,
    IN OUT LPRECT lpRect,
    IN UINT uFormat);

HANDLE
WINAPI
CreateFileWrapW(
    IN LPCWSTR lpFileName,
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN DWORD dwCreationDisposition,
    IN DWORD dwFlagsAndAttributes,
    IN HANDLE hTemplateFile
    );

DWORD
WINAPI
ExpandEnvironmentStringsWrapW(
    IN LPCWSTR lpSrc,
    OUT LPWSTR lpDst,
    IN DWORD nSize
    );

VOID
WINAPI
GetStartupInfoWrapW(
    OUT LPSTARTUPINFOW lpStartupInfo
    );

HMODULE
WINAPI
GetModuleHandleWrapW(
    IN LPCWSTR lpModuleName
    );

DWORD
WINAPI
GetModuleFileNameWrapW(
    IN HMODULE hModule,
    OUT LPWSTR lpFilename,
    IN DWORD nSize
    );

HMODULE
WINAPI
LoadLibraryWrapW(
    IN LPCWSTR lpLibFileName
    );

DWORD
WINAPI
GetShortPathNameWrapW(
    IN LPCWSTR lpszLongPath,
    OUT LPWSTR  lpszShortPath,
    IN DWORD    cchBuffer
    );


HMODULE
WINAPI
LoadLibraryExWrapW(
    IN LPCWSTR lpLibFileName,
    IN HANDLE hFile,
    IN DWORD dwFlags
    );


HANDLE
WINAPI
FindFirstFileWrapW(
    IN LPCWSTR lpFileName,
    OUT LPWIN32_FIND_DATAW lpFindFileData
    );

BOOL
WINAPI
FindNextFileWrapW(
    IN HANDLE hFindFile,
    OUT LPWIN32_FIND_DATAW lpFindFileData
    );


BOOL
WINAPI
GetDiskFreeSpaceWrapW(
    IN LPCWSTR lpRootPathName,
    OUT LPDWORD lpSectorsPerCluster,
    OUT LPDWORD lpBytesPerSector,
    OUT LPDWORD lpNumberOfFreeClusters,
    OUT LPDWORD lpTotalNumberOfClusters
    );

DWORD
WINAPI
GetFullPathNameWrapW(
    IN LPCWSTR lpFileName,
    IN DWORD nBufferLength,
    OUT LPWSTR lpBuffer,
    OUT LPWSTR *lpFilePart
    );

BOOL
WINAPI
RemoveDirectoryWrapW(
    IN LPCWSTR lpPathName
    );

DWORD
WINAPI
GetFileAttributesWrapW(
    IN LPCWSTR lpFileName
    );

BOOL
WINAPI
SetFileAttributesWrapW(
    IN LPCWSTR lpFileName,
    IN DWORD dwFileAttributes
    );

UINT
WINAPI
GetDriveTypeWrapW(
    IN LPCWSTR lpRootPathName
    );

HANDLE
WINAPI
FindFirstChangeNotificationWrapW(
    IN LPCWSTR lpPathName,
    IN BOOL bWatchSubtree,
    IN DWORD dwNotifyFilter
    );

BOOL
WINAPI
GetVolumeInformationWrapW(
    IN LPCWSTR lpRootPathName,
    OUT LPWSTR lpVolumeNameBuffer,
    IN DWORD nVolumeNameSize,
    OUT LPDWORD lpVolumeSerialNumber,
    OUT LPDWORD lpMaximumComponentLength,
    OUT LPDWORD lpFileSystemFlags,
    OUT LPWSTR lpFileSystemNameBuffer,
    IN DWORD nFileSystemNameSize
    );

BOOL
WINAPI
MoveFileWrapW(
    IN LPCWSTR lpExistingFileName,
    IN LPCWSTR lpNewFileName
    );

DWORD
WINAPI
GetProfileStringWrapW(
    IN LPCWSTR lpAppName,
    IN LPCWSTR lpKeyName,
    IN LPCWSTR lpDefault,
    OUT LPWSTR lpReturnedString,
    IN DWORD nSize
    );

BOOL
WINAPI
GetDefaultCommConfigWrapW(
    IN LPCWSTR lpszName,
    OUT LPCOMMCONFIG lpCC,
    IN OUT LPDWORD lpdwSize
    );

DWORD
WINAPI
GetCurrentDirectoryWrapW(
    IN DWORD nBufferLength,
    OUT LPWSTR lpBuffer
    );


// GDI32.dll
int WINAPI
GetObjectWrapW( IN HGDIOBJ, IN int, OUT LPVOID);


BOOL
WINAPI
ExtTextOutWrapW(
    HDC        hdc,
    int        x,
    int        y,
    UINT       fl,
    CONST RECT *prcl,
    LPCWSTR    pwsz,
    UINT       c,       // count of bytes = 2 * (# of WCHAR's)
    CONST INT *pdx);

BOOL
WINAPI
GetTextMetricsWrapW( IN HDC, OUT LPTEXTMETRICW);

HFONT
WINAPI
CreateFontIndirectWrapW( IN CONST LOGFONTW *);

BOOL
APIENTRY
GetTextExtentPointWrapW(HDC hdc,LPCWSTR pwsz,DWORD cwc,LPSIZE psizl);

HDC
WINAPI CreateMetaFileWrapW( IN LPCWSTR);

HDC
WINAPI CreateDCWrapW( IN LPCWSTR, IN LPCWSTR, IN LPCWSTR, IN CONST DEVMODEW *);


// USER32.dll

ULONG_PTR
WINAPI
SetClassLongPtrWrapW(
    IN HWND hWnd,
    IN int nIndex,
    IN LONG_PTR dwNewLong);

HWND
WINAPI
CreateDialogIndirectParamWrapW(
    IN HINSTANCE hInstance,
    IN LPCDLGTEMPLATEW lpTemplate,
    IN HWND hWndParent,
    IN DLGPROC lpDialogFunc,
    IN LPARAM dwInitParam);

LRESULT
WINAPI
DispatchMessageWrapW(
    IN CONST MSG *lpMsg);

HWND
WINAPI
CreateDialogParamWrapW(
    IN HINSTANCE hInstance,
    IN LPCWSTR lpTemplateName,
    IN HWND hWndParent,
    IN DLGPROC lpDialogFunc,
    IN LPARAM dwInitParam);

BOOL
WINAPI
IsDialogMessageWrapW(
    IN HWND hDlg,
    IN LPMSG lpMsg);

BOOL
WINAPI
SetDlgItemTextWrapW(
    IN HWND hDlg,
    IN int nIDDlgItem,
    IN LPCWSTR lpString);

HANDLE
WINAPI
LoadImageWrapW(
    IN HINSTANCE,
    IN LPCWSTR,
    IN UINT,
    IN int,
    IN int,
    IN UINT);

UINT
WINAPI
GetDlgItemTextWrapW(
    IN HWND hDlg,
    IN int nIDDlgItem,
    OUT LPWSTR lpString,
    IN int nMaxCount);

LRESULT
WINAPI
SendDlgItemMessageWrapW(
    IN HWND hDlg,
    IN int nIDDlgItem,
    IN UINT Msg,
    IN WPARAM wParam,
    IN LPARAM lParam);

int
WINAPI
TranslateAcceleratorWrapW(
    IN HWND hWnd,
    IN HACCEL hAccTable,
    IN LPMSG lpMsg);

int
WINAPI
GetWindowTextWrapW(
    IN HWND hWnd,
    OUT LPWSTR lpString,
    IN int nMaxCount);

INT_PTR
WINAPI
DialogBoxParamWrapW(
    IN HINSTANCE hInstance,
    IN LPCWSTR lpTemplateName,
    IN HWND hWndParent,
    IN DLGPROC lpDialogFunc,
    IN LPARAM dwInitParam);

ATOM
WINAPI
RegisterClassExWrapW(
    IN CONST WNDCLASSEXW *);

ATOM
WINAPI
RegisterClassWrapW(
    IN CONST WNDCLASSW *lpWndClass);

BOOL
WINAPI
UnregisterClassWrapW(
    IN LPCWSTR lpClassName,
    IN HINSTANCE hInstance);


HICON
WINAPI
LoadIconWrapW(
    IN HINSTANCE hInstance,
    IN LPCWSTR lpIconName);

LONG
WINAPI
GetWindowLongWrapW(
    IN HWND hWnd,
    IN int nIndex);

LONG_PTR
WINAPI
GetWindowLongPtrWrapW(
    HWND hWnd,
    int nIndex);


HWND
WINAPI
CreateWindowExWrapW(
    IN DWORD dwExStyle,
    IN LPCWSTR lpClassName,
    IN LPCWSTR lpWindowName,
    IN DWORD dwStyle,
    IN int X,
    IN int Y,
    IN int nWidth,
    IN int nHeight,
    IN HWND hWndParent,
    IN HMENU hMenu,
    IN HINSTANCE hInstance,
    IN LPVOID lpParam);

BOOL
WINAPI
PostMessageWrapW(
    IN HWND hWnd,
    IN UINT Msg,
    IN WPARAM wParam,
    IN LPARAM lParam);

LONG
WINAPI
SetWindowLongWrapW(
    IN HWND hWnd,
    IN int nIndex,
    IN LONG dwNewLong);

LONG_PTR
WINAPI
SetWindowLongPtrWrapW(
    HWND hWnd,
    int nIndex,
    LONG_PTR dwNewLong);


LRESULT
WINAPI
SendMessageWrapW(
    IN HWND hWnd,
    IN UINT Msg,
    IN WPARAM wParam,
    IN LPARAM lParam);

BOOL
WINAPI
PeekMessageWrapW(
    OUT LPMSG lpMsg,
    IN HWND hWnd,
    IN UINT wMsgFilterMin,
    IN UINT wMsgFilterMax,
    IN UINT wRemoveMsg);

UINT
WINAPI
MapVirtualKeyWrapW(
    IN UINT uCode,
    IN UINT uMapType);

HHOOK
WINAPI
SetWindowsHookExWrapW(
    IN int idHook,
    IN HOOKPROC lpfn,
    IN HINSTANCE hmod,
    IN DWORD dwThreadId);

BOOL
WINAPI
PostThreadMessageWrapW(
    IN DWORD idThread,
    IN UINT Msg,
    IN WPARAM wParam,
    IN LPARAM lParam);

BOOL
WINAPI
SetWindowTextWrapW(
    IN HWND hWnd,
    IN LPCWSTR lpString);

BOOL
WINAPI
WinHelpWrapW(
    IN HWND hWndMain,
    IN LPCWSTR lpszHelp,
    IN UINT uCommand,
    IN ULONG_PTR dwData
    );

LRESULT
WINAPI
DefWindowProcWrapW(
    IN HWND hWnd,
    IN UINT Msg,
    IN WPARAM wParam,
    IN LPARAM lParam);

LRESULT
WINAPI
CallWindowProcWrapW(
    IN WNDPROC lpPrevWndFunc,
    IN HWND hWnd,
    IN UINT Msg,
    IN WPARAM wParam,
    IN LPARAM lParam);


int
WINAPI
MessageBoxWrapW(
    IN HWND hWnd,
    IN LPCWSTR lpText,
    IN LPCWSTR lpCaption,
    IN UINT uType);

HCURSOR
WINAPI
LoadCursorWrapW(
    IN HINSTANCE hInstance,
    IN LPCWSTR lpCursorName);

BOOL
WINAPI
ModifyMenuWrapW(
    IN HMENU hMnu,
    IN UINT uPosition,
    IN UINT uFlags,
    IN UINT_PTR uIDNewItem,
    IN LPCWSTR lpNewItem
    );

BOOL
WINAPI
AppendMenuWrapW(
    IN HMENU hMenu,
    IN UINT uFlags,
    IN UINT_PTR uIDNewItem,
    IN LPCWSTR lpNewItem
    );

int
WINAPI
LoadStringWrapW(
    IN HINSTANCE hInstance,
    IN UINT uID,
    OUT LPWSTR lpBuffer,
    IN int nBufferMax);

BOOL
WINAPI
GetMessageWrapW(
    OUT LPMSG lpMsg,
    IN HWND hWnd,
    IN UINT wMsgFilterMin,
    IN UINT wMsgFilterMax);

HACCEL
WINAPI
LoadAcceleratorsWrapW(
    IN HINSTANCE hInstance,
    IN LPCWSTR lpTableName);

LPWSTR
WINAPI
CharNextWrapW(
    IN LPCWSTR lpsz);


BOOL WINAPI
InsertMenuWrapW(
        HMENU   hMenu,
        UINT    uPosition,
        UINT    uFlags,
        UINT_PTR uIDNewItem,
        LPCWSTR lpNewItem);

DWORD WINAPI
CharLowerBuffWrapW( LPWSTR pch, DWORD cchLength );

DWORD WINAPI
CharUpperBuffWrapW( LPWSTR pch, DWORD cchLength );

HWND WINAPI
FindWindowExWrapW(
    HWND hwndParent,
    HWND hwndChildAfter,
    LPCWSTR pwzClassName,
    LPCWSTR pwzWindowName);

BOOL WINAPI IsCharAlphaWrapW(IN WCHAR ch);
BOOL WINAPI IsCharUpperWrapW(IN WCHAR ch);
BOOL WINAPI IsCharLowerWrapW(IN WCHAR ch);
BOOL WINAPI IsCharAlphaNumericWrapW(IN WCHAR ch);

BOOL WINAPI
GetClassInfoWrapW(
    HINSTANCE hModule,
    LPCWSTR lpClassName,
    LPWNDCLASSW lpWndClassW);

BOOL
WINAPI
GetClassInfoExWrapW(
    IN HINSTANCE,
    IN LPCWSTR,
    OUT LPWNDCLASSEXW);


BOOL
WINAPI
GetKeyboardLayoutNameWrapW(
    OUT LPWSTR pwszKLID);

int
WINAPI
GetClipboardFormatNameWrapW(
    IN UINT format,
    OUT LPWSTR lpszFormatName,
    IN int cchMaxCount);

UINT
WINAPI
RegisterClipboardFormatWrapW(
    IN LPCWSTR lpszFormat);

BOOL
WINAPI
GetComputerNameWrapW (
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    );

HANDLE
WINAPI
CreateSemaphoreWrapW(
    IN LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    IN LONG lInitialCount,
    IN LONG lMaximumCount,
    IN LPCWSTR lpName
    );

//Shell32.dll

BOOL
SHGetPathFromIDListWrapW(
    LPCITEMIDLIST pidl,
    LPWSTR pszPath);

int
SHFileOperationWrapW(
    LPSHFILEOPSTRUCTW pFileOpW);

HICON
ExtractIconWrapW(
    HINSTANCE hInst,
    LPCWSTR lpszExeFileName,
    UINT nIconIndex);


int WINAPIV wsprintfWrapW(
    LPWSTR lpOut,
    LPCWSTR lpFmt,
    ...);

int wvsprintfWrapW(LPWSTR pwszOut,
               LPCWSTR pwszFormat,
               va_list arglist);

//Comdlg32.dll
BOOL
APIENTRY
GetSaveFileNameWrapW(LPOPENFILENAMEW);

SHORT
WINAPI
GetFileTitleWrapW(
    LPCWSTR lpszFileW,
    LPWSTR lpszTitleW,
    WORD cbBuf);


BOOL
WINAPI
GetOpenFileNameWrapW(OPENFILENAME FAR*);

//Shell32.dll
STDAPI SHGetFolderPathWrapW(HWND hwnd, int csidl,
                            HANDLE hToken, DWORD dwFlags,
                            LPWSTR pszPath);

STDAPI StrRetToStrWrapW(STRRET *pstr,
                        LPCITEMIDLIST pidl,
                        LPWSTR *ppsz);

//winspool.lib
BOOL
WINAPI
EnumPrintersWrapW(
    IN DWORD   Flags,
    IN LPWSTR Name,
    IN DWORD   Level,
    OUT LPBYTE  pPrinterEnum,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);

BOOL
WINAPI
OpenPrinterWrapW(
   IN LPWSTR    pPrinterName,
   OUT LPHANDLE phPrinter,
   IN LPPRINTER_DEFAULTSW pDefault
);

DWORD
WINAPI
StartDocPrinterWrapW(
    IN HANDLE  hPrinter,
    IN DWORD   Level,
    IN LPBYTE  pDocInfo
);

DWORD
WINAPI
GetPrinterDataWrapW(
    IN HANDLE   hPrinter,
    IN LPWSTR  pValueName,
    OUT LPDWORD  pType,
    OUT LPBYTE   pData,
    IN DWORD    nSize,
    OUT LPDWORD  pcbNeeded
);

BOOL
WINAPI
GetPrinterDriverWrapW(
    HANDLE hPrinter,     // printer object
    LPTSTR pEnvironment, // environment name.  NULL is supported.
    DWORD Level,         // information level
    LPBYTE pDriverInfo,  // driver data buffer
    DWORD cbBuf,         // size of buffer
    LPDWORD pcbNeeded    // bytes received or required
);


//
// IME Wrapper functions accept fn pointers to the entry points
// to the real functions since other modules will dynamically bind
//

typedef BOOL (CALLBACK* PFN_ImmGetIMEFileNameW)(
    IN  HKL     hkl,
    OUT LPWSTR  lpszFileName,
    OUT UINT    uBufferLength
    );
typedef BOOL (CALLBACK* PFN_ImmGetIMEFileNameA)(
    IN  HKL     hkl,
    OUT LPSTR  lpszFileName,
    OUT UINT    uBufferLength
    );
UINT ImmGetIMEFileName_DynWrapW(
    IN HKL hkl,
    OUT LPWSTR szName,
    IN UINT uBufLen,
    IN PFN_ImmGetIMEFileNameW pfnImmGetIMEFileNameW,
    IN PFN_ImmGetIMEFileNameA pfnImmGetIMEFileNameA);


typedef BOOL (CALLBACK* PFN_IMPGetIMEW)(
    IN  HWND      hWnd,
    OUT LPIMEPROW  lpImePro
    );
typedef BOOL (CALLBACK* PFN_IMPGetIMEA)(
    IN  HWND      hWnd,
    OUT LPIMEPROA  lpImePro
    );
BOOL ImpGetIME_DynWrapW(
    IN HWND hWnd,
    OUT LPIMEPROW lpImeProW,
    IN PFN_IMPGetIMEW pfnIMPGetIMEW,
    IN PFN_IMPGetIMEA pfnIMPGetIMEA);


#ifdef __cplusplus
} //endif extern "C"
#endif

#endif //DEFINE_WRAPPER_FNS

#endif //defined(UNICODE) && !defined(_WIN64)
#endif //_uwrap_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\asn1\asnobjct.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asnobjct

Abstract:

    This module provides the methods of the top generic object for the ASN.1
    library.

Author:

    Doug Barlow (dbarlow) 10/8/1995

Environment:

    Win32

Notes:

    This module assumes that the width of an unsigned long int is 32 bits.

--*/

#include <windows.h>
#include "asnPriv.h"


//
//==============================================================================
//
//  CAsnObject
//

IMPLEMENT_NEW(CAsnObject)

/*++

CAsnObject:

    This is the construction routine for a CAsnObject.

Arguments:

    pasnParent supplies the parent of this object.

    dwType supplies the type of the object.

    dwFlags supplies any special flags for this object.  Options are:

        fOptional implies the object is optional.
        fDelete implies the object should be deleted when its parent destructs.

    dwTag is the tag of the object.  If this is zero, the tag is taken from the
        type.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CAsnObject::CAsnObject(
    IN DWORD dwFlags,
    IN DWORD dwTag,
    IN DWORD dwType)
:   m_rgEntries(),
    m_bfDefault()
{
    ASSERT(0 == (dwFlags & (fPresent | fDefault | 0xffffffe0)));
    m_dwTag = (tag_Undefined == dwTag) ? (dwType % 100) : dwTag;
    m_dwType = dwType;
    m_dwFlags = dwFlags;
    m_State = fill_Empty;
    m_pasnParent = NULL;
    ASSERT((tag_Undefined != m_dwTag)
            || (type_Any == m_dwType)
            || (type_Choice == m_dwType));
}


/*++

~CAsnObject:

    This is the destructor for the object.  We go through the list of objects
    and delete any marked as fDelete.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CAsnObject::~CAsnObject()
{
    CAsnObject *pasn;
    DWORD index;
    DWORD count = m_rgEntries.Count();

    for (index = 0; index < count; index += 1)
    {
        pasn = m_rgEntries[index];
        if ((NULL != pasn) && (this != pasn))
        {
            if (0 != (pasn->m_dwFlags & fDelete))
                delete pasn;
        }
    }
}


/*++

Adopt:

    This method causes this object to treat the given object as its parent for
    event notification.

Arguments:

    pasnParent supplies the address of the parent object.  Typically the caller
        provides the value 'this'.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

void
CAsnObject::Adopt(
    CAsnObject *pasnObject)
{
    CAsnObject *pasn;
    DWORD index;
    DWORD count = m_rgEntries.Count();

    for (index = 0; index < count; index += 1)
    {
        pasn = m_rgEntries[index];
        if ((NULL != pasn) && (this != pasn))
            pasn->Adopt(this);
    }
    ASSERT(this != pasnObject);
    m_pasnParent = pasnObject;
}


/*++

Clear:

    This method purges any stored values from the object and any underlying
    objects.  It does not free any Default storage.  It does delete autoDelete
    objects.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

void
CAsnObject::Clear(
    void)
{
    CAsnObject *pasn;
    DWORD index;
    DWORD count = m_rgEntries.Count();

    for (index = 0; index < count; index += 1)
    {
        pasn = m_rgEntries[index];
        ASSERT(NULL != pasn);
        ASSERT(this != pasn);

        if (NULL == pasn)
            continue;

        pasn->Clear();
        if (0 != (pasn->m_dwFlags & fDelete))
        {
            delete pasn;
            m_rgEntries.Set(index, NULL);
        }
    }
}


/*++

Tag:

    This routine returns the tag value of the object.

Arguments:

    None

Return Value:

    The tag, if known, or zero if not.

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

DWORD
CAsnObject::Tag(
    void)
const
{
    return m_dwTag;
}


/*++

DataLength:

    This routine returns the length of the local machine encoding of the data of
    an object.  This default implementation goes through all the subcomponents
    and adds up their lengths, but produces an ASN.1 encoding.

Arguments:

    None

Return Value:

    If >=0, the length of the data portion of this object.
    if < 0, an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::DataLength(
    void)
const
{
    LONG lTotal = 0;
    LONG lth;
    CAsnObject *pasn;
    DWORD index;
    DWORD count;


    if (!Complete())
    {
        TRACE("Incomplete structure")
        return -1;  // ?error? Incomplete structure.
    }
    count = m_rgEntries.Count();
    for (index = 0; index < count; index += 1)
    {
        pasn = m_rgEntries[index];
        ASSERT(NULL != pasn);
        ASSERT(pasn != this);

        if (NULL == pasn)
        {
            lth = -1;
            goto ErrorExit;
        }

        lth = pasn->_encLength();
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;
    }
    return lTotal;

ErrorExit:
    return lth;
}


/*++

Read:

    This default method constructs the value from the encoding of the underlying
    objects.

Arguments:

    bfDst receives the value.
    pbDst receives the value.  It is assumed to be long enough.

Return Value:

    If >=0, the length of the data portion of this object.
    if < 0, an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::Read(
    OUT CBuffer &bfDst)
const
{
    LONG lth = DataLength();
    if (0 < lth)
    {
        if (NULL == bfDst.Resize(lth))
            return -1;  // ?error? no memory
        return Read(bfDst.Access());
    }
    else
        return lth;
}

LONG
CAsnObject::Read(
    OUT LPBYTE pbDst)
const
{
    if (!Complete())
    {
        TRACE("Incomplete Structure")
        return -1;  // ?error? Incomplete structure.
    }
    return EncodeData(pbDst);
}


/*++

Write:

    This default implementation does an encoding operation on each of the
    components.

Arguments:

    bfSrc supplies the data to be written as a CBuffer object.
    pbSrc supplies the data as a BYTE array, with
    cbSrcLen supplies the length of the pbSrc Array.

Return Value:

    If >=0, the length of the data portion of this object.
    if < 0, an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::Write(
    IN const CBuffer &bfSrc)
{
    return Write(bfSrc.Access(), bfSrc.Length());
}

LONG
CAsnObject::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen)
{
    LONG lTotal = 0;
    LONG lth = -1;
    CAsnObject *pasn;
    DWORD index;
    DWORD count = m_rgEntries.Count();

    Clear();
    for (index = 0; index < count; index += 1)
    {
        pasn = m_rgEntries[index];
        ASSERT(NULL != pasn);
        ASSERT(pasn != this);

        if (NULL == pasn)
        {
            lth = -1;
            goto ErrorExit;
        }

        lth = pasn->_decode(&pbSrc[lTotal],cbSrcLen-lTotal);
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;
        if (cbSrcLen < (DWORD)lTotal)
        {
            TRACE("Data Encoding Error: Exceeded length while parsing")
            lth = -1;   // ?ErrorCode? Data Encoding Error
            goto ErrorExit;
        }
    }
    if ((DWORD)lTotal != cbSrcLen)
    {
        TRACE("Data Encoding Error: Length mismatch")
        lth = -1;   // ?ErrorCode? Data Encoding Error
        goto ErrorExit;
    }
    return lTotal;

ErrorExit:
    return lth;
}


/*++

EncodingLength:

    This method returns the length of the object in its ASN.1 encoding.

Arguments:

    None

Return Value:

    >= 0 is the length of the object's ASN.1 encoding.
    < 0 implies an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::EncodingLength(
    void)
const
{
    if (!Complete())
    {
        TRACE("Incomplete Object")
        return -1;  // ?error? Incomplete object.
    }
    return _encLength();
}

LONG
CAsnObject::_encLength(
    void)
const
{
    BYTE rge[32];
    LONG lTotal = 0;
    LONG lth;
    CAsnObject *pasn;
    DWORD index;
    DWORD count = m_rgEntries.Count();

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        lth = -1;
        goto ErrorExit;
        break;

    case fill_Optional:
    case fill_Defaulted:
        lTotal = 0;
        break;

    case fill_Present:
    case fill_NoElements:
        lth = EncodeTag(rge);
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;
        lth = EncodeLength(rge);
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;
        for (index = 0; index < count; index += 1)
        {
            pasn = m_rgEntries[index];
            ASSERT(NULL != pasn);
            ASSERT(pasn != this);

            if (NULL == pasn)
            {
                lth = -1;
                goto ErrorExit;
            }

            lth = pasn->_encLength();
            if (0 > lth)
                goto ErrorExit;
            lTotal += lth;
        }
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        goto ErrorExit;
        break;
    }
    return lTotal;

ErrorExit:
    return lth;
}


/*++

Encode:

    This method provides the ASN.1 encoding of the object.

Arguments:

    bfDst receives the encoding in a CBuffer format.

    pbDst receives the encoding in a LPBYTE format.  The buffer is assumed to be
        long enough.

Return Value:

    >= 0 is the length of the ASN.1 encoding.
    < 0 is an error indication.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::Encode(
    OUT CBuffer &bfDst)
const
{
    LONG lth = EncodingLength();
    if (0 > lth)
        goto ErrorExit;
    if (NULL == bfDst.Resize(lth))
        goto ErrorExit;
    lth = _encode(bfDst.Access());
    if (0 > lth)
        goto ErrorExit;
    return lth;

ErrorExit:
    bfDst.Reset();
    return lth;
}

LONG
CAsnObject::Encode(
    OUT LPBYTE pbDst)
const
{
    if (!Complete())
    {
        TRACE("Incomplete Structure")
        return -1;  // ?error? Incomplete structure.
    }
    return _encode(pbDst);
}

LONG
CAsnObject::_encode(
    OUT LPBYTE pbDst)
const
{
    LONG lth;
    LONG lTotal = 0;

    lth = EncodeTag(&pbDst[lTotal]);
    if (0 > lth)
        goto ErrorExit;
    lTotal += lth;
    lth = EncodeLength(&pbDst[lTotal]);
    if (0 > lth)
        goto ErrorExit;
    lTotal += lth;
    lth = EncodeData(&pbDst[lTotal]);
    if (0 > lth)
        goto ErrorExit;
    lTotal += lth;
    return lTotal;

ErrorExit:
    return lth;
}


/*++

Decode:

    This method reads an ASN.1 encoding of the object, and loads the components
    with the data.

Arguments:

    pbSrc supplies the ASN.1 encoding in an LPBYTE format.
    bfSrc supplies the ASN.1 encoding in a CBuffer format.

Return Value:

    >= 0 is the number of bytes consumed by the decoding.
    < 0 implies an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::Decode(
    IN const CBuffer &bfSrc)
{
    LONG lth = Decode(bfSrc.Access(), bfSrc.Length());
    return lth;
}

LONG
CAsnObject::Decode(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc)
{
    Clear();
    return _decode(pbSrc,cbSrc);
}

LONG
CAsnObject::_decode(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc)
{
    LONG lth;
    LONG lTotal = 0;
    DWORD tag, length;
    BOOL fIndefinite, fConstr;


    //
    // Extract the Tag.
    //

    lth = ExtractTag(&pbSrc[lTotal], cbSrc, &tag, &fConstr);
    if (0 > lth)
        goto ErrorExit;
    if ((m_dwTag != tag)
        || (0 != (fConstr ^ (0 != (m_dwFlags & fConstructed)))))
    {
        if (0 != ((fOptional | fDefault) & m_dwFlags))
            return 0;
        else
        {
            TRACE("Invalid Tag Value")
            lth = -1;   // ?error? Invalid Tag Value
            goto ErrorExit;
        }
    }
    lTotal += lth;

    //
    // Extract the length.
    //

    lth = ExtractLength(&pbSrc[lTotal], cbSrc-lTotal, &length, &fIndefinite);
    if (0 > lth)
        goto ErrorExit;
    if (fIndefinite && !fConstr)
    {
        TRACE("Indefinite length on primitive object")
        lth = -1;   // ?error? - Indefinite length on primitive object
        goto ErrorExit;
    }
    lTotal += lth;

    //
    // Extract the data.
    //

    lth = DecodeData(&pbSrc[lTotal], cbSrc-lTotal, length);
    if (0 > lth)
        goto ErrorExit;
    ASSERT((DWORD)lth == length);
    lTotal += lth;

    //
    // Extract any trailing tag.
    //

    if (fIndefinite)
    {
        lth = ExtractTag(&pbSrc[lTotal], cbSrc-lTotal, &tag, &fConstr);
        if (0 > lth)
            goto ErrorExit;
        if ((0 != tag) || (fConstr))
        {
            TRACE("Bad indefinite length encoding")
            lth = -1;   // ?Error? Bad indefinite length encoding.
            goto ErrorExit;
        }
        lTotal += lth;
    }


    //
    // Return the status.
    //

    return lTotal;

ErrorExit:
    return lth;
}


/*++

ChildAction:

    This method receives notification of actions from children.  The default
    action is to just propagate the action up the tree.

Arguments:

    action supplies the action identifier.

    pasnChild supplies the child address.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

void
CAsnObject::ChildAction(
    IN ChildActions action,
    IN CAsnObject *pasnChild)
{
    switch (action)
    {
    case act_Cleared:

        //
        // These actions are swallowed.
        //

        break;

    case act_Written:

        //
        // These actions are propagated.
        //

        if (NULL != m_pasnParent)
            m_pasnParent->ChildAction(action, this);
        break;

    default:
        ASSERT(FALSE);  // Don't propagate, but complain when debugging.
        break;
    }
}


/*++

SetDefault:

    This protected method is used to declare data that was just decoded to be
    the default data for the object.

Arguments:

    None

Return Value:

    >= 0 The length of the default data.
    < 0 implies an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::SetDefault(
    void)
{
    LONG lth;

    ASSERT(Complete());
    lth = Read(m_bfDefault);
    if (0 > lth)
        goto ErrorExit;
    Clear();
    m_dwFlags &= ~(fPresent | fOptional);
    m_dwFlags |= fDefault;

ErrorExit:
    return lth;
}


/*++

State:

    This routine checks to see if a structure is completely filled in.

Arguments:

    None

Return Value:

    fill_Empty   - There is no added data anywhere in the structure.
    fill_Present - All the data is present in the structure.
    fill_Partial - Not all of the data is there, but some of it is.
    fill_Defauted - No data has been written, but a default value is available.
    fill_Optional - No data has been written, but the object is optional.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CAsnObject::FillState
CAsnObject::State(
    void) const
{
    CAsnObject *pasn;
    DWORD index;
    DWORD count = m_rgEntries.Count();
    DWORD dwThereCount = 0,
          dwOptionalCount = 0;
    FillState result;

    for (index = 0; index < count; index += 1)
    {
        pasn = m_rgEntries[index];
        ASSERT(NULL != pasn);
        ASSERT(pasn != this);

        if (NULL == pasn)
            continue;

        result = pasn->State();
        switch (result)
        {
        case fill_NoElements:       // It's there if we want it to be.
            if (0 != ((fOptional | fDefault) & m_dwFlags))
                dwOptionalCount += 1;
            else
                dwThereCount += 1;
            break;

        case fill_Present:
            dwThereCount += 1;      // Count it as there.
            break;

        case fill_Partial:
            return fill_Partial;    // Some data under us is missing.
            break;

        case fill_Optional:
        case fill_Defaulted:
            dwOptionalCount += 1;   // Count it as conditionally there.
            break;

        case fill_Empty:
            break;                  // We have no data here.  Continue
        default:
            ASSERT(FALSE);
            break;
        }
    }

    if (0 == dwThereCount)
    {

        //
        // We're officially not here, either empty, defaulted, or optional.
        //

        if (0 != (fOptional & m_dwFlags))
            result = fill_Optional;     // We're optional.
        else if (0 != (fDefault & m_dwFlags))
            result = fill_Defaulted;    // We're defaulted.
        else if (0 == count)
            result = fill_NoElements;   // We just don't have children.
        else
            result = fill_Empty;        // We're empty.
    }
    else if (count == dwThereCount + dwOptionalCount)
    {

        //
        // Every element was filled in.  We can report that we're here.
        //

        result = fill_Present;
    }
    else
    {

        //
        // Not every element was filled in, but some of them were.  We're
        // partial.
        //

        result = fill_Partial;
    }
    ((CAsnObject *)this)->m_State = result;
    return result;
}


/*++

Complete:

    This routine determines if enough information exists within the ASN.1 Object
    for it to be generally useful.

Arguments:

    None

Return Value:

    TRUE - All data is filled in, either directly, or is optional or defaulted.
    FALSE - Not all fields have been filled in.

Author:

    Doug Barlow (dbarlow) 10/24/1995

--*/

BOOL
CAsnObject::Complete(
    void)
const
{
    BOOL fResult;

    switch (State())
    {
    case fill_Empty:
    case fill_Partial:
        fResult = FALSE;
        break;

    case fill_Optional:
    case fill_Defaulted:
    case fill_Present:
    case fill_NoElements:
        fResult = TRUE;
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        fResult = FALSE;
        break;
    }
    return fResult;
}


/*++

Exists:

    This routine determines if enough information exists within the ASN.1 Object
    for it to be specifically useful.

Arguments:

    None

Return Value:

    TRUE - All data is filled in, either directly, or is defaulted.
    FALSE - Not all fields have been filled in.  They may be optional.

Author:

    Doug Barlow (dbarlow) 10/24/1995

--*/

BOOL
CAsnObject::Exists(
    void)
const
{
    BOOL fResult;

    switch (State())
    {
    case fill_Empty:
    case fill_Partial:
    case fill_Optional:
        fResult = FALSE;
        break;

    case fill_Defaulted:
    case fill_Present:
    case fill_NoElements:
        fResult = TRUE;
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        fResult = FALSE;
        break;
    }
    return fResult;
}


/*++

Compare:

    This method compares this ASN.1 Object to another.

Arguments:

    asnObject supplies the other object for comparison.

Return Value:

    A value indicating a comparitive value:
    < 0 - This object is less than that object.
    = 0 - This object is the same as that object.
    > 0 - This object is more than that object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::Compare(
    const CAsnObject &asnObject)
const
{
    CAsnObject *pasn1, *pasn2;
    LONG lSame = 0x100; // Meaningless comparison
    LONG lCmp;
    DWORD index;
    DWORD count = asnObject.m_rgEntries.Count();

    if ((m_dwType == asnObject.m_dwType)
        && (m_rgEntries.Count() == count))
    {
        for (index = 0; index < count; index += 1)
        {
            pasn1 = m_rgEntries[index];
            ASSERT(NULL != pasn1);
            ASSERT(this != pasn1);

            if (NULL == pasn1)
                continue;

            pasn2 = asnObject.m_rgEntries[index];
            ASSERT(NULL != pasn2);
            ASSERT(&asnObject != pasn2);

            if (NULL == pasn2)
                continue;

            lCmp = pasn1->Compare(*pasn2);
            if (0 != lCmp)
                break;
        }
        if (index == count)
            lSame = 0;
        else
            lSame = lCmp;
    }
    return lSame;
}


/*++

Copy:

    This method replaces the contents of this ASN.1 Object with another.  The
    objects must be identical structures.  Tags and defaults are not duplicated.

Arguments:

    asnObject supplies the source object.

Return Value:

    >= 0 Is the number of bytes actually copied
    < 0 is an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::Copy(
    const CAsnObject &asnObject)
{
    LONG lth;
    Clear();
    asnObject.State();
    lth = _copy(asnObject);  // ?Exception? on error?
    ASSERT(0 <= lth);
    return lth;
}

LONG
CAsnObject::_copy(
    const CAsnObject &asnObject)
{
    CAsnObject *pasn1;
    const CAsnObject *pasn2;
    LONG lTotal = 0, lth = -1;
    DWORD index;
    DWORD count = asnObject.m_rgEntries.Count();

    if ((m_dwType == asnObject.m_dwType) && (m_rgEntries.Count() == count))
    {
        for (index = 0; index < count; index += 1)
        {
            pasn1 = m_rgEntries[index];
            ASSERT(NULL != pasn1);
            ASSERT(pasn1 != this);
            pasn2 = asnObject.m_rgEntries[index];
            ASSERT(NULL != pasn2);
            ASSERT(pasn1 != &asnObject);

            if (NULL == pasn2)
                continue;

            switch (pasn2->m_State)
            {
            case fill_Empty:
            case fill_Partial:
                TRACE("Incomplete structure in copy")
                lth = -1;   // ?Error? Incomplete structure
                break;

            case fill_Present:
            case fill_NoElements:
                if (NULL == pasn1)
                    continue;
                lth = pasn1->_copy(*pasn2);
                break;

            case fill_Defaulted:
            case fill_Optional:
                lth = 0;
                break;

            default:
                ASSERT(FALSE);   // ?error? Internal consistency check.
                lth = -1;
            }
            if (0 > lth)
                goto ErrorExit;
            lTotal += lth;
        }
    }
    else
    {
        TRACE("Copy Structure Mismatch")
        lth = -1;   // ?error? data type mismatch.
        goto ErrorExit;
    }
    return lTotal;

ErrorExit:
    return lth;
}


/*++

EncodeTag:

    This method encodes the tag of the object into the supplied buffer.

Arguments:

    pbDst receives the ASN.1 encoding of the tag.

Return Value:

    >= 0 is the length of the tag.
    < 0 is an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::EncodeTag(
    OUT LPBYTE pbDst)
const
{
    BYTE
        tagbuf[8],
        cls,
        cnstr;
    DWORD
        length,
        tag = Tag();
    LONG
        lth;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        TRACE("Incomplete Structure")
        return -1;       // ?error? Incomplete structure
        break;

    case fill_Optional:
    case fill_Defaulted:
        return 0;
        break;

    case fill_Present:
    case fill_NoElements:
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        return -1;
        break;
    }


    //
    // Break up the tag into its pieces.
    //

    cls = (BYTE)((tag & 0xc0000000) >> 24);
    tag &= 0x1fffffff;
    cnstr = (0 == (fConstructed & m_dwFlags)) ? 0 : 0x20;
    ASSERT((0 != tag) || (0 != cls));


    //
    //  Place a tag into the output buffer.
    //

    length = sizeof(tagbuf) - 1;
    if (31 > tag)
    {

        //
        //  Short form type encoding.
        //

        tagbuf[length] = (BYTE)tag;
    }
    else
    {

        //
        //  Long form type encoding.
        //

        tagbuf[length] = (BYTE)(tag & 0x7f);
        for (;;)
        {
            length -= 1;
            tag = (tag >> 7) & 0x01ffffff;
            if (0 == tag)
                break;
            tagbuf[length] = (BYTE)((tag & 0x7f) | 0x80);
        }
        tagbuf[length] = 31;
    }


    //
    // Place the tag type.
    //

    tagbuf[length] |= cls | cnstr;
    lth = sizeof(tagbuf) - length;
    memcpy(pbDst, &tagbuf[length], lth);
    return lth;
}


/*++

EncodeLength:

    This method encodes the definite length of the object into the supplied
    buffer.

Arguments:

    pbDst receives the ASN.1 encoding of the length.

    lSize supplies the size of the encoded data.

Return Value:

    >= 0 is the length of the resultant encoding
    < 0 is an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::EncodeLength(
    OUT LPBYTE pbDst)
const
{
    LONG lth, lTotal = 0;
    DWORD count, index;
    CAsnObject *pasn;


    //
    // This default implementation just encodes the data.
    //


    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        TRACE("Incomplete Structure")
        lth = -1;       // ?error? Incomplete Structure
        goto ErrorExit;
        break;

    case fill_Optional:
    case fill_Defaulted:
        lth = 0;
        break;

    case fill_Present:
    case fill_NoElements:
        count = m_rgEntries.Count();
        for (index = 0; index < count; index += 1)
        {
            pasn = m_rgEntries[index];
            ASSERT(NULL != pasn);
            ASSERT(pasn != this);

            if (pasn == NULL)
                continue;

            lth = pasn->_encLength();
            if (0 > lth)
                goto ErrorExit;
            lTotal += lth;
        }
        lth = EncodeLength(pbDst, lTotal);
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;

ErrorExit:
    return lth;
}

LONG
CAsnObject::EncodeLength(
    OUT LPBYTE pbDst,
    IN LONG lSize)
const
{
    BYTE
        lenbuf[8];
    DWORD
        length = sizeof(lenbuf) - 1;
    LONG
        lth;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        TRACE("Incomplete Object")
        lth = -1;       // ?error? Incomplete structure
        break;

    case fill_Optional:
    case fill_Defaulted:
        lth = 0;
        break;

    case fill_Present:
    case fill_NoElements:
        if (0x80 > lSize)
        {
            lenbuf[length] = (BYTE)lSize;
            lth = 1;
        }
        else
        {
            while (0 < lSize)
            {
                lenbuf[length] = (BYTE)(lSize & 0xff);
                length -= 1;
                lSize = (lSize >> 8) & 0x00ffffff;
            }
            lth = sizeof(lenbuf) - length;
            lenbuf[length] = (BYTE)(0x80 | (lth - 1));
        }

        memcpy(pbDst, &lenbuf[length], lth);
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

EncodeData:

    This method encodes the data into the supplied buffer.

Arguments:

    pbDst

Return Value:

    >= 0 is the length of the encoding.
    < 0 is an error

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::EncodeData(
    OUT LPBYTE pbDst)
const
{
    LONG lTotal = 0;
    LONG lth;
    CAsnObject *pasn;
    DWORD index;
    DWORD count = m_rgEntries.Count();

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        TRACE("Incomplete Structure")
        lth = -1;       // ?error? Incomplete structure
        goto ErrorExit;
        break;

    case fill_Optional:
    case fill_Defaulted:
    case fill_NoElements:
        break;

    case fill_Present:
        for (index = 0; index < count; index += 1)
        {
            pasn = m_rgEntries[index];
            ASSERT(NULL != pasn);
            ASSERT(pasn != this);

            if (NULL == pasn)
                continue;

            lth = pasn->_encode(&pbDst[lTotal]);
            if (0 > lth)
                goto ErrorExit;
            lTotal += lth;
        }
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        goto ErrorExit;
        break;
    }
    return lTotal;

ErrorExit:
    return lth;
}


/*++

DecodeData:

    This routine decodes the data portion of the ASN.1.  The tag and length have
    already been removed.

Arguments:

    pbSrc supplies the address of the ASN.1 encoding of the data.

    dwLength supplies the length of the data.


Return Value:

    >= 0 - The number of bytes removed from the input stream.
    <  0 - An error occurred.

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

LONG
CAsnObject::DecodeData(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc,
    IN DWORD dwLength)
{
    LONG lTotal = 0;
    LONG lth = -1;
    CAsnObject *pasn;
    DWORD index;
    DWORD count = m_rgEntries.Count();

    //
    // Decode the data.
    //

    for (index = 0; index < count; index += 1)
    {
        pasn = m_rgEntries[index];
        ASSERT(NULL != pasn);
        ASSERT(pasn != this);

        if (NULL == pasn)
            continue;

        if ((DWORD)lTotal < dwLength)
        {
            lth = pasn->_decode(&pbSrc[lTotal],cbSrc-lTotal);
            if (0 > lth)
                goto ErrorExit;
            lTotal += lth;

            if ((DWORD)lTotal > dwLength)
            {
                TRACE("Decoding Overrun")
                lth = -1;   // ?error? Decoding overrun.
                goto ErrorExit;
            }
        }
        else
        {
            if (0 == (pasn->m_dwFlags & (fOptional | fDefault)))
            {
                TRACE("Incomplete construction")
                lth = -1;   // ?error? Incomplete construction
                goto ErrorExit;
            }
        }
    }
    if ((DWORD)lTotal != dwLength)
    {
        TRACE("Decoding length mismatch")
        lth = -1;   // ?error? Decoding length mismatch.
        goto ErrorExit;
    }
    return lTotal;

ErrorExit:
    return lth;
}


/*++

TypeCompare:

    This routine compares the entire structure of an Object to another Object.

Arguments:

    asn - The other object.

Return Value:

    TRUE - They are identical
    FALSE - They differ

Author:

    Doug Barlow (dbarlow) 10/19/1995

--*/

BOOL
CAsnObject::TypeCompare(
    const CAsnObject &asnObject)
const
{
    CAsnObject *pasn1, *pasn2;
    DWORD index;
    DWORD count = m_rgEntries.Count();

    //
    // See if we really have anything to do.
    //

    if (m_dwType != asnObject.m_dwType)
        goto ErrorExit;
    if (count != asnObject.m_rgEntries.Count())
        goto ErrorExit;


    //
    // Recursively compare the types.
    //

    for (index = 0; index < count; index += 1)
    {
        pasn1 = m_rgEntries[index];
        ASSERT(NULL != pasn1);
        ASSERT(pasn1 != this);

        if (NULL == pasn1)
            continue;

        pasn2 = asnObject.m_rgEntries[index];
        ASSERT(NULL != pasn2);
        ASSERT(pasn1 != &asnObject);

        if (NULL == pasn2)
            continue;

        if (!pasn1->TypeCompare(*pasn2))
            goto ErrorExit;
    }
    return TRUE;

ErrorExit:
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\asn1\asntext.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asnText

Abstract:

    This module provides the implementation for the base class of Text based
    ASN.1 objects.

Author:

    Doug Barlow (dbarlow) 10/9/1995

Environment:

    Win32

Notes:

--*/

#include <windows.h>
#include "asnPriv.h"

IMPLEMENT_NEW(CAsnTextString)

BOOL
CAsnTextString::CheckString(
    const BYTE FAR *pch,
    DWORD cbString,
    DWORD length)
const
{
    DWORD idx, index, offset;

    if (NULL != m_pbmValidChars)
    {
        for (idx = 0; idx < length; idx += 1, cbString -= 1)
        {
            if (cbString < sizeof(BYTE))
            {
                return FALSE;
            }

            index = pch[idx] / 32;
            offset = pch[idx] % 32;
            if (0 == (((*m_pbmValidChars)[index] >> offset) & 1))
                return FALSE;
        }
    }
    return TRUE;
}

CAsnTextString::operator LPCSTR(
    void)
{
    LPCSTR sz = NULL;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        sz = NULL;      // ?error? Incomplete structure
        break;

    case fill_Defaulted:
        if (NULL == m_bfDefault.Append((LPBYTE)"\000", 1))
            goto ErrorExit;
        
        if (NULL == m_bfDefault.Resize(m_bfDefault.Length() - 1, TRUE))
            goto ErrorExit;

        sz = (LPCSTR)m_bfDefault.Access();
        break;

    case fill_Present:
        if (NULL == m_bfData.Append((LPBYTE)"\000", 1))
            goto ErrorExit;

        if (NULL == m_bfData.Resize(m_bfData.Length() - 1, TRUE))
            goto ErrorExit;

        sz = (LPCSTR)m_bfData.Access();
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        sz = NULL;
        break;
    }

ErrorExit:
    return sz;
}

CAsnTextString &
CAsnTextString::operator =(
    LPCSTR szSrc)
{
    LONG lth = Write((LPBYTE)szSrc, strlen(szSrc));
    ASSERT(0 > lth); // ?error? Per return lth -- maybe a throw?
    return *this;
}

CAsnTextString::CAsnTextString(
    IN DWORD dwFlags,
    IN DWORD dwTag,
    IN DWORD dwType)
:   CAsnPrimitive(dwFlags, dwTag, dwType),
    m_pbmValidChars(NULL)
{ /* Init as Primitive */ }

LONG
CAsnTextString::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen)
{
    if (!CheckString(pbSrc, cbSrcLen, cbSrcLen))
    {
        TRACE("Invalid character for string type")
        goto ErrorExit; // ?error? Invalid Character in string.
    }
    if (NULL == m_bfData.Presize(cbSrcLen + 1))
        goto ErrorExit;

    CAsnPrimitive::Write(pbSrc, cbSrcLen);
    if (NULL == m_bfData.Append((LPBYTE)"\000", 1))
        goto ErrorExit;

    if (NULL == m_bfData.Resize(cbSrcLen, TRUE))
        goto ErrorExit;

    return cbSrcLen;

ErrorExit:
    return -1;
}

LONG
CAsnTextString::DecodeData(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc,
    IN DWORD dwLength)
{
    LONG lth;

    if (!CheckString(pbSrc, cbSrc, dwLength))
    {
        TRACE("Invalid character for string type in incoming stream")
        goto ErrorExit; // ?error? Invalid Character in string.
    }

    if (NULL == m_bfData.Presize(dwLength + 1))
        goto ErrorExit;

    lth = CAsnPrimitive::DecodeData(pbSrc, cbSrc, dwLength);
    if (NULL == m_bfData.Append((LPBYTE)TEXT("\000"), sizeof(TCHAR)))
        goto ErrorExit;

    if (NULL == m_bfData.Resize(dwLength))
        goto ErrorExit;

    return lth;

ErrorExit:
    Clear();
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\asn1\msasnlib.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    msasnlib

Abstract:

    This module provides the primary services of the MS ASN.1 Library.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32

Notes:

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

#if !defined(OS_WINCE)
#include <basetsd.h>
#endif

#include "asnPriv.h"

#ifdef OS_WINCE
// We have a private version of strtoul() for CE since it's not supported
// there.
extern "C" unsigned long __cdecl strtoul(const char *nptr, char **endptr, int ibase);
#endif

//
//==============================================================================
//
//  CAsnBoolean
//

IMPLEMENT_NEW(CAsnBoolean)


CAsnBoolean::CAsnBoolean(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnPrimitive(dwFlags, dwTag, type_Boolean)
{ /* Force the type to type_Boolean */ }

LONG
CAsnBoolean::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen)
{
    BYTE rslt;
    if (1 != cbSrcLen)
    {
        TRACE("BOOLEAN Value longer than one byte")
        return -1;  // ?error? Invalid value
    }
    rslt = 0 != *pbSrc ? 0xff : 0;
    return CAsnPrimitive::Write(&rslt, 1);
}

CAsnBoolean::operator BOOL(void)
const
{
    BOOL result;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete BOOLEAN value")
        result = FALSE; // ?throw? error.
        break;

    case fill_Present:
        result = (0 != *m_bfData.Access());
        break;

    case fill_Defaulted:
        result = (0 != *m_bfDefault.Access());
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        result = FALSE;
        break;
    }
    return result;
}

BOOL
CAsnBoolean::operator =(
    BOOL fValue)
{
    BYTE rslt = 0 != fValue ? 0xff : 0;
    CAsnPrimitive::Write(&rslt, 1);
    return fValue;
}

CAsnObject *
CAsnBoolean::Clone(
    IN DWORD dwFlags)
const
{ return new CAsnBoolean(dwFlags, m_dwTag); }

LONG
CAsnBoolean::DecodeData(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc,
    IN DWORD dwLength)
{
    if (1 != dwLength)
    {
        TRACE("Decoded BOOLEAN Value longer than one byte")
        return -1;  // ?error? Invalid value
    }
    return CAsnPrimitive::DecodeData(pbSrc, cbSrc, dwLength);
}


//
//==============================================================================
//
//  CAsnInteger
//

IMPLEMENT_NEW(CAsnInteger)


CAsnInteger::CAsnInteger(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnPrimitive(dwFlags, dwTag, type_Integer)
{ /* Force the type to type_Integer */ }

LONG
CAsnInteger::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen)
{
    if (0 < cbSrcLen)
    {
        if (NULL == m_bfData.Set(pbSrc, cbSrcLen))
            goto ErrorExit;  // ?error? Propagate No Memory
    }
    else
    {
        TRACE("Attempt to write a Zero Length integer")
        return -1;
    }
    m_dwFlags |= fPresent;
    if (NULL != m_pasnParent)
        m_pasnParent->ChildAction(act_Written, this);
    return m_bfData.Length();

ErrorExit:
    return -1;
}

LONG
CAsnInteger::Write(
    IN const DWORD *pdwSrc,
    IN DWORD cdwSrcLen)
{
#if defined(OS_WINCE)
    size_t length;
#else
    SIZE_T length;
#endif

    LPBYTE pbBegin = (LPBYTE)pdwSrc;
    LPBYTE pbEnd = (LPBYTE)(&pdwSrc[cdwSrcLen]);
    while (0 == *(--pbEnd));   // Note semi-colon here!
    length = pbEnd - pbBegin + 1;

    if (0 < cdwSrcLen)
    {
        if (0 != (*pbEnd & 0x80))
        {
            if (NULL == m_bfData.Resize((DWORD)length + 1))
                return -1;  // Propagate memory error.
            pbBegin = m_bfData.Access();
            *pbBegin++ = 0;
        }
        else
        {
            if (NULL == m_bfData.Resize((DWORD)length))
                return -1;  // Propagate memory error.
            pbBegin = m_bfData.Access();
        }
        while (0 < length--)
            *pbBegin++ = *pbEnd--;
        m_dwFlags |= fPresent;
        if (NULL != m_pasnParent)
            m_pasnParent->ChildAction(act_Written, this);
        return m_bfData.Length();
    }
    else
    {
        TRACE("Attempt to write a Zero Length integer")
        return -1;
    }
}

CAsnInteger::operator LONG(
    void)
const
{
    DWORD index;
    LPBYTE pbVal;
    LONG lResult;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete INTEGER")
        return -1;  // ?error? Undefined value

    case fill_Present:
        pbVal = m_bfData.Access();
        index = m_bfData.Length();
        break;

    case fill_Defaulted:
        pbVal = m_bfDefault.Access();
        index = m_bfDefault.Length();
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        return -1;
        break;
    }

    if (sizeof(LONG) < index)
    {
        TRACE("INTEGER Overflow")
        return -1;  // ?error? Integer overflow.
    }

    if (NULL == pbVal)
    {
        ASSERT(FALSE);  // ?error? invalid object
        return -1;
    }

    lResult = (0 != (0x80 & *pbVal)) ? -1 : 0;
    while (0 < index)
    {
        index -= 1;

        lResult <<= 8;

        lResult |= (ULONG)pbVal[index];
    }
    return lResult;
}

CAsnInteger::operator ULONG(
    void)
const
{
    DWORD index, len;
    LPBYTE pbVal;
    ULONG lResult = 0;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete INTEGER")
        return (ULONG)(-1);  // ?error? Undefined value

    case fill_Present:
        pbVal = m_bfData.Access();
        len = m_bfData.Length();
        break;

    case fill_Defaulted:
        pbVal = m_bfDefault.Access();
        len = m_bfDefault.Length();
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        return (ULONG)(-1);
        break;
    }

    if (sizeof(ULONG) < len)
    {
        TRACE("INTEGER Overflow")
        return (ULONG)(-1);  // ?error? Integer overflow.
    }

    for (index = 0; index < len; index += 1)
    {
        lResult <<= 8;
        lResult |= (ULONG)pbVal[index];
    }
    return lResult;
}

LONG
CAsnInteger::operator =(
    LONG lValue)
{
    BYTE nval[sizeof(LONG) + 2];
    DWORD index, nLength;
    LONG isSigned;


    index = sizeof(nval);

    for (DWORD i = 0; i < index; i++)
        nval[i] = (BYTE)0;

    if ((0 == lValue) || (-1 == lValue))
    {
        nval[--index] = (BYTE)(lValue & 0xff);
    }
    else
    {
        isSigned = lValue;

        while (0 != lValue)
        {
            nval[--index] = (BYTE)(lValue & 0xff);
            lValue >>= 8;
        }
        if (0 > isSigned)
        {
            while ((index < sizeof(nval) - 1) && (0xff == nval[index]) && (0 != (0x80 & nval[index + 1])))
                index += 1;
        }
        else
        {
            if (0 != (0x80 & nval[index]))
                nval[--index] = 0;
        }
    }

    nLength = sizeof(nval) - index;
    CAsnPrimitive::Write(&nval[index], nLength);
    return lValue;
}

ULONG
CAsnInteger::operator =(
    ULONG lValue)
{
    BYTE nval[sizeof(ULONG) + 2];
    DWORD index, nLength;
    ULONG lVal = lValue;


    index = sizeof(nval);
    if (0 == lVal)
    {
        nval[--index] = 0;
    }
    else
    {
        while (0 != lVal)
        {
            nval[--index] = (BYTE)(lVal & 0xff);
            lVal >>= 8;
        }
        if (0 != (0x80 & nval[index]))
            nval[--index] = 0;
    }

    nLength = sizeof(nval) - index;
    Write(&nval[index], nLength);
    return lValue;
}

CAsnObject *
CAsnInteger::Clone(
    IN DWORD dwFlags)
const
{ return new CAsnInteger(dwFlags, m_dwTag); }


//
//==============================================================================
//
//  CAsnBitstring
//

IMPLEMENT_NEW(CAsnBitstring)


CAsnBitstring::CAsnBitstring(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnPrimitive(dwFlags, dwTag, type_Bitstring)
{ /* Force the type to type_Bitstring */ }

LONG
CAsnBitstring::DataLength(
    void)
const
{
    LONG lth;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete BIT STRING")
        lth = -1;  // ?error? No value.
        break;

    case fill_Present:
        lth = m_bfData.Length() - 1;
        break;

    case fill_Defaulted:
        lth = m_bfDefault.Length() - 1;
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}

LONG
CAsnBitstring::Read(
    OUT CBuffer &bfDst,
    OUT int *offset)
const
{
    LONG lth;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete BIT STRING")
        lth = -1;  // ?error? No value.
        break;

    case fill_Present:
        if (NULL != offset)
            *offset = *m_bfData.Access();
        if (NULL == bfDst.Set(m_bfData.Access(1), m_bfData.Length() - 1))
            goto ErrorExit;

        lth = bfDst.Length();
        break;

    case fill_Defaulted:
        if (NULL != offset)
            *offset = *m_bfDefault.Access();
        if (NULL == bfDst.Set(m_bfDefault.Access(1), m_bfDefault.Length() - 1))
            goto ErrorExit;

        lth = bfDst.Length();
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;

ErrorExit:
    return -1;
}

LONG
CAsnBitstring::Read(
    OUT LPBYTE pbDst,
    OUT int *offset)
const
{
    LONG lth;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete BIT STRING")
        lth = -1;  // ?error? No value.
        break;

    case fill_Defaulted:
        if (NULL != offset)
            *offset = *m_bfDefault.Access();
        lth = m_bfDefault.Length() - 1;
        memcpy(pbDst, m_bfDefault.Access(1), lth);
        break;

    case fill_Present:
        if (NULL != offset)
            *offset = *m_bfData.Access();
        lth = m_bfData.Length() - 1;
        memcpy(pbDst, m_bfData.Access(1), lth);
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}

LONG
CAsnBitstring::Write(
    IN const CBuffer &bfSrc,
    IN int offset)
{
    return Write(bfSrc.Access(), bfSrc.Length(), offset);
}

LONG
CAsnBitstring::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen,
    IN int offset)
{
    BYTE val;
    if ((7 < offset) || (0 > offset))
    {
        TRACE("BIT STRING Unused bit count invalid")
        return -1;  // ?error? invalid parameter
    }
    val = (BYTE)offset;
    if (NULL == m_bfData.Presize(cbSrcLen + 1))
        goto ErrorExit;

    if (NULL == m_bfData.Set(&val, 1))
        goto ErrorExit;

    if (NULL == m_bfData.Append(pbSrc, cbSrcLen))
        goto ErrorExit;

    m_dwFlags |= fPresent;
    if (NULL != m_pasnParent)
        m_pasnParent->ChildAction(act_Written, this);
    return m_bfData.Length() - 1;

ErrorExit:
    return -1;
}

CAsnObject *
CAsnBitstring::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnBitstring(dwFlags, m_dwTag);
}


//
//==============================================================================
//
//  CAsnOctetstring
//

IMPLEMENT_NEW(CAsnOctetstring)


CAsnOctetstring::CAsnOctetstring(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnPrimitive(dwFlags, dwTag, type_Octetstring)
{ /* Force the type to type_Octetstring */ }

CAsnObject *
CAsnOctetstring::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnOctetstring(dwFlags, m_dwTag);
}


//
//==============================================================================
//
//  CAsnNull
//

IMPLEMENT_NEW(CAsnNull)


CAsnNull::CAsnNull(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnPrimitive(dwFlags, dwTag, type_Null)
{
    m_dwFlags |= fPresent;
}

void
CAsnNull::Clear(
    void)
{
    CAsnPrimitive::Clear();
    m_dwFlags |= fPresent;
}

LONG
CAsnNull::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen)
{
    if (0 == cbSrcLen)
    {
        if (NULL != m_pasnParent)
            m_pasnParent->ChildAction(act_Written, this);
        return 0;
    }
    else
    {
        TRACE("Attempt to write data to a NULL")
        return -1; // ?error? invalid length
    }
}

CAsnObject *
CAsnNull::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnNull(dwFlags, m_dwTag);
}

LONG
CAsnNull::DecodeData(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc,
    IN DWORD dwLength)
{
    if (0 != dwLength)
    {
        TRACE("NULL datum has non-zero length")
        return -1;  // ?error? Invalid length.
    }
    return CAsnPrimitive::DecodeData(pbSrc, cbSrc, dwLength);
}


//
//==============================================================================
//
//  CAsnObjectIdentifier
//

IMPLEMENT_NEW(CAsnObjectIdentifier)


CAsnObjectIdentifier::CAsnObjectIdentifier(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnPrimitive(dwFlags, dwTag, type_ObjectIdentifier)
{ /* Force type type to type_ObjectIdentifier */ }

CAsnObjectIdentifier::operator LPCTSTR(
    void)
const
{
    TCHAR numbuf[36];
    DWORD dwVal, dwLength, index;
    BYTE c;
    LPBYTE pbValue;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete OBJECT IDENTIFIER")
        return NULL;    // ?error? Incomplete value.
        break;

    case fill_Defaulted:
        dwLength = m_bfDefault.Length();
        pbValue = m_bfDefault.Access();
        break;

    case fill_Present:
        dwLength = m_bfData.Length();
        pbValue = m_bfData.Access();
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        return NULL;
        break;
    }

    ASSERT(0 < dwLength);    // Invalid Object Id.

    if (NULL == pbValue)
    {
        ASSERT(FALSE);  // ?error? Invalid object
        return NULL;
    }

    dwVal = *pbValue / 40;
    _ultoa(dwVal, ( char * )numbuf, 10);
    if (NULL == ((CAsnObjectIdentifier *)this)->m_bfText.Set(
                                                             (LPBYTE)numbuf, strlen( ( char * )numbuf) * sizeof(CHAR)))
        goto ErrorExit;

    dwVal = *pbValue % 40;
    _ultoa(dwVal, ( char * )numbuf, 10);
    if (NULL == ((CAsnObjectIdentifier *)this)->m_bfText.Append(
                                                                (LPBYTE)".", sizeof(CHAR)))
        goto ErrorExit;

    if (NULL == ((CAsnObjectIdentifier *)this)->m_bfText.Append(
                                                                (LPBYTE)numbuf, strlen( ( char * )numbuf) * sizeof(CHAR)))
        goto ErrorExit;

    dwVal = 0;
    for (index = 1; index < dwLength; index += 1)
    {
        c = pbValue[index];
        dwVal = (dwVal << 7) + (c & 0x7f);
        if (0 == (c & 0x80))
        {
            _ultoa(dwVal, ( char * )numbuf, 10);
            if (NULL == ((CAsnObjectIdentifier *)this)->m_bfText.Append(
                                                                        (LPBYTE)".", sizeof(CHAR)))
                goto ErrorExit;

            if (NULL == ((CAsnObjectIdentifier *)this)->m_bfText.Append(
                                                                        (LPBYTE)numbuf, strlen( ( char * )numbuf) * sizeof(CHAR)))
                goto ErrorExit;

            dwVal = 0;
        }
    }
    if (NULL == ((CAsnObjectIdentifier *)this)->m_bfText.Append(
                                                                (LPBYTE)"", sizeof(CHAR)))
        goto ErrorExit;

    return (LPTSTR)m_bfText.Access();

ErrorExit:
    return NULL;
}



LPCTSTR
CAsnObjectIdentifier::operator =(
    IN LPCTSTR szValue)
{
    BYTE oidbuf[sizeof(DWORD) * 2];
    DWORD dwVal1, dwVal2;
    LPCTSTR sz1, sz2;
    CBuffer bf;

    if (NULL == bf.Presize(strlen( ( char * )szValue)))
        return NULL;    // ?error? No memory
    sz1 = szValue;
    dwVal1 = strtoul( ( char * )sz1, (LPSTR *)&sz2, 0);
    if (TEXT('.') != *sz2)
    {
        TRACE("OBJECT ID contains strange character '" << *sz2 << "'.")
        return NULL;    // ?error? invalid Object Id string.
    }
    sz1 = sz2 + 1;
    dwVal2 = strtoul( ( char * )sz1, (LPSTR *)&sz2, 0);
    if ((TEXT('.') != *sz2) && (0 != *sz2))
    {
        TRACE("OBJECT ID contains strange character '" << *sz2 << "'.")
        return NULL;    // ?error? invalid Object Id string.
    }
    dwVal1 *= 40;
    dwVal1 += dwVal2;
    if (127 < dwVal1)
    {
        TRACE("OBJECT ID Leading byte is too big")
        return NULL;    // ?error? invalid Object Id string.
    }
    *oidbuf = (BYTE)dwVal1;
    if (NULL == bf.Set(oidbuf, 1))
        goto ErrorExit;

    while (TEXT('.') == *sz2)
    {
        sz1 = sz2 + 1;
        dwVal1 = strtoul( ( char * )sz1, (LPSTR *)&sz2, 0);

        dwVal2 = sizeof(oidbuf);
        oidbuf[--dwVal2] = (BYTE)(dwVal1 & 0x7f);
        for (;;)
        {
            dwVal1 = (dwVal1 >> 7) & 0x01ffffff;
            if ((0 == dwVal1) || (0 == dwVal2))
                break;

            oidbuf[--dwVal2] = (BYTE)((dwVal1 & 0x7f) | 0x80);
        }

        if (NULL == bf.Append(&oidbuf[dwVal2], sizeof(oidbuf) - dwVal2))
            goto ErrorExit;
    }
    if (0 != *sz2)
    {
        TRACE("OBJECT ID contains strange character '" << *sz2 << "'.")
        return NULL;    // ?error? invalid Object Id string.
    }

    if (0 > Write(bf.Access(), bf.Length()))
        return NULL;    // ?error? forwarding underlying error.
    return szValue;

ErrorExit:
    return NULL;
}

CAsnObject *
CAsnObjectIdentifier::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnObjectIdentifier(dwFlags, m_dwTag);
}


//
//==============================================================================
//
//  CAsnReal
//

IMPLEMENT_NEW(CAsnReal)


CAsnReal::CAsnReal(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnPrimitive(dwFlags, dwTag, type_Real)
{ /* Force the type to type_Real */ }

CAsnReal::operator double(
    void)
const
{
    // ?todo?
    return 0.0;
}

double
CAsnReal::operator =(
    double rValue)
{
    // ?todo?
    return 0.0;
}

CAsnObject *
CAsnReal::Clone(              // Create an identical object type.
    IN DWORD dwFlags)
const
{
    return new CAsnReal(dwFlags, m_dwTag);
}


//
//==============================================================================
//
//  CAsnEnumerated
//

IMPLEMENT_NEW(CAsnEnumerated)


CAsnEnumerated::CAsnEnumerated(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnPrimitive(dwFlags, dwTag, type_Enumerated)
{ /* Force the type to type_Enumerated */ }

// ?todo?  What's this?

CAsnObject *
CAsnEnumerated::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnEnumerated(dwFlags, m_dwTag);
}


//
//==============================================================================
//
//  CAsnSequence
//

IMPLEMENT_NEW(CAsnSequence)


CAsnSequence::CAsnSequence(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnConstructed(dwFlags, dwTag, type_Sequence)
{ /* Force the type to type_Sequence */ }


//
//==============================================================================
//
//  CAsnSequenceOf
//

IMPLEMENT_NEW(CAsnSequenceOf)


CAsnSequenceOf::CAsnSequenceOf(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnSeqsetOf(dwFlags, dwTag, type_SequenceOf)
{ /* Force the type to type_SequenceOf */ }


//
//==============================================================================
//
//  CAsnSet
//

IMPLEMENT_NEW(CAsnSet)


CAsnSet::CAsnSet(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnConstructed(dwFlags, dwTag, type_Set)
{ /* Force the type to type_Set */ }


//
//==============================================================================
//
//  CAsnSetOf
//

IMPLEMENT_NEW(CAsnSetOf)


CAsnSetOf::CAsnSetOf(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnSeqsetOf(dwFlags, dwTag, type_SetOf)
{ /* Force the type to type_SetOf */ }


//
//==============================================================================
//
//  CAsnTag
//

IMPLEMENT_NEW(CAsnTag)


CAsnTag::CAsnTag(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnConstructed(dwFlags, dwTag, type_Tag)
{ /* Force the type to type_Tag */ }

void
CAsnTag::Reference(
    CAsnObject *pasn)
{
    ASSERT(0 == m_rgEntries.Count());
    m_rgEntries.Add(pasn);
}

CAsnObject *
CAsnTag::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnTag(dwFlags, m_dwTag);
}

LONG
CAsnTag::DataLength(
    void) const
{
    CAsnObject *pasn = m_rgEntries[0];
    ASSERT(NULL != pasn);

    if (pasn == NULL)
        return NULL;

    return pasn->DataLength();
}

LONG
CAsnTag::Read(
    OUT LPBYTE pbDst)
const
{
    CAsnObject *pasn = m_rgEntries[0];
    ASSERT(NULL != pasn);

    if (pasn == NULL)
        return NULL;

    return pasn->Read(pbDst);
}


LONG
CAsnTag::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen)
{
    CAsnObject *pasn = m_rgEntries[0];
    ASSERT(NULL != pasn);

    if (pasn == NULL)
        return NULL;

    return pasn->Write(pbSrc, cbSrcLen);
}


//
//==============================================================================
//
//  CAsnChoice
//

IMPLEMENT_NEW(CAsnChoice)


/*++

CAsnChoice:

    This is the construction routine for a CAsnChoice.

Arguments:

    dwFlags supplies any special flags for this object.  Options are:

        fOptional implies the object is optional.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CAsnChoice::CAsnChoice(
        IN DWORD dwFlags)
:   CAsnObject(dwFlags, tag_Undefined, type_Choice)
{
    m_nActiveEntry = (DWORD)(-1);
    m_dwDefaultTag = tag_Undefined;
}


/*++

Tag:

    This routine returns the tag value of the object.

Arguments:

    None

Return Value:

    The tag, if known, or zero if not.

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

DWORD
CAsnChoice::Tag(
    void)
const
{
    DWORD result;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        result = tag_Undefined; // ?error? Undefined tag
        break;

    case fill_Defaulted:
        result = m_dwDefaultTag;
        break;

    case fill_Partial:
    case fill_Present:
        result = m_rgEntries[m_nActiveEntry]->Tag();
        break;

    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        result = tag_Undefined;
        break;
    }
    return result;
}


/*++

DataLength:

    This routine returns the length of the local machine encoding of the data of
    an object.

Arguments:

    None

Return Value:

    If >=0, the length of the data portion of this object.
    if < 0, an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::DataLength(
    void)
const
{
    LONG lth;

    switch (State())
    {
    case fill_Empty:
    case fill_Partial:
    case fill_Optional:
    case fill_NoElements:
        TRACE("Incomplete CHOICE")
        lth =  -1;  // ?error? incomplete structure.
        break;

    case fill_Defaulted:
        lth = m_bfDefault.Length();
        break;

    case fill_Present:
        lth = m_rgEntries[m_nActiveEntry]->DataLength();
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

Read:

    Read the value of the object.

Arguments:

    bfDst receives the value.
    pbDst receives the value.  It is assumed to be long enough.

Return Value:

    If >=0, the length of the data portion of this object.
    if < 0, an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::Read(
    OUT LPBYTE pbDst)
    const
{
    LONG lth;

    switch (State())
    {
    case fill_Empty:
    case fill_Partial:
    case fill_NoElements:
        TRACE("Incomplete CHOICE")
        lth =  -1;  // ?error? incomplete structure.
        break;

    case fill_Optional:
        lth = 0;
        break;

    case fill_Defaulted:
        lth = m_bfDefault.Length();
        memcpy(pbDst, m_bfDefault.Access(), lth);
        break;

    case fill_Present:
        lth = m_rgEntries[m_nActiveEntry]->Read(pbDst);
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

Write:

    This method examines the tag of the presented data, and forwards it to the
    right choice.

Arguments:

    pbSrc supplies the data as a BYTE array, with
    cbSrcLen supplies the length of the pbSrc Array.

Return Value:

    If >=0, the length of the data portion of this object.
    if < 0, an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen)
{
    LONG lth;
    Clear();
    lth = _decode(pbSrc,cbSrcLen);
    if ((0 < lth) && ((DWORD)lth == cbSrcLen))
        return lth;
    else
    {
        TRACE("CHOICE Buffer length error")
        return -1;  // ?error? Buffer mismatch.
    }
}


/*++

EncodingLength:

    This method returns the length of the object in its ASN.1 encoding.

Arguments:

    None

Return Value:

    >= 0 is the length of the object's ASN.1 encoding.
    < 0 implies an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::_encLength(
    void) const
{
    LONG lth;

    switch (m_State)
    {
    case fill_Partial:
    case fill_Empty:
    case fill_NoElements:
        lth = -1;       // ?error? Incomplete structure
        break;

    case fill_Optional:
    case fill_Defaulted:
        lth = 0;
        break;

    case fill_Present:
        lth = m_rgEntries[m_nActiveEntry]->_encLength();
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

Decode:

    This method examines the tag of the presented data, and forwards it to the
    right choice.

Arguments:

    pbSrc supplies the ASN.1 encoding in an LPBYTE format.
    bfSrc supplies the ASN.1 encoding in a CBuffer format.

Return Value:

    >= 0 is the number of bytes consumed by the decoding.
    < 0 implies an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::_decode(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc)
{
    DWORD tag, length, index;
    LONG lth, lTotal = 0;
    BOOL fImplicit, fConstr;
    CAsnObject *pasn;
    DWORD count = m_rgEntries.Count();

    lth = ExtractTag(&pbSrc[lTotal], cbSrc - lTotal, &tag, &fConstr);
    if (0 > lth)
        goto ErrorExit;
    lTotal += lth;

    lth = ExtractLength(&pbSrc[lTotal], cbSrc - lTotal, &length, &fImplicit);
    if (0 > lth)
        goto ErrorExit;
    lTotal += lth;

    for (index = 0; index < count; index += 1)
    {
        pasn = m_rgEntries[index];
        if (NULL != pasn)
        {
            if ((tag == pasn->m_dwTag)
                && (fConstr == (0 != (pasn->m_dwFlags & fConstructed))))
            {
                lth = pasn->DecodeData(&pbSrc[lTotal], cbSrc - lTotal, length);
                if (0 > lth)
                    goto ErrorExit;
                lTotal += lth;
                break;
            }
        }
    }
    if (index == count)
    {
        TRACE("Unrecognized Tag in input stream")
        lth = -1;   // ?error? Unrecognized tag
        goto ErrorExit;
    }

    if (m_nActiveEntry != index)
    {
        // This may have been done already by the action callback.
        pasn = m_rgEntries[m_nActiveEntry];
        if (NULL != pasn)
            pasn->Clear();  // That may do a callback, too.
        m_nActiveEntry = index;
    }
    return lTotal;

ErrorExit:
    return lth;
}


/*++

ChildAction:

    This method receives notification of actions from children.

Arguments:

    action supplies the action identifier.

    pasnChild supplies the child address.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

void
CAsnChoice::ChildAction(
    IN ChildActions action,
    IN CAsnObject *pasnChild)
{
    DWORD index, count;
    CAsnObject *pasn;

    if (act_Written == action)
    {

        //
        // When a child entry gets written, make sure it becomes the active
        // entry.
        //

        count = m_rgEntries.Count();
        for (index = 0; index < count; index += 1)
        {
            pasn = m_rgEntries[index];
            if (pasnChild == pasn)
                break;
        }
        ASSERT(index != count);

        if (m_nActiveEntry != index)
        {
            pasn = m_rgEntries[m_nActiveEntry];
            if (NULL != pasn)
                pasn->Clear();  // That may do a callback, too.
            m_nActiveEntry = index;
        }
    }
    CAsnObject::ChildAction(action, this);
}


/*++

SetDefault:

    This protected method is used to declare data that was just decoded to be
    the default data for the object.

Arguments:

    None

Return Value:

    >= 0 The length of the default data.
    < 0 implies an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::SetDefault(
    void)
{
    LONG lth;
    CAsnObject *pasn = m_rgEntries[m_nActiveEntry];
    ASSERT(NULL != pasn);

    if (pasn == NULL)
        return -1;

    m_dwDefaultTag = pasn->Tag();
    lth = CAsnObject::SetDefault();
    return lth;
}


/*++

State:

    This routine checks to see if a structure is completely filled in.

Arguments:

    None

Return Value:

    fill_Empty   - There is no added data anywhere in the structure.
    fill_Present - All the data is present in the structure (except maybe
                   defaulted or optional data).
    fill_Partial - Not all of the data is there, but some of it is.
    fill_Defauted - No data has been written, but a default value is available.
    fill_Optional - No data has been written, but the object is optional.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CAsnObject::FillState
CAsnChoice::State(
    void) const
{
    FillState result;
    if (m_nActiveEntry >= m_rgEntries.Count())
    {
        if (0 != (fOptional & m_dwFlags))
            result = fill_Optional;
        else if (0 != (fDefault & m_dwFlags))
            result = fill_Defaulted;
        else
            result = fill_Empty;
    }
    else
        result = m_rgEntries[m_nActiveEntry]->State();
    ((CAsnChoice *)this)->m_State = result;
    return result;
}


/*++

Compare:

    This method compares this ASN.1 Object to another.

Arguments:

    asnObject supplies the other object for comparison.

Return Value:

    A value indicating a comparitive value:
    < 0 - This object is less than that object.
    = 0 - This object is the same as that object.
    > 0 - This object is more than that object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::Compare(
    const CAsnObject &asnObject)
const
{
    LONG lth;

    switch (State())
    {
    case fill_Empty:
    case fill_Partial:
    case fill_Optional:
    case fill_NoElements:
    case fill_Defaulted:
        lth = 0x0100;   // ?error? Incapable of comparing.
        break;

    case fill_Present:
        lth = m_rgEntries[m_nActiveEntry]->Compare(asnObject);
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = 0x0100;
        break;
    }
    return lth;
}


/*++

Copy:

    This method replaces the contents of this ASN.1 Object with another.  The
    objects must be identical structures.  Tags and defaults are not duplicated.

Arguments:

    asnObject supplies the source object.

Return Value:

    >= 0 Is the number of bytes actually copied
    < 0 is an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::_copy(
    const CAsnObject &asnObject)
{
    LONG lth = -1;
    CAsnObject *pasn;
    DWORD tag, index;
    DWORD count = m_rgEntries.Count();

    tag = asnObject.Tag();
    for (index = 0; index < count; index += 1)
    {
        pasn = m_rgEntries[index];
        if (NULL != pasn)
        {
            if (tag == pasn->Tag())
            {
                lth = pasn->_copy(asnObject);
                if (0 > lth)
                    goto ErrorExit;
                break;
            }
        }
    }
    if (index == count)
    {
        TRACE("CHOICE's don't match in a Copy")
        lth = -1;   // ?error? Unrecognized tag
        goto ErrorExit;
    }

    m_nActiveEntry = index;
    return lth;

ErrorExit:
    return lth;
}


/*++

EncodeTag:

    This method encodes the tag of the object into the supplied buffer.

Arguments:

    pbDst receives the ASN.1 encoding of the tag.

Return Value:

    >= 0 is the length of the tag.
    < 0 is an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::EncodeTag(
    OUT LPBYTE pbDst)
const
{
    LONG lth;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        lth = -1;       // ?error? Incomplete structure
        break;

    case fill_Optional:
    case fill_Defaulted:
        lth = 0;
        break;

    case fill_Present:
    case fill_NoElements:
        lth = m_rgEntries[m_nActiveEntry]->EncodeTag(pbDst);
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

EncodeLength:

    This method encodes the definite length of the object into the supplied
    buffer.

Arguments:

    pbDst receives the ASN.1 encoding of the length.

Return Value:

    >= 0 is the length of the resultant encoding
    < 0 is an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::EncodeLength(
    OUT LPBYTE pbDst)
const
{
    LONG lth;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        lth = -1;       // ?error? Incomplete Structure
        break;

    case fill_Optional:
    case fill_Defaulted:
    case fill_NoElements:
        lth = 0;
        break;

    case fill_Present:
        lth = m_rgEntries[m_nActiveEntry]->EncodeLength(pbDst);
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

EncodeData:

    This method encodes the data into the supplied buffer.

Arguments:

    pbDst

Return Value:

    >= 0 is the length of the encoding.
    < 0 is an error

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::EncodeData(
    OUT LPBYTE pbDst)
const
{
    LONG lth;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        lth = -1;       // ?error? Incomplete structure
        break;

    case fill_Optional:
    case fill_Defaulted:
    case fill_NoElements:
        lth = 0;
        break;

    case fill_Present:
        lth = m_rgEntries[m_nActiveEntry]->EncodeData(pbDst);
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

DecodeData:

    This routine decodes the data portion of the ASN.1.  The tag and length have
    already been removed.

Arguments:

    pbSrc supplies the address of the ASN.1 encoding of the data.

    dwLength supplies the length of the data.


Return Value:

    >= 0 - The number of bytes removed from the input stream.
    <  0 - An error occurred.

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

LONG
CAsnChoice::DecodeData(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc,
    IN DWORD dwLength)
{
    CAsnObject *pasn = m_rgEntries[m_nActiveEntry];
    ASSERT(NULL != pasn);

    if (NULL == pasn)
        return -1;

    return pasn->DecodeData(pbSrc, cbSrc, dwLength);
}


//
//==============================================================================
//
//  CAsnAny
//

IMPLEMENT_NEW(CAsnAny)


CAsnAny::CAsnAny(
    IN DWORD dwFlags)
:   CAsnObject(dwFlags, tag_Undefined, type_Any),
    m_bfData()
{
    m_rgEntries.Add(this);
}

void
CAsnAny::Clear(
    void)
{
    m_bfData.Reset();
    m_dwFlags &= ~fPresent;
    m_dwTag = m_dwDefaultTag = tag_Undefined;
    if (NULL != m_pasnParent)
        m_pasnParent->ChildAction(act_Cleared, this);
}

DWORD
CAsnAny::Tag(
    void)
const
{
    DWORD result;

    switch (State())
    {
    case fill_Present:
    case fill_NoElements:
        result = m_dwTag;
        break;
    case fill_Defaulted:
        result = m_dwDefaultTag;
        break;
    case fill_Optional:
        result = tag_Undefined;
        break;
    default:
        result = tag_Undefined; // ?error? Not complete.
        break;
    }
    return result;
}

LONG
CAsnAny::DataLength(
    void) const
{
    LONG lth;

    switch (State())
    {
    case fill_Present:
        lth = m_bfData.Length();
        break;
    case fill_Defaulted:
        lth = m_bfDefault.Length();
        break;
    case fill_Optional:
    case fill_NoElements:
        lth = 0;
        break;
    default:
        lth = -1;   // ?error? Not complete.
        break;
    }
    return lth;
}

LONG
CAsnAny::Read(
    OUT LPBYTE pbDst)
    const
{
    LONG lth;

    switch (State())
    {
    case fill_Empty:
    case fill_Partial:
    case fill_Optional:
        TRACE("Incomplete ANY")
        lth = -1;  // ?Error? Incomplete data
        break;

    case fill_Defaulted:
        lth = m_bfDefault.Length();
        memcpy(pbDst, m_bfDefault.Access(), lth);
        break;

    case fill_Present:
    case fill_NoElements:
        lth = m_bfData.Length();
        memcpy(pbDst, m_bfData.Access(), lth);
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}

LONG
CAsnAny::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen)
{
    TRACE("Writing to an ANY without specifying a Tag")
    return -1;  // ?error? No tag.
}

CAsnObject &
CAsnAny::operator =(
    IN const CAsnObject &asnValue)
{
    LONG lth;

    m_bfData.Reset();
    lth = asnValue.EncodingLength();
    if (0 < lth)
    {
        if (NULL == m_bfData.Resize(lth))
            goto ErrorExit;

        lth = asnValue.EncodeData(m_bfData.Access());
        ASSERT(0 <= lth);

        if (NULL == m_bfData.Resize(lth, TRUE))
            goto ErrorExit;
    }
    m_dwFlags |= fPresent | (asnValue.m_dwFlags & fConstructed);
    m_dwTag = asnValue.Tag();
    if (NULL != m_pasnParent)
        m_pasnParent->ChildAction(act_Written, this);
    return *this;

ErrorExit:
    ASSERT(FALSE);
    return *this;
}

LONG
CAsnAny::Cast(
    OUT CAsnObject &asnObj)
{
    LONG lth;

    asnObj.m_dwTag = m_dwTag;
    lth = asnObj.DecodeData(m_bfData.Access(), m_bfData.Length(), m_bfData.Length());
    return lth;
}

LONG
CAsnAny::_encLength(
    void) const
{
    BYTE rge[32];
    LONG lTotal = 0;
    LONG lth;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        lth = -1;       // ?error? Incomplete structure
        goto ErrorExit;
        break;

    case fill_Optional:
    case fill_Defaulted:
    case fill_NoElements:
        lTotal = 0;
        break;

    case fill_Present:
        lth = EncodeTag(rge);
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;
        lth = CAsnObject::EncodeLength(rge, m_bfData.Length());
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;
        lTotal += m_bfData.Length();
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        goto ErrorExit;
        break;
    }
    return lTotal;

ErrorExit:
    return lth;
}

LONG
CAsnAny::_decode(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc)
{
    LONG lth;
    LONG lTotal = 0;
    DWORD length;
    BOOL fIndefinite, fConstr;
    DWORD tag;


    //
    // Extract the Tag.
    //

    lth = ExtractTag(&pbSrc[lTotal], cbSrc-lTotal, &tag, &fConstr);
    if (0 > lth)
        goto ErrorExit; // ?error? propagate error
    ASSERT(0 != tag);
    m_dwTag = tag;
    lTotal += lth;


    //
    // Extract the length.
    //

    lth = ExtractLength(&pbSrc[lTotal], cbSrc-lTotal, &length, &fIndefinite);
    if (0 > lth)
        goto ErrorExit;
    if (fIndefinite && !fConstr)
    {
        TRACE("Indefinite Length on Primitive Object")
        lth = -1;   // ?error? - Indefinite length on primitive object
        goto ErrorExit;
    }
    lTotal += lth;


    //
    // Extract the data.
    //

    lth = DecodeData(&pbSrc[lTotal], cbSrc-lTotal, length);
    if (0 > lth)
        goto ErrorExit;
    lTotal += lth;


    //
    // Extract any trailing tag.
    //

    if (fIndefinite)
    {
        lth = ExtractTag(&pbSrc[lTotal], cbSrc-lTotal, &tag);
        if (0 > lth)
            goto ErrorExit;
        if (0 != tag)
        {
            TRACE("NON-ZERO Tag on expected Indefinite Length Terminator")
            lth = -1;   // ?Error? Bad indefinite length encoding.
            goto ErrorExit;
        }
        lTotal += lth;
    }


    //
    // Return the status.
    //

    if (fConstr)
        m_dwFlags |= fConstructed;
    else
        m_dwFlags &= ~fConstructed;
    return lTotal;

ErrorExit:
    return lth;
}

CAsnObject *
CAsnAny::Clone(
    DWORD dwFlags)
const
{
    return new CAsnAny(dwFlags);
}

CAsnObject::FillState
CAsnAny::State(
    void) const
{
    FillState result;

    if (0 != (fPresent & m_dwFlags))
        result = fill_Present;
    else if (0 != (m_dwFlags & fOptional))
        result = fill_Optional;
    else if (0 != (m_dwFlags & fDefault))
        result = fill_Defaulted;
    else
        result = fill_Empty;
    ((CAsnAny *)this)->m_State = result;
    return result;
}

LONG
CAsnAny::Compare(
    const CAsnObject &asnObject)
const
{
    const CAsnAny *
        pasnAny;
    const CBuffer
        *pbfThis,
        *pbfThat;
    LONG
        result;


    if (type_Any != asnObject.m_dwType)
    {
        TRACE("No support for Non-ANY comparisons yet.")
        goto ErrorExit;
    }
    pasnAny = (CAsnAny *)&asnObject;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        TRACE("Incomplete Structure in Comparison")
        goto ErrorExit; // ?error? Incomplete structure
        break;

    case fill_Optional:
        pbfThis = NULL;
        break;

    case fill_Defaulted:
        pbfThis = &m_bfDefault;
        break;

    case fill_NoElements:
    case fill_Present:
        pbfThis = &m_bfData;
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        goto ErrorExit;
        break;
    }

    switch (pasnAny->m_State)
    {
    case fill_Empty:
    case fill_Partial:
        TRACE("Incomplete Structure in Comparison")
        goto ErrorExit; // ?error? Incomplete structure

    case fill_Optional:
        pbfThat = NULL;
        break;

    case fill_Defaulted:
        pbfThat = &pasnAny->m_bfDefault;
        break;

    case fill_NoElements:
    case fill_Present:
        pbfThat = &pasnAny->m_bfData;
        break;

    default:
        ASSERT(FALSE)   // ?error? Internal error
        goto ErrorExit;
        break;
    }

    if ((NULL == pbfThis) && (NULL == pbfThat))
        return 0;   // They're both optional and missing.
    else if (NULL == pbfThis)
        return -(*pbfThat->Access());
    else if (NULL == pbfThat)
        return *pbfThis->Access();

    if (Tag() != pasnAny->Tag())
    {
        TRACE("Tags don't match in ANY Comparison")
        goto ErrorExit;
    }

    if (pbfThis->Length() > pbfThat->Length())
        result = (*pbfThis)[pbfThat->Length()];
    else if (pbfThis->Length() < pbfThat->Length())
        result = -(*pbfThat)[pbfThis->Length()];
    else
        result = memcmp(pbfThis->Access(), pbfThat->Access(), pbfThis->Length());

    return result;

ErrorExit:
    return 0x100;
}

LONG
CAsnAny::_copy(
    const CAsnObject &asnObject)
{
    const CAsnAny *
        pasnAny;
    const CBuffer
        *pbfThat
            = NULL;
    LONG
        lth
            = 0;

    if (type_Any != asnObject.m_dwType)
    {
        TRACE("No support for Non-ANY copies yet.")
        goto ErrorExit;
    }
    pasnAny = (CAsnAny *)&asnObject;

    switch (pasnAny->m_State)
    {
    case fill_Empty:
    case fill_Partial:
        goto ErrorExit; // ?error? Incomplete structure
        break;

    case fill_Optional:
        if (0 == (m_dwFlags & fOptional))
            goto ErrorExit;     // ?error? Optionality mismatch
        break;

    case fill_Defaulted:
        if (0 == (m_dwFlags & fDefault))
            pbfThat = &pasnAny->m_bfDefault;
        break;

    case fill_NoElements:
    case fill_Present:
        pbfThat = &pasnAny->m_bfData;
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        goto ErrorExit;
        break;
    }

    if (NULL != pbfThat)
    {
        m_bfData = *pbfThat;
        if (m_bfData.Length() != pbfThat->Length())
            return -1;
        m_dwFlags |= fPresent | (pasnAny->m_dwFlags & fConstructed);
        m_dwTag = pasnAny->Tag();
        if (NULL != m_pasnParent)
            m_pasnParent->ChildAction(act_Written, this);
    }
    return lth;

ErrorExit:
    return -1;
}

LONG
CAsnAny::EncodeLength(
    OUT LPBYTE pbDst)
const
{
    LONG lth;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        lth = -1;   // ?error? Incomplete Structure
        break;

    case fill_Optional:
    case fill_Defaulted:
        lth = 0;
        break;

    case fill_NoElements:
    case fill_Present:
        lth = CAsnObject::EncodeLength(pbDst, m_bfData.Length());
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}

LONG
CAsnAny::EncodeData(
    OUT LPBYTE pbDst)
const
{
    LONG lth;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        lth = -1;       // ?error? Incomplete structure
        break;

    case fill_Optional:
    case fill_Defaulted:
    case fill_NoElements:
        lth = 0;
        break;

    case fill_Present:
        lth = m_bfData.Length();
        if( lth )
        {
            memcpy(pbDst, m_bfData.Access(), lth);
        }
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}

LONG
CAsnAny::SetDefault(
    void)
{
    LONG lth;
    ASSERT(0 != (m_dwFlags & fPresent));
    ASSERT(tag_Undefined != m_dwTag);
    m_dwDefaultTag = m_dwTag;
    lth = CAsnObject::SetDefault();
    return lth;
}

LONG
CAsnAny::DecodeData(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc,
    IN DWORD cbSrcLen)
{
    ASSERT(tag_Undefined != m_dwTag);
    if (0 < cbSrcLen)
    {
        if (cbSrc < cbSrcLen)
            return -1;

        if (NULL == m_bfData.Set(pbSrc, cbSrcLen))
            return -1;  // ?error? no memory.
    }
    else
        m_bfData.Reset();
    m_dwFlags |= fPresent;
    if (NULL != m_pasnParent)
        m_pasnParent->ChildAction(act_Written, this);
    return m_bfData.Length();
}


/*++

TypeCompare:

    This routine compares the entire structure of an Object to another Object.

Arguments:

    asn - The other object.

Return Value:

    TRUE - They are identical
    FALSE - They differ

Author:

    Doug Barlow (dbarlow) 10/19/1995

--*/

BOOL
CAsnAny::TypeCompare(
    const CAsnObject &asnObject)
const
{
    return (m_dwType == asnObject.m_dwType);
}


//
//==============================================================================
//
//  String Types
//

IMPLEMENT_NEW(CAsnNumericString)

CAsnNumericString::CAsnNumericString(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTextString(dwFlags, dwTag, type_NumericString)
{
    // ?todo? Identify m_pbmValidChars
}

CAsnObject *
CAsnNumericString::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnNumericString(dwFlags, m_dwTag);
}


IMPLEMENT_NEW(CAsnPrintableString)

CAsnPrintableString::CAsnPrintableString(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTextString(dwFlags, dwTag, type_PrintableString)
{
    // ?todo? Identify m_pbmValidChars
}

CAsnObject *
CAsnPrintableString::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnPrintableString(dwFlags, m_dwTag);
}


IMPLEMENT_NEW(CAsnTeletexString)

CAsnTeletexString::CAsnTeletexString(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTextString(dwFlags, dwTag, type_TeletexString)
{
    // ?todo? Identify m_pbmValidChars
}

CAsnObject *
CAsnTeletexString::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnTeletexString(dwFlags, m_dwTag);
}


IMPLEMENT_NEW(CAsnVideotexString)

CAsnVideotexString::CAsnVideotexString(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTextString(dwFlags, dwTag, type_VideotexString)
{
    // ?todo? Identify m_pbmValidChars
}

CAsnObject *
CAsnVideotexString::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnVideotexString(dwFlags, m_dwTag);
}


IMPLEMENT_NEW(CAsnVisibleString)

CAsnVisibleString::CAsnVisibleString(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTextString(dwFlags, dwTag, type_VisibleString)
{
    // ?todo? Identify m_pbmValidChars
}

CAsnObject *
CAsnVisibleString::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnVisibleString(dwFlags, m_dwTag);
}


IMPLEMENT_NEW(CAsnIA5String)

CAsnIA5String::CAsnIA5String(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTextString(dwFlags, dwTag, type_IA5String)
{
    // ?todo? Identify m_pbmValidChars
}

CAsnObject *
CAsnIA5String::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnIA5String(dwFlags, m_dwTag);
}


IMPLEMENT_NEW(CAsnGraphicString)

CAsnGraphicString::CAsnGraphicString(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTextString(dwFlags, dwTag, type_GraphicString)
{
    // ?todo? Identify m_pbmValidChars
}

CAsnObject *
CAsnGraphicString::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnGraphicString(dwFlags, m_dwTag);
}


IMPLEMENT_NEW(CAsnGeneralString)

CAsnGeneralString::CAsnGeneralString(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTextString(dwFlags, dwTag, type_GeneralString)
{
    // ?todo? Identify m_pbmValidChars
}

CAsnObject *
CAsnGeneralString::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnGeneralString(dwFlags, m_dwTag);
}


IMPLEMENT_NEW(CAsnUnicodeString)

CAsnUnicodeString::CAsnUnicodeString(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTextString(dwFlags, dwTag, type_UnicodeString)
{
    // ?todo? Identify m_pbmValidChars
}

CAsnObject *
CAsnUnicodeString::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnUnicodeString(dwFlags, m_dwTag);
}


//
//==============================================================================
//
//  CAsnGeneralizedTime
//

IMPLEMENT_NEW(CAsnGeneralizedTime)

CAsnGeneralizedTime::CAsnGeneralizedTime(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnVisibleString(dwFlags, dwTag)
{
    m_dwType = type_GeneralizedTime;
}


CAsnGeneralizedTime::operator FILETIME(
    void)
{
    LPSTR pc, pcDiff;
    DWORD size, index;
#if defined(OS_WINCE)
    size_t len;
#else
    SIZE_T len;
#endif

    SYSTEMTIME stm, stmDiff;
    FILETIME ftmDiff;
    char cDiff = 'Z';

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete GeneralizedTime")
        goto ErrorExit; // ?error? Incomplete structure
        break;

    case fill_Defaulted:
        pc = (LPSTR)m_bfDefault.Access();
        size = m_bfDefault.Length();
        break;

    case fill_Present:
        pc = (LPSTR)m_bfData.Access();
        size = m_bfData.Length();
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        goto ErrorExit;
        break;
    }

    memset(&stm, 0, sizeof(stm));
    memset(&stmDiff, 0, sizeof(stmDiff));

                    //   YYYY  MM  DD  hh  mm  ss
    if (7 != sscanf(pc, "%4hd%2hd%2hd%2hd%2hd%2hd",
                &stm.wYear,
                &stm.wMonth,
                &stm.wDay,
                &stm.wHour,
                &stm.wMinute,
                &stm.wSecond,
                &cDiff))
        goto ErrorExit;
    index = 14;
    if (index < size)
    {
        if (('.' == pc[index]) || (',' == pc[index]))
        {

            //
            // There are milliseconds specified.
            //

            index += 1;
            stm.wMilliseconds = (WORD)strtoul(&pc[index], &pcDiff, 10);
            len = pcDiff - &pc[index];
            if ((len == 0) || (len > 3))
            {
                TRACE("Milliseconds with more than 3 digits: " << &pc[index])
                goto ErrorExit; // ?error? invalid millisecond value.
            }
            index += (DWORD)len;
            while (3 > len++)
                stm.wMilliseconds *= 10;
        }
    }

    if (!SystemTimeToFileTime(&stm, &m_ftTime))
    {
        TRACE("Time Conversion Error")
        goto ErrorExit; // ?error? conversion error
    }

    if (index < size)
    {
        cDiff = pc[index++];
        switch (cDiff)
        {
        case 'Z':   // Zulu Time -- no changes.
            break;

        case '+':   // Add the difference.
            if (size - index != 4)
            {
                TRACE("Invalid Time differential")
                goto ErrorExit; // ?error? Invalid time differential
            }
            if (2 != sscanf(&pc[index], "%2hd%2hd",
                        &stmDiff.wHour,
                        &stmDiff.wMinute))
                goto ErrorExit;
            if (!SystemTimeToFileTime(&stmDiff, &ftmDiff))
            {
                TRACE("Time conversion error")
                goto ErrorExit; // ?error? conversion error
            }
            FTINT(m_ftTime) += FTINT(ftmDiff);
            break;

        case '-':   // Subtract the difference
            if (size - index != 4)
            {
                TRACE("Invalid Time differential")
                goto ErrorExit; // ?error? Invalid time differential
            }
            if (2 != sscanf(&pc[index], "%2hd%2hd",
                        &stmDiff.wHour,
                        &stmDiff.wMinute))
                goto ErrorExit;
            if (!SystemTimeToFileTime(&stmDiff, &ftmDiff))
            {
                TRACE("Time conversion Error")
                goto ErrorExit; // ?error? conversion error
            }
            FTINT(m_ftTime) -= FTINT(ftmDiff);
            break;

        default:
            TRACE("Invalid Time differential Indicator")
            goto ErrorExit; // ?error? Invalid time format
        }
    }
    return m_ftTime;

ErrorExit:
    memset(&m_ftTime, 0, sizeof(FILETIME));
    return m_ftTime;
}

const FILETIME &
CAsnGeneralizedTime::operator =(
    const FILETIME &ftValue)
{
    LONG lth;
    char szTime[24];
    SYSTEMTIME stm;

    if (!FileTimeToSystemTime(&ftValue, &stm))
    {
        TRACE("Invalid Incoming Time")
        goto ErrorExit;     // ?error? Invalid incoming time.
    }
    sprintf(szTime,
            "%04d%02d%02d%02d%02d%02d.%03d",
            stm.wYear,
            stm.wMonth,
            stm.wDay,
            stm.wHour,
            stm.wMinute,
            stm.wSecond,
            stm.wMilliseconds);
    lth = strlen(szTime);
    ASSERT(18 == lth);
    lth = Write((LPBYTE)szTime, lth);
    if (0 > lth)
        goto ErrorExit;    // ?error? Propagate write error.
    return ftValue;

ErrorExit:
    memset(&m_ftTime, 0, sizeof(FILETIME));
    return m_ftTime;
}

CAsnObject *
CAsnGeneralizedTime::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnGeneralizedTime(dwFlags, m_dwTag);
}


//
//==============================================================================
//
//  CAsnUniversalTime
//

IMPLEMENT_NEW(CAsnUniversalTime)

CAsnUniversalTime::CAsnUniversalTime(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnVisibleString(dwFlags, dwTag)
{
    m_dwType = type_UniversalTime;
}


CAsnUniversalTime::operator FILETIME(
    void)
{
    LPCSTR pc;
    DWORD size;
    SYSTEMTIME stm, stmDiff;
    FILETIME ftmDiff;
    char cDiff;

    ASSERT(FALSE);      // We never use this function, as it uses two-year dates

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete UniversalTime")
        goto ErrorExit; // ?error? Incomplete structure
        break;

    case fill_Defaulted:
        pc = (LPSTR)m_bfDefault.Access();
        size = m_bfDefault.Length();
        break;

    case fill_Present:
        pc = (LPSTR)m_bfData.Access();
        size = m_bfData.Length();
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        goto ErrorExit;
        break;
    }

    memset(&stm, 0, sizeof(stm));
    memset(&stmDiff, 0, sizeof(stmDiff));

    switch (size)
    {
    case 11:                // YY  MM  DD  hh  mm   Z
        if (6 != sscanf(pc, "%2hd%2hd%2hd%2hd%2hd%1hc",
                    &stm.wYear,
                    &stm.wMonth,
                    &stm.wDay,
                    &stm.wHour,
                    &stm.wMinute,
                    &cDiff))
            goto ErrorExit;
        break;

    case 13:                // YY  MM  DD  hh  mm  ss   Z
        if (7 != sscanf(pc, "%2hd%2hd%2hd%2hd%2hd%2hd%1hc",
                    &stm.wYear,
                    &stm.wMonth,
                    &stm.wDay,
                    &stm.wHour,
                    &stm.wMinute,
                    &stm.wSecond,
                    &cDiff))
            goto ErrorExit;
        break;

    case 15:                // YY  MM  DD  hh  mm   +  hh  mm
        if (8 != sscanf(pc, "%2hd%2hd%2hd%2hd%2hd%1hc%2hd%2hd",
                    &stm.wYear,
                    &stm.wMonth,
                    &stm.wDay,
                    &stm.wHour,
                    &stm.wMinute,
                    &cDiff,
                    &stmDiff.wHour,
                    &stmDiff.wMinute))
            goto ErrorExit;
        break;

    case 17:                // YY  MM  DD  hh  mm  ss  +  hh  mm
        if (9 != sscanf(pc, "%2hd%2hd%2hd%2hd%2hd%2hd%1hc%2hd%2hd",
                    &stm.wYear,
                    &stm.wMonth,
                    &stm.wDay,
                    &stm.wHour,
                    &stm.wMinute,
                    &stm.wSecond,
                    &cDiff,
                    &stmDiff.wHour,
                    &stmDiff.wMinute))
            goto ErrorExit;
        break;

    default:
        TRACE("Invalid Time String")
        goto ErrorExit; // ?error? Invalid time
    }

    if (50 < stm.wYear)
        stm.wYear += 1900;  // NB: we don't use two-character years
    else
        stm.wYear += 2000;
    if (!SystemTimeToFileTime(&stm, &m_ftTime))
    {
        TRACE("Time Conversion Error")
        goto ErrorExit; // ?error? conversion error
    }
    switch (cDiff)
    {
    case 'Z':   // Already UTC.
        break;

    case '+':   // Add the difference.
        if (!SystemTimeToFileTime(&stmDiff, &ftmDiff))
        {
            TRACE("Time Conversion Error")
            goto ErrorExit; // ?error? conversion error
        }
        FTINT(m_ftTime) += FTINT(ftmDiff);
        break;

    case '-':   // Subtract the difference
        if (!SystemTimeToFileTime(&stmDiff, &ftmDiff))
        {
            TRACE("Time Conversion Error")
            goto ErrorExit; // ?error? conversion error
        }
        FTINT(m_ftTime) -= FTINT(ftmDiff);
        break;

    default:
        TRACE("Invalid Time Format")
        goto ErrorExit; // ?error? Invalid time format
    }
    return m_ftTime;

ErrorExit:
    memset(&m_ftTime, 0, sizeof(FILETIME));
    return m_ftTime;
}

const FILETIME &
CAsnUniversalTime::operator =(
    const FILETIME &ftValue)
{
    LONG lth;
    char szTime[24];
    SYSTEMTIME stm;

    if (!FileTimeToSystemTime(&ftValue, &stm))
    {
        TRACE("Invalid incoming time")
        goto ErrorExit;     // ?error? Invalid incoming time.
    }
    sprintf(szTime,
            "%02d%02d%02d%02d%02d%02dZ",
            stm.wYear % 100,
            stm.wMonth,
            stm.wDay,
            stm.wHour,
            stm.wMinute,
            stm.wSecond);
    lth = strlen(szTime);
    ASSERT(13 == lth);
    lth = Write((LPBYTE)szTime, lth);
    if (0 > lth)
        goto ErrorExit;    // ?error? Propagate write error.
    return ftValue;

ErrorExit:
    memset(&m_ftTime, 0, sizeof(FILETIME));
    return m_ftTime;
}

CAsnObject *
CAsnUniversalTime::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnUniversalTime(dwFlags, m_dwTag);
}

//
//==============================================================================
//
//  CAsnObjectDescriptor
//

IMPLEMENT_NEW(CAsnObjectDescriptor)

CAsnObjectDescriptor::CAsnObjectDescriptor(
    IN DWORD dwFlags,
    IN DWORD dwTag)
: CAsnGraphicString(dwFlags, dwTag)
{
    m_dwType = type_ObjectDescriptor;
}

CAsnObject *
CAsnObjectDescriptor::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnObjectDescriptor(dwFlags, m_dwTag);
}


//
//==============================================================================
//
//  CAsnExternal
//

IMPLEMENT_NEW(CAsnExternal_Encoding_singleASN1Type)

CAsnExternal_Encoding_singleASN1Type::CAsnExternal_Encoding_singleASN1Type(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTag(dwFlags, dwTag),
    _entry1(0)
{
    m_rgEntries.Set(0, &_entry1);
}

CAsnObject *
CAsnExternal_Encoding_singleASN1Type::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnExternal_Encoding_singleASN1Type(dwFlags, m_dwTag);
}


IMPLEMENT_NEW(CAsnExternal_Encoding)

CAsnExternal_Encoding::CAsnExternal_Encoding(
    IN DWORD dwFlags)
:   CAsnChoice(dwFlags),
    singleASN1Type(0, TAG(0)),
    octetAligned(0, TAG(1)),
    arbitrary(0, TAG(2))
{
    m_rgEntries.Set(0, &singleASN1Type);
    m_rgEntries.Set(1, &octetAligned);
    m_rgEntries.Set(2, &arbitrary);
}

CAsnObject *
CAsnExternal_Encoding::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnExternal_Encoding(dwFlags);
}


IMPLEMENT_NEW(CAsnExternal)

CAsnExternal::CAsnExternal(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    directReference(fOptional),
    indirectReference(fOptional),
    dataValueDescriptor(fOptional),
    encoding(0)
{
    m_dwType = type_External;
    m_rgEntries.Set(0, &directReference);
    m_rgEntries.Set(1, &indirectReference);
    m_rgEntries.Set(2, &dataValueDescriptor);
    m_rgEntries.Set(3, &encoding);
}

CAsnObject *
CAsnExternal::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnExternal(dwFlags, m_dwTag);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\asn1\asnprimt.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asnprimt

Abstract:

    This module provides the implementation of the ASN.1 Primitive Object base
    class.

Author:

    Doug Barlow (dbarlow) 10/8/1995

Environment:

    Win32

Notes:



--*/

#include <windows.h>
#include "asnPriv.h"


//
//==============================================================================
//
//  CAsnPrimitive
//

IMPLEMENT_NEW(CAsnPrimitive)

/*++

CAsnPrimitive:

    This is the constructor for a Primitve type ASN.1 encoding.

Arguments:

    dwType is the type of the object.

    dwFlags supplies any special flags for this object.  Options are:

        fOptional implies the object is optional.

    dwTag is the tag of the object.  If this is zero, the tag is taken from the
        type.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

CAsnPrimitive::CAsnPrimitive(
        IN DWORD dwFlags,
        IN DWORD dwTag,
        IN DWORD dwType)
:   CAsnObject(dwFlags, dwTag, dwType),
    m_bfData()
{
    ASSERT(0 == (dwFlags & (fConstructed)));
    m_rgEntries.Add(this);
}


/*++

Clear:

    This method sets the primitive object to it's default state.  It does not
    affect the default setting.

Arguments:

    None

Return Value:

    none

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

void
CAsnPrimitive::Clear(
    void)
{
    m_bfData.Reset();
    m_dwFlags &= ~fPresent;
    if (NULL != m_pasnParent)
        m_pasnParent->ChildAction(act_Cleared, this);
}


/*++

DataLength:

    This method returns the length of the local machine encoding of the data.
    For this general object, the local machine encoding and ASN.1 encoding are
    identical.

Arguments:

    None

Return Value:

    >= 0 - The length of the local machine encoding.

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

LONG
CAsnPrimitive::DataLength(
    void)
const
{
    LONG lth;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        lth = -1;       // ?error? Incomplete Structure
        break;

    case fill_Defaulted:
        lth = m_bfDefault.Length();
        break;

    case fill_Present:
        lth = m_bfData.Length();
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

Read:

    This default method provides the stored data.

Arguments:

    pbDst receives the value.  It is assumed to be long enough.

Return Value:

    If >=0, the length of the data portion of this object.
    if < 0, an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnPrimitive::Read(
    OUT LPBYTE pbDst)
const
{
    LONG lth;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        lth = -1;       // ?error? Incomplete structure.
        break;

    case fill_Defaulted:
        lth = m_bfDefault.Length();
        memcpy(pbDst, m_bfDefault.Access(), lth);
        break;

    case fill_Present:
        lth = m_bfData.Length();
        memcpy(pbDst, m_bfData.Access(), lth);
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

Write:

    This default implementation copies the provided data to our data buffer.

Arguments:

    pbSrc supplies the data as a BYTE array, with
    cbSrcLen supplies the length of the pbSrc Array.

Return Value:

    If >=0, the length of the data portion of this object.
    if < 0, an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnPrimitive::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen)
{
    if (0 < cbSrcLen)
    {
        if (NULL == m_bfData.Set(pbSrc, cbSrcLen))
            return -1;
    }
    else
        m_bfData.Reset();
    m_dwFlags |= fPresent;
    if (NULL != m_pasnParent)
        m_pasnParent->ChildAction(act_Written, this);
    return m_bfData.Length();
}


/*++

EncodingLength:

    This method returns the length of the object in its ASN.1 encoding.

Arguments:

    None

Return Value:

    >= 0 is the length of the object's ASN.1 encoding.
    < 0 implies an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnPrimitive::_encLength(
    void) const
{
    BYTE rge[32];
    LONG lTotal = 0;
    LONG lth;


    switch (m_State)
    {
    case fill_Empty:
        lth = -1;       // ?error? Incomplete structure
        goto ErrorExit;
        break;

    case fill_Optional:
    case fill_Defaulted:
        lTotal = 0;
        break;

    case fill_Present:
        lth = EncodeTag(rge);
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;
        lth = EncodeLength(rge);
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;
        lTotal += m_bfData.Length();
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lTotal;

ErrorExit:
    return lth;
}


/*++

State:

    This routine checks to see if a structure is completely filled in.

Arguments:

    None

Return Value:

    fill_Empty    - There is no added data anywhere in the structure.
    fill_Present  - All the data is present in the structure (except maybe
                    defaulted or optional data).
    fill_Partial  - Not all of the data is there, but some of it is.  (Not used
                    by this object type.)
    fill_Defauted - No data has been written, but a default value is available.
    fill_Optional - No data has been written, but the object is optional.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CAsnObject::FillState
CAsnPrimitive::State(
    void) const
{
    FillState result;

    if (0 != (fPresent & m_dwFlags))
        result = fill_Present;
    else if (0 != (m_dwFlags & fOptional))
        result = fill_Optional;
    else if (0 != (m_dwFlags & fDefault))
        result = fill_Defaulted;
    else
        result = fill_Empty;
    ((CAsnPrimitive *)this)->m_State = result;
    return result;
}


/*++

Compare:

    This method compares this ASN.1 Object to another.

Arguments:

    asnObject supplies the other object for comparison.

Return Value:

    A value indicating a comparitive value:
    < 0 - This object is less than that object.
    = 0 - This object is the same as that object.
    > 0 - This object is more than that object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnPrimitive::Compare(
    const CAsnObject &asnObject)
const
{
    const CAsnPrimitive *
        pasnPrim;
    const CBuffer
        *pbfThis,
        *pbfThat;
    LONG
        result;

    if (m_dwType != asnObject.m_dwType)
        return 0x100;   // They're incomparable.
    pasnPrim = (const CAsnPrimitive *)&asnObject;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete Primitive in Comparison")
        return 0x100;
        break;

    case fill_Defaulted:
        pbfThis = &m_bfDefault;
        break;

    case fill_Present:
        pbfThis = &m_bfData;
        break;

    case fill_NoElements:
    case fill_Partial:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        return 0x100;
        break;
    }
    switch (pasnPrim->m_State)
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete Primitive in Comparison")
        return 0x100;
        break;

    case fill_Defaulted:
        pbfThat = &pasnPrim->m_bfDefault;
        break;

    case fill_Present:
        pbfThat = &pasnPrim->m_bfData;
        break;

    case fill_NoElements:
    case fill_Partial:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        return 0x100;
        break;
    }

    if (pbfThis->Length() > pbfThat->Length())
        result = (*pbfThis)[pbfThat->Length()];
    else if (pbfThis->Length() < pbfThat->Length())
        result = (*pbfThat)[pbfThis->Length()];
    else
        result = memcmp(pbfThis->Access(), pbfThat->Access(), pbfThis->Length());

    return result;
}


/*++

_copy:

    This method replaces the contents of this ASN.1 Object with another.  The
    objects must be identical structures.  Tags and defaults are not duplicated.

Arguments:

    asnObject supplies the source object.

Return Value:

    >= 0 Is the number of bytes actually copied
    < 0 is an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnPrimitive::_copy(
    const CAsnObject &asnObject)
{
    const CAsnPrimitive *
        pasnPrim;
    LONG
        lth;

    if (m_dwType != asnObject.m_dwType)
    {
        TRACE("Type mismatch in _copy")
        lth = -1;   // ?error? Wrong type.
        goto ErrorExit;
    }
    pasnPrim = (const CAsnPrimitive *)&asnObject;

    switch (pasnPrim->m_State)
    {
    case fill_Empty:
        TRACE("Incomplete Structure in _copy")
        lth = -1;       // ?error? Incomplete structure
        goto ErrorExit;
        break;

    case fill_Optional:
        lth = 0;
        break;

    case fill_Defaulted:
        lth = Write(
                pasnPrim->m_bfDefault.Access(),
                pasnPrim->m_bfDefault.Length());
        break;

    case fill_Present:
        lth = Write(
                pasnPrim->m_bfData.Access(),
                pasnPrim->m_bfData.Length());
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;

ErrorExit:
    return lth;
}


/*++

EncodeLength:

    This method encodes the definite length of the object into the supplied
    buffer.

Arguments:

    pbDst receives the ASN.1 encoding of the length.

Return Value:

    >= 0 is the length of the resultant encoding
    < 0 is an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnPrimitive::EncodeLength(
    OUT LPBYTE pbDst)
const
{
    LONG lth;

    switch (m_State)
    {
    case fill_Empty:
        TRACE("Incomplete Structure")
        lth = -1;       // ?error? Incomplete Structure
        break;

    case fill_Optional:
    case fill_Defaulted:
        lth = 0;
        break;

    case fill_Present:
        lth = CAsnObject::EncodeLength(pbDst, m_bfData.Length());
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

EncodeData:

    This method encodes the data into the supplied buffer.

Arguments:

    pbDst

Return Value:

    >= 0 is the length of the encoding.
    < 0 is an error

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnPrimitive::EncodeData(
    OUT LPBYTE pbDst)
const
{
    LONG lth;

    switch (m_State)
    {
    case fill_Empty:
        TRACE("Incomplete Structure")
        lth = -1;       // ?error? Incomplete Structure
        break;

    case fill_Optional:
    case fill_Defaulted:
        lth = 0;
        break;

    case fill_Present:
        lth = m_bfData.Length();
        if (0 != lth)
            memcpy(pbDst, m_bfData.Access(), lth);
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

DecodeData:

    This routine decodes the data portion of the ASN.1.  The tag and length have
    already been removed.

Arguments:

    pbSrc supplies the address of the ASN.1 encoding of the data.

    dwLength supplies the length of the data.


Return Value:

    >= 0 - The number of bytes removed from the input stream.
    <  0 - An error occurred.

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

LONG
CAsnPrimitive::DecodeData(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc,
    IN DWORD dwLength)
{
    if (0 < dwLength)
    {
        if (cbSrc < dwLength)
        {
            return -1;
        }

        if (NULL == m_bfData.Set(pbSrc, dwLength))
            return -1;  // ?error? no memory
    }
    else
        m_bfData.Reset();
    m_dwFlags |= fPresent;
    if (NULL != m_pasnParent)
        m_pasnParent->ChildAction(act_Written, this);
    return dwLength;
}


/*++

TypeCompare:

    This routine compares the entire structure of an Object to another Object.

Arguments:

    asn - The other object.

Return Value:

    TRUE - They are identical
    FALSE - They differ

Author:

    Doug Barlow (dbarlow) 10/19/1995

--*/

BOOL
CAsnPrimitive::TypeCompare(
    const CAsnObject &asnObject)
const
{
    return (m_dwType == asnObject.m_dwType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\asn1\asnof.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asnof

Abstract:

    This module provides the implementation of the Base Class for ASN.1 SET OF
    and SEQUENCE OF.

Author:

    Doug Barlow (dbarlow) 10/8/1995

Environment:

    Win32

Notes:



--*/

#include <windows.h>
#include "asnPriv.h"


//
//==============================================================================
//
//  CAsnSeqsetOf
//

IMPLEMENT_NEW(CAsnSeqsetOf)

/*++

CAsnSeqsetOf:

    This is the construction routine for a CAsnSeqsetOf base class.

Arguments:

    dwType supplies the type of the object.

    dwFlags supplies any special flags for this object.  Options are:

        fOptional implies the object is optional.
        fDelete implies the object should be deleted when its parent destructs.

    dwTag is the tag of the object.  If this is zero, the tag is taken from the
        type.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CAsnSeqsetOf::CAsnSeqsetOf(
    IN DWORD dwFlags,
    IN DWORD dwTag,
    IN DWORD dwType)
:   CAsnObject(dwFlags | fConstructed, dwTag, dwType)
{ /* Force constructed flag */ }


/*++

Clear:

    This method purges any stored values from the object and any underlying
    objects.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

void
CAsnSeqsetOf::Clear(
    void)
{
    CAsnObject::Clear();
    m_rgEntries.Empty();
}


LONG
CAsnSeqsetOf::Add(
    void)
{
    LONG count = m_rgEntries.Count();
    CAsnObject *pasn = m_pasnTemplate->Clone(fDelete);
    if (NULL == pasn)
        goto ErrorExit;
    if (NULL == m_rgEntries.Add(pasn))
        goto ErrorExit;
    return count;

ErrorExit:
    if (NULL != pasn)
        delete pasn;
    return -1;
}

LONG
CAsnSeqsetOf::Insert(
    DWORD dwIndex)
{
    DWORD index;
    DWORD count = m_rgEntries.Count();
    CAsnObject *pasn = m_pasnTemplate->Clone(fDelete);
    if (NULL == pasn)
        goto ErrorExit;

    if (count > dwIndex)
    {
        for (index = count; index > dwIndex; index -= 1)
            m_rgEntries.Set(index, m_rgEntries[index - 1]);
        m_rgEntries.Set(dwIndex, pasn);
    }
    else
    {
        TRACE("*OF Insert out of range")
        goto ErrorExit; // ?error? Index out of range.
    }
    return (LONG)dwIndex;

ErrorExit:
    if (NULL != pasn)
        delete pasn;
    return -1;
}


/*++

DecodeData:

    This routine decodes the data portion of the ASN.1.  The tag and length have
    already been removed.

Arguments:

    pbSrc supplies the address of the ASN.1 encoding of the data.

    dwLength supplies the length of the data.


Return Value:

    >= 0 - The number of bytes removed from the input stream.
    <  0 - An error occurred.

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

LONG
CAsnSeqsetOf::DecodeData(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc,
    IN DWORD dwLength)
{
    LONG lth = -1, lTotal = 0;
    CAsnObject *pasn = NULL;
    DWORD tag, length;
    BOOL fConstr;

    ASSERT(0 == m_rgEntries.Count())
    ASSERT(NULL != m_pasnTemplate)

    while ((DWORD)lTotal < dwLength)
    {
        lth = ExtractTag(&pbSrc[lTotal], cbSrc-lTotal, &tag, &fConstr);
        if (0 > lth)
            goto ErrorExit; // ?error? Propagate error
        if ((tag != m_pasnTemplate->Tag())
            || (0 != (fConstr ^ (0 !=
                        (m_pasnTemplate->m_dwFlags & fConstructed)))))
        {
            TRACE("Incoming tag doesn't match template")
            lth = -1;   // ?error? Tag mismatch
            goto ErrorExit;
        }
        if (0 != (fConstr ^ (0 != (m_dwFlags & fConstructed))))
        {
            TRACE("Incoming construction doesn't match template")
            lth = -1;   // ?error? Construction mismatch
            goto ErrorExit;
        }
        lTotal += lth;

        lth = ExtractLength(&pbSrc[lTotal], cbSrc - lTotal, &length);
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;
        pasn = m_pasnTemplate->Clone(fDelete);
        if (NULL == pasn)
        {
            lth = -1;   // ?error? No memory
            goto ErrorExit;
        }

        lth = pasn->DecodeData(&pbSrc[lTotal], cbSrc - lTotal, length);
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;

        if (NULL == m_rgEntries.Add(pasn))
        {
            lth = -1;   // ?error? No memory
            goto ErrorExit;
        }
        pasn = NULL;
    }
    if ((DWORD)lTotal != dwLength)
    {
        TRACE("Decoding buffer mismatch")
        goto ErrorExit; // ?error? Decoding Error
    }
    return lTotal;

ErrorExit:
    if (NULL != pasn)
        delete pasn;
    return lth;
}


/*++

TypeCompare:

    This routine compares the entire structure of an Object to another Object.

Arguments:

    asn - The other object.

Return Value:

    TRUE - They are identical
    FALSE - They differ

Author:

    Doug Barlow (dbarlow) 10/19/1995

--*/

BOOL
CAsnSeqsetOf::TypeCompare(
    const CAsnObject &asnObject)
const
{

    //
    // See if we really have anything to do.
    //

    if (m_dwType != asnObject.m_dwType)
        return FALSE;


    //
    // compare the templates.
    //

    ASSERT(NULL != m_pasnTemplate)
    return m_pasnTemplate->TypeCompare(
                *((CAsnSeqsetOf &)asnObject).m_pasnTemplate);
}


/*++

Copy:

    This method replaces the contents of this ASN.1 Object with another.  The
    objects must be identical structures.  Tags and defaults are not duplicated.

Arguments:

    asnObject supplies the source object.

Return Value:

    >= 0 Is the number of bytes actually copied
    < 0 is an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnSeqsetOf::_copy(
    const CAsnObject &asnObject)
{
    CAsnSeqsetOf *pasnOf;
    CAsnObject *pasn1 = NULL, *pasn2;
    LONG lTotal = 0, lth;
    DWORD index;
    DWORD count = asnObject.m_rgEntries.Count();

    if (m_dwType == asnObject.m_dwType)
    {
        pasnOf = (CAsnSeqsetOf *)&asnObject;
        if (m_pasnTemplate->m_dwType == pasnOf->m_pasnTemplate->m_dwType)
        {
            for (index = 0; index < count; index += 1)
            {
                pasn1 = m_pasnTemplate->Clone(fDelete);
                if (NULL == pasn1)
                {
                    lth = -1;   // ?error? No memory
                    goto ErrorExit;
                }
                pasn2 = asnObject.m_rgEntries[index];
                ASSERT(NULL != pasn2)
                ASSERT(pasn1 != &asnObject)
                lth = pasn1->_copy(*pasn2);
                if (0 > lth)
                    goto ErrorExit;
                if (NULL == m_rgEntries.Add(pasn1))
                {
                    lth = -1;   // ?error? No memory
                    goto ErrorExit;
                }
                pasn1 = NULL;
                lTotal += lth;
            }
        }
        else
        {
            TRACE("Copy Template Structure Mismatch")
            lth = -1;   // ?error? data type mismatch.
            goto ErrorExit;
        }
    }
    else
    {
        TRACE("Copy Structure Mismatch")
        lth = -1;   // ?error? data type mismatch.
        goto ErrorExit;
    }
    return lTotal;

ErrorExit:
    if (NULL != pasn1)
        delete pasn1;
    return lth;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\asn1\text.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    text

Abstract:

    This header file provides a text handling class.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32

Notes:



--*/

#ifndef _TEXT_H_
#define _TEXT_H_

#include <string.h>
#include <mbstring.h>
#include "buffers.h"


//
//==============================================================================
//
//  CText
//

class CText
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CText()
    :   m_bfUnicode(),
        m_bfAnsi()
    { m_fFlags = fBothGood; };

    virtual ~CText() {};


    //  Properties
    //  Methods

    void
    Clear(
        void)
    {
        m_bfUnicode.Clear();
        m_bfAnsi.Clear();
        m_fFlags = fBothGood;
    };


    //  Operators

    CText &
    operator=(
        const CText &tz);
    LPCSTR
    operator=(
        LPCSTR sz);
    LPCWSTR
    operator=(
        LPCWSTR wsz);

    CText &
    operator+=(
        const CText &tz);
    LPCSTR
    operator+=(
        LPCSTR sz);
    LPCWSTR
    operator+=(
        LPCWSTR wsz);

    BOOL operator==(const CText &tz)
    { return (0 == Compare(tz)); };
    BOOL operator==(LPCSTR sz)
    { return (0 == Compare(sz)); };
    BOOL operator==(LPCWSTR wsz)
    { return (0 == Compare(wsz)); };

    BOOL operator!=(const CText &tz)
    { return (0 != Compare(tz)); };
    BOOL operator!=(LPCSTR sz)
    { return (0 != Compare(sz)); };
    BOOL operator!=(LPCWSTR wsz)
    { return (0 != Compare(wsz)); };

    BOOL operator<=(const CText &tz)
    { return (0 <= Compare(tz)); };
    BOOL operator<=(LPCSTR sz)
    { return (0 <= Compare(sz)); };
    BOOL operator<=(LPCWSTR wsz)
    { return (0 <= Compare(wsz)); };

    BOOL operator>=(const CText &tz)
    { return (0 >= Compare(tz)); };
    BOOL operator>=(LPCSTR sz)
    { return (0 >= Compare(sz)); };
    BOOL operator>=(LPCWSTR wsz)
    { return (0 >= Compare(wsz)); };

    BOOL operator<(const CText &tz)
    { return (0 < Compare(tz)); };
    BOOL operator<(LPCSTR sz)
    { return (0 < Compare(sz)); };
    BOOL operator<(LPCWSTR wsz)
    { return (0 < Compare(wsz)); };

    BOOL operator>(const CText &tz)
    { return (0 > Compare(tz)); };
    BOOL operator>(LPCSTR sz)
    { return (0 > Compare(sz)); };
    BOOL operator>(LPCWSTR wsz)
    { return (0 > Compare(wsz)); };

    operator LPCSTR(void)
    { return Ansi(); };

    operator LPCWSTR(void)
    { return Unicode(); };


protected:
    //  Properties

    enum {
        fNoneGood = 0,
        fAnsiGood = 1,
        fUnicodeGood = 2,
        fBothGood = 3
    } m_fFlags;

    CBuffer
        m_bfUnicode,
        m_bfAnsi;

    //  Methods

    LPCWSTR
    Unicode(        // Return the text as a Unicode string.
        void);

    LPCSTR
    Ansi(        // Return the text as an Ansi string.
        void);

    int
    Compare(
        const CText &tz);

    int
    Compare(
        LPCSTR sz);

    int
    Compare(
        LPCWSTR wsz);
};

IMPLEMENT_STATIC_NEW(CText)


/*++

CText::operator=:

    These methods set the CText object to the given value, properly adjusting
    the object to the type of text.

Arguments:

    tz supplies the new value as a CText object.
    sz supples the new value as an LPCSTR object (ANSI).
    wsz supplies the new value as an LPCWSTR object (Unicode).

Return Value:

    A reference to the CText object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CText &
CText::operator=(
    const CText &tz)
{

    //
    // See what the other CText object has that's good, and copy it over here.
    //

    switch (m_fFlags = tz.m_fFlags)
    {
    case fNoneGood:
        // Nothing's Good!?!  ?Error?
        TRACE("CText -- Nothing listed as valid.")
        goto ErrorExit;
        break;

    case fAnsiGood:
        // The ANSI buffer is good.
        m_bfAnsi = tz.m_bfAnsi;
        break;

    case fUnicodeGood:
        // The Unicode buffer is good.
        m_bfUnicode = tz.m_bfUnicode;
        break;

    case fBothGood:
        // Everything is good.
        m_bfAnsi = tz.m_bfAnsi;
        m_bfUnicode = tz.m_bfUnicode;
        break;

    default:
        // Internal error.
        goto ErrorExit;
    }
    return *this;

ErrorExit:
    return *this;
}

LPCSTR
CText::operator=(
    LPCSTR sz)
{
    DWORD length;

    //
    // Reset the ANSI buffer.
    //

    if (NULL != sz)
    {
        length = strlen(sz) + sizeof(CHAR); // ?str?
        if (NULL == m_bfAnsi.Set((LPBYTE)sz, length))
            goto ErrorExit;
    }
    else
        m_bfAnsi.Reset();
    m_fFlags = fAnsiGood;
    return *this;

ErrorExit:  // ?what? do we do?
    return *this;
}

LPCWSTR
CText::operator=(
    LPCWSTR wsz)
{
    DWORD length;


    //
    // Reset the Unicode Buffer.
    //

    if (NULL != wsz)
    {
        length = wcslen(wsz) + sizeof(WCHAR);
        if (NULL == m_bfUnicode.Set((LPBYTE)wsz, length))
            goto ErrorExit;
    }
    else
        m_bfUnicode.Reset();
    m_fFlags = fUnicodeGood;
    return *this;

ErrorExit:  // ?what? do we do?
    return *this;
}


/*++

CText::operator+=:

    These methods append the given data to the existing CText object value,
    properly adjusting the object to the type of text.

Arguments:

    tz supplies the new value as a CText object.
    sz supples the new value as an LPCSTR object (ANSI).
    wsz supplies the new value as an LPCWSTR object (Unicode).

Return Value:

    A reference to the CText object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CText &
CText::operator+=(
    const CText &tz)
{

    //
    // Append the other's value to our good value.
    //

    switch (m_fFlags = tz.m_fFlags)
    {
    case fNoneGood:
        goto ErrorExit;
        break;

    case fAnsiGood:
        if (NULL == m_bfAnsi.Resize(m_bfAnsi.Length() - sizeof(CHAR), TRUE))
            goto ErrorExit;
        m_bfAnsi += tz.m_bfAnsi;
        break;

    case fUnicodeGood:
        if (NULL == m_bfUnicode.Resize(
                        m_bfUnicode.Length() - sizeof(WCHAR), TRUE))
            goto ErrorExit;
        m_bfUnicode = tz.m_bfUnicode;
        break;

    case fBothGood:
        if (NULL == m_bfAnsi.Resize(m_bfAnsi.Length() - sizeof(CHAR), TRUE))
            goto ErrorExit;
        m_bfAnsi = tz.m_bfAnsi;
        if (NULL == m_bfUnicode.Resize(
                        m_bfUnicode.Length() - sizeof(WCHAR), TRUE))
            goto ErrorExit;
        m_bfUnicode = tz.m_bfUnicode;
        break;

    default:
        goto ErrorExit;
    }
    return *this;

ErrorExit:  // ?What?
    return *this;
}

LPCSTR
CText::operator+=(
    LPCSTR sz)
{
    DWORD length;


    //
    // Extend ourself as an ANSI string.
    //

    if (NULL != sz)
    {
        length = strlen(sz);    // ?str?
        if (0 < length)
        {
            length += 1;
            length *= sizeof(CHAR);
            if (NULL == Ansi())
                goto ErrorExit;
            m_bfAnsi.Resize(m_bfAnsi.Length() - sizeof(CHAR), TRUE);
            if (NULL == m_bfAnsi.Append((LPBYTE)sz, length))
                goto ErrorExit;
            m_fFlags = fAnsiGood;
        }
    }
    return *this;

ErrorExit:  // ?what? do we do?
    return *this;
}

LPCWSTR
CText::operator+=(
    LPCWSTR wsz)
{
    DWORD length;


    //
    // Extend ourself as a Unicode string.
    //

    if (NULL != wsz)
    {
        length = wcslen(wsz);
        if (0 < length)
        {
            length += 1;
            length *= sizeof(WCHAR);
            if (NULL == Unicode())
                goto ErrorExit;
            m_bfUnicode.Resize(m_bfUnicode.Length() - sizeof(WCHAR), TRUE);
            if (NULL == m_bfUnicode.Append((LPBYTE)wsz, length))
                goto ErrorExit;
            m_fFlags = fUnicodeGood;
        }
    }
    return *this;

ErrorExit:  // ?what? do we do?
    return *this;
}


/*++

Unicode:

    This method returns the CText object as a Unicode string.

Arguments:

    None

Return Value:

    The value of the object expressed in Unicode.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline LPCWSTR
CText::Unicode(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fNoneGood:
        // No valid values.  Report an error.
        goto ErrorExit;
        break;

    case fAnsiGood:
        // The ANSI value is good.  Convert it to Unicode.
        if (0 < m_bfAnsi.Length())
        {
            length =
                MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    (LPCSTR)m_bfAnsi.Access(),
                    m_bfAnsi.Length() - sizeof(CHAR),
                    NULL,
                    0);
            if ((0 == length)
                || (NULL == m_bfUnicode.Resize(
                                (length + 1) * sizeof(WCHAR))))
                goto ErrorExit;
            length =
                MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    (LPCSTR)m_bfAnsi.Access(),
                    m_bfAnsi.Length() - sizeof(CHAR),
                    (LPWSTR)m_bfUnicode.Access(),
                    length);
            if (0 == length)
                goto ErrorExit;
            *(LPWSTR)m_bfUnicode.Access(length * sizeof(WCHAR)) = 0;
        }
        else
            m_bfUnicode.Reset();
        m_fFlags = fBothGood;
        break;

    case fUnicodeGood:
    case fBothGood:
        // The Unicode value is good.  Just return that.
        break;

    default:
        // Internal error.
        goto ErrorExit;
    }


    //
    // If we don't have any value, return a null string.
    //

    if (0 == m_bfUnicode.Length)
        return L"";
    else
        return (LPCWSTR)m_bfUnicode.Access();

ErrorExit:
    return NULL;
}


/*++

CText::Ansi:

    This method returns the value of the object expressed in an ANSI string.

Arguments:

    None

Return Value:

    The value of the object expressed as an ANSI string.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline LPCSTR
CText::Ansi(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fNoneGood:
        // Nothing is good!?!  Return an error.
        goto ErrorExit;
        break;

    case fUnicodeGood:
        // The Unicode buffer is good.  Convert it to ANSI.
        if (0 < m_bfUnicode.Length())
        {
            length =
                WideCharToMultiByte(
                    CP_ACP,
                    0,
                    (LPCWSTR)m_bfUnicode.Access(),
                    (m_bfUnicode.Length() / sizeof(WCHAR)) - 1,
                    NULL,
                    0,
                    NULL,
                    NULL);
            if ((0 == length)
                || (NULL == m_bfAnsi.Resize(
                                (length + 1) * sizeof(CHAR))))
                goto ErrorExit;
            length =
                WideCharToMultiByte(
                    CP_ACP,
                    0,
                    (LPCWSTR)m_bfUnicode.Access(),
                    (m_bfUnicode.Length() / sizeof(WCHAR)) - 1,
                    (LPSTR)m_bfAnsi.Access(),
                    length,
                    NULL,
                    NULL);
            if (0 == length)
                goto ErrorExit;
            *(LPSTR)m_bfAnsi.Access(length * sizeof(CHAR)) = 0;
        }
        else
            m_bfAnsi.Reset();
        m_fFlags = fBothGood;
        break;

    case fAnsiGood:
    case fBothGood:
        // The ANSI buffer is good.  We'll return that.
        break;

    default:
        // An internal error.
        goto ErrorExit;
    }


    //
    // If there's nothing in the ANSI buffer, return a null string.
    //

    if (0 == m_bfAnsi.Length)
        return "";
    else
        return (LPCSTR)m_bfAnsi.Access();

ErrorExit:
    return NULL;
}


/*++

Compare:

    These methods compare the value of this object to another value, and return
    a comparative value.

Arguments:

    tz supplies the value to be compared as a CText object.
    sz supplies the value to be compared as an ANSI string.
    wsz supplies the value to be compared as a Unicode string.

Return Value:

    < 0 - The supplied value is less than this object.
    = 0 - The supplied value is equal to this object.
    > 0 - The supplies value is greater than this object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline int
CText::Compare(
    const CText &tz)
{
    int nResult;


    //
    // See what we've got to compare.
    //

    switch (tz.m_fFlags)
    {
    case fNoneGood:
        // Nothing!?!  Complain.
        TRACE("CText - No format is valid.")
        goto ErrorExit;
        break;

    case fBothGood:
    case fAnsiGood:
        // Use the ANSI version for fastest comparison.
        if (NULL == Ansi())
            goto ErrorExit;
        nResult = strcmp((LPSTR)m_bfAnsi.Access(), (LPSTR)tz.m_bfAnsi.Access());  // ?str?
        break;

    case fUnicodeGood:
        // The Unicode version is good.
        if (NULL == Unicode())
            goto ErrorExit;
        nResult = wcscmp((LPWSTR)m_bfUnicode.Access(), (LPWSTR)tz.m_bfUnicode.Access());
        break;

    default:
        // Internal Error.
        goto ErrorExit;
    }
    return nResult;

ErrorExit:  // ?What?
    return 1;
}

inline int
CText::Compare(
    LPCSTR sz)
{

    //
    // Make sure our ANSI version is good.
    //

    if (NULL == Ansi())
        goto ErrorExit;

    //
    // Do an ANSI comparison.
    //

    return strcmp((LPCSTR)m_bfAnsi.Access(), sz);   // ?str?

ErrorExit:  // ?what?
    return 1;
}

inline int
CText::Compare(
    LPCWSTR wsz)
{

    //
    // Make sure our Unicode version is good.
    //

    if (NULL == Unicode())
        goto ErrorExit;


    //
    // Do the comparison using Unicode.
    //

    return wcscmp((LPCWSTR)m_bfUnicode.Access(), wsz);

ErrorExit:  // ?what?
    return 1;
}

#endif // _TEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\asn1\asnutils.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asnUtils

Abstract:

    This module contains the utility routines used by the internal ASN.1
    Classes.

Author:

    Doug Barlow (dbarlow) 10/9/1995

Environment:

    Win32

Notes:

    Some of these routines assume that an unsigned long int is 32 bits wide.

--*/

#include <windows.h>
#include "asnPriv.h"


/*++

ExtractTag:

    This routine extracts a tag from an ASN.1 BER stream.

Arguments:

    pbSrc supplies the buffer containing the ASN.1 stream.

    pdwTag receives the tag.

Return Value:

    >= 0 - The number of bytes extracted from the stream.

    <  0 - An error occurred.

Author:

    Doug Barlow (dbarlow) 10/9/1995

--*/

LONG
ExtractTag(
    const BYTE FAR *pbSrc,
    DWORD cbSrc,
    LPDWORD pdwTag,
    LPBOOL pfConstr)
{
    LONG lth = 0;
    DWORD tagw;
    BYTE tagc, cls;

    if (cbSrc < sizeof(BYTE))
    {
        lth = -1;
        goto ErrorExit;
    }

    tagc = pbSrc[lth++];

    cls = tagc & 0xc0;  // Top 2 bits.
    if (NULL != pfConstr)
        *pfConstr = (0 != (tagc & 0x20));
    tagc &= 0x1f;       // Bottom 5 bits.

    if (31 > tagc)
        tagw = tagc;
    else
    {
        tagw = 0;
        do
        {
            if (0 != (tagw & 0xfe000000))
            {
                TRACE("Integer Overflow")
                lth = -1;   // ?error? Integer overflow
                goto ErrorExit;
            }

            if (cbSrc < (DWORD)(lth+1))
            {
                lth = -1;
                goto ErrorExit;
            }

            tagc = pbSrc[lth++];

            tagw <<= 7;
            tagw |= tagc & 0x7f;
        } while (0 != (tagc & 0x80));
    }

    *pdwTag = tagw | (cls << 24);
    return lth;

ErrorExit:
    return lth;
}


/*++

ExtractLength:

    This routine extracts a length from an ASN.1 BER stream.  If the length is
    indefinite, this routine recurses to figure out the real length.  A flag as
    to whether or not the encoding was indefinite is optionally returned.

Arguments:

    pbSrc supplies the buffer containing the ASN.1 stream.

    pdwLen receives the len.

    pfIndefinite, if not NULL, receives a flag indicating whether or not the
        encoding was indefinite.

Return Value:

    >= 0 - The number of bytes extracted from the stream.

    <  0 - An error occurred.

Author:

    Doug Barlow (dbarlow) 10/9/1995

--*/

LONG
ExtractLength(
    const BYTE FAR *pbSrc,
    DWORD cbSrc,
    LPDWORD pdwLen,
    LPBOOL pfIndefinite)
{
    DWORD ll, rslt;
    LONG lth, lTotal = 0;
    BOOL fInd = FALSE;


    //
    // Extract the Length.
    //

    if (cbSrc < sizeof(BYTE))
    {
        lth = -1;
        goto ErrorExit;
    }

    if (0 == (pbSrc[lTotal] & 0x80))
    {

        //
        // Short form encoding.
        //

        rslt = pbSrc[lTotal++];
    }
    else
    {
        rslt = 0;
        ll = pbSrc[lTotal++] & 0x7f;

        if (0 != ll)
        {

            //
            // Long form encoding.
            //

            for (; 0 < ll; ll -= 1)
            {
                if (0 != (rslt & 0xff000000))
                {
                    TRACE("Integer Overflow")
                    lth = -1;   // ?error? Integer overflow
                    goto ErrorExit;
                }
                else
                {
                    if (cbSrc < (DWORD)(lTotal+1))
                    {
                        lth = -1;
                        goto ErrorExit;
                    }

                    rslt = (rslt << 8) | pbSrc[lTotal];
                }

                lTotal += 1;
            }
        }
        else
        {
            DWORD ls = lTotal;

            //
            // Indefinite encoding.
            //

            fInd = TRUE;

            if (cbSrc < ls+2)
            {
                lth = -1;
                goto ErrorExit;
            }

            while ((0 != pbSrc[ls]) || (0 != pbSrc[ls + 1]))
            {

                // Skip over the Type.
                if (31 > (pbSrc[ls] & 0x1f))
                    ls += 1;
                else
                {
                    while (0 != (pbSrc[++ls] & 0x80))
                    {
                        if (cbSrc < ls+2)
                        {
                            lth = -1;
                            goto ErrorExit;
                        }
                    }
                }

                lth = ExtractLength(&pbSrc[ls], cbSrc-ls, &ll);
                ls += lth + ll;

                if (cbSrc < ls+2)
                {
                    lth = -1;
                    goto ErrorExit;
                }
            }
            rslt = ls - lTotal;
        }
    }

    //
    // Supply the caller with what we've learned.
    //

    *pdwLen = rslt;
    if (NULL != pfIndefinite)
        *pfIndefinite = fInd;
    return lTotal;


ErrorExit:
    return lth;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\include\asnpriv.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asnpriv

Abstract:

    This header file contains definitions and symbols that are private to the
    Microsoft ASN.1 Compiler Run-Time Library.

Author:

    Doug Barlow (dbarlow) 10/9/1995

Environment:

    Win32

Notes:



--*/

#ifndef _ASNPRIV_H_
#define _ASNPRIV_H_

#include <memcheck.h>
#include "MSAsnLib.h"

extern LONG
ExtractTag(
    const BYTE FAR *pbSrc,
    DWORD cbSrc,
    LPDWORD pdwTag,
    LPBOOL pfConstr = NULL);

extern LONG
ExtractLength(
    const BYTE FAR *pbSrc,
    DWORD cbSrc,
    LPDWORD pdwLen,
    LPBOOL pfIndefinite = NULL);

#define ErrorCheck if (0 != GetLastError()) goto ErrorExit

#endif // _ASNPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\include\asnof.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asnof

Abstract:

    This header file provides the description of the ASN.1 SEQUENCE OF / SET OF.

Author:

    Doug Barlow (dbarlow) 10/8/1995

Environment:

    Win32

Notes:



--*/

#ifndef _ASNOF_H_
#define _ASNOF_H_

#include "asnpriv.h"


//
//==============================================================================
//
//  CAsnSeqsetOf
//

class CAsnSeqsetOf
:   public CAsnObject
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnSeqsetOf(
        IN DWORD dwFlags,
        IN DWORD dwTag,
        IN DWORD dwType);


    //  Properties
    //  Methods

    virtual void
    Clear(              // Empty the object.
        void);

    virtual DWORD
    Count(void) const
    { return m_rgEntries.Count(); };

    virtual LONG
    Add(void);

    virtual LONG
    Insert(
        DWORD dwIndex);


    //  Operators

// protected:
    //  Properties

    CDynamicArray<CAsnObject> m_rgDefaults;

    CAsnObject *m_pasnTemplate;


    //  Methods

    virtual BOOL
    TypeCompare(        // Compare the types of objects.
        const CAsnObject &asnObject)
    const;

    virtual LONG
    _copy(              // Copy another object to this one.
        const CAsnObject &asnObject);

    virtual LONG
    DecodeData(         // Read data in encoding format.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc,
        IN DWORD dwLength);
};

#endif // _ASNOF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\include\asncnstr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asncnstr

Abstract:

    This header file describes the ASN.1 Constructed Object.

Author:

    Doug Barlow (dbarlow) 10/8/1995

Environment:

    Win32

Notes:



--*/

#ifndef _ASNCNSTR_H_
#define _ASNCNSTR_H_

#include "asnpriv.h"


//
//==============================================================================
//
//  CAsnConstructed
//

class CAsnConstructed
:   public CAsnObject
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnConstructed(
        IN DWORD dwFlags,
        IN DWORD dwTag,
        IN DWORD dwType);


    //  Properties
    //  Methods
    //  Operators

// protected:
    //  Properties
    //  Methods
};

#endif // _ASNCNSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\include\asnprimt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asnprimt

Abstract:

    This header file provides the definitions for the ASN.1 Primitive Object.

Author:

    Doug Barlow (dbarlow) 10/8/1995

Environment:

    Win32

Notes:



--*/

#ifndef _ASNPRIMT_H_
#define _ASNPRIMT_H_

#include "asnpriv.h"


//
//==============================================================================
//
//  CAsnPrimitive
//

class CAsnPrimitive
:   public CAsnObject
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnPrimitive(
        IN DWORD dwFlags,
        IN DWORD dwTag,
        IN DWORD dwType);


    //  Properties
    //  Methods

    virtual void
    Clear(              // Empty the object.
        void);

    virtual LONG
    DataLength(         // Return the length of the object.
        void) const;

    virtual LONG
    Read(               // Return the value of the object.
        OUT LPBYTE pbDst)
        const;

    virtual LONG
    Write(              // Set the value of the object.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen);


    //  Operators

// protected:
    //  Properties

    CBuffer m_bfData;


    //  Methods

    virtual LONG
    _encLength(         // Return the length of the encoded object.
        void) const;

    virtual FillState   // Current fill state.
    State(
        void) const;

    virtual BOOL
    TypeCompare(        // Compare the types of objects.
        const CAsnObject &asnObject)
    const;

    virtual LONG
    Compare(            // Return a comparison to another object.
        const CAsnObject &asnObject)
    const;

    virtual LONG
    _copy(               // Copy another object to this one.
        const CAsnObject &asnObject);

    virtual LONG
    EncodeLength(       // Place encoding of Length, return length of encoding
        OUT LPBYTE pbDest)
    const;

    virtual LONG
    EncodeData(         // Place encoding of Data, return length of encoding
        OUT LPBYTE pbDest)
    const;

    virtual LONG
    DecodeData(         // Read data in encoding format.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc,
        IN DWORD dwLength);
};

#endif // _ASNPRIMT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\include\asnobjct.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asnobjct

Abstract:

    This module provides the Generic ASN.1 Support Object definitions.

Author:

    Doug Barlow (dbarlow) 10/8/1995

Environment:

    Win32

Notes:

    This code assumes that the width of an unsigned long integer is 32 bits.

--*/

#ifndef _ASNOBJCT_H_
#define _ASNOBJCT_H_

#include "asnpriv.h"


//
//==============================================================================
//
//  CAsnObject
//

class CAsnObject
{
public:

    enum Flags {
        fOptional    = 0x01,
        fDelete      = 0x02,
        fDefault     = 0x04,
        fPresent     = 0x08,
        fConstructed = 0x10 };

    enum Tags {
        tag_Undefined        = 0,
        tag_Boolean          = 1,
        tag_Integer          = 2,
        tag_Bitstring        = 3,
        tag_Octetstring      = 4,
        tag_Null             = 5,
        tag_ObjectIdentifier = 6,
        tag_ObjectDescriptor = 7,
        tag_External         = 8,
        tag_Real             = 9,
        tag_Enumerated       = 10,
        tag_Sequence         = 16,
        tag_Set              = 17,
        tag_NumericString    = 18,
        tag_PrintableString  = 19,
        tag_TeletexString    = 20,
        tag_VideotexString   = 21,
        tag_IA5String        = 22,
        tag_UniversalTime    = 23,
        tag_GeneralizedTime  = 24,
        tag_GraphicString    = 25,
        tag_VisibleString    = 26,
        tag_GeneralString    = 27,
        tag_UnicodeString    = 30 };

    enum Classes {
        cls_Universal       = 0,
        cls_Application     = 1,
        cls_ContextSpecific = 2,
        cls_Private         = 3 };


    //  Constructors & Destructor

    DECLARE_NEW

    CAsnObject(
        IN DWORD dwFlags,
        IN DWORD dwTag,
        IN DWORD dwType);

    virtual ~CAsnObject();


    //  Properties
    //  Methods


    // Exposed methods.

    virtual LONG
    Read(               // Return the value, making sure it's there.
        OUT CBuffer &bfDst)
        const;

    virtual LONG
    Write(              // Set the value of the object, clearing first.
        IN const CBuffer &bfSrc);

    virtual LONG
    Encode(             // Return the encoding, ensuring it's there.
        OUT CBuffer &bfDst)
        const;

    virtual LONG
    Decode(             // Load an encoding into the object, clearing it first.
        IN const CBuffer &bfSrc);

    virtual LONG
    Read(               // Return the value of the object, ensuring it's there.
        OUT LPBYTE pbDst)
        const;

    virtual LONG
    Write(              // Set the value of the object, clearing first.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen);

    virtual LONG
    Encode(             // Return the encoding of the object, making sure it's there.
        OUT LPBYTE pbDst)
        const;

    virtual LONG
    Decode(             // Load an encoding into the object, clearing it first.
        IN const BYTE FAR *pbSrc, IN DWORD cbSrc);

    virtual void
    Clear(              // Empty the object.
        void);

    virtual DWORD
    Tag(                // Return the tag of the object.
        void) const;

    virtual LONG
    DataLength(         // Return the length of the data, ensuring it's there.
        void) const;

    virtual LONG
    EncodingLength(     // Return the length of the encoded object if it's there
        void) const;


    //  Operators

    virtual int
    operator==(
        const CAsnObject &asnObject)
    const
    { State(); asnObject.State();
      return 0 == Compare(asnObject); };

    virtual int
    operator!=(
        const CAsnObject &asnObject)
    const
    { State(); asnObject.State();
      return 0 != Compare(asnObject); };

    virtual LONG
    Copy(
        const CAsnObject &asnObject);


// protected:

    enum Types {
        type_Undefined        = 0,
        type_Boolean          = 1,
        type_Integer          = 2,
        type_Bitstring        = 3,
        type_Octetstring      = 4,
        type_Null             = 5,
        type_ObjectIdentifier = 6,
        type_ObjectDescriptor = 7,
        type_External         = 8,
        type_Real             = 9,
        type_Enumerated       = 10,
        type_Sequence         = 16,
        type_Set              = 17,
        type_NumericString    = 18,
        type_PrintableString  = 19,
        type_TeletexString    = 20,
        type_VideotexString   = 21,
        type_IA5String        = 22,
        type_UniversalTime    = 23,
        type_GeneralizedTime  = 24,
        type_GraphicString    = 25,
        type_VisibleString    = 26,
        type_GeneralString    = 27,
        type_UnicodeString    = 30,
        type_Of               = 100,
        type_SequenceOf       = 116,    // Sequence + Of
        type_SetOf            = 117,    // Set + Of
        type_Tag              = 200,
        type_Choice           = 300,
        type_Any              = 400 };

    enum FillState {
        fill_Empty   = 0,
        fill_Present = 1,
        fill_Partial = 2,
        fill_Defaulted = 3,
        fill_Optional = 4,
        fill_NoElements = 5 };

    enum ChildActions {
        act_Cleared = 1,
        act_Written };


    //  Properties

    CAsnObject *m_pasnParent;

    CDynamicArray<CAsnObject> m_rgEntries;

    DWORD m_dwType;
    DWORD m_dwTag;
    DWORD m_dwFlags;
    FillState m_State;
    CBuffer m_bfDefault;


    //  Methods

    virtual LONG
    _decode(             // Load an encoding into the object
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc);

    virtual LONG
    _encLength(         // Return the length of the encoded object if it's there
        void) const;

    virtual LONG
    _encode(            // Encode the object, no presence checking.
        OUT LPBYTE pbDst)
    const;

    virtual void
    Adopt(
        IN CAsnObject *pasnParent);

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const = 0;

    virtual void
    ChildAction(        // Child notification method.
        IN ChildActions action,
        IN CAsnObject *pasnChild);

    virtual BOOL
    Complete(           // Is all data accounted for?
        void) const;

    virtual BOOL
    Exists(             // Is all data available to be read?
        void) const;

    virtual FillState   // Current fill state.
    State(
        void) const;

    virtual BOOL
    TypeCompare(        // Compare the types of objects.
        const CAsnObject &asnObject)
    const;

    virtual LONG
    Compare(            // Return a comparison to another object.
        const CAsnObject &asnObject)
    const;

    virtual LONG
    _copy(              // Copy another object to this one.
        const CAsnObject &asnObject);

    LONG
    virtual EncodeTag(  // Place encoding of tag, return length of encoding
        OUT LPBYTE pbDst)
    const;

    virtual LONG
    EncodeLength(       // Place encoding of Length, return length of encoding
        OUT LPBYTE pbDest)
    const;

    virtual LONG
    EncodeData(         // Place encoding of Data, return length of encoding
        OUT LPBYTE pbDest)
    const;

    virtual LONG
    SetDefault(         // Set the current value to be the default value.
        void);

    virtual LONG
    DecodeData(         // Read data in encoding format.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc,
        IN DWORD dwLength);

    virtual LONG
    EncodeLength(       // Place encoding of given Length, return length of encoding
        OUT LPBYTE pbDest,
        IN LONG lSize)
    const;
};

#endif // _ASNOBJCT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\licecert\certcate.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    certcate.cpp

Abstract:

    This module contains the implementation of routines for loading and
    verifying X509 certifcates.  It is adapted from Doug Barlow's
    PKCS library.

Author:

    Frederick Chong (fredch) 6/1/1998

Environment:

    Win32, WinCE, Win16

Notes:

--*/

#include <windows.h>

#include <objbase.h>

#include <math.h>
#ifndef OS_WINCE
#include <stddef.h>
#endif // ndef OS_WINCE
#include "certcate.h"
#include "crtStore.h"

#include "licecert.h"
#include "utility.h"
#include "pkcs_err.h"

#include "rsa.h"
#include "md5.h"
#include "sha.h"
#include "tssec.h"

//
//-----------------------------------------------------------------------------
// The number of padding bytes as recommended by PKCS #1
//

static const DWORD
    rgdwZeroes[2]
        = { 0, 0 };

//
//-----------------------------------------------------------------------------
//
// certificate handle management
//

static const BYTE
    HANDLE_CERTIFICATES     = 1;

static CHandleTable<CCertificate>
    grgCertificateHandles(
        HANDLE_CERTIFICATES);

static void
CvtOutString(
    IN const COctetString &osString,
    OUT LPBYTE pbBuffer,
    IN OUT LPDWORD pcbLength);


extern CCertificate *
MapCertificate(
    IN const BYTE FAR * pbCertificate,
    IN DWORD cbCertificate,
    IN DWORD dwTrust,
    IN OUT LPDWORD pdwType,
    IN OUT LPDWORD pfStore,
    OUT LPDWORD pdwWarnings,
    OUT COctetString &osIssuer,
    IN OUT LPDWORD pfDates,
    IN BOOL fRunOnce = FALSE );


/*++

MapCertificate:

    This routine tries to parse the given certificate until it can determine the
    actual type, creates that type, and returns it as a CCertificate object.

Arguments:

    pbCertificate - Supplies the certificate containing the key to be loaded.

    dwTrust - Supplies the level of trust to be used in certificate validation.

    pdwType - Supplies the type of the certificate, or CERTYPE_UNKNOWN if it is
        not known.  It receives the actual type of the certificate.

    pfStore - Supplies the minimum acceptable Certificate Store, and receives
        the store of the certifying root key.

    pdwWarnings - Receives any warning flags.  Warning flags can be any of the
        following, OR'ed together:

            CERTWARN_NO_CRL - At least one of the signing CAs didn't have an
                associated CRL.
            CERTWARN_EARLY_CRL - At least one of the signing CAs had an
                associated CRL who's issuing date was in the future.
            CERTWARN_LATE_CRL - At least one of the signing CAs had an expired
                CRL.
            CERTWARN_TOBEREVOKED - At least one of the signing CAs contained a
                revocation for a certificate, but its effective date has not yet
                been reached.

    osIssuer - Receives the name of the root authority, or on error, receives
        the name of the missing Issuer.

    fRunOnce - Used as an internal recursion control parameter.  Should be set to FALSE for
        a normal call, then is reset to true as we recurse to allow the dwTrust parameter
        to take effect.

Return Value:

    The correct CCertificate subclass.  Errors are thrown.

Author:

    Doug Barlow (dbarlow) 9/26/1995
    Frederick Chong (fredch) - modified 6/1/98

--*/

CCertificate *
MapCertificate(
    IN const BYTE FAR * pbCertificate,
    IN DWORD cbCertificate,
    IN DWORD dwTrust,
    IN OUT LPDWORD pdwType,
    IN OUT LPDWORD pfStore,
    OUT LPDWORD pdwWarnings,
    OUT COctetString &osIssuer,
    IN BOOL fRunOnce,
    IN OUT LPDWORD pfDates )
{
    CCertificate *pCert = NULL;
    LONG lth = -1;

    if( CERTYPE_UNKNOWN == *pdwType )
    {
        //
        // only support X509 certificate
        //

        Certificate * pAsnX509Cert;

        pAsnX509Cert = new Certificate;

        if( NULL == pAsnX509Cert )
        {
            ErrorThrow( PKCS_NO_MEMORY );
        }

        lth = pAsnX509Cert->Decode(pbCertificate,cbCertificate);

        delete pAsnX509Cert;

        if( 0 < lth )
        {
            ErrorThrow(PKCS_BAD_PARAMETER);
        }
    }
    else if( CERTYPE_X509 != *pdwType )
    {
        ErrorThrow(PKCS_BAD_PARAMETER);
    }

    //
    // create the X509 certificate object.
    //

    pCert = new CX509Certificate;

    if (NULL == pCert)
        ErrorThrow(PKCS_NO_MEMORY);

    pCert->Load(
        pbCertificate,
        cbCertificate,
        dwTrust,
        pfStore,
        pdwWarnings,
        osIssuer,
        pfDates,
        fRunOnce );

    ErrorCheck;

    *pdwType = pCert->Type();
    return pCert;

ErrorExit:

    if (NULL != pCert)
        delete pCert;

    return NULL;
}


/*++

CvtOutString:

    This routine converts an Octet String to an output buffer & length pair,
    taking into account that the output pair might be invalid or NULL.

Arguments:

    osString - Supplies the octet string to be copied out.
    pbBuffer - Receives the value of the octet string.
    pcbLength - Supplies the size of the pbBuffer, and receives the length of
        the ouput string.

Return Value:

    0 - Success.
    Anything else is an error, and represents the suggested value to throw.

Author:

    Doug Barlow (dbarlow) 8/23/1995

--*/

static void
CvtOutString(
    IN const COctetString &osString,
    OUT LPBYTE pbBuffer,
    IN OUT LPDWORD pcbLength)
{
    if (NULL != pcbLength)
    {
        DWORD len = *pcbLength;         // We can read pcbLength.
        *pcbLength = osString.Length(); // We can write pcbLength.
        if (NULL != pbBuffer)
        {
            if (len >= osString.Length())
            {
                if (0 < osString.Length())
                    memcpy(pbBuffer, osString.Access(), osString.Length());
            }
            else
            {
                if (NULL != pbBuffer)
                    ErrorThrow(PKCS_BAD_LENGTH);
            }
        }
    }
    return;

ErrorExit:
    return;
}


/*++

PkcsCertificateLoadAndVerify:

    This method loads and validates a given certificate for use.

Arguments:

    pbCert - Supplies a buffer containing the ASN.1 certificate.
    cbCert - Size of the certificate buffer
    pdwType - Supplies the type of the certificate, or CERTYPE_UNKNOWN if it is
        not known.  It receives the actual type of the certificate.
    dwStore - Supplies an identification of which certificate store this
        certificate should be loaded into.  Options are:

            CERTSTORE_APPLICATION - Store in application volatile memory
            CERTSTORE_CURRENT_USER - Store permanently in Registry under current
                user
            CERTSTORE_LOCAL_MACHINE - Store permanently in Registry under local
                machine

    dwTrust - Supplies the level of trust to be used in certificate validation.
    szIssuerName - Receives the name of the root issuer, or on error, receives
        the name of a missing issuer, if any.
    pcbIssuerLen - Supplies the length of the szIssuerName buffer, and receives
        the full length of the above issuer name, including trailing null byte.
    pdwWarnings - Receives a set of bits indicating certificate validation
        warnings that may occur.  Possible bit setting values are:

            CERTWARN_NO_CRL - At least one of the signing CAs didn't have an
                associated CRL.
            CERTWARN_EARLY_CRL - At least one of the signing CAs had an
                associated CRL who's issuing date was in the future.
            CERTWARN_LATE_CRL - At least one of the signing CAs had an expired
                CRL.
            CERTWARN_TOBEREVOKED - At least one of the signing CAs contained a
                revocation for a certificate, but its effective date has not yet
                been reached.

Return Value:

    TRUE - Successful validation, conditional to the pdwWarnings flags.
    FALSE - Couldn't be validated.  See LastError for details.

Author:

    Doug Barlow (dbarlow) 8/23/1995
    Frederick Chong (fredch) 6/1/1998 - remove unecessary function parameters

--*/

BOOL WINAPI
PkcsCertificateLoadAndVerify(
    OUT LPCERTIFICATEHANDLE phCert,
    IN const BYTE FAR * pbCert,
    IN DWORD cbCert,
    IN OUT LPDWORD pdwType,
    IN DWORD dwStore,
    IN DWORD dwTrust,
    OUT LPTSTR szIssuerName,
    IN OUT LPDWORD pcbIssuerLen,
    OUT LPDWORD pdwWarnings,
    IN OUT LPDWORD pfDates )
{
    const void *
        pvHandle
            = NULL;
    COctetString
        osIssuer,
        osSerialNum;
    CDistinguishedName
        dnName,
        dnIssuer;
    DWORD
        dwIssLen
            = *pcbIssuerLen,
        fStore
            = dwStore,
        dwWarnings
            = 0,
        dwType
            = CERTYPE_UNKNOWN;
    CCertificate *
        pSigner = NULL;
    BOOL
        fTmp;

    //
    // Initializations.
    //

    ErrorInitialize;

    if (NULL != pdwType)
        dwType = *pdwType;
    if (NULL != pdwWarnings)
        *pdwWarnings = 0;

    //
    // Validate the certificate by loading it into a CCertificate.
    //

    if (NULL != szIssuerName && *pcbIssuerLen > 0)
    {
        *pcbIssuerLen = 0;
        *szIssuerName = 0;
    }
    pSigner = MapCertificate(
                    pbCert,
                    cbCert,
                    dwTrust,
                    &dwType,
                    &fStore,
                    &dwWarnings,
                    osIssuer,
                    TRUE,
                    pfDates );
    CvtOutString(osIssuer, (LPBYTE)szIssuerName, &dwIssLen);
    *pcbIssuerLen = dwIssLen;
    ErrorCheck;
    pvHandle = grgCertificateHandles.Add(pSigner);
    ErrorCheck;

    //
    // Load the Certificate into the certificate store.
    //

    dnName.Import(pSigner->Subject());
    ErrorCheck;
    AddCertificate(dnName, pbCert, cbCert, dwType, dwStore);
    ErrorCheck;
    if (pSigner->HasParent())
    {
        dnIssuer.Import(pSigner->Issuer());
        ErrorCheck;
        pSigner->SerialNo(osSerialNum);
        ErrorCheck;
        AddReference(
            dnName,
            dnIssuer,
            osSerialNum.Access(),
            osSerialNum.Length(),
            dwStore);
        ErrorCheck;
    }


    //
    // Tell it all to the caller.
    //

    if (NULL != pdwType)
        *pdwType = dwType;
    if (NULL != pdwWarnings)
        *pdwWarnings = dwWarnings;

    *phCert = pvHandle;

    return MapError();

ErrorExit:

    if (NULL != pvHandle)
        grgCertificateHandles.Delete(pvHandle);

    return MapError();
}



/*++

PkcsGetPublicKey:

    This method retrieves the public key in an X509 certificate

Arguments:

    hCert - Handle to a certificate.
    lpPubKey - Memory to receive the public key
    lpcbPubKey - Size of the above memory

Return Value:

    TRUE - Successful validation, conditional to the pdwWarnings flags.
    FALSE - Couldn't be validated.  See LastError for details.

Author:

    Frederick Chong (fredch) 6/1/1998

--*/

BOOL WINAPI
PkcsCertificateGetPublicKey(
    CERTIFICATEHANDLE   hCert,
    LPBYTE              lpPubKey,
    LPDWORD             lpcbPubKey )
{
    CCertificate *pCert;

    ErrorInitialize;

    pCert = grgCertificateHandles.Lookup(hCert);
    ErrorCheck;

    pCert->GetPublicKey( lpPubKey, lpcbPubKey );
    ErrorCheck;

    return MapError();

ErrorExit:

    return MapError();
}


BOOL WINAPI
PkcsCertificateCloseHandle(
    CERTIFICATEHANDLE   hCert )
{
    CCertificate *pSigner;
    CDistinguishedName dnName;

    ErrorInitialize;
    pSigner = grgCertificateHandles.Lookup(hCert);
    ErrorCheck;
    dnName.Import(pSigner->Subject());
    ErrorCheck;
    DeleteCertificate(dnName);
    ErrorCheck;
    grgCertificateHandles.Delete(hCert);
    ErrorCheck;
    return TRUE;

ErrorExit:
    return MapError();

}


//
//==============================================================================
//
//  CCertificate
//


//
// Trivial Methods
//

IMPLEMENT_NEW(CCertificate)

CCertificate::CCertificate()
{ Init(); }

CCertificate::~CCertificate()
{ Clear(); }

void
CCertificate::Load(
    IN const BYTE FAR * pbCertificate,
    IN DWORD cbCertificate,
    IN DWORD dwTrust,
    IN OUT LPDWORD pfStore,
    OUT LPDWORD pdwWarnings,
    OUT COctetString &osIssuer,
    IN OUT LPDWORD pfDates,
    IN BOOL fRunOnce )
{
    ErrorThrow(PKCS_INTERNAL_ERROR);    // Should never be called.
ErrorExit:
    return;
}

const Name &
CCertificate::Subject(
    void)
const
{
    ErrorThrow(PKCS_INTERNAL_ERROR);    // Should never be called.
ErrorExit:
    return *(Name *)NULL;
}

DWORD
CCertificate::Type(
    void)
const
{
    ErrorThrow(PKCS_INTERNAL_ERROR);    // Should never be called.
ErrorExit:
    return 0;
}

BOOL
CCertificate::HasParent(
    void)
const
{
    return FALSE;
}

const Name &
CCertificate::Issuer(
    void)
const
{
    ErrorThrow(PKCS_INTERNAL_ERROR);    // Should never be called.
ErrorExit:
    return *(Name *)NULL;
}

void
CCertificate::SerialNo(
    COctetString &osSerialNo)
const
{
    ErrorThrow(PKCS_INTERNAL_ERROR);    // Should never be called.
ErrorExit:
    return;
}


/*++

Init:

    This method initializes the object to a default state.  It does not perform
    any deletion of allocated objects.  Use Clear for that.

Arguments:

    none

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/26/1995

--*/

void
CCertificate::Init(
    void)
{
}


/*++

Clear:

    This routine clears out all allocations of the object and returns it to its
    initial state.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/26/1995

--*/

void
CCertificate::Clear(
    void)
{
    Init();
}


/*++

Verify:

    This method uses the underlying Public Key from the certificate to validate
    a signature on a given block of data.

Arguments:

    pbSigned supplies the data that was signed.
    cbSignedLen supplies the length of that data, in bytes.
    algIdSignature supplies the signature type used to generate the signature.
    szDescription supplies a description string incorporated into the hash.
        This parameter may be NULL if no such string was used.
    pbSignature supplies the signature in DWORD format.
    cbSigLen supplies the length of the signature.

Return Value:

    None.  A DWORD is thrown on errors.

Author:

    Frederick Chong (fredch) 5/30/98

--*/

void
CCertificate::Verify(
    IN const BYTE FAR * pbSigned,
    IN DWORD cbSigned,
    IN DWORD cbSignedLen,
    IN ALGORITHM_ID algIdSignature,
    IN LPCTSTR szDescription,
    IN const BYTE FAR * pbSignature,
    IN DWORD cbSigLen)
    const
{
    DWORD
        dwHashAlg,
        dwHashLength;

    LPBSAFE_PUB_KEY
        pBsafePubKey = ( LPBSAFE_PUB_KEY  )m_osPublicKey.Access();
    MD5_CTX
        Md5Hash;
    A_SHA_CTX
        ShaHash;
    LPBYTE
        pbHashData;
    BYTE
        abShaHashValue[A_SHA_DIGEST_LEN];
    COctetString
        osSignedData,
        osSignature,
        osHashData;
    BOOL
        bResult = TRUE;

    //
    // Verify the signature.
    //

    dwHashAlg = GET_HASH_ALG(algIdSignature);


    //
    // only support RSA signing
    //

    if( SIGN_ALG_RSA != ( GET_SIGN_ALG(algIdSignature) ) )
    {
        ErrorThrow(PKCS_BAD_PARAMETER);
    }

    //
    // compute the hash
    //

    if( HASH_ALG_MD5 == dwHashAlg )
    {
        //
        // calculate MD5 hash
        //

        if (cbSigned < cbSignedLen)
        {
            ErrorThrow(PKCS_BAD_PARAMETER);
        }

        MD5Init( &Md5Hash );
        MD5Update( &Md5Hash, pbSigned, cbSignedLen );
        MD5Final( &Md5Hash );
        pbHashData = Md5Hash.digest,
        dwHashLength = MD5DIGESTLEN;
    }
    else if( ( HASH_ALG_SHA == dwHashAlg ) || ( HASH_ALG_SHA1 == dwHashAlg ) )
    {
        //
        // calculate SHA hash
        //

        if (cbSigned < cbSignedLen)
        {
            ErrorThrow(PKCS_BAD_PARAMETER);
        }

        A_SHAInit( &ShaHash );
        A_SHAUpdate( &ShaHash, ( LPBYTE )pbSigned, cbSignedLen );
        A_SHAFinal( &ShaHash, abShaHashValue );
        pbHashData = abShaHashValue;
        dwHashLength = A_SHA_DIGEST_LEN;
    }
    else
    {
        //
        // no support for other hash algorithm
        //

        ErrorThrow( PKCS_BAD_PARAMETER );
    }

    osSignature.Resize( cbSigLen + sizeof( rgdwZeroes ) );
    ErrorCheck;

    osSignature.Set(pbSignature, cbSigLen);
    ErrorCheck;

    osSignature.Append( ( const unsigned char * )rgdwZeroes, sizeof( rgdwZeroes ) );
    ErrorCheck;

    osSignedData.Resize( pBsafePubKey->keylen );
    ErrorCheck;
    memset( osSignedData.Access(), 0x00, osSignedData.Length() );

    if( !( bResult = BSafeEncPublic( pBsafePubKey, osSignature.Access(), osSignedData.Access() ) ) )
    {
        ErrorThrow( PKCS_CANT_VALIDATE );
    }
    else
    {
        ErrorInitialize;
    }

    PkcsToDword( osSignedData.Access(), osSignedData.Length() );

    GetHashData( osSignedData, osHashData );
    ErrorCheck;

    if( 0 != memcmp( osHashData.Access(), pbHashData,
                     osHashData.Length() > dwHashLength ?
                     dwHashLength : osHashData.Length() ) )
    {
        ErrorThrow( PKCS_CANT_VALIDATE );
    }

    return;

ErrorExit:

    return;
}


/*++

GetPublicKey

    This method retrieves the public key in a certificate

Arguments:

    pbPubKey Memory to copy the public key to
    lpcbPubKey Size of the memory

Return Value:

    None.  A DWORD is thrown on errors.

Author:

    Frederick Chong (fredch) 5/30/98

--*/

void
CCertificate::GetPublicKey(
    IN LPBYTE pbPubKey,
    IN OUT LPDWORD lpcbPubKey )
    const
{
    DWORD cbKeySize = m_osPublicKey.Length();

    if( 0 >= cbKeySize )
    {
        ErrorThrow( PKCS_INTERNAL_ERROR )
    }

    if( ( *lpcbPubKey < cbKeySize ) || ( NULL == pbPubKey ) )
    {
        ErrorThrow( PKCS_BAD_LENGTH );
    }

    memcpy( pbPubKey, m_osPublicKey.Access(), cbKeySize );
    *lpcbPubKey = cbKeySize;

    return;

ErrorExit:

    *lpcbPubKey = cbKeySize;

    return;
}


//
//==============================================================================
//
//  CX509Certificate
//

//
// Trivial Methods
//

IMPLEMENT_NEW(CX509Certificate)

CX509Certificate::CX509Certificate()
{
    Init();
}

CX509Certificate::~CX509Certificate()
{
    Clear();
}

const Name &
CX509Certificate::Subject(
    void)
const
{
    return m_asnCert.subject;
}

const CertificateToBeSigned &
CX509Certificate::Coding(
    void)
const
{
    return m_asnCert;
}

DWORD
CX509Certificate::Type(
    void)
const
{
    return CERTYPE_X509;
}

const Name &
CX509Certificate::Issuer(
    void)
const
{
    return m_asnCert.issuer;
}

void
CX509Certificate::SerialNo(
    COctetString &osSerialNo)
const
{
    LONG lth;
    lth = m_asnCert.serialNumber.DataLength();
    if (0 > lth)
        ErrorThrow(PKCS_ASN_ERROR);
    osSerialNo.Resize(lth);
    ErrorCheck;
    lth = m_asnCert.serialNumber.Read(osSerialNo.Access());
    if (0 > lth)
        ErrorThrow(PKCS_ASN_ERROR);
ErrorExit:
    return;
}


/*++

Init:

    This method initializes the object to a default state.  It does not perform
    any deletion of allocated objects.  Use Clear for that.

Arguments:

    none

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/26/1995

--*/

void
CX509Certificate::Init(
    void)
{
    CCertificate::Init();
}


/*++

Clear:

    This routine clears out all allocations of the object and returns it to its
    initial state.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/26/1995

--*/

void
CX509Certificate::Clear(
    void)
{
    m_asnCert.Clear();
    CCertificate::Clear();
    Init();
}


void
CX509Certificate::Load(
    IN const BYTE FAR * pbCertificate,
    IN DWORD cbCertificate,
    IN DWORD dwTrust,
    IN OUT LPDWORD pfStore,
    OUT LPDWORD pdwWarnings,
    OUT COctetString &osIssuer,
    IN OUT LPDWORD pfDates,
    IN BOOL fRunOnce )
{
    CCertificate *
        pcrtIssuer
            = NULL;

    Load2(
        pbCertificate,
        cbCertificate,
        dwTrust,
        pfStore,
        pdwWarnings,
        osIssuer,
        fRunOnce,
        &pcrtIssuer,
        pfDates );

    if ((NULL != pcrtIssuer) && (pcrtIssuer != this))
        delete pcrtIssuer;
}



void
CX509Certificate::Load2(
    IN const BYTE FAR * pbCertificate,
    IN DWORD cbCertificate,
    IN DWORD dwTrust,
    IN OUT LPDWORD pfStore,
    OUT LPDWORD pdwWarnings,
    OUT COctetString &osIssuer,
    IN BOOL fRunOnce,
    OUT CCertificate **ppcrtIssuer,
    IN OUT LPDWORD pfDates )
{
    Certificate *
        pAsnCert = NULL;
    CDistinguishedName
        dnIssuer;
    CCertificate *
        pcrtIssuer
            = NULL;
    COctetString
        osCert,
        osIssuerCRL;
    DWORD
        dwWarnings
            = 0,
        length,
        offset,
        dwType,
        count,
        index,
        version;
    BOOL
        fTmp,
        fRoot
            = FALSE;
    FILETIME
        tmNow,
        tmThen;
    SYSTEMTIME
        sysTime;

    pAsnCert = new Certificate;

    if( NULL == pAsnCert )
    {
        ErrorThrow( PKCS_NO_MEMORY );
    }

    //
    // Properly initialize the object.
    //

    Clear();
    if (NULL != pdwWarnings)
        *pdwWarnings = 0;
    osIssuer.Empty();

    if (0 > pAsnCert->Decode(pbCertificate, cbCertificate))
        ErrorThrow(PKCS_ASN_ERROR);

    if (0 > m_asnCert.Copy(pAsnCert->toBeSigned))
    {
        TRACE("Copy failure")
        ErrorThrow(PKCS_ASN_ERROR);
    }
    PKInfoToBlob(
        m_asnCert.subjectPublicKeyInfo,
        m_osPublicKey);
    ErrorCheck;

    //
    // First simple checks.
    //

    if (m_asnCert.version.Exists())
    {
        version = m_asnCert.version;
        if (X509_MAX_VERSION < version)
            ErrorThrow(PKCS_NO_SUPPORT);       // Version 3 maximum.
    }
    else
        version = X509_VERSION_1;


    if( CERT_DATE_DONT_VALIDATE != *pfDates )
    {
        //
        // Check the validity dates.
        //

        GetSystemTime( &sysTime );

        if( !SystemTimeToFileTime( &sysTime, &tmNow ) )
        {
            ErrorThrow( PKCS_CANT_VALIDATE );
        }

        tmThen = m_asnCert.validity.notBefore;
        if(1 == CompareFileTime(&tmThen, &tmNow))
        {
            if( CERT_DATE_ERROR_IF_INVALID == *pfDates )
            {
                //
                // invalid date results in cert validation error
                //

                *pfDates = CERT_DATE_NOT_BEFORE_INVALID;
                ErrorThrow(PKCS_CANT_VALIDATE);
            }
            else
            {
                //
                // Not an error, return the date validation result.
                //

                *pfDates = CERT_DATE_NOT_BEFORE_INVALID;
                goto next_check;
            }
        }

        tmThen = m_asnCert.validity.notAfter;
        if (1 == CompareFileTime(&tmNow, &tmThen))
        {
            if( CERT_DATE_ERROR_IF_INVALID == *pfDates )
            {
                //
                // invalid date results in cert validation error
                //

                *pfDates = CERT_DATE_NOT_AFTER_INVALID;
                ErrorThrow(PKCS_CANT_VALIDATE);
            }

            //
            // Not an error, return the date validation result.
            //

            *pfDates = CERT_DATE_NOT_AFTER_INVALID;
        }
        else
        {
            //
            // Both dates are OK
            //

            *pfDates = CERT_DATE_OK;
        }
    }

next_check:

    //
    // Do we have to validate this certificate?
    //

    if ((CERTTRUST_NOCHECKS != dwTrust)
        && (fRunOnce ? (dwTrust != *pfStore) : TRUE))
    {

        //
        // Find the signer.
        //

        dnIssuer.Import(m_asnCert.issuer);
        ErrorCheck;
        fTmp = NameCompare(m_asnCert.issuer, m_asnCert.subject);
        ErrorCheck;
        if (fTmp)
        {

            //
            // This is a root key.  We just assume it's good, and that we don't
            // have any outstanding CRL entries against ourself.
            //

            fRoot = TRUE;
            pcrtIssuer = this;
            dnIssuer.Export(osIssuer);
            ErrorCheck;
        }
        else
        {
            COctetString
                osIssuerCert;

            fTmp =
                FindCertificate(
                    dnIssuer,
                    pfStore,
                    osIssuerCert,
                    osIssuerCRL,
                    &dwType);
            ErrorCheck;
            if (!fTmp)
            {
                dnIssuer.Export(osIssuer);
                ErrorThrow(PKCS_CANT_VALIDATE);
            }

            //
            // map the issuer certificate to a known certificate type, but this time
            // don't verify the issuer certificate again.
            //

            pcrtIssuer =
                MapCertificate(
                osIssuerCert.Access(),
                osIssuerCert.Length(),
                CERTTRUST_NOCHECKS,
                &dwType,
                pfStore,
                &offset,
                osIssuer,
                FALSE,
                pfDates );
            ErrorCheck;
            dwWarnings |= offset;
        }


        //
        // Validate the certificate against the signer's key.
        //

        VerifySignedAsn(
            *pcrtIssuer,
            pbCertificate,
            cbCertificate,
            NULL);      // No description attributes here.
        ErrorCheck;


        //
        // Validate the certificate against the signer's CRL.
        //

        if (0 != osIssuerCRL.Length())
        {
            CertificateRevocationList
                asnIssuerCRL;

            //
            // Check the signature on the CRL.
            //

            if (0 > asnIssuerCRL.Decode(osIssuerCRL.Access(), osIssuerCRL.Length()))
                ErrorThrow(PKCS_ASN_ERROR);
            VerifySignedAsn(
                *pcrtIssuer,
                osIssuerCRL.Access(),
                osIssuerCRL.Length(),
                NULL);
            ErrorCheck;


            //
            // Check the trivial fields, issuer and algorithm.
            //

            fTmp = NameCompare(
                m_asnCert.issuer, asnIssuerCRL.toBeSigned.issuer);
            ErrorCheck;
            if (!fTmp)
                ErrorThrow(PKCS_CANT_VALIDATE);
            if (m_asnCert.subjectPublicKeyInfo.algorithm
                != asnIssuerCRL.toBeSigned.signature)
                ErrorThrow(PKCS_CANT_VALIDATE);


            //
            // Validate the CRL times.
            //

            tmThen = asnIssuerCRL.toBeSigned.lastUpdate;
            if (1 == CompareFileTime(&tmThen, &tmNow))
                dwWarnings |= CERTWARN_EARLYCRL;
            if (asnIssuerCRL.toBeSigned.nextUpdate.Exists())
            {
                tmThen = asnIssuerCRL.toBeSigned.nextUpdate;
                if (1 == CompareFileTime(&tmNow, &tmThen))
                    dwWarnings |= CERTWARN_LATECRL;
            }
            else
            {
                if (asnIssuerCRL.toBeSigned.version.Exists())
                {
                    version = asnIssuerCRL.toBeSigned.version;
                    if (X509_VERSION_1 >= version)
                        ErrorThrow(PKCS_ASN_ERROR);
                }
                else
                    version = X509_VERSION_1;
            }


            //
            // Look for revocations of this certificate.
            //

            if (asnIssuerCRL.toBeSigned.revokedCertificates.Exists())
            {
                length = asnIssuerCRL.toBeSigned.revokedCertificates.Count();
                for (offset = 0; offset < length; offset += 1)
                {
                    if (asnIssuerCRL.toBeSigned.revokedCertificates[(int)offset]
                            .userCertificate
                        == m_asnCert.serialNumber)
                    {
                        tmThen = asnIssuerCRL.toBeSigned
                                    .revokedCertificates[(int)offset].revocationDate;
                        if (0 == FTINT(tmThen))
                            ErrorThrow(PKCS_ASN_ERROR);
                        if (1 == CompareFileTime(&tmThen, &tmNow))
                            dwWarnings |= CERTWARN_TOBEREVOKED;
                        else
                            ErrorThrow(PKCS_CANT_VALIDATE);
                    }
                }
            }
        }
        else
        {
            if (!fRoot)
                dwWarnings |= CERTWARN_NOCRL;
        }
    }
    else
    {
        dnIssuer.Import(m_asnCert.subject);
        ErrorCheck;
        dnIssuer.Export(osIssuer);
        ErrorCheck;
        TRACE("Implicit trust invoked on subject "
              << (LPCTSTR)osIssuer.Access());
    }


    //
    // Check the extensions list for anything critical.
    //

    count = m_asnCert.extensions.Count();
    for (index = 0; index < count; index += 1)
    {
        if (m_asnCert.extensions[(int)index].critical.Exists())
            if (m_asnCert.extensions[(int)index].critical)
                dwWarnings |= CERTWARN_CRITICALEXT;
    }


    //
    // Everything checks out.  Load up the object.
    //

    *ppcrtIssuer = pcrtIssuer;
    pcrtIssuer = NULL;
    if (NULL != pdwWarnings)
        *pdwWarnings = dwWarnings;

    if( pAsnCert )
    {
        delete pAsnCert;
    }

    return;

ErrorExit:
    if ((NULL != pcrtIssuer) && (pcrtIssuer != this))
        delete pcrtIssuer;

    if( pAsnCert )
    {
        delete pAsnCert;
    }

    Clear();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\include\msasnlib.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    msasnlib

Abstract:

    This header file provides the definitions and symbols for access to the
Microsoft ASN.1 Support Library.

Author:

    Doug Barlow (dbarlow) 9/29/1995

Environment:

    Win32, C++

Notes:



--*/

#ifndef _MSASNLIB_H_
#define _MSASNLIB_H_

#include "Buffers.h"

//
// use template version of dynamic array for non-win16 compile
//

#include "DynArray.h"

#include "asnobjct.h"
#include "asnprimt.h"
#include "asncnstr.h"
#include "asnof.h"
#include "asntext.h"

#ifndef FTINT
#define FTINT(tm) (*(_int64 *)&(tm))
#endif

inline DWORD
UNIVERSAL(
    DWORD dwTag)
{
    return (CAsnObject::cls_Universal << 30) + dwTag;
}

inline DWORD
APPLICATION(
    DWORD dwTag)
{
    return (CAsnObject::cls_Application << 30) + dwTag;
}

inline DWORD
TAG(
    DWORD dwTag)
{
    return (CAsnObject::cls_ContextSpecific << 30) + dwTag;
}

inline DWORD
PRIVATE(
    DWORD dwTag)
{
    return (CAsnObject::cls_Private << 30) + dwTag;
}


//
//==============================================================================
//
//  CAsnBoolean
//

class CAsnBoolean
:   public CAsnPrimitive
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnBoolean(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Boolean);


    //  Properties
    //  Methods

    virtual LONG
    Write(              // Set the value of the object.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen);


    //  Operators

    operator BOOL(void)
    const;

    BOOL
    operator =(BOOL fValue);

// protected:
    //  Properties
    //  Methods

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;

    virtual LONG
    DecodeData(         // Read data in encoding format.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc,
        IN DWORD dwLength);
};


//
//==============================================================================
//
//  CAsnInteger
//

class CAsnInteger
:   public CAsnPrimitive
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnInteger(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Integer);


    //  Properties
    //  Methods

    virtual LONG
    Write(              // Set the value of the object as an array of DWORDs.
        IN const DWORD *pdwSrc,
        IN DWORD cdwSrcLen = 1);

    virtual LONG
    Write(              // Set the value of the object, clearing first.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen);


    //  Operators

    operator LONG(void)
    const;

    operator ULONG(void)
    const;

    LONG
    operator =(LONG lValue);

    ULONG
    operator =(ULONG lValue);

// protected:
    //  Properties
    //  Methods

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnBitstring
//

class CAsnBitstring
:   public CAsnPrimitive
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnBitstring(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Bitstring);


    //  Properties
    //  Methods

    virtual LONG
    DataLength(         // Return the length of the object.
        void) const;

    virtual LONG
    Read(               // Return the value of the object.
        OUT CBuffer &bfDst,
        OUT int *offset = NULL)
        const;

    virtual LONG
    Read(               // Return the value of the object.
        OUT LPBYTE pbDst,
        OUT int *offset)
        const;

    virtual LONG
    Write(              // Set the value of the object.
        IN const CBuffer &bfSrc,
        IN int offset = 0);

    virtual LONG
    Write(              // Set the value of the object.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen,
        IN int offset = 0);


    //  Operators

// protected:
    //  Properties
    //  Methods

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnOctetstring
//

class CAsnOctetstring
:   public CAsnPrimitive
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnOctetstring(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Octetstring);


    //  Properties
    //  Methods
    //  Operators

// protected:
    //  Properties
    //  Methods

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnNull
//

class CAsnNull
:   public CAsnPrimitive
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnNull(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Null);


    //  Properties
    //  Methods

    virtual void
    Clear(void);

    virtual LONG
    Write(
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen);


    //  Operators

// protected:
    //  Properties
    //  Methods

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;

    virtual LONG
    DecodeData(
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc,
        IN DWORD dwLength);
};


//
//==============================================================================
//
//  CAsnObjectIdentifier
//

class CAsnObjectIdentifier
:   public CAsnPrimitive
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnObjectIdentifier(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_ObjectIdentifier);


    //  Properties
    //  Methods

    operator LPCTSTR(void) const;

    LPCTSTR
    operator =(
        LPCTSTR szValue);


    //  Operators

// protected:

    //  Properties

    CBuffer m_bfText;


    //  Methods

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnReal
//

class CAsnReal
:   public CAsnPrimitive
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnReal(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Real);


    //  Properties
    //  Methods
    //  Operators

    operator double(void)
    const;

    double
    operator =(double rValue);


// protected:
    //  Properties
    //  Methods

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnEnumerated
//

class CAsnEnumerated
:   public CAsnPrimitive
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnEnumerated(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Enumerated);


    //  Properties
    //  Methods     ?todo? - What is this?
    //  Operators

// protected:
    //  Properties
    //  Methods

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnSequence & CAsnSequenceOf
//

class CAsnSequence
:   public CAsnConstructed
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnSequence(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Sequence);


    //  Properties
    //  Methods
    //  Operators

// protected:
    //  Properties
    //  Methods
};

class CAsnSequenceOf
:   public CAsnSeqsetOf
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnSequenceOf(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Sequence);


    //  Properties
    //  Methods
    //  Operators

// protected:
    //  Properties
    //  Methods
};


//
//==============================================================================
//
//  CAsnSet & CAsnSetOf
//

class CAsnSet
:   public CAsnConstructed
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnSet(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Set);


    //  Properties
    //  Methods
    //  Operators

// protected:
    //  Properties
    //  Methods
};

class CAsnSetOf
:   public CAsnSeqsetOf
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnSetOf(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Set);


    //  Properties
    //  Methods
    //  Operators

// protected:
    //  Properties
    //  Methods
};


//
//==============================================================================
//
//  CAsnTag
//

class CAsnTag
:   public CAsnConstructed
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnTag(
        IN DWORD dwFlags,
        IN DWORD dwTag);


    //  Properties
    //  Methods

    virtual LONG
    DataLength(         // Return the length of the object.
        void) const;

    virtual LONG
    Read(               // Return the value of the object.
        OUT LPBYTE pbDst)
        const;

    virtual LONG
    Write(              // Set the value of the object.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen);


    //  Operators


// protected:

    //  Properties
    //  Methods

    virtual void
    Reference(
        CAsnObject *pasn);

    virtual CAsnObject *
    Clone(
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnAny
//

class CAsnAny
:   public CAsnObject
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnAny(
        IN DWORD dwFlags);


    //  Properties
    //  Methods

    virtual void
    Clear(              // Empty the object.
        void);

    virtual DWORD
    Tag(                // Return the tag of the object.
        void) const;

    virtual LONG
    DataLength(         // Return the length of the object.
        void) const;

    virtual LONG
    Read(               // Return the value of the object.
        OUT LPBYTE pbDst)
        const;

    virtual LONG
    Write(              // Set the value of the object.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen);

    virtual LONG
    Cast(               // Fill another ASN.1 structure from the ANY.
        OUT CAsnObject &asnObj);

    CAsnObject &
    operator =(         // Set the ANY value from another ASN.1 object
        IN const CAsnObject &asnValue);


    //  Operators


// protected:

    //  Properties

    CBuffer m_bfData;
    DWORD m_dwDefaultTag;


    //  Methods

    virtual LONG
    _decode(         // Load an encoding into the object.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc);

    virtual LONG
    _encLength(         // Return the length of the encoded object.
        void) const;

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;

    virtual FillState   // Current fill state.
    State(
        void) const;

    virtual BOOL
    TypeCompare(        // Compare the types of objects.
        const CAsnObject &asnObject)
    const;

    virtual LONG
    Compare(            // Return a comparison to another object.
        const CAsnObject &asnObject)
    const;

    virtual LONG
    _copy(              // Copy another object to this one.
        const CAsnObject &asnObject);

    virtual LONG
    EncodeLength(       // Place encoding of Length, return length of encoding
        OUT LPBYTE pbDest)
    const;

    virtual LONG
    EncodeData(         // Place encoding of Data, return length of encoding
        OUT LPBYTE pbDest)
    const;

    virtual LONG
    SetDefault(         // Set the current value to be the default value.
        void);

    virtual LONG
    DecodeData(         // Read data in encoding format.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc,
        IN DWORD dwLength);

};


//
//==============================================================================
//
//  CAsnChoice
//

class CAsnChoice
:   public CAsnObject
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnChoice(
        IN DWORD dwFlags);


    //  Properties
    //  Methods

    virtual DWORD
    Tag(                // Return the tag of the object.
        void) const;

    virtual LONG
    DataLength(         // Return the length of the object.
        void) const;

    virtual LONG
    Read(               // Return the value of the object.
        OUT LPBYTE pbDst)
        const;

    virtual LONG
    Write(              // Set the value of the object.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen);


    //  Operators


// protected:
    //  Properties

    DWORD m_nActiveEntry;
    DWORD m_dwDefaultTag;


    //  Methods

    virtual LONG
    _decode(         // Load an encoding into the object.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc);

    virtual LONG
    _encLength(         // Return the length of the encoded object.
        void) const;

    virtual LONG
    SetDefault(         // Set the current value to be the default value.
        void);

    virtual FillState   // Current fill state.
    State(
        void) const;

    virtual LONG
    Compare(            // Return a comparison to another object.
        const CAsnObject &asnObject)
    const;

    virtual LONG
    _copy(              // Copy another object to this one.
        const CAsnObject &asnObject);

    virtual LONG
    EncodeTag(          // Place encoding of Tag, return length of encoding
        OUT LPBYTE pbDest)
    const;

    virtual LONG
    EncodeLength(       // Place encoding of Length, return length of encoding
        OUT LPBYTE pbDest)
    const;

    virtual LONG
    EncodeData(         // Place encoding of Data, return length of encoding
        OUT LPBYTE pbDest)
    const;

    virtual LONG
    DecodeData(         // Read data in encoding format.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc,
        IN DWORD dwLength);

    virtual void
    ChildAction(        // Child notification method.
        IN ChildActions action,
        IN CAsnObject *pasnChild);
};


//
//==============================================================================
//
//  String Types
//

class CAsnNumericString
:   public CAsnTextString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnNumericString(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_NumericString);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

class CAsnPrintableString
:   public CAsnTextString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnPrintableString(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_PrintableString);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

class CAsnTeletexString
:   public CAsnTextString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnTeletexString(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_TeletexString);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

class CAsnVideotexString
:   public CAsnTextString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnVideotexString(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_VideotexString);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

class CAsnVisibleString
:   public CAsnTextString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnVisibleString(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_VisibleString);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

class CAsnIA5String
:   public CAsnTextString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnIA5String(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_IA5String);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

class CAsnGraphicString
:   public CAsnTextString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnGraphicString(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_GraphicString);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

class CAsnGeneralString
:   public CAsnTextString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnGeneralString(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_GeneralString);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


class CAsnUnicodeString
:   public CAsnTextString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnUnicodeString(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_UnicodeString);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

//
//==============================================================================
//
//  CAsnGeneralizedTime
//

class CAsnGeneralizedTime
:   public CAsnVisibleString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnGeneralizedTime(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_GeneralizedTime);


    operator FILETIME(
        void);

    const FILETIME &
    operator =(
        const FILETIME &ftValue);

// protected:


    FILETIME m_ftTime;

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnUniversalTime
//

class CAsnUniversalTime
:   public CAsnVisibleString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnUniversalTime(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_UniversalTime);


    //
    // Win16 does not support file time operation
    //

    operator FILETIME(
        void);

    const FILETIME &
    operator =(
        const FILETIME &ftValue);

// protected:

    FILETIME m_ftTime;

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnObjectDescriptor
//

class CAsnObjectDescriptor
:   public CAsnGraphicString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnObjectDescriptor(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_ObjectDescriptor);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnExternal
//

class CAsnExternal_Encoding_singleASN1Type
:   public CAsnTag
{
    friend class CAsnExternal_Encoding;

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnExternal_Encoding_singleASN1Type(
        IN DWORD dwFlags,
        IN DWORD dwTag);

    //  Properties

    CAsnAny _entry1;

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

class CAsnExternal_Encoding
:   public CAsnChoice
{
    friend class CAsnExternal;

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnExternal_Encoding(
        IN DWORD dwFlags);

    //  Properties

    CAsnExternal_Encoding_singleASN1Type singleASN1Type;
    CAsnOctetstring octetAligned;
    CAsnBitstring arbitrary;

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

class CAsnExternal
:   public CAsnSequence
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnExternal(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_External);


    //  Properties

    CAsnObjectIdentifier directReference;
    CAsnInteger indirectReference;
    CAsnObjectDescriptor dataValueDescriptor;
    CAsnExternal_Encoding encoding;

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

#endif // _MSASNLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\include\asntext.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asntext

Abstract:

    This module provides the implementation for the ASN.1 Text Object base
    class.

Author:

    Doug Barlow (dbarlow) 10/8/1995

Environment:

    Win32

Notes:

    This code assumes that the width of an unsigned long integer is 32 bits.

--*/

#ifndef _ASNTEXT_H_
#define _ASNTEXT_H_

#include "asnPriv.h"


//
//==============================================================================
//
//  CAsnTextString
//

class CAsnTextString
:   public CAsnPrimitive
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnTextString(
        IN DWORD dwFlags,
        IN DWORD dwTag,
        IN DWORD dwType);


    //  Properties
    //  Methods

    virtual LONG
    Write(              // Set the value of the object.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen);


    //  Operators

    operator LPCSTR(
        void);

    CAsnTextString &
    operator =(
        LPCSTR szSrc);

// protected:

    typedef DWORD CharMap[256 / sizeof(DWORD)];


    //  Properties

    CharMap *m_pbmValidChars;


    //  Methods

    virtual BOOL
    CheckString(
        const BYTE FAR *pch,
        DWORD cbString,
        DWORD length)
    const;


public:

    virtual LONG
    DecodeData(         // Read data in encoding format.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc,
        IN DWORD dwLength);
};

#endif // _ASNTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\licecert\certcate.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    licecert.h

Abstract:

    Adapted from Doug Barlow's PKCS library

Author:

    Frederick Chong (dbarlow) 5/28/1998

Environment:

    

Notes:



--*/

#ifndef _CERTCATE_H_
#define _CERTCATE_H_

#include <msasnlib.h>
#include "names.h"
#include "x509.h"
#include "memcheck.h"


//
//==============================================================================
// Supported Certificate Types.
//

#define CERTYPE_UNKNOWN         0   // Unknown Certificate Type.
#define CERTYPE_LOCAL_CA        1   // A local CA pointer.
#define CERTYPE_X509            2   // An X.509 certificate.
#define CERTYPE_PKCS_X509       3   // A PKCS & imbedded X.509 Certificate.
#define CERTYPE_PKCS7_X509      4   // A PKCS7 & embedded X.509 Certificate
#define CERTYPE_PKCS_REQUEST    5   // A PKCS Certificate Request (internal use

//
//==============================================================================
// X.509 Certificate specifics
//

#define X509_VERSION_1 0            // This certificate is X.509 version 1
#define X509_VERSION_2 1            // This certificate is X.509 version 2
#define X509_VERSION_3 2            // This certificate is X.509 version 3
#define X509_MAX_VERSION X509_VERSION_3 // Max version supported.

#define X509CRL_VERSION_1 0         // This CRL is X.509 version 1
#define X509CRL_VERSION_2 1         // This CRL is X.509 version 2
#define X509CRL_MAX_VERSION X509CRL_VERSION_2 // Max version supported.

//
//==============================================================================
// Certificate Store Definitions
//

#define CERTSTORE_NONE          0   // No store to be used.
#define CERTSTORE_APPLICATION   1   // Store in application volatile memory
#define CERTSTORE_CURRENT_USER  3   // Store in Registry under current user
#define CERTSTORE_LOCAL_MACHINE 5   // Store in Registry under local machine

#define CERTTRUST_NOCHECKS      0   // Don't do any certificate checking
#define CERTTRUST_APPLICATION   1   // Trust the Application Store
#define CERTTRUST_NOONE         0xffff // Trust No One -- Validate everything

//
//==============================================================================
// Certificate Warning Definitions
//

#define CERTWARN_NOCRL       0x01   // At least one of the signing CAs didn't
                                    // have an associated CRL.
#define CERTWARN_EARLYCRL    0x02   // At least one of the signing CAs had an
                                    // associated CRL who's issuing date was
                                    // in the future.
#define CERTWARN_LATECRL     0x04   // At least one of the signing CAs had an
                                    // expired CRL.
#define CERTWARN_TOBEREVOKED 0x08   // At least one of the signing CAs contained
                                    // a revocation for a certificate, but its
                                    // effective date has not yet been reached.
#define CERTWARN_CRITICALEXT 0x10   // At least one of the signing CAs contained
                                    // an unrecognized critical extension.

//
//==============================================================================
// The supported signature and hashing algorithm
//

typedef DWORD ALGORITHM_ID;

#define SIGN_ALG_RSA            0x00010000

#define HASH_ALG_MD2            0x00000001
#define HASH_ALG_MD4            0x00000002
#define HASH_ALG_MD5            0x00000003
#define HASH_ALG_SHA            0x00000004
#define HASH_ALG_SHA1           0x00000005

#define GET_SIGN_ALG( _Alg )    _Alg & 0xFFFF0000
#define GET_HASH_ALG( _Alg )    _Alg & 0x0000FFFF


class CCertificate;

typedef const void FAR * CERTIFICATEHANDLE;
typedef CERTIFICATEHANDLE * PCERTIFICATEHANDLE, FAR * LPCERTIFICATEHANDLE;
            


BOOL WINAPI
PkcsCertificateLoadAndVerify(
    OUT LPCERTIFICATEHANDLE phCert,    
    IN const BYTE FAR * pbCert,
    IN DWORD cbCert,
    IN OUT LPDWORD pdwType,
    IN DWORD dwStore,
    IN DWORD dwTrust,
    OUT LPTSTR szIssuerName,
    IN OUT LPDWORD pcbIssuerLen,
    OUT LPDWORD pdwWarnings,
    IN OUT LPDWORD pfDates );


BOOL WINAPI
PkcsCertificateGetPublicKey(
    CERTIFICATEHANDLE   hCert,
    LPBYTE              lpPubKey,
    LPDWORD             lpcbPubKey );


BOOL WINAPI
PkcsCertificateCloseHandle(
    CERTIFICATEHANDLE   hCert );

//
//==============================================================================
//
//  CCertificate
//

class CCertificate
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CCertificate();
    virtual ~CCertificate();


    //  Properties
    //  Methods

    virtual void
    Load(
        //IN CProvider *pksProvider,
        IN const BYTE FAR * pbCertificate,
        IN DWORD cbCertificate,
        IN DWORD dwTrust,
        IN OUT LPDWORD pfStore,
        OUT LPDWORD pdwWarnings,
        OUT COctetString &osIssuer,
        //IN BOOL fOwnProvider,
        IN OUT LPDWORD pfDates,
        IN BOOL fRunOnce = FALSE );

    virtual void
    Verify(
        IN const BYTE FAR * pbSigned,
        IN DWORD cbSigned,
        IN DWORD cbSignedLen,
        IN ALGORITHM_ID algIdSignature,
        IN LPCTSTR szDescription,
        IN const BYTE FAR * pbSignature,
        IN DWORD cbSigLen)
        const;

    virtual void
    GetPublicKey(
        IN LPBYTE pbPubKey,
        IN OUT LPDWORD lpcbPubKey ) 
        const;

    virtual const Name &
    Subject(void) const;

    virtual BOOL
    HasParent(void) const;

    virtual const Name &
    Issuer(void) const;

    virtual void
    SerialNo(
        OUT COctetString &osSerialNo)
    const;

    virtual DWORD
    Type(void) const;


    //  Operators

protected:
    //  Properties

    COctetString m_osPublicKey;

    //  Methods

    virtual void
    Init(void);

    virtual void
    Clear(void);

};


//
//==============================================================================
//
//  CX509Certificate
//

class CX509Certificate
:   public CCertificate
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CX509Certificate();
    virtual ~CX509Certificate();


    //  Properties
    //  Methods

    virtual void
    Load(
        IN const BYTE FAR * pbCertificate,
        IN DWORD cbCertificate,
        IN DWORD dwTrust,
        IN OUT LPDWORD pfStore,
        OUT LPDWORD pdwWarnings,
        OUT COctetString &osIssuer,
        IN OUT LPDWORD pfDates,
        IN BOOL fRunOnce = FALSE );

    
    virtual const Name &
    Subject(void) const;

    virtual BOOL
    HasParent(void) const
    { return TRUE; };

    virtual const Name &
    Issuer(void) const;

    virtual void
    SerialNo(
        OUT COctetString &osSerialNo)
    const;

    virtual DWORD
    Type(void) const;

    virtual const CertificateToBeSigned &
    Coding(void) const;


    //  Operators

protected:
    //  Properties

    CertificateToBeSigned
        m_asnCert;

    //  Methods

    virtual void
    Init(void);

    virtual void
    Clear(void);

    virtual void
    Load2(  // Backdoor for derivative extensions.
        IN const BYTE FAR * pbCertificate,
        IN DWORD cbCertificate,
        IN DWORD dwTrust,
        IN OUT LPDWORD pfStore,
        OUT LPDWORD pdwWarnings,
        OUT COctetString &osIssuer,
        IN BOOL fRunOnce,
        OUT CCertificate **ppcrtIssuer,
        IN OUT LPDWORD pfDates );
        
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\licecert\crtstore.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    CrtStore

Abstract:

    This header file describes the Certificate Store service.

Author:

    Doug Barlow (dbarlow) 8/14/1995

Environment:

    Win32, Crypto API

Notes:



--*/

#ifndef _CRTSTORE_H_
#define _CRTSTORE_H_

#include <msasnlib.h>
#include "names.h"
#include "ostring.h"


extern void
AddCertificate(
    IN const CDistinguishedName &dnName,
    IN const BYTE FAR *pbCertificate,
    IN DWORD cbCertificate,
    IN DWORD dwType,
    IN DWORD fStore);

extern void
DeleteCertificate(
    IN const CDistinguishedName &dnName);

extern void
AddReference(
    IN const CDistinguishedName &dnSubject,
    IN const CDistinguishedName &dnIssuer,
    IN const BYTE FAR *pbSerialNo,
    IN DWORD cbSNLen,
    IN DWORD fStore);

extern BOOL
FindCertificate(
    IN const CDistinguishedName &dnName,
    IN OUT LPDWORD pfStore,
    OUT COctetString &osCertificate,
    OUT COctetString &osCRL,
    OUT LPDWORD pdwType);

#endif // _CRTSTORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\licecert\crtstore.cpp ===
/*++

Copyright (c) 1995 - 1998  Microsoft Corporation

Module Name:

    CrtStore

Abstract:

    This file provides the certificate store functionality.  This version uses
    the registry for certificate store maintenance.  We actually maintain 3
    stores:

    *   The application store.  This is the default.  Certificates in the
        application store are maintained locally an forgotten once the
        application exits.

    *   The user store.  Certificates in this store are persistent,
        and are maintained in the registry under HKEY_CURRENT_USER.  They are
        available to any application executed in the context of the current
        user.

    *   The system store.  Certificates in this store are persistent, and are
        maintained in the registry under HKEY_LOCAL_MACHINE.  They are available
        to all users on this system.

Author:

    Doug Barlow (dbarlow) 8/14/1995
    Frederick Chong (fredch) 6/5/1998 - Delete all code that uses user and system store

Environment:

    Win32, Crypto API

Notes:



--*/

#include <windows.h>
#include <stdlib.h>
#include <msasnlib.h>
#include "ostring.h"
#include "pkcs_err.h"
#include "utility.h"
#include <memcheck.h>

class CAppCert
{
public:
    DECLARE_NEW

    COctetString
        m_name,
        m_cert,
        m_crl;
    DWORD
        m_dwType;
};
IMPLEMENT_NEW(CAppCert)

class CAppCertRef
{
public:
    DECLARE_NEW

    COctetString
        m_osIssuerSn,
        m_osSubject;
};
IMPLEMENT_NEW(CAppCertRef)

#if 0
class CAppSName
{
public:
    DECLARE_NEW
    COctetString
        m_osSimpleName,
        m_osDistinguishedName,
        m_osKeySet,
        m_osProvider;
    DWORD
        m_dwKeyType,
        m_dwProvType;
};
IMPLEMENT_NEW(CAppSName)
#endif

#define CERT_ID 8
#define CERTREF_ID 9


static CHandleTable<CAppCert>
    rgAppCerts(CERT_ID);

static CHandleTable<CAppCertRef>
    rgAppCertRefs(CERTREF_ID);

static COctetString
    osAppDNamePrefix;

static void
AddSerial(
    IN const BYTE FAR *pbSerialNo,
    IN DWORD cbSNLen,
    IN OUT COctetString &osOut);


/*++

AddCertificate:

    This routine adds a given certificate to the Certificate Store.  No
    validation is done on the certificate.

Arguments:

    szCertName - Supplies the name of the certificate.
    pbCertificate - Supplies the certificate to save.
    pbCRL - Supplies the CRL for this certificate.
    dwType - Supplies the type of certificate.
    fStore - Supplies the identifier for the store to be used.

Return Value:

    None.  A DWORD status code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 8/14/1995

--*/

void
AddCertificate(
    IN const CDistinguishedName &dnName,
    IN const BYTE FAR *pbCertificate,
    IN DWORD cbCertificate,
    IN DWORD dwType,
    IN DWORD fStore)
{
    DWORD
        length,
        count,
        idx;
    DWORD
        dwCertLength = 0,
        dwCrlLength = 0;
    CAppCert *
        appCert;
    COctetString
        osSubject;

    ErrorCheck;
    dnName.Export(osSubject);
    ErrorCheck;

    length = ASNlength(pbCertificate, cbCertificate, &idx);
    dwCertLength = length + idx;

    switch (fStore)
    {
    case CERTSTORE_NONE:
        return;     // Not to be stored at all.
        break;

    case CERTSTORE_APPLICATION:
        appCert = NULL;
        count = rgAppCerts.Count();
        for (idx = 0; idx < count; idx += 1)
        {
            appCert = rgAppCerts.Lookup(
                        MAKEHANDLE(CERT_ID, idx), FALSE);
            if (NULL != appCert)
            {
                if (appCert->m_name == osSubject)
                    break;
                appCert = NULL;
            }
        }
        if (NULL == appCert)
            appCert = rgAppCerts.Lookup(rgAppCerts.Create());
        ErrorCheck;

        if (NULL == appCert)
        {
            ErrorThrow(PKCS_INVALID_HANDLE);
        }

        appCert->m_name = osSubject;
        ErrorCheck;

        if (cbCertificate < dwCertLength)
        {
            ErrorThrow(PKCS_BAD_PARAMETER);
        }

        appCert->m_cert.Set(pbCertificate, dwCertLength);
        ErrorCheck;
        appCert->m_dwType = dwType;
        return;
        break;

    default:
        ErrorThrow(PKCS_BAD_PARAMETER);
    }

    return;


ErrorExit:

    return;
}


/*++

AddReference:

    This routine adds a reference to a certificate to the certificate store.  No
    validation is performed.

Arguments:

    dnSubject - Supplies the name of the subject of the certificate.
    dnIssuer - Supplies the name of the Issuer of the certificate.
    pbSerialNo - Supplies the serial number.
    cbSNLen - Supplies the length of the serial number, in bytes.
    fStore - Supplies the identifier for the store to be used.

Return Value:

    None.  A DWORD status code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 2/15/1996

--*/

void
AddReference(
    IN const CDistinguishedName &dnSubject,
    IN const CDistinguishedName &dnIssuer,
    IN const BYTE FAR *pbSerialNo,
    IN DWORD cbSNLen,
    IN DWORD fStore)
{
    COctetString
        osSubject,
        osIssuer,
        osSNum;
    CAppCertRef *
        appCertRef;
    DWORD
        count,
        idx;

    ErrorCheck;
    dnIssuer.Export(osIssuer);
    ErrorCheck;
    AddSerial(pbSerialNo, cbSNLen, osSNum);
    ErrorCheck;

    dnSubject.Export(osSubject);
    ErrorCheck;

    switch (fStore)
    {
    case CERTSTORE_NONE:
        return;     // Not to be stored at all.
        break;

    case CERTSTORE_APPLICATION:
        osIssuer.Resize(osIssuer.Length() - 1);
        ErrorCheck;
        osIssuer.Append(osSNum);
        ErrorCheck;
        appCertRef = NULL;
        count = rgAppCertRefs.Count();
        for (idx = 0; idx < count; idx += 1)
        {
            appCertRef = rgAppCertRefs.Lookup(
                        MAKEHANDLE(CERTREF_ID, idx), FALSE);
            if (NULL != appCertRef)
            {
                if (appCertRef->m_osIssuerSn == osIssuer)
                    break;
                appCertRef = NULL;
            }
        }
        if (NULL == appCertRef)
            appCertRef = rgAppCertRefs.Lookup(rgAppCertRefs.Create());
        ErrorCheck;

        if (NULL == appCertRef)
        {
            ErrorThrow(PKCS_INVALID_HANDLE);
        }

        appCertRef->m_osIssuerSn = osIssuer;
        appCertRef->m_osSubject = osSubject;
        ErrorCheck;
        return;
        break;
    default:
        ErrorThrow(PKCS_BAD_PARAMETER);
    }

ErrorExit:

    return;
}



/*++

FindCertificate:

    This routine searches the various certificate stores, looking for a match.
    It does not validate what it finds.

Arguments:

    dnName - Supplies the name to search for.
    pfStore - Supplies the minimum store to search in, and receives the store it
        was found in.
    osCertificate - Receives the requested certificate.
    osCRL - Receives the CRL for the requested certificate, if any.
    pdwType - Receives the type of the certificate.

Return Value:

    TRUE - Such a certificate was found.
    FALSE - No such certificate was found.
    A DWORD status code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 8/14/1995

--*/

BOOL
FindCertificate(
    IN const CDistinguishedName &dnName,
    OUT LPDWORD pfStore,
    OUT COctetString &osCertificate,
    OUT COctetString &osCRL,
    OUT LPDWORD pdwType)
{
    COctetString
        osName;
    DWORD
        index,
        idx,
        count;
    CAppCert *
        appCert;


    //
    // Build the key name.
    //

    ErrorCheck;
    osCertificate.Empty();
    osCRL.Empty();
    dnName.Export(osName);
    ErrorCheck;

    //
    // Search for the key name in the various stores.
    //

    for (index = *pfStore;
         index <= CERTSTORE_LOCAL_MACHINE;
         index += 1)
    {
        switch (index)
        {
        case CERTSTORE_APPLICATION:
            count = rgAppCerts.Count();
            for (idx = 0; idx < count; idx += 1)
            {
                appCert = rgAppCerts.Lookup(
                            MAKEHANDLE(CERT_ID, idx), FALSE);
                ErrorCheck;
                if (NULL != appCert)
                {
                    if (appCert->m_name == osName)
                    {
                        osCertificate = appCert->m_cert;
                        ErrorCheck;
                        osCRL = appCert->m_crl;
                        ErrorCheck;
                        *pdwType = appCert->m_dwType;
                        *pfStore = CERTSTORE_APPLICATION;
                        return TRUE;
                    }
                }
            }
            continue;
            break;

        default:
            continue;   // Skip unknown values
        }


        //
        // If found, extract the fields.
        //
    }

    return FALSE;

ErrorExit:
    osCertificate.Empty();
    osCRL.Empty();

    return FALSE;
}


/*++

AddSerial:

    This routine appends a serial number in text format to the end of a suppled
    octet string.

Arguments:

    pbSerialNo supplies the address of the binary serial number.

    cbSNLen supplies the length of the serial number, in bytes.

    osOut receives the extension.

Return Value:

    None.  A status DWORD is thrown on errors.

Author:

    Doug Barlow (dbarlow) 2/15/1996

--*/

static void
AddSerial(
    IN const BYTE FAR *pbSerialNo,
    IN DWORD cbSNLen,
    IN OUT COctetString &osOut)
{
    static TCHAR szPrefix[] = TEXT("\\SN#");
    static TCHAR digits[] = TEXT("0123456789abcdef");
    TCHAR buf[2];
    DWORD index;

    index = osOut.Length();
    index += cbSNLen * 2 + sizeof(szPrefix);
    osOut.Length(index);
    ErrorCheck;

    osOut.Append((LPBYTE)szPrefix, sizeof(szPrefix) - sizeof(TCHAR));
    ErrorCheck;

    for (index = 0; index < cbSNLen; index += 1)
    {
        buf[0] = digits[pbSerialNo[index] >> 4];
        buf[1] = digits[pbSerialNo[index] & 0x0f];
        osOut.Append((LPBYTE)buf, sizeof(buf));
        ErrorCheck;
    }
    buf[0] = 0;
    osOut.Append((LPBYTE)buf, sizeof(TCHAR));
ErrorExit:
    return;
}


/*++

DeleteCertificate:

    This routine removes all occurences of the named certificate from the
    system.

Arguments:

    dnName - Supplies the name of the subject of the certificate to delete.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 8/23/1995
    Frederick Chong (fredch) 6/5/98 - Get rid of stores other than application

--*/

void
DeleteCertificate(
    IN const CDistinguishedName &dnName)
{
    COctetString
        osName;
    CAppCert *
        appCert;
    DWORD
        count,
        idx;

    //
    // Build the key name.
    //

    dnName.Export(osName);
    ErrorCheck;

    count = rgAppCerts.Count();
    for (idx = 0; idx < count; idx += 1)
    {
        appCert = rgAppCerts.Lookup( MAKEHANDLE(CERT_ID, idx), FALSE);
        ErrorCheck;
        if (NULL != appCert)
        {
            if (appCert->m_name == osName)
                rgAppCerts.Delete(MAKEHANDLE(CERT_ID, idx));
            ErrorCheck;
        }
    }

    return;

ErrorExit:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\licecert\licecert.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    licecert.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Frederick Chong - June. 23rd 1998

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES = \
    $(C_DEFINES) \
    $(CLIENT_EXE_CDEFS)

#
# List of sources
#

SOURCES_PLATFORM =

CLIENT_SOURCES_RC = \

CLIENT_SOURCES_COMMON = \
    certcate.cpp \
    ostring.cpp \
    pkcs_err.cpp \
    utility.cpp \
    x509.cpp \
    pkcs_1.cpp \
    crtstore.cpp \
    licecert.cpp \

CLIENT_SOURCES_LAST  = \
    names.cpp

SOURCES = \
    $(CLIENT_SOURCES_RC) \
    $(SOURCES_PLATFORM) \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_LAST)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\licecert\names.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    names

Abstract:

    This class supports a common internal name format.  It exists so that names
    can be easily accessed and converted from one format to another.

    This Class provides translations among the various supported name formats:

        X.500 ASN.1 BER
        Character Delimited
        ?Moniker?

    A Character Delimited name is of the form, '<RDName>;...;<RDName>', where
    each <RDName> is of the form, '[<type>=]<string>[,<type>=string,...]'.
    <type> is any of 'CTN', 'LOC', 'ORG', or 'OUN', from F.500, or an Object
    Identifier in the form, 'n1.n2.n3...' (n1 - n3 representing integers).
    <string> is any string of characters, excluding ';', and '\\'.

Author:

    Doug Barlow (dbarlow) 7/12/1995

Environment:

    Win32

Notes:



--*/

//#ifndef _WIN32_WINNT
//#define _WIN32_WINNT 0x0400
//#endif
#include <windows.h>
//#include <wincrypt.h>
#include <string.h>

#include "names.h"
#include "pkcs_err.h"

#ifdef OS_WINCE
#include "wince.h"
#endif // OS_WINCE

static const struct atributeTable {
    LPCTSTR name;
    LPCTSTR objectId;
    unsigned int tag;
    unsigned int minLength;
    unsigned int maxLength;
} knownAttributes[]
    = { //  Name            Object Id           Tag Min Max
        {   TEXT("COM"),    TEXT("2.5.4.3"),    19, 1,  64    },    // commonName
        {   TEXT("SUR"),    TEXT("2.5.4.4"),    19, 1,  64    },    // surname
        {   TEXT("SN"),     TEXT("2.5.4.5"),    19, 1,  64    },    // serialNumber
        {   TEXT("CTN"),    TEXT("2.5.4.6"),    19, 2,  2     },    // countryName
        {   TEXT("LOC"),    TEXT("2.5.4.7"),    19, 1,  128   },    // localityName
        {   TEXT("STN"),    TEXT("2.5.4.8"),    19, 1,  128   },    // stateOrProvinceName
        {   TEXT("SADD"),   TEXT("2.5.4.9"),    19, 1,  128   },    // streetAddress
        {   TEXT("ORG"),    TEXT("2.5.4.10"),   19, 1,  64    },    // organizationName
        {   TEXT("OUN"),    TEXT("2.5.4.11"),   19, 1,  64    },    // organizationalUnitName
        {   TEXT("TIT"),    TEXT("2.5.4.12"),   19, 1,  64    },    // title
        {   TEXT("DES"),    TEXT("2.5.4.13"),   19, 1,  1024  },    // description
        {   TEXT("BCTG"),   TEXT("2.5.4.15"),   19, 1,  128   },    // businessCategory
        {   TEXT("PCOD"),   TEXT("2.5.4.17"),   19, 1,  40    },    // postalCode
        {   TEXT("POB"),    TEXT("2.5.4.18"),   19, 1,  40    },    // postOfficeBox
        {   TEXT("PDO"),    TEXT("2.5.4.19"),   19, 1,  128   },    // physicalDeliveryOfficeName
        {   TEXT("TEL"),    TEXT("2.5.4.20"),   19, 1,  32    },    // telephoneNumber
        {   TEXT("X.121"),  TEXT("2.5.4.24"),   18, 1,  15    },    // x121Address
        {   TEXT("ISDN"),   TEXT("2.5.4.25"),   18, 1,  16    },    // internationalISDNNumber
        {   TEXT("DI"),     TEXT("2.5.4.27"),   19, 1,  128   },    // destinationIndicator
        {   TEXT("???"),    TEXT("0.0"),        19, 1,  65535 } };  // <trailer>

//      {   TEXT("KI"),     TEXT("2.5.4.2"),    19, 1,  65535 },    // knowledgeInformation (obsolete)
//      {   TEXT("SG"),     TEXT("2.5.4.14"),   0,  0,  0     },    // searchGuide
//      {   TEXT("PADD"),   TEXT("2.5.4.16"),   0,  0,  0     },    // postalAddress
//      {   TEXT("TLX"),    TEXT("2.5.4.21"),   0,  0,  0     },    // telexNumber
//      {   TEXT("TTX"),    TEXT("2.5.4.22")    0,  0,  0     },    // teletexTerminalIdentifier
//      {   TEXT("FAX"),    TEXT("2.5.4.23"),   0,  0,  0     },    // facimilieTelephoneNumber
//      {   TEXT("RADD"),   TEXT("2.5.4.26"),   0,  0,  0     },    // registeredAddress
//      {   TEXT("DLM"),    TEXT("2.5.4.28"),   0,  0,  0     },    // preferredDeliveryMethod
//      {   TEXT("PRADD"),  TEXT("2.5.4.29"),   0,  0,  0     },    // presentationAddress
//      {   TEXT("SAC"),    TEXT("2.5.4.30"),   0,  0,  0     },    // supportedApplicationContext
//      {   TEXT("MEM"),    TEXT("2.5.4.31"),   0,  0,  0     },    // member
//      {   TEXT("OWN"),    TEXT("2.5.4.32"),   0,  0,  0     },    // owner
//      {   TEXT("RO"),     TEXT("2.5.4.33"),   0,  0,  0     },    // roleOccupant
//      {   TEXT("SEE"),    TEXT("2.5.4.34"),   0,  0,  0     },    // seeAlso
//      {   TEXT("CLASS"),  TEXT("?.?"),        0,  0,  0     },    // Object Class
//      {   TEXT("A/B"),    TEXT("?.?"),        0,  0,  0     },    // Telex answerback (not yet in X.520)
//      {   TEXT("UC"),     TEXT("?.?"),        0,  0,  0     },    // User Certificate
//      {   TEXT("UP"),     TEXT("?.?"),        0,  0,  0     },    // User Password
//      {   TEXT("VTX"),    TEXT("?.?"),        0,  0,  0     },    // Videotex user number (not yet in X.520)
//      {   TEXT("O/R"),    TEXT("?.?"),        0,  0,  0     },    // O/R address (MHS) (X.400)

//      {   TEXT("ATR50"),  TEXT("2.5.4.50"),   19, 1,  64    },    // dnQualifier
//      {   TEXT("ATR51"),  TEXT("2.5.4.51"),   0,  0,  0     },    // enhancedSearchGuide
//      {   TEXT("ATR52"),  TEXT("2.5.4.52"),   0,  0,  0     },    // protocolInformation
//      {   TEXT("ATR7.1"), TEXT("2.5.4.7.1"),  19, 1,  128   },    // collectiveLocalityName
//      {   TEXT("ATR8.1"), TEXT("2.5.4.8.1"),  19, 1,  128   },    // collectoveStateOrProvinceName
//      {   TEXT("ATR9.1"), TEXT("2.5.4.9.1"),  19, 1,  128   },    // collectiveStreetAddress
//      {   TEXT("AT10.1"), TEXT("2.5.4.10.1"), 19, 1,  64    },    // collectiveOrganizationName
//      {   TEXT("AT11.1"), TEXT("2.5.4.11.1"), 19, 1,  64    },    // collectiveOrganizationalUnitName
//      {   TEXT("AT17.1"), TEXT("2.5.4.17.1"), 19, 1,  40    },    // collectivePostalCode
//      {   TEXT("AT18.1"), TEXT("2.5.4.18.1"), 19, 1,  40    },    // collectivePostOfficeBox
//      {   TEXT("AT19.1"), TEXT("2.5.4.19.1"), 19, 1,  128   },    // collectivePhysicalDeliveryOfficeName
//      {   TEXT("AT20.1"), TEXT("2.5.4.20.1"), 19, 1,  32    },    // collectiveTelephoneNumber
//      {   TEXT("AT21.1"), TEXT("2.5.4.21.1"), 0,  0,  0     },    // collectiveTelexNumber
//      {   TEXT("AT22.1"), TEXT("2.5.4.22.1")  0,  0,  0     },    // collectiveTeletexTerminalIdentifier
//      {   TEXT("AT23.1"), TEXT("2.5.4.23.1"), 0,  0,  0     },    // collectiveFacimilieTelephoneNumber
//      {   TEXT("AT25.1"), TEXT("2.5.4.25.1"), 18, 1,  16    },    // collectiveInternationalISDNNumber


static const DWORD
    KNOWNATTRIBUTESCOUNT
        = (sizeof(knownAttributes) / sizeof(struct atributeTable)) - 1;

#define ATR_COMMONNAME              0
#define ATR_UNKNOWN                 KNOWNATTRIBUTESCOUNT


//
//==============================================================================
//
//  CAttribute
//

IMPLEMENT_NEW(CAttribute)


/*++

TypeCompare:

    This method compares the type of a given attribute to this attribute's type.
    It provides a simplistic ordering of types, so that Attribute Lists can sort
    their attributes for comparison and conversion consistencies.

Arguments:

    atr - Supplies the attribute whose type is to be compared.

Return Value:

    <0 - The given attribute type comes before this attribute's type in an
         arbitrary but consistent ordering scheme.
    =0 - The given attribute type is the same as this attribute's type.
    >0 - The given attribute type comes after this attribute's type in an
         arbitrary but consistent ordering scheme.

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

int
CAttribute::TypeCompare(
    IN const CAttribute &atr)
    const
{
    if (m_nType == atr.m_nType)
    {
        if (KNOWNATTRIBUTESCOUNT == m_nType)
            return strcmp( ( LPCSTR )( ( LPCTSTR )m_osObjId ), ( LPCSTR )( ( LPCTSTR )atr.m_osObjId ) );
        else
            return 0;
    }
    else
        return (int)(m_nType - atr.m_nType);
}


/*++

Compare:

    This method compares a supplied attribute to this attribute.  They are equal
    if both the attribute type and value match.

Arguments:

    atr - This supplies the attribute to be compared to this one.

Return Value:

    -1 - The type or value is less than this attribute.
     0 - The attributes are identical.
     1 - The type or value is greater than this attribute.

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

int
CAttribute::Compare(
    IN const CAttribute &atr)
    const
{
    int dif;

    dif = TypeCompare(atr);
    if (0 == dif)
        dif = GetValue().Compare(atr.GetValue());
    return dif;
}


/*++

Set:

    These methods are used to set the type and value of an attribute.

    ?TODO?  Validate the string contents.

Arguments:

    szType - Supplies the type of the attribute.  NULL implies commonName.
    szValue - Supplies the value of the attribute as a string.  The value is
        converted to ASN.1 PrintableString format.
    pbValue - Supplies the value of the attribute, already encoded in ASN.1
    cbValLen - Supplies the length of the pbValue buffer.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

void
CAttribute::Set(
    IN LPCTSTR szType,
    IN const BYTE FAR *pbValue,
    IN DWORD cbValLen)
{
    DWORD index;
    if (NULL == szType ? TRUE : 0 == *szType)
    {
        index = ATR_COMMONNAME;
        szType = knownAttributes[index].objectId;
    }
    else
    {
        for (index = 0; index < KNOWNATTRIBUTESCOUNT; index += 1)
        {
            if (0 == strcmp( ( char * )szType, ( char * )knownAttributes[index].objectId))
                break;
            if (0 == _stricmp( ( char * )szType, ( char * )knownAttributes[index].name))
            {
                szType = knownAttributes[index].objectId;
                break;
            }
        }
    }
    m_nType = index;
    m_osObjId = szType;
    m_osValue.Set(pbValue, cbValLen);
}

void
CAttribute::Set(
    IN LPCTSTR szType,
    IN LPCTSTR szValue)
{
    CAsnPrintableString asnString;   // ?todo? Support other string types.
    DWORD cbValLen = strlen( ( char * )szValue);
    DWORD index;
    LONG lth;

    if (NULL == szType ? TRUE : 0 == *szType)
    {
        index = ATR_COMMONNAME;
        szType = knownAttributes[index].objectId;
    }
    else
    {
        for (index = 0; index < KNOWNATTRIBUTESCOUNT; index += 1)
        {
            if (0 == strcmp( ( char * )szType, ( char * )knownAttributes[index].objectId))
                break;
            if (0 == _stricmp( ( char * )szType, ( LPCSTR )knownAttributes[index].name))
            {
                szType = knownAttributes[index].objectId;
                break;
            }
        }
    }

    if (index < KNOWNATTRIBUTESCOUNT)
    {
        if ((knownAttributes[index].minLength > cbValLen)
            || knownAttributes[index].maxLength < cbValLen)
            ErrorThrow(PKCS_BAD_LENGTH);
    }
    m_nType = index;
    m_osObjId = szType;
    lth = asnString.Write((LPBYTE)szValue, cbValLen);
    if (0 > lth)
        ErrorThrow(PKCS_ASN_ERROR);
    lth = asnString.EncodingLength();
    if (0 > lth)
        ErrorThrow(PKCS_ASN_ERROR);
    m_osValue.Resize(lth);
    ErrorCheck;

    lth = asnString.Encode(m_osValue.Access());
    if (0 > lth)
        ErrorThrow(PKCS_ASN_ERROR);
    return;

ErrorExit:
    return;
}


//
//==============================================================================
//
//  CAttributeList
//

IMPLEMENT_NEW(CAttributeList)


/*++

Clear:

    This routine flushes the storage used for an RDN.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

void
CAttributeList::Clear(
    void)
{
    DWORD count = Count();
    for (DWORD index = 0; index < count; index += 1)
    {
        CAttribute *patr = m_atrList[index];
        if (NULL != patr)
            delete patr;
    }
    m_atrList.Clear();
}


/*++

CAttributeList::Add:

    Add an attribute to the RDN.  Attributes must be unique, so if an existing
    attribute has the same type as the attribute being added, then the existing
    attribute is first deleted.  The entries are maintained in sorted order.

Arguments:

    atr - Supplies the attribute to add.  This attribute must have been created
        via a 'new' directive, and becomes the property of this object, to be
        deleted once this object goes away.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

void
CAttributeList::Add(
    IN CAttribute &atr)
{
    int datr=0;
    DWORD index;
    DWORD count = Count();


    //
    // Look for the slot in which the attribute should go.
    //

    for (index = 0; index < count; index += 1)
    {
        datr = m_atrList[index]->TypeCompare(atr);
        ErrorCheck;
        if (0 <= datr)
            break;
    }

    if (index != count)
    {

        //
        // Some array shuffling is necessary.
        //

        if (0 == datr)
        {

            //
            // Replace this attribute in the array with the new one.
            //

            delete m_atrList[index];
        }
        else
        {

            //
            // Insert the new attribute here in the array.
            //

            for (DWORD idx = count; idx > index; idx -= 1)
            {
                m_atrList.Set(idx, m_atrList[idx - 1]);
                ErrorCheck;
            }
        }
    }


    //
    // We're ready -- add in the new attribute.
    //

    m_atrList.Set(index, &atr);
    ErrorCheck;
    return;

ErrorExit:
    return;
}


/*++

CAttributeList::Compare:

    This routine compares one RDName to another.  The RDNames are considered
    equal if they both contain the same attributes.

Arguments:

    rdn - Supplies the user-supplied RDN to be compared to this RDN.

Return Value:

    -1 - The supplied RDName is a proper subset of this RDName.
     0 - The two RDNames are identical
     1 - The supplied RDName contains an element not found in this RDName.

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

int
CAttributeList::Compare(
    IN const CAttributeList &rdn)
    const
{
    DWORD
        cRdn = rdn.Count(),
        cThs = Count(),
        iRdn = 0,
        iThs = 0;
    DWORD
        dif,
        result = 0;     // Assume they're the same for now.

    for (;;)
    {

        //
        // Have we reached the end of either set?
        //

        if (iRdn >= cRdn)
        {

            //
            // If we've reached the end of the rdn list, then unless we've also
            // reached the end of this list, the rdn list is a subset of this
            // list.
            //

            if (iThs < cThs)
                result = -1;
            break;
        }
        if (iThs >= cThs)
        {

            //
            // If we've reached the end of this list, then the rdn list has more
            // elements.
            //

            result = 1;
            break;
        }


        //
        // There are still more elements to compare.  Make the comparison of the
        // two current elements.
        //

        dif = rdn[(int)iRdn]->Compare(*m_atrList[(int)iThs]);
        ErrorCheck;
        if (0 == dif)
        {

            //
            // If they're the same, continue with the next pair of elements.
            //

            iRdn += 1;
            iThs += 1;
        }
        else if (0 < dif)
        {
            //
            // If the rdn list element is less than this's element, then it's
            // got an element we don't have.  Declare it not a subset.
            //

            result = 1;
            break;
        }
        else    // 0 > dif
        {

            //
            // If the rdn list element is greater than this's element, then this
            // list has an element the rdn list doesn't have.  Note that we've
            // detected that it's a non-proper subset, and continue checking.
            //

            result = -1;
            iThs += 1;
        }
    }
    return (int)result;

ErrorExit:
    return 1;
}


/*++

operator=:

    This routine sets this Attribute list to the contents of the supplied
    attribute list.

Arguments:

    atl - Supplies the source attribute list.

Return Value:

    This.  A DWORD status code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 8/21/1995

--*/

CAttributeList &
CAttributeList::operator=(
    IN const CAttributeList &atl)
{
    CAttribute *patr = NULL;
    DWORD count = atl.Count();
    Clear();
    for (DWORD index = 0; index < count; index += 1)
    {
        patr = new CAttribute;
        if (NULL == patr)
            ErrorThrow(PKCS_NO_MEMORY);
        *patr = *atl[(int)index];
        m_atrList.Set(index, patr);
        ErrorCheck;
        patr = NULL;
    }
    return *this;

ErrorExit:
    if (NULL != patr)
        delete patr;
    return *this;
}


/*++

CAttributeList::Import:

    These routines import attribute lists from other formats into our internal
    format.  The Import routines remove any existing attributes before bringing
    in the new ones.

Arguments:

    asnAtrLst - Supplies an ASN.1 X.509 Attributes structure to be imported
        into our internal format.

Return Value:

    None
    A DWORD containing an error code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 7/20/1995

--*/

void
CAttributeList::Import(
    const Attributes &asnAtrLst)
{
    CAttribute *
        addMe
            = NULL;
    long int
        length;
    COctetString
        osValue,
        osType;
    LPCTSTR
        sz;
    int
        atrMax
            = (int)asnAtrLst.Count();


    Clear();
    for (int index = 0; index < atrMax; index += 1)
    {
        length = asnAtrLst[index].attributeValue.EncodingLength();
        if (0 > length)
            ErrorThrow(PKCS_ASN_ERROR);
        osValue.Resize(length);
        ErrorCheck;
        length =
            asnAtrLst[index].attributeValue.Encode(
                osValue.Access());
        if (0 > length)
            ErrorThrow(PKCS_ASN_ERROR);

        sz = asnAtrLst[index].attributeType;
        if (NULL == sz)
            ErrorThrow(PKCS_ASN_ERROR);
        osType.Set((LPBYTE)sz, strlen( ( char * ) sz) + 1);
        ErrorCheck;
        addMe = new CAttribute;
        if (NULL == addMe)
            ErrorThrow(PKCS_NO_MEMORY);
        addMe->Set(osType, osValue.Access(), osValue.Length());
        ErrorCheck;
        Add(*addMe);
        addMe = NULL;
    }
    return;

ErrorExit:
    if (NULL != addMe)
        delete addMe;
    Clear();
}


/*++

Export:

    These methods export an internal format attribute list into other external
    formats.

Arguments:

    asnAtrList - Receives the attribute list.

Return Value:

    None.  A DWORD containing an error code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 7/25/1995

--*/

void
CAttributeList::Export(
    IN Attributes &asnAtrList)
    const
{
    DWORD
        index;
    CAttribute *
        patr;
    long int
        length;


    asnAtrList.Clear();
    for (index = 0; index < Count(); index += 1)
    {
        if (0 > asnAtrList.Add())
            ErrorThrow(PKCS_ASN_ERROR);
        patr = m_atrList[index];
        if (NULL ==
            (asnAtrList[(int)index].attributeType = (LPCTSTR)patr->GetType().Access()))
            ErrorThrow(PKCS_ASN_ERROR);
        length =
            asnAtrList[(int)index].attributeValue.Decode(
                            patr->GetValue().Access(),
                            patr->GetValue().Length());
        if (0 > length)
            ErrorThrow(PKCS_ASN_ERROR);
    }
    return;

ErrorExit:
    return;
}


/*++

AttributeValue:

    This routine returns the attribute value corresponding to the given object
    identifier.

Arguments:

    pszObjId - The object Identifier to search for.

Return Value:

    the Value of the attribute, or NULL if it's not in the list.

Author:

    Doug Barlow (dbarlow) 8/15/1995

--*/

CAttribute *
CAttributeList::operator[](
    IN LPCTSTR pszObjId)
    const
{
    DWORD
        count
            = m_atrList.Count(),
        index;

    for (index = 0; index < count; index += 1)
    {
        if (0 == strcmp(
                    ( char * )pszObjId,
                    ( LPCSTR )( ( LPCTSTR )m_atrList[index]->GetType())))
            return m_atrList[index];
    }
    return NULL;
}


//
//==============================================================================
//
//  CDistinguishedName
//

IMPLEMENT_NEW(CDistinguishedName)


/*++

Clear:

    This method cleans out a distinguished name.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

void
CDistinguishedName::Clear(
    void)
{
    DWORD count = Count();
    for (DWORD index = 0; index < count; index += 1)
    {
        CAttributeList * patl = m_rdnList[index];
        if (NULL != patl)
        {
            patl->Clear();
            delete patl;
        }
    }
    m_rdnList.Clear();
}


/*++

Add:

    This method adds an RDN to the end of the Distinguished name.

Arguments:

    prdn - Supplies the address of the RDN to be added to the list.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

void
CDistinguishedName::Add(
    IN CAttributeList &rdn)
{
    m_rdnList.Set(Count(), &rdn);
}


/*++

CDistinguishedName::Compare:

    This method compares a distingushed name for equivalence to this name.  A
    name is equivalent to this name if the lengths are the same, and the
    attributes of each RDN in the compared name is a subset of the corresponding
    RDN from this Name.

Arguments:

    pdn - Supplies the distingushed name to be compared to this name.

Return Value:

    -1 - The supplied name is a subset of this name.
     0 - The two names are identical.
     1 - The supplied name contains an RDN which contains an attribute not in
         the corresponding RDN of this name.

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

int
CDistinguishedName::Compare(
    IN const CDistinguishedName &dn)
    const
{
    int
        dif,
        result = 0;
    DWORD
        iTs = 0,
        iDn = 0,
        cTs = Count(),
        cDn = dn.Count();


    for (;;)
    {

        //
        // Have we reached the end of either set?
        //

        if (iDn >= cDn)
        {

            //
            // If we've reached the end of the dn list, then unless we've also
            // reached the end of this list, the dn list is a subset of this
            // list.
            //

            if (iTs < cTs)
                result = -1;
            break;
        }
        if (iTs >= cTs)
        {

            //
            // If we've reached the end of this list, then the dn list has more
            // elements.
            //

            result = 1;
            break;
        }


        //
        // There are still more elements to compare.  Make the comparison of the
        // two current elements.
        //

        dif = m_rdnList[(int)iTs]->Compare(*dn[(int)iDn]);
        if (0 < dif)
        {
            //
            // If the dn list element is less than this's element, then this has
            // an element it don't have.  Note it's a subset.
            //

            result = -1;
        }
        else if (0 > dif)
        {

            //
            // If the dn list element is greater than this's element, then it
            // has an element that this list doesn't have.  report it as a
            // non-proper subset.
            //

            result = 1;
            break;
        }
        // else they're the same, maintain status quo.

        iDn += 1;
        iTs += 1;
    }
    return result;
}


/*++

Import:

    This routine imports a character delimited name into the internal format.

Arguments:

    pszName - Supplies the character delimited name

Return Value:

    None.  An error code is thrown if an error occurs.

Author:

    Doug Barlow (dbarlow) 7/17/1995

--*/

void
CDistinguishedName::Import(
    IN LPCTSTR pszName)
{
    COctetString
        osAtrType,
        osAtrValue;
    CAttribute *
        patr
            = NULL;
    CAttributeList *
        patl
            = NULL;
    const char
        *pchStart
            = ( const char * )pszName,
        *pchEnd
            = ( const char * )pszName;


    //
    // Initialize the state machine.
    //

    Clear();


    //
    // Find an attribute.
    //

    while (0 != *pchEnd)
    {
        pchEnd = strpbrk( pchStart, ";\\=");
        if (NULL == pchEnd)
            pchEnd = pchStart + strlen(pchStart);
        switch (*pchEnd)
        {
        case TEXT(';'):
        case TEXT('\000'):
        case TEXT('\\'):

            // Flush any existing value into a value string.
            if (pchStart != pchEnd)
            {
                osAtrValue.Length(osAtrValue.Length() + (ULONG)(pchEnd - pchStart) + 1);
                ErrorCheck;
                if (0 < osAtrValue.Length())
                    osAtrValue.Resize(strlen( ( LPCSTR )( ( LPCTSTR )osAtrValue ) ) );
                ErrorCheck;
                osAtrValue.Append((LPBYTE)pchStart, (ULONG)(pchEnd - pchStart));
                ErrorCheck;
                osAtrValue.Append((LPBYTE)"\000", 1);
                ErrorCheck;
            }

            // Flush any existing strings into an attribute.
            if (0 != osAtrValue.Length())
            {
                if (NULL == patr)
                {
                    patr = new CAttribute;
                    if (NULL == patr)
                        ErrorThrow(PKCS_NO_MEMORY);
                }
                else
                    ErrorThrow(PKCS_NAME_ERROR);
                patr->Set(osAtrType, osAtrValue);
                ErrorCheck;
                osAtrValue.Empty();
                osAtrType.Empty();
            }

            // Flush any existing attribute into the attribute list.
            if (NULL != patr)
            {
                if (NULL == patl)
                {
                    patl = new CAttributeList;
                    if (NULL == patl)
                        ErrorThrow(PKCS_NO_MEMORY);
                }
                patl->Add(*patr);
                ErrorCheck;
                patr = NULL;
            }

            if (TEXT(';') != *pchEnd)
            {
                // Flush any existing attribute list into the name.
                if (NULL != patl)
                {
                    Add(*patl);
                    ErrorCheck;
                    patl = NULL;
                }
            }
            break;

        case TEXT('='):
            // Flush any existing value into the type string.
            if (0 != osAtrType.Length())
            {
                osAtrValue.Length(osAtrValue.Length() + (ULONG)(pchEnd - pchStart) + 1);
                ErrorCheck;
                if (0 < osAtrValue.Length())
                    osAtrValue.Resize(strlen( ( LPCSTR )( ( LPCTSTR )osAtrValue ) ) );
                ErrorCheck;
                osAtrValue.Append((LPBYTE)TEXT("="), sizeof(TCHAR));
                ErrorCheck;
                osAtrValue.Append((LPBYTE)pchStart, (ULONG)(pchEnd - pchStart));
                ErrorCheck;
                osAtrValue.Append((LPBYTE)"\000", 1);
                ErrorCheck;
            }
            else
            {
                if (pchStart != pchEnd)
                {
                    osAtrType.Set((LPBYTE)pchStart, (ULONG)(pchEnd - pchStart));
                    ErrorCheck;
                    osAtrType.Append((LPBYTE)"\000", 1);
                    ErrorCheck;
                }
            }
            ErrorCheck;
            break;

        default:
            ErrorThrow(PKCS_INTERNAL_ERROR);
        }

        // Move forward to the next token.
        if (TEXT('\000') != *pchEnd)
            pchEnd += 1;
        pchStart = pchEnd;
    }
    return;

ErrorExit:
    if (NULL != patr)
        delete patr;
    if (NULL != patl)
        delete patl;
    Clear();
}


void
CDistinguishedName::Import(
    IN const Name &asnName)
{
    DWORD
        rdnIndex,
        rdnMax;
    CAttributeList *
        patl
           = NULL;


    Clear();
    rdnMax = (DWORD)asnName.Count();
    for (rdnIndex = 0;
        rdnIndex < rdnMax;
        rdnIndex += 1)
    {
        patl = new CAttributeList;
        if (NULL == patl)
            ErrorThrow(PKCS_NO_MEMORY);
        patl->Import(
                asnName[(int)rdnIndex]);
        ErrorCheck;

        // Add that RDN into the Name.
        Add(*patl);
        ErrorCheck;
        patl = NULL;
    }
    return;

ErrorExit:
    if (NULL != patl)
        delete patl;
    Clear();
}


/*++

Export:

    This routine exports a name as a character delimited string.  In the string
    version, Only interesting attributes from within each RDN are exported.

Arguments:

    osName - Receives the exported name as a string.
    asnName - Receives the exported name as an ASN.1 construction.

Return Value:

    None.  A DWORD error code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 7/17/1995

--*/

void
CDistinguishedName::Export(
    OUT COctetString &osName)
const
{
    DWORD
        rdnIndex,
        atrIndex;
    CAttribute *
        patr
            = NULL;
    CAttributeList *
        patl
           = NULL;
    LPCTSTR
        pstr;
    CAsnPrintableString
        asnString;   // ?todo? Support other string types.
    CAsnUnicodeString
        asnUnicodeString;
    CAsnIA5String
        asnIA5String;
    COctetString
        osTmp;
    LONG
        lth;


    osName.Empty();
    for (rdnIndex = 0; rdnIndex < Count(); rdnIndex += 1)
    {
        patl = m_rdnList[rdnIndex];
        for (atrIndex = 0; atrIndex < patl->Count(); atrIndex += 1)
        {
            patr = (*patl)[(int)atrIndex];
            if (ATR_UNKNOWN >= patr->GetAtrType())
            {
                if (ATR_COMMONNAME != patr->GetAtrType())
                {
                    pstr = knownAttributes[patr->GetAtrType()].name;
                    osName.Append((LPBYTE)pstr, strlen( ( char * )pstr));
                    ErrorCheck;
                    osName.Append((LPBYTE)"=", 1);
                    ErrorCheck;
                }

                //
                // support printable and unicode string decoding
                //

                if(0 <= asnString.Decode(patr->GetValue().Access(),
                                         patr->GetValue().Length()))
                {
                    lth = asnString.DataLength();
                    if (0 > lth)
                        ErrorThrow(PKCS_ASN_ERROR);
                    osTmp.Resize(lth);
                    ErrorCheck;
                    lth = asnString.Read(osTmp.Access());
                    if (0 > lth)
                        ErrorThrow(PKCS_ASN_ERROR);
                }
                else if(0 <= asnUnicodeString.Decode(patr->GetValue().Access(),
                                                     patr->GetValue().Length()))
                {
                    lth = asnUnicodeString.DataLength();
                    if (0 > lth)
                        ErrorThrow(PKCS_ASN_ERROR);
                    osTmp.Resize(lth);
                    ErrorCheck;
                    lth = asnUnicodeString.Read(osTmp.Access());
                    if (0 > lth)
                        ErrorThrow(PKCS_ASN_ERROR);
                }
                else if(0 <= asnIA5String.Decode(patr->GetValue().Access(),
                                                 patr->GetValue().Length()))
                {
                    lth = asnIA5String.DataLength();
                    if (0 > lth)
                        ErrorThrow(PKCS_ASN_ERROR);
                    osTmp.Resize(lth);
                    ErrorCheck;
                    lth = asnIA5String.Read(osTmp.Access());
                    if (0 > lth)
                        ErrorThrow(PKCS_ASN_ERROR);
                }
                else
                {
                    ErrorThrow(PKCS_ASN_ERROR);
                }

                osName.Append(osTmp.Access(), lth);
                ErrorCheck;
            }
            // else, just ignore it.
            osName.Append((LPBYTE)";", 1);
            ErrorCheck;
        }

        if (0 < osName.Length())
            *(LPBYTE)(osName.Access(osName.Length() - 1)) = '\\';
    }
    if (0 < osName.Length())
        *(LPBYTE)(osName.Access(osName.Length() - 1)) = '\000';
    return;

ErrorExit:
    return;
}


void
CDistinguishedName::Export(
    OUT Name &asnName)
    const
{
    DWORD
        rdnIndex;
    CAttributeList *
        patl;


    asnName.Clear();
    for (rdnIndex = 0; rdnIndex < Count(); rdnIndex += 1)
    {
        patl = m_rdnList[rdnIndex];
        if (0 > asnName.Add())
            ErrorThrow(PKCS_ASN_ERROR);
        patl->Export(
            asnName[(int)rdnIndex]);
        ErrorCheck;
    }
    return;

ErrorExit:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\licecert\licecert.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    licecert.cpp

Abstract:

    This module contains the APIs for parsing and verifying X509 certificates

Author:

    Frederick Chong (fredch) 6/1/1998

Environment:

    Win32, WinCE, Win16

Notes:

--*/

#include <windows.h>

#include "license.h"
#include "certcate.h"
#include "licecert.h"

#define MAX_NUM_CERT_BLOBS 200

//+----------------------------------------------------------------------------
//
// Function:
//
//  VerifyCertChain
//
// Abstract:
//
//  Verifies a chain of X509 certificates
//
// Parameters:
//
//  pbCert - Points to the certificate chain
//  cbCert - Size of the certificate chain
//  pbPublicKey - The memory to store the public key of the subject on output.
//                If set to NULL on input, the API will return 
//                LICENSE_STATUS_INSUFFICIENT_BUFFER and the size of the 
//                required buffer set in pcbPublicKey.
//  pcbPublicKey - Size of the allocated memory on input.  On output, contains
//                 the actual size of the public key.
//  pfDates - How the API should check the validity dates in the cert chain.
//            This flag may be set to the following values:
//
//  CERT_DATE_ERROR_IF_INVALID - The API will return an error if the
//                               dates are invalid. When the API returns,
//                               this flag will be set to CERT_DATE_OK if the
//                               dates are OK or one of CERT_DATE_NOT_BEFORE_INVALID
//                               or CERT_DATE_NOT_AFTER_INVALID.
//  CERT_DATE_DONT_VALIDATE - Don't validate the dates in the cert chain.  The value
//                            in this flag is not changed when the API returns. 
//  CERT_DATE_WARN_IF_INVALID - Don't return an error for invalid cert dates.
//                              When the API returns, this flag will be set to
//                              CERT_DATE_OK if the dates are OK or one of
//                              CERT_DATE_NOT_BEFORE_INVALID or 
//                              CERT_DATE_NOT_AFTER_INVALID.
//
// Return:
//
//  LICENSE_STATUS_OK if the function is successful.
//
//+----------------------------------------------------------------------------
 
LICENSE_STATUS
VerifyCertChain( 
    LPBYTE  pbCert, 
    DWORD   cbCert,
    LPBYTE  pbPublicKey,
    LPDWORD pcbPublicKey,
    LPDWORD pfDates )
{
    PCert_Chain 
        pCertChain = ( PCert_Chain )pbCert;
    UNALIGNED Cert_Blob 
        *pCertificate;
    BYTE FAR * 
        abCertAligned;
    LPBYTE
        lpCertHandles = NULL;
    LPCERTIFICATEHANDLE phCert;

    LICENSE_STATUS
        dwRetCode = LICENSE_STATUS_OK;
    DWORD
        dwCertType = CERTYPE_X509, 
        dwIssuerLen, 
        i,
        cbCertHandles = 0;
    BOOL
        fRet;

    if( ( NULL == pCertChain ) || ( sizeof( Cert_Chain ) >= cbCert ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // check cert chain version
    //

    if( MAX_CERT_CHAIN_VERSION < GET_CERTIFICATE_VERSION( pCertChain->dwVersion ) )
    {
        return( LICENSE_STATUS_NOT_SUPPORTED );
    }

    //
    // allocate memory for the certificate handles
    //

    // arbitrary limit of blobs, so that cbCertHandles doesn't overflow
    if (pCertChain->dwNumCertBlobs > MAX_NUM_CERT_BLOBS)
    {
        return (LICENSE_STATUS_INVALID_INPUT);
    }

    //
    // Verify input data before actually allocate memory
    //
    pCertificate = (PCert_Blob)&(pCertChain->CertBlob[0]);
    for(i=0; i < pCertChain->dwNumCertBlobs; i++)
    {
        if (((PBYTE)pCertificate > (pbCert + (cbCert - sizeof(Cert_Blob)))) ||
            (pCertificate->cbCert == 0) ||
            (pCertificate->cbCert > (DWORD)((pbCert + cbCert) - pCertificate->abCert)))
        {
            return (LICENSE_STATUS_INVALID_INPUT);
        }

        pCertificate = (PCert_Blob)(pCertificate->abCert + pCertificate->cbCert);
    }

    cbCertHandles = sizeof( CERTIFICATEHANDLE ) * pCertChain->dwNumCertBlobs;
    lpCertHandles = new BYTE[ cbCertHandles ];
    
    if( NULL == lpCertHandles )
    {
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }

    memset( lpCertHandles, 0, cbCertHandles );

    //
    // Load all the certificates into memory.  The certificate chain always
    // start with the root issuer's certificate
    //

    for( i = 0, pCertificate = pCertChain->CertBlob, phCert = ( LPCERTIFICATEHANDLE )lpCertHandles; 
         i < pCertChain->dwNumCertBlobs; i++, phCert++ )
    {
        if (i != 0)
        {
            if (pCertificate->abCert == NULL)
            {
                abCertAligned = NULL;
            }
            else
            {
                abCertAligned = new BYTE[pCertificate->cbCert];
                if (NULL == abCertAligned)
                {
                    dwRetCode = LICENSE_STATUS_OUT_OF_MEMORY;
                    goto done;
                }

                memcpy(abCertAligned,pCertificate->abCert,pCertificate->cbCert);
            }
        }
        else
        {
            //
            // First item is always aligned
            //
            abCertAligned = pCertificate->abCert;
        }

        fRet = PkcsCertificateLoadAndVerify( phCert,
                                             abCertAligned,
                                             pCertificate->cbCert,
                                             &dwCertType,
                                             CERTSTORE_APPLICATION,
                                             CERTTRUST_NOONE,
                                             NULL,
                                             &dwIssuerLen,
                                             NULL,
                                             pfDates );

        if ((abCertAligned != NULL) && (abCertAligned != pCertificate->abCert))
        {
            delete [] abCertAligned;
        }

        if( !fRet )
        {
            dwRetCode = GetLastError();
            goto done;
        }

        pCertificate = (PCert_Blob )(pCertificate->abCert + pCertificate->cbCert);
    }

    //
    // Get the public key of the last certificate
    //

    if( !PkcsCertificateGetPublicKey( *( phCert - 1), pbPublicKey, pcbPublicKey ) )
    {
        dwRetCode = GetLastError();
    }

done:

    //
    // free all the certificate handles
    //

    if( lpCertHandles )
    {        
        for( i = 0, phCert = ( LPCERTIFICATEHANDLE )lpCertHandles;
             i < pCertChain->dwNumCertBlobs; i++, phCert++ )
        {
            if( *phCert )
            {
                PkcsCertificateCloseHandle( *phCert );
            }
        }

        delete [] lpCertHandles;
    }

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\licecert\pkcs_1.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pkcs_1.cpp

Abstract:

    This module implements the PKCS 1 ASN.1 objects

Author:

    Frederick Chong (fredch) 6/1/1998

Notes:

--*/

#include <windows.h>
#include "pkcs_1.h"

RSAPublicKey::RSAPublicKey(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    modulus(0),
    publicExponent(0)
{
    m_rgEntries.Set(0, &modulus);
    m_rgEntries.Set(1, &publicExponent);
}

CAsnObject *
RSAPublicKey::Clone(
    DWORD dwFlags)
const
{
    return new RSAPublicKey(dwFlags);
}


DigestInfo::DigestInfo(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    DigestAlgorithmIdentifier(0),
    Digest(0)
{
    m_rgEntries.Add(&DigestAlgorithmIdentifier);
    m_rgEntries.Add(&Digest);
}


CAsnObject *
DigestInfo::Clone(
    DWORD dwFlags)
const
{
    return new DigestInfo(dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\licecert\ostring.cpp ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    OctetString.cpp

Abstract:

    This module implements the COctetString class, providing simple manipulation
    of binary data.

Author:

    Doug Barlow (dbarlow) 9/29/1994

Environment:



Notes:



--*/

#include <windows.h>
#include <memory.h>
#include "oString.h"


static const BYTE FAR * const
    v_pvNilString
        = (const BYTE *)"";


//
//==============================================================================
//
//  COctetString
//

IMPLEMENT_NEW(COctetString)


/*++

COctetString:

    This routine provides default initialization.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

COctetString::COctetString()
{
    Initialize();
}

COctetString::COctetString(
    unsigned int nLength)
{
    Initialize();
    SetMinBufferLength(nLength);
}


/*++

COctetString:

    Construct an Octet String, copying data from a given octet string.

Arguments:

    osSource - Supplies the source octet string.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

COctetString::COctetString(
    IN const COctetString &osSource)
{
    Initialize();
    Set(osSource.m_pvBuffer, osSource.m_nStringLength);
}

COctetString::COctetString(
    IN const COctetString &osSourceOne,
    IN const COctetString &osSourceTwo)
{
    Initialize();
    SetMinBufferLength(
        osSourceOne.m_nStringLength + osSourceTwo.m_nStringLength);
    ErrorCheck;
    Set(osSourceOne.m_pvBuffer, osSourceOne.m_nStringLength);
    ErrorCheck;
    Append(osSourceTwo.m_pvBuffer, osSourceTwo.m_nStringLength);
    return;

ErrorExit:
    Empty();
    return;
}


/*++

COctetString:

    Construct an Octet String given a data block to initialize it from.

Arguments:

    pvSource - Supplies the data with which to load the octet string.

    nLength - Supplies the length of the source, in bytes.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

COctetString::COctetString(
    IN const BYTE FAR *pvSource,
    IN DWORD nLength)
{
    Initialize();
    Set(pvSource, nLength);
}


/*++

Initialize:

    This routine initializes a freshly created Octet String.  It doesn't
    reinitialize an old one!  Use Clear() for that.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/30/1994

--*/

void
COctetString::Initialize(
    void)
{
    m_nStringLength = m_nBufferLength = 0;
    m_pvBuffer = (LPBYTE)v_pvNilString;
}


/*++

Clear:

    This routine resets the octet string to an empty state.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

void
COctetString::Clear(
    void)
{
    if ((v_pvNilString != m_pvBuffer) && (NULL != m_pvBuffer))
    {
        delete[] m_pvBuffer;
        Initialize();
    }
}


/*++

Empty:

    Empty is a friendlier form of Clear, that can be called publicly, and just
    makes sure things are consistent.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 8/22/1995

--*/

void
COctetString::Empty(
    void)
{
    m_nStringLength = 0;
    if (NULL == m_pvBuffer)
        m_pvBuffer = (LPBYTE)v_pvNilString;
    if ((LPBYTE)v_pvNilString != m_pvBuffer)
        *m_pvBuffer = 0;
}


/*++

SetMinBufferLength:

    This routine ensures that there are at least the given number of octets
    within the buffer.  This routine can and will destroy existing data!  Use
    ResetMinBufferLength to preserve the data.

Arguments:

    nDesiredLength - Supplies the minimum number of octets needed.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

void
COctetString::SetMinBufferLength(
    IN DWORD nDesiredLength)
{
    if (m_nBufferLength < nDesiredLength)
    {
        Clear();
        NEWReason("COctetString Buffer")
        m_pvBuffer = new BYTE[nDesiredLength];
        if (NULL == m_pvBuffer)
        {
            Clear();
            ErrorThrow(PKCS_NO_MEMORY);
        }
        m_nBufferLength = nDesiredLength;
    }
    return;

ErrorExit:
    Empty();
}


/*++

ResetMinBufferLength:

    This routine ensures that the buffer has room for at least a given number of
    bytes, ensuring that any data is preserved should the buffer need enlarging.

Arguments:

    nDesiredLength - The number of bytes needed in the buffer.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

void
COctetString::ResetMinBufferLength(
    IN DWORD nDesiredLength)
{
    if (m_nBufferLength < nDesiredLength)
    {
        if (0 == m_nStringLength)
        {
            SetMinBufferLength(nDesiredLength);
            ErrorCheck;
        }
        else
        {
            NEWReason("COctetString Buffer")
            LPBYTE pvNewBuffer = new BYTE[nDesiredLength];
            if (NULL == pvNewBuffer)
                ErrorThrow(PKCS_NO_MEMORY);
            memcpy(pvNewBuffer, m_pvBuffer, m_nStringLength);
            delete[] m_pvBuffer;
            m_pvBuffer = pvNewBuffer;
            m_nBufferLength = nDesiredLength;
        }
    }
    return;

ErrorExit:
    Empty();
}


/*++

Set:

    Set an Octet String to a given value.

Arguments:

    pbSource - The source string that this octetstring gets set to.

    nLength - The number of octets in the source.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

void
COctetString::Set(
    IN const BYTE FAR * const pvSource,
    IN DWORD nLength)
{
    if (0 == nLength)
    {
        m_nStringLength = 0;
    }
    else
    {
        SetMinBufferLength(nLength);
        ErrorCheck;
        memcpy(m_pvBuffer, pvSource, nLength);
        m_nStringLength = nLength;
    }
    return;

ErrorExit:
    Empty();
}


/*++

Append:

    This routine appends a given string onto the end of an existing octet
    string.

Arguments:

    pvSource - Supplies the octet string to append onto this one.

    nLength - Supplies the length of the source.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

void
COctetString::Append(
    IN const BYTE FAR * const pvSource,
    IN DWORD nLength)
{
    if (0 != nLength)
    {
        ResetMinBufferLength(m_nStringLength + nLength);
        ErrorCheck;
        memcpy(&((LPSTR)m_pvBuffer)[m_nStringLength], pvSource, nLength);
        m_nStringLength += nLength;
    }
    return;

ErrorExit:
    Empty();
}


/*++

Compare:

    This method compares an octet string to this octet string for equality.

Arguments:

    ostr - Supplies the octet string to compare

Return Value:

    0 - They match
    otherwise, they don't.

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

int
COctetString::Compare(
    IN const COctetString &ostr)
    const
{
    int dif = (int)(ostr.m_nStringLength - m_nStringLength);
    if (0 == dif)
        dif = memcmp((LPSTR)m_pvBuffer, (LPSTR)ostr.m_pvBuffer, m_nStringLength);
    return dif;
}


/*++

operator=:

    This routine assigns the value of one octet string to another.

Arguments:

    Source - Supplies the source octet string.

Return Value:

    A reference to the resultant octet string.

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

COctetString &
COctetString::operator=(
    IN const COctetString &osSource)
{
    Set(osSource.m_pvBuffer, osSource.m_nStringLength);
    return *this;
}

COctetString &
COctetString::operator=(
    IN LPCTSTR pszSource)
{
    Set(pszSource);
    return *this;
}


/*++

operator+=:

    This routine appends the value of one octet string to another.

Arguments:

    Source - Supplies the source octet string.

Return Value:

    A reference to the resultant octet string.

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

COctetString &
COctetString::operator+=(
    IN const COctetString &osSource)
{
    Append(osSource.m_pvBuffer, osSource.m_nStringLength);
    return *this;
}


/*++

Range:

    This routine extracts a substring from the Octetstring, and places it into
    the given target octetstring.  Asking for an Offset that is greater than the
    size of the octetstring produces an empty string.  Asking for more bytes
    than exist in the octetstring produces just the bytes remaining.

Arguments:

    target - The octetstring to receive the substring.
    Offset - The number of bytes to move past the beginning of the source
             octetstring.  Zero implies start at the beginning.
    Length - The number of bytes to transfer.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 5/17/1995

--*/

DWORD
COctetString::Range(
    COctetString &target,
    DWORD offset,
    DWORD length)
    const
{
    if (offset > m_nStringLength)
    {
        target.m_nStringLength = 0;
    }
    else
    {
        if (length > m_nStringLength - offset)
            length = m_nStringLength - offset;
        target.SetMinBufferLength(length);
        ErrorCheck;
        memcpy(target.m_pvBuffer, (char *)m_pvBuffer + offset, length);
        target.m_nStringLength = length;
    }
    return target.m_nStringLength;

ErrorExit:
    target.Empty();
    return 0;
}

DWORD
COctetString::Range(
    LPBYTE target,
    DWORD offset,
    DWORD length)
    const
{
    if (offset > m_nStringLength)
        length = 0;
    else if (length > m_nStringLength - offset)
        length = m_nStringLength - offset;
    if (0 < length)
        memcpy(target, (char *)m_pvBuffer + offset, length);
    return length;
}


/*++
//
//==============================================================================
//
//  COctetString Friends
//

operator+:

    This routine concatenates two octet strings into a third.

Arguments:

    SourceOne - Supplies the first string.

    SourceTwo - Supplies the second string.

Return Value:

    A reference to a new resultant string.

Author:

    Doug Barlow (dbarlow) 9/30/1994

--*/
COctetString
operator+(
    IN const COctetString &osSourceOne,
    IN const COctetString &osSourceTwo)
{
    return COctetString(osSourceOne, osSourceTwo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\licecert\ostring.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    OctetString.h

Abstract:

    This header file describes a class for the manipulation of binary data.

Author:

    Doug Barlow (dbarlow) 9/29/1994

Environment:

    Works anywhere.

Notes:



--*/

#ifndef _OCTETSTRING_H_
#define _OCTETSTRING_H_
#ifdef _DEBUG
#include <iostream.h>
#endif

#ifndef NO_EXCEPTS
#include "pkcs_err.h"
#endif
#include "memcheck.h"


//
//==============================================================================
//
//  COctetString
//

class
COctetString
{
public:

    DECLARE_NEW

    //  Constructors & Destructor

    COctetString();         //  Default constructor.

    COctetString(           //  Object assignment constructors.
        IN const COctetString &osSource);

    COctetString(
        IN const BYTE FAR *pvSource,
        IN DWORD nLength);

    COctetString(
        IN unsigned int nLength);

    virtual ~COctetString()
    { Clear(); };


    //  Properties


    //  Methods

    void
    Set(
        IN const BYTE FAR * const pvSource,
        IN DWORD nLength);

    void
    Set(
        IN LPCTSTR pstrSource,
        IN DWORD nLength = 0xffffffff)
    {
        if (0xffffffff == nLength)
            nLength = strlen( ( char * )pstrSource) + 1;
        Set((const BYTE FAR *)pstrSource, nLength);
    };

    void
    Append(
        IN const BYTE FAR * const pvSource,
        IN DWORD nLength);

    void
    Append(
        IN const COctetString &osSource)
    { Append(osSource.m_pvBuffer, osSource.m_nStringLength); };

    DWORD
    Length(
        void) const
    { return m_nStringLength; };

    void
    Resize(
        IN DWORD nLength)
    {
        ResetMinBufferLength(nLength);
#ifndef NO_EXCEPTS
        ErrorCheck;
#endif
        m_nStringLength = nLength;
#ifndef NO_EXCEPTS
    ErrorExit:
        return;
#endif
    };

    int
    Compare(
        IN const COctetString &ostr)
        const;

    DWORD
    Length(
        IN DWORD size)
    {
        ResetMinBufferLength(size);
        return m_nBufferLength;
    };

    BYTE FAR *
    Access(
        DWORD offset = 0)
        const
    {
        if (offset >= m_nStringLength)
        {
            return NULL;
        }
        return m_pvBuffer + offset;
    }

    DWORD
    Range(
        COctetString &target,
        DWORD offset,
        DWORD length)
        const;
    DWORD
    Range(
        LPBYTE target,
        DWORD offset,
        DWORD length)
        const;

    void
    Empty(
        void);

    void
    Clear(
        void);


    //  Operators

    COctetString &
    operator=(
        IN const COctetString &osSource);

    COctetString &
    operator=(
        IN LPCTSTR pszSource);

    COctetString &
    operator+=(
        IN const COctetString &osSource);

    BYTE
    operator[](
        int offset)
        const
    {
        if ((DWORD)offset >= m_nStringLength)
            return 0;
        return *Access(offset);
    }

    int
    operator==(
        IN const COctetString &ostr)
        const
    { return 0 == Compare(ostr); };

    int
    operator!=(
        IN const COctetString &ostr)
        const
    { return 0 != Compare(ostr); };

    operator LPCTSTR(void) const
    {
#ifdef _DEBUG
        DWORD length = strlen(( LPCSTR )m_pvBuffer);
        if (length > m_nBufferLength)
            cerr << "Buffer overrun!" << endl;
        if (length > m_nStringLength)
            cerr << "String overrun!" << endl;
#endif
        return (LPCTSTR)m_pvBuffer;
    };


protected:

    COctetString(           //  Object assignment constructors.
        IN const COctetString &osSourceOne,
        IN const COctetString &osSourceTwo);

    //  Properties

    DWORD m_nStringLength;
    DWORD m_nBufferLength;
    LPBYTE m_pvBuffer;


    //  Methods

    void
    Initialize(
        void);

    void
    SetMinBufferLength(
        IN DWORD nDesiredLength);

    void
    ResetMinBufferLength(
        IN DWORD nDesiredLength);

    friend
        COctetString 
        operator+(
            IN const COctetString &osSourceOne,
            IN const COctetString &osSourceTwo);

};

COctetString 
operator+(
    IN const COctetString &osSourceOne,
    IN const COctetString &osSourceTwo);

#endif // _OCTETSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\licecert\pkcs_1.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pkcs_1.h

Abstract:

    This module implements the PKCS 1 ASN.1 objects

Author:

    Frederick Chong (fredch) 6/1/1998

Notes:

--*/

#ifndef _PKCS_1_H_
#define _PKCS_1_H_

#include <MSAsnLib.h>
#include "x509.h"

class RSAPublicKey
:   public CAsnSequence
{
public:
    RSAPublicKey(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CAsnInteger modulus;
    CAsnInteger publicExponent;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


class DigestInfo
:   public CAsnSequence
{
public:
    DigestInfo(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    AlgorithmIdentifier DigestAlgorithmIdentifier;
    CAsnOctetstring     Digest;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\licecert\names.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    names

Abstract:

    This header file describes the class used for name translation.

Author:

    Doug Barlow (dbarlow) 7/12/1995

Environment:

    Win32, C++

Notes:



--*/

#ifndef _NAMES_H_
#define _NAMES_H_

#include "x509.h"
#include "ostring.h"
#include "memcheck.h"

class Name;


//
//==============================================================================
//
//  CCollection
//

template <class T>
class CCollection
{
public:

    //  Constructors & Destructor

    CCollection(void)
    { m_Max = m_Mac = 0; m_pvList = NULL; };

    virtual ~CCollection()
    { Clear(); };


    //  Properties
    //  Methods

    void
    Clear(void)
    {
        if (NULL != m_pvList)
        {
            delete[] m_pvList;
            m_pvList = NULL;
            m_Max = 0;
            m_Mac = 0;
        }
    };

    void
    Set(
        IN int nItem,
        IN T *pvItem);
    T * const
    Get(
        IN int nItem)
        const;
    DWORD
    Count(void) const
    { return m_Mac; };


    //  Operators
    T * const
    operator[](int nItem) const
    { return Get(nItem); };


protected:
    //  Properties

    DWORD
        m_Max,          // Number of element slots available.
        m_Mac;          // Number of element slots used.
    T **
        m_pvList;       // The elements.


    //  Methods
};


/*++

Set:

    This routine sets an item in the collection array.  If the array isn't that
    big, it is expanded will NULL elements to become that big.

Arguments:

    nItem - Supplies the index value to be set.
    pvItem - Supplies the value to be set into the given index.

Return Value:

    None.  A DWORD error code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template<class T>
inline void
CCollection<T>::Set(
    IN int nItem,
    IN T * pvItem)
{
    DWORD index;


    //
    // Make sure the array is big enough.
    //

    if ((DWORD)nItem >= m_Max)
    {
        int newSize = (0 == m_Max ? 16 : m_Max);
        while (nItem >= newSize)
            newSize *= 2;
        NEWReason("Collection array")
        T **newList = new T*[newSize];
        if (NULL == newList)
            ErrorThrow(PKCS_NO_MEMORY);
        for (index = 0; index < m_Mac; index += 1)
            newList[index] = m_pvList[index];
        if (NULL != m_pvList)
            delete[] m_pvList;
        m_pvList = newList;
        m_Max = newSize;
    }


    //
    // Make sure intermediate elements are filled in.
    //

    if ((DWORD)nItem >= m_Mac)
    {
        for (index = m_Mac; index < (DWORD)nItem; index += 1)
            m_pvList[index] = NULL;
        m_Mac = (DWORD)nItem + 1;
    }


    //
    // Fill in the list element.
    //

    m_pvList[(DWORD)nItem] = pvItem;
    return;

ErrorExit:
    return;
}


/*++

Get:

    This method returns the element at the given index.  If there is no element
    previously stored at that element, it returns NULL.  It does not expand the
    array.

Arguments:

    nItem - Supplies the index into the list.

Return Value:

    The value stored at that index in the list, or NULL if nothing has ever been
    stored there.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template <class T>
inline T * const
CCollection<T>::Get(
    int nItem)
    const
{
    if (m_Mac <= (DWORD)nItem)
        return NULL;
    else
        return m_pvList[nItem];
}


//
//==============================================================================
//
//  CAttribute
//

class CAttribute
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAttribute()
    :   m_osValue(),
        m_osObjId()
    { m_nType = 0; };

    virtual ~CAttribute() {};


    //  Properties
    //  Methods

    int
    TypeCompare(
        IN const CAttribute &atr)
        const;

    int
    Compare(
        IN const CAttribute &atr)
        const;

    void
    Set(
        IN LPCTSTR pszType,
        IN const BYTE FAR * pbValue,
        IN DWORD cbValLen);

    void
    Set(
        IN LPCTSTR szType,
        IN LPCTSTR szValue);

    const COctetString &
    GetValue(void) const
    { return m_osValue; };

    const COctetString &
    GetType(void) const
    { return m_osObjId; };

    DWORD
    GetAtrType(void) const
    { return m_nType; };


    //  Operators

    int
    operator==(
        IN const CAttribute &atr)
        const
    { return 0 == Compare(atr); };

    int
    operator!=(
        IN const CAttribute &atr)
        const
    { return 0 != Compare(atr); };

    CAttribute &
    operator=(
        IN const CAttribute &atr)
    { Set(atr.GetType(), atr.GetValue().Access(), atr.GetValue().Length());
      return *this; };


protected:
    //  Properties

    DWORD m_nType;
    COctetString m_osValue;
    COctetString m_osObjId;


    //  Methods
};


//
//==============================================================================
//
//  CAttributeList
//

class CAttributeList
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    ~CAttributeList()
    { Clear(); };


    //  Properties
    //  Methods

    void
    Clear(                          //  Remove all contents.
        void);

    void
    Add(
        IN CAttribute &atr);
    DWORD
    Count(void)
        const
    { return m_atrList.Count(); };
    void
    Import(
        const Attributes &asnAtrList);
    void
    Export(
        Attributes &asnAtrList)
        const;
    int
    Compare(
        IN const CAttributeList &rdn)
        const;


    //  Operators

    void
    operator+=(
        IN CAttribute &atr)
    { Add(atr); };

    int operator==(
        IN const CAttributeList &rdn)
        const
    { return 0 == Compare(rdn); };

    int operator!=(
        IN const CAttributeList &rdn)
        const
    { return 0 != Compare(rdn); };

    int operator<(
        IN const CAttributeList &rdn)
        const
    { return -1 == Compare(rdn); };

    int operator>(
        IN const CAttributeList &rdn)
        const
    { return 1 == Compare(rdn); };

    int operator<=(
        IN const CAttributeList &rdn)
        const
    { return 1 != Compare(rdn); };

    int operator>=(
        IN const CAttributeList &rdn)
        const
    { return -1 != Compare(rdn); };

    CAttribute *
    operator[](
        IN int nItem)
        const
    { return m_atrList[nItem]; };

    CAttribute *
    operator[](
        IN LPCTSTR pszObjId)
        const;

    CAttributeList &
    operator=(
        IN const CAttributeList &atl);


protected:
    //  Properties

    CCollection<CAttribute>
        m_atrList;

    //  Methods
};


//
//==============================================================================
//
//  CDistinguishedName
//

class CDistinguishedName
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    virtual ~CDistinguishedName()
    { Clear(); };


    //  Properties
    //  Methods

    void
    Clear(
        void);

    void
    Add(
        IN CAttributeList &prdn);
    int
    Compare(
        IN const CDistinguishedName &pdn)
        const;
    DWORD
    Count(void)
        const
    { return m_rdnList.Count(); };

    void
    Import(
        IN LPCTSTR pszName);
    void
    Import(
        IN const Name &asnName);

    void
    Export(
        OUT COctetString &osName)
        const;
    void
    Export(
        OUT Name &asnName)
        const;


    //  Operators

    void
    operator+=(
        IN CAttributeList &rdn)
    { Add(rdn); };

    int operator==(
        IN const CDistinguishedName &dn)
        const
    { return 0 == Compare(dn); };

    int operator!=(
        IN const CDistinguishedName &dn)
        const
    { return 0 != Compare(dn); };

    int operator<(
        IN const CDistinguishedName &dn)
        const
    { return -1 == Compare(dn); };

    int operator>(
        IN const CDistinguishedName &dn)
        const
    { return 1 == Compare(dn); };

    int operator<=(
        IN const CDistinguishedName &dn)
        const
    { return 1 != Compare(dn); };

    int operator>=(
        IN const CDistinguishedName &dn)
        const
    { return -1 != Compare(dn); };

    CAttributeList *
    operator[](
        IN int nItem)
        const
    { return m_rdnList[nItem]; };


protected:
    //  Properties

    CCollection<CAttributeList>
        m_rdnList;

    //  Methods
};

#endif // _NAMES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\licecert\pkcs_err.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pkcs_err

Abstract:

    This routine performs error collection and remapping for the PKCS
    Certificate library.  The exception code is translated into an error code,
    which is placed into LastError for reference by the calling application.

Author:

    Doug Barlow (dbarlow) 9/18/1995

Environment:

    Win32, Crypto API

Notes:

--*/

#include <windows.h>

#ifdef OS_WINCE
#include <wince.h>
#endif

#include "pkcs_err.h"

/*++

MapError:

    This routine returns an indication of error.

Arguments:

    None.

Return Value:

    TRUE - No error encountered.
    FALSE - An error was reported -- Details in LastError.

Author:

    Doug Barlow (dbarlow) 9/18/1995

--*/

BOOL
MapError(
    void)
{
    return (GetLastError() == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\licecert\pkcs_err.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pkcs_err

Abstract:

    This header file contains the definitions for the various error codes that
    can occur within the PKCS library.

Author:

    Doug Barlow (dbarlow) 8/4/1995

Environment:

    Win32, Crypto API

Notes:



--*/

#ifndef _PKCS_ERR_H_
#define _PKCS_ERR_H_

#include "license.h"
#include "memcheck.h"

#define PKCSERR_PREFIX 0

static const DWORD
    PKCS_NO_MEMORY =       (DWORD)LICENSE_STATUS_OUT_OF_MEMORY,         // Memory Allocation Error.
    PKCS_NAME_ERROR =      (DWORD)LICENSE_STATUS_INVALID_X509_NAME,     // X.509 name parsing error.
    PKCS_INTERNAL_ERROR =  (DWORD)LICENSE_STATUS_UNSPECIFIED_ERROR,     // Internal logic error.
    PKCS_NO_SUPPORT =      (DWORD)LICENSE_STATUS_NOT_SUPPORTED,         // Unsupported algorithm or attribute.
    PKCS_BAD_PARAMETER =   (DWORD)LICENSE_STATUS_INVALID_INPUT,         // Invalid Paramter.
    PKCS_CANT_VALIDATE =   (DWORD)LICENSE_STATUS_INVALID_CERTIFICATE,   // Can't validate signature.
    PKCS_NO_ATTRIBUTE =    (DWORD)LICENSE_STATUS_NO_ATTRIBUTES,         // No attribute to match id.
    PKCS_NO_EXTENSION =    (DWORD)LICENSE_STATUS_NO_EXTENSION,          // No extension to match id.
    PKCS_BAD_LENGTH =      (DWORD)LICENSE_STATUS_INSUFFICIENT_BUFFER,   // Insufficient buffer size.
    PKCS_ASN_ERROR =       (DWORD)LICENSE_STATUS_ASN_ERROR,             // ASN.1 Error from ASN_EZE Library.
    PKCS_INVALID_HANDLE =  (DWORD)LICENSE_STATUS_INVALID_HANDLE;        // Invalid handle

extern BOOL
MapError(
    void);


//
// Pseudo Exception Handling Macros.
//

#define ErrorInitialize SetLastError(0)
#define ErrorThrow(sts) \
    { if (0 == GetLastError()) SetLastError(sts); \
      goto ErrorExit; }
#define ErrorCheck if (0 != GetLastError()) goto ErrorExit
#define ErrorSet(sts) SetLastError(sts)

#endif // _PKCS_ERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\licecert\utility.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    utility

Abstract:

    This header file describes the utility routines available to the PKCS
    library.

Author:

    Frederick Chong (fredch) 6/1/1998, adapted from Doug Barlow's PKCS library
    code.

Notes:


--*/

#ifndef _UTILITY_H_
#define _UTILITY_H_

#include "certcate.h"
#include "ostring.h"
#include "x509.h"
#include "pkcs_err.h"

#ifdef OS_WINCE
#include <adcgbtyp.h>
#endif
#ifndef RSA1
#define RSA1 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'1'<<24))
#define RSA2 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'2'<<24))
#endif


typedef struct {
    LPCTSTR szKey;
    DWORD dwValue;
} MapStruct;

extern DWORD
DwordToPkcs(
    IN OUT LPBYTE dwrd,
    IN DWORD lth);

extern DWORD
PkcsToDword(
    IN OUT LPBYTE pbPkcs,
    IN DWORD lth);

extern DWORD
ASNlength(
    IN const BYTE FAR *asnBuf,
    IN DWORD cbBuf,
    OUT LPDWORD pdwData = NULL);

extern void
PKInfoToBlob(
    IN SubjectPublicKeyInfo &asnPKInfo,
    OUT COctetString &osBlob);

extern ALGORITHM_ID
ObjIdToAlgId(
    const AlgorithmIdentifier &asnAlgId);

extern void
FindSignedData(
    IN const BYTE FAR * pbSignedData,
    IN DWORD cbSignedData,
    OUT LPDWORD pdwOffset,
    OUT LPDWORD pcbLength);

extern BOOL
NameCompare(
    IN LPCTSTR szName1,
    IN LPCTSTR szName2);

extern BOOL
NameCompare(
    IN const Name &asnName1,
    IN const Name &asnName2);

extern BOOL
NameCompare(
    IN LPCTSTR szName1,
    IN const Name &asnName2);

extern BOOL
NameCompare(
    IN const Name &asnName1,
    IN LPCTSTR szName2);

extern BOOL
NameCompare(
    IN const CDistinguishedName &dnName1,
    IN const Name &asnName2);

extern void
VerifySignedAsn(
    IN const CCertificate &crt,
    IN const BYTE FAR * pbAsnData,
    IN DWORD cbAsnData,
    IN LPCTSTR szDescription);
    
extern BOOL
MapFromName(
    IN const MapStruct *pMap,
    IN LPCTSTR szKey,
    OUT LPDWORD pdwResult);

extern BOOL
GetHashData( 
    COctetString &osEncryptionBlock, 
    COctetString &osHashData );

//
//==============================================================================
//
//  CHandleTable
//

#ifdef OS_WINCE
#define ULongToPtr( ul ) ((VOID *)(ULONG_PTR)((unsigned long)ul))
#endif

#define BAD_HANDLE (DWORD)(-1)
#define MAKEHANDLE(id, ix) ULongToPtr(((id) << 24) + (ix))

#ifdef OS_WINCE
#define PARSEHANDLE(hdl) ((m_bIdentifier == ((DWORD)(hdl) >> 24)) \
                            ? (DWORD)(hdl) & 0x00ffffff \
                            : BAD_HANDLE)
#else
#define PARSEHANDLE(hdl) ((m_bIdentifier == (PtrToUlong(hdl) >> 24)) \
                            ? PtrToUlong(hdl) & 0x00ffffff \
                            : BAD_HANDLE)
#endif

template <class T>
class CHandleTable
{
public:

    //  Constructors & Destructor

    CHandleTable(BYTE bIdentifier)
    :   m_rghHandles()
    {
        m_bIdentifier = bIdentifier;
        __try {
            InitializeCriticalSection(&m_critSect);
            m_fValid = TRUE;
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            m_fValid = FALSE;
        }

    };

    virtual ~CHandleTable()
    {
        if (m_fValid)
        {
            Clear();
            DeleteCriticalSection(&m_critSect);
        }
    };


    //  Methods

    const void *
    Add(
        T *pT)
    {
        LPVOID pvHandle;

        if (!m_fValid)
            ErrorThrow(PKCS_NO_MEMORY);

        EnterCriticalSection(&m_critSect);
        __try
        {
            for (DWORD index = 0; NULL != m_rghHandles[index]; index += 1);
                // Null for loop body.
            m_rghHandles.Set(index, pT);
            pvHandle = MAKEHANDLE(m_bIdentifier, index);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            pvHandle = NULL;
        }
        LeaveCriticalSection(&m_critSect);
        ErrorCheck;
        if (NULL == pvHandle)
            ErrorThrow(PKCS_NO_MEMORY);
        return pvHandle;

    ErrorExit:
        return NULL;
    };

    const void *
    Create(void)
    {
        const void *pvHandle;
        T *pT = NULL;

        if (!m_fValid)
            ErrorThrow(PKCS_NO_MEMORY);

        NEWReason("Handle Table Entry")
        pT = new T;
        if (NULL == pT)
            ErrorThrow(PKCS_NO_MEMORY);
        pvHandle = Add(pT);
        ErrorCheck;
        return pvHandle;

    ErrorExit:
        if (NULL != pT)
            delete pT;
        return NULL;
    };

    T *
    Lookup(
        IN const void *hHandle,
        IN BOOL fThrowErr = TRUE)
    {
        T *pt = NULL;

        if (!m_fValid)
            ErrorThrow(PKCS_NO_MEMORY);
#ifndef OS_WINCE
        DWORD index = PARSEHANDLE(hHandle);
#else
        DWORD index;
		index = PARSEHANDLE(hHandle);
#endif
        if (BAD_HANDLE != index)
        {
            EnterCriticalSection(&m_critSect);
            __try
            {
                pt = m_rghHandles[index];
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                pt = NULL;
            }
            LeaveCriticalSection(&m_critSect);
        }
        if (NULL == pt && fThrowErr)
            ErrorThrow(PKCS_INVALID_HANDLE);
        return pt;

    ErrorExit:
        return NULL;
    };

    void
    Delete(
        IN const void *hHandle)
    {
        T *pt = NULL;

        if (!m_fValid)
            ErrorThrow(PKCS_NO_MEMORY);

#ifndef OS_WINCE
        DWORD index = PARSEHANDLE(hHandle);
#else
        DWORD index;
		index = PARSEHANDLE(hHandle);
#endif
        if (BAD_HANDLE != index)
        {
            EnterCriticalSection(&m_critSect);
            __try
            {
                pt = m_rghHandles[index];
                if (NULL != pt)
                {
                    m_rghHandles.Set(index, NULL);
                    delete pt;
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {}
            LeaveCriticalSection(&m_critSect);
        }
        if (NULL == pt)
            ErrorThrow(PKCS_INVALID_HANDLE);

    ErrorExit:
        return;
    };

    DWORD
    Count(void) const
    { return m_fValid ? m_rghHandles.Count() : 0; };

    void
    Clear(void)
    {
        T *pt;

        if (!m_fValid)
            return;

        for (DWORD index = m_rghHandles.Count(); 0 < index;)
        {
            index -= 1;
            pt = m_rghHandles[index];
            if (NULL != pt)
                delete pt;
        }
        m_rghHandles.Clear();
    }

protected:
    //  Properties

    CRITICAL_SECTION
        m_critSect;
    BYTE
        m_bIdentifier;
    CCollection<T>
        m_rghHandles;
    BOOL m_fValid;


    // Methods
};

#endif // _UTILITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certutil\decode.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        decode.c
//
// Contents:    Routine related to decoding client certificate
//
// History:     03-18-98    HueiWang    Created
//
// Note:
//---------------------------------------------------------------------------
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <shellapi.h>
#include <stddef.h>
#include <winnls.h>
#include "base64.h"
#include "license.h"
#include "cryptkey.h"
#include "certutil.h"

extern HCRYPTPROV  g_hCertUtilCryptProv;

//
// Internal to this file only
//
typedef struct CertNameInfoEnumStruct10 {
    PBYTE   pbSecretKey;
    DWORD   cbSecretKey;
    HWID    hWid;
} CertNameInfoEnumStruct10, *PCertNameInfoEnumStruct10;


typedef struct CertNameInfoEnumStruct20 {
    PBYTE   pbSecretKey;
    DWORD   cbSecretKey;

    PLICENSEDPRODUCT pLicensedProduct;
} CertNameInfoEnumStruct20, *PCertNameInfoEnumStruct20;

///////////////////////////////////////////////////////////////////////////////

int __cdecl
SortLicensedProduct(
    const void* elem1,
    const void* elem2
    )
/*++

Abstract:

    Sort licensed product array in decending order

++*/
{
    PLICENSEDPRODUCT p1=(PLICENSEDPRODUCT) elem1;
    PLICENSEDPRODUCT p2=(PLICENSEDPRODUCT) elem2;

    if(p1->pLicensedVersion->wMajorVersion != p2->pLicensedVersion->wMinorVersion)
    {
        return p2->pLicensedVersion->wMajorVersion - p1->pLicensedVersion->wMinorVersion;
    }

    return p2->pLicensedVersion->wMinorVersion - p1->pLicensedVersion->wMinorVersion;
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
LicenseGetSecretKey(
    PDWORD  pcbSecretKey,
    BYTE FAR *   pSecretKey )
{
    static BYTE bSecretKey[] = { 0xCF, 0x08, 0x75, 0x4E, 0x5F, 0xDC, 0x2A, 0x57, 
                                0x43, 0xEE, 0xE5, 0xA9, 0x8E, 0xD4, 0xF0, 0xD0 };

    if( sizeof( bSecretKey ) > *pcbSecretKey )
    {
        *pcbSecretKey = sizeof( bSecretKey );
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    memcpy( pSecretKey, bSecretKey, sizeof( bSecretKey ) );
    *pcbSecretKey = sizeof( bSecretKey );

    return( LICENSE_STATUS_OK );
}

/***************************************************************************************

    LSFreeLicensedProduct(PLICENSEDPRODUCT pLicensedProduct)

***************************************************************************************/
void 
LSFreeLicensedProduct(
    PLICENSEDPRODUCT pLicensedProduct
    )
/*++

++*/
{
    if(pLicensedProduct)
    {
        if(pLicensedProduct->pbOrgProductID)
        {
            FreeMemory(pLicensedProduct->pbOrgProductID);
            pLicensedProduct->pbOrgProductID = NULL;
        }

        if(pLicensedProduct->pbPolicyData)
        {
            FreeMemory(pLicensedProduct->pbPolicyData);
            pLicensedProduct->pbPolicyData = NULL;
        }

        if(pLicensedProduct->pLicensedVersion)
        {
            FreeMemory(pLicensedProduct->pLicensedVersion);
            pLicensedProduct->pLicensedVersion = NULL;
        }
    
        FreeMemory(pLicensedProduct->szLicensedClient);
        pLicensedProduct->szLicensedClient = NULL;

        FreeMemory(pLicensedProduct->szLicensedUser);
        pLicensedProduct->szLicensedUser = NULL;

        if(pLicensedProduct->LicensedProduct.pProductInfo)
        {
            FreeMemory(pLicensedProduct->LicensedProduct.pProductInfo->pbCompanyName);
            pLicensedProduct->LicensedProduct.pProductInfo->pbCompanyName = NULL;

            FreeMemory(pLicensedProduct->LicensedProduct.pProductInfo->pbProductID);
            pLicensedProduct->LicensedProduct.pProductInfo->pbProductID = NULL;

            FreeMemory(pLicensedProduct->LicensedProduct.pProductInfo);
            pLicensedProduct->LicensedProduct.pProductInfo = NULL;
        }

        FreeMemory(pLicensedProduct->szIssuer);
        pLicensedProduct->szIssuer = NULL;

        FreeMemory(pLicensedProduct->szIssuerId);
        pLicensedProduct->szIssuerId = NULL;

        FreeMemory(pLicensedProduct->szIssuerScope);
        pLicensedProduct->szIssuerScope = NULL;

        if(pLicensedProduct->LicensedProduct.pbEncryptedHwid)
        {
            FreeMemory(pLicensedProduct->LicensedProduct.pbEncryptedHwid);
            pLicensedProduct->LicensedProduct.pbEncryptedHwid = NULL;
        }

        if(pLicensedProduct->szIssuerDnsName)
        {
            FreeMemory(pLicensedProduct->szIssuerDnsName);
            pLicensedProduct->szIssuerDnsName = NULL;
        }

        //if(pLicensedProduct->pbEncodedHWID)
        //    FreeMemory(pLicensedProduct->pbEncodedHWID);
    } 
}

/***************************************************************************************

BOOL WINAPI CryptDecodeObject(  DWORD dwEncodingType,  // in
                                LPCSTR lpszStructType, // in  
                                const BYTE * pbEncoded,  // in
                                DWORD cbEncoded,       // in  
                                DWORD dwFlags,         // in
                                void * pvStructInfo,   // out  
                                DWORD * pcbStructInfo  // in/out); 

***************************************************************************************/
DWORD 
LSCryptDecodeObject(  
    IN DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE * pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    OUT void ** pvStructInfo,   
    IN OUT DWORD * pcbStructInfo
    )
/*++

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(!CryptDecodeObject(dwEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, NULL, pcbStructInfo) ||
       (*pvStructInfo=(PBYTE)AllocMemory(*pcbStructInfo)) == NULL ||
       !CryptDecodeObject(dwEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, *pvStructInfo, pcbStructInfo))
    {
        dwStatus=GetLastError();
    }

    return dwStatus;
}

/***************************************************************************************
Function:

    LSDecodeClientHWID(IN PBYTE pbData, 
                       IN DWORD cbData, 
                       IN PBYTE* pbSecretKey, 
                       IN DWORD cbSecretKey,       
                       IN OUT HWID* pHwid)

Abstract:

Parameters:

Returns:    

***************************************************************************************/
LICENSE_STATUS
LSDecodeClientHWID(
    PBYTE pbData, 
    DWORD cbData, 
    PBYTE pbSecretKey, 
    DWORD cbSecretKey, 
    HWID* pHwid
    )
/*++
++*/
{
    CHAR pbDecodedHwid[1024];
    DWORD cbDecodedHwid=sizeof(pbDecodedHwid);

    //
    // Client Encrypted HWID can't be more than 1K
    //
    if(cbData >= cbDecodedHwid)
    {
        return LICENSE_STATUS_INVALID_INPUT;
    }
        
    SetLastError(LICENSE_STATUS_OK);
    memset(pbDecodedHwid, 0, sizeof(pbDecodedHwid));

    __try {
        if(LSBase64Decode(CAST_PBYTE pbData, cbData, (UCHAR *)pbDecodedHwid, &cbDecodedHwid) != LICENSE_STATUS_OK ||
           LicenseDecryptHwid(pHwid, cbDecodedHwid, (UCHAR *)pbDecodedHwid, cbSecretKey, pbSecretKey) != 0)
        {
            SetLastError(LICENSE_STATUS_CANNOT_VERIFY_HWID);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(LICENSE_STATUS_UNSPECIFIED_ERROR);
    }

    return GetLastError();
}


LICENSE_STATUS
LSEncryptClientHWID(
    HWID* pHwid, 
    PBYTE pbData, 
    PDWORD cbData, 
    PBYTE pbSecretKey, 
    DWORD cbSecretKey
    )
/*++
++*/
{
    BYTE tmp_pbEncryptedHwid[sizeof(HWID)*2+2];
    DWORD tmp_cbEncryptedHwid=sizeof(tmp_pbEncryptedHwid);
    PBYTE pbKey=NULL;
    DWORD cbKey=0;
    DWORD status;

    if(pbSecretKey)
    {
        pbKey = pbSecretKey;
        cbKey = cbSecretKey;
    }
    else
    {
        LicenseGetSecretKey( &cbKey, NULL );
        if((pbKey = (PBYTE)AllocMemory(cbKey)) == NULL)
        {
            return LICENSE_STATUS_OUT_OF_MEMORY;
        }

        status=LicenseGetSecretKey( &cbKey, pbKey );
        if(status != LICENSE_STATUS_OK)
        {
            return status;
        }
    }

    memset(tmp_pbEncryptedHwid, 0, sizeof(tmp_pbEncryptedHwid));
    if((status=LicenseEncryptHwid(pHwid,
                                  &tmp_cbEncryptedHwid, 
                                  tmp_pbEncryptedHwid, 
                                  cbKey,
                                  pbKey) != LICENSE_STATUS_OK))
    {
        return status;
    }

    if(pbData && *cbData)
    {
        memcpy(pbData, tmp_pbEncryptedHwid, tmp_cbEncryptedHwid);
    }

    *cbData = tmp_cbEncryptedHwid;
    if(pbKey != pbSecretKey)
        FreeMemory(pbKey);

    return LICENSE_STATUS_OK;
}

/*************************************************************************************

    EnumDecodeHWID()

**************************************************************************************/
BOOL 
ConvertUnicodeOIDToAnsi(
    LPSTR szUnicodeOID, 
    LPSTR szAnsiOID, 
    DWORD cbAnsiOid
    )
/*++
++*/
{
    memset(szAnsiOID, 0, cbAnsiOid);
    if(HIWORD(szUnicodeOID) == 0)
    {
        return WideCharToMultiByte(GetACP(), 
                                  0, 
                                  (WCHAR *)szUnicodeOID, 
                                  -1, 
                                  szAnsiOID, 
                                  cbAnsiOid, 
                                  NULL, 
                                  NULL) == 0;
    }

    strncpy(
            szAnsiOID, 
            szUnicodeOID, 
            min(cbAnsiOid, strlen(szUnicodeOID))
        );
    return TRUE;
}

/*************************************************************************************

    EnumDecodeHWID()

*************************************************************************************/
BOOL 
EnumDecodeHWID(
    IN PCERT_RDN_ATTR pCertRdnAttr, 
    IN HANDLE dwParm
    )
/*++
++*/
{
    PCertNameInfoEnumStruct20 pEnumParm = (PCertNameInfoEnumStruct20)dwParm;
    BOOL bszOIDHwid=TRUE;
    DWORD status=LICENSE_STATUS_OK;
    int cmpResult;
    CHAR ansiOID[4096]; // hardcoded for now.

    if(!ConvertUnicodeOIDToAnsi(pCertRdnAttr->pszObjId, ansiOID, sizeof(ansiOID)/sizeof(ansiOID[0])))
        return FALSE;

    bszOIDHwid = (strcmp(ansiOID, szOID_COMMON_NAME) == 0);

    if(bszOIDHwid)
    {
        pEnumParm->pLicensedProduct->LicensedProduct.pbEncryptedHwid = (PBYTE)AllocMemory(pCertRdnAttr->Value.cbData);
        if(!pEnumParm->pLicensedProduct->LicensedProduct.pbEncryptedHwid)
        {
            status = LICENSE_STATUS_OUT_OF_MEMORY;
        }
        else
        {
            memcpy(pEnumParm->pLicensedProduct->LicensedProduct.pbEncryptedHwid,
                   pCertRdnAttr->Value.pbData,
                   pCertRdnAttr->Value.cbData);
    
            pEnumParm->pLicensedProduct->LicensedProduct.cbEncryptedHwid=pCertRdnAttr->Value.cbData;
        }

        if(pEnumParm->pbSecretKey)
        {
            status = LSDecodeClientHWID(pCertRdnAttr->Value.pbData, 
                                        pCertRdnAttr->Value.cbData/sizeof(TCHAR),
                                        pEnumParm->pbSecretKey,
                                        pEnumParm->cbSecretKey,
                                        &pEnumParm->pLicensedProduct->Hwid);
        }
    }

    // continue if this is not our subject field.
    return (status != LICENSE_STATUS_OK || !bszOIDHwid);
}
/*************************************************************************************

    EnumIssuerLicense20()

**************************************************************************************/
BOOL
EnumIssuerLicense20(
    IN PCERT_RDN_ATTR pCertRdnAttr, 
    IN HANDLE dwParm
    )
/*++
++*/
{
    PCertNameInfoEnumStruct20 pEnumParm=(PCertNameInfoEnumStruct20)dwParm;
    CHAR ansiOID[4096];
    DWORD status=LICENSE_STATUS_OK;

    if(!ConvertUnicodeOIDToAnsi(pCertRdnAttr->pszObjId, ansiOID, sizeof(ansiOID)/sizeof(ansiOID[0])))
    {
        status=GetLastError();
    }
    else
    {
        if(strcmp(ansiOID, OID_ISSUER_LICENSE_SERVER_NAME) == 0)
        {
            pEnumParm->pLicensedProduct->szIssuer = (LPTSTR)AllocMemory( pCertRdnAttr->Value.cbData + sizeof(TCHAR) );
            if(!pEnumParm->pLicensedProduct->szIssuer)
            {
                status = LICENSE_STATUS_OUT_OF_MEMORY;
            }
            else
            {
                memcpy(
                    pEnumParm->pLicensedProduct->szIssuer, 
                    pCertRdnAttr->Value.pbData,
                    pCertRdnAttr->Value.cbData
                );
            }
        }
        else if(strcmp(ansiOID, OID_ISSUER_LICENSE_SERVER_SCOPE) == 0)
        {
            pEnumParm->pLicensedProduct->szIssuerScope = (LPTSTR)AllocMemory( pCertRdnAttr->Value.cbData + sizeof(TCHAR) );
            if(!pEnumParm->pLicensedProduct->szIssuerScope)
            {
                status = LICENSE_STATUS_OUT_OF_MEMORY;
            }
            else
            {
                memcpy(
                        pEnumParm->pLicensedProduct->szIssuerScope, 
                        pCertRdnAttr->Value.pbData,
                        pCertRdnAttr->Value.cbData
                    );
            }
        }
    }

    return status != LICENSE_STATUS_OK;
}
/*************************************************************************************

    EnumSubjectLicense20()

**************************************************************************************/
BOOL
EnumSubjectLicense20(
    IN PCERT_RDN_ATTR pCertRdnAttr, 
    IN HANDLE dwParm
    )
/*++
++*/
{
    PCertNameInfoEnumStruct20 pEnumParm=(PCertNameInfoEnumStruct20)dwParm;
    CHAR ansiOID[4096];
    DWORD status=LICENSE_STATUS_OK;

    if(!ConvertUnicodeOIDToAnsi(pCertRdnAttr->pszObjId, ansiOID, sizeof(ansiOID)/sizeof(ansiOID[0])))
    {
       status=GetLastError();
    }
    else
    {
        DWORD cbData=pCertRdnAttr->Value.cbData;
        PBYTE pbData=pCertRdnAttr->Value.pbData;

        if(strcmp(ansiOID, OID_SUBJECT_CLIENT_COMPUTERNAME) == 0)
        {
            pEnumParm->pLicensedProduct->szLicensedClient=(LPTSTR)AllocMemory(cbData + sizeof(TCHAR));
            if(!pEnumParm->pLicensedProduct->szLicensedClient)
            {
                status = LICENSE_STATUS_OUT_OF_MEMORY;
            }
            else
            {
                memcpy(
                        pEnumParm->pLicensedProduct->szLicensedClient, 
                        pbData,
                        cbData
                    );
            }
        }
        else if(strcmp(ansiOID, OID_SUBJECT_CLIENT_USERNAME) == 0)
        {
            pEnumParm->pLicensedProduct->szLicensedUser=(LPTSTR)AllocMemory(cbData + sizeof(TCHAR));
            if(!pEnumParm->pLicensedProduct->szLicensedUser)
            {
                status = LICENSE_STATUS_OUT_OF_MEMORY;
            }
            else
            {
                memcpy(
                        pEnumParm->pLicensedProduct->szLicensedUser, 
                        pbData,
                        cbData
                    );
            }
        }
        else if(strcmp(ansiOID, OID_SUBJECT_CLIENT_HWID) == 0)
        {
            pEnumParm->pLicensedProduct->LicensedProduct.cbEncryptedHwid = 0;
            LSBase64Decode(
                    CAST_PBYTE pCertRdnAttr->Value.pbData, 
                    pCertRdnAttr->Value.cbData / sizeof(TCHAR), 
                    NULL, 
                    &(pEnumParm->pLicensedProduct->LicensedProduct.cbEncryptedHwid)
                );

            pEnumParm->pLicensedProduct->LicensedProduct.pbEncryptedHwid = (PBYTE)AllocMemory(
                                                                                    pEnumParm->pLicensedProduct->LicensedProduct.cbEncryptedHwid
                                                                                );
            if(!pEnumParm->pLicensedProduct->LicensedProduct.pbEncryptedHwid)
            {
                status = LICENSE_STATUS_OUT_OF_MEMORY;
                return status;
            }

            status = LSBase64Decode(
                            CAST_PBYTE pCertRdnAttr->Value.pbData, 
                            pCertRdnAttr->Value.cbData / sizeof(TCHAR), 
                            pEnumParm->pLicensedProduct->LicensedProduct.pbEncryptedHwid, 
                            &(pEnumParm->pLicensedProduct->LicensedProduct.cbEncryptedHwid)
                        );

            if(status != LICENSE_STATUS_OK)
            {
                return status;
            }

            if(pEnumParm->pbSecretKey)
            {
                status = LSDecodeClientHWID(
                                    pCertRdnAttr->Value.pbData, 
                                    pCertRdnAttr->Value.cbData / sizeof(TCHAR),
                                    pEnumParm->pbSecretKey,
                                    pEnumParm->cbSecretKey,
                                    &pEnumParm->pLicensedProduct->Hwid
                                );
            }
        }
    }

    return status != LICENSE_STATUS_OK;
}
/***************************************************************************************
Function:
    LSEnumerateCertNameInfo()

Description:
    Routine to enumerate all CERT_RDN_VALUE values in CERT_NAME_BLOB and pass it
    to callback function specified in parameter

Arguments:
    IN cbData - Count of bytes in the buffer pointed by pbData
    IN pbData - Pointer to a block of data
    IN EnumerateCertNameInfoCallBack - Enumeration call back routine, it is defined as

        typedef BOOL (*EnumerateCertNameInfoCallBack)(PCERT_RDN_ATTR pCertRdnAttr, 
                                                      DWORD dwUserData);
    IN dwUserData - See EnumerateCertNameInfoCallBack

Return:
    LICENSE_STATUS_OK
    WIN32 error codes           from CryptDecodeObject()
    HLS_E_INTERNAL
    Any error set by callback.
***************************************************************************************/
DWORD
LSEnumerateCertNameInfo(
    IN LPBYTE pbData, 
    IN DWORD cbData,
    IN EnumerateCertNameInfoCallBack func, 
    IN HANDLE dwUserData
    )
/*++

++*/
{
    BOOL bCryptSuccess=TRUE;
    BOOL bCallbackCancel=FALSE;
    DWORD status = LICENSE_STATUS_OK;
    CERT_NAME_INFO CertNameBlob;

    SetLastError(LICENSE_STATUS_OK);

    __try {
        memset(&CertNameBlob, 0, sizeof(CertNameBlob));
        do {
            bCryptSuccess=CryptDecodeObject( 
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    X509_NAME,
                                    pbData,
                                    cbData,
                                    0,
                                    NULL, 
                                    &CertNameBlob.cRDN
                                );
            if(!bCryptSuccess)
            {
                status = LICENSE_STATUS_CANNOT_DECODE_LICENSE;
                break;
            }
                      
            CertNameBlob.rgRDN=(PCERT_RDN)AllocMemory(CertNameBlob.cRDN);
            if(!CertNameBlob.rgRDN)
            {
                SetLastError(status=LICENSE_STATUS_OUT_OF_MEMORY);
                break;
            }

            bCryptSuccess=CryptDecodeObject( 
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    X509_NAME,
                                    pbData,
                                    cbData,
                                    CRYPT_DECODE_NOCOPY_FLAG,
                                    (LPBYTE)CertNameBlob.rgRDN, 
                                    &CertNameBlob.cRDN
                                );

            if(!bCryptSuccess)
            {
                status = LICENSE_STATUS_CANNOT_DECODE_LICENSE;
                break;
            }

            PCERT_RDN pCertRdn=CertNameBlob.rgRDN;
            int num_rdn=pCertRdn->cRDNAttr;
            pCertRdn++;

            for(int i=0; i < num_rdn && !bCallbackCancel; i++, pCertRdn++)
            {
                int num_attr=pCertRdn->cRDNAttr;
                PCERT_RDN_ATTR pCertRdnAttr=pCertRdn->rgRDNAttr;
                
                for(int j=0; j < num_attr && !bCallbackCancel; j++, pCertRdnAttr++)
                {
                    bCallbackCancel=(func)(pCertRdnAttr, dwUserData);
                }
            }
        } while(FALSE);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(LICENSE_STATUS_UNSPECIFIED_ERROR);
    }

    FreeMemory(CertNameBlob.rgRDN);
    return GetLastError();
}

/*****************************************************************************

    DecodeLicense20()

*****************************************************************************/
DWORD
DecodeGetIssuerDnsName(
    PBYTE pbData, 
    DWORD cbData, 
    LPTSTR* pszIssuerDnsName
    )
/*++
++*/
{
    DWORD dwStatus=LICENSE_STATUS_OK;
    PLSCERT_AUTHORITY_INFO_ACCESS pbAccessInfo=NULL;
    DWORD cbAccessInfo=0;

    *pszIssuerDnsName=NULL;
    dwStatus=LSCryptDecodeObject(  
                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            szOID_X509_AUTHORITY_ACCESS_INFO,
                            pbData,
                            cbData,
                            CRYPT_DECODE_NOCOPY_FLAG, 
                            (PVOID *)&pbAccessInfo,
                            &cbAccessInfo
                        );

    if(dwStatus != ERROR_SUCCESS)
        return dwStatus;

    for(DWORD i=0; i < pbAccessInfo->cAccDescr; i++)
    {
        // we only use these for our license
        if(strcmp(pbAccessInfo[i].rgAccDescr->pszAccessMethod, szOID_X509_ACCESS_PKIX_OCSP) == 0)
        {
            // our extension has only dns name entry...
            if(pbAccessInfo[i].rgAccDescr->AccessLocation.dwAltNameChoice == LSCERT_ALT_NAME_DNS_NAME)
            {
                *pszIssuerDnsName = (LPTSTR)AllocMemory(
                                                    (wcslen(pbAccessInfo[i].rgAccDescr->AccessLocation.pwszDNSName)+1) * sizeof(TCHAR)
                                                );
                if(*pszIssuerDnsName == NULL)
                {
                    dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
                }
                else
                {
                    wcscpy(*pszIssuerDnsName, pbAccessInfo[i].rgAccDescr->AccessLocation.pwszDNSName);
                }

                break;
            }
            else if(pbAccessInfo[i].rgAccDescr->AccessLocation.dwAltNameChoice == CERT_ALT_NAME_DIRECTORY_NAME)
            {
                *pszIssuerDnsName = (LPTSTR)AllocMemory(
                                                    pbAccessInfo[i].rgAccDescr->AccessLocation.DirectoryName.cbData + sizeof(TCHAR)
                                                );
                if(*pszIssuerDnsName == NULL)
                {
                    dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
                }
                else
                {
                    memcpy(
                            *pszIssuerDnsName, 
                            pbAccessInfo[i].rgAccDescr->AccessLocation.DirectoryName.pbData,
                            pbAccessInfo[i].rgAccDescr->AccessLocation.DirectoryName.cbData
                        );
                }
                break;
            }
        }
    }

    // always return success.
    FreeMemory(pbAccessInfo);
    return dwStatus;
}


/*****************************************************************************

    DecodeLicense20()

*****************************************************************************/
DWORD
GetClientLicenseVersion( 
    PCERT_EXTENSION pCertExtension, 
    DWORD dwNumExtension 
    )
/*++
++*/
{
    DWORD dwVersion = TERMSERV_CERT_VERSION_UNKNOWN;

    for(DWORD i=0; i < dwNumExtension; i++, pCertExtension++)
    {
        if(strcmp(pCertExtension->pszObjId, szOID_PKIX_HYDRA_CERT_VERSION) == 0)
        {
            if(pCertExtension->Value.cbData == sizeof(DWORD) && 
               *(DWORD UNALIGNED *)pCertExtension->Value.pbData <= TERMSERV_CERT_VERSION_CURRENT)
            {
                //
                // we don't support version 0x00020001, it never release
                //
                dwVersion = *(DWORD UNALIGNED *)pCertExtension->Value.pbData;
                break;
            }
        }
    }

    return dwVersion;
}

/*****************************************************************************

    DecodeLicense20()

*****************************************************************************/
LICENSE_STATUS
DecodeLicense20(
    IN PCERT_INFO     pCertInfo,                       
    IN PBYTE          pbSecretKey,
    IN DWORD          cbSecretKey,
    IN OUT PLICENSEDPRODUCT pLicensedInfo
    )
/*++

++*/
{
    LICENSE_STATUS dwStatus=LICENSE_STATUS_OK;
    PBYTE   pbCompanyName=NULL;
    DWORD   cbCompanyName=0;

    DWORD   dwCertVersion=0;

    LICENSED_PRODUCT_INFO* pLicensedProductInfo=NULL;
    DWORD   cbLicensedProductInfo=0;

    PBYTE   pbPolicyData=NULL;
    DWORD   cbPolicyData = 0;

    CertNameInfoEnumStruct20  enumStruct;
    ULARGE_INTEGER* pulSerialNumber;
    DWORD i;

    PCERT_EXTENSION pCertExtension=pCertInfo->rgExtension;


    dwCertVersion = GetClientLicenseVersion(
                                        pCertExtension, 
                                        pCertInfo->cExtension
                                    );

    if(dwCertVersion == TERMSERV_CERT_VERSION_UNKNOWN)
    {
        dwStatus = LICENSE_STATUS_INVALID_LICENSE;
        goto cleanup;
    }

    if(dwCertVersion == 0x00020001)
    {   
        dwStatus = LICENSE_STATUS_UNSUPPORTED_VERSION;
        goto cleanup;
    }

    for(i=0; i < pCertInfo->cExtension && dwStatus == LICENSE_STATUS_OK; i++, pCertExtension++)
    {
        if(strcmp(pCertExtension->pszObjId, szOID_PKIS_PRODUCT_SPECIFIC_OID) == 0)  
        {
            //
            // product specific extension 
            //
            pbPolicyData = pCertExtension->Value.pbData;
            cbPolicyData = pCertExtension->Value.cbData;
        }                
        else if(strcmp(pCertExtension->pszObjId, szOID_PKIX_MANUFACTURER) == 0)
        {
            //
            // manufacturer of product
            //
            pbCompanyName = pCertExtension->Value.pbData;
            cbCompanyName = pCertExtension->Value.cbData;
        }
        else if(strcmp(pCertExtension->pszObjId, szOID_PKIX_LICENSED_PRODUCT_INFO) == 0)
        {
            //
            // Licensed product info
            //
            pLicensedProductInfo = (LICENSED_PRODUCT_INFO*) pCertExtension->Value.pbData;
            cbLicensedProductInfo = pCertExtension->Value.cbData;
        }
        else if(strcmp(pCertExtension->pszObjId, szOID_X509_AUTHORITY_ACCESS_INFO) == 0)
        {
            //
            // License Server access info,
            //
            dwStatus = DecodeGetIssuerDnsName(
                                    pCertExtension->Value.pbData,
                                    pCertExtension->Value.cbData,
                                    &pLicensedInfo->szIssuerDnsName
                                );

        }
        else if(strcmp(pCertExtension->pszObjId, szOID_PKIX_MS_LICENSE_SERVER_INFO) == 0)
        {
            //
            // HYDRA_CERT_VERSION_CURRENT use extension to store license server name
            //
            // extract license server info from this extension
            //

            dwStatus = LSExtensionToMsLicenseServerInfo(
                                pCertExtension->Value.pbData,
                                pCertExtension->Value.cbData,
                                &pLicensedInfo->szIssuer,
                                &pLicensedInfo->szIssuerId,
                                &pLicensedInfo->szIssuerScope
                            );
        }
    }

    if(dwStatus != LICENSE_STATUS_OK)
    {
        //
        // invalid license
        //
        goto cleanup;
    }

    if(pCertInfo->SerialNumber.cbData > sizeof(ULARGE_INTEGER))
    {
        //
        // Our serial number if 64 bits
        //
        dwStatus = LICENSE_STATUS_NOT_HYDRA;
        goto cleanup;
    }

    if(pbCompanyName == NULL || pLicensedProductInfo == NULL)
    {
        //
        // not hydra certificate
        //
        dwStatus = LICENSE_STATUS_NOT_HYDRA;
        goto cleanup;
    }

    //
    // Serial Number - Decoded as a multiple byte integer. 
    // SerialNumber.pbData[0] is the least significant byte. 
    // SerialNumber.pbData[SerialNumber.cbData - 1] is the most significant byte.)
    //
    pulSerialNumber = &(pLicensedInfo->ulSerialNumber);
    memset(pulSerialNumber, 0, sizeof(ULARGE_INTEGER));
    for(i=0; i < pCertInfo->SerialNumber.cbData; i++)
    {
        ((PBYTE)pulSerialNumber)[i] = pCertInfo->SerialNumber.pbData[i];
    }

    //
    // Extract validity of certificate
    //
    pLicensedInfo->NotBefore = pCertInfo->NotBefore;
    pLicensedInfo->NotAfter = pCertInfo->NotAfter;


    //
    // Extract info from certificate.
    //
    enumStruct.pLicensedProduct=pLicensedInfo;

    enumStruct.pbSecretKey = pbSecretKey;
    enumStruct.cbSecretKey = cbSecretKey;

    pLicensedInfo->dwLicenseVersion = dwCertVersion;
    pLicensedInfo->LicensedProduct.pProductInfo=(PProduct_Info)AllocMemory(sizeof(Product_Info));
    if(pLicensedInfo->LicensedProduct.pProductInfo == NULL)
    {
        dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
        goto cleanup;
    }

    if(pbPolicyData != NULL)
    {
        //
        //  Policy Module specific data
        //
        pLicensedInfo->pbPolicyData = (PBYTE)AllocMemory(cbPolicyData);
        if(pLicensedInfo->pbPolicyData == NULL)
        {
            dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
            goto cleanup;
        }

        memcpy(pLicensedInfo->pbPolicyData, pbPolicyData, cbPolicyData);
        pLicensedInfo->cbPolicyData = cbPolicyData;
    }

    if(dwCertVersion == TERMSERV_CERT_VERSION_RC1)
    {
        //
        // HYDRA 4.0 RC1 - license server is stored in certificate's Issuer field
        //
        dwStatus=LSEnumerateCertNameInfo(
                                pCertInfo->Issuer.pbData, 
                                pCertInfo->Issuer.cbData,
                                EnumIssuerLicense20,
                                &enumStruct
                            );
        if(dwStatus != LICENSE_STATUS_OK)
        {
            goto cleanup;
        }
    }

    dwStatus=LSEnumerateCertNameInfo(
                            pCertInfo->Subject.pbData, 
                            pCertInfo->Subject.cbData,
                            EnumSubjectLicense20,
                            &enumStruct
                        );

    if(dwStatus != LICENSE_STATUS_OK)
    {
        goto cleanup;
    }

    pLicensedInfo->LicensedProduct.pProductInfo->cbCompanyName = cbCompanyName;
    pLicensedInfo->LicensedProduct.pProductInfo->pbCompanyName = (PBYTE)AllocMemory(cbCompanyName+sizeof(TCHAR));
    if(!pLicensedInfo->LicensedProduct.pProductInfo->pbCompanyName)
    {
        dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
        goto cleanup;
    }

    memcpy(
            pLicensedInfo->LicensedProduct.pProductInfo->pbCompanyName, 
            pbCompanyName, 
            cbCompanyName
        );

    dwStatus=LSExtensionToMsLicensedProductInfo(
                                (PBYTE)pLicensedProductInfo,
                                cbLicensedProductInfo,
                                &pLicensedInfo->dwQuantity,
                                &pLicensedInfo->LicensedProduct.dwPlatformID,
                                &pLicensedInfo->LicensedProduct.dwLanguageID, 
                                &pLicensedInfo->pbOrgProductID,
                                &pLicensedInfo->cbOrgProductID,
                                &pLicensedInfo->LicensedProduct.pProductInfo->pbProductID,  
                                &pLicensedInfo->LicensedProduct.pProductInfo->cbProductID,
                                &pLicensedInfo->pLicensedVersion,
                                &pLicensedInfo->dwNumLicensedVersion
                            );
    if(dwStatus != LICENSE_STATUS_OK)
    {
        goto cleanup;
    }

    pLicensedInfo->LicensedProduct.pProductInfo->dwVersion = MAKELONG(
                                                                    pLicensedInfo->pLicensedVersion[0].wMinorVersion, 
                                                                    pLicensedInfo->pLicensedVersion[0].wMajorVersion
                                                                );

    //
    // assign product version to PLICENSEREQUEST
    // backward ??? didn't bail out at 0.
    //
    for(i=1; i < pLicensedInfo->dwNumLicensedVersion; i++)
    {
        if(!(pLicensedInfo->pLicensedVersion[i].dwFlags & LICENSED_VERSION_TEMPORARY))
        {
            pLicensedInfo->LicensedProduct.pProductInfo->dwVersion = MAKELONG(
                                                                            pLicensedInfo->pLicensedVersion[i].wMinorVersion, 
                                                                            pLicensedInfo->pLicensedVersion[i].wMajorVersion
                                                                        );
        }
    }

    if(pLicensedInfo->szIssuerDnsName == NULL && pLicensedInfo->szIssuer)
    {
        pLicensedInfo->szIssuerDnsName = (LPTSTR)AllocMemory((wcslen(pLicensedInfo->szIssuer)+1) * sizeof(TCHAR));
        if(pLicensedInfo->szIssuerDnsName == NULL)
        {
            dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
        }
        else
        {
            wcscpy(pLicensedInfo->szIssuerDnsName, pLicensedInfo->szIssuer);
        }
    }

cleanup:    

    return dwStatus;
}

//------------------------------------------------------
DWORD
IsW2kLicenseIssuerNonEnforce(
    IN HCRYPTPROV hCryptProv,
    IN PCCERT_CONTEXT pCert, 
    IN HCERTSTORE hCertStore,
    OUT PBOOL pbStatus
    )
/*++

Abstract:

    Verify client license is issued by a non-enforce 
    license server

Parameters:

    hCryptProv - Crypo Provider.
    pCert - Certificate to be verify
    hCertStore - Certificate store that contains issuer's certificate

Returns:

    LICENSE_STATUS_OK or error code.

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwFlags;
    DWORD i;
    PCCERT_CONTEXT  pCertIssuer=NULL;

    //
    // There can only be one license server certificate.
    //
    dwFlags = CERT_STORE_SIGNATURE_FLAG;
    pCertIssuer = CertGetIssuerCertificateFromStore(
                                            hCertStore,
                                            pCert,
                                            NULL,
                                            &dwFlags
                                        );
    if(pCertIssuer == NULL)
    {
        dwStatus = LICENSE_STATUS_NO_CERTIFICATE;
        goto cleanup;
    }

    //
    // A CH registered license server has szOID_PKIX_HYDRA_CERT_ROOT extension
    // A telephone registered license server has szOID_PKIS_TLSERVER_SPK_OID extension
    //
    for(i=0; i < pCertIssuer->pCertInfo->cExtension; i++)
    {
        if(strcmp(pCertIssuer->pCertInfo->rgExtension[i].pszObjId, szOID_PKIX_HYDRA_CERT_ROOT) == 0 ||
           strcmp(pCertIssuer->pCertInfo->rgExtension[i].pszObjId, szOID_PKIS_TLSERVER_SPK_OID) == 0 )
        {
            break;
        }
    }

    *pbStatus = (i >= pCertIssuer->pCertInfo->cExtension) ? TRUE : FALSE;

    if(pCertIssuer != NULL)
    {
        CertFreeCertificateContext(pCertIssuer);
    }

cleanup:

    return dwStatus;
}


//------------------------------------------------------
LICENSE_STATUS
LSVerifyTlsCertificate(
    IN HCRYPTPROV hCryptProv,
    IN PCCERT_CONTEXT pCert, 
    IN HCERTSTORE hCertStore
    )
/*++

Abstract:

    Given a certifcate and certificate store, this routine
    verify that certificate chain up to root certificate.

Parameters:

    hCryptProv - Crypo Provider.
    pCert - Certificate to be verify
    hCertStore - Certificate store that contains issuer's certificate

Returns:

++*/
{
    PCCERT_CONTEXT  pCertContext = pCert;
    PCCERT_CONTEXT  pCertIssuer=NULL, pCertIssuerNew;
    DWORD           dwStatus=ERROR_SUCCESS;
    DWORD           dwLastVerification=0;

    pCertContext = CertDuplicateCertificateContext(pCert);
    if(pCertContext == NULL)
    {
        dwStatus = GetLastError();
    }

    while(pCertContext != NULL)
    {
        //
        // Verify against all issuer's certificate
        //
        DWORD dwFlags;
        BOOL  bVerify=FALSE;

        dwStatus=ERROR_SUCCESS;
        dwLastVerification=0;
        pCertIssuer=NULL;

        do {
            dwFlags = CERT_STORE_SIGNATURE_FLAG; // | CERT_STORE_TIME_VALIDITY_FLAG;

            pCertIssuerNew = CertGetIssuerCertificateFromStore(
                                                    hCertStore,
                                                    pCertContext,
                                                    pCertIssuer,
                                                    &dwFlags
                                                );

            if (NULL != pCertIssuer)
            {
                CertFreeCertificateContext(pCertIssuer);
            }

            // pass pCertIssuer back to CertGetIssuerCertificateFromStore() 
            // to prevent infinite loop.
            pCertIssuer = pCertIssuerNew;

            if(pCertIssuer == NULL)
            {
                dwStatus = GetLastError();
                break;
            }
            
            dwLastVerification=dwFlags;
            bVerify = (dwFlags == 0);

        } while(!bVerify);

        // 
        // Check against error return from CertGetIssuerCertificateFromStore()
        //
        if(dwStatus != ERROR_SUCCESS || dwLastVerification)
        {
            if(dwStatus == CRYPT_E_SELF_SIGNED)
            {
                // self-signed certificate
                if( CryptVerifyCertificateSignature(
                                            hCryptProv, 
                                            X509_ASN_ENCODING, 
                                            pCertContext->pbCertEncoded, 
                                            pCertContext->cbCertEncoded,
                                            &pCertContext->pCertInfo->SubjectPublicKeyInfo
                                        ) )
                {
                    dwStatus=ERROR_SUCCESS;
                }
            }
            else if(dwStatus == CRYPT_E_NOT_FOUND)
            {
                // can't find issuer's certificate
                dwStatus = LICENSE_STATUS_CANNOT_FIND_ISSUER_CERT;
            }
            else if(dwLastVerification & CERT_STORE_SIGNATURE_FLAG)
            {
                dwStatus=LICENSE_STATUS_INVALID_LICENSE;
            }
            else if(dwLastVerification & CERT_STORE_TIME_VALIDITY_FLAG)
            {
                dwStatus=LICENSE_STATUS_EXPIRED_LICENSE;
            }
            else
            {
                dwStatus=LICENSE_STATUS_UNSPECIFIED_ERROR;
            }

            break;
        }

        //
        // free cert. context ourself instead of relying on Crypto.
        if(pCertContext != NULL)
        {
            CertFreeCertificateContext(pCertContext);
        }

        pCertContext = pCertIssuer;

    } // while(pCertContext != NULL)

    if(pCertContext != NULL)
    {
        CertFreeCertificateContext(pCertContext);
    }

    return dwStatus;
}


//----------------------------------------------------------

LICENSE_STATUS
LSVerifyDecodeClientLicense(
    IN PBYTE                pbLicense,
    IN DWORD                cbLicense,
    IN PBYTE                pbSecretKey,
    IN DWORD                cbSecretKey,
    IN OUT PDWORD           pdwNumLicensedInfo,
    IN OUT PLICENSEDPRODUCT pLicensedInfo
    )
/*++


    Verify and decode client licenses.

++*/
{
    HCERTSTORE hCertStore=NULL;
    LICENSE_STATUS dwStatus=LICENSE_STATUS_OK;
    CRYPT_DATA_BLOB Serialized;
    PCCERT_CONTEXT pCertContext=NULL;
    PCCERT_CONTEXT pPrevCertContext=NULL;
    PCERT_INFO pCertInfo;
    DWORD dwCertVersion;

    DWORD dwLicensedInfoSize=*pdwNumLicensedInfo;
    *pdwNumLicensedInfo = 0;

    Serialized.pbData = pbLicense;
    Serialized.cbData = cbLicense;

    if(g_hCertUtilCryptProv == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    hCertStore = CertOpenStore(
                        szLICENSE_BLOB_SAVEAS_TYPE,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        g_hCertUtilCryptProv,
                        CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                        &Serialized
                    );

    if(!hCertStore)
    {
        dwStatus=GetLastError();
        goto cleanup;
    }

    while( TRUE )
    {
        //
        // Loop thru all certificates in blob
        //
        pCertContext = CertEnumCertificatesInStore(
                                    hCertStore, 
                                    pPrevCertContext
                                );
        if(pCertContext == NULL)
        {
            //
            // end certificate in store or error
            //
            if((dwStatus=GetLastError()) == CRYPT_E_NOT_FOUND)
            {
                SetLastError(dwStatus = ERROR_SUCCESS);
            }

            break;
        }

        //
        // Calculate number of license in this blob
        //
        dwCertVersion = GetClientLicenseVersion(
                                        pCertContext->pCertInfo->rgExtension, 
                                        pCertContext->pCertInfo->cExtension
                                    );

        if(dwCertVersion == 0x00020001)
        {   
            //
            // This is internal test version, never got release 
            //
            dwStatus = LICENSE_STATUS_UNSUPPORTED_VERSION;
            break;
        }
        else if(dwCertVersion != TERMSERV_CERT_VERSION_UNKNOWN)
        {
            //
            // This certificate is issued by license server,
            // verify certificate chain.
            //
            dwStatus = LSVerifyTlsCertificate(
                                        g_hCertUtilCryptProv,
                                        pCertContext,
                                        hCertStore
                                    );

            if(dwStatus != LICENSE_STATUS_OK)
            {
                break;
            }

            if(pLicensedInfo != NULL && *pdwNumLicensedInfo < dwLicensedInfoSize)
            {
                //
                // Decode certificate
                //
                dwStatus=DecodeLicense20(
                                    pCertContext->pCertInfo, 
                                    pbSecretKey,
                                    cbSecretKey,
                                    pLicensedInfo + *pdwNumLicensedInfo
                                );

                if(dwStatus != LICENSE_STATUS_OK)
                {
                    break;
                }
            
                if(dwCertVersion == 0x00050001)
                {
                    DWORD dwFlags = (pLicensedInfo + *pdwNumLicensedInfo)->pLicensedVersion->dwFlags;

                    //
                    // License Server 5.2 or older does not set its enforce/noenforce so we need
                    // to figure out from its own certificate.
                    //
                    if( GET_LICENSE_ISSUER_MAJORVERSION(dwFlags) <= 5 &&
                        GET_LICENSE_ISSUER_MINORVERSION(dwFlags) <= 2 )
                    {
                        if( !(dwFlags & LICENSED_VERSION_TEMPORARY) )
                        {
                            BOOL bNonEnforce = FALSE;

                            dwStatus = IsW2kLicenseIssuerNonEnforce(
                                                        g_hCertUtilCryptProv,
                                                        pCertContext,
                                                        hCertStore,
                                                        &bNonEnforce
                                                    );

                            if(dwStatus != LICENSE_STATUS_OK)
                            {
                                break;
                            }

                            if(bNonEnforce == FALSE)
                            {
                                (pLicensedInfo + *pdwNumLicensedInfo)->pLicensedVersion->dwFlags |= LICENSE_ISSUER_ENFORCE_TYPE;
                            }
                        }
                    }
                }
            }

            (*pdwNumLicensedInfo)++;
        }

        pPrevCertContext = pCertContext;
    }

cleanup:

    if(hCertStore)
    {
        // Force close on all cert.
        if(CertCloseStore(
                        hCertStore, 
                        CERT_CLOSE_STORE_FORCE_FLAG) == FALSE)
        {
            dwStatus = GetLastError();
        }
    }

    if(dwStatus != LICENSE_STATUS_OK)
    {
        //
        // dwNumLicensedInfo is a DWORD.
        //
        int count = (int) *pdwNumLicensedInfo;

        for(;count >= 0 && pLicensedInfo != NULL; count--)
        {
            LSFreeLicensedProduct(pLicensedInfo + count);
        }
    }
    else if(pLicensedInfo != NULL)
    {
        qsort(
            pLicensedInfo,
            *pdwNumLicensedInfo,
            sizeof(LICENSEDPRODUCT),
            SortLicensedProduct
        );
    }                

    if(*pdwNumLicensedInfo == 0 && dwStatus == LICENSE_STATUS_OK)
    {
        dwStatus = LICENSE_STATUS_NO_LICENSE_ERROR;
    }

    //
    // Force re-issue of client licenses.
    //
    return (dwStatus != LICENSE_STATUS_OK) ? LICENSE_STATUS_CANNOT_DECODE_LICENSE : dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\licecert\x509.cpp ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    x509.cpp

Abstract:

    This module implements the X509 certificate manipulation functions

Author:

    Doug Barlow (dbarlow) 9/29/1994

Environment:



Notes:



--*/

#include <windows.h>
#include "x509.h"


//
//==============================================================================
//
//  Attribute
//

Attribute::Attribute(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    attributeType(0),
    attributeValue(0)
{
    m_rgEntries.Add(&attributeType);
    m_rgEntries.Add(&attributeValue);
}

CAsnObject *
Attribute::Clone(
    DWORD dwFlags)
const
{
    return new Attribute(dwFlags);
}


//
//==============================================================================
//
//  Attributes
//

Attributes::Attributes(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSetOf(dwFlags, dwTag),
    m_asnEntry1(0)
{
    m_pasnTemplate = &m_asnEntry1;
}

CAsnObject *
Attributes::Clone(
    DWORD dwFlags)
const
{
    return new Attributes(dwFlags);
}


//
//==============================================================================
//
//  UniqueIdentifier
//

UniqueIdentifier::UniqueIdentifier(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    attributeType(0),
    attributeValue(0)
{
    m_rgEntries.Add(&attributeType);
    m_rgEntries.Add(&attributeValue);
}

CAsnObject *
UniqueIdentifier::Clone(
    DWORD dwFlags)
const
{
    return new UniqueIdentifier(dwFlags);
}


//
//==============================================================================
//
//  RelativeDistinguishedName
//

RelativeDistinguishedName::RelativeDistinguishedName(
    DWORD dwFlags,
    DWORD dwTag)
:   Attributes(dwFlags, dwTag)
{
}

CAsnObject *
RelativeDistinguishedName::Clone(
    DWORD dwFlags)
const
{
    return new RelativeDistinguishedName(dwFlags);
}


//
//==============================================================================
//
//  Name
//

Name::Name(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequenceOf(dwFlags, dwTag),
    m_asnEntry1(0)
{
    m_pasnTemplate = &m_asnEntry1;
}

CAsnObject *
Name::Clone(
    DWORD dwFlags)
const
{
    return new Name(dwFlags);
}


//
//==============================================================================
//
//  Validity
//

Validity::Validity(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    notBefore(0),
    notAfter(0)
{
    m_rgEntries.Add(&notBefore);
    m_rgEntries.Add(&notAfter);
}

CAsnObject *
Validity::Clone(
    DWORD dwFlags)
const
{
    return new Validity(dwFlags);
}


//
//==============================================================================
//
//  AlgorithmIdentifier
//

AlgorithmIdentifier::AlgorithmIdentifier(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    algorithm(0),
    parameters(fOptional)
{
    m_rgEntries.Add(&algorithm);
    m_rgEntries.Add(&parameters);
}

CAsnObject *
AlgorithmIdentifier::Clone(DWORD dwFlags)
const
{
    return new AlgorithmIdentifier(dwFlags);
}


//
//==============================================================================
//
//  SubjectPublicKeyInfo
//

SubjectPublicKeyInfo::SubjectPublicKeyInfo(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    algorithm(0),
    subjectPublicKey(0)
{
    m_rgEntries.Add(&algorithm);
    m_rgEntries.Add(&subjectPublicKey);
}

CAsnObject *
SubjectPublicKeyInfo::Clone(
    DWORD dwFlags)
const
{
    return new SubjectPublicKeyInfo(dwFlags);
}


//
//==============================================================================
//
//  Extension
//

Extension::Extension(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    extnid(0),
    critical(fOptional),    // DEFAULT FALSE
    extnValue(0)
{
    m_rgEntries.Add(&extnid);
//  critical.Write((LPBYTE)"\x00", 1);
//  critical.SetDefault();
    m_rgEntries.Add(&critical);
    m_rgEntries.Add(&extnValue);
}

CAsnObject *
Extension::Clone(
    DWORD dwFlags)
const
{
    return new Extension(dwFlags);
}


//
//==============================================================================
//
//  Extensions
//

Extensions::Extensions(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequenceOf(dwFlags, dwTag),
    m_asnEntry1(0)
{
    m_pasnTemplate = &m_asnEntry1;
}

CAsnObject *
Extensions::Clone(
    DWORD dwFlags)
const
{
    return new Extensions(dwFlags);
}


//
//==============================================================================
//
//  CertificateToBeSigned
//

CertificateToBeSigned::CertificateToBeSigned(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    _tag1(fOptional, TAG(0)),   // DEFAULT 0
    version(0),
    serialNumber(0),
    signature(0),
    issuer(0),
    validity(0),
    subject(0),
    subjectPublicKeyInfo(0),
    issuerUniqueID(fOptional, TAG(1)),
    subjectUniqueID(fOptional, TAG(2)),
    _tag2(fOptional, TAG(3)),
    extensions(0)
{
    _tag1.Reference(&version);
//  _tag1.Write((LPBYTE)"\x02\x01\x00", 3);
//  _tag1.SetDefault();
    m_rgEntries.Add(&_tag1);
    m_rgEntries.Add(&serialNumber);
    m_rgEntries.Add(&signature);
    m_rgEntries.Add(&issuer);
    m_rgEntries.Add(&validity);
    m_rgEntries.Add(&subject);
    m_rgEntries.Add(&subjectPublicKeyInfo);
    m_rgEntries.Add(&issuerUniqueID);
    m_rgEntries.Add(&subjectUniqueID);
    _tag2.Reference(&extensions);
    m_rgEntries.Add(&_tag2);
}

CAsnObject *
CertificateToBeSigned::Clone(
    DWORD dwFlags)
const
{
    return new CertificateToBeSigned(dwFlags);
}


//
//==============================================================================
//
//  Certificate
//

Certificate::Certificate(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    toBeSigned(0),
    algorithm(0),
    signature(0)
{
    m_rgEntries.Add(&toBeSigned);
    m_rgEntries.Add(&algorithm);
    m_rgEntries.Add(&signature);
}

CAsnObject *
Certificate::Clone(
    DWORD dwFlags)
const
{
    return new Certificate(dwFlags);
}


//
//==============================================================================
//
//  CRLEntry
//

CRLEntry::CRLEntry(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    userCertificate(0),
    revocationDate(0),
    crlEntryExtensions(fOptional)
{
    m_rgEntries.Add(&userCertificate);
    m_rgEntries.Add(&revocationDate);
    m_rgEntries.Add(&crlEntryExtensions);
}

CAsnObject *
CRLEntry::Clone(
    DWORD dwFlags)
const
{
    return new CRLEntry(dwFlags);
}


//
//==============================================================================
//
//  RevokedCertificates
//

RevokedCertificates::RevokedCertificates(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequenceOf(dwFlags, dwTag),
    m_asnEntry1(0)
{
    m_pasnTemplate = &m_asnEntry1;
}

CAsnObject *
RevokedCertificates::Clone(
    DWORD dwFlags)
const
{
    return new RevokedCertificates(dwFlags);
}


//
//==============================================================================
//
//  CertificateRevocationListToBeSigned
//

CertificateRevocationListToBeSigned::CertificateRevocationListToBeSigned(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    version(0),     // DEFAULT 0
    signature(0),
    issuer(0),
    lastUpdate(0),
    nextUpdate(fOptional),
    revokedCertificates(fOptional),
    _tag1(fOptional, TAG(0)),
    crlExtensions(0)
{
    m_rgEntries.Add(&version);
    m_rgEntries.Add(&signature);
    m_rgEntries.Add(&issuer);
    m_rgEntries.Add(&lastUpdate);
    m_rgEntries.Add(&nextUpdate);
    m_rgEntries.Add(&revokedCertificates);
    _tag1.Reference(&crlExtensions);
    m_rgEntries.Add(&_tag1);
}

CAsnObject *
CertificateRevocationListToBeSigned::Clone(
    DWORD dwFlags)
const
{
    return new CertificateRevocationListToBeSigned(dwFlags);
}


//
//==============================================================================
//
//  CertificateRevocationList
//

CertificateRevocationList::CertificateRevocationList(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    toBeSigned(0),
    algorithm(0),
    signature(0)
{
    m_rgEntries.Add(&toBeSigned);
    m_rgEntries.Add(&algorithm);
    m_rgEntries.Add(&signature);
}

CAsnObject *
CertificateRevocationList::Clone(
    DWORD dwFlags)
const
{
    return new CertificateRevocationList(dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\licecert\utility.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    utility

Abstract:

    This module contains a collection of interesting utility routines useful to
    more than one other module.

Author:

    Frederick Chong (fredch) 6/1/1998 - Adapted code from Doug Barlow's PKCS library
    

Notes:



--*/

#include <windows.h>
#include <string.h>
#include <stdlib.h>

#if !defined(OS_WINCE)
#include <basetsd.h>
#endif

#include "utility.h"
#include "pkcs_1.h"
#include "x509.h"
#include "pkcs_err.h"
#include "names.h"

#include "rsa.h"

static const char
    md2[] =                  "1.2.840.113549.2.2",
    md4[] =                  "1.2.840.113549.2.4",
    md5[] =                  "1.2.840.113549.2.5",
    sha[] =                  "1.3.14.3.2.18",
    rsaEncryption[] =        "1.2.840.113549.1.1.1",
    md2WithRSAEncryption[] = "1.2.840.113549.1.1.2",
    md4WithRSAEncryption[] = "1.2.840.113549.1.1.3",
    md5WithRSAEncryption[] = "1.2.840.113549.1.1.4",
    shaWithRSAEncryption[] = "1.3.14.3.2.15",
    sha1WithRSASign[] =      "1.3.14.3.2.29";

static const MapStruct
    mapAlgIds[]
        = { { ( LPCTSTR )md2,                  HASH_ALG_MD2 },
            { ( LPCTSTR )md4,                  HASH_ALG_MD4 },
            { ( LPCTSTR )md5,                  HASH_ALG_MD5 },
            { ( LPCTSTR )sha,                  HASH_ALG_SHA },
            { ( LPCTSTR )rsaEncryption,        SIGN_ALG_RSA },
            { ( LPCTSTR )md2WithRSAEncryption, SIGN_ALG_RSA | HASH_ALG_MD2 },
            { ( LPCTSTR )md4WithRSAEncryption, SIGN_ALG_RSA | HASH_ALG_MD4 },
            { ( LPCTSTR )md5WithRSAEncryption, SIGN_ALG_RSA | HASH_ALG_MD5 },
            { ( LPCTSTR )shaWithRSAEncryption, SIGN_ALG_RSA | HASH_ALG_SHA },
            { ( LPCTSTR )sha1WithRSASign,      SIGN_ALG_RSA | HASH_ALG_SHA1 },
            { ( LPCTSTR )NULL, 0 } };


/*++

DwordToPkcs:

    This routine converts an LPDWORD little endian integer to a big endian
    integer in place, suitable for use with ASN.1 or PKCS.  The sign of the
    number is maintained.

Arguments:

    dwrd - Supplies and receives the integer in the appropriate formats.
    lth - length of the supplied array, in bytes.

Return Value:

    The size of the resulting array, with trailing zeroes stripped.

Author:

    Doug Barlow (dbarlow) 7/27/1995

--*/

DWORD
DwordToPkcs(
    IN OUT LPBYTE dwrd,
    IN DWORD lth)
{
    LPBYTE pbBegin = dwrd;
    LPBYTE pbEnd = &dwrd[lth];
    while (0 == *(--pbEnd));   // Note semi-colon here!
    if ((0 == (dwrd[lth - 1] & 0x80)) && (0 != (*pbEnd & 0x80)))
        pbEnd += 1;

#if defined(OS_WINCE)
    size_t length = pbEnd - pbBegin + 1;
#else
    SIZE_T length = pbEnd - pbBegin + 1;
#endif

    while (pbBegin < pbEnd)
    {
        BYTE tmp = *pbBegin;
        *pbBegin++ = *pbEnd;
        *pbEnd-- = tmp;
    }
    return (DWORD)length;
}


/*++

PkcsToDword:

    This routine reverses the effects of DwordToPkcs, so that a big endian
    byte stream integer is converted to a little endian DWORD stream integer in
    place.

Arguments:

    pbPkcs - Supplies and receives the integer in the appropriate formats.
    lth - length of the supplied array, in bytes.

Return Value:

    The size of the resultant array in bytes, with trailing zeroes stripped.

Author:

    Doug Barlow (dbarlow) 7/27/1995

--*/

DWORD
PkcsToDword(
    IN OUT LPBYTE pbPkcs,
    IN DWORD lth)
{
    LPBYTE pbBegin = pbPkcs;
    LPBYTE pbEnd = &pbPkcs[lth - 1];
    DWORD length = lth;
    while (pbBegin < pbEnd)
    {
        BYTE tmp = *pbBegin;
        *pbBegin++ = *pbEnd;
        *pbEnd-- = tmp;
    }
    for (pbEnd = &pbPkcs[lth - 1]; 0 == *pbEnd; pbEnd -= 1)
        length -= 1;
    return length;
}


/*++

ASNlength:

    This routine returns the length, in bytes, of the following ASN.1
    construction in the supplied buffer.  This routine recurses if necessary to
    always produce a length, even if the following construction uses indefinite
    endcoding.

Arguments:

    asnBuf - Supplies the ASN.1 buffer to parse.
    pdwData - Receives the number of bytes prior to the value of the
        construction (i.e., the length in bytes of the Type and Length
        encodings).  If this is NULL, no value is returned.

Return Value:

    The length of the construction.  A DWORD status code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 7/27/1995

--*/

DWORD
ASNlength(
    IN const BYTE FAR *asnBuf,
    IN DWORD cbBuf,
    OUT LPDWORD pdwData)
{
    DWORD
        lth
            = 0,
        index
            = 0;


    //
    // Skip over the Type.
    //

    if (cbBuf < sizeof(BYTE))
    {
        ErrorThrow(PKCS_ASN_ERROR);
    }

    if (31 > (asnBuf[index] & 0x1f))
    {
        index += 1;
    }
    else
    {
        if (cbBuf < (index+2) * sizeof(BYTE))
        {
            ErrorThrow(PKCS_ASN_ERROR);
        }

        while (0 != (asnBuf[++index] & 0x80))
        {
            if (cbBuf < (index+2) * sizeof(BYTE))
            {
                ErrorThrow(PKCS_ASN_ERROR);
            }
        }
    }


    //
    // Extract the Length.
    //

    if (cbBuf < (index+1) * sizeof(BYTE))
    {
        ErrorThrow(PKCS_ASN_ERROR);
    }

    if (0 == (asnBuf[index] & 0x80))
    {

        //
        // Short form encoding.
        //

        lth = asnBuf[index++];
    }
    else
    {
        DWORD ll = asnBuf[index++] & 0x7f;

        if (0 != ll)
        {
            //
            // Long form encoding.
            //

            for (; 0 < ll; ll -= 1)
            {
                if (0 != (lth & 0xff000000))
                {
                    ErrorThrow(PKCS_ASN_ERROR);
                }
                else
                {
                    if (cbBuf < (index+1) * sizeof(BYTE))
                    {
                        ErrorThrow(PKCS_ASN_ERROR);
                    }

                    lth = (lth << 8) | asnBuf[index];
                }
                index += 1;
            }
        }
        else
        {

            //
            // Indefinite encoding.
            //

            DWORD offset;

            if (cbBuf < (index + 2) * sizeof(BYTE))
            {
                ErrorThrow(PKCS_ASN_ERROR);
            }

            while ((0 != asnBuf[index]) || (0 != asnBuf[index + 1]))
            {
                ll = ASNlength(&asnBuf[index], cbBuf - index, &offset);
                lth += ll;
                index += offset;

                if (cbBuf < (index + 2) * sizeof(BYTE))
                {
                    ErrorThrow(PKCS_ASN_ERROR);
                }
            }
            index += 2;
        }
    }

    //
    // Supply the caller with what we've learned.
    //

    if (NULL != pdwData)
        *pdwData = index;
    return lth;


ErrorExit:
    if (NULL != pdwData)
        *pdwData = 0;
    return 0;
}


/*++

PKInfoToBlob:

    This routine converts an ASN.1 PublicKeyInfo structure to a BSAFE Key
    Blob.

Arguments:

    asnPKInfo - Supplies the ASN.1 PublicKeyInfo structure.
    algType - Supplies the type of key (CALG_RSA_SIGN or CALG_RSA_KEYX)
    osBlob - Receves the Crypto API Key Blob.

Return Value:

    None.  A DWORD status code is thrown on errors.

Author:

    Frederick Chong (fredch) 6/1/1998

--*/

void
PKInfoToBlob(
    IN  SubjectPublicKeyInfo &asnPKInfo,
    OUT COctetString &osBlob)
{
    long int
        lth,
        origLth;
    LPCTSTR
        sz;
    COctetString
        osMiscString;
    CAsnNull
        asnNull;


    sz = (LPCTSTR)asnPKInfo.algorithm.algorithm;
    if (NULL == sz)
        ErrorThrow(PKCS_ASN_ERROR);     // Or memory out.
    asnPKInfo.algorithm.parameters = asnNull;


    //
    // Convert the key to a key blob.
    //

    if( ( 0 == strcmp( ( char * )sz, rsaEncryption ) ) ||
        ( 0 == strcmp( ( char * )sz, md5WithRSAEncryption ) ) ||
        ( 0 == strcmp( ( char * )sz, shaWithRSAEncryption ) ) )
    {

        //
        // It's an RSA public key & exponent structure.
        // Convert it to a Bsafe key structure
        //

        RSAPublicKey asnPubKey;
        LPBSAFE_PUB_KEY pBsafePubKey;

        LPBYTE modulus;
        int shift = 0;

        lth = asnPKInfo.subjectPublicKey.DataLength();
        if (0 > lth)
            ErrorThrow(PKCS_ASN_ERROR);
        osMiscString.Resize(lth);
        ErrorCheck;
        lth = asnPKInfo.subjectPublicKey.Read(
                osMiscString.Access(), &shift);
        if (0 > lth)
            ErrorThrow(PKCS_ASN_ERROR);
        if (0 > asnPubKey.Decode(osMiscString.Access(), osMiscString.Length()))
            ErrorThrow(PKCS_ASN_ERROR);
        lth = asnPubKey.modulus.DataLength();
        if (0 > lth)
            ErrorThrow(PKCS_ASN_ERROR);
        osMiscString.Resize(lth);
        ErrorCheck;
        lth = asnPubKey.modulus.Read(osMiscString.Access());
        if (0 > lth)
            ErrorThrow(PKCS_ASN_ERROR);

        // osBlob is fixed in place here.
        origLth = sizeof(BSAFE_PUB_KEY) + lth;
        osBlob.Resize(origLth);
        ErrorCheck;

        pBsafePubKey = ( LPBSAFE_PUB_KEY )osBlob.Access();
        modulus = (LPBYTE)osBlob.Access( sizeof( BSAFE_PUB_KEY ) );
        
        memcpy(modulus, osMiscString.Access(), osMiscString.Length());
        lth = PkcsToDword(modulus, osMiscString.Length());
        ErrorCheck;
        
        pBsafePubKey->magic = RSA1;
        pBsafePubKey->keylen = lth + sizeof( DWORD ) * 2; // meet PKCS #1 minimum padding size
        pBsafePubKey->bitlen = lth * 8;
        pBsafePubKey->datalen = lth - 1;
        pBsafePubKey->pubexp = asnPubKey.publicExponent;
        osBlob.Resize( sizeof( BSAFE_PUB_KEY ) + lth + sizeof( DWORD ) * 2 );
        ErrorCheck;
        
        //
        // zero out padding bytes
        //

        memset( osBlob.Access() + sizeof( BSAFE_PUB_KEY ) + lth, 0, sizeof( DWORD ) * 2 );

        ErrorCheck;
    }
    else
        ErrorThrow(PKCS_NO_SUPPORT);
    return;

ErrorExit:
    osBlob.Empty();
}


/*++

ObjIdToAlgId:

    This routine translates an Object Identifier to an Algorithm Identifier.

Arguments:

    asnAlgId - Supplies the AlgorithmIdentifier structure to be recognized.

Return Value:

    The Crypto API ALG_ID corresponding to the supplied AlgorithmIdentifier.  A
    DWORD status code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 7/31/1995

--*/

ALGORITHM_ID
ObjIdToAlgId(
    const AlgorithmIdentifier &asnAlgId)
{
    DWORD
        dwAlgId;
    LPCTSTR
        sz;


    //
    // Extract the Object Identifier string.
    //

    sz = asnAlgId.algorithm;
    if (NULL == sz)
        ErrorThrow(PKCS_ASN_ERROR);
    // Ignore parameters ?fornow?


    //
    // Check it against known identifiers.
    //

    if (!MapFromName(mapAlgIds, sz, &dwAlgId))
        ErrorThrow(PKCS_NO_SUPPORT);
    return (ALGORITHM_ID)dwAlgId;

ErrorExit:
    return 0;
}


/*++

FindSignedData:

    This routine examines a block of ASN.1 that has been created by the SIGNED
    macro, and extracts the offset and length of that data.

Arguments:

    pbSignedData - Supplies the ASN.1 Encoded signed data.
    pdwOffset - Receives the number of bytes from the beginning of the signed
        data that the actual data begins.
    pcbLength - Receives the length of the actual data.

Return Value:

    None.  A DWORD status code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 8/22/1995

--*/

void
FindSignedData(
    IN const BYTE FAR * pbSignedData,
    IN DWORD cbSignedData,
    OUT LPDWORD pdwOffset,
    OUT LPDWORD pcbLength)
{
    DWORD
        length,
        offset,
        inset;

    // Here we get the offset to the toBeSigned field.
    ASNlength(pbSignedData, cbSignedData, &offset);
    ErrorCheck;

    // Now find the length of the toBeSigned field.
    length = ASNlength(&pbSignedData[offset], cbSignedData - offset, &inset);
    ErrorCheck;
    length += inset;

    // Return our findings.
    *pdwOffset = offset;
    *pcbLength = length;
    return;

ErrorExit:
    return;
}


/*++

NameCompare:

    These routines compare various forms of Distinguished Names for Equality.

Arguments:

    szName1 supplies the first name as a string.
    asnName1 supplies the first name as an X.509 Name.
    szName2 supplies the second name as a string.
    asnName2 supplies the second name as an X.509 Name.

Return Value:

    TRUE - They are identical.
    FALSE - They are different.

Author:

    Doug Barlow (dbarlow) 9/12/1995

--*/

BOOL
NameCompare(
    IN LPCTSTR szName1,
    IN LPCTSTR szName2)
{
    int result;
    CDistinguishedName dnName1, dnName2;
    dnName1.Import(szName1);
    ErrorCheck;
    dnName2.Import(szName2);
    ErrorCheck;
    result = dnName1.Compare(dnName2);
    ErrorCheck;
    return (0 == result);

ErrorExit:
    return FALSE;
}

BOOL
NameCompare(
    IN const Name &asnName1,
    IN const Name &asnName2)
{
    int result;
    CDistinguishedName dnName1, dnName2;
    dnName1.Import(asnName1);
    ErrorCheck;
    dnName2.Import(asnName2);
    ErrorCheck;
    result = dnName1.Compare(dnName2);
    ErrorCheck;
    return (0 == result);

ErrorExit:
    return FALSE;
}

BOOL
NameCompare(
    IN LPCTSTR szName1,
    IN const Name &asnName2)
{
    int result;
    CDistinguishedName dnName1, dnName2;
    dnName1.Import(szName1);
    ErrorCheck;
    dnName2.Import(asnName2);
    ErrorCheck;
    result = dnName1.Compare(dnName2);
    ErrorCheck;
    return (0 == result);

ErrorExit:
    return FALSE;
}

BOOL
NameCompare(
    IN const Name &asnName1,
    IN LPCTSTR szName2)
{
    int result;
    CDistinguishedName dnName1, dnName2;
    dnName1.Import(asnName1);
    ErrorCheck;
    dnName2.Import(szName2);
    ErrorCheck;
    result = dnName1.Compare(dnName2);
    ErrorCheck;
    return (0 == result);

ErrorExit:
    return FALSE;
}

BOOL
NameCompare(
    IN const CDistinguishedName &dnName1,
    IN const Name &asnName2)
{
    int result;
    CDistinguishedName dnName2;
    dnName2.Import(asnName2);
    ErrorCheck;
    result = dnName1.Compare(dnName2);
    ErrorCheck;
    return (0 == result);

ErrorExit:
    return FALSE;
}


/*++

VerifySignedAsn:

    This method verifies a signature on a signed ASN.1 Structure.

Arguments:

    crt - Supplies the CCertificate object to use to validate the signature.
    pbAsnData - Supplies the buffer containing the signed ASN.1 structure.
    szDescription - Supplies a description incorporated into the signature, if
        any.

Return Value:

    None.  A DWORD status code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 7/31/1995

--*/

void
VerifySignedAsn(
    IN const CCertificate &crt,
    IN const BYTE FAR * pbAsnData,
    IN DWORD cbAsnData,
    IN LPCTSTR szDescription)    
{
    AlgorithmIdentifier
        asnAlgId;
    CAsnBitstring
        asnSignature;
    COctetString
        osSignature;
    const BYTE FAR *
        pbData;
    DWORD
        length,
        offset;
    long int
        lth;
    int
        shift = 0;
    ALGORITHM_ID
        algIdSignature;
    
    //
    // Extract the fields.
    //

    FindSignedData(pbAsnData, cbAsnData, &offset, &length);
    ErrorCheck;
    pbData = &pbAsnData[offset];
    cbAsnData -= offset;

    lth = asnAlgId.Decode(pbData + length, cbAsnData - length);
    if (0 > lth)
        ErrorThrow(PKCS_ASN_ERROR);
    lth = asnSignature.Decode(pbData + length + lth, cbAsnData - length - lth);
    if (0 > lth)
        ErrorThrow(PKCS_ASN_ERROR);

    if (0 > (lth = asnSignature.DataLength()))
        ErrorThrow(PKCS_ASN_ERROR);
    offset = 0;
    osSignature.Resize(lth);
    ErrorCheck;
    if (0 > asnSignature.Read(osSignature.Access(), &shift))
        ErrorThrow(PKCS_ASN_ERROR);
    lth = PkcsToDword(osSignature.Access(), lth);
    ErrorCheck;
    algIdSignature = ObjIdToAlgId(asnAlgId);
    ErrorCheck;
    crt.Verify(
        pbData,
        cbAsnData,
        length,
        algIdSignature,
        szDescription,
        osSignature.Access(),
        osSignature.Length());
    ErrorCheck;
    return;

ErrorExit:
    return;
}


/*++

MapFromName:

    This routine translates a string value to a corresponding 32-bit integer
    value based on the supplied translation table.

Arguments:

    pMap supplies the mapping table address.

    szKey supplies the string value to translate from.

    pdwResult receives the translation.


  Return Value:

    TRUE - Successful Translation.
    FALSE - Translation Failure.

Author:

    Doug Barlow (dbarlow) 2/14/1996

--*/

BOOL
MapFromName(
    IN const MapStruct *pMap,
    IN LPCTSTR szKey,
    OUT LPDWORD pdwResult)
{
    const MapStruct *pMatch = pMap;

    if (NULL == szKey)
        return FALSE;
    while (NULL != pMatch->szKey)
    {
        if (0 == strcmp( ( char * )pMatch->szKey, ( char * )szKey))
        {
            *pdwResult = pMatch->dwValue;
            return TRUE;
        }
        pMatch += 1;
    }
    return FALSE;
}


/*++

GetHashData:

    This routine gets the hash data from a PKCS #1 encryption block.

Arguments:

    osEncryptionBlock The PKCS #1 encryption block.
    osHashData The hashed data

Return Value:

    TRUE if the function is successful or FALSE otherwise.

Author:

    Frederick Chong (fredch) 5/29/1998

--*/


BOOL
GetHashData( 
    COctetString &osEncryptionBlock, 
    COctetString &osHashData )
{
    DWORD
        i, numPaddings = 0, Length;
    LPBYTE
        pbEncryptionBlock;
    DigestInfo
        asnDigest;

    //
    // according to PKCS #1, the decrypted block should be of the following form
    // EB = 0x00 || BT || PS || 0x00 || D where
    //
    // EB = Encryption Block, 
    // BT = Block Type and can be 0x00, 0x01 or 0x02, 
    // PS = Padding String and must be 0xFF when BT = 0x01, 
    // D = data to be encrypted
    // || = concatenation.
    //
    // Furthermore, For RSA decryption, it is an error if BT != 0x01
    //

    //
    // Search for decryption block type since the encryption block
    // passed in may start off with a bunch of zeroed padding bytes
    //

    Length = osEncryptionBlock.Length();
    pbEncryptionBlock = osEncryptionBlock.Access();
        
    for( i = 0; i < Length; i++ )
    {
        if( 0x01 == *( pbEncryptionBlock + i ) )
        {
            break;
        }
    }

    if( i == Length )
    {
        ErrorThrow( PKCS_ASN_ERROR );
    }

    //
    // now look for the padding string.  Expects all padding string to be
    // 0xFF when BT = 0x01
    //
    
    i++;
    while( i < Length )
    {
        if( 0xFF == *( pbEncryptionBlock + i ) )
        {
            //
            // count the number of padding bytes
            //

            numPaddings++;
        }
        else
        {
            break;
        }

        i++;
    }

    //
    // PKCS #1 requires at least 8 padding bytes
    //

    if( numPaddings < 8 )
    {
        ErrorThrow( PKCS_ASN_ERROR );
    }

    if( ++i >= Length )
    {
        ErrorThrow( PKCS_ASN_ERROR );
    }

    //
    // Decode the data block which is an ASN.1 encoded DigestInfo object
    //

    asnDigest.Decode( pbEncryptionBlock + i, osEncryptionBlock.Length() - i );
    ErrorCheck;

    //
    // Get the hashed data
    //

    osHashData.Resize( asnDigest.Digest.DataLength() );
    ErrorCheck;

    asnDigest.Digest.Read( osHashData.Access() );
    ErrorCheck;

    return( TRUE );

ErrorExit:

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certutil\ext.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        ext.c
//
// Contents:    Routine related to hydra certificate extension
//
// History:     03-18-98    HueiWang    Created
//
// Note:
//---------------------------------------------------------------------------
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <tchar.h>
#include <shellapi.h>
#include <stddef.h>
#include <winnls.h>
#include "base64.h"
#include "license.h"
#include "cryptkey.h"
#include "certutil.h"

/*****************************************************************************

    LSConvertMsLicensedProductInfoToExtension();
    LSConvertExtensionToMsLicensedProductInfo();

*****************************************************************************/
DWORD 
LSExtensionToMsLicensedProductInfo(
    PBYTE      pbData,
    DWORD      cbData,
    PDWORD     pdwQuantity,
    PDWORD     pdwPlatformId,
    PDWORD     pdwLanguagId,
    PBYTE*     ppbOriginalProductId,
    PDWORD     pcbOriginalProductId,
    PBYTE*     ppbAdjustedProductId,
    PDWORD     pcbAdjustedProductId,
    LICENSED_VERSION_INFO** ppLicenseInfo,
    PDWORD     pdwNumberLicensedVersionInfo
    )
/*++
++*/
{
    // 
    // Need to consider structure version
    //
    UNALIGNED LICENSED_PRODUCT_INFO *ptr = (LICENSED_PRODUCT_INFO*)pbData;

    if(ptr->dwVersion != LICENSED_PRODUCT_INFO_VERSION)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if(pdwQuantity)
    {
        *pdwQuantity = ptr->dwQuantity;
    }

    if(pdwPlatformId)
    {
        *pdwPlatformId = ptr->dwPlatformID;
    }

    if(pdwLanguagId)
    {
        *pdwLanguagId = ptr->dwLanguageID;
    }

    //
    // Original request product ID
    //
    if(ppbOriginalProductId)
    {
        // allocate memory to prevent alignment fault
        *ppbOriginalProductId = (PBYTE)AllocMemory(ptr->wOrgProductIDSize + sizeof(TCHAR));
        if(!*ppbOriginalProductId)
        {
            return LICENSE_STATUS_OUT_OF_MEMORY;
        }

        memcpy(
            *ppbOriginalProductId, 
            pbData + ptr->wOrgProductIDOffset, 
            ptr->wOrgProductIDSize
        );
    }

    if(pcbOriginalProductId)
    {
        *pcbOriginalProductId = ptr->wOrgProductIDSize;
    }

    //
    // Adjusted product ID
    //
    if(ppbAdjustedProductId)
    {
        // allocate memory to prevent alignment fault
        *ppbAdjustedProductId = (PBYTE)AllocMemory(ptr->wAdjustedProductIdSize + sizeof(TCHAR));
        if(!*ppbAdjustedProductId)
        {
            return LICENSE_STATUS_OUT_OF_MEMORY;
        }

        memcpy(
            *ppbAdjustedProductId, 
            pbData + ptr->wAdjustedProductIdOffset, 
            ptr->wAdjustedProductIdSize
        );
    }

    if(pcbAdjustedProductId)
    {
        *pcbAdjustedProductId = ptr->wAdjustedProductIdSize;
    }


    //
    // alignment fix up
    //
    if(ppLicenseInfo)
    {
        *ppLicenseInfo = (LICENSED_VERSION_INFO *)AllocMemory(ptr->wNumberOfVersionInfo * sizeof(LICENSED_VERSION_INFO));
        if(!*ppLicenseInfo)
        {
            return LICENSE_STATUS_OUT_OF_MEMORY;
        }

        memcpy(
            *ppLicenseInfo, 
            pbData + ptr->wVersionInfoOffset, 
            ptr->wNumberOfVersionInfo * sizeof(LICENSED_VERSION_INFO)
        );
    }

    if(pdwNumberLicensedVersionInfo)
        *pdwNumberLicensedVersionInfo = ptr->wNumberOfVersionInfo;

    return LICENSE_STATUS_OK;
}

//----------------------------------------------------------------------------------------
DWORD 
LSLicensedProductInfoToExtension(
    IN DWORD dwQuantity,
    IN DWORD dwPlatformId,
    IN DWORD dwLangId,
    IN PBYTE pbOriginalProductId,
    IN DWORD cbOriginalProductId,
    IN PBYTE pbAdjustedProductId,
    IN DWORD cbAdjustedProductId,
    IN LICENSED_VERSION_INFO* pLicensedVersionInfo,
    IN DWORD dwNumLicensedVersionInfo,
    OUT PBYTE *pbData,
    OUT PDWORD cbData
    )
/*++
++*/
{
    LICENSED_PRODUCT_INFO* pLicensedInfo;

    *cbData=sizeof(LICENSED_PRODUCT_INFO) + cbAdjustedProductId + 
                cbOriginalProductId + dwNumLicensedVersionInfo * sizeof(LICENSED_VERSION_INFO);
    pLicensedInfo=(LICENSED_PRODUCT_INFO *)AllocMemory(*cbData);
    if(!pLicensedInfo)
    {
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    pLicensedInfo->dwVersion = LICENSED_PRODUCT_INFO_VERSION;
    pLicensedInfo->dwQuantity = dwQuantity;
    pLicensedInfo->dwPlatformID = dwPlatformId;
    pLicensedInfo->dwLanguageID = dwLangId;

    //
    // First variable data is the original product request ID
    //
    pLicensedInfo->wOrgProductIDOffset = offsetof(LICENSED_PRODUCT_INFO, bVariableDataStart);
    pLicensedInfo->wOrgProductIDSize = (WORD)cbOriginalProductId;
    memcpy(
        &(pLicensedInfo->bVariableDataStart[0]), 
        pbOriginalProductId, 
        cbOriginalProductId
    );

    //
    // Second variable is the adjusted product id by policy module
    //
    pLicensedInfo->wAdjustedProductIdOffset = pLicensedInfo->wOrgProductIDOffset + pLicensedInfo->wOrgProductIDSize;
    pLicensedInfo->wAdjustedProductIdSize = (WORD)cbAdjustedProductId;
    memcpy(
        (PBYTE)pLicensedInfo + pLicensedInfo->wAdjustedProductIdOffset,
        pbAdjustedProductId,
        cbAdjustedProductId
    );

    //
    // Third variable is the product version array
    //
    pLicensedInfo->wVersionInfoOffset = pLicensedInfo->wAdjustedProductIdOffset + pLicensedInfo->wAdjustedProductIdSize;
    pLicensedInfo->wNumberOfVersionInfo = (WORD)dwNumLicensedVersionInfo;

    memcpy((PBYTE)pLicensedInfo + pLicensedInfo->wVersionInfoOffset, 
           pLicensedVersionInfo, 
           dwNumLicensedVersionInfo * sizeof(LICENSED_VERSION_INFO));

    *pbData=(PBYTE)pLicensedInfo;
    return LICENSE_STATUS_OK;
}
//----------------------------------------------------------------------------------------
LICENSE_STATUS
LSMsLicenseServerInfoToExtension(
    LPTSTR szIssuer,
    LPTSTR szIssuerId,
    LPTSTR szScope,
    PBYTE* pbData,
    PDWORD cbData
    )
/*++
++*/
{
    MS_LICENSE_SERVER_INFO* pLicenseServerInfo;

    *cbData=sizeof(MS_LICENSE_SERVER_INFO) + 
            (_tcslen(szIssuerId) + _tcslen(szIssuer) + _tcslen(szScope) + 3) * sizeof(TCHAR);

    pLicenseServerInfo = (MS_LICENSE_SERVER_INFO*)AllocMemory(*cbData);
    if(pLicenseServerInfo == NULL)
    {
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    pLicenseServerInfo->dwVersion = MS_LICENSE_SERVER_INFO_VERSION2;
    pLicenseServerInfo->wIssuerOffset = 0;
    pLicenseServerInfo->wIssuerIdOffset = (_tcslen(szIssuer)+1) * sizeof(TCHAR);
    pLicenseServerInfo->wScopeOffset = pLicenseServerInfo->wIssuerIdOffset + (_tcslen(szIssuerId) + 1) * sizeof(TCHAR);

    memcpy(
            &(pLicenseServerInfo->bVariableDataStart[0]), 
            (PBYTE)szIssuer, 
            _tcslen(szIssuer) * sizeof(TCHAR)
        );

    memcpy(
            &(pLicenseServerInfo->bVariableDataStart[0]) + pLicenseServerInfo->wIssuerIdOffset,
            (PBYTE)szIssuerId, 
            _tcslen(szIssuerId) * sizeof(TCHAR)
        );

    memcpy(
            &(pLicenseServerInfo->bVariableDataStart[0]) + pLicenseServerInfo->wScopeOffset,
            szScope, 
            _tcslen(szScope) * sizeof(TCHAR)
        );

    *pbData = (PBYTE)pLicenseServerInfo;
    return LICENSE_STATUS_OK;
}
//---------------------------------------------------------------------------------------
#ifdef _WIN64
DWORD
UnalignedStrLenW(
    UNALIGNED WCHAR *pString
    )
{
    DWORD dwChar = 0;

    while(*pString != (WCHAR)NULL)
    {
        dwChar++;
        pString++;
    }

    return(dwChar);
}

#define STRLEN3264 UnalignedStrLenW
#else
#define STRLEN3264 wcslen
#endif

LICENSE_STATUS
LSExtensionToMsLicenseServerInfo(
    PBYTE   pbData,
    DWORD   cbData,
    LPTSTR* szIssuer,
    LPTSTR* szIssuerId,
    LPTSTR* szScope
    )
/*++
++*/
{
    UNALIGNED MS_LICENSE_SERVER_INFO *pLServerInfo =
        (MS_LICENSE_SERVER_INFO*)pbData;

    if(pLServerInfo->dwVersion == MS_LICENSE_SERVER_INFO_VERSION1)
    {
        DWORD cchIssuer, cchScope;
        MS_LICENSE_SERVER_INFO10 UNALIGNED * pLServerInfo1 =
            (MS_LICENSE_SERVER_INFO10 UNALIGNED *)pbData;

        *szIssuerId = NULL;

        cchIssuer = STRLEN3264((LPTSTR)(&(pLServerInfo1->bVariableDataStart[0]) +
            pLServerInfo1->wIssuerOffset));
        cchScope = STRLEN3264((LPTSTR)(&(pLServerInfo1->bVariableDataStart[0]) +
            pLServerInfo1->wScopeOffset));

        *szIssuer = (LPTSTR)AllocMemory((cchIssuer + 1) * sizeof(TCHAR));
        *szScope = (LPTSTR)AllocMemory((cchScope + 1) * sizeof(TCHAR));

        if ((*szIssuer == NULL) || (*szScope == NULL))
        {
            // FreeMemory checks for NULL before freeing

            FreeMemory(*szIssuer);
            *szIssuer = NULL;

            FreeMemory(*szScope);
            *szScope = NULL;
            return(LICENSE_STATUS_OUT_OF_MEMORY);
        }

        memcpy(
            (PBYTE)(*szIssuer),
            (PBYTE)(&(pLServerInfo1->bVariableDataStart[0]) +
                pLServerInfo1->wIssuerOffset),
            (cchIssuer + 1) * sizeof(TCHAR)
            );

        memcpy(
            (PBYTE)(*szScope),
            (PBYTE)(&(pLServerInfo1->bVariableDataStart[0]) +
                pLServerInfo1->wScopeOffset),
            (cchScope + 1) * sizeof(TCHAR)
            );
    }
    else
    {
        DWORD cchIssuer, cchIssuerId, cchScope;

        cchIssuer = STRLEN3264((LPTSTR)(&(pLServerInfo->bVariableDataStart[0]) +
            pLServerInfo->wIssuerOffset));
        cchIssuerId = STRLEN3264((LPTSTR)(&(pLServerInfo->bVariableDataStart[0]) +
            pLServerInfo->wIssuerIdOffset));
        cchScope = STRLEN3264((LPTSTR)(&(pLServerInfo->bVariableDataStart[0]) +
            pLServerInfo->wScopeOffset));

        *szIssuer = (LPTSTR)AllocMemory((cchIssuer + 1) * sizeof(TCHAR));
        *szIssuerId = (LPTSTR)AllocMemory((cchIssuerId + 1) * sizeof(TCHAR));
        *szScope = (LPTSTR)AllocMemory((cchScope + 1) * sizeof(TCHAR));

        if ((*szIssuer == NULL) || (*szIssuerId == NULL) || (*szScope == NULL))
        {
            // FreeMemory checks for NULL before freeing

            FreeMemory(*szIssuer);
            *szIssuer = NULL;

            FreeMemory(*szIssuerId);
            *szIssuerId = NULL;

            FreeMemory(*szScope);
            *szScope = NULL;
            return(LICENSE_STATUS_OUT_OF_MEMORY);
        }

        memcpy(
            (PBYTE)(*szIssuer),
            (PBYTE)(&(pLServerInfo->bVariableDataStart[0]) +
                pLServerInfo->wIssuerOffset),
            (cchIssuer + 1) * sizeof(TCHAR)
            );

        memcpy(
            (PBYTE)(*szIssuerId),
            (PBYTE)(&(pLServerInfo->bVariableDataStart[0]) +
                pLServerInfo->wIssuerIdOffset),
            (cchIssuerId + 1) * sizeof(TCHAR)
            );

        memcpy(
            (PBYTE)(*szScope),
            (PBYTE)(&(pLServerInfo->bVariableDataStart[0]) +
                pLServerInfo->wScopeOffset),
            (cchScope + 1) * sizeof(TCHAR)
            );
    }

    return LICENSE_STATUS_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\cryptkey\base64.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        base64.cpp
//
// Contents:    base64 encode/decode implementation
//
// History:     25-Jul-96       vich created
//              23-Jan-98       HueiWang    Copy from ISPU project
//                                          and modify function name
//---------------------------------------------------------------------------
# include <windows.h>
# include <assert.h>
# include "base64.h"
# undef LSBase64Encode
# undef LSBase64Decode

# define CSASSERT assert
# define TCHAR CHAR

//# define LSBase64Encode LSBase64EncodeA
//# define LSBase64Decode LSBase64DecodeA


// The following table translates an ascii subset to 6 bit values as follows
// (see rfc 1521):
//
//  input    hex (decimal)
//  'A' --> 0x00 (0)
//  'B' --> 0x01 (1)
//  ...
//  'Z' --> 0x19 (25)
//  'a' --> 0x1a (26)
//  'b' --> 0x1b (27)
//  ...
//  'z' --> 0x33 (51)
//  '0' --> 0x34 (52)
//  ...
//  '9' --> 0x3d (61)
//  '+' --> 0x3e (62)
//  '/' --> 0x3f (63)
//
// Encoded lines must be no longer than 76 characters.
// The final "quantum" is handled as follows:  The translation output shall
// always consist of 4 characters.  'x', below, means a translated character,
// and '=' means an equal sign.  0, 1 or 2 equal signs padding out a four byte
// translation quantum means decoding the four bytes would result in 3, 2 or 1
// unencoded bytes, respectively.
//
//  unencoded size    encoded data
//  --------------    ------------
//     1 byte		"xx=="
//     2 bytes		"xxx="
//     3 bytes		"xxxx"

#define CB_BASE64LINEMAX	64	// others use 64 -- could be up to 76

// Any other (invalid) input character value translates to 0x40 (64)

const BYTE abDecode[256] =
{
    /* 00: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 10: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 20: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
    /* 30: */ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
    /* 40: */ 64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    /* 50: */ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
    /* 60: */ 64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    /* 70: */ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
    /* 80: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 90: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* a0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* b0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* c0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* d0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* e0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* f0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
};


const UCHAR abEncode[] =
    /*  0 thru 25: */ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    /* 26 thru 51: */ "abcdefghijklmnopqrstuvwxyz"
    /* 52 thru 61: */ "0123456789"
    /* 62 and 63: */  "+/";


DWORD			// ERROR_*
LSBase64DecodeA(
    IN TCHAR const *pchIn,
    IN DWORD cchIn,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut)
{
    DWORD err = ERROR_SUCCESS;
    DWORD cchInDecode, cbOutDecode;
    TCHAR const *pchInEnd;
    TCHAR const *pchInT;
    BYTE *pbOutT;

    // Count the translatable characters, skipping whitespace & CR-LF chars.

    cchInDecode = 0;
    pchInEnd = &pchIn[cchIn];
    for (pchInT = pchIn; pchInT < pchInEnd; pchInT++)
    {
	if (sizeof(abDecode) < (unsigned) *pchInT || abDecode[*pchInT] > 63)
	{
	    // skip all whitespace

	    if (*pchInT == ' ' ||
	        *pchInT == '\t' ||
	        *pchInT == '\r' ||
	        *pchInT == '\n')
	    {
		continue;
	    }

	    if (0 != cchInDecode)
	    {
		if ((cchInDecode % 4) == 0)
		{
		    break;			// ends on quantum boundary
		}

		// The length calculation may stop in the middle of the last
		// translation quantum, because the equal sign padding
		// characters are treated as invalid input.  If the last
		// translation quantum is not 4 bytes long, it must be 2 or 3
		// bytes long.

		if (*pchInT == '=' && (cchInDecode % 4) != 1)
		{
		    break;				// normal termination
		}
	    }
	    err = ERROR_INVALID_DATA;
	    goto error;
	}
	cchInDecode++;
    }
    CSASSERT(pchInT <= pchInEnd);
    pchInEnd = pchInT;		// don't process any trailing stuff again

    // We know how many translatable characters are in the input buffer, so now
    // set the output buffer size to three bytes for every four (or fraction of
    // four) input bytes.

    cbOutDecode = ((cchInDecode + 3) / 4) * 3;

    pbOutT = pbOut;

    if (NULL == pbOut)
    {
	pbOutT += cbOutDecode;
    }
    else
    {
	// Decode one quantum at a time: 4 bytes ==> 3 bytes

	CSASSERT(cbOutDecode <= *pcbOut);
	pchInT = pchIn;
	while (cchInDecode > 0)
	{
	    DWORD i;
	    BYTE ab4[4];

	    memset(ab4, 0, sizeof(ab4));
	    for (i = 0; i < min(sizeof(ab4)/sizeof(ab4[0]), cchInDecode); i++)
	    {
		while (
		    sizeof(abDecode) > (unsigned) *pchInT &&
		    63 < abDecode[*pchInT])
		{
		    pchInT++;
		}
		CSASSERT(pchInT < pchInEnd);
		ab4[i] = (BYTE) *pchInT++;
	    }

	    // Translate 4 input characters into 6 bits each, and deposit the
	    // resulting 24 bits into 3 output bytes by shifting as appropriate.

	    // out[0] = in[0]:in[1] 6:2
	    // out[1] = in[1]:in[2] 4:4
	    // out[2] = in[2]:in[3] 2:6

	    *pbOutT++ =
		(BYTE) ((abDecode[ab4[0]] << 2) | (abDecode[ab4[1]] >> 4));

	    if (i > 2)
	    {
		*pbOutT++ =
		  (BYTE) ((abDecode[ab4[1]] << 4) | (abDecode[ab4[2]] >> 2));
	    }
	    if (i > 3)
	    {
		*pbOutT++ = (BYTE) ((abDecode[ab4[2]] << 6) | abDecode[ab4[3]]);
	    }
	    cchInDecode -= i;
	}
	CSASSERT((DWORD) (pbOutT - pbOut) <= cbOutDecode);
    }
    *pcbOut = (DWORD)(pbOutT - pbOut);
error:
    return(err);
}


DWORD			// ERROR_*
LSBase64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT TCHAR *pchOut,
    OUT DWORD *pcchOut)
{
    TCHAR *pchOutT;
    DWORD cchOutEncode;

    // Allocate enough memory for full final translation quantum.

    cchOutEncode = ((cbIn + 2) / 3) * 4;

    // and enough for CR-LF pairs for every CB_BASE64LINEMAX character line.

    cchOutEncode +=
	2 * ((cchOutEncode + CB_BASE64LINEMAX - 1) / CB_BASE64LINEMAX);

    pchOutT = pchOut;
    if (NULL == pchOut)
    {
	pchOutT += cchOutEncode;
    }
    else
    {
	DWORD cCol;

	CSASSERT(cchOutEncode <= *pcchOut);
	cCol = 0;
	while ((long) cbIn > 0)	// signed comparison -- cbIn can wrap
	{
	    BYTE ab3[3];

	    if (cCol == CB_BASE64LINEMAX/4)
	    {
		cCol = 0;
		*pchOutT++ = '\r';
		*pchOutT++ = '\n';
	    }
	    cCol++;
	    memset(ab3, 0, sizeof(ab3));

	    ab3[0] = *pbIn++;
	    if (cbIn > 1)
	    {
		ab3[1] = *pbIn++;
		if (cbIn > 2)
		{
		    ab3[2] = *pbIn++;
		}
	    }

	    *pchOutT++ = abEncode[ab3[0] >> 2];
	    *pchOutT++ = abEncode[((ab3[0] << 4) | (ab3[1] >> 4)) & 0x3f];
	    *pchOutT++ = (cbIn > 1)?
			abEncode[((ab3[1] << 2) | (ab3[2] >> 6)) & 0x3f] : '=';
	    *pchOutT++ = (cbIn > 2)? abEncode[ab3[2] & 0x3f] : '=';

	    cbIn -= 3;
	}
	*pchOutT++ = '\r';
	*pchOutT++ = '\n';
	CSASSERT((DWORD) (pchOutT - pchOut) <= cchOutEncode);
    }
    *pcchOut = (DWORD)(pchOutT - pchOut);
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certlib\licecert\x509.h ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    x509.h

Abstract:


Author:

    Frederick Chong (dbarlow) 5/28/1998

Environment:



Notes:



--*/


#ifndef _X509_H_
#define _X509_H_
#include <MSAsnLib.h>


//
//==============================================================================
//
//  Attribute
//

class Attribute
:   public CAsnSequence
{
public:
    Attribute(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CAsnObjectIdentifier attributeType;
    CAsnAny attributeValue;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  Attributes
//

class Attributes
:   public CAsnSetOf
{
public:
    Attributes(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    virtual Attribute &
    operator[](int index) const
    { return *(Attribute *)m_rgEntries[index]; };

    Attribute m_asnEntry1;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  UniqueIdentifier
//

class UniqueIdentifier
:   public CAsnSequence
{
public:
    UniqueIdentifier(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CAsnObjectIdentifier attributeType;
    CAsnOctetstring attributeValue;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  RelativeDistinguishedName
//

class RelativeDistinguishedName
:   public Attributes
{
public:
    RelativeDistinguishedName(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  Name
//

class Name
:   public CAsnSequenceOf
{
public:
    Name(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    virtual RelativeDistinguishedName &
    operator[](int index) const
    { return *(RelativeDistinguishedName *)m_rgEntries[index]; };

    RelativeDistinguishedName m_asnEntry1;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  Validity
//

class Validity
:   public CAsnSequence
{
public:
    Validity(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CAsnUniversalTime notBefore;
    CAsnUniversalTime notAfter;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  AlgorithmIdentifier
//

class AlgorithmIdentifier
:   public CAsnSequence
{
public:
    AlgorithmIdentifier(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CAsnObjectIdentifier algorithm;
    CAsnAny parameters;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};

class SubjectPublicKeyInfo
:   public CAsnSequence
{
public:
    SubjectPublicKeyInfo(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    AlgorithmIdentifier algorithm;
    CAsnBitstring subjectPublicKey;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  Extension
//

class Extension
:   public CAsnSequence
{
public:
    Extension(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CAsnObjectIdentifier extnid;
    CAsnBoolean critical;
    CAsnOctetstring extnValue;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  Extensions
//

class Extensions
:   public CAsnSequenceOf
{
public:
    Extensions(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    virtual Extension &
    operator[](int index) const
    { return *(Extension *)m_rgEntries[index]; };

    Extension m_asnEntry1;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CertificateToBeSigned
//

class CertificateToBeSigned
:   public CAsnSequence
{
public:
    CertificateToBeSigned(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CAsnTag _tag1;
    CAsnInteger version;
    CAsnInteger serialNumber;
    AlgorithmIdentifier signature;
    Name issuer;
    Validity validity;
    Name subject;
    SubjectPublicKeyInfo subjectPublicKeyInfo;
    UniqueIdentifier issuerUniqueID;
    UniqueIdentifier subjectUniqueID;
    CAsnTag _tag2;
    Extensions extensions;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  Certificate
//

class Certificate
:   public CAsnSequence
{
public:
    Certificate(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CertificateToBeSigned toBeSigned;
    AlgorithmIdentifier algorithm;
    CAsnBitstring signature;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};



//
//==============================================================================
//
//  CRLEntry
//

class CRLEntry
:   public CAsnSequence
{
public:
    CRLEntry(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CAsnInteger userCertificate;
    CAsnUniversalTime revocationDate;
    Extensions crlEntryExtensions;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  RevokedCertificates
//

class RevokedCertificates
:   public CAsnSequenceOf
{
public:
    RevokedCertificates(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    virtual CRLEntry &
    operator[](int index) const
    { return *(CRLEntry *)m_rgEntries[index]; };

    CRLEntry m_asnEntry1;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CertificateRevocationListToBeSigned
//

class CertificateRevocationListToBeSigned
:   public CAsnSequence
{
public:
    CertificateRevocationListToBeSigned(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CAsnInteger version;
    AlgorithmIdentifier signature;
    Name issuer;
    CAsnUniversalTime lastUpdate;
    CAsnUniversalTime nextUpdate;
    RevokedCertificates revokedCertificates;
    CAsnTag _tag1;
    Extensions crlExtensions;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CertificateRevocationList
//

class CertificateRevocationList
:   public CAsnSequence
{
public:
    CertificateRevocationList(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CertificateRevocationListToBeSigned toBeSigned;
    AlgorithmIdentifier algorithm;
    CAsnBitstring signature;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};

#endif  // _X509_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\certutil\verify.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        verify.c
//
// Contents:    Routine related to certificate verification
//
// History:     03-18-98    HueiWang    Created
//
// Note:
//---------------------------------------------------------------------------

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <wincrypt.h>
#include <shellapi.h>
#include "license.h"
#include "certutil.h"

HCRYPTPROV  g_hCertUtilCryptProv=NULL;
BOOL        g_PrivateCryptProv = TRUE;

void
LSShutdownCertutilLib()
{
    if(g_hCertUtilCryptProv && g_PrivateCryptProv)
    {
        CryptReleaseContext(g_hCertUtilCryptProv, 0);
    }
    g_hCertUtilCryptProv = NULL;
}

BOOL
LSInitCertutilLib( HCRYPTPROV hProv )
{
    if(hProv)
    {
        g_hCertUtilCryptProv = hProv;
        g_PrivateCryptProv = FALSE;
    }
    else if(g_hCertUtilCryptProv == NULL)
    {
        if(!CryptAcquireContext(&g_hCertUtilCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
        {
            if(CryptAcquireContext(
                            &g_hCertUtilCryptProv, 
                            NULL, 
                            NULL, 
                            PROV_RSA_FULL, 
                            CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET | CRYPT_VERIFYCONTEXT
                        ) == FALSE)
            {
                return FALSE;
            }
        }

        g_PrivateCryptProv = TRUE;
    }

    return TRUE;
}

/**************************************************************************
Function:

    LSVerifyCertificateChain(IN LPTSTR szFile)

Abstract:

    Verify Licenses in file store

Parameters:

    szFile - Name of file contain license

Returns:
    ERROR_SUCCESS
    LICENSE_STATUS_NO_LICENSE_ERROR
    LICENSE_STATUS_CANNOT_FIND_ISSUER_CERT  Can't find issuer's certificate.
    LICENSE_STATUS_UNSPECIFIED_ERROR        Unknown error.
    LICENSE_STATUS_INVALID_LICENSE          Invalid License
    LICENSE_STATUS_EXPIRED_LICENSE          Expired licenses

**************************************************************************/
LICENSE_STATUS
LSVerifyCertificateChain(
    HCRYPTPROV hCryptProv, 
    HCERTSTORE hCertStore
    )
/*++

++*/
{
    PCCERT_CONTEXT  pCertContext=NULL;
    PCCERT_CONTEXT  pCertIssuer=NULL;
    DWORD           dwStatus=ERROR_SUCCESS;
    DWORD           dwLastVerification=0;

    //
    // Get the first certificate
    //
    pCertContext=CertFindCertificateInStore(
                                        hCertStore,
                                        X509_ASN_ENCODING,
                                        0,
                                        CERT_FIND_ANY,
                                        NULL,  
                                        NULL
                                    );

    if(pCertContext == NULL)
    {
        #if DBG
        dwStatus=GetLastError();
        #endif

        return LICENSE_STATUS_NO_LICENSE_ERROR;
    }

    while(pCertContext != NULL)
    {
        //
        // Verify against all issuer's certificate
        //
        DWORD dwFlags;
        BOOL  bVerify=FALSE;

        dwStatus=ERROR_SUCCESS;
        dwLastVerification=0;
        pCertIssuer=NULL;

        do {
            dwFlags = CERT_STORE_SIGNATURE_FLAG; // | CERT_STORE_TIME_VALIDITY_FLAG;

            pCertIssuer = CertGetIssuerCertificateFromStore(
                                                    hCertStore,
                                                    pCertContext,
                                                    pCertIssuer,
                                                    &dwFlags
                                                );

            if(!pCertIssuer)
            {
                dwStatus = GetLastError();
                break;
            }
            
            dwLastVerification=dwFlags;
            bVerify = (dwFlags == 0);
        } while(!bVerify);

        // 
        // Check against error return from CertGetIssuerCertificateFromStore()
        //
        if(dwStatus != ERROR_SUCCESS || dwLastVerification)
        {
            if(dwStatus == CRYPT_E_SELF_SIGNED)
            {
                // self-signed certificate
                if( CryptVerifyCertificateSignature(
                                            hCryptProv, 
                                            X509_ASN_ENCODING, 
                                            pCertContext->pbCertEncoded, 
                                            pCertContext->cbCertEncoded,
                                            &pCertContext->pCertInfo->SubjectPublicKeyInfo
                                        ) )
                {
                    dwStatus=ERROR_SUCCESS;
                }
            }
            else if(dwStatus == CRYPT_E_NOT_FOUND)
            {
                // can't find issuer's certificate
                dwStatus = LICENSE_STATUS_CANNOT_FIND_ISSUER_CERT;
            }
            else if(dwLastVerification & CERT_STORE_SIGNATURE_FLAG)
            {
                dwStatus=LICENSE_STATUS_INVALID_LICENSE;
            }
            else if(dwLastVerification & CERT_STORE_TIME_VALIDITY_FLAG)
            {
                dwStatus=LICENSE_STATUS_EXPIRED_LICENSE;
            }
            else
            {
                dwStatus=LICENSE_STATUS_UNSPECIFIED_ERROR;
            }

            break;
        }

        // Success verifiy certificate, 
        // continue on verifying issuer's certificate
        CertFreeCertificateContext(pCertContext);
        pCertContext = pCertIssuer;
    } // while(pCertContext != NULL)

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\cryptkey\cryptkey.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cryptkey.c
//
//  Contents:   Functions that are used to pack and unpack different messages
//
//  Classes:
//
//  Functions:
//
//  History:    12-19-97  v-sbhatt   Created
//
//----------------------------------------------------------------------------

//
// Include files
//

#include "windows.h"
#include "tchar.h"
#ifdef _DEBUG
#include "stdio.h"
#endif  //_DEBUG
#include "stdlib.h"
#include "malloc.h"

#ifdef OS_WINCE
#include <wincelic.h>
#include <ceconfig.h>
#endif  //OS_WINCE


#include "license.h"

#include "cryptkey.h"
#include "rsa.h"
#include "md5.h"
#include "sha.h"
#include "rc4.h"

#include <tssec.h>

#ifdef OS_WIN32
#include "des.h"
#include "tripldes.h"
#include "modes.h"
#include "sha_my.h"
#include "dh_key.h"
#include "dss_key.h"
#endif //

#ifndef OS_WINCE
#include "assert.h"
#endif // OS_WINCE


LPBSAFE_PUB_KEY PUB;
unsigned char pubmodulus[] =
{
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x3d, 0x3a, 0x5e, 0xbd, 0x72, 0x43, 0x3e, 0xc9,
0x4d, 0xbb, 0xc1, 0x1e, 0x4a, 0xba, 0x5f, 0xcb,
0x3e, 0x88, 0x20, 0x87, 0xef, 0xf5, 0xc1, 0xe2,
0xd7, 0xb7, 0x6b, 0x9a, 0xf2, 0x52, 0x45, 0x95,
0xce, 0x63, 0x65, 0x6b, 0x58, 0x3a, 0xfe, 0xef,
0x7c, 0xe7, 0xbf, 0xfe, 0x3d, 0xf6, 0x5c, 0x7d,
0x6c, 0x5e, 0x06, 0x09, 0x1a, 0xf5, 0x61, 0xbb,
0x20, 0x93, 0x09, 0x5f, 0x05, 0x6d, 0xea, 0x87,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


BYTE    PAD_1[40] = {0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
                                     0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
                                     0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
                                     0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
                                     0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36};

BYTE    PAD_2[48] = {0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
                                         0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
                                         0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
                                         0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
                                         0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
                                         0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C};

//Initializes a pulic key
static BOOL initpubkey(void)
{
    PUB = (LPBSAFE_PUB_KEY)pubmodulus;

    PUB->magic = RSA1;
    PUB->keylen = 0x48;
    PUB->bitlen = 0x0200;
    PUB->datalen = 0x3f;
    PUB->pubexp = 0xc0887b5b;
        return TRUE;
}

/*****************************************************************************
*   Funtion :   LicenseMakeSessionKeys
*   Purpose :   Generates a session keys based on CryptSystem and puts the
                data in the rgbSessionKey data member of CryptSystem
*   Returns :   License_status
******************************************************************************/

LICENSE_STATUS
CALL_TYPE
LicenseSetPreMasterSecret(
                                                PCryptSystem    pCrypt,
                                                PUCHAR                  pPreMasterSecret
                                                )
{
        LICENSE_STATUS lsReturn = LICENSE_STATUS_OK;

        assert(pCrypt);
        assert(pPreMasterSecret);
        //check the state of the crypt system
        if(pCrypt->dwCryptState != CRYPT_SYSTEM_STATE_INITIALIZED)
        {
                lsReturn = LICENSE_STATUS_INVALID_CRYPT_STATE;
                return lsReturn;
        }

        memcpy(pCrypt->rgbPreMasterSecret, pPreMasterSecret, LICENSE_PRE_MASTER_SECRET);
        pCrypt->dwCryptState = CRYPT_SYSTEM_STATE_PRE_MASTER_SECRET;
        return lsReturn;

}

LICENSE_STATUS
CALL_TYPE
LicenseMakeSessionKeys(
                                PCryptSystem    pCrypt,
                                DWORD                   dwReserved
                            )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    MD5_CTX             Md5Hash;
    A_SHA_CTX           ShaHash;
    BYTE                rgbShaHashValue[A_SHA_DIGEST_LEN];
    BYTE                rgbKeyBlock[3*LICENSE_SESSION_KEY];
    BYTE FAR *          sz[3] = { "A","BB","CCC" };
    BYTE                rgbWriteKey[LICENSE_SESSION_KEY];
    DWORD               ib;

        assert(pCrypt);

        if(pCrypt->dwCryptState != CRYPT_SYSTEM_STATE_MASTER_SECRET)
        {
                lsReturn = LICENSE_STATUS_INVALID_CRYPT_STATE;
                return lsReturn;
        }
    //At this point, rgbPreMasterSecret  should contain Master secret.
    //ie a call to BuildMasterSecret is required before this is called

    for(ib=0 ; ib<3 ; ib++)
        {
                // SHA(master_secret + ServerHello.random + ClientHello.random + 'foo')
                A_SHAInit  (&ShaHash);
                A_SHAUpdate(&ShaHash, sz[ib], (UINT)ib + 1);
                A_SHAUpdate(&ShaHash, pCrypt->rgbPreMasterSecret, LICENSE_PRE_MASTER_SECRET);
                A_SHAUpdate(&ShaHash, pCrypt->rgbServerRandom, LICENSE_RANDOM);
                A_SHAUpdate(&ShaHash, pCrypt->rgbClientRandom, LICENSE_RANDOM);
                A_SHAFinal (&ShaHash, rgbShaHashValue);

                // MD5(master_secret + SHA-hash)
                MD5Init  (&Md5Hash);
                MD5Update(&Md5Hash, pCrypt->rgbPreMasterSecret, LICENSE_PRE_MASTER_SECRET);
                MD5Update(&Md5Hash, rgbShaHashValue, A_SHA_DIGEST_LEN);
                MD5Final (&Md5Hash);
                memcpy(rgbKeyBlock + ib * MD5DIGESTLEN, Md5Hash.digest, MD5DIGESTLEN);
                //CopyMemory(rgbKeyBlock + ib * MD5DIGESTLEN, Md5Hash.digest, MD5DIGESTLEN);
    }

    //
    // extract keys from key block
    //

    ib = 0;
        memcpy(pCrypt->rgbMACSaltKey, rgbKeyBlock + ib, LICENSE_MAC_WRITE_KEY);
        ib+= LICENSE_MAC_WRITE_KEY;
        memcpy(rgbWriteKey, rgbKeyBlock + ib, LICENSE_SESSION_KEY);

    // final_client_write_key = MD5(client_write_key +
        //      ClientHello.random + ServerHello.random)
        MD5Init  (&Md5Hash);

    MD5Update(&Md5Hash, rgbWriteKey, LICENSE_SESSION_KEY);
        MD5Update(&Md5Hash, pCrypt->rgbClientRandom, LICENSE_RANDOM);
        MD5Update(&Md5Hash, pCrypt->rgbServerRandom, LICENSE_RANDOM);
        MD5Final (&Md5Hash);

    memcpy(pCrypt->rgbSessionKey, Md5Hash.digest, LICENSE_SESSION_KEY);
        pCrypt->dwCryptState = CRYPT_SYSTEM_STATE_SESSION_KEY;
    return lsReturn;

}

/*****************************************************************************
*   Funtion :   LicenseBuildMasterSecret
*   Purpose :   Generates the Master Secret based on ClientRandom, ServerRandom
*               and PreMasterSecret data members of CryptSystem and puts the
*               data in the rgbPreMasterSecret data member of CryptSystem
*               Note: A call to this function should preceed any call to
*               LicenseMakeSessionKeys
*   Returns :   License_status
******************************************************************************/

LICENSE_STATUS
CALL_TYPE
LicenseBuildMasterSecret(
                         PCryptSystem   pSystem
                         )
{
    LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
    BYTE rgbRandom[2 * LICENSE_RANDOM];
    BYTE rgbT[LICENSE_PRE_MASTER_SECRET];
    BYTE FAR* sz[3] = { "A","BB","CCC" } ;
    MD5_CTX Md5Hash;
    A_SHA_CTX ShaHash;
    BYTE bShaHashValue[A_SHA_DIGEST_LEN];
    WORD i;

        assert(pSystem);

        if(pSystem->dwCryptState != CRYPT_SYSTEM_STATE_PRE_MASTER_SECRET)
        {
                lsReturn = LICENSE_STATUS_INVALID_CRYPT_STATE;
                return lsReturn;
        }

    //initialize all buffers with zero
    memset(rgbT, 0, LICENSE_PRE_MASTER_SECRET);
    memset(bShaHashValue, 0, A_SHA_DIGEST_LEN);


//      CopyMemory(rgbRandom,  pSystem->rgbClientRandom, LICENSE_RANDOM);
        memcpy(rgbRandom,  pSystem->rgbClientRandom, LICENSE_RANDOM);

        //CopyMemory(rgbRandom + LICENSE_RANDOM, pSystem->rgbServerRandom, LICENSE_RANDOM);
        memcpy(rgbRandom + LICENSE_RANDOM, pSystem->rgbServerRandom, LICENSE_RANDOM);
        for ( i = 0 ; i < 3 ; i++)
                {
            // SHA('A' or 'BB' or 'CCC' + pre_master_secret + ClientRandom + ServerRandom)
            A_SHAInit(&ShaHash);
                A_SHAUpdate(&ShaHash, sz[i], i + 1);
            A_SHAUpdate(&ShaHash, pSystem->rgbPreMasterSecret, LICENSE_PRE_MASTER_SECRET);
            A_SHAUpdate(&ShaHash, rgbRandom, LICENSE_RANDOM * 2);
            A_SHAFinal(&ShaHash, bShaHashValue);

            // MD5(pre_master_secret + SHA-hash)
            MD5Init(&Md5Hash);
            MD5Update(&Md5Hash, pSystem->rgbPreMasterSecret, LICENSE_PRE_MASTER_SECRET);
            MD5Update(&Md5Hash, bShaHashValue, A_SHA_DIGEST_LEN);
            MD5Final(&Md5Hash);
          //  CopyMemory(rgbT + (i * MD5DIGESTLEN), Md5Hash.digest, MD5DIGESTLEN);
                memcpy(rgbT + (i * MD5DIGESTLEN), Md5Hash.digest, MD5DIGESTLEN);
            }

    // Store MASTER_KEY on top of pre-master key
    //CopyMemory(pSystem->rgbPreMasterSecret, rgbT, LICENSE_PRE_MASTER_SECRET);
        memcpy(pSystem->rgbPreMasterSecret, rgbT, LICENSE_PRE_MASTER_SECRET);
        pSystem->dwCryptState = CRYPT_SYSTEM_STATE_MASTER_SECRET;
    return lsReturn;
}

/******************************************************************************
*       Function : LicenseVerifyServerCert
*       Purpose  : This function accepts a pointer to a Hydra Server Cert structure
*                          and verifies the signature on the certificatewith universal MS
*                          public key.
*       Return   : License_Status
*******************************************************************************/

LICENSE_STATUS
CALL_TYPE
LicenseVerifyServerCert(
                                                PHydra_Server_Cert      pCert
                                                )
{
        LICENSE_STATUS          lsResult = LICENSE_STATUS_OK;
        BYTE FAR *  pbTemp;
        BYTE FAR *  pbSignData = NULL;
        BYTE            SignHash[0x48];
        DWORD           cbSignData, dwTemp;
        MD5_CTX         HashState;

        if( NULL == pCert )
        {
                assert(pCert);
                return ( LICENSE_STATUS_INVALID_INPUT );
        }

        if( NULL == pCert->PublicKeyData.pBlob )
        {
                assert(pCert->PublicKeyData.pBlob);
                return ( LICENSE_STATUS_INVALID_INPUT );
        }

        if( NULL == pCert->SignatureBlob.pBlob )
        {
                assert(pCert->SignatureBlob.pBlob);
                return ( LICENSE_STATUS_INVALID_INPUT );
        }

        if( BB_RSA_SIGNATURE_BLOB == pCert->SignatureBlob.wBlobType )
        {
                //Generate the hash on the data
                if( ( pCert->dwSigAlgID != SIGNATURE_ALG_RSA ) ||
                        ( pCert->dwKeyAlgID != KEY_EXCHANGE_ALG_RSA ) ||
                        ( pCert->PublicKeyData.wBlobType != BB_RSA_KEY_BLOB ) )
                {
#if DBG
                        OutputDebugString(_T("Error Invalid Certificate.\n"));
#endif
                        lsResult = LICENSE_STATUS_INVALID_INPUT;
                        goto CommonReturn;
                }
        }
        else
        {
#if DBG
                OutputDebugString(_T("Error Invalid Public Key parameter.\n"));
#endif
                lsResult = LICENSE_STATUS_INVALID_INPUT;
                goto CommonReturn;
        }

        cbSignData = 3*sizeof(DWORD) + 2*sizeof(WORD) + pCert->PublicKeyData.wBlobLen;

        if( NULL == (pbSignData = (BYTE FAR *)malloc(cbSignData)) )
        {
#if DBG
                OutputDebugString(_T("Error allocating memory.\n"));
#endif
                lsResult = LICENSE_STATUS_OUT_OF_MEMORY;
                goto CommonReturn;
        }

        memset(pbSignData, 0x00, cbSignData);

        //Pack the certificate data into a byte blob excluding the signature info
        pbTemp = pbSignData;
        dwTemp = 0;

        memcpy(pbTemp, &pCert->dwVersion, sizeof(DWORD));
        pbTemp += sizeof(DWORD);
        dwTemp += sizeof(DWORD);

        memcpy(pbTemp, &pCert->dwSigAlgID, sizeof(DWORD));
        pbTemp += sizeof(DWORD);
        dwTemp += sizeof(DWORD);

        memcpy(pbTemp, &pCert->dwKeyAlgID, sizeof(DWORD));
        pbTemp += sizeof(DWORD);
        dwTemp += sizeof(DWORD);

        memcpy(pbTemp, &pCert->PublicKeyData.wBlobType, sizeof(WORD));
        pbTemp += sizeof(WORD);
        dwTemp += sizeof(WORD);

        memcpy(pbTemp, &pCert->PublicKeyData.wBlobLen, sizeof(WORD));
        pbTemp += sizeof(WORD);
        dwTemp += sizeof(WORD);

        memcpy(pbTemp, pCert->PublicKeyData.pBlob, pCert->PublicKeyData.wBlobLen);
        pbTemp += pCert->PublicKeyData.wBlobLen;
        dwTemp += pCert->PublicKeyData.wBlobLen;

                //Generate the hash on the data
        MD5Init(&HashState);
        MD5Update(&HashState, pbSignData, (UINT)cbSignData);
        MD5Final(&HashState);

        //Initialize the public key and Decrypt the signature
        if(!initpubkey())
        {
#if DBG
                OutputDebugString(_T("Error generating public key!\n"));
#endif
                lsResult = LICENSE_STATUS_INITIALIZATION_FAILED;
                goto CommonReturn;
        }
        memset(SignHash, 0x00, 0x48);
        if (!BSafeEncPublic(PUB, pCert->SignatureBlob.pBlob, SignHash))
        {
#if DBG
                OutputDebugString(_T("Error encrypting signature!\n"));
#endif
                lsResult = LICENSE_STATUS_INVALID_SIGNATURE;
                goto CommonReturn;
        }
        else
        {
            SetLastError(0);
        }


        if(memcmp(SignHash, HashState.digest, 16))
        {
#if DBG
                OutputDebugString(_T("Error Invalid signature.\n"));
#endif
                lsResult = LICENSE_STATUS_INVALID_SIGNATURE;
                goto CommonReturn;
        }
        else
        {
                lsResult = LICENSE_STATUS_OK;
                goto CommonReturn;
        }




CommonReturn:
        if(pbSignData)
        {
                free(pbSignData);
                pbSignData = NULL;
        }
        return lsResult;
}


LICENSE_STATUS
CALL_TYPE
LicenseGenerateMAC(
                                   PCryptSystem         pCrypt,
                                   BYTE FAR *           pbData,
                                   DWORD                        cbData,
                                   BYTE FAR *           pbMACData
                                   )
{
        LICENSE_STATUS          lsResult = LICENSE_STATUS_OK;
        A_SHA_CTX       SHAHash;
        MD5_CTX         MD5Hash;
        BYTE            rgbSHADigest[A_SHA_DIGEST_LEN];

        assert(pCrypt);
        assert(pbData);
        assert(pbMACData);


        if(pCrypt->dwCryptState != CRYPT_SYSTEM_STATE_SESSION_KEY)
        {
                lsResult = LICENSE_STATUS_INVALID_CRYPT_STATE;
                return lsResult;
        }
        //Do SHA(MACSalt + PAD_2 + Length + Content)
        A_SHAInit(&SHAHash);
        A_SHAUpdate(&SHAHash, pCrypt->rgbMACSaltKey, LICENSE_MAC_WRITE_KEY);
        A_SHAUpdate(&SHAHash, PAD_1, 40);
        A_SHAUpdate(&SHAHash, (BYTE FAR *)&cbData, sizeof(DWORD));
        A_SHAUpdate(&SHAHash, pbData, (UINT)cbData);
        A_SHAFinal(&SHAHash, rgbSHADigest);

        //Do MD5(MACSalt + PAD_2 + SHAHash)
        MD5Init(&MD5Hash);
        MD5Update(&MD5Hash, pCrypt->rgbMACSaltKey, LICENSE_MAC_WRITE_KEY);
        MD5Update(&MD5Hash, PAD_2, 48);
        MD5Update(&MD5Hash, rgbSHADigest, A_SHA_DIGEST_LEN);
        MD5Final(&MD5Hash);

        memcpy(pbMACData, MD5Hash.digest, 16);

        return lsResult;
}


//
// decrypt the enveloped data using the given private key.
//

LICENSE_STATUS
CALL_TYPE
LicenseDecryptEnvelopedData(
        BYTE FAR *              pbPrivateKey,
        DWORD                   cbPrivateKey,
        BYTE FAR *              pbEnvelopedData,
        DWORD                   cbEnvelopedData,
        BYTE FAR *              pbData,
        DWORD                   *pcbData
        )
{

        LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
        LPBSAFE_PRV_KEY         Prv;
//      BYTE                            InputBuffer[500];

        assert(pbPrivateKey);
        assert(pbEnvelopedData);
        assert(pcbData);

        Prv = (LPBSAFE_PRV_KEY)pbPrivateKey;

        if(cbEnvelopedData != Prv->keylen)
        {
                lsReturn = LICENSE_STATUS_INVALID_INPUT;
                *pcbData = 0;
                return lsReturn;
        }

        if(pbData == NULL)
        {
                *pcbData = Prv->keylen;
                return lsReturn;
        }


        //Now memset the output buffer to 0
        memset(pbData, 0x00, *pcbData);

        if(!BSafeDecPrivate(Prv, pbEnvelopedData, pbData))
        {
                lsReturn = LICENSE_STATUS_INVALID_INPUT;
                *pcbData = 0;
                return lsReturn;
        }

        *pcbData = Prv->keylen;

        return lsReturn;
}


//
// Encrypt the data using the public key
//

LICENSE_STATUS
CALL_TYPE
LicenseEnvelopeData(
        BYTE FAR *                      pbPublicKey,
        DWORD                   cbPublicKey,
        BYTE FAR *                      pbData,
        DWORD                   cbData,
        BYTE FAR *                      pbEnvelopedData,
        DWORD                   *pcbEnvelopedData
        )
{
        LPBSAFE_PUB_KEY         Pub;
        LPBYTE                           InputBuffer = NULL;

        assert(pcbEnvelopedData);

        if(!pcbEnvelopedData)
        {
            return LICENSE_STATUS_INVALID_INPUT;
        }

        assert(pbPublicKey);

        if(!pbPublicKey)
        {
            *pcbEnvelopedData = 0;
            return LICENSE_STATUS_INVALID_INPUT;
        }
        
        
        
        Pub = (LPBSAFE_PUB_KEY)pbPublicKey;

        if(pbEnvelopedData == NULL)
        {
                *pcbEnvelopedData = Pub->keylen;
                return LICENSE_STATUS_OK;
        }
        
        assert(pbData);
        assert(cbData<=Pub->datalen);
        assert(Pub->datalen <= Pub->keylen);
        assert(*pcbEnvelopedData>=Pub->keylen);
        
        if(!pbData || cbData > Pub->datalen || 
            Pub->datalen > Pub->keylen || *pcbEnvelopedData < Pub->keylen)
        {
            *pcbEnvelopedData = 0;
            return LICENSE_STATUS_INVALID_INPUT;
        }

        *pcbEnvelopedData = 0;

        InputBuffer = malloc(Pub->keylen);
        if(!InputBuffer)
        {
            return LICENSE_STATUS_OUT_OF_MEMORY;
        }

        //Initialize input buffer with 0
        memset(InputBuffer, 0x00, Pub->keylen);

        //Copy the data to be encrypted to the input buffer
        memcpy(InputBuffer, pbData, cbData);

        memset(pbEnvelopedData, 0x00, Pub->keylen);

        if(!BSafeEncPublic(Pub, InputBuffer, pbEnvelopedData))
        {
                free(InputBuffer);
                return LICENSE_STATUS_INVALID_INPUT;
        }
        else        
        {
            SetLastError(0);
        }
        
        free(InputBuffer);
        *pcbEnvelopedData = Pub->keylen;
        return LICENSE_STATUS_OK;
}


//
// encrypt the session data using the session key
// pbData contains the data to be encrypted and cbData contains the size
// after the function returns, they represent the encrypted data and size
// respectively
//

LICENSE_STATUS
CALL_TYPE
LicenseEncryptSessionData(
    PCryptSystem    pCrypt,
        BYTE FAR *                      pbData,
        DWORD                   cbData
    )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
        struct RC4_KEYSTRUCT    Key;

        assert(pCrypt);
        assert(pbData);
        assert(cbData);

    if( ( NULL == pCrypt ) ||
        ( NULL == pbData ) ||
        ( 0 == cbData ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

        //Check the state of the CryptSystem
        assert(pCrypt->dwCryptState == CRYPT_SYSTEM_STATE_SESSION_KEY);

        memset(&Key, 0x00, sizeof(struct RC4_KEYSTRUCT));

        //Initialize the key
        rc4_key(&Key, LICENSE_SESSION_KEY, pCrypt->rgbSessionKey);

        //Now encrypt the data with the key
        rc4(&Key, (UINT)cbData, pbData);
    return lsReturn;

}


//
// decrypt the session data using the session key
// pbData contains the data to be decrypted and cbData contains the size
// after the function returns, they represent the decrypted data and size
// respectively


LICENSE_STATUS
CALL_TYPE
LicenseDecryptSessionData(
    PCryptSystem    pCrypt,
        BYTE FAR *                      pbData,
        DWORD                   cbData)
{
        LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
        struct RC4_KEYSTRUCT    Key;

        assert(pCrypt);
        assert(pbData);
        assert(cbData);

    //
    // check input
    //

    if( ( NULL == pCrypt ) ||
        ( NULL == pbData ) ||
        ( 0 >= cbData ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

        //Check the state of the CryptSystem
        assert(pCrypt->dwCryptState == CRYPT_SYSTEM_STATE_SESSION_KEY);

        memset(&Key, 0x00, sizeof(struct RC4_KEYSTRUCT));

        //Initialize the key
        rc4_key(&Key, LICENSE_SESSION_KEY, pCrypt->rgbSessionKey);

        //Now encrypt the data with the key
        rc4(&Key, (UINT)cbData, pbData);
    return lsReturn;
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
CALL_TYPE
LicenseEncryptHwid(
    PHWID   pHwid,
    PDWORD  pcbEncryptedHwid,
    BYTE FAR *   pEncryptedHwid,
    DWORD   cbSecretKey,
    BYTE FAR *   pSecretKey )
{
    LICENSE_STATUS         Status = LICENSE_STATUS_OK;
    struct RC4_KEYSTRUCT   Key;

    assert( pHwid );
    assert( sizeof( HWID ) <= *pcbEncryptedHwid );
    assert( pEncryptedHwid );
    assert( LICENSE_SESSION_KEY == cbSecretKey );
    assert( pSecretKey );

    if( ( NULL == pHwid ) ||
        ( sizeof( HWID ) > *pcbEncryptedHwid ) ||
        ( NULL == pEncryptedHwid ) ||
        ( LICENSE_SESSION_KEY != cbSecretKey ) ||
        ( NULL == pSecretKey ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // Initialize the key
    //

    memset( &Key, 0x00, sizeof( struct RC4_KEYSTRUCT ) );
    rc4_key(&Key, LICENSE_SESSION_KEY, pSecretKey);

    //
    // Now encrypt the data with the key
    //

    memcpy( pEncryptedHwid, pHwid, sizeof( HWID ) );

    rc4( &Key, sizeof( HWID ), pEncryptedHwid );
    *pcbEncryptedHwid = sizeof( HWID );

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
CALL_TYPE
LicenseDecryptHwid(
    PHWID pHwid,
    DWORD cbEncryptedHwid,
    BYTE FAR * pEncryptedHwid,
    DWORD cbSecretKey,
    BYTE FAR * pSecretKey )
{
    LICENSE_STATUS              Status = LICENSE_STATUS_OK;
        struct RC4_KEYSTRUCT    Key;

    assert( pHwid );
    assert( cbEncryptedHwid );
    assert( pEncryptedHwid );
    assert( cbSecretKey );
    assert( pSecretKey );

    if( ( NULL == pHwid ) ||
        ( sizeof( HWID ) > cbEncryptedHwid ) ||
        ( NULL == pEncryptedHwid ) ||
        ( LICENSE_SESSION_KEY != cbSecretKey ) ||
        ( NULL == pSecretKey ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // Initialize the key
    //

    memset( &Key, 0x00, sizeof( struct RC4_KEYSTRUCT ) );
    rc4_key(&Key, LICENSE_SESSION_KEY, pSecretKey);

    //
    // Now decrypt the data with the key
    //

    memcpy( ( BYTE FAR * )pHwid, pEncryptedHwid, sizeof( HWID ) );
    rc4( &Key, sizeof( HWID ), ( BYTE FAR * )pHwid );

    return( Status );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
CALL_TYPE
UnpackHydraServerCertificate(
    BYTE FAR *                          pbMessage,
        DWORD                           cbMessage,
        PHydra_Server_Cert      pCanonical )
{
        LICENSE_STATUS          lsReturn = LICENSE_STATUS_OK;
        BYTE FAR *      pbTemp = NULL;
        DWORD   dwTemp = 0;

        if( (pbMessage == NULL) || (pCanonical == NULL ) )
        {
                lsReturn = LICENSE_STATUS_INVALID_INPUT;
                goto ErrorReturn;
        }

        dwTemp = 3*sizeof(DWORD) + 4*sizeof(WORD);

        if(dwTemp > cbMessage)
        {
                lsReturn = LICENSE_STATUS_INVALID_INPUT;
                goto ErrorReturn;
        }

        pbTemp = pbMessage;
        dwTemp = cbMessage;

        //Assign dwVersion
        pCanonical->dwVersion = *( UNALIGNED DWORD* )pbTemp;
        pbTemp += sizeof(DWORD);
        dwTemp -= sizeof(DWORD);

        //Assign dwSigAlgID
        pCanonical->dwSigAlgID = *( UNALIGNED DWORD* )pbTemp;
        pbTemp += sizeof(DWORD);
        dwTemp -= sizeof(DWORD);

        //Assign dwSignID
        pCanonical->dwKeyAlgID  = *( UNALIGNED DWORD* )pbTemp;
        pbTemp += sizeof(DWORD);
        dwTemp -= sizeof(DWORD);

        //Assign PublicKeyData
        pCanonical->PublicKeyData.wBlobType = *( UNALIGNED WORD* )pbTemp;
        pbTemp += sizeof(WORD);
        dwTemp -= sizeof(WORD);

        if( pCanonical->PublicKeyData.wBlobType != BB_RSA_KEY_BLOB )
        {
                lsReturn = LICENSE_STATUS_INVALID_INPUT;
                goto ErrorReturn;
        }
        pCanonical->PublicKeyData.wBlobLen = *( UNALIGNED WORD* )pbTemp;
        pbTemp += sizeof(WORD);
        dwTemp -= sizeof(WORD);

        if(pCanonical->PublicKeyData.wBlobLen >0)
        {
                if( NULL ==(pCanonical->PublicKeyData.pBlob = (BYTE FAR *)malloc(pCanonical->PublicKeyData.wBlobLen)) )
                {
                        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
                        goto ErrorReturn;
                }
                memset(pCanonical->PublicKeyData.pBlob, 0x00, pCanonical->PublicKeyData.wBlobLen);
                memcpy(pCanonical->PublicKeyData.pBlob, pbTemp, pCanonical->PublicKeyData.wBlobLen);
                pbTemp += pCanonical->PublicKeyData.wBlobLen;
                dwTemp -= pCanonical->PublicKeyData.wBlobLen;
        }

        //Assign SignatureBlob
        pCanonical->SignatureBlob.wBlobType = *( UNALIGNED WORD* )pbTemp;
        pbTemp += sizeof(WORD);
        dwTemp -= sizeof(WORD);

        if( pCanonical->SignatureBlob.wBlobType != BB_RSA_SIGNATURE_BLOB )
        {
                lsReturn = LICENSE_STATUS_INVALID_INPUT;
                goto ErrorReturn;
        }
        pCanonical->SignatureBlob.wBlobLen = *( UNALIGNED WORD* )pbTemp;
        pbTemp += sizeof(WORD);
        dwTemp -= sizeof(WORD);

        if(pCanonical->SignatureBlob.wBlobLen >0)
        {
                if( NULL ==(pCanonical->SignatureBlob.pBlob = (BYTE FAR *)malloc(pCanonical->SignatureBlob.wBlobLen)) )
                {
                        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
                        goto ErrorReturn;
                }
                memset(pCanonical->SignatureBlob.pBlob, 0x00, pCanonical->SignatureBlob.wBlobLen);
                memcpy(pCanonical->SignatureBlob.pBlob, pbTemp, pCanonical->SignatureBlob.wBlobLen);
                pbTemp += pCanonical->SignatureBlob.wBlobLen;
                dwTemp -= pCanonical->SignatureBlob.wBlobLen;
        }
CommonReturn:
        return lsReturn;
ErrorReturn:
        if(pCanonical->PublicKeyData.pBlob)
        {
                free(pCanonical->PublicKeyData.pBlob);
                pCanonical->PublicKeyData.pBlob = NULL;
        }
        if(pCanonical->SignatureBlob.pBlob)
        {
                free(pCanonical->SignatureBlob.pBlob);
                pCanonical->SignatureBlob.pBlob = NULL;
        }
        memset(pCanonical, 0x00, sizeof(Hydra_Server_Cert));
        goto CommonReturn;
}


LICENSE_STATUS
CALL_TYPE
CreateHWID(
           PHWID phwid )
{
#ifdef OS_WINCE
    UUID    uuid;
#endif // OS_WINCE

    OSVERSIONINFO osvInfo;

    if( phwid == NULL )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    memset( phwid, 0x00, sizeof( HWID ) );

#ifdef OS_WINCE

    phwid->dwPlatformID = PLATFORM_WINCE_20;

    if (! OEMGetUUID(&uuid))
    {
        RETAILMSG( 1, ( TEXT( "Unable to get UUID from OEMGetUUID %d\r\n" ), GetLastError() ) );
        return ( LICENSE_STATUS_UNSPECIFIED_ERROR );
    }
    else
    {
        memcpy( &phwid->Data1, &uuid, sizeof(UUID) );

        return( LICENSE_STATUS_OK );
    }

#endif // OS_WINCE

    //
    // use Win32 platform ID
    //

    memset( &osvInfo, 0, sizeof( OSVERSIONINFO ) );
    osvInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
    GetVersionEx( &osvInfo );

    phwid->dwPlatformID = osvInfo.dwPlatformId;

    if (TSRNG_GenerateRandomBits( ( BYTE FAR * )&( phwid->Data1 ), sizeof( DWORD ) )
        && TSRNG_GenerateRandomBits( ( BYTE FAR * )&( phwid->Data2 ), sizeof( DWORD ) )
        && TSRNG_GenerateRandomBits( ( BYTE FAR * )&( phwid->Data3 ), sizeof( DWORD ) )
        && TSRNG_GenerateRandomBits( ( BYTE FAR * )&( phwid->Data4 ), sizeof( DWORD ) ))
    {
        return ( LICENSE_STATUS_OK );
    }
    else
    {
        return ( LICENSE_STATUS_UNSPECIFIED_ERROR );
    }

}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
CALL_TYPE
GenerateClientHWID(
    PHWID   phwid )
{
    HKEY    hKey = NULL;
    LONG    lStatus = 0;
    DWORD   dwDisposition = 0;
    DWORD   dwValueType = 0;
    DWORD   cbHwid = sizeof(HWID);
    BOOL    fReadOnly = FALSE;
    LICENSE_STATUS LicStatus = LICENSE_STATUS_OK;

    if( phwid == NULL )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    memset( phwid, 0x00, sizeof( HWID ) );

    //
    // Try and open the HWID registry key.  If it doesn't already exist then create it.
    //

    lStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            TEXT( "Software\\Microsoft\\MSLicensing\\HardwareID" ),
                            0,
                            KEY_READ,
                            &hKey );

    if( ERROR_SUCCESS != lStatus )
    {
        lStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                              TEXT( "Software\\Microsoft\\MSLicensing\\HardwareID" ),
                              0,
                              TEXT( "Client HWID" ),
                              REG_OPTION_NON_VOLATILE,
                              KEY_READ | KEY_WRITE,
                              NULL,
                              &hKey,
                              &dwDisposition );
    }
    else
    {
        //
        // Indicate that we have opened an existing key read-only
        //

        fReadOnly = TRUE;
        dwDisposition = REG_OPENED_EXISTING_KEY;
    }

    if( lStatus != ERROR_SUCCESS )
    {
        return( LICENSE_STATUS_OPEN_STORE_ERROR );
    }

    //
    // If the key exists, then first try to Read the value of ClientHWID
    //

    if ( dwDisposition == REG_OPENED_EXISTING_KEY )
    {

        lStatus = RegQueryValueEx( hKey, TEXT( "ClientHWID" ), 0, &dwValueType, (PVOID)phwid, &cbHwid );
    }

    if( ( dwDisposition == REG_CREATED_NEW_KEY) || (lStatus != ERROR_SUCCESS) || (cbHwid != sizeof(HWID)) )
    {
        //
        // error reading the HWID value, generate a new one.
        //

        if (fReadOnly)
        {
            //
            // Try to re-open the key read-write
            //

            RegCloseKey(hKey);

            lStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                    TEXT( "Software\\Microsoft\\MSLicensing\\HardwareID" ),
                                    0,
                                    KEY_READ | KEY_WRITE,
                                    &hKey );

            if (lStatus != ERROR_SUCCESS)
            {
                return( LICENSE_STATUS_OPEN_STORE_ERROR );
            }
        }

        LicStatus = CreateHWID(phwid);
        if (LicStatus != LICENSE_STATUS_OK)
        {
            goto cleanup;
        }

        lStatus = RegSetValueEx( hKey, TEXT( "ClientHWID" ), 0, REG_BINARY, ( BYTE FAR * )phwid, sizeof( HWID ) );

        if( lStatus != ERROR_SUCCESS )
        {
            LicStatus = LICENSE_STATUS_WRITE_STORE_ERROR;

            goto cleanup;
        }
    }

cleanup:

    if (NULL != hKey)
        RegCloseKey( hKey );

    return( LicStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\licdebug\debuglib.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    core.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Sep. 5th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES = \
    $(C_DEFINES) \
    $(CLIENT_EXE_CDEFS)

#
# List of sources
#

SOURCES_PLATFORM =

CLIENT_SOURCES_RC = \

CLIENT_SOURCES_COMMON = \
    licdbg.c

CLIENT_SOURCES_LAST  = \

SOURCES = \
    $(CLIENT_SOURCES_RC) \
    $(SOURCES_PLATFORM) \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_LAST)

#
# Precompiled specs
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\hclient\liclient\hcpack.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       hcpack.c
//
//  Contents:   Functions that are used to pack and unpack different messages
//
//  Classes:
//
//  Functions:  PackHydraClientNewLicenseRequest
//              PackHydraClientKeyExchangeInfo
//              PackHydraClientLicenseInfo
//              PackHydraClientPlatformInfo
//              PackHydraClientPlatformChallengeResponse
//              PackLicenseErrorMessage
//              UnPackLicenseErrorMessage
//              UnpackHydraServerLicenseRequest
//              UnPackHydraServerPlatformChallenge
//              UnPackHydraServerNewLicense
//              UnPackHydraServerUpgradeLicense
//              UnpackHydraServerCertificate
//
//  History:    12-19-97  v-sbhatt   Created
//
//----------------------------------------------------------------------------

//
//Includes
//

#include "windows.h"
#ifndef OS_WINCE
#include "stdio.h"
#endif // OS_WINCE
#include "stdlib.h"

#include <tchar.h>

#ifdef OS_WINCE
#include <wincelic.h>
#endif  //OS_WINCE

#include "license.h"
#include "hcpack.h"
#include "licdbg.h"

#define INVALID_INPUT_RETURN lsReturn = LICENSE_STATUS_INVALID_INPUT; LS_LOG_RESULT(lsReturn); goto ErrorReturn

#define EXTENDED_ERROR_CAPABILITY 0x80

//Copies a binary blob into a byte buffer. Does not check for any abnormal
//condition. After copying buffer points to the end of the blob
static VOID CopyBinaryBlob(
                           BYTE FAR *   pbBuffer,
                           PBinary_Blob pbbBlob,
                           DWORD FAR *  pdwCount
                           )
{
    *pdwCount = 0;

    //First copy the wBlobType data;
    memcpy(pbBuffer, &pbbBlob->wBlobType, sizeof(WORD));
    pbBuffer += sizeof(WORD);
    *pdwCount += sizeof(WORD);

    //Copy the wBlobLen data
    memcpy(pbBuffer, &pbbBlob->wBlobLen, sizeof(WORD));
    pbBuffer += sizeof(WORD);
    *pdwCount += sizeof(WORD);

    if( (pbbBlob->wBlobLen >0) && (pbbBlob->pBlob != NULL) )
    {
        //Copy the actual data
        memcpy(pbBuffer, pbbBlob->pBlob, pbbBlob->wBlobLen);
        pbBuffer += pbbBlob->wBlobLen;
        *pdwCount += pbbBlob->wBlobLen;
    }
}


//Function implementation

/***************************************************************************************
*   Function    : PackHydraClientNewLicenseRequest
*   Purpose     : This function takes a pointer to a Hydra_Client_New_License_Request
*                 structure and copies the data to the buffer pointed by pbBuffer.
*                 pcbBuffer should point the size of the buffer pointed by pbBuffer.
*                 After the function returns, pcbBuffer contains the no. of bytes copied
*                 in the buffer. If pbBuffer is NULL, the fucntion returns the size of
*                 the pbBuffer to be allocated.
*   Returns     : LICENSE_STATUS
****************************************************************************************/


LICENSE_STATUS
PackHydraClientNewLicenseRequest(
            IN      PHydra_Client_New_License_Request   pCanonical,
            IN      BOOL                                fExtendedError,
            OUT     BYTE FAR *                          pbBuffer,
            IN OUT  DWORD FAR *                         pcbBuffer
            )
{
    LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *      pbTemp = NULL;
    DWORD       dwCount = 0;
    Preamble    Header;

    LS_BEGIN(TEXT("PackHydraClientNewLicenseRequest"));
    //Check if the inputs are valid or not!
    if(pCanonical == NULL)
    {
        INVALID_INPUT_RETURN;;
    }

    if( pbBuffer == NULL && pcbBuffer == NULL )
    {
        INVALID_INPUT_RETURN;;
    }

    //Initialize Message Header
    Header.bMsgType = HC_NEW_LICENSE_REQUEST;
    Header.bVersion = PREAMBLE_VERSION_3_0;
    if( fExtendedError == TRUE)
    {
        Header.bVersion |= EXTENDED_ERROR_CAPABILITY;
    }
    Header.wMsgSize = 0;

    //Calculate the size of the message and place the data in Header.wMsgSize.
    //Start with Preamble size
    Header.wMsgSize += sizeof(Preamble);

    //dwPrefKeyExchangeAlg
    Header.wMsgSize += sizeof(pCanonical->dwPrefKeyExchangeAlg);

    //dwPlatformID
    Header.wMsgSize += sizeof(pCanonical->dwPlatformID);

    //Client Random
    Header.wMsgSize += LICENSE_RANDOM;

    //EncryptedPreMasterSecret
    Header.wMsgSize += sizeof(pCanonical->EncryptedPreMasterSecret.wBlobType) +
                       sizeof(pCanonical->EncryptedPreMasterSecret.wBlobLen) +
                       pCanonical->EncryptedPreMasterSecret.wBlobLen;

    //
    // client user name and machine name
    //

    Header.wMsgSize += sizeof(pCanonical->ClientUserName.wBlobType) +
                       sizeof(pCanonical->ClientUserName.wBlobLen) +
                       pCanonical->ClientUserName.wBlobLen;

    Header.wMsgSize += sizeof(pCanonical->ClientMachineName.wBlobType) +
                       sizeof(pCanonical->ClientMachineName.wBlobLen) +
                       pCanonical->ClientMachineName.wBlobLen;

    if(pbBuffer == NULL)
    {
        *pcbBuffer = (DWORD)Header.wMsgSize;
        LS_RETURN(lsReturn);
        goto CommonReturn;
    }
    else if(*pcbBuffer < (DWORD)Header.wMsgSize)
    {
        lsReturn = LICENSE_STATUS_INSUFFICIENT_BUFFER;
        LS_RETURN(lsReturn);
        goto ErrorReturn;
    }
    pbTemp = pbBuffer;
    *pcbBuffer = 0;

    //Now start copying different members of the New License structure to the
    //buffer specified by the caller

    //first copy the Header into the buffer
    memcpy(pbTemp, &Header, sizeof(Preamble));
    pbTemp += sizeof(Preamble);
    *pcbBuffer += sizeof(Preamble);

    //Copy the dwPrefKeyExchangeAlg parameter
    memcpy(pbTemp, &pCanonical->dwPrefKeyExchangeAlg, sizeof(pCanonical->dwPrefKeyExchangeAlg));
    pbTemp += sizeof(pCanonical->dwPrefKeyExchangeAlg);
    *pcbBuffer += sizeof(pCanonical->dwPrefKeyExchangeAlg);

    //Copy PlatformID;
    memcpy(pbTemp, &pCanonical->dwPlatformID, sizeof(pCanonical->dwPlatformID));
    pbTemp += sizeof(pCanonical->dwPlatformID);
    *pcbBuffer += sizeof(pCanonical->dwPlatformID);


    //Copy ClientRandom
    memcpy(pbTemp, pCanonical->ClientRandom, LICENSE_RANDOM);
    pbTemp += LICENSE_RANDOM;
    *pcbBuffer += LICENSE_RANDOM;

    //Copy EncryptedPreMasterSecret Blob
    CopyBinaryBlob(pbTemp, &pCanonical->EncryptedPreMasterSecret, &dwCount);
    pbTemp += dwCount;
    *pcbBuffer += dwCount;

    //
    // copy client user name
    //

    CopyBinaryBlob(pbTemp, &pCanonical->ClientUserName, &dwCount);
    pbTemp += dwCount;
    *pcbBuffer += dwCount;

    //
    // copy client machine name
    //

    CopyBinaryBlob(pbTemp, &pCanonical->ClientMachineName, &dwCount);
    pbTemp += dwCount;
    *pcbBuffer += dwCount;

    LS_LOG_RESULT(lsReturn);
CommonReturn:
    //return    lsReturn;
    LS_RETURN(lsReturn);

ErrorReturn:
    goto CommonReturn;
}


/***************************************************************************************
*   Function    : PackHydraClientLicenseInfo
*   Purpose     : This function takes a pointer to a Hydra_Client_License_Info structure
*                 and copies the data to the buffer pointed by pbBuffer. pcbBuffer
*                 should point the size of the buffer pointed by pbBuffer. After the
*                 function returns, pcbBuffer contains the no. of bytes copied in the
*                 buffer. If pbBuffer is NULL, the fucntion returns the size of the
*                 pbBuffer to be allocated
*   Returns     : LICENSE_STATUS
****************************************************************************************/

LICENSE_STATUS
PackHydraClientLicenseInfo(
            IN      PHydra_Client_License_Info      pCanonical,
            IN      BOOL                            fExtendedError,
            OUT     BYTE FAR *                      pbBuffer,
            IN OUT  DWORD FAR *                     pcbBuffer
            )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *          pbTemp; //To be used while copying the data
    Preamble        Header;
    DWORD           dwCount = 0;
    //Check if the inputs are valid or not!

    LS_BEGIN(TEXT("PackHydraClientLicenseInfo\n"));
    if(pCanonical == NULL)
    {
        INVALID_INPUT_RETURN;
    }

    if( pbBuffer == NULL && pcbBuffer == NULL )
    {
        INVALID_INPUT_RETURN;
    }

    //Initialize Message Header
    Header.bMsgType = HC_LICENSE_INFO;
    Header.bVersion = PREAMBLE_VERSION_3_0;
    if(fExtendedError == TRUE)
    {
        Header.bVersion |= EXTENDED_ERROR_CAPABILITY;
    }
    Header.wMsgSize = 0;

    //Calculate the size of the message and place the data in Header.wMsgSize.
    //Start with Preamble size
    Header.wMsgSize += sizeof(Preamble);

    //dwPrefKeyExchangeAlg
    Header.wMsgSize += sizeof(pCanonical->dwPrefKeyExchangeAlg);

    //dwPlatformID
    Header.wMsgSize += sizeof(pCanonical->dwPlatformID);

    //ClientRandom
    Header.wMsgSize += LICENSE_RANDOM;

    //EncryptedPreMasterSecret
    Header.wMsgSize += sizeof(pCanonical->EncryptedPreMasterSecret.wBlobType) +
                       sizeof(pCanonical->EncryptedPreMasterSecret.wBlobLen) +
                       pCanonical->EncryptedPreMasterSecret.wBlobLen;


    //Add the license Info
    Header.wMsgSize += sizeof(pCanonical->LicenseInfo.wBlobType) +
                       sizeof(pCanonical->LicenseInfo.wBlobLen) +
                       pCanonical->LicenseInfo.wBlobLen;

    //Encrypted HWID
    Header.wMsgSize += sizeof(pCanonical->EncryptedHWID.wBlobType) +
                       sizeof(pCanonical->EncryptedHWID.wBlobLen) +
                       pCanonical->EncryptedHWID.wBlobLen;

    //MACData
    Header.wMsgSize += LICENSE_MAC_DATA;

    //If the input buffer is null, inform the user to allocate a buffer of size
    //*pcbBuffer!
    if(pbBuffer == NULL)
    {
        *pcbBuffer = (DWORD)Header.wMsgSize;
        LS_LOG_RESULT(lsReturn);
        goto CommonReturn;
    }
    //else, check if the allocated buffer size is more than the required!
    else if(*pcbBuffer < (DWORD)Header.wMsgSize)
    {
        lsReturn = LICENSE_STATUS_INSUFFICIENT_BUFFER;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    pbTemp = pbBuffer;
    *pcbBuffer = 0;

    //Now start copying different members of the New License structure to the
    //buffer specified by the caller

    //first copy the Header into the buffer
    memcpy(pbTemp, &Header, sizeof(Preamble));
    pbTemp += sizeof(Preamble);
    *pcbBuffer += sizeof(Preamble);

    //Copy the dwPrefKeyExchangeAlg parameter
    memcpy(pbTemp, &pCanonical->dwPrefKeyExchangeAlg, sizeof(pCanonical->dwPrefKeyExchangeAlg));
    pbTemp += sizeof(pCanonical->dwPrefKeyExchangeAlg);
    *pcbBuffer += sizeof(pCanonical->dwPrefKeyExchangeAlg);

    //Copy the dwPlatformID
    memcpy(pbTemp, &pCanonical->dwPlatformID, sizeof(pCanonical->dwPlatformID));
    pbTemp += sizeof(pCanonical->dwPlatformID);
    *pcbBuffer += sizeof(pCanonical->dwPlatformID);

    //Copy ClientRandom
    memcpy(pbTemp, pCanonical->ClientRandom, LICENSE_RANDOM);
    pbTemp += LICENSE_RANDOM;
    *pcbBuffer += LICENSE_RANDOM;

    //Copy EncryptedPreMasterSecret Blob
    CopyBinaryBlob(pbTemp, &pCanonical->EncryptedPreMasterSecret, &dwCount);
    pbTemp += dwCount;
    *pcbBuffer += dwCount;

    //Copy LicenseInfo
    CopyBinaryBlob(pbTemp, &pCanonical->LicenseInfo, &dwCount);
    pbTemp += dwCount;
    *pcbBuffer += dwCount;

    //Copy EncryptedHWID
    CopyBinaryBlob(pbTemp, &pCanonical->EncryptedHWID, &dwCount);
    pbTemp += dwCount;
    *pcbBuffer += dwCount;

    //Copy MACData
    memcpy(pbTemp, pCanonical->MACData, LICENSE_MAC_DATA);
    pbTemp += LICENSE_MAC_DATA;
    *pcbBuffer += LICENSE_MAC_DATA;

    LS_LOG_RESULT(lsReturn);
CommonReturn:
    //return lsReturn;
    LS_RETURN(lsReturn);
ErrorReturn:
    goto CommonReturn;
}


/****************************************************************************************
*   Function    : PackHydraClientPlatformChallengeResponse
*   Purpose     : This function takes a pointer to a Hydra_Client_Platform_Info structure
*                 and copies the data to the buffer pointed by pbBuffer. pcbBuffer should
*                 point the size of the buffer pointed by pbBuffer. After the function
*                 returns, pcbBuffer contains the no. of bytes copied in the buffer.
*                 If pbBuffer is NULL, the fucntion returns the size of the pbBuffer to
*                 be allocated
*   Returns     : LICENSE_STATUS
******************************************************************************************/


LICENSE_STATUS
PackHydraClientPlatformChallengeResponse(
            IN      PHydra_Client_Platform_Challenge_Response   pCanonical,
            IN      BOOL                                        fExtendedError,
            OUT     BYTE FAR *                                  pbBuffer,
            IN OUT  DWORD FAR *                                 pcbBuffer
            )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *          pbTemp; //To be used while copying the data
    Preamble        Header;
    DWORD           dwCount = 0;
    //Check if the inputs are valid or not!

    LS_BEGIN(TEXT("PackHydraClientPlatformChallengeResponse\n"));

    if(pCanonical == NULL)
    {
        INVALID_INPUT_RETURN;
    }

    if( pbBuffer == NULL && pcbBuffer == NULL )
    {
        INVALID_INPUT_RETURN;
    }

    //Initialize Message Header
    Header.bMsgType = HC_PLATFORM_CHALENGE_RESPONSE;
    Header.bVersion = PREAMBLE_VERSION_3_0;
    if(fExtendedError == TRUE)
    {
        Header.bVersion |= EXTENDED_ERROR_CAPABILITY;
    }
    Header.wMsgSize = 0;

    //Calculate the size of the message and place the data in Header.wMsgSize.
    //Start with Preamble size
    Header.wMsgSize += sizeof(Preamble);

    //EncryptedChallengeResponse
    Header.wMsgSize += sizeof(pCanonical->EncryptedChallengeResponse.wBlobType) +
                       sizeof(pCanonical->EncryptedChallengeResponse.wBlobLen) +
                       pCanonical->EncryptedChallengeResponse.wBlobLen;

    //Encrypted HWID
    Header.wMsgSize += sizeof(pCanonical->EncryptedHWID.wBlobType) +
                       sizeof(pCanonical->EncryptedHWID.wBlobLen) +
                       pCanonical->EncryptedHWID.wBlobLen;

    //MACData
    Header.wMsgSize += LICENSE_MAC_DATA;

    if(pbBuffer == NULL)
    {
        *pcbBuffer = (DWORD)Header.wMsgSize;
        LS_LOG_RESULT(lsReturn);
        goto CommonReturn;
    }
    else if(*pcbBuffer < (DWORD)Header.wMsgSize)
    {
        lsReturn = LICENSE_STATUS_INSUFFICIENT_BUFFER;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    pbTemp = pbBuffer;
    *pcbBuffer = 0;

    //Now start copying different members of the New License structure to the
    //buffer specified by the caller

    //first copy the Header into the buffer
    memcpy(pbTemp, &Header, sizeof(Preamble));
    pbTemp += sizeof(Preamble);
    *pcbBuffer += sizeof(Preamble);

    //Copy LicenseInfo
    CopyBinaryBlob(pbTemp, &pCanonical->EncryptedChallengeResponse, &dwCount);
    pbTemp += dwCount;
    *pcbBuffer += dwCount;

    //Copy EncryptedHWID
    CopyBinaryBlob(pbTemp, &pCanonical->EncryptedHWID, &dwCount);
    pbTemp += dwCount;
    *pcbBuffer += dwCount;

    //Copy MACData
    memcpy(pbTemp, pCanonical->MACData, LICENSE_MAC_DATA);
    pbTemp += LICENSE_MAC_DATA;
    //CopyBinaryBlob(pbTemp, &pCanonical->MACData, &dwCount);
    *pcbBuffer += LICENSE_MAC_DATA;

    LS_LOG_RESULT(lsReturn);
CommonReturn:
    //return lsReturn;
    LS_RETURN(lsReturn);
ErrorReturn:
    goto CommonReturn;
}

/****************************************************************************************
*   Funtion     : PackLicenseErrorMessage
*   Purpose     : This function takes a pointer to a License_Error_Message structure
*                 and copies the data to the buffer pointed by pbBuffer. pcbBuffer should
*                 point the size of the buffer pointed by pbBuffer. After the function
*                 returns, pcbBuffer contains the no. of bytes copied in the buffer.
*                 If pbBuffer is NULL, the fucntion returns the size of the pbBuffer to
*                 be allocated
*   Return      : LICENSE_STATUS
*****************************************************************************************/

LICENSE_STATUS
PackLicenseErrorMessage(
            IN      PLicense_Error_Message          pCanonical,
            IN      BOOL                            fExtendedError,
            OUT     BYTE FAR *                      pbBuffer,
            IN OUT  DWORD FAR *                     pcbBuffer
            )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *          pbTemp; //To be used while copying the data
    Preamble        Header;
    DWORD           dwCount = 0;

    LS_BEGIN(TEXT("PackLicenseErrorMessage\n"));

    //Check if the inputs are valid or not!
    if(pCanonical == NULL)
    {
        INVALID_INPUT_RETURN;
    }

    if( pbBuffer == NULL && pcbBuffer == NULL )
    {
        INVALID_INPUT_RETURN;
    }

    //Initialize Message Header
    Header.bMsgType = GM_ERROR_ALERT;
    Header.bVersion = PREAMBLE_VERSION_3_0;
    if(fExtendedError == TRUE)
    {
        Header.bVersion |= EXTENDED_ERROR_CAPABILITY;
    }
    Header.wMsgSize = 0;

    //Calculate the size of the message and place the data in Header.wMsgSize.
    //Start with Preamble size
    Header.wMsgSize += sizeof(Preamble);

    //dwErrorCode
    Header.wMsgSize += sizeof(pCanonical->dwErrorCode);

    //dwStateTransition
    Header.wMsgSize += sizeof(pCanonical->dwStateTransition);

    //bbErrorInfo
    Header.wMsgSize += sizeof(pCanonical->bbErrorInfo.wBlobType) +
                       sizeof(pCanonical->bbErrorInfo.wBlobLen) +
                       pCanonical->bbErrorInfo.wBlobLen;

    if(pbBuffer == NULL)
    {
        *pcbBuffer = (DWORD)Header.wMsgSize;
        LS_LOG_RESULT(lsReturn);
        goto CommonReturn;
    }
    else if(*pcbBuffer < (DWORD)Header.wMsgSize)
    {
        lsReturn = LICENSE_STATUS_INSUFFICIENT_BUFFER;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    pbTemp = pbBuffer;
    *pcbBuffer = 0;

    //Now start copying different members of the New License structure to the
    //buffer specified by the caller

    //first copy the Header into the buffer
    memcpy(pbTemp, &Header, sizeof(Preamble));
    pbTemp += sizeof(Preamble);
    *pcbBuffer += sizeof(Preamble);

    //Copy dwErrorCode
    memcpy(pbTemp, &pCanonical->dwErrorCode, sizeof(pCanonical->dwErrorCode));
    pbTemp += sizeof(pCanonical->dwErrorCode);
    *pcbBuffer += sizeof(pCanonical->dwErrorCode);

    //Copy dwStateTransition
    memcpy(pbTemp, &pCanonical->dwStateTransition, sizeof(pCanonical->dwStateTransition));
    pbTemp += sizeof(pCanonical->dwStateTransition);
    *pcbBuffer += sizeof(pCanonical->dwStateTransition);

    //Copy bbErrorInfo
    CopyBinaryBlob(pbTemp, &pCanonical->bbErrorInfo, &dwCount);
    pbTemp += dwCount;
    *pcbBuffer += dwCount;

    LS_LOG_RESULT(lsReturn);
CommonReturn:
    LS_RETURN(lsReturn);
    //return lsReturn;
ErrorReturn:
    goto CommonReturn;
}

/****************************************************************************************
*   Function : UnpackLicenseErrorMessage
*   Purpose  : To unpack a binary blob into a License_Error_Message structure.
*   Note     : The caller should initialize the pointer. All the necessary allocation is
*              done by the function itself.
*              The caller should free all the memory components once it is no longer needed.
*   Return   : License_Status
*****************************************************************************************/

LICENSE_STATUS
UnPackLicenseErrorMessage(
            IN      BYTE FAR *                      pbMessage,
            IN      DWORD                           cbMessage,
            OUT     PLicense_Error_Message          pCanonical
            )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *          pbTemp;
    DWORD           dwTemp;
    DWORD           dwSize;

    LS_BEGIN(TEXT("UnpackLicenseErrorMessage\n"));

    if(pbMessage == NULL)
    {
        INVALID_INPUT_RETURN;
    }

    if(pCanonical == NULL)
    {
        INVALID_INPUT_RETURN;
    }

    //Memset pCanonical structure to zero    
    memset(pCanonical, 0x00, sizeof(License_Error_Message));


    LS_DUMPSTRING(cbMessage, pbMessage);

    pbTemp = pbMessage;
    dwTemp = cbMessage;

    if (dwTemp < 2 * sizeof(DWORD))
    {
        INVALID_INPUT_RETURN;
    }

    //Assign dwErrorCode

    pCanonical->dwErrorCode = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    //Assign dwStateTransition
    pCanonical->dwStateTransition = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    if (dwTemp < 2 * sizeof(WORD))
    {
        INVALID_INPUT_RETURN;
    }

    pCanonical->bbErrorInfo.wBlobType = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    pCanonical->bbErrorInfo.wBlobLen = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    dwSize = pCanonical->bbErrorInfo.wBlobLen;

    if(dwSize > dwTemp)
    {
        INVALID_INPUT_RETURN;
    }

    if(pCanonical->bbErrorInfo.wBlobLen>0)
    {
        if( NULL == (pCanonical->bbErrorInfo.pBlob = (BYTE FAR *)malloc(pCanonical->bbErrorInfo.wBlobLen)) )
        {
            pCanonical->bbErrorInfo.wBlobLen = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        memset(pCanonical->bbErrorInfo.pBlob, 0x00, pCanonical->bbErrorInfo.wBlobLen);
        memcpy(pCanonical->bbErrorInfo.pBlob, pbTemp, pCanonical->bbErrorInfo.wBlobLen);
    }
    else
    {
        pCanonical->bbErrorInfo.pBlob = NULL;
    }


    LS_LOG_RESULT(lsReturn);

ErrorReturn:

    LS_RETURN(lsReturn);
}


/****************************************************************************************
*   Function : UnpackHydraServerLicenseRequest
*   Purpose  : To unpack a binary blob into a Hydra_Server_License_Request structure.
*   Note     : The caller should initialize the output pointer. All the necessary
*              allocation for different structure components is done by the function itself.
*              The caller should free all the memory components once it is no longer needed.
*   Return   : License_Status
*****************************************************************************************/


LICENSE_STATUS
UnpackHydraServerLicenseRequest(
            IN      BYTE FAR *                      pbMessage,
            IN      DWORD                           cbMessage,
            OUT     PHydra_Server_License_Request   pCanonical
            )
{
    LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *pbTemp = NULL;
    DWORD       dwTemp = 0;
    DWORD       i = 0;

    LS_BEGIN(TEXT("UnpackHydraServerLicenseRequest\n"));

    if(pbMessage == NULL)
    {
        INVALID_INPUT_RETURN;
    }

    if(pCanonical == NULL)
    {
        INVALID_INPUT_RETURN;
    }

    LS_DUMPSTRING(cbMessage, pbMessage);

    pbTemp = pbMessage;
    dwTemp = cbMessage;

    if (dwTemp < LICENSE_RANDOM)
    {
        INVALID_INPUT_RETURN;
    }

    //Copy Server Random
    memcpy(pCanonical->ServerRandom, pbTemp, LICENSE_RANDOM);
    pbTemp += LICENSE_RANDOM;
    dwTemp -= LICENSE_RANDOM;

    if (dwTemp < 2 * sizeof(DWORD))
    {
        INVALID_INPUT_RETURN;
    }

    //Copy the ProductInfo structure
    pCanonical->ProductInfo.dwVersion = *( UNALIGNED  DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    pCanonical->ProductInfo.cbCompanyName = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    if(pCanonical->ProductInfo.cbCompanyName>0)
    {
        if(dwTemp < pCanonical->ProductInfo.cbCompanyName)
        {
            INVALID_INPUT_RETURN;
        }

        if( NULL == (pCanonical->ProductInfo.pbCompanyName = (BYTE FAR *)malloc(pCanonical->ProductInfo.cbCompanyName)) )
        {
            pCanonical->ProductInfo.cbCompanyName = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }

        memcpy(pCanonical->ProductInfo.pbCompanyName, pbTemp, pCanonical->ProductInfo.cbCompanyName);
        pbTemp += pCanonical->ProductInfo.cbCompanyName;
        dwTemp -= pCanonical->ProductInfo.cbCompanyName;
    }
    
    if(dwTemp < sizeof(DWORD))
    {
        INVALID_INPUT_RETURN;
    }

    pCanonical->ProductInfo.cbProductID = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    if(pCanonical->ProductInfo.cbProductID>0)
    {
        if(dwTemp < pCanonical->ProductInfo.cbProductID)
        {
            INVALID_INPUT_RETURN;
        }

        if( NULL == (pCanonical->ProductInfo.pbProductID = (BYTE FAR *)malloc(pCanonical->ProductInfo.cbProductID)) )
        {
            pCanonical->ProductInfo.cbProductID = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }

        memcpy(pCanonical->ProductInfo.pbProductID, pbTemp, pCanonical->ProductInfo.cbProductID);

        pbTemp += pCanonical->ProductInfo.cbProductID;
        dwTemp -= pCanonical->ProductInfo.cbProductID;
    }
    
    if(dwTemp < sizeof(WORD)*2)
    {
        INVALID_INPUT_RETURN;
    }

    //Copy KeyExchngList
    pCanonical->KeyExchngList.wBlobType = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    pCanonical->KeyExchngList.wBlobLen = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    if( pCanonical->KeyExchngList.wBlobLen > 0 )
    {
        if(dwTemp < pCanonical->KeyExchngList.wBlobLen)
        {
            INVALID_INPUT_RETURN;
        }

        if( NULL == (pCanonical->KeyExchngList.pBlob = (BYTE FAR *)malloc(pCanonical->KeyExchngList.wBlobLen)) )
        {
            pCanonical->KeyExchngList.wBlobLen = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }

        memcpy(pCanonical->KeyExchngList.pBlob, pbTemp, pCanonical->KeyExchngList.wBlobLen);

        pbTemp += pCanonical->KeyExchngList.wBlobLen;
        dwTemp -= pCanonical->KeyExchngList.wBlobLen;
    }
    
    if(dwTemp < sizeof(WORD)*2)
    {
        INVALID_INPUT_RETURN;
    }

    //Copy ServerCert
    pCanonical->ServerCert.wBlobType = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    pCanonical->ServerCert.wBlobLen = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    if(pCanonical->ServerCert.wBlobLen >0)
    {
        if(dwTemp < pCanonical->ServerCert.wBlobLen)
        {
            INVALID_INPUT_RETURN;
        }

        if( NULL == (pCanonical->ServerCert.pBlob = (BYTE FAR *)malloc(pCanonical->ServerCert.wBlobLen)) )
        {
            pCanonical->ServerCert.wBlobLen = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }

        memcpy(pCanonical->ServerCert.pBlob, pbTemp, pCanonical->ServerCert.wBlobLen);

        pbTemp += pCanonical->ServerCert.wBlobLen;
        dwTemp -= pCanonical->ServerCert.wBlobLen;
    }
    
    if(dwTemp < sizeof(DWORD))
    {
        INVALID_INPUT_RETURN;
    }

    //Copy the scopelist
    pCanonical->ScopeList.dwScopeCount = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof( DWORD );
    dwTemp -= sizeof( DWORD );
    
    if(dwTemp < pCanonical->ScopeList.dwScopeCount*sizeof(Binary_Blob))
    {
        pCanonical->ScopeList.dwScopeCount = 0;
        INVALID_INPUT_RETURN;
    }

    if( NULL == (pCanonical->ScopeList.Scopes = (PBinary_Blob)malloc(pCanonical->ScopeList.dwScopeCount*sizeof(Binary_Blob))) )
    {
        pCanonical->ScopeList.dwScopeCount = 0;

        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    memset(pCanonical->ScopeList.Scopes, 0x00, pCanonical->ScopeList.dwScopeCount*sizeof(Binary_Blob));

    for(i = 0; i<pCanonical->ScopeList.dwScopeCount; i++ )
    {
        if(dwTemp < sizeof(WORD)*2)
        {
            pCanonical->ScopeList.dwScopeCount = i;
            INVALID_INPUT_RETURN;
        }

        pCanonical->ScopeList.Scopes[i].wBlobType = *( UNALIGNED WORD* )pbTemp;

        pbTemp += sizeof(WORD);
        dwTemp -= sizeof(WORD);

        pCanonical->ScopeList.Scopes[i].wBlobLen = *( UNALIGNED WORD* )pbTemp;

        pbTemp += sizeof(WORD);
        dwTemp -= sizeof(WORD);
        
        if(dwTemp < pCanonical->ScopeList.Scopes[i].wBlobLen)
        {
            pCanonical->ScopeList.dwScopeCount = i;
            INVALID_INPUT_RETURN;
        }

        if( NULL ==(pCanonical->ScopeList.Scopes[i].pBlob = (BYTE FAR *)malloc(pCanonical->ScopeList.Scopes[i].wBlobLen)) )
        {
            pCanonical->ScopeList.Scopes[i].wBlobLen = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }

        memcpy(pCanonical->ScopeList.Scopes[i].pBlob, pbTemp, pCanonical->ScopeList.Scopes[i].wBlobLen);

        pbTemp += pCanonical->ScopeList.Scopes[i].wBlobLen;
        dwTemp -= pCanonical->ScopeList.Scopes[i].wBlobLen;

    }

    LS_LOG_RESULT(lsReturn);
    LS_RETURN(lsReturn);

ErrorReturn:

    if (pCanonical)
    {
        if(pCanonical->ProductInfo.pbCompanyName)
        {
            free(pCanonical->ProductInfo.pbCompanyName);
            pCanonical->ProductInfo.pbCompanyName = NULL;
        }

        if(pCanonical->ProductInfo.pbProductID)
        {
            free(pCanonical->ProductInfo.pbProductID);
            pCanonical->ProductInfo.pbProductID = NULL;
        }

        if(pCanonical->KeyExchngList.pBlob)
        {
            free(pCanonical->KeyExchngList.pBlob);
            pCanonical->KeyExchngList.pBlob = NULL;
        }

        if(pCanonical->ServerCert.pBlob)
        {
            free(pCanonical->ServerCert.pBlob);
            pCanonical->ServerCert.pBlob = NULL;
        }

        for(i = 0; i<pCanonical->ScopeList.dwScopeCount; i++ )
        {
            if(pCanonical->ScopeList.Scopes[i].pBlob)
            {
                free(pCanonical->ScopeList.Scopes[i].pBlob);
                pCanonical->ScopeList.Scopes[i].pBlob = NULL;
            }
        }
        if(pCanonical->ScopeList.Scopes)
        {
            free(pCanonical->ScopeList.Scopes);
            pCanonical->ScopeList.Scopes = NULL;
        }
    }

    LS_RETURN(lsReturn);
}

/****************************************************************************************
*   Function : UnpackHydraPlatformChallenge
*   Purpose  : To unpack a binary blob into a Hydra_Server_Platform_Challenge structure.
*   Note     : The caller should initialize the output pointer. All the necessary
*              allocation for different structure components is done by the function itself.
*              The caller should free all the memory components once it is no longer needed.
*   Return   : License_Status
*****************************************************************************************/




LICENSE_STATUS
UnPackHydraServerPlatformChallenge(
            IN      BYTE FAR *                          pbMessage,
            IN      DWORD                               cbMessage,
            OUT     PHydra_Server_Platform_Challenge    pCanonical
            )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *      pbTemp = NULL;
    DWORD       dwTemp = 0;

    LS_BEGIN(TEXT("UnpackHydraServerPlatformChallenge\n"));

    if(pbMessage == NULL)
    {
        INVALID_INPUT_RETURN;
    }
    if(pCanonical == NULL)
    {
        INVALID_INPUT_RETURN;
    }

    LS_DUMPSTRING(cbMessage, pbMessage);

    pbTemp = pbMessage;
    dwTemp = cbMessage;

    if (dwTemp < sizeof(DWORD))
    {
        INVALID_INPUT_RETURN;
    }

    //Assign dwConnectFlags
    pCanonical->dwConnectFlags = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    if (dwTemp < 2 * sizeof(WORD))
    {
        INVALID_INPUT_RETURN;
    }

    //Assign EncryptedPlatformChallenge
    pCanonical->EncryptedPlatformChallenge.wBlobType = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    pCanonical->EncryptedPlatformChallenge.wBlobLen = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    if(pCanonical->EncryptedPlatformChallenge.wBlobLen >0)
    {
        if (dwTemp < pCanonical->EncryptedPlatformChallenge.wBlobLen)
        {
            INVALID_INPUT_RETURN;
        }

        if( NULL == (pCanonical->EncryptedPlatformChallenge.pBlob = (BYTE FAR *)malloc(pCanonical->EncryptedPlatformChallenge.wBlobLen)) )
        {
            pCanonical->EncryptedPlatformChallenge.wBlobLen = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }

        memcpy(pCanonical->EncryptedPlatformChallenge.pBlob, pbTemp, pCanonical->EncryptedPlatformChallenge.wBlobLen);

        pbTemp += pCanonical->EncryptedPlatformChallenge.wBlobLen;
        dwTemp -= pCanonical->EncryptedPlatformChallenge.wBlobLen;
    }

    if(dwTemp < LICENSE_MAC_DATA)
    {
        INVALID_INPUT_RETURN;
    }

    //Assign MACData
    memcpy(pCanonical->MACData, pbTemp, LICENSE_MAC_DATA);
    pbTemp += LICENSE_MAC_DATA;
    dwTemp -= LICENSE_MAC_DATA;

    LS_LOG_RESULT(lsReturn);
    LS_RETURN(lsReturn);

ErrorReturn:
    if (pCanonical)
    {
        if(pCanonical->EncryptedPlatformChallenge.pBlob)
        {
            free(pCanonical->EncryptedPlatformChallenge.pBlob);
            pCanonical->EncryptedPlatformChallenge.pBlob = NULL;
        }
    }

    LS_RETURN(lsReturn);
}

/****************************************************************************************
*   Function : UnpackHydraServerNewLicense
*   Purpose  : To unpack a binary blob into a Hydra_Server_New_License structure.
*   Note     : The caller should initialize the output pointer. All the necessary
*              allocation for different structure components is done by the function itself.
*              The caller should free all the memory components once it is no longer needed.
*   Return   : License_Status
*****************************************************************************************/


LICENSE_STATUS
UnPackHydraServerNewLicense(
            IN      BYTE FAR *                      pbMessage,
            IN      DWORD                           cbMessage,
            OUT     PHydra_Server_New_License       pCanonical
            )
{
    LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *  pbTemp = NULL;
    DWORD   dwTemp = 0;

    LS_BEGIN(TEXT("UnpackHydraServerNewLicense\n"));

    if( (pbMessage == NULL) || (pCanonical == NULL ) )
    {
        INVALID_INPUT_RETURN;
    }

    memset(pCanonical, 0x00, sizeof(Hydra_Server_New_License));

    LS_DUMPSTRING(cbMessage, pbMessage);

    pbTemp = pbMessage;
    dwTemp = cbMessage;

    if (dwTemp < 2 * sizeof(WORD))
    {
        INVALID_INPUT_RETURN;
    }

    //Assign EncryptedNewLicenseInfo
    pCanonical->EncryptedNewLicenseInfo.wBlobType = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    pCanonical->EncryptedNewLicenseInfo.wBlobLen = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    if(pCanonical->EncryptedNewLicenseInfo.wBlobLen > 0)
    {
        if (dwTemp < pCanonical->EncryptedNewLicenseInfo.wBlobLen)
        {
            INVALID_INPUT_RETURN;
        }

        if( NULL == (pCanonical->EncryptedNewLicenseInfo.pBlob = (BYTE FAR *)malloc(pCanonical->EncryptedNewLicenseInfo.wBlobLen)) )
        {
            pCanonical->EncryptedNewLicenseInfo.wBlobLen = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }

        memcpy(pCanonical->EncryptedNewLicenseInfo.pBlob, pbTemp, pCanonical->EncryptedNewLicenseInfo.wBlobLen);

        pbTemp += pCanonical->EncryptedNewLicenseInfo.wBlobLen;
        dwTemp -= pCanonical->EncryptedNewLicenseInfo.wBlobLen;
    }

    if(dwTemp < LICENSE_MAC_DATA)
    {
        INVALID_INPUT_RETURN;
    }

    //Copy MACData
    memcpy(pCanonical->MACData, pbTemp, LICENSE_MAC_DATA);
    pbTemp += LICENSE_MAC_DATA;
    dwTemp -= LICENSE_MAC_DATA;

    LS_LOG_RESULT(lsReturn);
    LS_RETURN(lsReturn);

ErrorReturn:
    if (pCanonical)
    {
        if(pCanonical->EncryptedNewLicenseInfo.pBlob)
        {
            free(pCanonical->EncryptedNewLicenseInfo.pBlob);
            pCanonical->EncryptedNewLicenseInfo.pBlob = NULL;
        }
    }

    LS_RETURN(lsReturn);
}


/****************************************************************************************
*   Function : UnpackHydraServerUpgradeLicense
*   Purpose  : To unpack a binary blob into a Hydra_Server_Upgrade_License structure.
*   Note     : The caller should initialize the output pointer. All the necessary
*              allocation for different structure components is done by the function itself.
*              The caller should free all the memory components once it is no longer needed.
*              Internally this function calls UnpackHydraServerUpgradeLicense.
*   Return   : License_Status
*****************************************************************************************/


LICENSE_STATUS
UnPackHydraServerUpgradeLicense(
            IN      BYTE FAR *                      pbMessage,
            IN      DWORD                           cbMessage,
            OUT     PHydra_Server_Upgrade_License   pCanonical
            )
{
    //Call UnpackHydraServerNewLicense as both the messages are same
    LS_BEGIN(TEXT("UnpackHydraServerUpgradeLicense\n"));
    return UnPackHydraServerNewLicense(pbMessage, cbMessage, pCanonical);
}

#if 0

//
// moved to cryptkey.c
//

/****************************************************************************************
*   Function : UnpackHydraServerCertificate
*   Purpose  : To unpack a binary blob into a Hydra_Server_Cert structure.
*   Note     : The caller should initialize the output pointer. All the necessary
*              allocation for different structure components is done by the function itself.
*              The caller should free all the memory components once it is no longer needed.
*   Return   : License_Status
*****************************************************************************************/


LICENSE_STATUS
UnpackHydraServerCertificate(
                             IN     BYTE FAR *          pbMessage,
                             IN     DWORD               cbMessage,
                             OUT    PHydra_Server_Cert  pCanonical
                             )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *  pbTemp = NULL;
    DWORD   dwTemp = 0;

    LS_BEGIN(TEXT("UnpackHydraServerCertificate\n"));

    if( (pbMessage == NULL) || (pCanonical == NULL ) )
    {
        INVALID_INPUT_RETURN;
    }

    dwTemp = 3*sizeof(DWORD) + 4*sizeof(WORD);

    if(dwTemp > cbMessage)
    {
        INVALID_INPUT_RETURN;
    }

    memset(pCanonical, 0x00, sizeof(Hydra_Server_Cert));

    LS_DUMPSTRING(cbMessage, pbMessage);

    pbTemp = pbMessage;
    dwTemp = cbMessage;

    //Assign dwVersion

    pCanonical->dwVersion = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    //Assign dwSigAlgID
    pCanonical->dwSigAlgID = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    //Assign dwSignID
    pCanonical->dwKeyAlgID  = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    //Assign PublicKeyData
    pCanonical->PublicKeyData.wBlobType = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    if( pCanonical->PublicKeyData.wBlobType != BB_RSA_KEY_BLOB )
    {
        INVALID_INPUT_RETURN;
    }
    pCanonical->PublicKeyData.wBlobLen = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    if(pCanonical->PublicKeyData.wBlobLen >0)
    {
        if( NULL ==(pCanonical->PublicKeyData.pBlob = (BYTE FAR *)malloc(pCanonical->PublicKeyData.wBlobLen)) )
        {
            pCanonical->PublicKeyData.wBlobLen = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        memset(pCanonical->PublicKeyData.pBlob, 0x00, pCanonical->PublicKeyData.wBlobLen);
        memcpy(pCanonical->PublicKeyData.pBlob, pbTemp, pCanonical->PublicKeyData.wBlobLen);
        pbTemp += pCanonical->PublicKeyData.wBlobLen;
        dwTemp -= pCanonical->PublicKeyData.wBlobLen;
    }

    //Assign SignatureBlob
    pCanonical->SignatureBlob.wBlobType = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    if( pCanonical->SignatureBlob.wBlobType != BB_RSA_SIGNATURE_BLOB )
    {
        INVALID_INPUT_RETURN;
    }
    pCanonical->SignatureBlob.wBlobLen = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    if(pCanonical->SignatureBlob.wBlobLen >0)
    {
        if( NULL ==(pCanonical->SignatureBlob.pBlob = (BYTE FAR *)malloc(pCanonical->SignatureBlob.wBlobLen)) )
        {
            pCanonical->SignatureBlob.wBlobLen = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        memset(pCanonical->SignatureBlob.pBlob, 0x00, pCanonical->SignatureBlob.wBlobLen);
        memcpy(pCanonical->SignatureBlob.pBlob, pbTemp, pCanonical->SignatureBlob.wBlobLen);
        pbTemp += pCanonical->SignatureBlob.wBlobLen;
        dwTemp -= pCanonical->SignatureBlob.wBlobLen;
    }

    LS_LOG_RESULT(lsReturn);

    LS_RETURN(lsReturn);

ErrorReturn:
    if (pCanonical)
    {
        if(pCanonical->PublicKeyData.pBlob)
        {
            free(pCanonical->PublicKeyData.pBlob);
            pCanonical->PublicKeyData.pBlob = NULL;
        }
        
        if(pCanonical->SignatureBlob.pBlob)
        {
            free(pCanonical->SignatureBlob.pBlob);
            pCanonical->SignatureBlob.pBlob = NULL;
        }

        memset(pCanonical, 0x00, sizeof(Hydra_Server_Cert));
    }

    LS_RETURN(lsReturn);
}

#endif


/****************************************************************************************
*   Function : UnpackNewLicenseInfo
*   Purpose  : To unpack a binary blob into a New_license_Info structure
*   Note     : The caller should initialize the output pointer. All the necessary
*              allocation for different structure components is done by the function itself.
*              The caller should free all the memory components once it is no longer needed.
*   Return   : License_Status
*****************************************************************************************/

LICENSE_STATUS
UnpackNewLicenseInfo(
                     BYTE FAR *         pbMessage,
                     DWORD              cbMessage,
                     PNew_License_Info  pCanonical
                     )
{
    LICENSE_STATUS lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *      pbTemp = NULL;
    DWORD       dwTemp = 0, dw = 0;

    LS_BEGIN(TEXT("UnpackNewLicenseInfo\n"));

    //Check for the validity of the inputs
    if( (pbMessage == NULL) || (pCanonical == 0) )
    {
        INVALID_INPUT_RETURN;
    }

    dwTemp = 5*sizeof(DWORD);

    if(dwTemp > cbMessage)
    {
        INVALID_INPUT_RETURN;
    }

    memset(pCanonical, 0x00, sizeof(New_License_Info));

    LS_DUMPSTRING(cbMessage, pbMessage);

    dwTemp = cbMessage;
    pbTemp = pbMessage;

    //Assign version
    pCanonical->dwVersion = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    //Assign Scope Data
    pCanonical->cbScope = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    dw = pCanonical->cbScope + 3*sizeof(DWORD);

    if( dw>dwTemp )
    {
        INVALID_INPUT_RETURN;
    }

    if( pCanonical->cbScope>0 )
    {
        if( NULL == (pCanonical->pbScope = (BYTE FAR *)malloc(pCanonical->cbScope)) )
        {
            pCanonical->cbScope = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        memset(pCanonical->pbScope, 0x00, pCanonical->cbScope);
        memcpy(pCanonical->pbScope, pbTemp, pCanonical->cbScope);

        pbTemp += pCanonical->cbScope;
        dwTemp -= pCanonical->cbScope;
    }

    //Assign CompanyName Data
    pCanonical->cbCompanyName = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    dw = pCanonical->cbCompanyName + 2*sizeof(DWORD);
    if( dw>dwTemp)
    {
        INVALID_INPUT_RETURN;
    }
    if( pCanonical->cbCompanyName>0 )
    {
        if( NULL == (pCanonical->pbCompanyName = (BYTE FAR *)malloc(pCanonical->cbCompanyName)) )
        {
            pCanonical->cbCompanyName = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        memset(pCanonical->pbCompanyName, 0x00, pCanonical->cbCompanyName);
        memcpy(pCanonical->pbCompanyName, pbTemp, pCanonical->cbCompanyName);

        pbTemp += pCanonical->cbCompanyName;
        dwTemp -= pCanonical->cbCompanyName;
    }

    //Assign ProductID data

    pCanonical->cbProductID = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    dw = pCanonical->cbProductID + sizeof(DWORD);
    if(dw>dwTemp)
    {
        INVALID_INPUT_RETURN;
    }
    if( pCanonical->cbProductID>0 )
    {
        if( NULL == (pCanonical->pbProductID = (BYTE FAR *)malloc(pCanonical->cbProductID)) )
        {
            pCanonical->cbProductID = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        memset(pCanonical->pbProductID, 0x00, pCanonical->cbProductID);
        memcpy(pCanonical->pbProductID, pbTemp, pCanonical->cbProductID);

        pbTemp += pCanonical->cbProductID;
        dwTemp -= pCanonical->cbProductID;
    }

    //Assign LicenseInfo data
    pCanonical->cbLicenseInfo = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    dw = pCanonical->cbLicenseInfo;

    if( dw>dwTemp )
    {
        INVALID_INPUT_RETURN;
    }
    if( pCanonical->cbLicenseInfo>0 )
    {
        if( NULL == (pCanonical->pbLicenseInfo = (BYTE FAR *)malloc(pCanonical->cbLicenseInfo)) )
        {
            pCanonical->cbLicenseInfo = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        memset(pCanonical->pbLicenseInfo, 0x00, pCanonical->cbLicenseInfo);
        memcpy(pCanonical->pbLicenseInfo, pbTemp, pCanonical->cbLicenseInfo);

        pbTemp += pCanonical->cbLicenseInfo;
        dwTemp -= pCanonical->cbLicenseInfo;
    }

    LS_LOG_RESULT(lsReturn);

    LS_RETURN(lsReturn);

ErrorReturn:
    if (pCanonical)
    {
        if(pCanonical->pbScope)
        {
            free(pCanonical->pbScope);
            pCanonical->pbScope = NULL;
        }

        if(pCanonical->pbCompanyName)
        {
            free(pCanonical->pbCompanyName);
            pCanonical->pbCompanyName = NULL;
        }

        if(pCanonical->pbProductID)
        {
            free(pCanonical->pbProductID);
            pCanonical->pbProductID = NULL;
        }

        if(pCanonical->pbLicenseInfo)
        {
            free(pCanonical->pbLicenseInfo);
            pCanonical->pbLicenseInfo = NULL;
        }
    }

    LS_RETURN(lsReturn);
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
UnPackExtendedErrorInfo( 
                   UINT32       *puiExtendedErrorInfo,
                   Binary_Blob  *pbbErrorInfo)
{
    LICENSE_STATUS lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *     pbTemp = NULL;
    DWORD          dwTemp = 0;
    WORD           wVersion;

    LS_BEGIN(TEXT("UnpackExtendedErrorInfo\n"));

    //Check for the validity of the inputs
    if( (puiExtendedErrorInfo == NULL) || (pbbErrorInfo == NULL) )
    {
        INVALID_INPUT_RETURN;
    }

    dwTemp = sizeof(WORD) + sizeof(WORD) + sizeof(UINT32);

    if(dwTemp > pbbErrorInfo->wBlobLen)
    {
        INVALID_INPUT_RETURN;
    }

    pbTemp = pbbErrorInfo->pBlob;

    wVersion = *(UNALIGNED WORD*)pbTemp;

    pbTemp += sizeof(WORD);

    if (wVersion < BB_ERROR_BLOB_VERSION)
    {
        //
        // Old version
        //

        INVALID_INPUT_RETURN;
    }

    //
    // skip reserved field
    //

    pbTemp += sizeof(WORD);

    *puiExtendedErrorInfo = *(UNALIGNED UINT32*)pbTemp;

    LS_LOG_RESULT(lsReturn);

    LS_RETURN(lsReturn);

ErrorReturn:

    LS_RETURN(lsReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\licdebug\licdbg.c ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1999
//
// File:        licdbg.c
//
// Contents:    
//
// History:     
//              
//              
//---------------------------------------------------------------------------

#if DBG         /* NOTE:  This file not compiled for retail builds */


#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>
#include "license.h"

#include "licdbg.h"


#ifndef min
#define min(x,y) ((x)<(y)?(x):(y))
#endif


DWORD   LicenseTraceIndent = 0;
DWORD   g_dwInfoLevel      = 0;


#define MAX_DEBUG_BUFFER 2048


// This function simply outputs information to the debugging log file handle.

void
//CALL_TYPE
LicenseDebugOutput(char *szOutString)
{
#ifndef NO_DEBUG
#ifndef OS_WINCE
    OutputDebugStringA(szOutString);
#else
    WCHAR szStr[MAX_DEBUG_BUFFER];
    if (MultiByteToWideChar(CP_ACP, 0, szOutString, -1, szStr, MAX_DEBUG_BUFFER) > 0)
        OutputDebugString(szStr);
#endif
#endif  //NO_DEBUG

}



void
//CALL_TYPE
DbgDumpHexString(const unsigned char *String, DWORD cbString)
{

#ifndef NO_DEBUG
    unsigned int i;

    for (i = 0; i < cbString; i++)
    {

    char *pch;
    char ach[9];

#ifndef OS_WINCE
    pch = &ach[wsprintf(ach,  "%2.2x", String[i])];
#else
    pch = &ach[sprintf(ach,  "%2.2x", String[i])];
#endif
//  LS_ASSERT(pch - ach <= sizeof(ach) - 4);


    if ((i & 1) == 1)
    {
        *pch++ = ' ';
    }
    if ((i & 7) == 7)
    {
        *pch++ = ' ';
    }
    if ((i & 15) == 15)
    {
        *pch++ = '\n';
    }
    *pch = '\0';
    LicenseDebugOutput(ach);
    }
#endif  //NO_DEBUG

}

#ifndef NO_DEBUG
char *aszLSDebugLevel[] = {
    "Error  ",
    "Warning",
    "Trace  ",
    "Mem    ",
    "Result "
};
#endif  //NO_DEBUG

void
//CALL_TYPE
LicenseDebugLog(long Mask, const char *Format, ...)
{
#ifndef NO_DEBUG
    va_list ArgList;
    int     Level = 0;
    int     PrefixSize = 0;
    int     iOut;
    char    szOutString[MAX_DEBUG_BUFFER];
    long    OriginalMask = Mask;

    if (Mask )//& g_dwInfoLevel)
    {
        while (!(Mask & 1))
        {
            Level++;
            Mask >>= 1;
        }
        if (Level >= sizeof(aszLSDebugLevel) / sizeof(char *))
        {
            Level = sizeof(aszLSDebugLevel) / sizeof(char *) - 1;
        }
        // Make the prefix first:  "Process.Thread> GINA-XXX"

#ifndef OS_WINCE
        iOut = wsprintf(
                szOutString,
                "%3d.%3d> %s: ",
                GetCurrentProcessId(),
                GetCurrentThreadId(),
                aszLSDebugLevel[Level]);
#else
        iOut = sprintf(
                szOutString,
                "%3d.%3d> %s: ",
                GetCurrentProcessId(),
                GetCurrentThreadId(),
                aszLSDebugLevel[Level]);
#endif

        PrefixSize = min(60, LicenseTraceIndent * 3);
#ifndef OS_WINCE
        FillMemory(szOutString+iOut, PrefixSize, ' ');
#else
        memset(szOutString+iOut, PrefixSize, ' ');
#endif
        PrefixSize += iOut;
        szOutString[PrefixSize] = '\0';

        va_start(ArgList, Format);

#ifndef OS_WINCE
        if (wvsprintf(&szOutString[PrefixSize], Format, ArgList) < 0)
#else
        if (vsprintf(&szOutString[PrefixSize], Format, ArgList) < 0)
#endif

        {
            static char szOverFlow[] = "\n<256 byte OVERFLOW!>\n";

            // Less than zero indicates that the string would not fit into the
            // buffer.  Output a special message indicating overflow.

#ifndef OS_WINCE
            lstrcpy(
            &szOutString[sizeof(szOutString) - sizeof(szOverFlow)],
            szOverFlow);
#else
            strcpy(
            &szOutString[sizeof(szOutString) - sizeof(szOverFlow)],
            szOverFlow);
#endif
        }
        va_end(ArgList);
        LicenseDebugOutput(szOutString);
    }
#endif  //NO_DEBUG
}


long
//CALL_TYPE    
LicenseLogErrorCode(
    long err, 
    const char *szFile, 
    long lLine)
{
#ifndef NO_DEBUG
    char *szName = "Unknown";

    switch(err)
    {
    case LICENSE_STATUS_OK: szName = "LICENSE_STATUS_OK"; break;
    case LICENSE_STATUS_OUT_OF_MEMORY: szName = "LICENSE_STATUS_OUT_OF_MEMORY"; break;
    case LICENSE_STATUS_INSUFFICIENT_BUFFER: szName = "LICENSE_STATUS_INSUFFICIENT_BUFFER"; break;
    case LICENSE_STATUS_INVALID_INPUT: szName = "LICENSE_STATUS_INVALID_INPUT"; break;
    case LICENSE_STATUS_INVALID_CLIENT_CONTEXT: szName = "LICENSE_STATUS_INVALID_CLIENT_CONTEXT"; break;
    case LICENSE_STATUS_INITIALIZATION_FAILED: szName = "LICENSE_STATUS_INITIALIZATION_FAILED"; break;
    case LICENSE_STATUS_INVALID_SIGNATURE: szName = "LICENSE_STATUS_INVALID_SIGNATURE"; break;
    case LICENSE_STATUS_INVALID_CRYPT_STATE: szName = "LICENSE_STATUS_INVALID_CRYPT_STATE"; break;

    case LICENSE_STATUS_CONTINUE: szName = "LICENSE_STATUS_CONTINUE"; break;
    case LICENSE_STATUS_ISSUED_LICENSE: szName = "LICENSE_STATUS_ISSUED_LICENSE"; break;
    case LICENSE_STATUS_CLIENT_ABORT: szName = "LICENSE_STATUS_CLIENT_ABORT"; break;
    case LICENSE_STATUS_SERVER_ABORT: szName = "LICENSE_STATUS_SERVER_ABORT"; break;
    case LICENSE_STATUS_NO_CERTIFICATE: szName = "LICENSE_STATUS_NO_CERTIFICATE"; break;
    case LICENSE_STATUS_NO_PRIVATE_KEY: szName = "LICENSE_STATUS_NO_PRIVATE_KEY"; break;
    case LICENSE_STATUS_SEND_ERROR: szName = "LICENSE_STATUS_SEND_ERROR"; break;
    case LICENSE_STATUS_INVALID_RESPONSE: szName = "LICENSE_STATUS_INVALID_RESPONSE"; break;
    case LICENSE_STATUS_CONTEXT_INITIALIZATION_ERROR: szName = "LICENSE_STATUS_CONTEXT_INITIALIZATION_ERROR"; break;
    case LICENSE_STATUS_NO_MESSAGE: szName = "LICENSE_STATUS_NO_MESSAGE"; break;
    case LICENSE_STATUS_INVALID_CLIENT_STATE: szName = "LICENSE_STATUS_INVALID_CLIENT_STATE"; break;
    case LICENSE_STATUS_OPEN_STORE_ERROR: szName = "LICENSE_STATUS_OPEN_STORE_ERROR"; break;
    case LICENSE_STATUS_CLOSE_STORE_ERROR: szName = "LICENSE_STATUS_CLOSE_STORE_ERROR"; break;
    case LICENSE_STATUS_NO_LICENSE_ERROR: szName = "LICENSE_STATUS_NO_LICENSE_ERROR"; break;
    case LICENSE_STATUS_INVALID_STORE_HANDLE: szName = "LICENSE_STATUS_INVALID_STORE_HANDLE"; break;
    case LICENSE_STATUS_DUPLICATE_LICENSE_ERROR: szName = "LICENSE_STATUS_DUPLICATE_LICENSE_ERROR"; break;
    case LICENSE_STATUS_INVALID_MAC_DATA: szName = "LICENSE_STATUS_INVALID_MAC_DATA"; break;
    case LICENSE_STATUS_INCOMPLETE_MESSAGE: szName = "LICENSE_STATUS_INCOMPLETE_MESSAGE"; break;
    case LICENSE_STATUS_RESTART_NEGOTIATION: szName = "LICENSE_STATUS_RESTART_NEGOTIATION"; break;
    }

    LicenseDebugLog(LS_LOG_RES, "Result: %s (0x%lx) - %s, Line %d\n", szName, err, szFile, lLine);

    return err;
#endif  //NO_DEBUG
    return 0;
}


void
//CALL_TYPE
LSAssert(
    void * FailedAssertion,
    void * FileName,
    unsigned long LineNumber,
    char * Message)
{
#ifndef NO_DEBUG
    LicenseDebugLog(LS_LOG_ERROR, 
               "Assertion FAILED, %s, %s : %d\n", 
               FailedAssertion,
               FileName,
               LineNumber);
#endif  //NO_DEBUG

}



#endif /* DEBUG */ /* NOTE:  This file not compiled for retail builds */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\cryptkey\cryptkey.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    core.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Sep. 5th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES = \
    $(C_DEFINES) \
    $(CLIENT_EXE_CDEFS)

#
# List of sources
#

SOURCES_PLATFORM =

CLIENT_SOURCES_RC = \

CLIENT_SOURCES_COMMON = \
    cryptkey.c

CLIENT_SOURCES_LAST  = \

SOURCES = \
    $(CLIENT_SOURCES_RC) \
    $(SOURCES_PLATFORM) \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_LAST)

#
# Precompiled specs
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\common\cryptkey\ubase64.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1999
//
// File:        ubase64.cpp
//
// Contents:    
//
// History:     
//              
//              
//---------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <assert.h>
// #include "crtem.h"
#include "base64.h"

DWORD LSBase64EncodeW(
    BYTE const *pbIn,
    DWORD cbIn,
    WCHAR *wszOut,
    DWORD *pcchOut)

{

    DWORD   cchOut;
    char   *pch = NULL;
    DWORD   cch;
    DWORD   err;

    assert(pcchOut != NULL);

    // only want to know how much to allocate
    // we know all base64 char map 1-1 with unicode

    __try
    {
        if( wszOut == NULL ) {

            // get the number of characters
            *pcchOut = 0;
            err = LSBase64EncodeA(
                    pbIn,
                    cbIn,
                    NULL,
                    pcchOut);
        }

        // otherwise we have an output buffer
        else {

            // char count is the same be it ascii or unicode,
            cchOut = *pcchOut;
            cch = 0;
            err = ERROR_OUTOFMEMORY;
            if( (pch = (char *) LocalAlloc(LPTR, cchOut)) != NULL  &&
        
                (err = LSBase64EncodeA(
                    pbIn,
                    cbIn,
                    pch,
                    &cchOut)) == ERROR_SUCCESS      ) {

                // should not fail!
                cch = MultiByteToWideChar(0, 
                                0, 
                                pch, 
                                cchOut, 
                                wszOut, 
                                *pcchOut);

                // check to make sure we did not fail                            
                assert(*pcchOut == 0 || cch != 0);                            
            }
        }
    }
    __except(  EXCEPTION_EXECUTE_HANDLER )
    {
        //
        // log the exception in the future
        //
        
        err = ERROR_EXCEPTION_IN_SERVICE;
    }

    if(pch != NULL)
    {
        LocalFree(pch);
    }

    return(err);
}

DWORD LSBase64DecodeW(
    const WCHAR * wszIn,
    DWORD cch,
    BYTE *pbOut,
    DWORD *pcbOut)
{

    char *pch = NULL;
    DWORD err = ERROR_SUCCESS;

    __try
    {

        // in all cases we need to convert to an ascii string
        // we know the ascii string is less

        if( (pch = (char *) LocalAlloc(LPTR, cch)) == NULL ) {
            err = ERROR_OUTOFMEMORY;
        }

        // we know no base64 wide char map to more than 1 ascii char
        else if( WideCharToMultiByte(0, 
                            0, 
                            wszIn, 
                            cch, 
                            pch, 
                            cch, 
                            NULL, 
                            NULL) == 0 ) {
            err = ERROR_NO_DATA;
        }
        
        // get the length of the buffer
        else if( pbOut == NULL ) {

            *pcbOut = 0;
            err = LSBase64Decode(
                            pch,
                            cch,
                            NULL,
                            pcbOut);
        }

        // otherwise fill in the buffer
        else {

            err = LSBase64Decode(
                            pch,
                            cch,
                            pbOut,
                            pcbOut);
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        // log the exception in the future
        //
        
        err = ERROR_EXCEPTION_IN_SERVICE;
    }

    if(pch != NULL)
    {
        LocalFree(pch);
    }

    return(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\hclient\liclient\hccontxt.c ===
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       HCContxt.c
//
//  Contents:   Functions that are used to pack and unpack different messages
//
//  Classes:
//
//  Functions:  
//
//  History:    12-23-97  v-sbhatt   Created
//              07-22-98  fredch     Added LicenseSetPublicKey() function
//----------------------------------------------------------------------------


#include "windows.h"

#include "stdlib.h"
#include <tchar.h>

#ifdef OS_WINCE
#include <wincelic.h>
#endif  //OS_WINCE


#include "license.h"
#include "cryptkey.h"
#include "hccontxt.h"
#include "cliprot.h"
#ifndef OS_WINCE
#include "assert.h"
#endif // OS_WINCE

VOID
FreeProprietaryCertificate(
    PHydra_Server_Cert * ppCertificate );

#ifdef __cplusplus
extern "C" {
#endif

/******************************************************************
*   Funtion : PLicense_Client_Context LicenseCreateContext(VOID)
*   Purpose : Creates a New License_Client_Context and initializes 
*             it with 0
*   Returns : Returns a pointer to created License_Client_Context
*******************************************************************/


PLicense_Client_Context 
LicenseCreateContext( VOID)
{
    PLicense_Client_Context     pContext;
    
    //Allocate approptiate memory!
    pContext = (PLicense_Client_Context)malloc(sizeof(License_Client_Context));
    if(pContext == NULL)
        return NULL;
    
    memset(pContext, 0, sizeof(License_Client_Context));

    //
    // allocate memory for the crypto context
    //

    pContext->pCryptParam = ( PCryptSystem )malloc( sizeof( CryptSystem ) );

    if( NULL == pContext->pCryptParam )
    {
        free( pContext );
        pContext = NULL;
        return( NULL );
    }

    return pContext;
}

/**********************************************************************************
*   Funtion : LICENSE_STATUS LicenseDeleteContext(PLicense_Client_Context pContext)
*   Purpose : Deletes an existing context and overwrites the memory with 0
*   Returns : Returns LICENSE_STATUS
*******************************************************************/


LICENSE_STATUS CALL_TYPE
LicenseDeleteContext(
                     HANDLE hContext
                     )//PLicense_Client_Context pContext)
{
    LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
    PLicense_Client_Context     pContext = (PLicense_Client_Context)hContext;
    if(pContext == NULL)
    { 
        lsReturn = LICENSE_STATUS_INVALID_CLIENT_CONTEXT;
#if DBG
        OutputDebugString(_T("The context handle passed is invalid"));
#endif
        return lsReturn;
    }
    
    //free pServerCert
    if(pContext->pServerCert)
    {
        FreeProprietaryCertificate( &pContext->pServerCert );       
    }

    //
    // Free the public key
    //
    
    if( pContext->pbServerPubKey )
    {
        memset( pContext->pbServerPubKey, 0x00, pContext->cbServerPubKey );
        free( pContext->pbServerPubKey );
        pContext->pbServerPubKey = NULL;
    }
        
    //Free pCryptSystem
    if(pContext->pCryptParam)
    {
        memset(pContext->pCryptParam, 0x00, sizeof(CryptSystem));
        free(pContext->pCryptParam);
        pContext->pCryptParam = NULL;
    }

    //Free the last message

    if(pContext->pbLastMessage)
    {
        memset(pContext->pbLastMessage, 0x00, pContext->cbLastMessage);
        free(pContext->pbLastMessage);
        pContext->pbLastMessage = NULL;
    }
    if(pContext)
    {
        //Zeroise the memory
        memset(pContext, 0, sizeof(License_Client_Context));
        //Now free the context;
        free(pContext);
        pContext = NULL;
    }
    
    hContext = NULL;
    return lsReturn;
}


/**********************************************************************************
*   Funtion : LICENSE_STATUS 
*             LicenseInitializeContext(
*                                      PLicense_Client_Context pContext,
*                                      DWORD       dwFlags
*                                       );
*   Purpose : Initializes an existing context
*   Returns : Returns LICENSE_STATUS
*******************************************************************/

LICENSE_STATUS CALL_TYPE
LicenseInitializeContext(
                         HANDLE     *phContext,
                         DWORD       dwFlags
                         )
{
    LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
    PLicense_Client_Context pContext;

    assert(phContext);
    
    pContext = LicenseCreateContext();
    
    if(pContext == NULL)
    {
#if DBG
        OutputDebugString(_T("\nUnable to allocate memory for the context.\n"));
#endif
        *phContext = NULL;
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        return lsReturn;
    }
    //Now initialize different members of the context structure
    pContext->dwProtocolVersion = LICENSE_HIGHEST_PROTOCOL_VERSION;
    pContext->dwState = LICENSE_CLIENT_STATE_WAIT_SERVER_HELLO;
    pContext->pCryptParam->dwCryptState = CRYPT_SYSTEM_STATE_INITIALIZED;
    pContext->pCryptParam->dwSignatureAlg = SIGNATURE_ALG_RSA;
    pContext->pCryptParam->dwKeyExchAlg = KEY_EXCHANGE_ALG_RSA;
    pContext->pCryptParam->dwSessKeyAlg = BASIC_RC4_128;
    pContext->pCryptParam->dwMACAlg = MAC_MD5_SHA;
    memset(pContext->pCryptParam->rgbClientRandom, 0x00, LICENSE_RANDOM);
    memset(pContext->pCryptParam->rgbServerRandom, 0x00, LICENSE_RANDOM);
    memset(pContext->pCryptParam->rgbPreMasterSecret, 0x00, LICENSE_PRE_MASTER_SECRET);
    memset(pContext->pCryptParam->rgbMACSaltKey, 0x00, LICENSE_MAC_WRITE_KEY);
    memset(pContext->pCryptParam->rgbSessionKey, 0x00, LICENSE_SESSION_KEY);
    memset(pContext->rgbMACData, 0x00, LICENSE_MAC_DATA);
    pContext->cbLastMessage = 0;
    pContext->pbLastMessage = NULL;
    pContext->pServerCert = NULL;   
    pContext->dwContextFlags = dwFlags;

    *phContext = (HANDLE)pContext;
    return lsReturn;
}


/******************************************************************
*   Funtion : LICENSE_STATUS
*             LicenseAcceptContext(
*                   HANDLE      hContext,
*                   UINT32      puiExtendedErrorInfo,
*                   BYTE FAR *  pbInput,
*                   DWORD       cbInput,
*                   BYTE FAR *  pbOutput,
*                   DWORD FAR * pcbOutput )
*
*   Purpose : Process and construct licensing protocol data.
*
*   Returns : Returns a LICENSE_STATUS return code.
*******************************************************************/

LICENSE_STATUS  CALL_TYPE
LicenseAcceptContext(
                      HANDLE    hContext,
                      UINT32    *puiExtendedErrorInfo,
                      BYTE FAR *pbInput,
                      DWORD     cbInput,
                      BYTE FAR *pbOutput,
                      DWORD FAR*pcbOutput
                      )
{
    PLicense_Client_Context     pContext = (PLicense_Client_Context)hContext;
    return LicenseClientHandleServerMessage(pContext, 
                                            puiExtendedErrorInfo,
                                            pbInput,
                                            cbInput,
                                            pbOutput,
                                            pcbOutput);
}


/******************************************************************
*   Funtion : LICENSE_STATUS
*             LicenseSetPublicKey(
*                   HANDLE          hContext,
*                   DWORD           cbPubKey,
*                   BYTE FAR *      pbPubKey )
*
*   Purpose : Sets the public key to use.
*
*   Returns : Returns a LICENSE_STATUS return code.
*******************************************************************/

LICENSE_STATUS CALL_TYPE
LicenseSetPublicKey(
    HANDLE          hContext,
    DWORD           cbPubKey,
    BYTE FAR *      pbPubKey )
{
    PLicense_Client_Context
        pContext = ( PLicense_Client_Context )hContext;
    PBYTE
        pbOldPubKey = NULL;

    if( ( NULL == pbPubKey ) || ( 0 >= cbPubKey ) || ( NULL == pContext ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // remember the old public key so that we can restore it if this
    // function call doesn't complete successfully.
    //
    
    pbOldPubKey = pContext->pbServerPubKey;
    
    //
    // allocate memory for the new public key
    //

    pContext->pbServerPubKey = malloc( cbPubKey );

    if( NULL == pContext->pbServerPubKey )
    {
        //
        // no memory, restore the old public key and return an error
        //

        pContext->pbServerPubKey = pbOldPubKey;
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }

    //
    // copy the new public key
    //

    memcpy( pContext->pbServerPubKey, pbPubKey, cbPubKey );
    pContext->cbServerPubKey = cbPubKey;

    if( pbOldPubKey )
    {
        free( pbOldPubKey );
    }

    return( LICENSE_STATUS_OK );
}


/******************************************************************
*   Funtion : LICENSE_STATUS
*             LicenseSetCertificate(
*                   HANDLE              hContext,
*                   PHydra_Server_Cert  pCertificate )
*
*   Purpose : Sets the certificate to use.
*
*   Returns : Returns a LICENSE_STATUS return code.
*******************************************************************/

LICENSE_STATUS CALL_TYPE
LicenseSetCertificate(
    HANDLE              hContext,
    PHydra_Server_Cert  pCertificate )
{
    PLicense_Client_Context
        pContext = ( PLicense_Client_Context )hContext;
    PHydra_Server_Cert
        pNewCert = NULL;
    LICENSE_STATUS
        Status = LICENSE_STATUS_OK;

    if( ( NULL == pCertificate ) || ( NULL == pContext ) ||
        ( NULL == pCertificate->PublicKeyData.pBlob) ||
        ( NULL == pCertificate->SignatureBlob.pBlob ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // allocate memory for the new certificate
    //

    pNewCert = ( PHydra_Server_Cert )malloc( sizeof( Hydra_Server_Cert ) );

    if( NULL == pNewCert )
    {
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }

    memset( ( char * )pNewCert, 0, sizeof( Hydra_Server_Cert ) );

    pNewCert->PublicKeyData.pBlob = ( LPBYTE )malloc( pCertificate->PublicKeyData.wBlobLen );

    if( NULL == pNewCert->PublicKeyData.pBlob )
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto ErrorExit;
    }

    pNewCert->SignatureBlob.pBlob = ( LPBYTE )malloc( pCertificate->SignatureBlob.wBlobLen );

    if( NULL == pNewCert->SignatureBlob.pBlob )
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto ErrorExit;
    }

    //
    // copy the certificate info
    //

    pNewCert->dwVersion = pCertificate->dwVersion;
    pNewCert->dwSigAlgID = pCertificate->dwSigAlgID;
    pNewCert->dwKeyAlgID = pCertificate->dwKeyAlgID;

    pNewCert->PublicKeyData.wBlobType = pCertificate->PublicKeyData.wBlobType;
    pNewCert->PublicKeyData.wBlobLen = pCertificate->PublicKeyData.wBlobLen;
    memcpy( pNewCert->PublicKeyData.pBlob, 
            pCertificate->PublicKeyData.pBlob,
            pNewCert->PublicKeyData.wBlobLen );

    pNewCert->SignatureBlob.wBlobType = pCertificate->SignatureBlob.wBlobType;
    pNewCert->SignatureBlob.wBlobLen = pCertificate->SignatureBlob.wBlobLen;
    memcpy( pNewCert->SignatureBlob.pBlob, 
            pCertificate->SignatureBlob.pBlob,
            pNewCert->SignatureBlob.wBlobLen );

    //
    // free the old certificate and reset the pointer.
    //

    if( pContext->pServerCert )
    {
        FreeProprietaryCertificate( &pContext->pServerCert );
    }
    
    pContext->pServerCert = pNewCert;

    return( Status );

ErrorExit:

    if( pNewCert->PublicKeyData.pBlob )
    {
        free( pNewCert->PublicKeyData.pBlob );
    }

    if( pNewCert->SignatureBlob.pBlob )
    {
        free( pNewCert->SignatureBlob.pBlob );
    }

    free( pNewCert );

    return( Status );
}

#ifdef __cpluscplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\hclient\liclient\cliprot.c ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    cliprot.c

Abstract:

Author:

    Frederick Chong (fredch) 6/1/1998

Environment:

    Win32, WinCE, Win16

Notes:

--*/

#include "windows.h"
#ifndef OS_WINCE
#include "stdio.h"
#endif // OS_WINCE
#include "stdlib.h"

#ifdef OS_WINCE
#include "wincelic.h"
#endif  //OS_WINCE

#include "tchar.h"

#include "lmcons.h"

#include "seccom.h"

#include "cryptkey.h"
#include "hccontxt.h"
#include "cliprot.h"
#include "hcpack.h"
#include "store.h"
#include "licdbg.h"
#include "platform.h"
#include "licecert.h"

#ifdef _WIN64

#define OFFSET_OF(type, field)    ((LONG)(LONG_PTR)&(((type *)0)->field))

#else

#define OFFSET_OF(type, field)    ((LONG)(LONG *)&(((type *)0)->field))

#endif

#define MAX_ALLOWABLE_LICENSE_SIZE (256 * 1024)
#define EXTENDED_ERROR_CAPABILITY 0x80


VOID
FreeProprietaryCertificate(
    PHydra_Server_Cert * ppCertificate );

static BOOL GeneratePseudoLicense(DWORD FAR * pcbData , PBYTE *ppbData);

static LICENSE_STATUS MapStoreError(LS_STATUS lsStatus)
{
    if(lsStatus == LSSTAT_SUCCESS)
        return LICENSE_STATUS_OK;
    if( (lsStatus == LSSTAT_ERROR) || (lsStatus == LSSTAT_INVALID_HANDLE) )
        return LICENSE_STATUS_INVALID_INPUT;
    if(lsStatus == LSSTAT_INSUFFICIENT_BUFFER)
        return LICENSE_STATUS_INSUFFICIENT_BUFFER;
    if(lsStatus == LSSTAT_LICENSE_NOT_FOUND)
        return LICENSE_STATUS_NO_LICENSE_ERROR;
    if(lsStatus == LSSTAT_OUT_OF_MEMORY)
        return LICENSE_STATUS_OUT_OF_MEMORY;
    if(lsStatus == LSSTAT_LICENSE_EXISTS)
        return LICENSE_STATUS_DUPLICATE_LICENSE_ERROR;

    return LICENSE_STATUS_INVALID_INPUT;
}


LICENSE_STATUS
CALL_TYPE
LicenseClientHandleServerMessage(
                     PLicense_Client_Context    pContext,
                     UINT32                     *puiExtendedErrorInfo,
                     BYTE FAR *                 pbInput,
                     DWORD                      cbInput,
                     BYTE FAR *                 pbOutput,
                     DWORD FAR *                pcbOutput
                     )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    BYTE FAR            *pbTemp = NULL;
    DWORD               dwTemp = 0;
    Preamble            Header;
    BOOL                fNew = FALSE;
    BOOL                fSupportExtendedError = FALSE;

    if(NULL == pContext || NULL == pbInput || pcbOutput == NULL)
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    pbTemp = pbInput;
    dwTemp = cbInput;
    
    Header = *( UNALIGNED Preamble*)pbTemp;

    //
    // check if we can support this preamble version
    //

    if( Header.bVersion > LICENSE_CURRENT_PREAMBLE_VERSION )
    {
        lsReturn = LICENSE_STATUS_NOT_SUPPORTED;
        goto CommonReturn;
    }

    //
    // Sets the preamble version to the version that the server is using
    //

   
    pContext->dwProtocolVersion |= Header.bVersion;

    if(pContext->dwProtocolVersion >= 2)
    {
        fSupportExtendedError = TRUE;
    }

    if( Header.wMsgSize != dwTemp)
    {
        License_Error_Message Error;
        memset(&Error, 0x00, sizeof(License_Error_Message));
        Error.dwErrorCode = GM_HS_ERR_INVALID_MESSAGE_LEN;
        Error.dwStateTransition = ST_RESEND_LAST_MESSAGE;
        Error.bbErrorInfo.wBlobType = BB_ERROR_BLOB;
        Error.bbErrorInfo.wBlobLen = 0;
        Error.bbErrorInfo.pBlob = NULL;
        
        DebugLog((DEB_TRACE, "Packing License Error Message from Client : %4d\n", *pcbOutput));
        PackLicenseErrorMessage(&Error, fSupportExtendedError, pbOutput, pcbOutput);
        
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        goto CommonReturn;
    }

    pbTemp += sizeof(Preamble);
    dwTemp -= sizeof(Preamble);

    switch(Header.bMsgType)
    {
    case GM_ERROR_ALERT:
        {
            License_Error_Message   Error;
            
            memset(&Error, 0x00, sizeof(License_Error_Message));
            
            DebugLog((DEB_TRACE, "Unpacking Hydra Server Error Message of size: %4d\n", dwTemp));
            if( LICENSE_STATUS_OK != (lsReturn = UnPackLicenseErrorMessage(pbTemp, 
                                                                           dwTemp,
                                                                           &Error)) )
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }

            DebugLog((DEB_TRACE, "LicenseClientHandleServerError : %4d\n", *pcbOutput));
            lsReturn = LicenseClientHandleServerError(pContext, 
                                                      &Error,
                                                      puiExtendedErrorInfo,
                                                      pbOutput, 
                                                      pcbOutput);
            if(Error.bbErrorInfo.pBlob) 
            {
                free(Error.bbErrorInfo.pBlob);
                Error.bbErrorInfo.pBlob = NULL;
            }
#if DBG
            if(pbOutput)
                OutputDebugString(_T("Client response data : \n"));
            LS_DUMPSTRING(*pcbOutput, pbOutput);
#endif
                
            if( lsReturn == LICENSE_STATUS_OK ||
                lsReturn == LICENSE_STATUS_CONTINUE ||
                lsReturn == LICENSE_STATUS_CLIENT_ABORT ||
                lsReturn == LICENSE_STATUS_SERVER_ABORT )
                goto CommonReturn;
            else
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }

            break;
        }
    case HS_LICENSE_REQUEST:
        {
            Hydra_Server_License_Request    LicRequest;
            DWORD                           dw;

            memset(&LicRequest, 0x00, sizeof(Hydra_Server_License_Request));
            
            DebugLog((DEB_TRACE, "Unpacking Hydra Server's License Request : %4d\n", dwTemp));
            if( LICENSE_STATUS_OK != (lsReturn = UnpackHydraServerLicenseRequest(pbTemp, 
                                                                                 dwTemp, 
                                                                                 &LicRequest)) )
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
            
            DebugLog((DEB_TRACE, "Client handles Server's license Request : %4d\n", *pcbOutput));
            
            lsReturn = LicenseClientHandleServerRequest(pContext, 
                                                        &LicRequest, 
                                                        TRUE, 
                                                        pbOutput, 
                                                        pcbOutput,
                                                        fSupportExtendedError);
#if DBG
            if(pbOutput)
                OutputDebugString(_T("Client response data : \n"));
            LS_DUMPSTRING(*pcbOutput, pbOutput);
#endif

            if(LicRequest.ProductInfo.pbCompanyName)
            {
                free(LicRequest.ProductInfo.pbCompanyName);
                LicRequest.ProductInfo.pbCompanyName = NULL;
            }
            if(LicRequest.ProductInfo.pbProductID)
            {
                free(LicRequest.ProductInfo.pbProductID);
                LicRequest.ProductInfo.pbProductID = NULL;
            }

            for(dw = 0; dw <LicRequest.ScopeList.dwScopeCount; dw++)
            {
                if(LicRequest.ScopeList.Scopes[dw].pBlob)
                {
                    free(LicRequest.ScopeList.Scopes[dw].pBlob);
                    LicRequest.ScopeList.Scopes[dw].pBlob = NULL;
                }
            }

            if(LicRequest.ScopeList.Scopes)
            {
                free(LicRequest.ScopeList.Scopes);
                LicRequest.ScopeList.Scopes = NULL;
            }

            if( LicRequest.KeyExchngList.pBlob )
            {
                free( LicRequest.KeyExchngList.pBlob );
            }

            if( LicRequest.ServerCert.pBlob )
            {
                free( LicRequest.ServerCert.pBlob );
            }

            if( lsReturn != LICENSE_STATUS_OK &&
                lsReturn != LICENSE_STATUS_CONTINUE &&
                lsReturn != LICENSE_STATUS_CLIENT_ABORT )
            {

                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
            break;
        }
    case HS_PLATFORM_CHALLENGE:
        {
            Hydra_Server_Platform_Challenge     PlatformCh;
            memset(&PlatformCh, 0x00, sizeof(Hydra_Server_Platform_Challenge));
            
            DebugLog((DEB_TRACE, "Unpacking Hydra Server's platform Challenge Request : %4d\n", dwTemp));
            if( LICENSE_STATUS_OK != (lsReturn = UnPackHydraServerPlatformChallenge(pbTemp, 
                                                                                    dwTemp, 
                                                                                    &PlatformCh)) )
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
            
            DebugLog((DEB_TRACE, "Client Handles Server's platform Challenge Response : %0d\n", *pcbOutput));
            lsReturn = LicenseClientHandleServerPlatformChallenge(pContext, 
                                                                 &PlatformCh, 
                                                                 pbOutput, 
                                                                 pcbOutput,
                                                                 fSupportExtendedError);
#if DBG
            if(pbOutput)
                OutputDebugString(_T("Client response data : \n"));
            LS_DUMPSTRING(*pcbOutput, pbOutput);
#endif

            if(PlatformCh.EncryptedPlatformChallenge.pBlob)
            {
                free(PlatformCh.EncryptedPlatformChallenge.pBlob);
                PlatformCh.EncryptedPlatformChallenge.pBlob = NULL;
            }
                
            if( lsReturn!=LICENSE_STATUS_CONTINUE )
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
            break;
        }
       
    case HS_NEW_LICENSE: 
            fNew = TRUE;
            DebugLog((DEB_TRACE, "New License received from Server.\n"));
    case HS_UPGRADE_LICENSE:
        {
            Hydra_Server_New_License    NewLicense;

            if (dwTemp > MAX_ALLOWABLE_LICENSE_SIZE)
            {
                //
                // SECURITY: Too much data to store in the registry
                // Reject the message
                //

                LS_LOG_RESULT(lsReturn = LICENSE_STATUS_INVALID_INPUT);
                goto ErrorReturn;
            }

            memset(&NewLicense, 0x00, sizeof(Hydra_Server_New_License));


            DebugLog((DEB_TRACE, "Unpacking Hydra Server's New License Message : %4d\n", dwTemp));

            if(LICENSE_STATUS_OK !=
                (lsReturn = UnPackHydraServerNewLicense(pbTemp, 
                                                        dwTemp, 
                                                        &NewLicense)) )
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }

            DebugLog((DEB_TRACE, "License Client handles New License : %4d\n", *pcbOutput));
            lsReturn = LicenseClientHandleNewLicense(pContext, 
                                                     &NewLicense,
                                                     fNew,
                                                     pbOutput, 
                                                     pcbOutput);


            if(NewLicense.EncryptedNewLicenseInfo.pBlob)
            {
                free(NewLicense.EncryptedNewLicenseInfo.pBlob);
                NewLicense.EncryptedNewLicenseInfo.pBlob = NULL;
            }

#if DBG
            if(pbOutput)
                OutputDebugString(_T("Client response data : \n"));
            LS_DUMPSTRING(*pcbOutput, pbOutput);
#endif

            if( lsReturn != LICENSE_STATUS_OK )
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
            break;
        }
    default:
        //
        // Invalid message type
        //

        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        goto ErrorReturn;
        break;
    }
    LS_LOG_RESULT(lsReturn);

CommonReturn:
    
    return lsReturn;
    LS_RETURN(lsReturn);

ErrorReturn:
    *pcbOutput = 0;

    goto CommonReturn;
}

LICENSE_STATUS
CALL_TYPE
LicenseClientHandleServerError(
                               PLicense_Client_Context  pContext,
                               PLicense_Error_Message   pCanonical,
                               UINT32                   *puiExtendedErrorInfo,
                               BYTE FAR *               pbMessage,
                               DWORD FAR *              pcbMessage
                               )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    LS_BEGIN(TEXT("LicenseClientHandleServerError"));

    if(NULL == pContext || NULL == pCanonical || NULL == pcbMessage || NULL == puiExtendedErrorInfo)
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        return lsReturn;        
    }
    
    // Switch on the StateTransition as this dictates the next state
    // client has to take!

    switch(pCanonical->dwStateTransition)
    {
    
    case ST_TOTAL_ABORT: //Server has asked for a total abort
        *pcbMessage = 0;
        if( pCanonical->dwErrorCode == GM_HS_ERR_INVALID_CLIENT ||
            pCanonical->dwErrorCode == GM_HS_ERR_INVALID_SCOPE  ||
            pCanonical->dwErrorCode == GM_HS_ERR_INVALID_PRODUCTID ||
            pCanonical->dwErrorCode == GM_HS_ERR_INVALID_CLIENT )
        {
            lsReturn = LICENSE_STATUS_SERVER_ABORT;
        }
        else
            lsReturn = LICENSE_STATUS_CLIENT_ABORT;

        pContext->dwState = LICENSE_CLIENT_STATE_ABORT;
        pContext->cbLastMessage = 0;
        break;
    
    case ST_NO_TRANSITION:
        lsReturn = LICENSE_STATUS_OK;
        *pcbMessage = 0;
        break;
    
    case ST_RESEND_LAST_MESSAGE:
        // Server has asked to send the last send message again!
        // treat as error (fall through)

    case ST_RESET_PHASE_TO_START:
        // Server has asked to restart the negotiation
        // treat as error (fall through)

    default:
        // Server sent unknown dwStateTransition

        lsReturn = LICENSE_STATUS_CLIENT_ABORT;
        pContext->dwState = LICENSE_CLIENT_STATE_ABORT;
        pContext->cbLastMessage = 0;
        break;

    }

    if ((lsReturn != LICENSE_STATUS_OK) && (pCanonical->bbErrorInfo.wBlobLen > 0) && (pCanonical->bbErrorInfo.pBlob != NULL))
    {
        // ignore any errors

        UnPackExtendedErrorInfo(puiExtendedErrorInfo,&(pCanonical->bbErrorInfo));
    }

    LS_LOG_RESULT(lsReturn);
    return lsReturn;
}

LICENSE_STATUS
CALL_TYPE
LicenseClientHandleServerRequest(
                               PLicense_Client_Context          pContext,
                               PHydra_Server_License_Request    pCanonical,
                               BOOL                             fNewLicense,
                               BYTE FAR *                       pbMessage,
                               DWORD FAR *                      pcbMessage,
                               BOOL                             fExtendedError
                               )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    UCHAR               Random[LICENSE_RANDOM];
    UCHAR               PreMasterSecret[LICENSE_PRE_MASTER_SECRET];
    HANDLE      hStore = NULL;
    LSINDEX     lsIndex;
    DWORD       dwCount = 0;
    BYTE FAR *      pbData = NULL;
    DWORD       cbData = 0;

    LS_BEGIN(TEXT("LicenseClientHandleServerRequest"));

    memset(&lsIndex, 0x00, sizeof(LSINDEX));


    if( (pContext == NULL) || (pCanonical == NULL)  )
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    if(pContext->dwState != LICENSE_CLIENT_STATE_WAIT_SERVER_HELLO)
    {
        lsReturn = LICENSE_STATUS_INVALID_CLIENT_STATE;
        goto ErrorReturn;
    }

    if( pContext->dwContextFlags & LICENSE_CONTEXT_NO_SERVER_AUTHENTICATION )
    {
        //
        // No server authentication required, make sure that we have the
        // public key or the certificate of the server so that we can use it to 
        // encrypt the pre-master secret during the next phase of the licensing protocol.
        // 
    
        if( ( NULL == pContext->pbServerPubKey ) && ( NULL == pContext->pServerCert ) )
        {
            lsReturn = LICENSE_STATUS_CONTEXT_INITIALIZATION_ERROR;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        
    }
    else
    {
        //
        // Do Hydra server authentication by validating the server certificate
        //
        
        DWORD
            dwCertVersion;

        if( ( 0 >= pCanonical->ServerCert.wBlobLen ) ||
            ( NULL == pCanonical->ServerCert.pBlob ) )
        {
            //
            // make sure that we have received a certificate from the server
            //

            lsReturn = LICENSE_STATUS_NO_CERTIFICATE;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }

        //
        // Determine the version of the certificate so that we can decode and
        // validate it correctly.
        //

        memcpy( ( char * )&dwCertVersion, pCanonical->ServerCert.pBlob, sizeof( DWORD ) );      
        
        if( CERT_CHAIN_VERSION_2 > dwCertVersion )
        {
            Hydra_Server_Cert ServerCert;

            //
            // Validate a proprietory certificate
            //

            memset( &ServerCert, 0, sizeof( ServerCert ) );

            if( !UnpackServerCert(pCanonical->ServerCert.pBlob,
                                  (DWORD)pCanonical->ServerCert.wBlobLen,
                                  &ServerCert) )
            {
                lsReturn = LICENSE_STATUS_UNSPECIFIED_ERROR;
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
        
            //Now verify the signature on the server certificate

            if(!ValidateServerCert(&ServerCert) )
            {
                lsReturn = LICENSE_STATUS_UNSPECIFIED_ERROR;
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
            else
            {
                //
                // free any old certificate and remember the new one.
                //

                if( pContext->pServerCert )
                {
                    FreeProprietaryCertificate( &pContext->pServerCert );
                }
            
                lsReturn = LicenseSetCertificate( 
                                        ( HANDLE )pContext,
                                        &ServerCert );

                if( LICENSE_STATUS_OK != lsReturn )
                {
                    LS_LOG_RESULT( lsReturn );
                    goto ErrorReturn;
                }
            }
        }
        else
        {
            DWORD
                fDates =  CERT_DATE_DONT_VALIDATE;

            //
            // X509 certificate
            //

            //
            // this first call finds out the memory required for the public key
            //

            lsReturn = VerifyCertChain( pCanonical->ServerCert.pBlob, 
                                        ( DWORD )pCanonical->ServerCert.wBlobLen,
                                        NULL, 
                                        &pContext->cbServerPubKey,
                                        &fDates );

            if( LICENSE_STATUS_INSUFFICIENT_BUFFER == lsReturn )
            {
                if( pContext->pbServerPubKey )
                {
                    free( pContext->pbServerPubKey );
                }

                pContext->pbServerPubKey = malloc( pContext->cbServerPubKey );

                if( NULL == pContext->pbServerPubKey )
                {
                    lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
                    LS_LOG_RESULT(lsReturn);
                    goto ErrorReturn;
                }

                lsReturn = VerifyCertChain( pCanonical->ServerCert.pBlob, 
                                            ( DWORD )pCanonical->ServerCert.wBlobLen,
                                            pContext->pbServerPubKey, 
                                            &pContext->cbServerPubKey,
                                            &fDates );
            }

            if( LICENSE_STATUS_OK != lsReturn )
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
        }
    }

    if(pContext->pCryptParam == NULL)
    {
        lsReturn = LICENSE_STATUS_INITIALIZATION_FAILED;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    //Copy Server Random to pCryptSystem->rgbServerRandom
    memcpy(pContext->pCryptParam->rgbServerRandom, pCanonical->ServerRandom, LICENSE_RANDOM);
    
    LicenseDebugOutput("Server Random : \n");
    LS_DUMPSTRING(LICENSE_RANDOM, pContext->pCryptParam->rgbServerRandom);

    //Generate 32 byte Client Random
    if (!TSRNG_GenerateRandomBits(Random, LICENSE_RANDOM))
    {
        lsReturn = LICENSE_STATUS_CONTEXT_INITIALIZATION_ERROR;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //Copy ClientRandom to pContext->pCryptParam
    memcpy(pContext->pCryptParam->rgbClientRandom, Random, LICENSE_RANDOM);
    
    LicenseDebugOutput("Client Random : \n");
    LS_DUMPSTRING(LICENSE_RANDOM, pContext->pCryptParam->rgbClientRandom);
    
    //Generate 48 byte long PreMasterSecret
    if (!TSRNG_GenerateRandomBits(PreMasterSecret, LICENSE_PRE_MASTER_SECRET))
    {
        lsReturn = LICENSE_STATUS_CONTEXT_INITIALIZATION_ERROR;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    LicenseDebugOutput("Pre Master Secret : \n");
    LS_DUMPSTRING(LICENSE_PRE_MASTER_SECRET, PreMasterSecret);

    //Copy Premastersecret to pCryptParam
    lsReturn = LicenseSetPreMasterSecret(pContext->pCryptParam, PreMasterSecret);
    
    
    //Search in the store to find an appropriate License

    //To do that, first open the system store.
    if( LICENSE_STATUS_OK != (lsReturn = MapStoreError(LSOpenLicenseStore(&hStore, NULL, TRUE))) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    //Initialize lsIndex structure with the values sent by the Server
    lsIndex.dwVersion = pCanonical->ProductInfo.dwVersion;
    lsIndex.cbCompany = pCanonical->ProductInfo.cbCompanyName;

    if( NULL == (lsIndex.pbCompany = (LPSTR)malloc(lsIndex.cbCompany)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    memset(lsIndex.pbCompany, 0x00, lsIndex.cbCompany); 
    memcpy(lsIndex.pbCompany, pCanonical->ProductInfo.pbCompanyName, lsIndex.cbCompany); 
    
    lsIndex.cbProductID = pCanonical->ProductInfo.cbProductID;

    if( NULL == (lsIndex.pbProductID = (LPSTR)malloc(lsIndex.cbProductID)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    memset(lsIndex.pbProductID, 0x00, lsIndex.cbProductID); 
    memcpy(lsIndex.pbProductID, pCanonical->ProductInfo.pbProductID, lsIndex.cbProductID ); 
    
    for(dwCount=0; dwCount<pCanonical->ScopeList.dwScopeCount; dwCount ++)
    {
        DWORD dwProtVer = PREAMBLE_VERSION_1_0;
        lsIndex.cbScope = pCanonical->ScopeList.Scopes[dwCount].wBlobLen;
        if( NULL == (lsIndex.pbScope = (LPSTR)malloc(lsIndex.cbScope)) )
        {
            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            continue;
        }
        
        //Initialize pszScope member of the lsIndex with the ith element in the scopelist
        memset(lsIndex.pbScope, 0x00, lsIndex.cbScope);
        memcpy(lsIndex.pbScope, pCanonical->ScopeList.Scopes[dwCount].pBlob, lsIndex.cbScope);
                
        if( LICENSE_STATUS_OK != (lsReturn = MapStoreError(LSFindLicenseInStore(hStore, 
                                                                                &lsIndex, 
                                                                                &cbData, 
                                                                                NULL))) )
        {
            if(lsIndex.pbScope) 
            {
                free(lsIndex.pbScope);
                lsIndex.pbScope = NULL;
            }
            continue;
        }

        //
        // NOTE:  this line was previously
        // if(pContext->dwProtocolVersion != PREAMBLE_VERSION_2_0) for
        // Hydra 4.0 clients, which means that a pseudo license will be
        // generated for licensing protocol later than 2.0 as well!
        // To overcome this problem, Hydra 5.0 server will use the 
        // PREAMBLE_VERSION_2_0 for Hydra 4.0 clients.
        //

        if( GET_PREAMBLE_VERSION( pContext->dwProtocolVersion ) < PREAMBLE_VERSION_2_0)
        {
            if( !GeneratePseudoLicense(&cbData, &pbData) )
            {
                lsReturn = LICENSE_STATUS_UNSPECIFIED_ERROR;
                if(lsIndex.pbScope)
                {
                    free(lsIndex.pbScope);
                    lsIndex.pbScope = NULL;
                }
                goto ErrorReturn;
            }
            lsReturn = LICENSE_STATUS_OK;
            if(lsIndex.pbScope)
            {
                free(lsIndex.pbScope);
                lsIndex.pbScope = NULL;
            }
            break;
        }
        if(cbData == 0)
        {
            if(lsIndex.pbScope)
            {
                free(lsIndex.pbScope);
                lsIndex.pbScope = NULL;
            }
            continue;
        }   
        if( NULL == (pbData=(BYTE FAR *)malloc(cbData)) )
        {   
            if(lsIndex.pbScope)
            {
                free(lsIndex.pbScope);
                lsIndex.pbScope = NULL;
            }
            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            continue;
        }
        if( LICENSE_STATUS_OK != (lsReturn = MapStoreError(LSFindLicenseInStore(hStore, 
                                                                                &lsIndex, 
                                                                                &cbData, 
                                                                                pbData))) )
        {
            if(lsIndex.pbScope)
            {
                free(lsIndex.pbScope);
                lsIndex.pbScope = NULL;
            }
            continue;
        }
        
        LicenseDebugOutput("License Info Data : \n");
        LS_DUMPSTRING(cbData, pbData);

        lsReturn = LICENSE_STATUS_OK;
        if(lsIndex.pbScope)
        {
            free(lsIndex.pbScope);
            lsIndex.pbScope = NULL;
        }
        break;
    }

    //If a license is found in the store, then Continue with Hydra_Client_License_Info message
    if( LICENSE_STATUS_OK == lsReturn )
    {
        if( LICENSE_STATUS_CONTINUE != (lsReturn = ClientConstructLicenseInfo(pContext, 
                                                                        pbData, 
                                                                        cbData, 
                                                                        pbMessage, 
                                                                        pcbMessage,
                                                                        fExtendedError)) )
        {
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        goto CommonReturn;
    }

    //Else if no license if found, then depending on fNewLicense, either Request for a new license
    //or, abort connection

    else if(lsReturn == LICENSE_STATUS_NO_LICENSE_ERROR)
    {
        if(fNewLicense)
        {
            if( LICENSE_STATUS_CONTINUE != (lsReturn = ClientConstructNewLicenseRequest(pContext, 
                                                                                  pbMessage, 
                                                                                  pcbMessage,
                                                                                  fExtendedError)) )
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
            goto CommonReturn;
        }
        else    //Generate an error message and close connection
        {
            if( LICENSE_STATUS_CLIENT_ABORT != (lsReturn = ClientConstructErrorAlert(pContext, 
                                                                           GM_HC_ERR_NO_LICENSE, 
                                                                           ST_TOTAL_ABORT,
                                                                           NULL,
                                                                           0,
                                                                           pbMessage,
                                                                           pcbMessage,
                                                                           fExtendedError
                                                                           )) )
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
        }
    }

    LS_LOG_RESULT(lsReturn);

CommonReturn:

    //
    // close license store
    //
    
    if( hStore )
    {
        LSCloseLicenseStore(hStore);
        hStore = NULL;
    }
    
    if(pbData)
    {
        free(pbData);
        pbData = NULL;
    }
    if(lsIndex.pbCompany)
    {
        free(lsIndex.pbCompany);
        lsIndex.pbCompany = NULL;
    }
    if(lsIndex.pbProductID)
    {
        free(lsIndex.pbProductID);
        lsIndex.pbProductID = NULL;
    }
    if(lsIndex.pbScope)
    {
        free(lsIndex.pbScope);
        lsIndex.pbScope = NULL;
    }
    return lsReturn;
    //LS_RETURN(lsReturn);
ErrorReturn:
    *pcbMessage = 0;

    if( pContext != NULL)
    {
        if(pContext->pServerCert)
        {
            free(pContext->pServerCert);
            pContext->pServerCert = NULL;
        }

        if( pContext->pbServerPubKey )
        {
            free( pContext->pbServerPubKey );
            pContext->pbServerPubKey = NULL;
        }
    }

    goto CommonReturn;
}


LICENSE_STATUS
CALL_TYPE
LicenseClientHandleServerPlatformChallenge(
                               PLicense_Client_Context          pContext,
                               PHydra_Server_Platform_Challenge pCanonical,
                               BYTE FAR *                       pbMessage,
                               DWORD FAR *                      pcbMessage,
                               BOOL                             fExtendedError
                               )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    Hydra_Client_Platform_Challenge_Response    Response;
    
    BYTE                MACData[LICENSE_MAC_DATA];
    HWID                hwid;
    BYTE FAR *          pbData = NULL;
    UCHAR *             LocalBuf = NULL;
    DWORD               cbData = 0;

    LS_BEGIN(TEXT("LicenseClientHandleServerPlatformChallenge"));


    if( (pContext == NULL) || (pCanonical == NULL) || (pcbMessage == NULL) )
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }


    memset(&Response, 0x00, sizeof(Hydra_Client_Platform_Challenge_Response));

    
    if( (pContext->dwState != LICENSE_CLIENT_STATE_LICENSE_RESPONSE) &&
        (pContext->dwState != LICENSE_CLIENT_STATE_NEW_LICENSE_REQUEST) )
    {
        lsReturn = LICENSE_STATUS_INVALID_CLIENT_STATE;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //First decrypt the encrypted platform challenge
    if( LICENSE_STATUS_OK != (lsReturn = LicenseDecryptSessionData(pContext->pCryptParam,
                                                                  pCanonical->EncryptedPlatformChallenge.pBlob,
                                                                  (DWORD)pCanonical->EncryptedPlatformChallenge.wBlobLen)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    //Generate the MAC with the decrypted platform Challenge
    if( LICENSE_STATUS_OK != (lsReturn = LicenseGenerateMAC(pContext->pCryptParam,
                                                            pCanonical->EncryptedPlatformChallenge.pBlob,
                                                            (DWORD)pCanonical->EncryptedPlatformChallenge.wBlobLen,
                                                           MACData
                                                           )) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    LicenseDebugOutput(" Client generated MAC data to verify Server's message Authenticity : \n");
    LS_DUMPSTRING(LICENSE_MAC_DATA, MACData);
    

    //Compare the generated MAC with the one sent by the server
    if( memcmp(MACData, pCanonical->MACData, LICENSE_MAC_DATA) )
    {
        lsReturn = LICENSE_STATUS_INVALID_MAC_DATA;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //Generate Platform Challenge Response
    if( LICENSE_STATUS_OK != (lsReturn = ClientGenerateChallengeResponse(pContext,
                                                                         &pCanonical->EncryptedPlatformChallenge,
                                                                         &Response.EncryptedChallengeResponse)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;

    }

    //Generate HWID, Encrypt it using the Session key and put it in the Response
    memset(&hwid, 0x00, sizeof(HWID));
    if( LICENSE_STATUS_OK != (lsReturn = GenerateClientHWID(&hwid)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }


    //GenerateClientHWID(&hwid);
    LicenseDebugOutput("HWID in byte : \n");

    LS_DUMPSTRING(sizeof(HWID), (BYTE FAR *)&hwid);


    Response.EncryptedHWID.wBlobType = BB_DATA_BLOB;
    Response.EncryptedHWID.wBlobLen = sizeof(HWID);
    if( NULL == (Response.EncryptedHWID.pBlob = (BYTE FAR *)malloc(Response.EncryptedHWID.wBlobLen)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    memset(Response.EncryptedHWID.pBlob, 0x00, Response.EncryptedHWID.wBlobLen);
    memcpy(Response.EncryptedHWID.pBlob, &hwid, Response.EncryptedHWID.wBlobLen);
    
    if( NULL == (LocalBuf = (UCHAR *)malloc(Response.EncryptedChallengeResponse.wBlobLen + 
        Response.EncryptedHWID.wBlobLen)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    cbData += Response.EncryptedChallengeResponse.wBlobLen;
    memcpy(LocalBuf, Response.EncryptedChallengeResponse.pBlob, Response.EncryptedChallengeResponse.wBlobLen);
    memcpy(LocalBuf + cbData, Response.EncryptedHWID.pBlob, Response.EncryptedHWID.wBlobLen);
    cbData += Response.EncryptedHWID.wBlobLen;
    
    //Generate MACData and put it in the Response
    if( LICENSE_STATUS_OK != (lsReturn = LicenseGenerateMAC(pContext->pCryptParam,
                                                            LocalBuf,
                                                            cbData,
                                                            Response.MACData)) )
    {
        free(LocalBuf);
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    free(LocalBuf);

    //Now encrypt the platform challenge response using the negotiated session key
    if( LICENSE_STATUS_OK != (lsReturn = LicenseEncryptSessionData(pContext->pCryptParam,
                                                                   Response.EncryptedChallengeResponse.pBlob,
                                                                   Response.EncryptedChallengeResponse.wBlobLen
                                                                   )) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //Encrypt the HWID with generated session key
    if( LICENSE_STATUS_OK != (lsReturn = LicenseEncryptSessionData(pContext->pCryptParam, 
                                                                   Response.EncryptedHWID.pBlob,
                                                                   (DWORD)Response.EncryptedHWID.wBlobLen)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //Now we have our Platform challenge Response Ready. Pack the data in a byte stream
    if( LICENSE_STATUS_OK != (lsReturn = PackHydraClientPlatformChallengeResponse(&Response,
                                                                                  fExtendedError,
                                                                                  pbMessage,
                                                                                  pcbMessage)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    // Set appropriate state and data in proper places
    
    //Set the MACData in the CryptSystem MAC buffer.
    memcpy(pContext->rgbMACData, Response.MACData, LICENSE_MAC_DATA);
    
    //Set the state of the context to LICENSE_CLIENT_STATE_PLATFORM_CHALLENGE_RESPONSE
    //provided data was written in the  output. i.e pbMessage is not NULL

    if(pbMessage)
        pContext->dwState = LICENSE_CLIENT_STATE_PLATFORM_CHALLENGE_RESPONSE;

    //Copy the whole message to the context
    pContext->cbLastMessage = *pcbMessage;
    if(pbMessage)
    {
        if( pContext->pbLastMessage )
        {
            free( pContext->pbLastMessage );
        }

        if( NULL == (pContext->pbLastMessage = (BYTE FAR *)malloc(pContext->cbLastMessage)) )
        {
            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        memset(pContext->pbLastMessage, 0x00, pContext->cbLastMessage);
        memcpy(pContext->pbLastMessage, pbMessage, pContext->cbLastMessage);
    }

    lsReturn = LICENSE_STATUS_CONTINUE;

    LS_LOG_RESULT(lsReturn);                                                                         
CommonReturn:
    //LICENSE_LOG_RESULT(lsReturn);

    if(Response.EncryptedChallengeResponse.pBlob)
    {
        free(Response.EncryptedChallengeResponse.pBlob);
        Response.EncryptedChallengeResponse.pBlob = NULL;
    }
    if(Response.EncryptedHWID.pBlob)
    {
        free(Response.EncryptedHWID.pBlob);
        Response.EncryptedHWID.pBlob = NULL;
    }
    return lsReturn;
    //LS_RETURN(lsReturn);
ErrorReturn:
    *pcbMessage = 0;
    goto CommonReturn;
}

LICENSE_STATUS
CALL_TYPE
LicenseClientHandleNewLicense(
                               PLicense_Client_Context      pContext,
                               PHydra_Server_New_License    pCanonical,
                               BOOL                         fNew,
                               BYTE FAR *                   pbMessage,
                               DWORD FAR *                  pcbMessage
                               )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    New_License_Info    NewLicense;
    BYTE                MACData[LICENSE_MAC_DATA];
    Binary_Blob         bbData;
    LSINDEX             lsIndex;
    HANDLE              hStore = NULL;

    LS_BEGIN(TEXT("LicenseClientHandleNewLicense"));

    if(NULL == pContext || NULL == pCanonical )
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    memset(&bbData, 0x00, sizeof(Binary_Blob));
    memset(&NewLicense, 0x00, sizeof(New_License_Info));
    memset(&lsIndex, 0x00, sizeof(LSINDEX));

    //First decrypt the encrypted license info
    if( LICENSE_STATUS_OK != (lsReturn = LicenseDecryptSessionData(pContext->pCryptParam,
                                                                   pCanonical->EncryptedNewLicenseInfo.pBlob,
                                                                   ( DWORD )( pCanonical->EncryptedNewLicenseInfo.wBlobLen ))) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //Generate the MAC data with the decrypted data
    if( LICENSE_STATUS_OK != (lsReturn = LicenseGenerateMAC(pContext->pCryptParam,
                                                            pCanonical->EncryptedNewLicenseInfo.pBlob,
                                                            (DWORD)pCanonical->EncryptedNewLicenseInfo.wBlobLen,
                                                            MACData)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //Compare this MAC with the one sent by the Server.
    if(memcmp(MACData, pCanonical->MACData, LICENSE_MAC_DATA))
    {
        lsReturn = LICENSE_STATUS_INVALID_MAC_DATA;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    if( LICENSE_STATUS_OK != (lsReturn = UnpackNewLicenseInfo(pCanonical->EncryptedNewLicenseInfo.pBlob,
                                                             (DWORD)pCanonical->EncryptedNewLicenseInfo.wBlobLen,
                                                              &NewLicense)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    //Try to open the system license store
    if( LICENSE_STATUS_OK != (lsReturn = MapStoreError(LSOpenLicenseStore(&hStore, NULL, FALSE))) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }   
    
    //Initialize the LSINDEX structure. This structure will be used to add/replace a license in the store

    //To do that, first initialize version info
    lsIndex.dwVersion = NewLicense.dwVersion;

    //Initialize Scope info
    lsIndex.cbScope = NewLicense.cbScope;
    if( NULL == (lsIndex.pbScope = (LPSTR)malloc(lsIndex.cbScope)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    memset(lsIndex.pbScope, 0x00, lsIndex.cbScope);
    memcpy(lsIndex.pbScope, NewLicense.pbScope, lsIndex.cbScope);
    

    //Initialize CompanyName info
    lsIndex.cbCompany = NewLicense.cbCompanyName;
    if( NULL == (lsIndex.pbCompany = (LPSTR)malloc(lsIndex.cbCompany)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    memset(lsIndex.pbCompany, 0x00, lsIndex.cbCompany);
    memcpy(lsIndex.pbCompany, NewLicense.pbCompanyName, lsIndex.cbCompany);
    

    //Initialize ProductID info
    lsIndex.cbProductID = NewLicense.cbProductID;
    if( NULL == (lsIndex.pbProductID = (LPSTR)malloc(lsIndex.cbProductID)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    memset(lsIndex.pbProductID, 0x00, lsIndex.cbProductID);
    memcpy(lsIndex.pbProductID, NewLicense.pbProductID, lsIndex.cbProductID);
    
    
    LS_LOG_RESULT(lsReturn);
    
    if( LICENSE_STATUS_OK != (lsReturn = LSAddLicenseToStore(hStore,
                                                             LS_REPLACE_LICENSE_OK,
                                                             &lsIndex,
                                                             NewLicense.pbLicenseInfo,
                                                             NewLicense.cbLicenseInfo
                                                             )) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    
    //Update state info and inform that the License Verification is over and the client can carry on 
    //with further connection!
    pContext->dwState = LICENSE_CLIENT_STATE_DONE;

    memset(pContext->rgbMACData, 0x00, LICENSE_MAC_DATA);

    //Reset the last send message to 0;
    if(pContext->pbLastMessage)
    {
        memset(pContext->pbLastMessage, 0x00, pContext->cbLastMessage);
        free(pContext->pbLastMessage);
        pContext->pbLastMessage = NULL;
    }
    pContext->cbLastMessage = 0;
    
    lsReturn = LICENSE_STATUS_OK;

CommonReturn:
    
    if( hStore )
    {
        LSCloseLicenseStore( hStore );
    }

    if(NewLicense.pbScope)
    {
        free(NewLicense.pbScope);
        NewLicense.pbScope = NULL;
    }
    
    if(NewLicense.pbCompanyName)
    {
        free(NewLicense.pbCompanyName);
        NewLicense.pbCompanyName = NULL;
    }

    if(NewLicense.pbProductID)
    {
        free(NewLicense.pbProductID);
        NewLicense.pbProductID = NULL;
    }

    if(NewLicense.pbLicenseInfo)
    {
        free(NewLicense.pbLicenseInfo);
        NewLicense.pbLicenseInfo = NULL;
    }

    if(lsIndex.pbScope)
    {
        free(lsIndex.pbScope);
        lsIndex.pbScope = NULL;
    }

    if(lsIndex.pbCompany)
    {
        free(lsIndex.pbCompany);
        lsIndex.pbCompany = NULL;
    }
    if(lsIndex.pbProductID)
    {
        free(lsIndex.pbProductID);
        lsIndex.pbProductID = NULL;
    }

    if(bbData.pBlob)
    {
        free(bbData.pBlob);
        bbData.pBlob = NULL;
    }

    return lsReturn;

ErrorReturn:
    goto CommonReturn;
}


LICENSE_STATUS 
CALL_TYPE
ClientConstructLicenseInfo(
                           PLicense_Client_Context  pContext,
                           BYTE FAR *               pbInput,
                           DWORD                    cbInput,
                           BYTE FAR *               pbOutput,
                           DWORD    FAR *           pcbOutput,
                           BOOL                     fExtendedError
                           )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    Hydra_Client_License_Info   Canonical;
    HWID                        hwid;
    Binary_Blob                 bbPreMasterSecret;
    DWORD                       dwSize = 0;
    DWORD                       dwState = 0;
    PBYTE                       pbServerPubKey;
    DWORD                       cbServerPubKey;

    LS_BEGIN(TEXT("ClientContstructLicenseInfo"));

    if(NULL == pContext || NULL == pcbOutput)
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }    
    
    //Construct the messages
    bbPreMasterSecret.wBlobType = BB_RANDOM_BLOB;
    bbPreMasterSecret.wBlobLen = LICENSE_PRE_MASTER_SECRET;
    if( NULL == (bbPreMasterSecret.pBlob = (BYTE FAR *)malloc(LICENSE_PRE_MASTER_SECRET)) )
    {
    
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    memcpy(bbPreMasterSecret.pBlob, pContext->pCryptParam->rgbPreMasterSecret, LICENSE_PRE_MASTER_SECRET);
    memset(&Canonical, 0x00, sizeof(Hydra_Client_License_Info));

    //RSA is hardcoded for the time being
    Canonical.dwPrefKeyExchangeAlg = pContext->pCryptParam->dwKeyExchAlg;
    
#ifdef OS_WINCE
    Canonical.dwPlatformID =  CLIENT_OS_ID_OTHER | CLIENT_IMAGE_ID_MICROSOFT;
#else   // WinNT or Win9x
    {
        DWORD dwVersion = GetVersion();

        if (dwVersion & 0x80000000) {
            // Win95
            Canonical.dwPlatformID = CLIENT_OS_ID_OTHER | CLIENT_IMAGE_ID_MICROSOFT;
        } else {

            OSVERSIONINFOEX ovix;
            BOOL b;       
            ovix.dwOSVersionInfoSize = sizeof(ovix);
            b = GetVersionEx((LPOSVERSIONINFO) &ovix);            
            if(b && ((ovix.wSuiteMask & VER_SUITE_EMBEDDEDNT) || (ovix.wSuiteMask & VER_SUITE_PERSONAL)))
            {
                Canonical.dwPlatformID = CLIENT_OS_ID_WINNT_40 | CLIENT_IMAGE_ID_MICROSOFT;
            }            
            else
            {

                // WinNT
                Canonical.dwPlatformID = CLIENT_IMAGE_ID_MICROSOFT |
                    ((((DWORD)(LOBYTE(LOWORD(dwVersion)))) - 2) << 24);
			    
			    Canonical.dwPlatformID |= (DWORD)(HIBYTE(LOWORD(dwVersion)));
            }
		
        }
    }
#endif

    //ClientRandom
    memcpy(Canonical.ClientRandom, pContext->pCryptParam->rgbClientRandom, LICENSE_RANDOM);
    
    if( pContext->pServerCert )
    {
        //
        // This public key is used for pre-Hydra 5.0 servers that are using proprietory
        // server certificates.
        //

        pbServerPubKey = pContext->pServerCert->PublicKeyData.pBlob;
        cbServerPubKey = pContext->pServerCert->PublicKeyData.wBlobLen;
    }
    else
    {
        pbServerPubKey = pContext->pbServerPubKey;
        cbServerPubKey = pContext->cbServerPubKey;
    }

    //We have to switch here depending on the key exchange algorithm to be used -Shubho
    if( LICENSE_STATUS_OK != (lsReturn = LicenseEnvelopeData(pbServerPubKey,
                                                             cbServerPubKey,
                                                             bbPreMasterSecret.pBlob,
                                                             bbPreMasterSecret.wBlobLen,
                                                             NULL,
                                                             &dwSize)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    if( NULL == (Canonical.EncryptedPreMasterSecret.pBlob = (BYTE FAR *)malloc(dwSize)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    memset(Canonical.EncryptedPreMasterSecret.pBlob, 0x00, dwSize);
    
    if( LICENSE_STATUS_OK != (lsReturn = LicenseEnvelopeData(pbServerPubKey,
                                                             cbServerPubKey,
                                                             bbPreMasterSecret.pBlob,
                                                             bbPreMasterSecret.wBlobLen,
                                                             Canonical.EncryptedPreMasterSecret.pBlob,
                                                             &dwSize)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    Canonical.EncryptedPreMasterSecret.wBlobLen = (WORD)dwSize;

    //Fill up LicenseInfo buffer
    Canonical.LicenseInfo.wBlobType = BB_DATA_BLOB;
    Canonical.LicenseInfo.wBlobLen = (WORD)cbInput;
    if( NULL == (Canonical.LicenseInfo.pBlob = (BYTE FAR *)malloc(Canonical.LicenseInfo.wBlobLen)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    memset(Canonical.LicenseInfo.pBlob, 0x00, Canonical.LicenseInfo.wBlobLen);
    memcpy(Canonical.LicenseInfo.pBlob, pbInput, Canonical.LicenseInfo.wBlobLen);
    

    //Generate HWID and put the data in a binary_blob to encrypt
    memset(&hwid, 0x00, sizeof(HWID));
    
    if( LICENSE_STATUS_OK != (lsReturn = GenerateClientHWID(&hwid)) )
    {   
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    Canonical.EncryptedHWID.wBlobType = BB_DATA_BLOB;
    Canonical.EncryptedHWID.wBlobLen = sizeof(HWID);
    if( NULL == (Canonical.EncryptedHWID.pBlob = (BYTE FAR *)malloc(Canonical.EncryptedHWID.wBlobLen)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    memset(Canonical.EncryptedHWID.pBlob, 0x00, Canonical.EncryptedHWID.wBlobLen);
    memcpy(Canonical.EncryptedHWID.pBlob, &hwid, Canonical.EncryptedHWID.wBlobLen);

    dwState = pContext->pCryptParam->dwCryptState;
    //Generate the session key and MACsalt
    if( LICENSE_STATUS_OK != (lsReturn = LicenseBuildMasterSecret(pContext->pCryptParam)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    if( LICENSE_STATUS_OK != (lsReturn = LicenseMakeSessionKeys(pContext->pCryptParam, 0)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //Encrypt the HWID with generated session key
    if( LICENSE_STATUS_OK != (lsReturn = LicenseEncryptSessionData(pContext->pCryptParam, 
                                                                   Canonical.EncryptedHWID.pBlob,
                                                                   (DWORD)Canonical.EncryptedHWID.wBlobLen)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    //Generate the MAC with original HWID
    LicenseGenerateMAC(pContext->pCryptParam, ( BYTE FAR * )&hwid, sizeof(hwid), Canonical.MACData);
    
    //Now everything is ready, so pack the data 
    if( LICENSE_STATUS_OK != (lsReturn = PackHydraClientLicenseInfo(&Canonical, fExtendedError, pbOutput, pcbOutput)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    //Set the MACData in the CryptSystem MAC buffer.
    memcpy(pContext->rgbMACData, Canonical.MACData, LICENSE_MAC_DATA);
    
    //Set the state of the context to LICENSE_CLIENT_STATE_LICENSE_RESPONSE
    //if any output data is written. i.e. pbOutput is not null. Also revert back
    //the crypparam state as this will also be called twice and we change the state
    //only when we have written something in the output!!!!! - bad!!!!!
    if(pbOutput)
    {
        pContext->dwState = LICENSE_CLIENT_STATE_LICENSE_RESPONSE;
    }
    
    else    //Restore earlier CryptSystem States
    {
        pContext->pCryptParam->dwCryptState = dwState;
        memcpy(pContext->pCryptParam->rgbPreMasterSecret, bbPreMasterSecret.pBlob, LICENSE_PRE_MASTER_SECRET);
        memset(pContext->pCryptParam->rgbSessionKey, 0x00, LICENSE_SESSION_KEY);
        memset(pContext->pCryptParam->rgbMACSaltKey, 0x00, LICENSE_MAC_WRITE_KEY);
    }

    //Copy the whole message to the context
    pContext->cbLastMessage = *pcbOutput;
    if(pbOutput)
    {
        if( pContext->pbLastMessage )
        {
            free( pContext->pbLastMessage );
        }

        if( NULL == (pContext->pbLastMessage = (BYTE FAR *)malloc(pContext->cbLastMessage)) )
        {
            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        memset(pContext->pbLastMessage, 0x00, pContext->cbLastMessage);
        memcpy(pContext->pbLastMessage, pbOutput, pContext->cbLastMessage);
    }

    lsReturn = LICENSE_STATUS_CONTINUE;
    LS_LOG_RESULT(lsReturn);
CommonReturn:
    
    if(Canonical.EncryptedPreMasterSecret.pBlob)
    {
        free(Canonical.EncryptedPreMasterSecret.pBlob);
        Canonical.EncryptedPreMasterSecret.pBlob = NULL;
    }

    if(Canonical.LicenseInfo.pBlob)
    {
        free(Canonical.LicenseInfo.pBlob);
        Canonical.LicenseInfo.pBlob = NULL;
    }

    if(Canonical.EncryptedHWID.pBlob)
    {
        free(Canonical.EncryptedHWID.pBlob);
        Canonical.EncryptedHWID.pBlob = NULL;
    }
    
    if(bbPreMasterSecret.pBlob)
    {
        free(bbPreMasterSecret.pBlob);
        bbPreMasterSecret.pBlob = NULL;
    }

    return  lsReturn;
//  LS_RETURN(lsReturn);
ErrorReturn:
    *pcbOutput = 0;
    goto CommonReturn;
}

LICENSE_STATUS 
CALL_TYPE
ClientConstructNewLicenseRequest(
                           PLicense_Client_Context  pContext,
                           BYTE FAR *               pbOutput,
                           DWORD FAR *              pcbOutput,
                           BOOL                     fExtendedError
                           )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    Hydra_Client_New_License_Request    Request;
    Binary_Blob                         bbPreMasterSecret;
    DWORD                               dwSize = 0;
    DWORD                               dwState = 0;

#ifdef OS_WINCE

#define LS_MAX(a,b) ((a) > (b) ? (a) : (b))

    BYTE                                szUserName[LS_MAX((UNLEN + 1),HWID_STR_LEN)];
    DWORD                               cbUserName = sizeof(szUserName);
    BYTE                                szMachineName[LS_MAX(MAX_COMPUTERNAME_LENGTH + 1,HWID_STR_LEN)];
    DWORD                               cbMachineName = sizeof(szMachineName);

#else

    BYTE                                szUserName[(UNLEN + 1) * sizeof(TCHAR)];
    DWORD                               cbUserName = UNLEN + 1;
    BYTE                                szMachineName[(MAX_COMPUTERNAME_LENGTH + 1) * sizeof(TCHAR)];
    DWORD                               cbMachineName = (MAX_COMPUTERNAME_LENGTH + 1) * sizeof(TCHAR);

#endif

    PBYTE                               pbServerPubKey;
    DWORD                               cbServerPubKey;

    LS_BEGIN(TEXT("ClientConstructNewLicenseRequest"));

    if(NULL == pContext)
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    } 

    memset(szUserName,0,sizeof(szUserName));
    memset(szMachineName,0,sizeof(szMachineName));


    dwState = pContext->pCryptParam->dwCryptState;

    bbPreMasterSecret.wBlobType = BB_RANDOM_BLOB;
    bbPreMasterSecret.wBlobLen = LICENSE_PRE_MASTER_SECRET;
    if( NULL == (bbPreMasterSecret.pBlob = (BYTE FAR *)malloc(LICENSE_PRE_MASTER_SECRET)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    memcpy(bbPreMasterSecret.pBlob, pContext->pCryptParam->rgbPreMasterSecret, LICENSE_PRE_MASTER_SECRET);

    //Initialize the message
    memset(&Request, 0x00, sizeof(Hydra_Client_New_License_Request));

    //RSA is hardcoded for the time being
    Request.dwPrefKeyExchangeAlg = pContext->pCryptParam->dwKeyExchAlg;
    
    //PlatformID
#ifdef OS_WINCE
    Request.dwPlatformID =  CLIENT_OS_ID_OTHER | CLIENT_IMAGE_ID_MICROSOFT;
#else   // WinNT or Win9x
    {
        DWORD dwVersion = GetVersion();

        if (dwVersion & 0x80000000) {
            // Win95
            Request.dwPlatformID = CLIENT_OS_ID_OTHER | CLIENT_IMAGE_ID_MICROSOFT;
        } else {

            OSVERSIONINFOEX ovix;
            BOOL b;       
            ovix.dwOSVersionInfoSize = sizeof(ovix);
            b = GetVersionEx((LPOSVERSIONINFO) &ovix);            
            if(b && ((ovix.wSuiteMask & VER_SUITE_EMBEDDEDNT) || (ovix.wSuiteMask & VER_SUITE_PERSONAL)))
            {
                Request.dwPlatformID = CLIENT_OS_ID_WINNT_40 | CLIENT_IMAGE_ID_MICROSOFT;
            }            
            else
            {

                // WinNT
                Request.dwPlatformID = CLIENT_IMAGE_ID_MICROSOFT |
                ((((DWORD)(LOBYTE(LOWORD(dwVersion)))) - 2) << 24);
            }            
        }
    }
#endif

    //Copy ClientRandom
    memcpy(Request.ClientRandom, pContext->pCryptParam->rgbClientRandom, LICENSE_RANDOM);
    
    //Encrypt the Premastersecret using Server's Public key
    //We have to switch here depending on the key exchange algorithm to be used -Shubho

    if( pContext->pServerCert )
    {
        //
        // This public key is used for pre-Hydra 5.0 servers that are using proprietory
        // server certificates.
        //

        pbServerPubKey = pContext->pServerCert->PublicKeyData.pBlob;
        cbServerPubKey = pContext->pServerCert->PublicKeyData.wBlobLen;
    }
    else
    {
        pbServerPubKey = pContext->pbServerPubKey;
        cbServerPubKey = pContext->cbServerPubKey;
    }

    if( LICENSE_STATUS_OK != (lsReturn = LicenseEnvelopeData(pbServerPubKey,
                                                             cbServerPubKey,
                                                             bbPreMasterSecret.pBlob,
                                                             bbPreMasterSecret.wBlobLen,
                                                             NULL,
                                                             &dwSize)) )
    {
#if DBG
        OutputDebugString(_T("LicenseEnvelopeData failed"));
        LS_LOG_RESULT(lsReturn);
#endif
        goto ErrorReturn;
    }
    
    if( NULL == (Request.EncryptedPreMasterSecret.pBlob = (BYTE FAR *)malloc(dwSize)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    memset(Request.EncryptedPreMasterSecret.pBlob, 0x00, dwSize);
    
    if( LICENSE_STATUS_OK != (lsReturn = LicenseEnvelopeData(pbServerPubKey,
                                                             cbServerPubKey,
                                                             bbPreMasterSecret.pBlob,
                                                             bbPreMasterSecret.wBlobLen,
                                                             Request.EncryptedPreMasterSecret.pBlob,
                                                             &dwSize)) )
    {
#if DBG
        OutputDebugString(_T("LicenseEnvelopeData failed"));
        LS_LOG_RESULT(lsReturn);
#endif
        goto ErrorReturn;
    }

    Request.EncryptedPreMasterSecret.wBlobLen = (WORD)dwSize;

    //
    // initialize the user name binary blob
    //
#if !defined(OS_WINCE)
    GetUserName( (LPTSTR)szUserName, &cbUserName );
#elif defined(OS_WINCE)
    GetUserName( (LPSTR)szUserName, &cbUserName );
#endif  //OS_WINCE

    Request.ClientUserName.wBlobType = BB_CLIENT_USER_NAME_BLOB;
    Request.ClientUserName.wBlobLen = ( WORD )cbUserName;
    Request.ClientUserName.pBlob = szUserName;

    //
    // initialize the machine name binary blob
    //

#if defined(OS_WINCE)
    GetComputerName( (LPSTR)szMachineName, &cbMachineName );
#else
    GetComputerName( (LPTSTR)szMachineName, &cbMachineName );
#endif

    Request.ClientMachineName.wBlobType = BB_CLIENT_MACHINE_NAME_BLOB;
    Request.ClientMachineName.wBlobLen = ( WORD )cbMachineName + 1;
    Request.ClientMachineName.pBlob = szMachineName;
        
    //New License Request is ready. Now pack the data,
    if( LICENSE_STATUS_OK != (lsReturn = PackHydraClientNewLicenseRequest(&Request,
                                                                          fExtendedError,
                                                                          pbOutput, 
                                                                          pcbOutput)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //Anyway Generate the session key and MACsalt for future use
    if( LICENSE_STATUS_OK != (lsReturn = LicenseBuildMasterSecret(pContext->pCryptParam)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    if( LICENSE_STATUS_OK != (lsReturn = LicenseMakeSessionKeys(pContext->pCryptParam, 0)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //Set the MACData in the CryptSystem MAC buffer.
    memset(pContext->rgbMACData, 0x00, LICENSE_MAC_DATA);

    //Set the state of the context to LICENSE_CLIENT_STATE_NEW_LICENSE_REQUEST
    //if something is written on the output. i.e. pbOutput is not NULL
    if(pbOutput)
    {
        pContext->dwState = LICENSE_CLIENT_STATE_LICENSE_RESPONSE;
    }
    
    else    //Restore earlier CryptSystem States
    {
        pContext->pCryptParam->dwCryptState = dwState;
        memcpy(pContext->pCryptParam->rgbPreMasterSecret, bbPreMasterSecret.pBlob, LICENSE_PRE_MASTER_SECRET);
        memset(pContext->pCryptParam->rgbSessionKey, 0x00, LICENSE_SESSION_KEY);
        memset(pContext->pCryptParam->rgbMACSaltKey, 0x00, LICENSE_MAC_WRITE_KEY);
    }

    //Copy the whole message to the context
    pContext->cbLastMessage = *pcbOutput;
    if(pbOutput)
    {
        if( pContext->pbLastMessage )
        {
            free( pContext->pbLastMessage );
        }

        if( NULL == (pContext->pbLastMessage = (BYTE FAR *)malloc(pContext->cbLastMessage)) )
        {
            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        memset(pContext->pbLastMessage, 0x00, pContext->cbLastMessage);
        memcpy(pContext->pbLastMessage, pbOutput, pContext->cbLastMessage);
    }

    lsReturn = LICENSE_STATUS_CONTINUE;
    LS_LOG_RESULT(lsReturn);
CommonReturn:
    
    if(bbPreMasterSecret.pBlob)
    {
        free(bbPreMasterSecret.pBlob);
        bbPreMasterSecret.pBlob = NULL;
    }

    if( Request.EncryptedPreMasterSecret.pBlob )
    {
        free( Request.EncryptedPreMasterSecret.pBlob );
    }

    return  lsReturn;
    //LS_RETURN(lsReturn);
ErrorReturn:
    *pcbOutput = 0;
    goto CommonReturn;
}

LICENSE_STATUS
CALL_TYPE
ClientConstructErrorAlert(
                         PLicense_Client_Context    pContext,
                         DWORD                      dwErrorCode,
                         DWORD                      dwStateTransition,
                         BYTE FAR *                 pbErrorInfo,
                         DWORD                      cbErrorInfo,
                         BYTE FAR *                 pbOutput,
                         DWORD  FAR *               pcbOutput,
                         BOOL                       fExtendedError
                         )
{
    LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
    License_Error_Message  Error;    
    
    LS_BEGIN(TEXT("ClientConstructErrorAlert\n"));

    if(NULL == pContext)
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    } 
    
    memset(&Error, 0x00, sizeof(License_Error_Message));
    Error.dwErrorCode = dwErrorCode;    
    Error.dwStateTransition = dwStateTransition;
    Error.bbErrorInfo.wBlobType = BB_ERROR_BLOB;
    Error.bbErrorInfo.wBlobLen = (WORD)cbErrorInfo;
    if(Error.bbErrorInfo.wBlobLen>0)
    {
        if( NULL == (Error.bbErrorInfo.pBlob = (BYTE FAR *)malloc(Error.bbErrorInfo.wBlobLen)) )
        {
            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        memset(Error.bbErrorInfo.pBlob, 0x00, Error.bbErrorInfo.wBlobLen);
        memcpy(Error.bbErrorInfo.pBlob, pbErrorInfo, Error.bbErrorInfo.wBlobLen);
    }
    else
        Error.bbErrorInfo.pBlob = NULL;
    
    if( LICENSE_STATUS_OK != (lsReturn = PackLicenseErrorMessage(&Error, 
                                                                 fExtendedError,
                                                                 pbOutput, 
                                                                 pcbOutput)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;       
    }
    
    //Set the MACData in the CryptSystem MAC buffer.
    memset(pContext->rgbMACData, 0x00, LICENSE_MAC_DATA);

    //Set the state of the context to LICENSE_CLIENT_STATE_ABORT;
    switch(dwStateTransition)
    {
    case ST_TOTAL_ABORT:
        pContext->dwState = LICENSE_CLIENT_STATE_ABORT;
        lsReturn = LICENSE_STATUS_CLIENT_ABORT;
        pContext->cbLastMessage = 0;
        break;
    case ST_NO_TRANSITION:
        lsReturn = LICENSE_STATUS_CONTINUE;
        pContext->cbLastMessage = *pcbOutput;
        if(pbOutput)
        {
            if( pContext->pbLastMessage )
            {
                free( pContext->pbLastMessage );
            }

            if( NULL == (pContext->pbLastMessage = (BYTE FAR *)malloc(pContext->cbLastMessage)) )
            {
                lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
            memset(pContext->pbLastMessage, 0x00, pContext->cbLastMessage);
            memcpy(pContext->pbLastMessage, pbOutput, pContext->cbLastMessage);
        }
        break;
    case ST_RESET_PHASE_TO_START:
        lsReturn = LICENSE_STATUS_CONTINUE;
        if( (pContext->dwState == LICENSE_CLIENT_STATE_LICENSE_RESPONSE) ||
            (pContext->dwState == LICENSE_CLIENT_STATE_NEW_LICENSE_REQUEST) )
        {
            pContext->dwState = LICENSE_CLIENT_STATE_WAIT_SERVER_HELLO;
        }
        else if(pContext->dwState == LICENSE_CLIENT_STATE_PLATFORM_CHALLENGE_RESPONSE)
        {
            pContext->dwState = LICENSE_CLIENT_STATE_NEW_LICENSE_REQUEST;
        }
        break;
    case ST_RESEND_LAST_MESSAGE:
        lsReturn = LICENSE_STATUS_CONTINUE;
        break;
    }
    
    LS_LOG_RESULT(lsReturn);    
CommonReturn:
    
    if(Error.bbErrorInfo.pBlob)
    {
        free(Error.bbErrorInfo.pBlob);
        Error.bbErrorInfo.pBlob = NULL;
    }
    return lsReturn;
    //LS_RETURN(lsReturn);
ErrorReturn:
    *pcbOutput = 0;
    goto CommonReturn;
}


LICENSE_STATUS
CALL_TYPE
ClientGenerateChallengeResponse(
                                PLicense_Client_Context     pContext,
                                PBinary_Blob                pChallengeData,
                                PBinary_Blob                pResponseData
                                )
{
    LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
    PPlatformChallengeResponseData pbChallengeResponse = NULL;
    WORD cbChallengeResponse;


    LS_BEGIN(TEXT("ClientGenerateChallengeResponse"));

    //For the time being we will send back the same data. But we have to finalize on the challenge
    //response generation algorithm as soon as possible - Shubho
    if( (pContext == NULL) || (pChallengeData == NULL) || (pResponseData == NULL) )
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    pResponseData->wBlobType = BB_DATA_BLOB;
    
    //
    // Determine how much memory we need to allocate, PlatformChallenge* is a variable length
    // structure.
    //
    cbChallengeResponse = (WORD)OFFSET_OF(PlatformChallengeResponseData, pbChallenge) + pChallengeData->wBlobLen;

    ASSERT(cbChallengeResponse <= PLATFORM_CHALLENGE_LENGTH);
    if(cbChallengeResponse > PLATFORM_CHALLENGE_LENGTH)
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    pbChallengeResponse = (PPlatformChallengeResponseData)malloc(cbChallengeResponse);
    if( NULL == pbChallengeResponse )
    {
        // can't allocate memory
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //
    // Setup challenge response data, 
    //

    pbChallengeResponse->wVersion = CURRENT_PLATFORMCHALLENGE_VERSION;

 
#ifdef OS_WINCE

    pbChallengeResponse->wClientType = WINCE_PLATFORMCHALLENGE_TYPE;
    pbChallengeResponse->wLicenseDetailLevel = LICENSE_DETAIL_DETAIL;

#else

    //
    // We only need one Win32 type since we already have dwPlatformID to differentiate Win98/NT
    // Note, we set license detail level in #define just in case platform can't handle amount
    // of data set back by license server
    //
    pbChallengeResponse->wClientType = WIN32_PLATFORMCHALLENGE_TYPE;
    pbChallengeResponse->wLicenseDetailLevel = LICENSE_DETAIL_DETAIL;

#endif

    if( (pChallengeData->pBlob != NULL) && (pChallengeData->wBlobLen >0) )
    {
        pbChallengeResponse->cbChallenge = pChallengeData->wBlobLen;
        memcpy(
                (PBYTE)pbChallengeResponse + OFFSET_OF(PlatformChallengeResponseData, pbChallenge),
                pChallengeData->pBlob,
                pChallengeData->wBlobLen
            );
    }
    else
    {
        // server didn't send us any challenge data.
        pbChallengeResponse->cbChallenge = 0;
    }

    pResponseData->wBlobLen = cbChallengeResponse;
    pResponseData->pBlob = (BYTE FAR *)pbChallengeResponse;
    
    lsReturn = LICENSE_STATUS_OK;
    LS_LOG_RESULT(lsReturn);

CommonReturn:
    //LS_RETURN(lsReturn);
    return lsReturn;
ErrorReturn:
    goto CommonReturn;
}

static BOOL GeneratePseudoLicense(
                                  DWORD FAR * pcbNewLicense, 
                                  LPBYTE FAR *ppNewLicense)
{
    TCHAR g_LicenseString[] = TEXT("Licensed To Kill");

#define REPEAT_LICENSE_STRING   15
#define LICENSE_STRING_LEN      sizeof(TCHAR) * lstrlen(g_LicenseString) 

#define LICENSE_SIZE         ( LICENSE_STRING_LEN * REPEAT_LICENSE_STRING ) + 1 * sizeof(TCHAR)

    UINT i;
    BYTE FAR *pbLicenseData = NULL;
    DWORD cbLicenseData = LICENSE_SIZE;
        
    if( NULL == ( *ppNewLicense = malloc(cbLicenseData) ) )
    {   
        return FALSE;
    }

    memset(*ppNewLicense, 0x00, cbLicenseData);
    //
    // fill the memory with this license string
    //
    pbLicenseData = *ppNewLicense;
    for( i = 0; i < REPEAT_LICENSE_STRING; i++ )
    {
        memcpy( pbLicenseData, g_LicenseString, LICENSE_STRING_LEN  );
        pbLicenseData += LICENSE_STRING_LEN;
    }

    *pcbNewLicense = cbLicenseData;

    return TRUE;
}


VOID
FreeProprietaryCertificate(
    PHydra_Server_Cert * ppCertificate )
{    
    if( NULL == *ppCertificate )
    {
        return;
    }

    if( ( *ppCertificate )->PublicKeyData.pBlob )
    {
        free( ( *ppCertificate )->PublicKeyData.pBlob );
    }

    if( ( *ppCertificate )->SignatureBlob.pBlob )
    {
        free( ( *ppCertificate )->SignatureBlob.pBlob );
    }

    free( *ppCertificate );

    *ppCertificate = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\hclient\liclient\liclient.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    core.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Sep. 5th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES = \
    $(C_DEFINES) \
    $(CLIENT_EXE_CDEFS)

#
# List of sources
#

SOURCES_PLATFORM =

CLIENT_SOURCES_RC = \

CLIENT_SOURCES_COMMON = \
    cliprot.c \
    hccontxt.c

CLIENT_SOURCES_LAST  = \
    hcpack.c

SOURCES = \
    $(CLIENT_SOURCES_RC) \
    $(SOURCES_PLATFORM) \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_LAST)

#
# Precompiled specs
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\hclient\lstore\lstore.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lstore.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Shubho Bhattacharya - Feb. 20th 1998

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES = \
    $(C_DEFINES) \
    $(CLIENT_EXE_CDEFS)

#
# List of sources
#

SOURCES_PLATFORM =

CLIENT_SOURCES_RC = \

CLIENT_SOURCES_COMMON = \
    store.c

CLIENT_SOURCES_LAST  = \

SOURCES = \
    $(CLIENT_SOURCES_RC) \
    $(SOURCES_PLATFORM) \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_LAST)

#
# Precompiled specs
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\base64.h ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    base64.h

Abstract:


Author:

    Fred Chong (FredCh) 7/1/1998

Environment:

Notes:

--*/

#ifndef __BASE64_H__
#define __BASE64_H__

#ifdef __cplusplus
extern "C" {
#endif


#ifdef UNICODE
#define LSBase64Decode  LSBase64DecodeW
#else
#define LSBase64Decode  LSBase64DecodeA
#endif // !UNICODE

DWORD			// ERROR_*
LSBase64DecodeA(
    IN CHAR const *pchIn,
    IN DWORD cchIn,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut);

DWORD			// ERROR_*
LSBase64DecodeW(
    IN WCHAR const *pchIn,
    IN DWORD cchIn,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut);

    
#ifdef UNICODE
#define LSBase64Encode  LSBase64EncodeW
#else
#define LSBase64Encode  LSBase64EncodeA
#endif // !UNICODE

DWORD			// ERROR_*
LSBase64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT CHAR *pchOut,
    OUT DWORD *pcchOut);

DWORD			// ERROR_*
LSBase64EncodeW(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT WCHAR *pchOut,
    OUT DWORD *pcchOut);

    
#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // BASE64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\cliprot.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cliprot.h
//
//  Contents:   Contains different client states and client protocol
//              related definitions        
//
//  Classes:
//
//  Functions:
//
//  History:    12-23-97   v-sbhatt   Created
//
//----------------------------------------------------------------------------

#ifndef _CLIPROT_H_
#define _CLIPROT_H



#ifdef __cplusplus
extern "C" {
#endif

//Different states for client state machine
#define LICENSE_CLIENT_STATE_WAIT_SERVER_HELLO              0x00    //Initial state of the machine
#define LICENSE_CLIENT_STATE_KEY_EXCHANGE_INFO              0x01    //Client key exchange info
#define LICENSE_CLIENT_STATE_LICENSE_RESPONSE               0x02    //License info
#define LICENSE_CLIENT_STATE_NEW_LICENSE_REQUEST            0x03    //Client asked for a new license
#define LICENSE_CLIENT_STATE_PLATFORM_INFO                  0x04    //Platform info
#define LICENSE_CLIENT_STATE_PLATFORM_CHALLENGE_RESPONSE    0x05    //Platform challenge response
#define LICENSE_CLIENT_STATE_ERROR                          0x06    //Error state
#define LICENSE_CLIENT_STATE_ABORT                          0x07    //Total abort;
#define LICENSE_CLIENT_STATE_DONE                           0x08

LICENSE_STATUS
CALL_TYPE
LicenseClientHandleServerMessage(
                     PLicense_Client_Context    pContext,
                     UINT32                     *puiExtendedErrorInfo,
                     BYTE FAR *                 pbInput,
                     DWORD                      cbInput,
                     BYTE FAR *                 pbOutput,
                     DWORD FAR *                pcbOutput
                     );
LICENSE_STATUS
CALL_TYPE
LicenseClientHandleServerError(
                               PLicense_Client_Context  pContext,
                               PLicense_Error_Message   pCanonical,
                               UINT32                   *puiExtendedErrorInfo,
                               BYTE FAR *               pbMessage,
                               DWORD FAR *              pcbMessage
                               );

LICENSE_STATUS
CALL_TYPE
LicenseClientHandleServerRequest(
                               PLicense_Client_Context          pContext,
                               PHydra_Server_License_Request    pCanonical,
                               BOOL                             fNewLicense,
                               BYTE FAR *                       pbMessage,
                               DWORD FAR *                      pcbMessage,
                               BOOL                             fSupportExtendedError
                               );

LICENSE_STATUS
CALL_TYPE
LicenseClientHandleServerPlatformChallenge(
                               PLicense_Client_Context          pContext,
                               PHydra_Server_Platform_Challenge pCanonical,
                               BYTE FAR *                       pbMessage,
                               DWORD FAR *                      pcbMessage,
                               BOOL                             fSupportExtendedError
                               );

LICENSE_STATUS
CALL_TYPE
LicenseClientHandleNewLicense(
                               PLicense_Client_Context      pContext,
                               PHydra_Server_New_License    pCanonical,
                               BOOL                         fNew,
                               BYTE FAR *                   pbMessage,
                               DWORD FAR *                      pcbMessage
                               );

LICENSE_STATUS 
CALL_TYPE
ClientConstructLicenseInfo(
                           PLicense_Client_Context  pContext,
                           BYTE FAR *               pbInput,
                           DWORD                    cbInput,
                           BYTE FAR *               pbOutput,
                           DWORD FAR *              pcbOutput,
                           BOOL                     fExtendedError
                           );

LICENSE_STATUS 
CALL_TYPE
ClientConstructNewLicenseRequest(
                           PLicense_Client_Context  pContext,
                           BYTE FAR *               pbOutput,
                           DWORD FAR *              pcbOutput,
                           BOOL                     fExtendedError
                           );

LICENSE_STATUS
CALL_TYPE
ClientConstructErrorAlert(
                         PLicense_Client_Context    pContext,
                         DWORD                      dwErrorCode,
                         DWORD                      dwStateTransition,
                         BYTE FAR *                 pbErrorInfo,
                         DWORD                      cbErrorInfo,
                         BYTE FAR *                 pbOutput,
                         DWORD FAR *                pcbOutput,
                         BOOL                       fExtendedError
                         );

LICENSE_STATUS
CALL_TYPE
ClientGenerateChallengeResponse(
                                PLicense_Client_Context     pContext,
                                PBinary_Blob                pChallengeData,
                                PBinary_Blob                pResponseData
                                );



#ifdef __cplusplus
}
#endif
#endif  //_CLIPROT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\certutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       certutil.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    03-18-97   HueiWang     Created
//
//----------------------------------------------------------------------------
#ifndef __LICENSE_VERIFY_H__
#define __LICENSE_VERIFY_H__

#include <windows.h>
#include <wincrypt.h>

typedef BOOL (*EnumerateCertNameInfoCallBack)(PCERT_RDN_ATTR pCertRdnAttr, HANDLE dwUserData);

#ifndef AllocateMemory
    #define AllocMemory(size) LocalAlloc(LPTR, size)
    #define FreeMemory(ptr) if(ptr) LocalFree(ptr)
#endif

//
//  SP3 build environment problem.
//
#define LSCERT_ALT_NAME_OTHER_NAME         1
#define LSCERT_ALT_NAME_RFC822_NAME        2
#define LSCERT_ALT_NAME_DNS_NAME           3
#define LSCERT_ALT_NAME_X400_ADDRESS       4
#define LSCERT_ALT_NAME_DIRECTORY_NAME     5
#define LSCERT_ALT_NAME_EDI_PARTY_NAME     6
#define LSCERT_ALT_NAME_URL                7
#define LSCERT_ALT_NAME_IP_ADDRESS         8
#define LSCERT_ALT_NAME_REGISTERED_ID      9

typedef struct _LSCERT_ALT_NAME_ENTRY {
    DWORD    dwAltNameChoice;
    union {
      CRYPT_ATTRIBUTE_TYPE_VALUE    OtherName;
      LPWSTR                        pwszRfc822Name;
      LPWSTR                        pwszDNSName;
      CRYPT_ATTRIBUTE_TYPE_VALUE    x400Address;
      CERT_NAME_BLOB                DirectoryName;
      LPWSTR                        pwszEdiPartyName;
      LPWSTR                        pszURL;
      CRYPT_DATA_BLOB               IPAddress;
      LPSTR                         pszRegisteredID;
    }; 
} LSCERT_ALT_NAME_ENTRY,   *PLSCERT_ALT_NAME_ENTRY;

typedef struct _LSCERT_ALT_NAME_INFO {
    DWORD                   cAltEntry;
    PLSCERT_ALT_NAME_ENTRY    rgAltEntry;
} LSCERT_ALT_NAME_INFO, *PLSCERT_ALT_NAME_INFO;

typedef struct _LSCERT_AUTHORITY_KEY_ID2_INFO {    
    CRYPT_DATA_BLOB     KeyId;
    LSCERT_ALT_NAME_INFO  AuthorityCertIssuer;
    CRYPT_INTEGER_BLOB  AuthorityCertSerialNumber;
} LSCERT_AUTHORITY_KEY_ID2_INFO, *PLSCERT_AUTHORITY_KEY_ID2_INFO; 

#define szOID_X509_AUTHORITY_KEY_ID2        "2.5.29.35"
#define szOID_X509_AUTHORITY_ACCESS_INFO    "1.3.6.1.5.5.7.1.1"
#define szOID_X509_ACCESS_PKIX_OCSP         "1.3.6.1.5.5.7.48.1" 

typedef struct _LSCERT_ACCESS_DESCRIPTION {
    LPSTR               pszAccessMethod;        // pszObjId
    LSCERT_ALT_NAME_ENTRY AccessLocation;
} LSCERT_ACCESS_DESCRIPTION, *PLSCERT_ACCESS_DESCRIPTION;
 
typedef struct _LSCERT_AUTHORITY_INFO_ACCESS {
    DWORD                       cAccDescr;
    PLSCERT_ACCESS_DESCRIPTION    rgAccDescr;
} LSCERT_AUTHORITY_INFO_ACCESS, *PLSCERT_AUTHORITY_INFO_ACCESS;


#if UNICODE
#define CAST_PBYTE (USHORT *)
#else
#define CAST_PBYTE
#endif

#define CERT_X509_MULTI_BYTE_INTEGER             ((LPCSTR) 28)

#ifdef __cplusplus
extern "C" {
#endif


void
LSShutdownCertutilLib();

BOOL
LSInitCertutilLib( 
    HCRYPTPROV hProv 
);

void
LSFreeLicensedProduct(
    PLICENSEDPRODUCT pLicensedProduct
);

LICENSE_STATUS
LSVerifyDecodeClientLicense(
    IN PBYTE                pbLicense,
    IN DWORD                cbLicense,
    IN PBYTE                pbSecretKey,
    IN DWORD                cbSecretKey,
    IN OUT PDWORD           pdwNumLicensedInfo,
    IN OUT PLICENSEDPRODUCT pLicensedInfo
);

LICENSE_STATUS
LSVerifyCertificateChain(
    HCRYPTPROV hCryptProv, 
    HCERTSTORE hCertStore
);

DWORD 
LSCryptDecodeObject(  
    IN DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE * pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    OUT void ** pvStructInfo,   
    IN OUT DWORD * pcbStructInfo
);

DWORD 
LSLicensedProductInfoToExtension(
    DWORD dwQuantity,
    DWORD dwPlatformId,
    DWORD dwLangId,
    PBYTE pbOriginalProductId,
    DWORD cbOriginalProductId,
    PBYTE pbAdjustedProductId,
    DWORD cbAdjustedProductId,
    LICENSED_VERSION_INFO* pLicensedVersionInfo,
    DWORD dwNumLicensedVersionInfo,
    PBYTE *pbData,
    PDWORD cbData
);

DWORD 
LSExtensionToMsLicensedProductInfo(
    PBYTE      pbData,
    DWORD      cbData,
    PDWORD     pdwQuantity,
    PDWORD     pdwPlatformId,
    PDWORD     pdwLanguagId,
    PBYTE*     ppbOriginalProductId,
    PDWORD     pcbOriginalProductId,
    PBYTE*     ppbAdjustedProductId,
    PDWORD     pcbAdjustedProductId,
    LICENSED_VERSION_INFO** ppLicenseInfo,
    PDWORD     pdwNumberLicensedVersionInfo
);

DWORD
LSEnumerateCertNameInfo(
    LPBYTE pbData,
    DWORD cbData,
    EnumerateCertNameInfoCallBack func,
    HANDLE dwUserData
);

LICENSE_STATUS
LSEncryptClientHWID(HWID* pHwid, 
                    PBYTE pbData, 
                    PDWORD cbData, 
                    PBYTE pbSecretKey, 
                    DWORD cbSecretKey);

LICENSE_STATUS
LSDecodeClientHWID( PBYTE pbData, 
                    DWORD cbData, 
                    PBYTE pbSecretKey, 
                    DWORD cbSecretKey,
                    HWID* pHwid);

LICENSE_STATUS
LicenseGetSecretKey(
    PDWORD  pcbSecretKey,
    BYTE FAR *   pSecretKey 
);

LICENSE_STATUS
LSExtensionToMsLicenseServerInfo(
    PBYTE   pbData,
    DWORD   cbData,
    LPTSTR* szIssuer,
    LPTSTR* szIssuerId,
    LPTSTR* szScope
);

LICENSE_STATUS
LSMsLicenseServerInfoToExtension(
    LPTSTR szIssuer,
    LPTSTR szIssuerId,
    LPTSTR szScope,
    PBYTE* pbData,
    PDWORD cbData
);

LICENSE_STATUS
DecodeLicense20(
    IN PCERT_INFO     pCertInfo,
    IN PBYTE          pbSecretKey,
    IN DWORD          cbSecretKey,
    IN OUT PLICENSEDPRODUCT pLicensedInfo,
    IN OUT ULARGE_INTEGER*  ulSerialNumber
);

#ifdef __cplusplus
};
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\hclient\lstore\store.c ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    store.c

Abstract:



Revision History:



--*/

#include <windows.h>
#ifndef OS_WINCE
#include <stdio.h>
#endif // OS_WINCE
#include <stdlib.h>

#ifndef OS_WINCE
#include <reglic.h>
#endif

#ifdef OS_WINCE
#include "ceconfig.h"
#endif

#include "store.h"

#define		MAX_LEN			256
#define		BASE_STORE		TEXT("Software\\Microsoft\\MSLicensing\\")
#define		STORE			TEXT("Store")
#define		COMMON_STORE	TEXT("Software\\Microsoft\\MSLicensing\\Store")

#define     MAX_SIZE_LICENSESTORE   2048
#define     MAX_NUM_LICENSESTORE    20
#define     MAX_LICENSESTORE_NAME   25

#ifdef OS_WINCE

typedef HANDLE STORE_HANDLE;

#ifdef OS_WINCE
//If gbFlushHKLM true, RegFlushKey is called in CCC::CC_OnDisconnected
//Since the penalty for RegFlushKey is high on CE, we dont do it immediately
BOOL gbFlushHKLM = FALSE;
#endif

//
// WriteLiceneToStore() and ReadLicenseFromStore is only used by WINCE
//
DWORD
CALL_TYPE
WriteLicenseToStore( 
    IN STORE_HANDLE hStore,
    IN BYTE	FAR * pbLicense,
    IN DWORD cbLicense
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwIndex;
    TCHAR szValueName[MAX_LICENSESTORE_NAME];  
    DWORD dwCount;

    dwIndex = 0;

    while( cbLicense > 0 )
    {
        if( dwIndex > 0 )
        {
            wsprintf(
                    szValueName, 
                    TEXT("ClientLicense%03d"), 
                    dwIndex
                );
        }
        else
        {
            lstrcpy(
                    szValueName,
                    TEXT("ClientLicense")
                ); 
        }

        dwIndex++;

        // must have a reason for this
        RegDeleteValue(
                    (HKEY)hStore,
                    szValueName
                );

        dwCount = (cbLicense > MAX_SIZE_LICENSESTORE) ? MAX_SIZE_LICENSESTORE : cbLicense;

        dwStatus = RegSetValueEx(
                                (HKEY)hStore,
                                szValueName,
                                0,
                                REG_BINARY,
                                pbLicense,
                                dwCount
                            );

        if( ERROR_SUCCESS != dwStatus )
        {
            break;
        }

        cbLicense -= dwCount;
        pbLicense += dwCount;
    }

    if( ERROR_SUCCESS == dwStatus )
    {
        //
        // Delete next store
   
        wsprintf(
                szValueName, 
                TEXT("ClientLicense%03d"), 
                dwIndex
            );

        RegDeleteValue(
                (HKEY)hStore,
                szValueName
            );
#ifdef OS_WINCE
        gbFlushHKLM = TRUE;
#endif
    }
#ifdef OS_WINCE
	else
    {
        DWORD cbValName;

        cbValName = MAX_LICENSESTORE_NAME;
        while ( (ERROR_SUCCESS == RegEnumValue(
                                    (HKEY)hStore,
                                    0, 
                                    szValueName, 
                                    &cbValName, 
                                    NULL, 
                                    NULL,
                                    NULL, 
                                    NULL
                                    ) ) && 
                (cbValName < MAX_LICENSESTORE_NAME)
                )
        {
            RegDeleteValue(
                 (HKEY) hStore,
                 szValueName
                );
            cbValName = MAX_LICENSESTORE_NAME;
        }
    }
#endif

    return dwStatus;
}


DWORD
CALL_TYPE
ReadLicenseFromStore( 
    IN STORE_HANDLE hStore,
    IN BYTE FAR * pbLicense,
    IN DWORD FAR * pcbLicense
    )
/*++

--*/
{
    DWORD dwStatus;
    DWORD dwIndex;
    TCHAR szValueName[MAX_LICENSESTORE_NAME];
    BYTE FAR * pbReadStart;
    DWORD cbReadSize;
    LONG dwSize;

    dwIndex = 0;
    dwSize = (LONG)*pcbLicense;
    *pcbLicense = 0;
    pbReadStart = pbLicense;

    
    for(;;)
    {
        if( pbLicense != NULL )
        {
            if( dwSize < 0 )
            {
                // don't continue on reading,
                // size of buffer is too small, should
                // query size first.
                dwStatus = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
        }
        else if( dwIndex >= MAX_NUM_LICENSESTORE )
        {
            // License is way to big, treat it as error
            dwStatus = LSSTAT_ERROR;
            break;
        }

        if( dwIndex > 0 )
        {
            wsprintf(
                    szValueName, 
                    TEXT("ClientLicense%03d"), 
                    dwIndex
                );
        }
        else
        {
            lstrcpy(
                    szValueName,
                    TEXT("ClientLicense")
                ); 
        }

        dwIndex++;
        cbReadSize = ( pbLicense ) ? dwSize : 0;

	    dwStatus = RegQueryValueEx(
                                (HKEY)hStore,
							    szValueName,
							    NULL,
                                NULL,
							    ( pbLicense ) ? pbReadStart : NULL,
                                &cbReadSize
                            );

        if( ERROR_SUCCESS != dwStatus )
	    {
            if( dwIndex != 0 )
            {
                // 
                // Ignore error if can't read from next store
                //
                dwStatus = ERROR_SUCCESS;
            }
            
            break;
        }

        (*pcbLicense) += cbReadSize;
        if( pbLicense )
        {
            pbReadStart += cbReadSize;
            dwSize -= cbReadSize;
        }
    }
   
    return dwStatus;
}

#endif // OS_WINCE


LS_STATUS
CALL_TYPE
LSOpenLicenseStore(
				 OUT HANDLE			*phStore,	 //The handle of the store
				 IN  LPCTSTR		szStoreName, //Optional store Name
				 IN  BOOL 			fReadOnly    //whether to open read-only
				 )
{
	LS_STATUS	lsResult = LSSTAT_ERROR;
	LPTSTR		szKey = NULL;
	HKEY		hKey;
	DWORD		dwDisposition = 0, dwRetCode;

	if (phStore==NULL)
		return LSSTAT_INVALID_HANDLE;

	//If any store name is provided, try opening the store
	if(szStoreName)
	{
		if( NULL == (szKey = (LPTSTR)malloc( 2*( lstrlen(BASE_STORE) + lstrlen(szStoreName) + 1 ) ) ) )
		{
			lsResult = LSSTAT_OUT_OF_MEMORY;
			goto ErrorReturn;
		}
		lstrcpy(szKey, BASE_STORE);
		lstrcat(szKey, szStoreName);
	}
	//Open standard store
	else
	{
        szKey = COMMON_STORE;
	}
    
    //
    // try and open the key.  If we cannot open the key, then create the key
    //

    dwRetCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              szKey,
                              0,  
                              fReadOnly ? KEY_READ : KEY_READ | KEY_WRITE,
                              &hKey );

    if( ERROR_SUCCESS != dwRetCode )
    {
        HKEY hKeyBase;

        dwRetCode = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
#ifndef OS_WINCE
                                    BASE_STORE,
#else
                                    szKey,
#endif
                                    0,
                                    TEXT("License Store"),
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_READ | KEY_WRITE,
                                    NULL,
                                    &hKeyBase,
                                    &dwDisposition );

        if (ERROR_SUCCESS == dwRetCode)
        {
#ifndef OS_WINCE

            // Set the proper ACL on the key; ignore errors

            SetupMSLicensingKey();

#endif

            dwRetCode = RegCreateKeyEx( hKeyBase,
                                        (szStoreName != NULL) ? szStoreName : STORE,
                                        0,
                                        TEXT("License Store"),
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hKey,
                                        &dwDisposition );

            RegCloseKey(hKeyBase);
        }
    }

    if( ERROR_SUCCESS == dwRetCode )
    {

        *phStore = ( HANDLE )hKey;

        lsResult = LSSTAT_SUCCESS;
    }
    else
    {
		*phStore = NULL;
    }
    
CommonReturn:	

    if (szKey)
    {
        // We only allocate memory for szKey if szStoreName wasn't NULL
        if (szStoreName)
            free(szKey);
    }

    return lsResult;

ErrorReturn:

    *phStore = NULL;
    goto CommonReturn;		
}	


//Closes an open store
LS_STATUS
CALL_TYPE
LSCloseLicenseStore(
				  IN HANDLE		hStore	//Handle of the store to be closed!
				  )

{	
	LS_STATUS	lsResult = LSSTAT_ERROR;
	HKEY	hKey = NULL;

	if(hStore==NULL)
		return lsResult;

	 hKey = (HKEY)hStore;

	if(hKey)
	{
		RegCloseKey(hKey);
		hKey = NULL;
		lsResult = LSSTAT_SUCCESS;
	}

	return lsResult;
}

/*
	Here we do not check any value. We do not even check if a license with same attributes present
	or not. This is to make the store functionality simpler. We assume, the higher level protocol 
	will take care of that
*/

//Add or updates/replaces license against a given LSINDEX in an open store 
//pointed by hStore
LS_STATUS
CALL_TYPE
LSAddLicenseToStore(
					IN HANDLE		hStore,	//Handle of a open store
					IN DWORD		dwFlags,//Flags either add or replace
					IN PLSINDEX		plsiName,	//Index against which License is added 
					IN BYTE	 FAR *	pbLicenseInfo,	//License info to be added
					IN DWORD		cbLicenseInfo	// size of the License info blob
					)

{
	
	LS_STATUS	lsResult = LSSTAT_ERROR;
	HANDLE		hLicense = NULL;	
    HKEY	hTempKey = NULL;
    DWORD dwRetCode;

	if( (hStore == NULL) ||
		(plsiName == NULL) ||
		(plsiName->pbScope == NULL) ||
		(plsiName->pbCompany == NULL) ||
		(plsiName->pbProductID == NULL) ||
		(pbLicenseInfo == NULL) ||
		(cbLicenseInfo == 0) )
		return LSSTAT_INVALID_HANDLE;

	lsResult = LSOpenLicenseHandle(hStore, FALSE, plsiName, &hLicense);
	switch(lsResult)
	{
		case LSSTAT_SUCCESS:
			if(dwFlags == LS_REPLACE_LICENSE_OK)
			{

#ifndef OS_WINCE
				RegDeleteValue((HKEY)hLicense, TEXT("ClientLicense"));
				//Set the License Info value
				if( ERROR_SUCCESS != RegSetValueEx(
							(HKEY)hLicense,
							TEXT("ClientLicense"),
							0,
							REG_BINARY,
							pbLicenseInfo,
							cbLicenseInfo
							) )
				{
					lsResult = LSSTAT_ERROR;
					goto ErrorReturn;
				}
#else

                if( ERROR_SUCCESS != WriteLicenseToStore( 
                                                (STORE_HANDLE)hLicense, 
                                                pbLicenseInfo, 
                                                cbLicenseInfo ) )
                {
                    lsResult = LSSTAT_ERROR;
                    goto ErrorReturn;
                }

#endif

			}
			else
			{
				lsResult = LSSTAT_LICENSE_EXISTS;
				goto ErrorReturn;
			}
				
			break;
		case LSSTAT_LICENSE_NOT_FOUND:
			{
				DWORD	dwIndex, dwDisposition = 0;
				TCHAR	szAddKey[MAX_LEN];

				for(dwIndex = 0; ; dwIndex ++)
				{
                    // Open iterative license names until we fail to 
                    // determine a free spot

					wsprintf(szAddKey, TEXT("LICENSE%03d"), dwIndex);
#ifdef OS_WINCE
					if( ERROR_SUCCESS != RegOpenKeyEx((HKEY)hStore, szAddKey, 0, 0, &hTempKey) )
#else // !OS_WINCE
					if( ERROR_SUCCESS != RegOpenKeyEx((HKEY)hStore, szAddKey, 0, KEY_READ | KEY_WRITE, &hTempKey) )
#endif // OS_WINCE
						break;
					else if(hTempKey)
					{
						RegCloseKey(hTempKey);
						hTempKey = NULL;
					}
				}
    
                //
                // try and open the key.  If we cannot open the key, then create the key
                //

                dwRetCode = RegOpenKeyEx( ( HKEY )hStore,
                                           szAddKey,
                                           0,
                                           KEY_READ | KEY_WRITE,
                                           &hTempKey );

                if( ERROR_SUCCESS != dwRetCode )
                {

                    dwRetCode = RegCreateKeyEx( ( HKEY )hStore, 
                                                szAddKey, 
                                                0,
                                                NULL,
                                                REG_OPTION_NON_VOLATILE,
                                                KEY_READ | KEY_WRITE,
                                                NULL,
                                                &hTempKey,
                                                &dwDisposition );
				
                }
                else
                {
                    //
                    // Indicate that we have opened an existing key successfully
                    //

                    dwDisposition = REG_OPENED_EXISTING_KEY;
                }

                if( ERROR_SUCCESS == dwRetCode )
				{
					if(dwDisposition == REG_CREATED_NEW_KEY)
					{

                        //Set the Scope Value in binary format
						if( ERROR_SUCCESS != RegSetValueEx(
									hTempKey,
									TEXT("LicenseScope"),
									0,
									REG_BINARY,
									plsiName->pbScope,
									plsiName->cbScope
									) )
						{
							lsResult = LSSTAT_ERROR;
							goto ErrorReturn;
						}

						//Set Company Name Value
						if( ERROR_SUCCESS != RegSetValueEx(
									hTempKey,
									TEXT("CompanyName"),
									0,
									REG_BINARY,
									plsiName->pbCompany,
									plsiName->cbCompany
									) )
						{
							lsResult = LSSTAT_ERROR;
							goto ErrorReturn;
						}
						
						//Set  Product Info
						if( ERROR_SUCCESS != RegSetValueEx(
									hTempKey,
									TEXT("ProductID"),
									0,
									REG_BINARY,
									plsiName->pbProductID,
									plsiName->cbProductID
									) )
						{
							lsResult = LSSTAT_ERROR;
							goto ErrorReturn;
						}


#ifndef OS_WINCE
						//Set the License Info value
						if( ERROR_SUCCESS != RegSetValueEx(
									hTempKey,
									TEXT("ClientLicense"),
									0,
									REG_BINARY,
									pbLicenseInfo,
									cbLicenseInfo
									) )
						{
							lsResult = LSSTAT_ERROR;
							goto ErrorReturn;
						}

#else

                        if( ERROR_SUCCESS != WriteLicenseToStore( 
                                                        (STORE_HANDLE)hTempKey, 
                                                        pbLicenseInfo, 
                                                        cbLicenseInfo ) )
                        {
                            lsResult = LSSTAT_ERROR;
                            goto ErrorReturn;
                        }

#endif

					}
					else // so ERROR_SUCCESS != RegCreateKeyEx
					{
						lsResult = LSSTAT_ERROR;
						goto ErrorReturn;
					}
							
				}
				else
				{
					lsResult = LSSTAT_ERROR;
					goto ErrorReturn;
				}
				lsResult = LSSTAT_SUCCESS;
			}
			break;
		default:
			goto ErrorReturn;
	}

	
CommonReturn:

	if(hLicense)
	{
		LSCloseLicenseHandle(hLicense, 0);
		hLicense = NULL;
	}
	if(hTempKey)
	{
		RegCloseKey(hTempKey);
		hTempKey = NULL;
	}
	return lsResult;

ErrorReturn:

	goto CommonReturn;
}

LS_STATUS
CALL_TYPE
LSDeleteLicenseFromStore(
						 IN HANDLE		hStore,	//Handle of a open store
						 IN PLSINDEX	plsiName	//Index of the license to be deleted
						 )
{
	LS_STATUS	lsResult = LSSTAT_ERROR;
	TCHAR		szKeyName[MAX_LEN];
	DWORD		dwKeyNameLen = MAX_LEN;
	DWORD		dwSubKeys = 0;
	DWORD		dwIndex = 0;
	DWORD		cbValueData = 0;
	BYTE FAR *	pbValueData = NULL;
	LONG		err = ERROR_SUCCESS;
	HKEY		hTempKey = NULL;
	FILETIME	ft;
    HKEY        hkeyStore = NULL;

	if( (hStore == NULL) ||
		(plsiName == NULL) ||
		(plsiName->pbScope == NULL) ||
		(plsiName->pbCompany == NULL) ||
		(plsiName->pbProductID == NULL) )
		return LSSTAT_INVALID_HANDLE;

    hkeyStore = (HKEY)hStore;

	if( ERROR_SUCCESS != RegQueryInfoKey(hkeyStore,
										NULL,
										NULL,
										NULL,
										&dwSubKeys, 
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL) )
										goto ErrorReturn;
		
	for(dwIndex = 0; dwIndex <dwSubKeys; dwIndex ++)
	{
		if( ERROR_SUCCESS != RegEnumKeyEx(
										hkeyStore,
										dwIndex,
										szKeyName,
										&dwKeyNameLen,
										NULL,
										NULL,
										NULL,
										&ft
										) )
		{
			continue;
		}
		
		err = RegOpenKeyEx(hkeyStore, szKeyName, 0, KEY_READ | KEY_WRITE | DELETE, &hTempKey);

		if(err != ERROR_SUCCESS)
			continue;
		err = RegQueryValueEx(hTempKey, 
							  TEXT("LicenseScope"),
							  NULL,
							  NULL,
							  NULL,
							  &cbValueData);

		if( (err!=ERROR_SUCCESS)||
			(cbValueData != plsiName->cbScope) )
			continue;
		
		if( NULL == (pbValueData = (BYTE FAR *)malloc(cbValueData)) )
		{
			lsResult = LSSTAT_OUT_OF_MEMORY;
			goto ErrorReturn;
		}
		
		memset(pbValueData, 0x00, cbValueData);

		err = RegQueryValueEx(hTempKey, 
							  TEXT("LicenseScope"),
							  NULL,
							  NULL,
							  pbValueData,
							  &cbValueData);
		
		if( (err!=ERROR_SUCCESS) ||
			(memcmp(pbValueData, plsiName->pbScope, cbValueData)) )
		{
			if(pbValueData)
			{
				free(pbValueData);
				pbValueData = NULL;
			}
			continue;
		}
		
		if(pbValueData)
		{
			free(pbValueData);
			pbValueData = NULL;
		}
		
		err = RegQueryValueEx(hTempKey, 
							  TEXT("CompanyName"),
							  NULL,
							  NULL,
							  NULL,
							  &cbValueData);
		
		if( (err!=ERROR_SUCCESS) ||
			(cbValueData != plsiName->cbCompany) )
			continue;
		
		if( NULL == (pbValueData = (BYTE FAR *)malloc(cbValueData)) )
		{
			lsResult = LSSTAT_OUT_OF_MEMORY;
			goto ErrorReturn;
		}
		
		memset(pbValueData, 0x00, cbValueData);

		err = RegQueryValueEx(hTempKey, 
							  TEXT("CompanyName"),
							  NULL,
							  NULL,
							  pbValueData,
							  &cbValueData);
		
		if( (err!=ERROR_SUCCESS) ||
			(memcmp(pbValueData, plsiName->pbCompany, cbValueData)) )
		{
			if(pbValueData)
			{
				free(pbValueData);
				pbValueData = NULL;
			}
			continue;
		}

		if(pbValueData)
		{
			free(pbValueData);
			pbValueData = NULL;
		}

		err = RegQueryValueEx(hTempKey, 
							  TEXT("ProductID"),
							  NULL,
							  NULL,
							  NULL,
							  &cbValueData);
		
		if( (err!=ERROR_SUCCESS) ||
			(cbValueData != plsiName->cbProductID) )
			continue;
		
		
		if( NULL == (pbValueData = (BYTE FAR *)malloc(cbValueData)) )
		{
			lsResult = LSSTAT_OUT_OF_MEMORY;
			goto ErrorReturn;
		}
		
		memset(pbValueData, 0x00, cbValueData);
		
		err = RegQueryValueEx(hTempKey, 
							  TEXT("ProductID"),
							  NULL,
							  NULL,
							  pbValueData,
							  &cbValueData);
		
		if( (err!=ERROR_SUCCESS) ||
			(memcmp(pbValueData, plsiName->pbProductID, cbValueData)) )
		{
			if(pbValueData)
			{
				free(pbValueData);
				pbValueData = NULL;
			}
			continue;
		}
		
		if(pbValueData)
		{
			free(pbValueData);
			pbValueData = NULL;
		}
		
		if(hTempKey)
		{
			RegCloseKey(hTempKey);
			hTempKey = NULL;
		}

		if( ERROR_SUCCESS == RegDeleteKey(hkeyStore, szKeyName) )
		{
			lsResult = LSSTAT_SUCCESS;
			break;
		}
		lsResult = LSSTAT_LICENSE_NOT_FOUND;
	}

CommonReturn:
	return lsResult;
ErrorReturn:
	goto CommonReturn;
}


//Finds a license in an open store against a particular store Index
LS_STATUS
CALL_TYPE
LSFindLicenseInStore(
					 IN HANDLE		hStore,	//Handle of a open store
					 IN		PLSINDEX	plsiName,	//LSIndex against which store is searched
					 IN OUT	DWORD FAR   *pdwLicenseInfoLen,	//Size of the license found
					 OUT	BYTE FAR	*pbLicenseInfo	//License Data
					 )
{
	LS_STATUS	lsResult = LSSTAT_ERROR;
	HANDLE		hLicense = NULL;
    HKEY hkeyLicense = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    
	if( LSSTAT_SUCCESS != (lsResult = LSOpenLicenseHandle( hStore, TRUE, plsiName, &hLicense)) )
		goto ErrorReturn;

    hkeyLicense = (HKEY)hLicense;

#ifndef OS_WINCE

	if( ERROR_SUCCESS == (dwStatus = RegQueryValueEx((HKEY)hkeyLicense,
										 TEXT("ClientLicense"),
										 NULL,
										 NULL,
										 pbLicenseInfo,
										 pdwLicenseInfoLen)) )
	{
            lsResult = LSSTAT_SUCCESS;
            goto CommonReturn;
	}


#else

    if( ERROR_SUCCESS == (dwStatus = ReadLicenseFromStore(
                                        (STORE_HANDLE)hkeyLicense,
                                        pbLicenseInfo,
										pdwLicenseInfoLen)) )
    {
        lsResult = LSSTAT_SUCCESS;
        goto CommonReturn;
    }

#endif

    if( dwStatus != ERROR_SUCCESS)
    {
        lsResult = LSSTAT_ERROR;
    }

    if(lsResult != LSSTAT_SUCCESS)
    {
			goto ErrorReturn;
	}
	else if(*pdwLicenseInfoLen == 0)
	{
		lsResult = LSSTAT_LICENSE_NOT_FOUND;
		goto ErrorReturn;
	}
	
CommonReturn:
	if(hLicense)
	{
		LSCloseLicenseHandle(hLicense, 0);
		hLicense = NULL;
	}
	return lsResult;
ErrorReturn:
	goto CommonReturn;
}


LS_STATUS
CALL_TYPE
LSEnumLicenses(
			   IN HANDLE		hStore,	//Handle of a open store
			   IN	DWORD		dwIndex, //numeric Index of the license to query
			   OUT	PLSINDEX	plsiName //The LSIndex structure corresponding to dwIndex
			   )
{	
	LS_STATUS	lsResult = LSSTAT_ERROR;
	TCHAR		szKeyName[MAX_LEN];
	DWORD		dwKeyLen = MAX_LEN;
	FILETIME	ft;
	LONG		err = 0;
	HKEY		hTempKey = NULL;
    HKEY        hkeyStore = NULL;

	if( (hStore == NULL) ||
		(plsiName == NULL) )
		return LSSTAT_INVALID_HANDLE;

	plsiName->dwVersion = 0x01;

    hkeyStore = (HKEY)hStore;
	
	if( ERROR_SUCCESS != RegEnumKeyEx(
									(HKEY)hkeyStore,
									dwIndex,
									szKeyName,
									&dwKeyLen,
									NULL,
									NULL,
									NULL,
									&ft
									) )
		goto ErrorReturn;
	
	if( ERROR_SUCCESS != RegOpenKeyEx((HKEY)hkeyStore, szKeyName, 0, KEY_ALL_ACCESS, &hTempKey) )
		goto ErrorReturn;

	err = RegQueryValueEx(hTempKey, 
						  TEXT("LicenseScope"),
						  NULL,
						  NULL,
						  NULL,
						  &plsiName->cbScope);

	if(err!=ERROR_SUCCESS)
		goto ErrorReturn;
	
	if( NULL == (plsiName->pbScope = (BYTE FAR *)malloc(plsiName->cbScope)) )
	{
		lsResult = LSSTAT_OUT_OF_MEMORY;
		goto ErrorReturn;
	}
	
	memset(plsiName->pbScope, 0x00, plsiName->cbScope);

	err = RegQueryValueEx(hTempKey, 
						  TEXT("LicenseScope"),
						  NULL,
						  NULL,
						  plsiName->pbScope,
						  &plsiName->cbScope);
	if(err!=ERROR_SUCCESS)
		goto ErrorReturn;

	err = RegQueryValueEx(hTempKey, 
						  TEXT("CompanyName"),
						  NULL,
						  NULL,
						  NULL,
						  &plsiName->cbCompany);
	if(err!=ERROR_SUCCESS)
		goto ErrorReturn;
	
	if( NULL == (plsiName->pbCompany = (BYTE FAR *)malloc(plsiName->cbCompany)) )
	{
		lsResult = LSSTAT_OUT_OF_MEMORY;;
		goto ErrorReturn;
	}
	
	memset(plsiName->pbCompany, 0x00, plsiName->cbCompany);

	err = RegQueryValueEx(hTempKey, 
						  TEXT("CompanyName"),
						  NULL,
						  NULL,
						  (BYTE FAR *)plsiName->pbCompany,
						  &plsiName->cbCompany);
	if(err!=ERROR_SUCCESS)
		goto ErrorReturn;


	err = RegQueryValueEx(hTempKey, 
						  TEXT("ProductID"),
						  NULL,
						  NULL,
						  NULL,
						  &plsiName->cbProductID);
	if(err!=ERROR_SUCCESS)
		goto ErrorReturn;
	
	if( NULL == (plsiName->pbProductID = (BYTE FAR *)malloc(plsiName->cbProductID)) )
	{
		lsResult = LSSTAT_OUT_OF_MEMORY;
		goto ErrorReturn;
	}
	memset(plsiName->pbProductID, 0x00, plsiName->cbProductID);

	err = RegQueryValueEx(hTempKey, 
						  TEXT("ProductID"),
						  NULL,
						  NULL,
						  plsiName->pbProductID,
						  &plsiName->cbProductID);
	if(err!=ERROR_SUCCESS)
	{
		goto ErrorReturn;
	}
	
	
	lsResult = LSSTAT_SUCCESS;
CommonReturn:
	if(hTempKey)
	{
		RegCloseKey(hTempKey);
		hTempKey = NULL;
	}
	return lsResult;
ErrorReturn:
	if(plsiName->pbScope)
	{
		free(plsiName->pbScope);
		plsiName->pbScope = NULL;
	}
	if(plsiName->pbCompany)
	{
		free(plsiName->pbCompany);
		plsiName->pbCompany = NULL;
	}
	if(plsiName->pbProductID)
	{
		free(plsiName->pbProductID);
		plsiName->pbProductID = NULL;
	}
	lsResult = LSSTAT_ERROR;
	goto CommonReturn;


}

LS_STATUS
CALL_TYPE
LSQueryInfoLicense(
				   IN HANDLE		hStore,	//Handle of a open store
				   OUT	DWORD	FAR *pdwLicenses, //Total no. of licenses available
				   OUT	DWORD	FAR *pdwMaxCompanyNameLen,	//Maximum length of the company length
				   OUT	DWORD	FAR *pdwMaxScopeLen,	//Maximum length of the company length
				   OUT	DWORD	FAR *pdwMaxProductIDLen	//Maximum length of the company length
				   )
{
	LS_STATUS	lsResult = LSSTAT_ERROR;
	FILETIME	ft;
	HKEY		hTempKey = NULL;
	TCHAR		szKey[MAX_LEN];
	DWORD		dwKeyLen = MAX_LEN;
	DWORD		dwSize = 0, dwIndex;
    HKEY        hkeyStore = NULL;
	
	if(pdwLicenses == NULL)
		return LSSTAT_ERROR;

	if(pdwMaxCompanyNameLen)
		*pdwMaxCompanyNameLen = 0;
	if(pdwMaxScopeLen)
		*pdwMaxScopeLen = 0;
	if(pdwMaxProductIDLen)
		*pdwMaxProductIDLen = 0;
	
    hkeyStore = (HKEY)hStore;

	if(ERROR_SUCCESS != RegQueryInfoKey((HKEY)hkeyStore,
										 NULL,
										 NULL,
										 NULL,
										 pdwLicenses,
										 NULL,
										 NULL,
										 NULL,
										 NULL,
										 NULL,
										 NULL,
										 &ft
										 ) )
		goto ErrorReturn;

	for (dwIndex = 0; dwIndex<*pdwLicenses; dwIndex++)
	{
			if( ERROR_SUCCESS != RegEnumKeyEx((HKEY)hkeyStore,
											 dwIndex,
											 szKey,
											 &dwKeyLen,
											 NULL,
											 NULL,
											 NULL,
											 &ft) )
				goto ErrorReturn;
			if( ERROR_SUCCESS != RegOpenKeyEx((HKEY)hkeyStore,
											  szKey,
											  0,
											  KEY_READ,
											  &hTempKey) )
				goto ErrorReturn;

			if(pdwMaxCompanyNameLen)
			{
				if( ERROR_SUCCESS != RegQueryValueEx( hTempKey,
													  TEXT("CompanyName"),
													  NULL,
													  NULL,
													  NULL,
													  &dwSize) )
					goto ErrorReturn;
				if(dwSize >= *pdwMaxCompanyNameLen)
					*pdwMaxCompanyNameLen = dwSize;
			}

			if(pdwMaxScopeLen)
			{
				if( ERROR_SUCCESS != RegQueryValueEx( hTempKey,
													  TEXT("LicenseScope"),
													  NULL,
													  NULL,
													  NULL,
													  &dwSize) )
					goto ErrorReturn;
				if(dwSize >= *pdwMaxScopeLen)
					*pdwMaxScopeLen = dwSize;
			}
			if(pdwMaxProductIDLen)
			{
				if( ERROR_SUCCESS != RegQueryValueEx( hTempKey,
													  TEXT("ProductID"),
													  NULL,
													  NULL,
													  NULL,
													  &dwSize) )
					goto ErrorReturn;
				if(dwSize >= *pdwMaxProductIDLen)
					*pdwMaxProductIDLen = dwSize;
			}
	}
	
	lsResult = LSSTAT_SUCCESS;
CommonReturn:
	if(hTempKey)
	{
		RegCloseKey(hTempKey);
		hTempKey = NULL;
	}
	return lsResult;
ErrorReturn:
	goto CommonReturn;

}


LS_STATUS	
CALL_TYPE
LSOpenLicenseHandle(
				   IN HANDLE		hStore,	//Handle of a open store
				   IN  BOOL         fReadOnly,
				   IN  PLSINDEX		plsiName,
				   OUT HANDLE		*phLicense	
				   )
{
	LS_STATUS		lsReturn = LSSTAT_LICENSE_NOT_FOUND;
	TCHAR	szKeyName[MAX_LEN];
	DWORD	dwKeyNameLen = MAX_LEN;
	DWORD	dwSubKeys = 0;
	DWORD	dwIndex = 0;
	DWORD	cbValueData = 0;
	BYTE FAR *pbValueData = NULL;
	LONG	err = ERROR_SUCCESS;
	HKEY	hTempKey = NULL;
	FILETIME	ft;
    HKEY        hkeyStore = NULL;

	if( (phLicense == NULL) ||
		(hStore == NULL) ||
		(plsiName == NULL) ||
		(plsiName->pbScope == NULL) ||
		(plsiName->pbCompany == NULL) ||
		(plsiName->pbProductID == NULL) )
	{
		return LSSTAT_INVALID_HANDLE;
	}

    hkeyStore = (HKEY)hStore;

	//Get the number of Licenses available
	if( ERROR_SUCCESS != RegQueryInfoKey((HKEY)hkeyStore, 
										NULL,
										NULL,
										NULL,
										&dwSubKeys, 
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL) )
										goto ErrorReturn;
	
	//Start searching from the first license until a match is obtained
	for(dwIndex = 0; dwIndex <dwSubKeys; dwIndex ++)
	{
		dwKeyNameLen = MAX_LEN;
		if( ERROR_SUCCESS != RegEnumKeyEx(
										(HKEY)hkeyStore,
										dwIndex,
										szKeyName,
										&dwKeyNameLen,
										NULL,
										NULL,
										NULL,
										&ft
										) )
		{
			continue;
		}
		
		err = RegOpenKeyEx((HKEY)hkeyStore,
                           szKeyName,
                           0,
                           fReadOnly ? KEY_READ : KEY_READ | KEY_WRITE,
                           &hTempKey);

		if(err != ERROR_SUCCESS)
			continue;
		
		err = RegQueryValueEx(hTempKey, 
							  TEXT("LicenseScope"),
							  NULL,
							  NULL,
							  NULL,
							  &cbValueData);

		if( (err != ERROR_SUCCESS) ||
			(cbValueData != plsiName->cbScope) )
		{
			if(hTempKey)
			{
				RegCloseKey(hTempKey);
				hTempKey = NULL;
			}
			continue;
		}
		
		if( NULL == (pbValueData = (BYTE FAR *)malloc(cbValueData)) )
		{
			if(hTempKey)
			{
				RegCloseKey(hTempKey);
				hTempKey = NULL;
			}
			lsReturn = LSSTAT_OUT_OF_MEMORY;
			goto ErrorReturn;
		}
		
		memset(pbValueData, 0x00, cbValueData);

		err = RegQueryValueEx(hTempKey, 
							  TEXT("LicenseScope"),
							  NULL,
							  NULL,
							  pbValueData,
							  &cbValueData);
		
		if( (err!=ERROR_SUCCESS) ||
			(memcmp(pbValueData, plsiName->pbScope, cbValueData)) )
		{
			if(hTempKey)
			{
				RegCloseKey(hTempKey);
				hTempKey = NULL;
			}
			if(pbValueData)
			{
				free(pbValueData);
				pbValueData = NULL;
				cbValueData = 0;
			}
			continue;
		}
	
		if(pbValueData)
		{
			free(pbValueData);
			pbValueData = NULL;
			cbValueData = 0;
		}
		

		err = RegQueryValueEx(hTempKey, 
							  TEXT("CompanyName"),
							  NULL,
							  NULL,
							  NULL,
							  &cbValueData);
		
		if( (err != ERROR_SUCCESS) ||
			(cbValueData != plsiName->cbCompany) )
		{
			if(hTempKey)
			{
				RegCloseKey(hTempKey);
				hTempKey = NULL;
			}
			continue;
		}
		
		if( NULL == (pbValueData = (BYTE FAR *)malloc(cbValueData)) )
		{
			if(hTempKey)
			{
				RegCloseKey(hTempKey);
				hTempKey = NULL;
			}
			lsReturn = LSSTAT_OUT_OF_MEMORY;
			goto ErrorReturn;
		}
		
		memset(pbValueData, 0x00, cbValueData);

		err = RegQueryValueEx(hTempKey, 
							  TEXT("CompanyName"),
							  NULL,
							  NULL,
							  pbValueData,
							  &cbValueData);
		
		if( (err!=ERROR_SUCCESS) ||
			(memcmp(pbValueData, plsiName->pbCompany, cbValueData)) )
		{
			if(hTempKey)
			{
				RegCloseKey(hTempKey);
				hTempKey = NULL;
			}
			if(pbValueData)
			{
				free(pbValueData);
				pbValueData = NULL;
				cbValueData = 0;
			}
			continue;
		}

		if(pbValueData)
		{
			free(pbValueData);
			pbValueData = NULL;
			cbValueData = 0;
		}
		
		err = RegQueryValueEx(hTempKey, 
							  TEXT("ProductID"),
							  NULL,
							  NULL,
							  NULL,
							  &cbValueData);
		if( (err != ERROR_SUCCESS) ||
			( cbValueData != plsiName->cbProductID ) )
		{
			if(hTempKey)
			{
				RegCloseKey(hTempKey);
				hTempKey = NULL;
			}
			continue;
		}
		
		if( NULL == (pbValueData = (BYTE FAR *)malloc(cbValueData)) )
		{
			if(hTempKey)
			{
				RegCloseKey(hTempKey);
				hTempKey = NULL;
			}
			lsReturn = LSSTAT_OUT_OF_MEMORY;
			goto ErrorReturn;
		}
		
		memset(pbValueData, 0x00, cbValueData);

		err = RegQueryValueEx(hTempKey, 
							  TEXT("ProductID"),
							  NULL,
							  NULL,
							  pbValueData,
							  &cbValueData);
		
		if( (err!=ERROR_SUCCESS) ||
			(memcmp(pbValueData, plsiName->pbProductID, cbValueData)) )
		{
			if(hTempKey)
			{
				RegCloseKey(hTempKey);
				hTempKey = NULL;
			}
			if(pbValueData)
			{
				free(pbValueData);
				pbValueData = NULL;
			}
			continue;
		}
		
		lsReturn = LSSTAT_SUCCESS;
		if(pbValueData)
		{
			free(pbValueData);
			pbValueData = NULL;
			cbValueData = 0;
		}
		break;
	}

    if (dwIndex == dwSubKeys)
    {
        // nothing found
        goto ErrorReturn;
    }

	
	*phLicense = (HANDLE)hTempKey;	
		
CommonReturn:
		return lsReturn;
ErrorReturn:
		if(pbValueData)
		{
			free(pbValueData);
			pbValueData = NULL;
		}
		*phLicense = NULL;
		pbValueData = NULL;
		cbValueData = 0;
		goto CommonReturn;
}

LS_STATUS
CALL_TYPE
LSCloseLicenseHandle(
					 IN HANDLE		hLicense,	//Handle of a open store
					 IN DWORD	dwFlags		//For future Use
					 )
{
	LS_STATUS	lsResult = LSSTAT_ERROR;
	HKEY	hKey = (HKEY)hLicense;
	if(hKey)
	{
		RegCloseKey(hKey);
		hKey = NULL;
		lsResult = LSSTAT_SUCCESS;
	}
	return lsResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\cryptkey.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cryptkey.h
//
//  Contents:	Functions that are used to pack and unpack different messages
//
//  Classes:
//
//  Functions:	
//
//  History:    12-23-97  v-sbhatt   Created
//
//----------------------------------------------------------------------------

#ifndef _CRYPTKEY_H_
#define _CRYPTKEY_H_

//
//  Generic CryptSystem structure to be used for all cryptographic operations
//    
typedef struct _CryptSystem
{
	DWORD					dwCryptState;							//State in which the system is in
    DWORD		            dwSignatureAlg;							//Signature AlgID	
	DWORD		            dwKeyExchAlg;							//KeyExchAlgID	
	DWORD		            dwSessKeyAlg;							//Symmetric Key ALg
	DWORD		            dwMACAlg;								//MAC algID
	UCHAR		            rgbClientRandom[LICENSE_RANDOM];		//Client Random
	UCHAR		            rgbServerRandom[LICENSE_RANDOM];		//ServerRandom
    UCHAR                   rgbPreMasterSecret[LICENSE_PRE_MASTER_SECRET];   //Place for pms and ms
    UCHAR                   rgbMACSaltKey[LICENSE_MAC_WRITE_KEY];
    UCHAR                   rgbSessionKey[LICENSE_SESSION_KEY];
}CryptSystem, *PCryptSystem;

#define CRYPT_SYSTEM_STATE_INITIALIZED			0x00000000
#define CRYPT_SYSTEM_STATE_PRE_MASTER_SECRET	0x00000001
#define CRYPT_SYSTEM_STATE_MASTER_SECRET		0x00000002
#define CRYPT_SYSTEM_STATE_SESSION_KEY			0x00000003
#define CRYPT_SYSTEM_STATE_MAC_DONE				0x00000004

#ifdef __cplusplus
extern "C" {
#endif

LICENSE_STATUS
CALL_TYPE
LicenseSetPreMasterSecret(
						PCryptSystem	pCrypt,
						PUCHAR			pPreMasterSecret
						);

LICENSE_STATUS
CALL_TYPE
LicenseBuildMasterSecret(
                PCryptSystem   pSystem
                );

LICENSE_STATUS
CALL_TYPE
LicenseMakeSessionKeys(
				PCryptSystem	pCrypt,
				DWORD			dwReserved
			    );

LICENSE_STATUS
CALL_TYPE
LicenseVerifyServerCert(
				PHydra_Server_Cert	pCert
				);

LICENSE_STATUS
CALL_TYPE
LicenseGenerateMAC(
				   PCryptSystem		pCrypt,
				   PBYTE			pbData,
				   DWORD			cbData,
				   PBYTE			pbMACData
				   );

LICENSE_STATUS
CALL_TYPE
LicenseEnvelopeData(
	PBYTE			pbPublicKey,
	DWORD			cbPublicKey,
	PBYTE			pbData,
	DWORD			cbData,
	PBYTE			pbEnvelopedData,
	DWORD			*cbEnvelopedData
	);


LICENSE_STATUS
CALL_TYPE
LicenseDecryptEnvelopedData( 
	PBYTE			pbPrivateKey,
	DWORD			cbPrivateKey,
	PBYTE			pbEnvelopedData,
	DWORD			cbEnvelopedData,
	PBYTE			pbData,
	DWORD			*pcbData );


LICENSE_STATUS    
CALL_TYPE
LicenseEncryptSessionData( 
    PCryptSystem    pCrypt,
	PBYTE			pbData,
	DWORD			cbData
	);


LICENSE_STATUS
CALL_TYPE
LicenseDecryptSessionData(
	PCryptSystem    pCrypt,
    PBYTE			pbData,
	DWORD			cbData
	);

//Temporarily declared and defined in Cryptkey.h and .c

LICENSE_STATUS
CALL_TYPE
GenerateClientHWID(
				   PHWID	phwid
				  );

LICENSE_STATUS
CALL_TYPE
LicenseEncryptHwid(
    PHWID   pHwid,
    PDWORD  pcbEncryptedHwid,
    PBYTE   pEncryptedHwid,
    DWORD   cbSecretKey,
    PBYTE   pSecretKey );


LICENSE_STATUS
CALL_TYPE
LicenseDecryptHwid(
    PHWID pHwid,
    DWORD cbEncryptedHwid,
    PBYTE pEncryptedHwid,
    DWORD cbSecretKey,
    PBYTE pSecretKey );


LICENSE_STATUS
CALL_TYPE
UnpackHydraServerCertificate(
    PBYTE				pbMessage,
	DWORD				cbMessage,
	PHydra_Server_Cert	pCanonical );


#ifdef __cplusplus
}
#endif

#endif //_CRYPTKEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\buffers.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    buffers

Abstract:

    This header file provides dynamic buffer and string classes for general use.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32

Notes:



--*/

#ifndef _BUFFERS_H_
#define _BUFFERS_H_

#include <string.h>
#include "memCheck.h"


//
//==============================================================================
//
//  CBuffer
//

class CBuffer
{
public:

    //  Constructors & Destructor

    CBuffer()           // Default Initializer
    { Initialize(); };

    CBuffer(            // Initialize with starting length.
        IN DWORD cbLength)
    { Initialize();
      Presize(cbLength, FALSE); };

    CBuffer(            // Initialize with starting data.
        IN const BYTE * const pbSource,
        IN DWORD cbLength)
    { Initialize();
      Set(pbSource, cbLength); };

    virtual ~CBuffer()  // Tear down.
    { Clear(); };


    //  Properties
    //  Methods

    void
    Clear(void);        // Free up any allocated memory.

    LPBYTE
    Reset(void);        // Return to default state (don't loose memory.)

    LPBYTE
    Presize(            // Make sure the buffer is big enough.
        IN DWORD cbLength,
        IN BOOL fPreserve = FALSE);

    LPBYTE
    Resize(         // Make sure the buffer & length are the right size.
        DWORD cbLength,
        BOOL fPreserve = FALSE);

    LPBYTE
    Set(            // Load a value.
        IN const BYTE * const pbSource,
        IN DWORD cbLength);

    LPBYTE
    Append(         // Append more data to the existing data.
        IN const BYTE * const pbSource,
        IN DWORD cbLength);

    DWORD
    Length(         // Return the length of the data.
        void) const
    { return m_cbDataLength; };

    LPBYTE
    Access(         // Return the data, starting at an offset.
        DWORD offset = 0)
    const
    { if (m_cbDataLength <= offset) return NULL;
      else return &m_pbBuffer[offset]; };

    int
    Compare(
        const CBuffer &bfSource)
    const;


    //  Operators

    CBuffer &
    operator=(
        IN const CBuffer &bfSource)
    { Set(bfSource.m_pbBuffer, bfSource.m_cbDataLength);
      return *this; };

    CBuffer &
    operator+=(
        IN const CBuffer &bfSource)
    { Append(bfSource.m_pbBuffer, bfSource.m_cbDataLength);
      return *this; };

    BYTE &
    operator[](
        DWORD offset)
        const
    { return *Access(offset); };

    int
    operator==(
        IN const CBuffer &bfSource)
        const
    { return 0 == Compare(bfSource); };

    int
    operator!=(
        IN const CBuffer &bfSource)
        const
    { return 0 != Compare(bfSource); };


protected:

    //  Properties

    LPBYTE m_pbBuffer;
    DWORD m_cbDataLength;
    DWORD m_cbBufferLength;


    //  Methods

    void
    Initialize(void)
    {
        m_pbBuffer = NULL;
        m_cbDataLength = 0;
        m_cbBufferLength = 0;
    };

    CBuffer(           //  Object assignment constructor.
        IN const CBuffer &bfSourceOne,
        IN const CBuffer &bfSourceTwo)
    {
        Initialize();
        Presize(bfSourceOne.m_cbDataLength + bfSourceTwo.m_cbDataLength);
        Set(bfSourceOne.m_pbBuffer, bfSourceOne.m_cbDataLength);
        Append(bfSourceTwo.m_pbBuffer, bfSourceTwo.m_cbDataLength);
    };

    friend
        CBuffer 
        operator+(
            IN const CBuffer &bfSourceOne,
            IN const CBuffer &bfSourceTwo);
};


/*++

Clear:

    This routine resets a CBuffer to it's initial state, freeing any allocated
    memory.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline void
CBuffer::Clear(
    void)
{
    if (NULL != m_pbBuffer)
        delete[] m_pbBuffer;
    Initialize();
}


/*++

Reset:

    This routine logically empties the CBuffer without actually deallocating
    memory.  It's data lengh goes to zero.

Arguments:

    None

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline LPBYTE
CBuffer::Reset(
    void)
{
    m_cbDataLength = 0;
    return m_pbBuffer;
}


/*++

Presize:

    This is the primary workhorse of the CBuffer class.  It ensures that the
    size of the buffer is of the proper size.  Data in the buffer may optionally
    be preserved, in which case the data length doesn't change.  If the buffer
    is not preserved, then the data length is reset to zero.

Arguments:

    cbLength supplies the desired length of the buffer.

    fPreserve supplies a flag indicating whether or not to preserve the current
        contents of the buffer.

Return Value:

    The address of the properly sized buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline LPBYTE
CBuffer::Presize(
    IN DWORD cbLength,
    IN BOOL fPreserve)
{
    LPBYTE pbNewBuf = NULL;
    if (fPreserve && (0 < m_cbDataLength))
    {

        //
        // Increase the buffer length, and preserve the existing data.
        //

        if (m_cbBufferLength < cbLength)
        {
            NEWReason("Buffer contents")
            pbNewBuf = new BYTE[cbLength];
            if (NULL == pbNewBuf)
                goto ErrorExit;
            memcpy(pbNewBuf, m_pbBuffer, m_cbDataLength);
            delete[] m_pbBuffer;
            m_pbBuffer = pbNewBuf;
            pbNewBuf = NULL;
            m_cbBufferLength = cbLength;
        }
    }
    else
    {

        //
        // Increase the buffer length, but lose any existing data.
        //

        if (m_cbBufferLength < cbLength)
        {
            NEWReason("Buffer contents")
            pbNewBuf = new BYTE[cbLength];
            if (NULL == pbNewBuf)
                goto ErrorExit;
            if (NULL != m_pbBuffer)
                delete[] m_pbBuffer;
            m_pbBuffer = pbNewBuf;
            pbNewBuf = NULL;
            m_cbBufferLength = cbLength;
        }
        m_cbDataLength = 0;
    }
    return m_pbBuffer;

ErrorExit:
    if (NULL != pbNewBuf)
        delete[] pbNewBuf;
    return NULL;
}


/*++

Resize:

    This method sets the length of the data to the given size.  If the buffer
    isn't big enough to support that data length, it is enlarged.

Arguments:

    cbLength supplies the new length of the data.

    fPreserve supplies a flag indicating whether or not to preserve existing
        data.

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline LPBYTE
CBuffer::Resize(
    DWORD cbLength,
    BOOL fPreserve)
{
    LPBYTE pb = Presize(cbLength, fPreserve);
    if (NULL != pb)
        m_cbDataLength = cbLength;
    return pb;
}


/*++

Set:

    This method sets the contents of the data to the given value.  If the buffer
    isn't big enough to hold the given data, it is enlarged.

Arguments:

    pbSource supplies the data to place in the data buffer.

    cbLength supplies the length of that data, in bytes.

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline LPBYTE
CBuffer::Set(
    IN const BYTE * const pbSource,
    IN DWORD cbLength)
{
    LPBYTE pb = Presize(cbLength, FALSE);
    if (NULL != pb)
    {
        if (0 < cbLength)
            memcpy(pb, pbSource, cbLength);
        m_cbDataLength = cbLength;
    }
    return pb;
}


/*++

CBuffer::Append:

    This method appends the supplied data onto the end of the existing data,
    enlarging the buffer if necessary.

Arguments:

    pbSource supplies the data to be appended.

    cbLength supplies the length of the data to be appended, in bytes.

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline LPBYTE
CBuffer::Append(
    IN const BYTE * const pbSource,
    IN DWORD cbLength)
{
    LPBYTE pb = m_pbBuffer;
    if (0 < cbLength)
    {
        pb = Presize(m_cbDataLength + cbLength, TRUE);
        if (NULL != pb)
        {
            memcpy(&pb[m_cbDataLength], pbSource, cbLength);
            m_cbDataLength += cbLength;
        }
    }
    return pb;
}


/*++

CBuffer::Compare:

    This method compares the contents of another CBuffer to this one, and
    returns a value indicating a comparative value.

Arguments:

    bfSource supplies the other buffer.

Return Value:

    < 0 - The other buffer is less than this one.
    = 0 - The other buffer is identical to this one.
    > 0 - The other buffer is greater than this one.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline int
CBuffer::Compare(
    const CBuffer &bfSource)
const
{
    if (m_cbDataLength < bfSource.m_cbDataLength)
        return *(bfSource.m_pbBuffer + m_cbDataLength);
    else if (m_cbDataLength > bfSource.m_cbDataLength)
        return *(m_pbBuffer + bfSource.m_cbDataLength);
    else if (0 < m_cbDataLength)
        return memcmp(m_pbBuffer, bfSource.m_pbBuffer, m_cbDataLength);
    else
        return 0;
}


/*++

operator+:

    This routine is a special operator that allows addition of two CBuffers to
    produce a third, a la bfThree = bfOne + bfTwo.  It calls the special
    protected constructor of CBuffer.

Arguments:

    bfSourceOne supplies the first buffer
    bfSourceTwo supplies the second buffer

Return Value:

    A reference to a temporary CBuffer that is the concatenation of the two
    provided buffers.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline CBuffer 
operator+(
    IN const CBuffer &bfSourceOne,
    IN const CBuffer &bfSourceTwo)
{
    return CBuffer(bfSourceOne, bfSourceTwo);
}

#endif // _BUFFERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\dynarray.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dynarray

Abstract:

    This header file implements a Dynamic Array.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32

Notes:



--*/

#ifndef _DYNARRAY_H_
#define _DYNARRAY_H_


//
//==============================================================================
//
//  CDynamicArray
//

template <class T>
class CDynamicArray
{
public:

    //  Constructors & Destructor

    CDynamicArray(void)
    { m_Max = m_Mac = 0; m_pvList = NULL; };

    virtual ~CDynamicArray()
    { Clear(); };


    //  Properties
    //  Methods

    void
    Clear(void)
    {
        if (NULL != m_pvList)
        {
            delete[] m_pvList;
            m_pvList = NULL;
            m_Max = 0;
            m_Mac = 0;
        }
    };

    void
    Empty(void)
    { m_Mac = 0; };

    T *
    Set(
        IN int nItem,
        IN T *pvItem);

    T *
    Insert(
        IN int nItem,
        IN T *pvItem);

    T *
    Add(
        IN T *pvItem);

    T * const
    Get(
        IN int nItem)
    const;

    DWORD
    Count(void) const
    { return m_Mac; };


    //  Operators
    T * const
    operator[](int nItem) const
    { return Get(nItem); };


protected:
    //  Properties

    DWORD
        m_Max,          // Number of element slots available.
        m_Mac;          // Number of element slots used.
    T **
        m_pvList;       // The elements.


    //  Methods
};


/*++

Set:

    This routine sets an item in the collection array.  If the array isn't that
    big, it is expanded with NULL elements to become that big.

Arguments:

    nItem - Supplies the index value to be set.
    pvItem - Supplies the value to be set into the given index.

Return Value:

    The value of the inserted value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template<class T>
inline T *
CDynamicArray<T>::Set(
    IN int nItem,
    IN T * pvItem)
{
    DWORD index;


    //
    // Make sure the array is big enough.
    //

    if ((DWORD)nItem >= m_Max)
    {
        int newSize = (0 == m_Max ? 4 : m_Max);
        while (nItem >= newSize)
            newSize *= 2;
        NEWReason("Dynamic Array")
        T **newList = new T*[newSize];
        if (NULL == newList)
            goto ErrorExit;
        for (index = 0; index < m_Mac; index += 1)
            newList[index] = m_pvList[index];
        if (NULL != m_pvList)
            delete[] m_pvList;
        m_pvList = newList;
        m_Max = newSize;
    }


    //
    // Make sure intermediate elements are filled in.
    //

    if ((DWORD)nItem >= m_Mac)
    {
        for (index = m_Mac; index < (DWORD)nItem; index += 1)
            m_pvList[index] = NULL;
        m_Mac = (DWORD)nItem + 1;
    }


    //
    // Fill in the list element.
    //

    m_pvList[(DWORD)nItem] = pvItem;
    return pvItem;

ErrorExit:
    return NULL;
}


/*++

Insert:

    This routine inserts an element in the array by moving all elements above it
    up one, then inserting the new element.

Arguments:

    nItem - Supplies the index value to be inserted.
    pvItem - Supplies the value to be set into the given index.

Return Value:

    The value of the inserted value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

template<class T>
inline T *
CDynamicArray<T>::Insert(
    IN int nItem,
    IN T * pvItem)
{
    DWORD index;
    for (index = nItem; index < m_Mac; index += 1)
        if (NULL == Set(index + 1, Get(index)))
            return NULL;    // Only the first one can fail, so no change
                            // happens on errors.
    return Set(nItem, pvItem);
}


/*++

Add:

    This method adds an element to the end of the dynamic array.

Arguments:

    pvItem - Supplies the value to be added to the list.

Return Value:

    The value of the added value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

template<class T>
inline T *
CDynamicArray<T>::Add(
    IN T *pvItem)
{
    return Set(Count(), pvItem);
}


/*++

Get:

    This method returns the element at the given index.  If there is no element
    previously stored at that element, it returns NULL.  It does not expand the
    array.

Arguments:

    nItem - Supplies the index into the list.

Return Value:

    The value stored at that index in the list, or NULL if nothing has ever been
    stored there.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template <class T>
inline T * const
CDynamicArray<T>::Get(
    int nItem)
    const
{
    if (m_Mac <= (DWORD)nItem)
        return NULL;
    else
        return m_pvList[nItem];
}

#endif // _DYNARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\licdbg.h ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    licdbg.h

Abstract:


Author:

    Fred Chong (FredCh) 7/1/1998

Environment:

Notes:

--*/

#ifndef __LICDBG_H__
#define __LICDBG_H__

#define LS_LOG_ERROR                0x0001
#define LS_LOG_WARNING              0x0002
#define LS_LOG_TRACE                0x0004
#define LS_LOG_ALLOC                0x0008
#define LS_LOG_RES                  0x0010
#define DEB_ERROR					LS_LOG_ERROR
#define DEB_WARN					LS_LOG_WARNING
#define DEB_TRACE					LS_LOG_TRACE

#if DBG

extern DWORD   LicenseTraceIndent;

#define LS_ASSERT(x) \
	    if (!(x)) \
		LSAssert(#x, __FILE__, __LINE__, NULL); else


#define DebugLog(x) LicenseDebugLog x
#ifndef OS_WINCE
#define LS_BEGIN(x) LicenseDebugLog(DEB_TRACE,"BEGIN:" x "\n"); LicenseTraceIndent++;
#else
#define LS_BEGIN(x) LicenseDebugLog(DEB_TRACE,"BEGIN:", x, "\n"); LicenseTraceIndent++;
#endif
#define LS_RETURN(x) { LicenseTraceIndent--; LicenseDebugLog(DEB_TRACE, "END  Line %d\n", __LINE__); return (x); }
#define LS_LOG_RESULT(x) LicenseLogErrorCode((x), __FILE__, __LINE__)
#define LS_END(x)   { LicenseTraceIndent--; LicenseDebugLog(DEB_TRACE, "END:Line %d\n",  __LINE__); }
#define LS_BREAK()  { LicenseDebugLog(DEB_TRACE, "BREAK  Line %d\n",  __LINE__); }
#define LS_DUMPSTRING(size, data)  \
		if ((data)) \
		DbgDumpHexString((data), (size)); 

void 
LicenseDebugOutput(char *szOutString);


long
//CALL_TYPE
LicenseLogErrorCode(long, const char *, long);
void
//CALL_TYPE
//_cdecl
LicenseDebugLog(long, const char *, ...);

void    
//CALL_TYPE
DbgDumpHexString(const unsigned char*, DWORD);

void 
//CALL_TYPE
LSAssert( void *, void *, unsigned long, char *);

#else

#define LS_ASSERT(x)
#define DebugLog(x)
#define LS_BEGIN(x) 
#define LS_RETURN(x) return (x)
#define LS_LOG_RESULT(x) x
#define LS_END(x)
#define LS_BREAK()
#define LS_DUMPSTRING(size, data)
#define LicenseDebugOutput(x)
#define LicenseDebugLog
#define DbgDumpHexString(x, y)
#define LicenseTraceIndent
#define LicenseLogErrorCode
#endif	//_DEBUG



#endif /* __LICDBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\hslice.h ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        hslice.h
//
// Contents:    Hydra Server License Protocol API
//
// History:     01-07-98    FredCh  Created
//
//-----------------------------------------------------------------------------


#ifndef _HSLICENSE_H_
#define _HSLICENSE_H_

#include <license.h>


///////////////////////////////////////////////////////////////////////////////
// Context flags
//

#define LICENSE_CONTEXT_PER_SEAT     0x00000001
#define LICENSE_CONTEXT_CONCURRENT   0x00000002
#define LICENSE_CONTEXT_INTERNET     0x00000003
#define LICENSE_CONTEXT_REMOTE_ADMIN 0x00000004
#define LICENSE_CONTEXT_CON_QUEUE    0x00000005

///////////////////////////////////////////////////////////////////////////////
// These are the different responses that can be constructed by the 
// ConstructLicenseResponse API
//

#define LICENSE_RESPONSE_VALID_CLIENT       0x00000001
#define LICENSE_RESPONSE_INVALID_CLIENT     0x00000002

//-----------------------------------------------------------------------------
//
// Terminal server's license server discovery mechanism may log these
// events:
//
// LICENSING_EVENT_NO_LICENSE_SERVER - it cannot find any license server.
//
// LICENSING_EVENT_TEMP_LICENSE_EXPIRED - A client has been disconnected
// because its temporary license has expired.
//
// LICENSING_EVENT_NO_LICENSE_GRANTED - No license could be granted, and
// we're past the grace period
//
// LICENSING_EVENT_NO_CONCURRENT_LICENSE - No more remote admin or internet
// connector logons allowed.
//
//-----------------------------------------------------------------------------

#define LICENSING_EVENT_NO_LICENSE_SERVER                   0x00000001
#define LICENSING_EVENT_TEMP_LICENSE_EXPIRED                0x00000002
#define LICENSING_EVENT_NO_LICENSE_GRANTED                  0x00000003
#define LICENSING_EVENT_NO_CONCURRENT_LICENSE               0x00000004

///////////////////////////////////////////////////////////////////////////////
// Hydra server licensing API
//

#ifdef __cplusplus
extern "C" {
#endif


LICENSE_STATUS
InitializeLicenseLib(
    BOOL fUseLicenseServer );


LICENSE_STATUS
ShutdownLicenseLib();


LICENSE_STATUS
CreateLicenseContext(
    HANDLE * phContext,
    DWORD    dwFlag );


LICENSE_STATUS
InitializeLicenseContext(
    HANDLE                  hContext,
    DWORD                   dwFlags,
    LPLICENSE_CAPABILITIES  pLicenseCap );


LICENSE_STATUS
AcceptLicenseContext(
    HANDLE  hContext,
    DWORD   cbInBuf,
    PBYTE   pInBuf,
    DWORD * pcbOutBuf,
    PBYTE * ppOutBuf );


LICENSE_STATUS
DeleteLicenseContext(
    HANDLE hContext );


LICENSE_STATUS
GetConcurrentLicense(
    HANDLE  hContext,
    PLONG   pLicenseCount );
    

LICENSE_STATUS
ReturnConcurrentLicense(
    HANDLE  hContext,
    LONG    LicenseCount );


LICENSE_STATUS
GetConcurrentLicenseCount(
    HANDLE  hContext,
    PLONG   pLicenseCount );


LICENSE_STATUS
ConstructLicenseResponse(
    HANDLE      hLicense,
    DWORD       dwResponse,
    PDWORD      pcbOutBuf,
    PBYTE *     ppOutBuf );


LICENSE_STATUS
InitializeLicensingTimeBomb();

BOOL
RegisteredWithLicenseServer();

VOID
ReceivedPermanentLicense();

LICENSE_STATUS
SetInternetConnectorStatus(
    BOOL    *   pfStatus );


LICENSE_STATUS
GetInternetConnectorStatus(
    BOOL    * pfStatus );


VOID
CheckLicensingTimeBombExpiration();
BOOL
IsLicensingTimeBombExpired();

VOID
LogLicensingEvent( 
    HANDLE  hLicense,
    DWORD   dwEventId );


LICENSE_STATUS
QueryLicenseInfo(
    HANDLE                  hLicense,
    PTS_LICENSE_INFO        pTsLicenseInfo );


VOID
FreeLicenseInfo(
    PTS_LICENSE_INFO        pTsLicenseInfo );

    
#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\licecert.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    licecert.h

Abstract:

    The header file for the X509 certificates parsing and verification API

Author:

    Frederick Chong (fredch) 6/1/1998

Environment:

    Win32, WinCE, Win16

Notes:

--*/

#ifndef _LICE_CERT_H_
#define _LICE_CERT_H_

//-----------------------------------------------------------------------------
//
// Flags to indicate to VerifyCertChain on how should the validity dates in the
// certificate chain be handled.
//
//-----------------------------------------------------------------------------

#define CERT_DATE_ERROR_IF_INVALID      0x00000001
#define CERT_DATE_WARN_IF_INVALID       0x00000002
#define CERT_DATE_DONT_VALIDATE         0x00000003

#define CERT_DATE_OK                    0x00000004
#define CERT_DATE_NOT_BEFORE_INVALID    0x00000005
#define CERT_DATE_NOT_AFTER_INVALID     0x00000006

#ifdef __cplusplus
extern "C" {
#endif

//+----------------------------------------------------------------------------
//
// Function:
//
//  VerifyCertChain
//
// Abstract:
//
//  Verifies a chain of X509 certificates
//
// Parameters:
//
//  pbCert - The certificate chain to verify
//  cbCert - Size of the certificate chain
//  pbPublicKey - The memory to store the public key of the subject on output.
//                If set to NULL on input, the API will return 
//                LICENSE_STATUS_INSUFFICIENT_BUFFER and the size of the 
//                required buffer set in pcbPublicKey.
//  pcbPublicKey - Size of the allocated memory on input.  On output, contains
//                 the actual size of the public key.
//  pfDates - How the API should check the validity dates in the cert chain.
//            This flag may be set to the following values:
//
//  CERT_DATE_ERROR_IF_INVALID - The API will return an error if the
//                               dates are invalid. When the API returns,
//                               this flag will be set to CERT_DATE_OK if the
//                               dates are OK or one of CERT_DATE_NOT_BEFORE_INVALID
//                               or CERT_DATE_NOT_AFTER_INVALID.
//  CERT_DATE_DONT_VALIDATE - Don't validate the dates in the cert chain.  The value
//                            in this flag is not changed when the API returns. 
//  CERT_DATE_WARN_IF_INVALID - Don't return an error for invalid cert dates.
//                              When the API returns, this flag will be set to
//                              CERT_DATE_OK if the dates are OK or one of
//                              CERT_DATE_NOT_BEFORE_INVALID or 
//                              CERT_DATE_NOT_AFTER_INVALID.
//
// Return:
//
//  LICENSE_STATUS_OK if the function is successful.
//
//+----------------------------------------------------------------------------
 
LICENSE_STATUS
VerifyCertChain( 
    LPBYTE  pbCert, 
    DWORD   cbCert,
    LPBYTE  pbPublicKey,
    LPDWORD pcbPublicKey,
    LPDWORD pfDate );


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\lscsp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows Terminal Server
//  Copyright (C) Microsoft Corporation, 1989 - 1998.
//
//  File:       lscsp.h
//
//  Contents:   Header file for License Server CSP routine
//
//----------------------------------------------------------------------------

#ifndef __LSCSP__
#define __LSCSP__

#include "license.h"

//-----------------------------------------------------------------------------
//
// The types of CSP data that can be retrieved and stored
//
// LsCspInfo_Certificate - The proprietory certificate
// LsCspInfo_X509Certificate - The X509 certificate
// LsCspInfo_PublicKey - The public key in the proprietory certificate
// LsCspInfo_PrivateKey - The private key corresponding to the proprietory certificate
// LsCspInfo_X509CertPrivateKey - The private key corresponding to the X509 certificate
// LsCspInfo_X509CertID - The X509 certificate ID
//
//-----------------------------------------------------------------------------

typedef enum {
    
    LsCspInfo_Certificate,
    LsCspInfo_X509Certificate,
    LsCspInfo_PublicKey,
    LsCspInfo_PrivateKey,
    LsCspInfo_X509CertPrivateKey,
    LsCspInfo_X509CertID

} LSCSPINFO, FAR *LPLSCSPINFO;

//-----------------------------------------------------------------------------
//
// Terminal server registry keys and values
//
//-----------------------------------------------------------------------------

#define HYDRA_CERT_REG_KEY \
    "System\\CurrentControlSet\\Services\\TermService\\Parameters"

#define HYDRA_CERTIFICATE_VALUE "Certificate"
#define HYDRA_X509_CERTIFICATE  "X509 Certificate"
#define HYDRA_X509_CERT_ID      "X509 Certificate ID"

// L$ means only readable from the local machine

#define PUBLIC_KEY_NAME \
    L"L$HYDRAENCKEY_3a6c88f4-80a7-4b9e-971b-c81aeaa4f943"

#define PRIVATE_KEY_NAME \
    L"L$HYDRAENCKEY_28ada6da-d622-11d1-9cb9-00c04fb16e75"

#define X509_CERT_PRIVATE_KEY_NAME \
    L"L$HYDRAENCKEY_dd2d98db-2316-11d2-b414-00c04fa30cc4"

#define X509_CERT_PUBLIC_KEY_NAME   \
    L"L$HYDRAENCPUBLICKEY_dd2d98db-2316-11d2-b414-00c04fa30cc4"



//-----------------------------------------------------------------------------
//
// Function Prototypes
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

LICENSE_STATUS
LsCsp_GetServerData(
    LSCSPINFO   Info,
    LPBYTE      pBlob,
    LPDWORD     pdwBlobLen
    );

LICENSE_STATUS
LsCsp_SetServerData(
    LSCSPINFO   Info,
    LPBYTE      pBlob,
    DWORD       dwBlobLen 
    );

LICENSE_STATUS
LsCsp_NukeServerData(
    LSCSPINFO   Info );

BOOL
LsCsp_DecryptEnvelopedData(
    CERT_TYPE   CertType,
    LPBYTE      pbEnvelopeData,
    DWORD       cbEnvelopeData,
    LPBYTE      pbData,
    LPDWORD     pcbData
    );

BOOL
LsCsp_EncryptEnvelopedData(
    LPBYTE  pbData,
    DWORD   cbData,
    LPBYTE  pbEnvelopedData,
    LPDWORD pcbEnvelopedData);


LICENSE_STATUS
LsCsp_Initialize( void );


VOID 
LsCsp_Exit( void );


BOOL 
LsCsp_UseBuiltInCert( void );


LICENSE_STATUS
LsCsp_InstallX509Certificate( LPVOID lpParam );


LICENSE_STATUS
LsCsp_EncryptHwid(
    PHWID       pHwid,
    LPBYTE      pbEncryptedHwid,
    LPDWORD     pcbEncryptedHwid );


LICENSE_STATUS
LsCsp_StoreSecret(
    TCHAR * ptszKeyName,
    BYTE *  pbKey,
    DWORD   cbKey );


LICENSE_STATUS
LsCsp_RetrieveSecret(
    TCHAR *     ptszKeyName,
    PBYTE       pbKey,
    DWORD *     pcbKey );


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\hcpack.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       Hcpack.h
//
//  Contents:	Functions that are used to pack and unpack different messages
//				coming in to and going out from Hydra Client
//  Classes:
//
//  Functions:
//
//  History:    12-20-97  v-sbhatt   Created
//
//----------------------------------------------------------------------------

#ifndef	_HCPACK_H_
#define _HCPACK_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Functions for Packing different Client Messages from the corresponding
// structures to simple binary blob
//

LICENSE_STATUS
PackHydraClientNewLicenseRequest(
			IN		PHydra_Client_New_License_Request	pCanonical,
            IN      BOOL                                fExtendedError,
			OUT		BYTE FAR *							pbBuffer,
			IN OUT	DWORD FAR *							pcbBuffer
			);

LICENSE_STATUS
PackHydraClientLicenseInfo(
			IN		PHydra_Client_License_Info      pCanonical,
            IN      BOOL                            fExtendedError,
			OUT		BYTE FAR *						pbBuffer,
			IN OUT	DWORD FAR *                     pcbBuffer            
			);


LICENSE_STATUS
PackHydraClientPlatformChallengeResponse(
			IN		PHydra_Client_Platform_Challenge_Response	pCanonical,
            IN      BOOL                                        fExtendedError,
			OUT 	BYTE FAR *									pbBuffer,
			IN OUT	DWORD FAR *									pcbBuffer
			);

LICENSE_STATUS
PackLicenseErrorMessage(
			IN  	PLicense_Error_Message			pCanonical,
            IN      BOOL                            fExtendedError,
			OUT 	BYTE FAR *						pbBuffer,
			IN OUT	DWORD FAR *						pcbBuffer
			);

//
// Functions for unpacking different Hydra Server Messages from 
// simple binary blobs to corresponding structure
//	
LICENSE_STATUS
UnPackLicenseErrorMessage(
			IN  	BYTE FAR *						pbMessage,
			IN  	DWORD							cbMessage,
			OUT 	PLicense_Error_Message			pCanonical
			);

LICENSE_STATUS
UnpackHydraServerLicenseRequest(
			IN  	BYTE FAR *						pbMessage,
			IN  	DWORD							cbMessage,
			OUT 	PHydra_Server_License_Request   pCanonical 
			);


LICENSE_STATUS
UnPackHydraServerPlatformChallenge(
			IN  	BYTE FAR *							pbMessage,
			IN  	DWORD								cbMessage,
			OUT 	PHydra_Server_Platform_Challenge	pCanonical
			);



LICENSE_STATUS
UnPackHydraServerNewLicense(
			IN  	BYTE FAR *						pbMessage,
			IN  	DWORD							cbMessage,
			OUT 	PHydra_Server_New_License		pCanonical
			);

LICENSE_STATUS
UnPackHydraServerUpgradeLicense(
			IN  	BYTE FAR *						pbMessage,
			IN  	DWORD							cbMessage,
			OUT 	PHydra_Server_Upgrade_License	pCanonical
			);

#if 0
LICENSE_STATUS
UnpackHydraServerCertificate(
							 IN		BYTE FAR *			pbMessage,
							 IN		DWORD				cbMessage,
							 OUT	PHydra_Server_Cert	pCaonical
							 );
#endif

LICENSE_STATUS
UnpackNewLicenseInfo(
					 BYTE FAR *			pbMessage,
					 DWORD				cbMessage,
					 PNew_License_Info	pCanonical
					 );


LICENSE_STATUS
UnPackExtendedErrorInfo( 
                   UINT32       *puiExtendedErrorInfo,
                   Binary_Blob  *pbbErrorInfo
                   );

#ifdef __cplusplus
}
#endif

#endif	//_HCPACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\licprot.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       licprot.h
//
//  Contents:   Licensing Protocol APIs
//
//  Classes:
//
//  Functions:
//
//  History:    02-15-00   RobLeit     Created
//
//----------------------------------------------------------------------------

#ifndef __LICPROT_H__
#define __LICPROT_H__

#ifdef __cplusplus
extern "C" {
#endif

LICENSE_STATUS CreateProtocolContext(LPLICENSE_CAPABILITIES pLicenseCap,HANDLE *phContext);

LICENSE_STATUS DeleteProtocolContext(HANDLE hContext);

LICENSE_STATUS InitializeProtocolLib();

LICENSE_STATUS ShutdownProtocolLib();

LICENSE_STATUS AcceptProtocolContext(HANDLE hContext,DWORD cbInBuf,PBYTE pInBuf,DWORD * pcbOutBuf,PBYTE * ppOutBuf, PBOOL pfExtendedError);

LICENSE_STATUS ConstructProtocolResponse(HANDLE hLicense,DWORD dwResponse,UINT32 uiExtendedErrorInfo, PDWORD pcbOutBuf,PBYTE * ppOutBuf, BOOL fExtendedError);

LICENSE_STATUS QueryLicenseInfo(HANDLE pLicenseContext,PTS_LICENSE_INFO pTsLicenseInfo);

LICENSE_STATUS RequestNewLicense(HANDLE hContext,TCHAR *tszLicenseServerName,LICENSEREQUEST *pLicenseRequest,TCHAR *tszComputerName,TCHAR *tszUserName,BOOL fAcceptTempLicense,BOOL fAcceptFewerLicenses,DWORD *pdwQuantity, DWORD *pcbLicense,PBYTE *ppbLicense);

LICENSE_STATUS InitProductInfo(PProduct_Info pProductInfo,LPTSTR lptszProductSku);

LICENSE_STATUS ReturnInternetLicense(HANDLE hContext,TCHAR *tszLicenseServer,LICENSEREQUEST *pLicenseRequest,ULARGE_INTEGER ulSerialNumber,DWORD dwQuantity);

BOOL AllowLicensingGracePeriodConnection();

DWORD StartCheckingGracePeriod();

DWORD StopCheckingGracePeriod();

LICENSE_STATUS DaysToExpiration(HANDLE hContext,DWORD *pdwDaysLeft,BOOL *pfTemporary);

LICENSE_STATUS
MarkLicenseFlags(HANDLE hContext, UCHAR ucFlags);
    
void LicenseLogEvent(WORD wEventType,DWORD dwEventId,WORD cStrings,PWCHAR *apwszStrings);


#ifdef __cplusplus
};
#endif

#endif // __LICPROT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\licekpak.h ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    licekpak.h

Abstract:


Author:

    Fred Chong (FredCh) 7/1/1998

Environment:

Notes:

--*/

#ifndef _LICE_KEYPACK_H_
#define _LICE_KEYPACK_H_

#include <windows.h>
#include <wincrypt.h>

///////////////////////////////////////////////////////////////////////////////
// keypack description
//

typedef struct _KeyPack_Description
{
    LCID    Locale;             // Locale ID

    DWORD   cbProductName;      // product name

    PBYTE   pbProductName;      // product name

    DWORD   cbDescription;      // Number of bytes in the description string

    PBYTE   pDescription;       // Pointer to the description string    

} KeyPack_Description, * PKeyPack_Description;


///////////////////////////////////////////////////////////////////////////////
// License keypack content
///////////////////////////////////////////////////////////////////////////////

//
// License keypack version
//

#define LICENSE_KEYPACK_VERSION_1_0                     0x00010000

//
// License keypack type
//

#define LICENSE_KEYPACK_TYPE_SELECT                     0x00000001
#define LICENSE_KEYPACK_TYPE_MOLP                       0x00000002
#define LICENSE_KEYPACK_TYPE_RETAIL                     0x00000003

//
// License keypack distribution channel identifiers
//

#define LICENSE_DISTRIBUTION_CHANNEL_OEM                0x00000001
#define LICENSE_DISTRIBUTION_CHANNEL_RETAIL             0x00000002

//
// License Keypack encryption information.
//

#define LICENSE_KEYPACK_ENCRYPT_CRYPTO                  0x00000000
#define LICENSE_KEYPACK_ENCRYPT_ALWAYSCRYPTO            0x00000001

#define LICENSE_KEYPACK_ENCRYPT_MIN                     LICENSE_KEYPACK_ENCRYPT_CRYPTO
#define LICENSE_KEYPACK_ENCRYPT_MAX                     LICENSE_KEYPACK_ENCRYPT_ALWAYSCRYPTO

typedef struct __LicensePackEncodeParm {
    DWORD dwEncodeType;
    HCRYPTPROV hCryptProv;

    PBYTE pbEncryptParm;    // depends on dwEncodeType
    DWORD cbEncryptParm;
} LicensePackEncodeParm, *PLicensePackEncodeParm;

typedef struct __LicensePackDecodeParm {
    HCRYPTPROV hCryptProv;

    //
    // Private binaries to generate encryption key to decrypt 
    // license key pack blob.  

    //
    // Private binaries to generate encryption key, this field is
    // ignore if key pack blob is encrypted using certificates.
    //
    PBYTE pbDecryptParm;
    DWORD cbDecryptParm;
    
    //
    // Certificate to generate encryption key, these fields are
    // require even data is encryped using private binaries.
    //
    DWORD cbClearingHouseCert;
    PBYTE pbClearingHouseCert;

    DWORD cbRootCertificate;
    PBYTE pbRootCertificate;

} LicensePackDecodeParm, *PLicensePackDecodeParm;

///////////////////////////////////////////////////////////////////////////////
// Content of license keypack 
//

typedef struct _License_KeyPack_
{
    DWORD                   dwVersion;          // version of this structure

    DWORD                   dwKeypackType;      // Select, MOLP, Retail

    DWORD                   dwDistChannel;      // Distribution channel: OEM/Retail

    GUID                    KeypackSerialNum;   // CH assigned serial number for this key pack
    
    FILETIME                IssueDate;          // Keypack issue date

    FILETIME                ActiveDate;         // License active date

    FILETIME                ExpireDate;         // License expiration date

    DWORD                   dwBeginSerialNum;   // beginning serial number for the licenses in the keypack

    DWORD                   dwQuantity;         // Number of licenses in the key pack

    DWORD                   cbProductId;        // product ID

    PBYTE                   pbProductId;        // product ID

    DWORD                   dwProductVersion;   // product version

    DWORD                   dwPlatformId;       // platform ID: Windows, Mac, UNIX etc...

    DWORD                   dwLicenseType;      // new, upgrade, competitive upgrade etc...

    DWORD                   dwDescriptionCount; // The number of human language descriptions

    PKeyPack_Description    pDescription;       // pointer to an array of keypack description

    DWORD                   cbManufacturer;     // The number of bytes in the manufacturer string

    PBYTE                   pbManufacturer;     // The manufacturer string

    DWORD                   cbManufacturerData; // The number of bytes in the manufacturer-specific data

    PBYTE                   pbManufacturerData; // Points to the manufacturer specific data
    
} License_KeyPack, * PLicense_KeyPack;


#define LICENSEPACKENCODE_VERSION           LICENSE_KEYPACK_VERSION_1_0
#define LICENSEPACKENCODE_CURRENTVERSION    LICENSEPACKENCODE_VERSION
#define LICENSEPACKENCODE_SIGNATURE         0xF0F0F0F0

typedef struct __EncodedLicenseKeyPack {
    DWORD dwSignature;      // old encoding puts size of encryption key.
    DWORD dwStructVersion;
    DWORD dwEncodeType;
    DWORD cbData;
    BYTE  pbData[1];
} EncodedLicenseKeyPack, *PEncodedLicenseKeyPack;


#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Exported functions
//

DWORD WINAPI 
DecodeLicenseKeyPack(
    PLicense_KeyPack        pLicenseKeyPack,
    HCRYPTPROV              hCryptProv,
    DWORD                   cbClearingHouseCert,
    PBYTE                   pbClearingHouseCert,
    DWORD                   cbRootCertificate,
    PBYTE                   pbRootCertificate,
    DWORD                   cbKeyPackBlob,
    PBYTE                   pbKeyPackBlob );


DWORD WINAPI
DecodeLicenseKeyPackEx(
    OUT PLicense_KeyPack pLicenseKeyPack,
    IN PLicensePackDecodeParm pDecodeParm,
    IN DWORD cbKeyPackBlob,
    IN PBYTE pbKeyPackBlob 
);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\hccontxt.h ===
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       HCContxt.h
//
//  Contents:	Functions that are used to pack and unpack different messages
//
//  Classes:
//
//  Functions:	
//
//  History:    12-22-97  v-sbhatt   Created
//
//----------------------------------------------------------------------------


typedef struct _License_Client_Context
{
    DWORD                   dwProtocolVersion;  // Version of licensing protocol
    DWORD                   dwState;            // State at which the connection is in
    DWORD                   dwContextFlags;
    PCryptSystem            pCryptParam;
    UCHAR                   rgbMACData[LICENSE_MAC_DATA];
    DWORD                   cbLastMessage;
    BYTE FAR *              pbLastMessage;
    PHydra_Server_Cert      pServerCert;        // used only for preamble version older than 3.0
    DWORD                   cbServerPubKey;     // used for preamble version 3.0 and later.
    BYTE FAR *              pbServerPubKey;

}License_Client_Context, *PLicense_Client_Context;


PLicense_Client_Context 
LicenseCreateContext(
    VOID );


LICENSE_STATUS CALL_TYPE 
LicenseDeleteContext(
    HANDLE	 hContext
                     );


LICENSE_STATUS CALL_TYPE
LicenseInitializeContext(
    HANDLE *        phContext,
    DWORD           dwFlags );


LICENSE_STATUS CALL_TYPE
LicenseSetPublicKey(
    HANDLE          hContext,
    DWORD           cbPubKey,
    BYTE FAR *      pbPubKey );


LICENSE_STATUS CALL_TYPE
LicenseSetCertificate(
    HANDLE              hContext,
    PHydra_Server_Cert  pCertificate );


LICENSE_STATUS CALL_TYPE
LicenseAcceptContext(
    HANDLE      hContext,
    UINT32    * puiExtendedErrorInfo,
    BYTE FAR  * pbInput,
    DWORD       cbInput,
    BYTE FAR  * pbOutput,
    DWORD FAR * pcbOutput );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\store.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       context.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-12-97  v-sbhatt   Created
//              12-18-97  v-sbhatt   Modified
//
//----------------------------------------------------------------------------


#ifndef _STORE_H_
#define _STORE_H_

#ifdef CALL_TYPE
#undef CALL_TYPE
#endif	//CALL_TYPE

#ifndef OS_WINCE
#define CALL_TYPE	_stdcall
#else
#define CALL_TYPE
#endif

#ifndef OUT
#define OUT
#endif	//OUT

#ifndef IN
#define IN
#endif	//IN

typedef DWORD LS_STATUS;

#define LSSTAT_SUCCESS					0x00
#define	LSSTAT_ERROR					0x01
#define LSSTAT_INSUFFICIENT_BUFFER		0x02
#define LSSTAT_LICENSE_NOT_FOUND		0x03
#define LSSTAT_OUT_OF_MEMORY			0x04
#define LSSTAT_INVALID_HANDLE			0x05
#define LSSTAT_LICENSE_EXISTS			0x06

//Adding or replacing flags, to be used in LSAddLicenseToStore

#define		LS_REPLACE_LICENSE_OK	0x00000001
#define		LS_REPLACE_LICENSE_ERR	0x00000000


//This is the License Store index structure. Licenses are queried against this index
typedef struct	tagLSINDEX
{
	DWORD		dwVersion;	//Uper two bytes major version and lower two bytes Minor version
	DWORD		cbScope;
	BYTE	FAR *pbScope;	//Scope for the license
	DWORD		cbCompany;
	BYTE	FAR *pbCompany;	//Manufacturer
	DWORD		cbProductID;
	BYTE	FAR *pbProductID;//Product ID of the product for which the License is intended to be
}LSINDEX, FAR * PLSINDEX;

#ifdef OS_WIN32
//Might not be necessay at all!!!!
typedef	LS_STATUS	(*PLSENUMPROC)(
								   IN HANDLE	hLicense,
								   IN PLSINDEX	plsiName,	//License Index Name
								   IN DWORD	dwUIParam	//User Parameter
								   );

#endif	//OS_WIN32

//Open a specified store. If the szStoreName is NULL, it will open default store
//Otherwise it will open the store specified by szStoreName parameter

LS_STATUS
CALL_TYPE
LSOpenLicenseStore(
				 OUT HANDLE			*hStore,	 //The handle of the store
				 IN  LPCTSTR		szStoreName, //Optional store Name
				 IN  BOOL 			fReadOnly    //whether to open read-only
				 );

//Closes an open store
LS_STATUS
CALL_TYPE
LSCloseLicenseStore(
				  IN HANDLE		hStore	//Handle of the store to be closed!
				  );

//Add or updates/replaces license against a given LSINDEX in an open store 
//pointed by hStore
LS_STATUS
CALL_TYPE
LSAddLicenseToStore(
					IN HANDLE		hStore,	//Handle of a open store
					IN DWORD		dwFlags,//Flags either add or replace
					IN PLSINDEX		plsiName,	//Index against which License is added 
					IN BYTE	 FAR   *pbLicenseInfo,	//License info to be added
					IN DWORD		cbLicenseInfo	// size of the License info blob
					);

//Deletes a license from the store refered by hStore and against the given LSINDEX
LS_STATUS
CALL_TYPE
LSDeleteLicenseFromStore(
						 IN HANDLE		hStore,	//Handle of a open store
						 IN PLSINDEX	plsiName	//Index of the license to be deleted
						 );

//Finds a license in an open store against a particular store Index
LS_STATUS
CALL_TYPE
LSFindLicenseInStore(
					 IN HANDLE		hStore,	//Handle of a open store
					 IN	PLSINDEX	plsiName,	//LSIndex against which store is searched
					 IN OUT	DWORD	FAR *pdwLicenseInfoLen,	//Size of the license found
					 OUT	BYTE	FAR *pbLicenseInfo	//License Data
					 );

LS_STATUS
CALL_TYPE
LSEnumLicenses(
			   IN HANDLE		hStore,	//Handle of a open store
			   IN	DWORD		dwIndex, //numeric Index of the license to query
			   OUT	PLSINDEX	plsindex //The LSIndex structure corresponding to dwIndex
			   );

LS_STATUS
CALL_TYPE
LSQueryInfoLicense(
				   IN HANDLE		hStore,	//Handle of a open store
				   OUT	DWORD	FAR *pdwLicenses, //Total no. of licenses available
				   OUT	DWORD	FAR *pdwMaxCompanyNameLen,	//Maximum length of the company length
				   OUT	DWORD	FAR *pdwMaxScopeLen,	//Maximum length of the company length
				   OUT	DWORD	FAR *pdwMaxProductIdLen	//Maximum length of the company length
				   );


LS_STATUS	
CALL_TYPE
LSOpenLicenseHandle(
				   IN HANDLE		hStore,	//Handle of a open store
				   IN  BOOL         fReadOnly,
				   IN  PLSINDEX		plsiName,
				   OUT HANDLE		*phStore	//Handle of a open store
				   );
LS_STATUS
CALL_TYPE
LSCloseLicenseHandle(
					 IN HANDLE		hStore,	//Handle of a open store
					 IN DWORD	dwFlags		//For future Use
					 );

#endif	//_STORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\adcg.h ===
/**INC+**********************************************************************/
/* Header:    adcg.h                                                        */
/*                                                                          */
/* Purpose:   Precompiled header file                                       */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/trc/adcg.h_v  $
// 
//    Rev 1.2   07 Jul 1997 14:56:56   AK
// SFR0000: Initial development completed
**/
/**INC-**********************************************************************/

#include <adcgbase.h>
#include <strsafe.h>
//Redirect win32 'W' calls to wrappers

#ifdef UNIWRAP
#include "uwrap.h"
#endif //UNIWRAP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\tlsapi.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        tlsapi.h
//
// Contents:    
//
// History:     12-09-97    HueiWang    Created
//
//---------------------------------------------------------------------------
#ifndef __TLSAPI_H__
#define __TLSAPI_H__

#include "tlsdef.h"

#ifndef WINAPI
#define WINAPI      __stdcall
#endif

typedef BYTE*   PBYTE;
typedef DWORD*  PDWORD;
typedef PBYTE   LPBYTE;
typedef PDWORD  LPDWORD;
typedef UCHAR*  PUCHAR;

//----------------------------------------------------------------------------------
// IssuedLicense related structure
//
typedef struct __LSLicense {
    DWORD       dwVersion;
    DWORD       dwLicenseId;             // internal tracking number
    DWORD       dwKeyPackId;             // join with License Pack

    TCHAR       szHWID[GUID_MAX_SIZE];
    TCHAR       szMachineName[MAXCOMPUTERNAMELENGTH];
    TCHAR       szUserName[MAXUSERNAMELENGTH];

    DWORD       dwCertSerialLicense;
    DWORD       dwLicenseSerialNumber;
    DWORD       ftIssueDate;
    DWORD       ftExpireDate;
    UCHAR       ucLicenseStatus;
} LSLicense, *LPLSLicense;

typedef LSLicense LSLicenseSearchParm;
typedef LSLicenseSearchParm* LPLSLicenseSearchParm;

typedef struct __LSLicenseEx {
    DWORD       dwVersion;
    DWORD       dwLicenseId;             // internal tracking number
    DWORD       dwKeyPackId;             // join with License Pack

    TCHAR       szHWID[GUID_MAX_SIZE];
    TCHAR       szMachineName[MAXCOMPUTERNAMELENGTH];
    TCHAR       szUserName[MAXUSERNAMELENGTH];

    DWORD       dwCertSerialLicense;
    DWORD       dwLicenseSerialNumber;
    DWORD       ftIssueDate;
    DWORD       ftExpireDate;
    UCHAR       ucLicenseStatus;
    DWORD       dwQuantity;
} LSLicenseEx, *LPLSLicenseEx;

//----------------------------------------------------------------------------------
// Table License Key Pack related structure
//
typedef struct __LSKeyPack {
    DWORD       dwVersion;

    UCHAR       ucKeyPackType;
    
    TCHAR       szCompanyName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR       szKeyPackId[LSERVER_MAX_STRING_SIZE+1];
    TCHAR       szProductName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR       szProductId[LSERVER_MAX_STRING_SIZE+1];
    TCHAR       szProductDesc[LSERVER_MAX_STRING_SIZE+1];

    WORD        wMajorVersion;
    WORD        wMinorVersion;
    DWORD       dwPlatformType;
    UCHAR       ucLicenseType;
    DWORD       dwLanguageId;
    UCHAR       ucChannelOfPurchase;

    TCHAR       szBeginSerialNumber[LSERVER_MAX_STRING_SIZE+1];

    DWORD       dwTotalLicenseInKeyPack;
    DWORD       dwProductFlags;

    DWORD       dwKeyPackId;
    UCHAR       ucKeyPackStatus;
    DWORD       dwActivateDate;
    DWORD       dwExpirationDate;
    DWORD       dwNumberOfLicenses;
} LSKeyPack, *LPLSKeyPack;

typedef LSKeyPack LSKeyPackSearchParm;
typedef LSKeyPackSearchParm* LPLSKeyPackSearchParm;

//---------------------------------------------------------------------------
typedef struct {
    DWORD   dwLow;
    DWORD   dwHigh;
} LSRange, *LPLSRange, *PLSRange;

    
typedef HANDLE                  TLS_HANDLE;
typedef DWORD                   CHALLENGE_CONTEXT;
typedef CHALLENGE_CONTEXT*      PCHALLENGE_CONTEXT;

typedef BOOL (* TLSENUMERATECALLBACK)(TLS_HANDLE hBinding, LPCTSTR pszServer, HANDLE dwUserData);

#ifdef __cplusplus
extern "C" {
#endif

HRESULT FindEnterpriseServer(TLS_HANDLE *phBinding);

HRESULT GetAllEnterpriseServers(WCHAR ***ppszServers, DWORD *pdwCount);

// void *MIDL_user_allocate(DWORD size);
// void MIDL_user_free(void *pointer); 
// void *  __stdcall MIDL_user_allocate(DWORD);
// void  __stdcall MIDL_user_free( void * );

DWORD WINAPI
EnumerateTlsServer(  
    TLSENUMERATECALLBACK fCallBack, 
    HANDLE dwUserData,
    DWORD dwTimeOut,
    BOOL fRegOnly
);

TLS_HANDLE WINAPI
TLSConnectToAnyLsServer(
    DWORD dwTimeout
);

TLS_HANDLE WINAPI 
TLSConnectToLsServer( 
    LPTSTR szLsServer 
);

void WINAPI 
TLSDisconnectFromServer( 
    TLS_HANDLE hHandle 
);

DWORD WINAPI
TLSGetVersion (
    TLS_HANDLE hHandle,
    PDWORD pdwVersion
);

DWORD WINAPI 
TLSSendServerCertificate( 
     TLS_HANDLE hHandle,
     DWORD cbCert,
     PBYTE pbCert,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSGetServerName( 
     TLS_HANDLE hHandle,
     LPTSTR pszMachineName,
     PDWORD pcbSize,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSGetServerScope( 
     TLS_HANDLE hHandle,
     LPTSTR pszScopeName,
     PDWORD pcbSize,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSGetServerScopeFixed( 
     TLS_HANDLE hHandle,
     LPTSTR *pszScopeName,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSGetInfo( 
     TLS_HANDLE hHandle,
     DWORD  cbHSCert,
     PBYTE  pHSCert,
     PDWORD pcbLSCert,
     PBYTE* ppbLSCert,
     DWORD* pcbLSSecretKey,
     PBYTE* ppbLSSecretKey,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSIssuePlatformChallenge( 
     TLS_HANDLE hHandle,
     DWORD dwClientInfo,
     PCHALLENGE_CONTEXT pChallengeContext,
     PDWORD pcbChallengeData,
     PBYTE* pChallengeData,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSIssueNewLicense( 
     TLS_HANDLE hHandle,
     CHALLENGE_CONTEXT ChallengeContext,
     LICENSEREQUEST* pRequest,
     LPTSTR pszMachineName,
     LPTSTR pszUserName,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     BOOL bAcceptTemporaryLicense,
     PDWORD pcbLicense,
     PBYTE* ppbLicense,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSIssueNewLicenseEx( 
     TLS_HANDLE hHandle,
     PDWORD pSupportFlags,
     CHALLENGE_CONTEXT ChallengeContext,
     LICENSEREQUEST  *pRequest,
     LPTSTR pMachineName,
     LPTSTR pUserName,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     BOOL bAcceptTemporaryLicense,
     DWORD dwQuantity,
     PDWORD pcbLicense,
     PBYTE* ppbLicense,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSIssueNewLicenseExEx( 
     TLS_HANDLE hHandle,
     PDWORD pSupportFlags,
     CHALLENGE_CONTEXT ChallengeContext,
     LICENSEREQUEST  *pRequest,
     LPTSTR pMachineName,
     LPTSTR pUserName,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     BOOL bAcceptTemporaryLicense,
     BOOL bAcceptFewerLicenses,
     DWORD *pdwQuantity,
     PDWORD pcbLicense,
     PBYTE* ppbLicense,
     PDWORD pdwErrCode
);

DWORD WINAPI
TLSUpgradeLicense(
     TLS_HANDLE hHandle,
     LICENSEREQUEST* pRequest,
     CHALLENGE_CONTEXT ChallengeContext,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     DWORD cbOldLicense,
     PBYTE pbOldLicense,
     PDWORD pcbNewLicense,
     PBYTE* ppbNewLicense,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSUpgradeLicenseEx( 
     TLS_HANDLE hHandle,
     PDWORD pSupportFlags,
     LICENSEREQUEST *pRequest,
     CHALLENGE_CONTEXT ChallengeContext,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     DWORD cbOldLicense,
     PBYTE pbOldLicense,
     DWORD dwQuantity,
     PDWORD pcbNewLicense,
     PBYTE* ppbNewLicense,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSAllocateConcurrentLicense( 
     TLS_HANDLE hHandle,
     LPTSTR pszHydraServer,
     LICENSEREQUEST* pRequest,
     LONG*  dwQuantity,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSGetLastError( 
     TLS_HANDLE hHandle,
     DWORD cbBufferSize,
     LPTSTR pszBuffer,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSGetLastErrorFixed( 
     TLS_HANDLE hHandle,
     LPTSTR *pszBuffer,
     PDWORD pdwErrCode
     );

DWORD WINAPI 
TLSKeyPackEnumBegin( 
     TLS_HANDLE hHandle,
     DWORD dwSearchParm,
     BOOL bMatchAll,
     LPLSKeyPackSearchParm lpSearchParm,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSKeyPackEnumNext( 
     TLS_HANDLE hHandle,
     LPLSKeyPack lpKeyPack,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSKeyPackEnumEnd( 
     TLS_HANDLE hHandle,
     PDWORD pdwErrCode
);


DWORD WINAPI 
TLSLicenseEnumBegin( 
     TLS_HANDLE hHandle,
     DWORD dwSearchParm,
     BOOL bMatchAll,
     LPLSLicenseSearchParm lpSearchParm,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSLicenseEnumNext( 
     TLS_HANDLE hHandle,
     LPLSLicense lpLicense,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSLicenseEnumNextEx( 
     TLS_HANDLE hHandle,
     LPLSLicenseEx lpLicense,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSLicenseEnumEnd( 
     TLS_HANDLE hHandle,
     PDWORD pdwErrCode
);


DWORD WINAPI 
TLSGetAvailableLicenses( 
     TLS_HANDLE hHandle,
     DWORD dwSearchParm,
     LPLSKeyPack lplsKeyPack,
     LPDWORD lpdwAvail,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSGetRevokeKeyPackList( 
     TLS_HANDLE hHandle,
     PDWORD pcbNumberOfRange,
     LPLSRange* ppRevokeRange,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSGetRevokeLicenseList( 
     TLS_HANDLE hHandle,
     PDWORD pcbNumberOfRange,
     LPLSRange* ppRevokeRange,
     PDWORD pdwErrCode
);

LICENSE_STATUS
TLSGetTSCertificate(
    CERT_TYPE       CertType,
    LPBYTE          *ppbCertificate,
    LPDWORD         pcbCertificate);

LICENSE_STATUS
TLSFreeTSCertificate(
    LPBYTE          pbCertificate);

DWORD WINAPI
TLSInit();

DWORD WINAPI
TLSStartDiscovery();

DWORD WINAPI
TLSStopDiscovery();

void WINAPI
TLSShutdown();

DWORD WINAPI
TLSInDomain(
     BOOL *pfInDomain,
     LPWSTR *szDomain);

DWORD WINAPI
TLSMarkLicense(
    TLS_HANDLE hHandle,
    UCHAR ucFlags,
    DWORD cbLicense,
    PBYTE pLicense,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSCheckLicenseMark(
    TLS_HANDLE hHandle,
    DWORD cbLicense,
    PBYTE pLicense,
    PUCHAR pucFlags,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSGetSupportFlags(
    TLS_HANDLE hHandle,
    DWORD *pdwSupportFlags
);

DWORD WINAPI 
TLSGetServerNameEx( 
     TLS_HANDLE hHandle,
     LPTSTR pszMachineName,
     PDWORD pcbSize,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSGetServerNameFixed( 
     TLS_HANDLE hHandle,
     LPTSTR *pszMachineName,
     PDWORD pdwErrCode
);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\tlsdef.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        tlsdef.h
//
// Contents:    
//
// History:     12-09-97    HueiWang    Created
//
//---------------------------------------------------------------------------
#ifndef __TLSDEF_H__
#define __TLSDEF_H__

//---------------------------------------------------------------------------
// Xenroll specific 
//#define CERTIFICATE_CA_TYPE     1
//#define CERTITICATE_MF_TYPE     2
//#define CERTIFICATE_CH_TYPE     3

//#define CERTIFICATE_LEVEL_ROOT  0


//---------------------------------------------------------------------------
// KeyPack related code
//
#define LSKEYPACKTYPE_UNKNOWN       0x0
#define LSKEYPACKTYPE_RETAIL        0x1
#define LSKEYPACKTYPE_SELECT        0x2
#define LSKEYPACKTYPE_CONCURRENT    0x3
#define LSKEYPACKTYPE_TEMPORARY     0x4
#define LSKEYPACKTYPE_OPEN          0x5
#define LSKEYPACKTYPE_FREE          0x6

#define LSKEYPACKTYPE_FIRST         LSKEYPACKTYPE_UNKNOWN
#define LSKEYPACKTYPE_LAST          LSKEYPACKTYPE_FREE

#define LSKEYPACKSTATUS_UNKNOWN     0x0
#define LSKEYPACKSTATUS_ACTIVE      0x1
#define LSKEYPACKSTATUS_PENDING     0x2
#define LSKEYPACKSTATUS_RETURNED    0x3
#define LSKEYPACKSTATUS_REVOKED     0x4
#define LSKEYPACKSTATUS_TEMPORARY   0x5
#define LSKEYPACKSTATUS_OTHERS      0x6
#define LSKEYPACKSTATUS_ADD_LICENSE 0x7
#define LSKEYPACKSTATUS_REMOVE_LICENSE 0x8
#define LSKEYPACKSTATUS_ADD_DESC    0x9
#define LSKEYPACKSTATUS_REMOVE_DESC 0x10
#define LSKEYPACKSTATUS_FIRST       LSKEYPACKSTATUS_UNKNOWN
#define LSKEYPACKSTATUS_LAST        LSKEYPACKSTATUS_REMOVE_DESC

#define LSKEYPACKLICENSETYPE_UNKNOWN        0x0
#define LSKEYPACKLICENSETYPE_NEW            0x1
#define LSKEYPACKLICENSETYPE_UPGRADE        0x2
#define LSKEYPACKLICENSETYPE_COMPETITIVE    0x3
#define LSKEYPACKLICENSETYPE_TEMPORARY      0x4

#define LSKEYPACKLICENSETYPE_FIRST          LSKEYPACKLICENSETYPE_UNKNOWN
#define LSKEYPACKLICENSETYPE_LAST           LSKEYPACKLICENSETYPE_TEMPORARY

#define LSKEYPACKCHANNELOFPURCHASE_UNKNOWN  0x0      
#define LSKEYPACKCHANNELOFPURCHASE_OEM      0x1
#define LSKEYPACKCHANNELOFPURCHASE_RETAIL   0x2

#define LSKEYPACKCHANNELOFPURCHASE_FIRST    LSKEYPACKCHANNELOFPURCHASE_UNKNOWN
#define LSKEYPACKCHANNELOFPURCHASE_LAST     LSKEYPACKCHANNELOFPURCHASE_RETAIL

#define LSKEYPACKPRODUCTFLAG_UNKNOWN        0x0000

#define LSKEYPACKPLATFORMTYPE_UNKNOWN       0x0000
#define LSKEYPACKPLATFORMTYPE_FREE          0x0002
#define LSKEYPACKPLATFORMTYPE_OTHERS        0x00FF

#define LSLICENSE_STATUS_UNKNOWN            0x0
#define LSLICENSE_STATUS_TEMPORARY          0x1
#define LSLICENSE_STATUS_ACTIVE             0x2
#define LSLICENSE_STATUS_UPGRADED           0x3
#define LSLICENSE_STATUS_REVOKE             0x4
#define LSLICENSE_STATUS_PENDING            0x5
#define LSLICENSE_STATUS_CONCURRENT         0x6

#define LSLICENSE_STATUS_FIRST              LSLICENSE_STATUS_UNKNOWN
#define LSLICENSE_STATUS_LAST               LSLICENSE_STATUS_CONCURRENT

//---------------------------------------------------------------------------
/// Key Pack Search Parameters

// Basic KeyPack Search Parameter
#define LSKEYPACK_SEARCH_INFO_ALL           0x0000FFFF
#define LSKEYPACK_SEARCH_KEYPACKID          0x00000001
#define LSKEYPACK_SEARCH_KEYPACKTYPE        0x00000002
#define LSKEYPACK_SEARCH_PRODUCTID          0x00000004
#define LSKEYPACK_SEARCH_MAJORVERSION       0x00000008
#define LSKEYPACK_SEARCH_MINORVERSION       0x00000010
#define LSKEYPACK_SEARCH_PLATFORMTYPE       0x00000020
#define LSKEYPACK_SEARCH_LICENSETYPE        0x00000040
#define LSKEYPACK_SEARCH_LANGID             0x00000080
#define LSKEYPACK_SEARCH_COP                0x00000100
#define LSKEYPACK_SEARCH_BSERIALNUMBER      0x00000200
#define LSKEYPACK_SEARCH_TOTALLICENSES      0x00000400
#define LSKEYPACK_SEARCH_PRODUCTFLAGS       0x00000800
#define LSKEYPACK_SEARCH_COMPANYNAME        0x00001000
#define LSKEYPACK_SEARCH_PRODUCTNAME        0x00002000
#define LSKEYPACK_SEARCH_PRODUCTDESC        0x00004000
#define LSKEYPACK_SEARCH_DUPLICATE \
    (LSKEYPACK_SEARCH_KEYPACKID | LSKEYPACK_SEARCH_COMPANYNAME | \
     LSKEYPACK_SEARCH_PRODUCTID | LSKEYPACK_SEARCH_MAJORVERSION | \
     LSKEYPACK_SEARCH_MINORVERSION | LSKEYPACK_SEARCH_PLATFORMTYPE)

// Extended KeyPack Search Parameters
#define LSKEYPACK_EXSEARCH_ALL              0xFFFF0000
#define LSKEYPACK_EXSEARCH_DWINTERNAL       0x00010000
#define LSKEYPACK_EXSEARCH_KEYPACKSTATUS    0x00020000
#define LSKEYPACK_EXSEARCH_ACTIVATEDATE     0x00040000
#define LSKEYPACK_EXSEARCH_EXPIREDATE       0x00080000
#define LSKEYPACK_EXSEARCH_AVAILABLE        0x00100000
#define LSKEYPACK_EXSEARCH_ALLVERSION       0x10000000

#define LSKEYPACK_SEARCH_ALL (LSKEYPACK_SEARCH_INFO_ALL | LSKEYPACK_EXSEARCH_ALL)
#define LSKEYPACK_SEARCH_NONE               0x00000000

#define LSKEYPACK_SET_KEYPACKSTATUS         LSKEYPACK_EXSEARCH_KEYPACKSTATUS
#define LSKEYPACK_SET_ACTIVATEDATE          LSKEYPACK_EXSEARCH_ACTIVATEDATE
#define LSKEYPACK_SET_EXPIREDATE            LSKEYPACK_EXSEARCH_EXPIREDATE
#define LSKEYPACK_SET_AVAILABLE             LSKEYPACK_EXSEARCH_AVAILABLE
#define LSKEYPACK_SET_ALLSTATUS             (LSKEYPACK_SET_KEYPACKSTATUS | LSKEYPACK_SET_ACTIVATEDATE | LSKEYPACK_SET_EXPIREDATE)

//-----------------------------------------------------------------------------
// License Search parameters
//
#define LSLICENSE_SEARCH_LICENSEID          0x00000001
#define LSLICENSE_SEARCH_KEYPACKID          0x00000002
#define LSLICENSE_SEARCH_MACHINENAME        0x00000008
#define LSLICENSE_SEARCH_USERNAME           0x00000010
#define LSLICENSE_SEARCH_ISSUEDATE          0x00000080
#define LSLICENSE_SEARCH_EXPIREDATE         0x00000100
#define LSLICENSE_SEARCH_NUMLICENSES        0x00000200
#define LSLICENSE_SEARCH_ENTRY_STATUS       0x20000000
#define LSLICENSE_SEARCH_MARK_FLAGS         LSLICENSE_SEARCH_ENTRY_STATUS
#define LSLICENSE_EXSEARCH_LICENSESTATUS    0x00100000
#define LSLICENSE_SEARCH_ALL \
    (LSLICENSE_SEARCH_LICENSEID | LSLICENSE_SEARCH_KEYPACKID | \
     LSLICENSE_SEARCH_MACHINENAME | \
     LSLICENSE_SEARCH_USERNAME | \
     LSLICENSE_SEARCH_ISSUEDATE | LSLICENSE_SEARCH_NUMLICENSES | \
     LSLICENSE_SEARCH_EXPIREDATE | LSLICENSE_EXSEARCH_LICENSESTATUS | \
     LSLICENSE_SEARCH_ENTRY_STATUS)

#define LSLICENSE_SEARCH_NONE               0x00000000

//-----------------------------------------------------------------------------
// General Define
#define LSERVER_MAX_STRING_SIZE     255
#define GUID_MAX_SIZE               37

#define MAXCOMPUTERNAMELENGTH   32   // from MAX_COMPUTERNAME_LENGTH in winbase.h
#define MAXUSERNAMELENGTH       256  // UNLEN in lmcons.h 

// HueiWang - temporary, need to define this
#define HLS_MAX_SCOPE_NAME_LENGTH   MAX_COMPUTERNAME_LENGTH

//-------------------------------------------------------------
// Hydra License Server Return Code
#define LSERVER_S_SUCCESS               ERROR_SUCCESS
#define LSERVER_SUCCESS_BASE            4000
#define LSERVER_ERROR_BASE              5000

#define LSERVER_I_NO_MORE_DATA            (LSERVER_SUCCESS_BASE + 1)
#define LSERVER_I_PROXIMATE_LICENSE       (LSERVER_SUCCESS_BASE + 2)
#define LSERVER_I_TEMPORARY_LICENSE       (LSERVER_SUCCESS_BASE + 3)
#define LSERVER_I_LICENSE_UPGRADED        (LSERVER_SUCCESS_BASE + 4)
#define LSERVER_I_CERTIFICATE_OVERWRITE   (LSERVER_SUCCESS_BASE + 5)
#define LSERVER_I_REMOVE_TOOMANY          (LSERVER_SUCCESS_BASE + 6)
#define LSERVER_I_SELFSIGN_CERTIFICATE    (LSERVER_SUCCESS_BASE + 7)
#define LSERVER_I_NOT_LSERVER_CERTIFICATE (LSERVER_SUCCESS_BASE + 8)
#define LSERVER_I_TEMP_SELFSIGN_CERT      (LSERVER_SUCCESS_BASE + 9)
#define LSERVER_I_SERVICE_SHUTDOWN        (LSERVER_SUCCESS_BASE + 10)

#define LSERVER_E_INTERNAL_ERROR        (LSERVER_ERROR_BASE + 1)
#define LSERVER_E_ERROR_GENERAL         (LSERVER_ERROR_BASE + 2)
#define LSERVER_E_ACCESS_DENIED         (LSERVER_ERROR_BASE + 3)
#define LSERVER_E_DUPLICATE             (LSERVER_ERROR_BASE + 4)
#define LSERVER_E_INVALID_HANDLE        (LSERVER_ERROR_BASE + 5)
#define LSERVER_E_INVALID_SEQUENCE      (LSERVER_ERROR_BASE + 6)
#define LSERVER_E_SERVER_BUSY           (LSERVER_ERROR_BASE + 7)
#define LSERVER_E_OUTOFMEMORY           (LSERVER_ERROR_BASE + 8)
#define LSERVER_E_INVALID_DATA          (LSERVER_ERROR_BASE + 9)
#define LSERVER_E_DATANOTFOUND          (LSERVER_ERROR_BASE + 10)
#define LSERVER_E_NO_LICENSE            (LSERVER_ERROR_BASE + 11)
#define LSERVER_E_NO_PRODUCT            (LSERVER_ERROR_BASE + 12)
#define LSERVER_E_LICENSE_REJECTED      (LSERVER_ERROR_BASE + 13)
#define LSERVER_E_LICENSE_REVOKED       (LSERVER_ERROR_BASE + 14)
#define LSERVER_E_LICENSE_EXPIRED       (LSERVER_ERROR_BASE + 15)
#define LSERVER_E_CORRUPT_DATABASE      (LSERVER_ERROR_BASE + 16)
#define LSERVER_E_NOTSUPPORTED          (LSERVER_ERROR_BASE + 17)
#define LSERVER_E_INVALID_NT_VERSION    (LSERVER_ERROR_BASE + 18)
#define LSERVER_E_NOT_NTSERVER          (LSERVER_ERROR_BASE + 19)
#define LSERVER_E_LS_NOTPRESENT         (LSERVER_ERROR_BASE + 20)
#define LSERVER_E_LS_NOTRUNNING         (LSERVER_ERROR_BASE + 21)
#define LSERVER_E_NO_CERTIFICATE        (LSERVER_ERROR_BASE + 22)
#define LSERVER_E_NOT_LSCERTIFICATE     (LSERVER_ERROR_BASE + 23)
#define LSERVER_E_POLICYMODULEERROR     (LSERVER_ERROR_BASE + 24)   // error in policy module return data
#define LSERVER_E_INVALID_RETURN        (LSERVER_ERROR_BASE + 25)
#define LSERVER_E_INCOMPATIBLE          (LSERVER_ERROR_BASE + 26)
#define LSERVER_E_INVALID_SPK           (LSERVER_ERROR_BASE + 27)
#define LSERVER_E_INVALID_LKP           (LSERVER_ERROR_BASE + 28)
#define LSERVER_E_INVALID_SIGN          (LSERVER_ERROR_BASE + 29)
#define LSERVER_E_POLICYDENYREQUEST     (LSERVER_ERROR_BASE + 30)
#define LSERVER_E_NOPOLICYMODULE        (LSERVER_ERROR_BASE + 31)
#define ISPOLICYMODULECODE(x) (0x08000000 & x)

#define LSERVER_E_LASTERROR              LSERVER_E_NOPOLICYMODULE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\wincelic.h ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    wincelic.h

Abstract:


Author:

    Fred Chong (FredCh) 7/1/1998

Environment:

Notes:

--*/

#include <dbgapi.h>
#define assert(x) ASSERT(x)

#define MAX_COMPUTERNAME_LENGTH 15

#ifdef HARDCODED_USER_NAME

#define WBT_USER_NAME "Windows Term"
#define WBT_USER_NAME_LEN   (sizeof(WBT_USER_NAME))

#else

#include <winsock.h>
#include <license.h>
#include <cryptkey.h>

// Two hex characters for each byte, plus null terminator

#define HWID_STR_LEN (sizeof(HWID) * 2 + 1)

#define BAD_HARDCODED_NAME1 "WBT"
#define BAD_HARDCODED_NAME2 "WinCE"

#endif

static BOOL GetUserName(
  LPSTR lpBuffer,  // address of name buffer
  LPDWORD nSize     // address of size of name buffer
)
{

#ifdef HARDCODED_USER_NAME
    if (*nSize < WBT_USER_NAME_LEN) {
        *nSize = WBT_USER_NAME_LEN;
        return FALSE;
    }

    *nSize = WBT_USER_NAME_LEN;
    strcpy(lpBuffer, WBT_USER_NAME);

    return TRUE;

#else

    CHAR achHostName[MAX_PATH+1];
    BOOL fReturn = FALSE;
    HWID hwid;
    DWORD cchName;

    // get the host name of the device
    if (0 == gethostname( achHostName, sizeof(achHostName) ))
    {
        // Check for bad hardcoded values
        if ((0 == strcmp(achHostName,BAD_HARDCODED_NAME1))
            || (0 == strcmp(achHostName,BAD_HARDCODED_NAME2)))
        {
            goto use_uuid;
        }

        // gethostname success

        cchName = strlen(achHostName);

        if (*nSize <= cchName)
        {
            *nSize = (cchName + 1);
            return FALSE;
        }

        strcpy(lpBuffer,achHostName);
        return TRUE;
    }
    
use_uuid:

    // Can't get hostname

    if (*nSize >= HWID_STR_LEN)
    {
        // Use UUID instead

        if (LICENSE_STATUS_OK == GenerateClientHWID(&hwid))
        {
            
            sprintf(lpBuffer,
                    "%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x",
                    (hwid.dwPlatformID & 0xFF000000) >> 24,
                    (hwid.dwPlatformID & 0x00FF0000) >> 16,
                    (hwid.dwPlatformID & 0x0000FF00) >> 8,
                     hwid.dwPlatformID & 0x000000FF,
                    (hwid.Data1 & 0xFF000000) >> 24,
                    (hwid.Data1 & 0x00FF0000) >> 16,
                    (hwid.Data1 & 0x0000FF00) >> 8,
                     hwid.Data1 & 0x000000FF,
                    (hwid.Data2 & 0xFF000000) >> 24,
                    (hwid.Data2 & 0x00FF0000) >> 16,
                    (hwid.Data2 & 0x0000FF00) >> 8,
                     hwid.Data2 & 0x000000FF,
                    (hwid.Data3 & 0xFF000000) >> 24,
                    (hwid.Data3 & 0x00FF0000) >> 16,
                    (hwid.Data3 & 0x0000FF00) >> 8,
                     hwid.Data3 & 0x000000FF,
                    (hwid.Data4 & 0xFF000000) >> 24,
                    (hwid.Data4 & 0x00FF0000) >> 16,
                    (hwid.Data4 & 0x0000FF00) >> 8,
                     hwid.Data4 & 0x000000FF
                     );

            fReturn = TRUE;
        }
    }

    *nSize = HWID_STR_LEN;

    return fReturn;

#endif

}

#define GetComputerName GetUserName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\memcheck.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    memcheck

Abstract:

    This header file provides access to the memory allocation debugging
    utilities.

Author:

    Doug Barlow (dbarlow) 9/29/1995

Environment:

    Win32

Notes:

--*/

#ifndef _MEMCHECK_H_
#define _MEMCHECK_H_

#if DBG


#if ((!defined (OS_WINCE)) || (_WIN32_WCE > 300))
#ifdef __cplusplus
#include <iostream.h>                   //  Just in case it's not anywhere else.
extern "C" {
#else   // __cplusplus
#include <stdio.h>                      //  Just in case it's not anywhere else.
#endif  //  __cplusplus

#else
#include <stdio.h>
#endif



//-----------------------------------------------------------------------------
//
// Function prototype
//
//-----------------------------------------------------------------------------

extern BOOL
    debugGbl;                           //  Whether or not to print breakpoint status.

extern void
Breakpoint(                             //  A convienient spot for a breakpoint.
    void);

extern LPVOID
AllocateMemory(                         //  Memory manipulation routines.
    DWORD bytes,
    LPCTSTR allocator);

extern LPVOID
ReallocateMemory(
    LPVOID mem,
    DWORD bytes);

extern LPVOID
FreeMemory(
    LPVOID mem);

LPCTSTR
typeMemory(                             //  Show the reason for allocation.
    LPVOID mem);

extern void
DisplayMemory(                          //  Report statistics on allocated memory.
    void);

BOOL
ValidateMemory(                         // Check out the allocations
    void);

#if ((!defined (OS_WINCE)) || (_WIN32_WCE > 300))
#ifdef __cplusplus
}

#ifdef _MSVC
extern void
SetReason(
    LPCTSTR szWhy);

extern void *
::operator new(
    size_t size);

extern void
::operator delete(
    void *obj);
#endif

#endif __cplusplus
#endif
#else   //  _DEBUG
#ifdef __cplusplus
extern "C" {
#endif  //  __cplusplus

extern LPVOID
AllocateMemory(
    DWORD bytes);

extern LPVOID
ReallocateMemory(
    LPVOID mem,
    DWORD bytes);

extern LPVOID
FreeMemory(
    LPVOID mem);

#ifdef __cplusplus
    }
#endif  // __cplusplus
#endif  //  _DEBUG


#ifdef TRACE
#undef TRACE                            //  Get rid of any conflicting definitions.
#endif
#ifdef ASSERT
#undef ASSERT
#endif

#if defined(_DEBUG) && defined (_MSVC)

#define breakpoint Breakpoint()
#ifdef __cplusplus
#define TRACE(aMessage) cout << aMessage << endl;
#define ASSERT(aTruism) if (!(aTruism)) { \
    TRACE("Assertion failed:\n  " << #aTruism << "\n  module " << __FILE__ << "  line " << __LINE__) \
    breakpoint; }
#define NEWReason(x) SetReason(x);
#define DECLARE_NEW \
    void *operator new(size_t size); \
    void operator delete(void *obj);
#define IMPLEMENT_NEW(cls) \
    void * cls::operator new(size_t size) { \
        return (cls *)AllocateMemory(size, #cls " Object"); } \
    void cls::operator delete(void *obj) { \
        FreeMemory(obj); }
#define IMPLEMENT_INLINE_NEW(cls) \
    inline void * cls::operator new(size_t size) { \
        return (cls *)AllocateMemory(size, #cls " Object"); } \
    inline void cls::operator delete(void *obj) { \
        FreeMemory(obj); }
#else
#define TRACE(aMessage) (void)printf aMessage, fflush(stdout);
#define ASSERT(aTruism) if (!(aTruism)) { \
    TRACE(("Assertion failed:\n  %s\n  module %s, line %d\n", #aTruism, __FILE__, __LINE__)) \
    breakpoint; }
#endif
#define allocateMemory(aLocation, aType, aSize, aReason) \
    aLocation = (aType)AllocateMemory(aSize, aReason)
#define reallocateMemory(aLocation, aType, aSize) \
    aLocation = (aType)ReallocateMemory(aLocation, aSize)
#define freeMemory(aLocation, aType) \
    aLocation = (aType)FreeMemory(aLocation)
#define displayMemory DisplayMemory()

#else

#define breakpoint
#define TRACE(aMessage)
#define ASSERT(aTruism)
#ifdef __cplusplus
#define NEWReason(x)
#define DECLARE_NEW
#define IMPLEMENT_NEW(cls)
#endif

#define allocateMemory(aLocation, aType, aSize, aReason) \
    aLocation = (aType)GlobalAlloc(GMEM_FIXED, aSize)
#define reallocateMemory(aLocation, aType, aSize) \
    aLocation = (aType)GlobalReAlloc(aLocation, aSize, 0)
#define freeMemory(aLocation, aType) \
    aLocation = (aType)GlobalFree(aLocation)

#define displayMemory

#endif  //  _DEBUG

#endif  // _MEMCHECK_H_
// End memcheck.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\license\inc\tlspol.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        tlspol.h
//
// Contents:    
//
// History:     08-26-98    HueiWang    Created
//
//---------------------------------------------------------------------------
#ifndef __TLSPOLICY_H__
#define __TLSPOLICY_H__
#include "tlsapi.h"

#ifndef WINAPI
#define WINAPI      __stdcall
#endif


//
// Return Code from Policy Module
//
typedef enum {
    POLICY_SUCCESS = 0,                 // Success in processing request.
    POLICY_ERROR,                       // Fail to process request.
    POLICY_NOT_SUPPORTED,               // Unsupported function.
    POLICY_CRITICAL_ERROR               // Critical error.
} POLICYSTATUS;

typedef HANDLE PMHANDLE;

//
// Request progress type
//
#define REQUEST_UPGRADE         1
#define REQUEST_NEW             2
#define REQUEST_KEYPACKTYPE     3
#define REQUEST_TEMPORARY       4
#define REQUEST_KEYPACKDESC     5
#define REQUEST_GENLICENSE      6
#define REQUEST_COMPLETE        7

//
// License Return Code
//
#define LICENSE_RETURN_ERROR        0       // Can't decide what to do
#define LICENSE_RETURN_DELETE       1       // delete the old license and return license to license pack
#define LICENSE_RETURN_KEEP         2       // keep the old license.

//
// Client request license type.
//
#define LICENSETYPE_LICENSE         1       // normal license type
#define LICENSETYPE_CONCURRENT      2       // concurrent license


//
// Keypack Registration.
//
#define REGISTER_PROGRESS_NEW                   1
#define REGISTER_PROGRESS_END                   2

typedef struct __PMREGISTERLKPDESC {
    LCID   Locale;                         // Description locale
    TCHAR  szProductName[LSERVER_MAX_STRING_SIZE+1];  // Product Name
    TCHAR  szProductDesc[LSERVER_MAX_STRING_SIZE+1];  // Product Desc.
} PMREGISTERLKPDESC, *PPMREGISTERLKPDESC, *LPPMREGISTERLKPDESC;

typedef enum {
    REGISTER_SOURCE_INTERNET = 1,           // Internet registration
    REGISTER_SOURCE_PHONE,                  // Phone registration
    REGISTER_SOURCE_DISK                    // Disk registration
} LICENSEPACKREGISTERSOURCE_TYPE;

typedef struct __PMREGISTERLICENSEPACK {
    LICENSEPACKREGISTERSOURCE_TYPE SourceType;  // type of registration source

    DWORD   dwKeyPackType;                  // Type of keypack
    DWORD   dwDistChannel;                  // distribution channel
    FILETIME IssueDate;                     // Issue Date
    FILETIME ActiveDate;                    // Active Date
    FILETIME ExpireDate;                    // Expiration Date
    DWORD   dwBeginSerialNum;               // Begin license serial number
    DWORD   dwQuantity;                     // Quantity of Licenses in KeyPack
    TCHAR   szProductId[LSERVER_MAX_STRING_SIZE+1]; // Product Code
    TCHAR   szCompanyName[LSERVER_MAX_STRING_SIZE+1]; // Company Name
    DWORD   dwProductVersion;               // Product Version
    DWORD   dwPlatformId;                   // Platform ID
    DWORD   dwLicenseType;                  // License Type
    DWORD   dwDescriptionCount;             // Number of Product Description 
    PPMREGISTERLKPDESC pDescription;          // Array of product description

    // KeyPackSerialNum is set only on internet
    GUID    KeypackSerialNum;               // KeyPack serial number

    // pbLKP is only set on PHONE
    PBYTE   pbLKP;                        
    DWORD   cbLKP;
} PMREGISTERLICENSEPACK, *PPMREGISTERLICENSEPACK, *LPPMREGISTERLICENSEPACK;

typedef struct __PMLSKEYPACK {
    FILETIME    IssueDate;
    FILETIME    ActiveDate;
    FILETIME    ExpireDate;
    LSKeyPack   keypack;
    DWORD       dwDescriptionCount;
    PPMREGISTERLKPDESC pDescription;
} PMLSKEYPACK, *PPMLSKEYPACK, *LPPMLSKEYPACK;

typedef struct __PMLICENSEREQUEST {
    DWORD dwLicenseType;    // License Type defined in tlsdef.h
    DWORD dwProductVersion;  // request product version.
    LPTSTR pszProductId;    // product product id.
    LPTSTR pszCompanyName;  // product company name.
    DWORD dwLanguageId;      // unused.
    DWORD dwPlatformId;     // request platform type.
    LPTSTR pszMachineName;  // client machine name.
    LPTSTR pszUserName;     // client user name.
    BOOL fTemporary;        // Whether the issued license must be temporary (can't be permanent)
    DWORD dwSupportFlags;   // Which new features are supported by TS
} PMLICENSEREQUEST, *PPMLICENSEREQUEST, *LPPMLICENSEREQUEST;

typedef struct __PMGENERATELICENSE {
    PPMLICENSEREQUEST pLicenseRequest; // return from REQUEST_NEW
    DWORD dwKeyPackType;          // License Pack Type
    DWORD dwKeyPackId;            // License Pack Id that license is allocated from
    DWORD dwKeyPackLicenseId;	    // License ID in the keypack.
    ULARGE_INTEGER ClientLicenseSerialNumber;  // License Serial Number.
    FILETIME ftNotBefore;
    FILETIME ftNotAfter;
} PMGENERATELICENSE, *PPMGENERATELICENSE, *LPPMGENERATELICENSE;

typedef struct __PMCERTEXTENSION {
    DWORD cbData;  // policy specific extension data
    PBYTE pbData;  // size of extension data
    FILETIME ftNotBefore; // license validity period
    FILETIME ftNotAfter;
} PMCERTEXTENSION, *PPMCERTEXTENSION, *LPPMCERTEXTENSION;

typedef struct __PMLICENSEDPRODUCT {
    PMLICENSEREQUEST LicensedProduct;    // licensed product
    PBYTE  pbData;      // policy specific extension data
    DWORD  cbData;      // size of extension data
    BOOL bTemporary;    // temporary license
    UCHAR ucMarked;     // mark flags, including whether user was authenticated
} PMLICENSEDPRODUCT, *PPMLICENSEDPRODUCT, *LPPMLICENSEDPRODUCT;

typedef struct __PMUPGRADEREQUEST {
    PBYTE pbOldLicense;
    DWORD cbOldLicense;
    DWORD dwNumProduct;                 // number of licensed product 
                                        //      contained in the client license
    PPMLICENSEDPRODUCT pProduct;        // array of licensed product in the client license
    PPMLICENSEREQUEST pUpgradeRequest;  // new license upgrade request
} PMUPGRADEREQUEST, *PPMUPGRADEREQUEST, *LPPMUPGRADEREQUEST;

typedef struct __PMKEYPACKDESCREQ {
    LPTSTR pszProductId;
    DWORD dwLangId;
    DWORD dwVersion;
} PMKEYPACKDESCREQ, *PPMKEYPACKDESCREQ, *LPPMKEYPACKDESCREQ;
 
typedef struct __PMKEYPACKDESC {
    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szProductName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szProductDesc[LSERVER_MAX_STRING_SIZE+1];
} PMKEYPACKDESC, *PPMKEYPACKDESC, *LPPMKEYPACKDESC;

typedef struct __PMSupportedProduct {
    TCHAR szCHSetupCode[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szTLSProductCode[LSERVER_MAX_STRING_SIZE+1];
} PMSUPPORTEDPRODUCT, *PPMSUPPORTEDPRODUCT, *LPPMSUPPORTEDPRODUCT;

typedef struct __PMLICENSETOBERETURN {
    DWORD dwQuantity;
    DWORD dwProductVersion;
    LPTSTR pszOrgProductId;
    LPTSTR pszCompanyName;
    LPTSTR pszProductId;
    LPTSTR pszUserName;
    LPTSTR pszMachineName;
    DWORD dwPlatformID;
    BOOL bTemp;
} PMLICENSETOBERETURN, *PPMLICENSETOBERETURN, *LPPMLICENSETOBERETURN;

#ifdef __cplusplus
class SE_Exception 
{
private:
    unsigned int nSE;
public:
    SE_Exception() {}
    SE_Exception(unsigned int n) : nSE(n) {}
    ~SE_Exception() {}

    //-------------------------------
    unsigned int 
    getSeNumber() 
    { 
        return nSE; 
    }
};
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Following API must be exported by policy module
//

POLICYSTATUS WINAPI
PMReturnLicense(
    PMHANDLE hClient,
    ULARGE_INTEGER* pLicenseSerialNumber,
    PPMLICENSETOBERETURN pLicenseTobeReturn,
    PDWORD pdwLicenseStatus,
    PDWORD pdwPolicyErrCode
);


POLICYSTATUS WINAPI
PMLicenseUpgrade(
    PMHANDLE hClient,
    DWORD dwProgressCode,
    PVOID pbProgressData,
    PVOID *ppbReturnData,
    PDWORD pdwPolicyErrCode,
    DWORD dwIndex
);

POLICYSTATUS WINAPI
PMLicenseRequest(
    PMHANDLE client,
    DWORD dwProgressCode, 
    PVOID pbProgressData, 
    PVOID* pbNewProgressData,
    PDWORD pdwPolicyErrCode
);

void WINAPI
PMTerminate();

POLICYSTATUS WINAPI
PMInitialize(
    DWORD dwLicenseServerVersion,    // HIWORD is major, LOWORD is minor
    LPCTSTR pszCompanyName,
    LPCTSTR pszProductFamilyCode,
    PDWORD pdwNumProduct,
    PMSUPPORTEDPRODUCT** ppszSupportedProduct,
    PDWORD pdwPolicyErrCode
);

POLICYSTATUS WINAPI
PMInitializeProduct(
    LPCTSTR pszCompanyName,
    LPCTSTR pszCHProductCode,
    LPCTSTR pszTLSProductCode,
    PDWORD pdwPolicyErrCode
);

POLICYSTATUS WINAPI
PMUnloadProduct(
    LPCTSTR pszCompanyName,
    LPCTSTR pszCHProductCode,
    LPCTSTR pszTLSProductCode,
    PDWORD pdwPolicyErrCode
);

POLICYSTATUS WINAPI
PMRegisterLicensePack(
    PMHANDLE client,
    DWORD dwProgressCode, 
    PVOID pbProgressData, 
    PVOID pbNewProgressData,
    PDWORD pdwPolicyErrCode
);    


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\trc.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    trc.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Sep. 5th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

DLLDEF=..\trc.def
DLLENTRY = _DllMainCRTStartup

#
# List of sources
#

CLIENT_SOURCES_RC = \
    ..\wtrc.rc

CLIENT_SOURCES_COMMON = \
    ..\atrcapi.c  \
    ..\atrcdata.c \
    ..\atrcint.c  \
    ..\wtrcapi.c

CLIENT_SOURCES_LAST = \
    ..\wtrcint.c

SOURCES = \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_RC) \
    $(CLIENT_SOURCES_LAST)

#
# Precompiled specs
#

PRECOMPILED_INCLUDE = ..\adcg.h
PRECOMPILED_PCH = adcg.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\ntrcdata.c ===
/**MOD+**********************************************************************/
/* Module:    ntrcdata.c                                                    */
/*                                                                          */
/* Purpose:   Internal tracing data - Windows NT specific                   */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 *  $Log:   Y:/logs/trc/ntrcdata.c_v  $
 *
 *    Rev 1.2   03 Jul 1997 13:28:22   AK
 * SFR0000: Initial development completed
 *
 *    Rev 1.1   20 Jun 1997 10:40:38   KH
 * Win16Port: Contains 32 bit specifics only
**/
/**MOD-**********************************************************************/

/****************************************************************************/
/* The following data is only required for the Win32 tracing.               */
/****************************************************************************/
#ifdef DLL_DISP

/****************************************************************************/
/* The following data is required for the NT kernel tracing.                */
/****************************************************************************/
DC_DATA(DCUINT32,        trcLinesLost,     0);

DC_DATA(DCUINT32,        trcStorageUsed,   0);

DC_DATA_NULL(TRC_SHARED_DATA, trcSharedData,    {0});

#else

/****************************************************************************/
/* For Windows CE, do not use shared memory for trace configuration data    */
/****************************************************************************/
#ifdef OS_WINCE
DC_DATA_NULL(TRC_SHARED_DATA, trcSharedData,    {0});
#endif

/****************************************************************************/
/* Handle to the trace DLL shared data.                                     */
/****************************************************************************/
DC_DATA(HANDLE,             trchSharedDataObject,    0);

/****************************************************************************/
/* Trace file handle array.                                                 */
/****************************************************************************/
DC_DATA_ARRAY_NULL(HANDLE,  trchFileObjects,    TRC_NUM_FILES, DC_STRUCT1(0));
DC_DATA_ARRAY_NULL(HANDLE,  trchMappingObjects, TRC_NUM_FILES, DC_STRUCT1(0));

/****************************************************************************/
/* Trace DLL module handle.                                                 */
/****************************************************************************/
DC_DATA(HANDLE, trchModule, 0);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\atrcint.c ===
/****************************************************************************/
/* atrcint.c                                                                */
/*                                                                          */
/* Internal trace functions                                                 */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1998                             */
/****************************************************************************/

#include <adcg.h>
/****************************************************************************/
/* Define TRC_FILE and TRC_GROUP.                                           */
/****************************************************************************/
#define TRC_FILE    "atrcint"
#define TRC_GROUP   TRC_GROUP_TRACE

/****************************************************************************/
/* Common and trace specific includes.                                      */
/****************************************************************************/
#include <atrcapi.h>
#include <atrcint.h>

/****************************************************************************/
/*                                                                          */
/* DATA                                                                     */
/*                                                                          */
/****************************************************************************/
#define DC_INCLUDE_DATA
#include <atrcdata.c>
#undef DC_INCLUDE_DATA

/****************************************************************************/
/*                                                                          */
/* FUNCTIONS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* FUNCTION: TRCCheckState(...)                                             */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function checks the current internal trace state.  It does the      */
/* following depending on the trace state:                                  */
/*                                                                          */
/* TRC_STATE_UNINITIALIZED : calls TRC_Initialize to initialize trace.  If  */
/*                           this succeeds it returns TRUE.                 */
/* TRC_STATE_INITIALIZED   : returns TRUE.                                  */
/* TRC_STATE_TERMINATED    : returns FALSE.                                 */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* See above.                                                               */
/*                                                                          */
/****************************************************************************/
DCBOOL32 DCINTERNAL TRCCheckState(DCVOID)
{
    DCBOOL32 rc              = FALSE;

    /************************************************************************/
    /* Now switch on the current trace state.                               */
    /************************************************************************/
    switch (trcState)
    {
        case TRC_STATE_UNINITIALIZED:
        {
            /****************************************************************/
            /* Trace is uninitialized so attempt to initialize it.          */
            /****************************************************************/
            rc = (0 == TRC_Initialize(FALSE));
        }
        break;

        case TRC_STATE_INITIALIZED:
        {
            /****************************************************************/
            /* Trace is initialized and tracing is permitted in this state  */
            /* so return TRUE.                                              */
            /****************************************************************/
            rc = TRUE;
        }
        break;

        case TRC_STATE_TERMINATED:
        {
            /****************************************************************/
            /* Trace has been terminated.  Tracing is no longer permitted   */
            /* so return FALSE.                                             */
            /****************************************************************/
            rc = FALSE;
        }
        break;

        default:
        {
            TRCDebugOutput(_T("Unknown trace state!\n"));
        }
        break;
    }

    return(rc);

} /* TRCCheckState */


/****************************************************************************/
/* FUNCTION: TRCDumpLine(...)                                               */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function takes a block of data and formats it into a string         */
/* containing raw hex plus ASCII equivalent data.                           */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* buffer        : the buffer to trace.                                     */
/* length        : the length.                                              */
/* offset        : the offset of the buffer.                                */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCDumpLine(PDCUINT8 buffer,
                              DCUINT   length,
                              DCUINT32 offset,
                              DCUINT   traceLevel)
{
    DCUINT   i, limDataSize;
    DCUINT   pos;
    TRC_LINE traceLine;
    HRESULT hr;

    /************************************************************************/
    /* Write the offset into the start of the TRC_LINE structure.           */
    /************************************************************************/
    hr = StringCchPrintf(traceLine.address,
                         SIZE_TCHARS(traceLine.address),
                         _T("    %05X "), offset);
    if (FAILED(hr)) {
        DC_QUIT;
    }

    /************************************************************************/
    /* Format the binary portion of the data.  First of all blank out the   */
    /* hexData portion of the TRC_LINE structure.                           */
    /************************************************************************/
    limDataSize = sizeof(traceLine.hexData) / sizeof(traceLine.hexData[0]);
    for (i = 0; i < limDataSize; i++) 
    {
        traceLine.hexData[i] = _T(' ');
    }

    /************************************************************************/
    /* Now write the data into the hexData block.  <pos> stores the current */
    /* position in the output buffer (which is an array of 36 characters).  */
    /* On each loop through we write two characters into the array (which   */
    /* represent one byte) and so we increment <pos> by 2 each time.        */
    /* However at the end of a block of eight characters we add an extra    */
    /* blank - thus we need to increment <pos> again.                       */
    /************************************************************************/
    pos = 0;
    for (i = 0; i < length; i++)
    {
        hr = StringCchPrintf(&(traceLine.hexData[pos]),
                             3, //we write 2 characters at most (+1 for null)
                             _T("%02X"),
                             (DCUINT8)*(buffer+i));
        if (FAILED(hr)) {
            DC_QUIT;
        }


        /********************************************************************/
        /* Increment character position by 2.                               */
        /********************************************************************/
        pos += 2;

        /********************************************************************/
        /* If this is the end of a group of four characters then add a      */
        /* spacing character.  We need to overwrite the terminating NULL    */
        /* written by DC_TSPRINTF.                                          */
        /********************************************************************/
        traceLine.hexData[pos] = _T(' ');
        if (0 == ((i + 1) % 4))
        {
            pos++;
        }
    }

    /************************************************************************/
    /* Copy in the binary data for display in ascii form. First of all      */ 
    /* blank out the asciiData portion of the TRC_LINE structure.           */
    /************************************************************************/
    limDataSize = sizeof(traceLine.asciiData) / sizeof(traceLine.asciiData[0]);
    for (i = 0; i < limDataSize; i++) 
    {
        traceLine.asciiData[i] = _T(' ');
    }
#ifdef UNICODE
    for (i = 0; i < length; i++)
    {
        traceLine.asciiData[i] = buffer[i];
    }
#else
    DC_MEMCPY(traceLine.asciiData, buffer, length);
#endif

    /************************************************************************/
    /* Now translate non-printable characters to '.'.                       */
    /************************************************************************/
    for (i = 0; i < length; i++)
    {
        if ((traceLine.asciiData[i] < 0x20) ||
            (traceLine.asciiData[i] > 0x7E))
        {
            traceLine.asciiData[i] = _T('.');
        }
    }

    /************************************************************************/
    /* Add the terminating newline.                                         */
    /************************************************************************/
    DC_MEMSET(traceLine.end, '\0', sizeof(traceLine.end));
    StringCchCopy(traceLine.end, SIZE_TCHARS(traceLine.end), TRC_CRLF);

    /************************************************************************/
    /* Finally trace this buffer out.                                       */
    /************************************************************************/
    TRCOutput((PDCTCHAR)&traceLine,
              DC_TSTRLEN((PDCTCHAR)&traceLine) * sizeof(DCTCHAR),
              traceLevel);

DC_EXIT_POINT:

    return;
} /* TRCDumpLine */


/****************************************************************************/
/* FUNCTION: TRCReadFlag(...)                                               */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function reads a flag setting from the configuration data.          */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* entryName     : the profile entry name.                                  */
/* flag          : the flag to set or clear.                                */
/* pSetting      : a pointer to the variable containing the flag.           */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCReadFlag(PDCTCHAR  entryName,
                              DCUINT32  flag,
                              PDCUINT32 pSetting)
{
    DCUINT   rc = 0;
    DCUINT32 entryValue;

    /************************************************************************/
    /* Test the flag and set entryValue to a boolean, rather than the       */
    /* entire flag array.                                                   */
    /************************************************************************/
    entryValue = (TEST_FLAG(*pSetting, flag) ? 1UL : 0UL);

    /************************************************************************/
    /* Call <TRCReadProfInt> to get the setting of an integer.              */
    /************************************************************************/
    rc = TRCReadProfInt(entryName, &entryValue);

    /************************************************************************/
    /* Check the return code - if it is non-zero then just leave this       */
    /* flag at its default setting.                                         */
    /************************************************************************/
    if (0 != rc)
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* Now set or clear the flag depending on <value>.                      */
    /************************************************************************/
    if (0UL == entryValue)
    {
        CLEAR_FLAG(*pSetting, flag);
    }
    else
    {
        SET_FLAG(*pSetting, flag);
    }

DC_EXIT_POINT:
    return;

} /* TRCReadFlag */


/****************************************************************************/
/* FUNCTION: TRCSetDefaults(...)                                            */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function sets the trace defaults.                                   */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCSetDefaults(DCVOID)
{
    /************************************************************************/
    /* Set the default values for the trace configuration.  The subsequent  */
    /* calls to TRCReadProfInt will only modify the default value if the    */
    /* appropriate entry exists in the configuration data.                  */
    /*                                                                      */
    /* We set the following things:                                         */
    /*                                                                      */
    /* - trace level to Alert.                                              */
    /* - enable all component groups.                                       */
    /* - remove all prefixes.                                               */
    /* - set the maximum trace file size to the default value.              */
    /* - set the data truncation size to the default value.                 */
    /* - set the function name size to the default value.                   */
    /* - enable the beep and file flags.                                    */
    /* - set the first trace file name to TRC1.TXT                          */
    /* - set the second trace file name to TRC2.TXT                         */
    /* In Win32, additionally                                               */
    /* - set time stamp                                                     */
    /* - set process ID                                                     */
    /* - set thread ID                                                      */
    /*                                                                      */
    /************************************************************************/
    trcpConfig->traceLevel                 = TRC_DEFAULT_TRACE_LEVEL;
    trcpConfig->components                 = TRC_DEFAULT_COMPONENTS;
    trcpConfig->prefixList[0]              = TRC_DEFAULT_PREFIX_LIST;
    trcpConfig->maxFileSize                = TRC_DEFAULT_MAX_FILE_SIZE;
    trcpConfig->dataTruncSize              = TRC_DEFAULT_DATA_TRUNC_SIZE;
    trcpConfig->funcNameLength             = TRC_DEFAULT_FUNC_NAME_LENGTH;
    trcpConfig->flags                      = 0UL;

    SET_FLAG(trcpConfig->flags, TRC_DEFAULT_FLAGS);

    
    StringCchCopy(trcpConfig->fileNames[0],
                  SIZE_TCHARS(trcpConfig->fileNames[0]),
                  TRC_DEFAULT_FILE_NAME0);
    StringCchCopy(trcpConfig->fileNames[1],
                  SIZE_TCHARS(trcpConfig->fileNames[1]),
                  TRC_DEFAULT_FILE_NAME1);
    return;

} /* TRCSetDefaults */


/****************************************************************************/
/* FUNCTION: TRCReadSharedDataConfig(...)                                   */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function reads configuration data into the shared data area.        */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCReadSharedDataConfig(DCVOID)
{
    /************************************************************************/
    /* Call routine to set up trace defaults.                               */
    /************************************************************************/
    TRCSetDefaults();

    /************************************************************************/
    /* Determine the trace level.                                           */
    /************************************************************************/
    TRCReadProfInt(_T("TraceLevel"), &(trcpConfig->traceLevel));
    if (trcpConfig->traceLevel > TRC_LEVEL_DIS )
    {
        /********************************************************************/
        /* Bad trace level.  Set to default.                                */
        /********************************************************************/
        trcpConfig->traceLevel = TRC_DEFAULT_TRACE_LEVEL;
    }

    /************************************************************************/
    /* Determine the maximum size of each trace file.                       */
    /************************************************************************/
    TRCReadProfInt(_T("TraceFileSize"), &(trcpConfig->maxFileSize));
    if ((trcpConfig->maxFileSize < TRC_MIN_TRC_FILE_SIZE) ||
        (trcpConfig->maxFileSize > TRC_MAX_TRC_FILE_SIZE))
    {
        /********************************************************************/
        /* Trace file setting in registry/ini file is out of bounds.        */
        /********************************************************************/
        (trcpConfig->maxFileSize) = TRC_DEFAULT_MAX_FILE_SIZE;
    }

    /************************************************************************/
    /* Determine the data truncation size.                                  */
    /************************************************************************/
    TRCReadProfInt(_T("DataTruncSize"), &(trcpConfig->dataTruncSize));
    if ( trcpConfig->dataTruncSize > TRC_MAX_TRC_FILE_SIZE )
    {
        /********************************************************************/
        /* Data trunc size is out of bounds.                                */
        /********************************************************************/
        trcpConfig->dataTruncSize = TRC_DEFAULT_DATA_TRUNC_SIZE;
    }

    /************************************************************************/
    /* Determine the function name size.                                    */
    /************************************************************************/
    TRCReadProfInt(_T("FuncNameLength"), &(trcpConfig->funcNameLength));
    if ( trcpConfig->funcNameLength >
         (TRC_FRMT_BUFFER_SIZE - TRC_LINE_BUFFER_SIZE) )

    {
        /********************************************************************/
        /* Func name length is out of bounds.                               */
        /********************************************************************/
        trcpConfig->funcNameLength = TRC_DEFAULT_FUNC_NAME_LENGTH;
    }

    /************************************************************************/
    /* Read the prefix list in.  This is in the form <COMP>=L where <COMP>  */
    /* is the component name and L is the desired trace level.  For example */
    /* TRCAPI=2,TRCINT=0 enables alert level tracing for module TRCAPI and  */
    /* debug level tracing for module TRCINT.                               */
    /************************************************************************/
    TRCReadProfString(_T("Prefixes"),
                      trcpConfig->prefixList,
                      TRC_PREFIX_LIST_SIZE);

    /************************************************************************/
    /* Read in the trace file names.                                        */
    /************************************************************************/
    TRCReadProfString(_T("FileName1"),
                      trcpConfig->fileNames[0],
                      TRC_FILE_NAME_SIZE);
    TRCReadProfString(_T("FileName2"),
                      trcpConfig->fileNames[1],
                      TRC_FILE_NAME_SIZE);

    /************************************************************************/
    /* Component groups.                                                    */
    /************************************************************************/
    TRCReadFlag(_T("NETWORK"),  TRC_GROUP_NETWORK,   &trcpConfig->components);
    TRCReadFlag(_T("SECURITY"), TRC_GROUP_SECURITY,  &trcpConfig->components);
    TRCReadFlag(_T("CORE"),     TRC_GROUP_CORE,      &trcpConfig->components);
    TRCReadFlag(_T("UI"),       TRC_GROUP_UI,        &trcpConfig->components);
    TRCReadFlag(_T("UTILITIES"),TRC_GROUP_UTILITIES, &trcpConfig->components);

    /************************************************************************/
    /* The following groups should be permanently off, as they're disused.  */
    /************************************************************************/
#ifdef DC_OMIT
    TRCReadFlag(_T("UNUSED1"),  TRC_GROUP_UNUSED1,   &trcpConfig->components);
    TRCReadFlag(_T("UNUSED2"),  TRC_GROUP_UNUSED2,   &trcpConfig->components);
    TRCReadFlag(_T("UNUSED3"),  TRC_GROUP_UNUSED3,   &trcpConfig->components);
    TRCReadFlag(_T("UNUSED4"),  TRC_GROUP_UNUSED4,   &trcpConfig->components);
    TRCReadFlag(_T("UNUSED5"),  TRC_GROUP_UNUSED5,   &trcpConfig->components);
#endif

    /************************************************************************/
    /* @@@ SJ Aug 97                                                        */
    /* Remove this as the components become used.                           */
    /************************************************************************/
    CLEAR_FLAG(trcpConfig->components, TRC_GROUP_UNUSED1);
    CLEAR_FLAG(trcpConfig->components, TRC_GROUP_UNUSED2);
    CLEAR_FLAG(trcpConfig->components, TRC_GROUP_UNUSED3);
    CLEAR_FLAG(trcpConfig->components, TRC_GROUP_UNUSED4);
    CLEAR_FLAG(trcpConfig->components, TRC_GROUP_UNUSED5);

    /************************************************************************/
    /* Trace flags.                                                         */
    /************************************************************************/
    TRCReadFlag(_T("BreakOnError"), TRC_OPT_BREAK_ON_ERROR,  &trcpConfig->flags);
    TRCReadFlag(_T("BeepOnError"),  TRC_OPT_BEEP_ON_ERROR,   &trcpConfig->flags);
    TRCReadFlag(_T("FileOutput"),   TRC_OPT_FILE_OUTPUT,     &trcpConfig->flags);
    TRCReadFlag(_T("DebugOutput"),  TRC_OPT_DEBUGGER_OUTPUT, &trcpConfig->flags);
    TRCReadFlag(_T("FlushOnTrace"), TRC_OPT_FLUSH_ON_TRACE,  &trcpConfig->flags);
    TRCReadFlag(_T("ProfileTrace"), TRC_OPT_PROFILE_TRACING, &trcpConfig->flags);
    TRCReadFlag(_T("StackTracing"), TRC_OPT_STACK_TRACING,   &trcpConfig->flags);
    TRCReadFlag(_T("ProcessID"),    TRC_OPT_PROCESS_ID,      &trcpConfig->flags);
    TRCReadFlag(_T("ThreadID"),     TRC_OPT_THREAD_ID,       &trcpConfig->flags);
    TRCReadFlag(_T("TimeStamp"),    TRC_OPT_TIME_STAMP,      &trcpConfig->flags);
    TRCReadFlag(_T("BreakOnAssert"),TRC_OPT_BREAK_ON_ASSERT, &trcpConfig->flags);

#ifdef DC_OMIT
/****************************************************************************/
/* Not implemented yet.                                                     */
/****************************************************************************/
    TRCReadFlag(_T("RelativeTimeStamp"), TRC_OPT_RELATIVE_TIME_STAMP,
                                                          &trcpConfig->flags);
#endif

    return;

} /* TRCReadSharedDataConfig */


/****************************************************************************/
/* FUNCTION: TRCShouldTraceThis(...)                                        */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function decides whether this trace line should be traced based     */
/* on the currently selected components and prefixes.  Note that this       */
/* function is not called if the trace level of the line is lower than      */
/* the currently selected trace level.                                      */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* traceComponent : the component group producing this trace.               */
/* pFileName      : the name of the file producing this trace.              */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* TRUE if the line should be traced and FALSE otherwise.                   */
/*                                                                          */
/****************************************************************************/
DCBOOL DCINTERNAL TRCShouldTraceThis(DCUINT32 traceComponent,
                                     DCUINT32 traceLevel,
                                     PDCTCHAR pFileName,
                                     DCUINT32 lineNumber)
{
    DCBOOL   rc              = FALSE;
    PDCTCHAR pName;
    PDCTCHAR pTemp;
    DCUINT32 pfxLength;
    DCUINT   pfxArrayNum;
    DCUINT32 pfxTraceLevel;
    DCBOOL32 pfxFnTrcLevel;

    /************************************************************************/
    /* First of all check the trace level.  If the trace level is error or  */
    /* above then we trace regardless.                                      */
    /************************************************************************/
    if ((traceLevel >= TRC_LEVEL_ERR) && (traceLevel != TRC_PROFILE_TRACE))
    {
        rc = TRUE;
        DC_QUIT;
    }

    /************************************************************************/
    /* If this component is suppressed then just quit.                      */
    /************************************************************************/
    if (0 == (traceComponent & trcpConfig->components))
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* If prefix checking requested then do it now.                         */
    /************************************************************************/
    if (_T('\0') == trcpConfig->prefixList[0])
    {
        /********************************************************************/
        /* The prefix list is empty so just quit.                           */
        /********************************************************************/
        rc = TRUE;
        DC_QUIT;
    }

    /************************************************************************/
    /* First we have to move past any explicit directory names in the file  */
    /* name.                                                                */
    /************************************************************************/
    pName = pFileName;
    pTemp = DC_TSTRCHR(pName, _T('\\'));
    while (NULL != pTemp)
    {
        pName = &(pTemp[1]);
        pTemp = DC_TSTRCHR(pName, _T('\\'));
    }

    /************************************************************************/
    /* We now have a pointer to the actual file prefix.  We need to compare */
    /* this with the list of prefixes that have been set (These have the    */
    /* format:                                                              */
    /*                                                                      */
    /* MODNAM=n,MODAPI=m,MODINT=o                                           */
    /*                                                                      */
    /* where MODNAM is the module name and m is the trace level).           */
    /*                                                                      */
    /* Set the prefix array number indicator <prefixArrayNumber> to 0 and   */
    /* null the temporary pointer.                                          */
    /************************************************************************/

    /************************************************************************/
    /* Try to find the current module name in the prefix list.              */
    /************************************************************************/
    for (pfxArrayNum = 0; pfxArrayNum < TRC_NUM_PREFIXES; pfxArrayNum++)
    {
        /********************************************************************/
        /* If the first character of the prefix name is a zero then ignore  */
        /* and break as we have reached the end of the prefix list.         */
        /********************************************************************/
        if (_T('\0') == trcpFilter->trcPfxNameArray[pfxArrayNum][0])
        {
            rc = FALSE;
            DC_QUIT;
        }

        /********************************************************************/
        /* Determine the length of the current prefix string.               */
        /********************************************************************/
        pfxLength = DC_TSTRLEN(trcpFilter->trcPfxNameArray[pfxArrayNum]);

        /********************************************************************/
        /* Now perform a case insensitive comparison between the prefix     */
        /* array and the file name.                                         */
        /********************************************************************/
        if (0 == TRCStrnicmp(pName,
                             trcpFilter->trcPfxNameArray[pfxArrayNum],
                             pfxLength))
        {
            /****************************************************************/
            /* If no line number range is specified or the line number of   */
            /* this piece of trace is within the range then consider it as  */
            /* a candidate for tracing out.                                 */
            /****************************************************************/
            if ((0 == trcpFilter->trcPfxStartArray[pfxArrayNum]) ||
                ((lineNumber < trcpFilter->trcPfxEndArray[pfxArrayNum]) &&
                 (lineNumber > trcpFilter->trcPfxStartArray[pfxArrayNum])))
            {
                /************************************************************/
                /* Now determine the prefix trace level.                    */
                /************************************************************/
                pfxTraceLevel = trcpFilter->trcPfxLevelArray[pfxArrayNum];
                pfxFnTrcLevel = trcpFilter->trcPfxFnLvlArray[pfxArrayNum];

                /************************************************************/
                /* Finally compare the trace level to the level specified   */
                /* in the prefix string.  If the statement trace level is   */
                /* lower than prefix level then we don't trace.             */
                /************************************************************/
                if (((traceLevel == TRC_PROFILE_TRACE) && pfxFnTrcLevel) ||
                    (traceLevel >= pfxTraceLevel))
                {
                    rc = TRUE;
                    DC_QUIT;
                }
            }
        }
    }

DC_EXIT_POINT:
    return(rc);

} /* TRCShouldTraceThis */


/****************************************************************************/
/* FUNCTION: TRCSplitPrefixes(...)                                          */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function takes a comma seperated array of prefixes and converts     */
/* them into an array.  Each member of this array is a seperate prefix.     */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCSplitPrefixes(DCVOID)
{
    PDCTCHAR pStart;
    PDCTCHAR pEnd;
    DCUINT   numChars;
    DCUINT   currentArrayNumber;
    DCUINT   i;
    DCUINT32 startLine;
    DCUINT32 endLine;

    /************************************************************************/
    /* First of all we blank out the old prefix name array.                 */
    /************************************************************************/
    DC_MEMSET(trcpFilter->trcPfxNameArray,
              '\0',
              sizeof(trcpFilter->trcPfxNameArray));

    /************************************************************************/
    /* Now blank out the old prefix level array.                            */
    /************************************************************************/
    for (i = 0; i < TRC_NUM_PREFIXES; i++)
    {
        trcpFilter->trcPfxLevelArray[i] = 0;
        trcpFilter->trcPfxFnLvlArray[i] = FALSE;
        trcpFilter->trcPfxStartArray[i] = 0;
        trcpFilter->trcPfxEndArray[i] = 0;
    }

    /************************************************************************/
    /* Set the current prefix array number to zero (i.e. ready to index the */
    /* first element of the prefix array).                                  */
    /************************************************************************/
    currentArrayNumber = 0;

    /************************************************************************/
    /* Split the prefix string into an array of seperate elements.          */
    /************************************************************************/
    pStart = trcpConfig->prefixList;

    /************************************************************************/
    /* Ignore any spaces at the start of the string.                        */
    /************************************************************************/
    while (_T(' ') == *pStart)
    {
        pStart++;
    }

    /************************************************************************/
    /* Now set <pEnd> to point to the same point as <pStart>.               */
    /************************************************************************/
    pEnd = pStart;

    while (_T('\0') != *pEnd)
    {
        /********************************************************************/
        /* Now run along the string looking for a comma, an equals sign,    */
        /* the end, a space or a bracket.                                   */
        /********************************************************************/
        while ((_T('\0') != *pEnd) &&
               (_T('=')  != *pEnd) &&
               (_T(' ')  != *pEnd) &&
               (_T('(')  != *pEnd) &&
               (_T(',')  != *pEnd))
        {
            pEnd = CharNext(pEnd);
        }

        /********************************************************************/
        /* We now have a valid string to write to the trace buffer so get   */
        /* its length.                                                      */
        /********************************************************************/
        numChars = (DCUINT)(pEnd - pStart);

        /********************************************************************/
        /* The maximum allowable length of the string is 7 characters (a 7  */
        /* character prefix).  If the length is greater than 7 characters   */
        /* then we truncate it.                                             */
        /********************************************************************/
        if (numChars > 7)
        {
            numChars = 7;
        }

        /********************************************************************/
        /* Now use <DC_MEMCPY> to copy the characters from the prefix       */
        /* string into the prefix array.  Note that as we zeroed the array  */
        /* out at the start we don't need to add a terminating NULL to the  */
        /* prefix array string.                                             */
        /********************************************************************/
        DC_MEMCPY(trcpFilter->trcPfxNameArray[currentArrayNumber],
                  pStart,
                  numChars * sizeof(TCHAR));

        /********************************************************************/
        /* Skip any spaces after this word, which may precede an '='.       */
        /********************************************************************/
        while (_T(' ') == *pEnd)
        {
            pEnd++;
        }

        /********************************************************************/
        /* Now split the trace level out and store it in the level array.   */
        /* If <pEnd> is currently pointing to an equals sign then we need   */
        /* to copy the trace level which follows to the level array.        */
        /* Otherwise we do nothing as the default level is set to           */
        /* TRC_LEVEL_DBG.                                                   */
        /********************************************************************/
        if (_T('=') == *pEnd)
        {
            /****************************************************************/
            /* Increment past the equals sign.                              */
            /****************************************************************/
            pEnd++;

            /****************************************************************/
            /* Skip any spaces after the '='.                               */
            /****************************************************************/
            while (_T(' ') == *pEnd)
            {
                pEnd++;
            }

            /****************************************************************/
            /* Check that we have not reached the end of the string or a    */
            /* comma.  This will happen if we have a prefix list such as    */
            /* 'trcint='.  In this case we just ignore the equals sign.     */
            /* Also check that the level specified is valid - otherwise     */
            /* ignore it.                                                   */
            /****************************************************************/
            if ((_T('\0') != *pEnd) &&
                (_T(',')  != *pEnd) &&
                (*pEnd >= TRC_LEVEL_MIN_CHAR) &&
                (*pEnd <= TRC_LEVEL_MAX_CHAR))
            {
                trcpFilter->trcPfxLevelArray[currentArrayNumber] =
                    (DCUINT32) (*pEnd - _T('0'));

                /************************************************************/
                /* Skip past the number.                                    */
                /************************************************************/
                pEnd++;
            }

            /****************************************************************/
            /* Check for a the function entry/exit trace flag.              */
            /****************************************************************/
            if (DC_TOUPPER(*pEnd) == TRC_LEVEL_PRF_CHAR)
            {
                trcpFilter->trcPfxFnLvlArray[currentArrayNumber] = TRUE;
                pEnd++;
            }
        }

        /********************************************************************/
        /* Skip any spaces after this word, which may precede an '('.       */
        /********************************************************************/
        while (_T(' ') == *pEnd)
        {
            pEnd++;
        }

        /********************************************************************/
        /* Now split out the (optional) line number range.                  */
        /*                                                                  */
        /* Syntax is (aaa-bbb), where aaa is the start line number and bbb  */
        /* is the end line number.                                          */
        /*                                                                  */
        /* Spaces are allowed - e.g.  ( aaa - bbb )                         */
        /********************************************************************/
        if (_T('(') == *pEnd)
        {
            pEnd++;                     /* skip past the open bracket       */
            startLine = 0;
            endLine = 0;

            /****************************************************************/
            /* Skip past blanks                                             */
            /****************************************************************/
            while (_T(' ') == *pEnd)
            {
                pEnd++;
            }

            /****************************************************************/
            /* Extract the start line number                                */
            /****************************************************************/
            while ((_T('0') <= *pEnd) &&
                   (_T('9') >= *pEnd))
            {
                startLine = (startLine * 10) + (*pEnd - _T('0'));
                pEnd++;
            }

            /****************************************************************/
            /* Look for the next delimiter: '-' or ')'                      */
            /****************************************************************/
            while ((_T('-') != *pEnd) &&
                   (_T(')') != *pEnd) &&
                   (_T('\0') != *pEnd))
            {
                pEnd = CharNext(pEnd);
            }

            /****************************************************************/
            /* Stop now if we've reached the end of the line                */
            /****************************************************************/
            if (_T('\0') == *pEnd)
            {
                TRCDebugOutput(_T("Unexpected end of line in prefixes"));
                DC_QUIT;
            }

            /****************************************************************/
            /* Extract the end line number (if any)                         */
            /****************************************************************/
            if (_T('-') == *pEnd)
            {
                pEnd++;                 /* skip past '-'                    */
                while (_T(' ') == *pEnd)
                {
                    pEnd++;
                }

                while ((_T('0') <= *pEnd) &&
                       (_T('9') >= *pEnd))
                {
                    endLine = (endLine * 10) + (*pEnd - _T('0'));
                    pEnd++;
                }

            }

            /****************************************************************/
            /* Look for the closing delimiter: ')'                          */
            /****************************************************************/
            while ((_T('\0') != *pEnd) &&
                   (_T(')') != *pEnd))
            {
                pEnd = CharNext(pEnd);
            }

            /****************************************************************/
            /* Stop now if we've reached the end of the line                */
            /****************************************************************/
            if (_T('\0') == *pEnd)
            {
                TRCDebugOutput(_T("Unexpected end of line in prefixes"));
                DC_QUIT;
            }

            pEnd++;                     /* Jump past close bracket          */

            /****************************************************************/
            /* Store the start and end line numbers if they make sense      */
            /****************************************************************/
            if (endLine > startLine)
            {
                trcpFilter->trcPfxStartArray[currentArrayNumber] = startLine;
                trcpFilter->trcPfxEndArray[currentArrayNumber] = endLine;

            }

        }

        /********************************************************************/
        /* Now increment the currentArrayNumber.                            */
        /********************************************************************/
        currentArrayNumber++;

        /********************************************************************/
        /* Check that we have not overrun the array.                        */
        /********************************************************************/
        if (currentArrayNumber >= TRC_NUM_PREFIXES)
        {
            /****************************************************************/
            /* We've overrun the prefix list - so send some trace to the    */
            /* debug console and then quit.                                 */
            /****************************************************************/
            TRCDebugOutput(_T("The prefix arrays are full!"));
            DC_QUIT;
        }

        /********************************************************************/
        /* If the character at the end of the string is a comma or a space  */
        /* then skip past it.                                               */
        /********************************************************************/
        while ((_T(',') == *pEnd) ||
               (_T(' ') == *pEnd))
        {
            pEnd++;
        }

        /********************************************************************/
        /* Set pStart to the same position as pEnd.                         */
        /********************************************************************/
        pStart = pEnd;
    }

    /************************************************************************/
    /* We're through so just return.                                        */
    /************************************************************************/
DC_EXIT_POINT:
    return;

} /* TRCSplitPrefixes */


/****************************************************************************/
/* FUNCTION: TRCStrnicmp(...)                                               */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Code to implement a strnicmp (length-limited, case-insensitive string    */
/* comparison) because it is otherwise unavailable (see SFR0636).           */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* source  - source string                                                  */
/* target  - target string                                                  */
/* count   - maximum length to compare                                      */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0     - strings match up to specified point                              */
/* other - strings do not match up to specified point                       */
/*                                                                          */
/****************************************************************************/
DCINT32 DCINTERNAL TRCStrnicmp(PDCTCHAR pSource,
                               PDCTCHAR pTarget,
                               DCUINT32 count)
{
    DCUINT sourcechar;
    DCUINT targetchar;
    DCINT32 rc=0;

    if (count == 0)
    {
        DC_QUIT;
    }

    do
    {
        /********************************************************************/
        /* Make sure that we extend characters in an unsigned fashion.      */
        /********************************************************************/
        sourcechar = (DCUINT)(DCUINT8)*pSource++;
        targetchar = (DCUINT)(DCUINT8)*pTarget++;

        /********************************************************************/
        /* Convert to lower case if char is an upper case letter.           */
        /********************************************************************/
        if ( (sourcechar >= _T('A')) && (sourcechar <= _T('Z')) )
        {
            sourcechar += _T('a') - _T('A');
        }

        if ( (targetchar >= _T('A')) && (targetchar <= _T('Z')) )
        {
            targetchar += _T('a') - _T('A');
        }

    } while ( (0 != (--count)) && sourcechar && (sourcechar == targetchar) );

    rc = (DCINT32)(sourcechar - targetchar);

DC_EXIT_POINT:

    return(rc);

} /* TRCStrnicmp  */


/****************************************************************************/
/* FUNCTION: TRCWriteFlag(...)                                              */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function writes a configuration flag setting.                       */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* entryName    - the profile entry name.                                   */
/* flag         - the flag to set or clear.                                 */
/* pSetting     - a pointer to the variable containing the flag.            */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCWriteFlag(PDCTCHAR entryName,
                               DCUINT32 flag,
                               DCUINT32 setting)
{
    DCUINT32 entryValue      = 0;

    /************************************************************************/
    /* If the flag is set then change the entryValue to 1.                  */
    /************************************************************************/
    if (TEST_FLAG(setting, flag))
    {
        entryValue = 1;
    }

    /************************************************************************/
    /* Call <TRCWriteProfInt> to write the flag settin.                     */
    /************************************************************************/
    TRCWriteProfInt(entryName, &entryValue);

    return;

} /* TRCWriteFlag */


/****************************************************************************/
/* FUNCTION: TRCWriteSharedDataConfig(...)                                  */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function saves configuration data from the shared data area.        */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCWriteSharedDataConfig(DCVOID)
{
    /************************************************************************/
    /* Save the trace level.                                                */
    /************************************************************************/
    TRCWriteProfInt(_T("TraceLevel"), &(trcpConfig->traceLevel));

    /************************************************************************/
    /* Save the maximum size of each trace file.                            */
    /************************************************************************/
    TRCWriteProfInt(_T("TraceFileSize"), &(trcpConfig->maxFileSize));

    /************************************************************************/
    /* Save the data truncation size.                                       */
    /************************************************************************/
    TRCWriteProfInt(_T("DataTruncSize"), &(trcpConfig->dataTruncSize));

    /************************************************************************/
    /* Save the function name size.                                         */
    /************************************************************************/
    TRCWriteProfInt(_T("FuncNameLength"), &(trcpConfig->funcNameLength));

    /************************************************************************/
    /* Write the prefix list out.  This is in the form <COMP>=L where       */
    /* <COMP> is the component name and L is the desired trace level.  For  */
    /* example CMDATA=2,CMINT=0 enables alert level tracing for module      */
    /* CMDATA and debug level tracing for module CMINT.                     */
    /************************************************************************/
    TRCWriteProfString(_T("Prefixes"), trcpConfig->prefixList);

    /************************************************************************/
    /* Save the trace file names.                                           */
    /************************************************************************/
    TRCWriteProfString(_T("FileName1"), trcpConfig->fileNames[0]);
    TRCWriteProfString(_T("FileName2"), trcpConfig->fileNames[1]);

    /************************************************************************/
    /* Component groups.                                                    */
    /************************************************************************/
    TRCWriteFlag(_T("NETWORK"),  TRC_GROUP_NETWORK,   trcpConfig->components);
    TRCWriteFlag(_T("SECURITY"), TRC_GROUP_SECURITY,  trcpConfig->components);
    TRCWriteFlag(_T("CORE"),     TRC_GROUP_CORE,      trcpConfig->components);
    TRCWriteFlag(_T("UI"),       TRC_GROUP_UI,        trcpConfig->components);
    TRCWriteFlag(_T("UTILITIES"),TRC_GROUP_UTILITIES, trcpConfig->components);
#ifdef DC_OMIT
/****************************************************************************/
/* These groups are reserved.                                               */
/****************************************************************************/
    TRCWriteFlag(_T("UNUSED1"),  TRC_GROUP_UNUSED1,   trcpConfig->components);
    TRCWriteFlag(_T("UNUSED2"),  TRC_GROUP_UNUSED2,   trcpConfig->components);
    TRCWriteFlag(_T("UNUSED3"),  TRC_GROUP_UNUSED3,   trcpConfig->components);
    TRCWriteFlag(_T("UNUSED4"),  TRC_GROUP_UNUSED4,   trcpConfig->components);
    TRCWriteFlag(_T("UNUSED5"),  TRC_GROUP_UNUSED5,   trcpConfig->components);
#endif

    /************************************************************************/
    /* Trace flags.                                                         */
    /************************************************************************/
    TRCWriteFlag(_T("BreakOnError"), TRC_OPT_BREAK_ON_ERROR,  trcpConfig->flags);
    TRCWriteFlag(_T("BeepOnError"),  TRC_OPT_BEEP_ON_ERROR,   trcpConfig->flags);
    TRCWriteFlag(_T("FileOutput"),   TRC_OPT_FILE_OUTPUT,     trcpConfig->flags);
    TRCWriteFlag(_T("DebugOutput"),  TRC_OPT_DEBUGGER_OUTPUT, trcpConfig->flags);
    TRCWriteFlag(_T("FlushOnTrace"), TRC_OPT_FLUSH_ON_TRACE,  trcpConfig->flags);
    TRCWriteFlag(_T("ProfileTrace"), TRC_OPT_PROFILE_TRACING, trcpConfig->flags);
    TRCWriteFlag(_T("StackTracing"), TRC_OPT_STACK_TRACING,   trcpConfig->flags);
    TRCWriteFlag(_T("ProcessID"),    TRC_OPT_PROCESS_ID,      trcpConfig->flags);
    TRCWriteFlag(_T("ThreadID"),     TRC_OPT_THREAD_ID,       trcpConfig->flags);
    TRCWriteFlag(_T("TimeStamp"),    TRC_OPT_TIME_STAMP,      trcpConfig->flags);
    TRCWriteFlag(_T("BreakOnAssert"),TRC_OPT_BREAK_ON_ASSERT, trcpConfig->flags);

#ifdef DC_OMIT
/****************************************************************************/
/* Not implemented yet.                                                     */
/****************************************************************************/
    TRCWriteFlag(_T("RelativeTimeStamp"), TRC_OPT_RELATIVE_TIME_STAMP,
                                                          &trcpConfig->flags);
#endif

    return;

} /* TRCWriteSharedDataConfig */


/****************************************************************************/
/* FUNCTION: TRCCloseAllFiles(...)                                          */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Closes all the trace memory mapped files.                                */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCCloseAllFiles(DCVOID)
{
    /************************************************************************/
    /* Close all the trace output files.  We close the one that the trace   */
    /* indicator is pointing at last - this is because we use the time      */
    /* stamp of the trace file to set the trace indicator at the start of   */
    /* day (we choose the most recent file).                                */
    /************************************************************************/
    TRCCloseSingleFile((trcpSharedData->trcIndicator + 1) % TRC_NUM_FILES, 0);

    /************************************************************************/
    /* Now close the other trace file.                                      */
    /************************************************************************/
    TRCCloseSingleFile(trcpSharedData->trcIndicator, 30);

    return;

} /* TRCCloseAllFiles */


/****************************************************************************/
/* FUNCTION: TRCOutput(...)                                                 */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function outputs the passed string to the trace file and/or the     */
/* debugger depending on the options selected.                              */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pText         : a pointer to the string.                                 */
/* length        : the length of the string.                                */
/* traceLevel    : the trace level.                                         */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCOutput(PDCTCHAR pText,
                            DCINT    length,
                            DCINT    traceLevel)
{
    /************************************************************************/
    /* Decide if we should output to file.                                  */
    /************************************************************************/
    if (TEST_FLAG(trcpConfig->flags, TRC_OPT_FILE_OUTPUT))
    {
        TRCOutputToFile(pText, length, traceLevel);
    }

    /************************************************************************/
    /* Decide if we should output to the debugger.                          */
    /************************************************************************/
    if (TEST_FLAG(trcpConfig->flags, TRC_OPT_DEBUGGER_OUTPUT))
    {
        TRCDebugOutput(pText);
    }

    return;

} /* TRCOutput */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\ntrcint.h ===
/**INC+**********************************************************************/
/* Header:    ntrcint.h                                                     */
/*                                                                          */
/* Purpose:   Internal tracing functions header - Windows NT specific       */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/trc/ntrcint.h_v  $
 *
 *    Rev 1.6   28 Aug 1997 14:52:26   ENH
 * SFR1189: Added TRACE_REG_PREFIX
 *
 *    Rev 1.5   22 Aug 1997 10:22:04   SJ
 * SFR1316: Trace options in wrong place in the registry.
 *
 *    Rev 1.4   12 Aug 1997 09:52:14   MD
 * SFR1002: Remove kernel tracing code
 *
 *    Rev 1.3   09 Jul 1997 18:02:46   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.2   03 Jul 1997 13:28:40   AK
 * SFR0000: Initial development completed
 *
 *    Rev 1.1   20 Jun 1997 10:25:50   KH
 * Win16Port: Contains 32 bit specifics only
**/
/**INC-**********************************************************************/

#ifndef _H_NTRCINT
#define _H_NTRCINT

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Macro to create the mutex which protects the shared data memory mapped   */
/* file.                                                                    */
/****************************************************************************/
#define TRCCreateMutex(a,b,c) (CreateMutex(a,b,c))

/****************************************************************************/
/* Macro to get the mutex which protects the shared data memory mapped      */
/* file.  By getting this semaphore we are serializing access to the trace  */
/* buffer and the trace configuration (e.g.  trace level, prefix list).     */
/*                                                                          */
/* We use the standard Win32 WaitForSingleObject function to wait for the   */
/* mutex.  The wait function requests ownership of the mutex for us.  If    */
/* the mutex is nonsignaled then we enter an efficient wait state which     */
/* consumes very little processor time while waiting for the mutex to       */
/* become signaled.                                                         */
/****************************************************************************/
#define TRCGrabMutex()             WaitForSingleObject(trchMutex, INFINITE)

/****************************************************************************/
/* Macro to free the mutex.  Use the standard Win32 ReleaseMutex function.  */
/****************************************************************************/
#define TRCReleaseMutex()          ReleaseMutex(trchMutex)

/****************************************************************************/
/* Trace a string out to the debugger.                                      */
/****************************************************************************/
#define TRCDebugOutput(pText)                                                \
{                                                                            \
    OutputDebugString(pText);                                                \
}

/****************************************************************************/
/* Get the current process Id using the Win32 GetCurrentProcessId function. */
/****************************************************************************/
#define TRCGetCurrentProcessId()   GetCurrentProcessId()

/****************************************************************************/
/* Get the thread process Id using the Win32 GetCurrentThreadId function.   */
/****************************************************************************/
#define TRCGetCurrentThreadId()    GetCurrentThreadId()

/****************************************************************************/
/* Define our own beep macro.                                               */
/****************************************************************************/
#define TRCBeep()                  MessageBeep(0)

/****************************************************************************/
/* Define our debug break macro.                                            */
/****************************************************************************/
DCVOID DCINTERNAL TRCDebugBreak(DCVOID);

/****************************************************************************/
/* Ducati registry prefix.                                                  */
/****************************************************************************/
#define TRACE_REG_PREFIX      _T("SOFTWARE\\Microsoft\\Terminal Server Client\\")

#define TRC_SUBKEY_NAME  (TRACE_REG_PREFIX TRC_INI_SECTION_NAME)       

/****************************************************************************/
/* Macro to close the mutex object.                                         */
/****************************************************************************/
#define TRCCloseHandle(handle) CloseHandle(handle)

#endif /* _H_NTRCINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\wtrcapi.c ===
/**MOD+**********************************************************************/
/* Module:    wtrcapi.c                                                     */
/*                                                                          */
/* Purpose:   External tracing functions - Windows specific                 */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/trc/wtrcapi.c_v  $
 *
 *    Rev 1.7   29 Aug 1997 09:42:02   ENH
 * SFR1259: Changed SystemError
 *
 *    Rev 1.6   12 Aug 1997 09:50:52   MD
 * SFR1002: Remove kernel tracing code
 *
 *    Rev 1.5   10 Jul 1997 18:04:26   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.4   10 Jul 1997 17:34:10   KH
 * SFR1022: Get 16-bit trace working
 *
 *    Rev 1.3   03 Jul 1997 13:28:50   AK
 * SFR0000: Initial development completed
**/
/**MOD-**********************************************************************/

/****************************************************************************/
/*                                                                          */
/* CONTENTS                                                                 */
/* ========                                                                 */
/* TRC_SystemError                                                          */
/* TRC_Initialize                                                           */
/* TRC_Terminate                                                            */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Standard includes.                                                       */
/****************************************************************************/
#include <adcg.h>

/****************************************************************************/
/* Define TRC_FILE and TRC_GROUP.                                           */
/****************************************************************************/
#define TRC_FILE    "wtrcapi"
#define TRC_GROUP   TRC_GROUP_TRACE

/****************************************************************************/
/* Trace specific includes.                                                 */
/****************************************************************************/
#include <atrcapi.h>
#include <atrcint.h>

/****************************************************************************/
/*                                                                          */
/* DATA                                                                     */
/*                                                                          */
/****************************************************************************/
#define DC_INCLUDE_DATA
#include <atrcdata.c>
#undef DC_INCLUDE_DATA

/****************************************************************************/
/*                                                                          */
/* FUNCTIONS                                                                */
/*                                                                          */
/****************************************************************************/

/**PROC+*********************************************************************/
/* TRC_SystemError(...)                                                     */
/*                                                                          */
/* See wtrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCVOID DCAPI DCEXPORT TRC_SystemError(DCUINT   traceComponent,
                                      DCUINT   lineNumber,
                                      PDCTCHAR funcName,
                                      PDCTCHAR fileName,
                                      PDCTCHAR string)

{
    /************************************************************************/
    /* The process of getting the system error is clearly platform specific */
    /* so we call the platform specific function.                           */
    /************************************************************************/
    TRCSystemError(traceComponent,
                   lineNumber,
                   funcName,
                   fileName,
                   string);

    return;

} /* TRC_SystemError */

/**PROC+*********************************************************************/
/* TRC_Initialize(...)                                                      */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCUINT32 DCAPI DCEXPORT TRC_Initialize(DCBOOL initShared)
{
    DCUINT rc                = 0;
#ifndef OS_WINCE
    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;
    OSVERSIONINFO ver;
    PSID psidEveryone = NULL;
    SID_IDENTIFIER_AUTHORITY sidEveryoneAuthority = SECURITY_WORLD_SID_AUTHORITY;
    DCUINT32 dwDaclLength;
    PACL pDacl = NULL;
#endif

    BOOL releaseMutex = FALSE;

    DC_IGNORE_PARAMETER(initShared);

    /************************************************************************/
    /* Create the mutex object which protects the shared memory mapped      */
    /* file.  If the mutex has already been created then CreateMutex simply */
    /* returns a handle to the existing mutex.                              */
    /*                                                                      */
    /* The mutex will be created with a NULL Dacl so processes running it in*/ 
    /* any context can have access.                                         */
    /************************************************************************/
#ifndef OS_WINCE
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&ver);
    if (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) {

        /************************************************************************/
        /* Get the SID for the Everyone group                                   */
        /************************************************************************/
        if (!AllocateAndInitializeSid (
                &sidEveryoneAuthority,          // pIdentifierAuthority
                1,                              // count of subauthorities
                SECURITY_WORLD_RID,             // subauthority 0
                0, 0, 0, 0, 0, 0, 0,            // subauthorities n
                &psidEveryone)) {               // pointer to pointer to SID
            rc = TRC_RC_CREATE_MUTEX_FAILED;
            OutputDebugString(_T("AllocateAndInitializeSid failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Allocate the Dacl                                                    */
        /************************************************************************/
        dwDaclLength = sizeof(ACL);
        dwDaclLength += (sizeof(ACCESS_DENIED_ACE) - sizeof(DWORD)) +
                           GetLengthSid(psidEveryone);
        dwDaclLength += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                           GetLengthSid(psidEveryone);
        pDacl = (PACL)LocalAlloc(LMEM_FIXED, dwDaclLength);
        if (pDacl == NULL) {
            rc = TRC_RC_CREATE_MUTEX_FAILED;
            OutputDebugString(_T("Can't allocate Dacl.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Initialize it.                                                       */
        /************************************************************************/
        if (!InitializeAcl(pDacl, dwDaclLength, ACL_REVISION)) {
            rc = TRC_RC_CREATE_MUTEX_FAILED;
            OutputDebugString(_T("InitializeAcl failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Allow all access                                                     */
        /************************************************************************/
        if (!AddAccessAllowedAce(
                        pDacl,
                        ACL_REVISION,
                        GENERIC_ALL,
                        psidEveryone)) {
            rc = TRC_RC_CREATE_MUTEX_FAILED;
            OutputDebugString(_T("AddAccessAllowedAce failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Block Write-DACL Access                                              */
        /************************************************************************/
        if (!AddAccessDeniedAce(
                        pDacl,
                        ACL_REVISION,
                        WRITE_DAC,
                        psidEveryone)) {
            rc = TRC_RC_CREATE_MUTEX_FAILED;
            OutputDebugString(_T("AddAccessDeniedAce failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Create the Mutex                                                     */
        /************************************************************************/
        InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
        SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE);
        sa.lpSecurityDescriptor = &sd;
        trchMutex = TRCCreateMutex(&sa,
                                   FALSE,
                                   TRC_MUTEX_NAME);

    }
    else {
#endif
        trchMutex = TRCCreateMutex(NULL,
                                   FALSE,
                                   TRC_MUTEX_NAME);
#ifndef OS_WINCE
    }
#endif

    /************************************************************************/
    /* Check that we created the mutex successfully.                        */
    /************************************************************************/
    if (NULL == trchMutex)
    {
        DWORD lastError = GetLastError();
        OutputDebugString(_T("Failed to create mutex.\n"));
        rc = TRC_RC_CREATE_MUTEX_FAILED;
        DC_QUIT;
    }

    /************************************************************************/
    /* Now that we've created the mutex, grab it.                           */
    /************************************************************************/
    TRCGrabMutex();
    releaseMutex = TRUE;

    /************************************************************************/
    /* Check the current trace DLL state.  Another thread may have          */
    /* concurrently called TRC_Initialize - if it has then we should exit   */
    /* as it will perform the initialization.                               */
    /************************************************************************/
    if (TRC_STATE_UNINITIALIZED != trcState)
    {
        TRCDebugOutput(_T("Trace DLL already initialized!\n"));
        DC_QUIT;
    }

    /************************************************************************/
    /* We need to open the shared data memory mapped file.                  */
    /************************************************************************/
    rc = TRCOpenSharedData();

    /************************************************************************/
    /* Check that the shared data MMF was created and opened successfully.  */
    /************************************************************************/
    if (0 != rc)
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* Now open the memory mapped trace files.                              */
    /************************************************************************/
    rc = TRCOpenAllFiles();

    /************************************************************************/
    /* Check that the trace MMFs were opened successfully.                  */
    /************************************************************************/
    if (0 != rc)
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* Write out the trace DLL initialized trace line.                      */
    /************************************************************************/
    TRCInternalTrace(TRC_TRACE_DLL_INITIALIZE);

    /************************************************************************/
    /* Update our internal state.                                           */
    /************************************************************************/
    trcState = TRC_STATE_INITIALIZED;

    /************************************************************************/
    /* Load the debug symbols.                                              */
    /************************************************************************/
    rc = TRCSymbolsLoad();

    if (0 != rc)
    {
        DC_QUIT;
    }


DC_EXIT_POINT:

    /************************************************************************/
    /* Release the mutex.                                                   */
    /************************************************************************/
    if( releaseMutex )
    {
        TRCReleaseMutex();
    }

#ifndef OS_WINCE
    if (pDacl) LocalFree(pDacl);
    if (psidEveryone) FreeSid(psidEveryone);
#endif
    return(rc);

} /* TRC_Initialize */

/**PROC+*********************************************************************/
/* TRC_Terminate(...)                                                       */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCVOID DCAPI DCEXPORT TRC_Terminate(DCBOOL termShared)
{
    DC_IGNORE_PARAMETER(termShared);

    /************************************************************************/
    /* Grab the mutex.  Note that this function is only called from the     */
    /* process detach case in the <DllMain> function - therefore we can be  */
    /* sure that this function gets called only once per process.           */
    /************************************************************************/
    TRCGrabMutex();

    /************************************************************************/
    /* Unload the symbols if we've loaded them.                             */
    /************************************************************************/
    if (TEST_FLAG(trcProcessStatus, TRC_STATUS_SYMBOLS_LOADED))
    {
        TRCSymbolsUnload();
    }

    /************************************************************************/
    /* Write out the trace DLL terminated trace line.                       */
    /************************************************************************/
    TRCInternalTrace(TRC_TRACE_DLL_TERMINATE);

    /************************************************************************/
    /* Close the trace files.                                               */
    /************************************************************************/
    TRCCloseAllFiles();

    /************************************************************************/
    /* Now we need to close the shared data area.                           */
    /************************************************************************/
    TRCCloseSharedData();

    /************************************************************************/
    /* We're no longer initialized so update our per-process flags.         */
    /************************************************************************/
    trcState = TRC_STATE_TERMINATED;

    /************************************************************************/
    /* Release the mutex.                                                   */
    /************************************************************************/
    TRCReleaseMutex();

    /************************************************************************/
    /* Close the mutex handle.  The mutex object is automatically destroyed */
    /* when the last handle is closed.                                      */
    /************************************************************************/
    TRCCloseHandle(trchMutex);
    trchMutex = NULL;

    return;

} /* TRC_Terminate */

#if defined(OS_WINCE) || defined(TRC_CONVERTOANSI)
/**PROC+*********************************************************************/
/* Name:      TRC_ConvertAndSprintf                                         */
/*                                                                          */
/* Purpose:   Convert ANSI trace format string to Unicode and do sprintf    */
/*            Windows CE only                                               */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    OUT    outBuf - output buffer                                 */
/*            IN     format - ANSI format string                            */
/*            IN     ...    - parameters                                    */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI TRC_ConvertAndSprintf(PDCTCHAR outBuf, const PDCACHAR format,...)
{
    va_list vaArgs;
    DCINT   count;
    static DCTCHAR stackBuffer[TRC_LINE_BUFFER_SIZE];

    count = DC_MIN(mbstowcs(NULL, format, 0), TRC_LINE_BUFFER_SIZE);
    va_start(vaArgs, format);

    mbstowcs(stackBuffer, format, count);
    vswprintf(outBuf,  stackBuffer, vaArgs);
    va_end(vaArgs);

    return;
}
#else
/****************************************************************************/
/* Dummy stub function, to enable a common DEF file to be used.             */
/****************************************************************************/
DCVOID DCAPI TRC_ConvertAndSprintf(DCVOID)
{
    return;
}
#endif // OS_WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\atrcapi.c ===
/**MOD+**********************************************************************/
/* Module:    atrcapi.c                                                     */
/*                                                                          */
/* Purpose:   External tracing functions                                    */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1996-7                                */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/trc/atrcapi.c_v  $
 *
 *    Rev 1.12   22 Sep 1997 15:14:38   KH
 * SFR1293: Fix Zippy16 file write errors when zippy starts before Ducati
 *
 *    Rev 1.11   05 Sep 1997 10:34:54   SJ
 * SFR1334: Zippy enhancements
 *
 *    Rev 1.10   12 Aug 1997 09:45:28   MD
 * SFR1002: Remove kernel tracing code
 *
 *    Rev 1.9   04 Aug 1997 15:03:26   KH
 * SFR1022: Cast file name length on sprintf call
 *
 *    Rev 1.8   31 Jul 1997 19:39:30   SJ
 * SFR1041: Port zippy to Win16
 *
 *    Rev 1.7   16 Jul 1997 14:00:48   KH
 * SFR1022: ALL functions are DCEXPORT
 *
 *    Rev 1.6   11 Jul 1997 12:44:24   KH
 * SFR1022: Add DCEXPORT to TRC_GetBuffer
 *
 *    Rev 1.4   09 Jul 1997 17:59:12   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.3   03 Jul 1997 13:27:24   AK
 * SFR0000: Initial development completed
**/
/**MOD-**********************************************************************/

/****************************************************************************/
/*                                                                          */
/* CONTENTS                                                                 */
/*                                                                          */
/* This file contains the DC-Groupware/NT tracing API.                      */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* TRC_GetBuffer                                                            */
/* TRC_TraceBuffer                                                          */
/* TRC_GetConfig                                                            */
/* TRC_SetConfig                                                            */
/* TRC_TraceData                                                            */
/* TRC_GetTraceLevel                                                        */
/* TRC_ProfileTraceEnabled                                                  */
/* TRC_ResetTraceFiles                                                      */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Standard includes.                                                       */
/****************************************************************************/
#include <adcg.h>

/****************************************************************************/
/* Define TRC_FILE and TRC_GROUP.                                           */
/****************************************************************************/
#define TRC_FILE    "atrcapi"
#define TRC_GROUP   TRC_GROUP_TRACE

/****************************************************************************/
/* Trace specific includes.                                                 */
/****************************************************************************/
#include <atrcapi.h>
#include <atrcint.h>

/****************************************************************************/
/*                                                                          */
/* DATA                                                                     */
/*                                                                          */
/****************************************************************************/
#define DC_INCLUDE_DATA
#include <atrcdata.c>
#undef DC_INCLUDE_DATA

/****************************************************************************/
/*                                                                          */
/* FUNCTIONS                                                                */
/*                                                                          */
/****************************************************************************/

/**PROC+*********************************************************************/
/* TRC_GetBuffer(...)                                                       */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
PDCTCHAR DCAPI DCEXPORT TRC_GetBuffer(DCVOID)
{
    /************************************************************************/
    /* Get the mutex.  Note that we do not need to check that we are        */
    /* initialized in this function as this should have already been done.  */
    /************************************************************************/
    TRCGrabMutex();

    //
    // Ensure null termination
    //
    trcpOutputBuffer[TRC_LINE_BUFFER_SIZE*sizeof(TCHAR) -1] = 0;

    /************************************************************************/
    /* Return a pointer to the trace buffer in the shared data memory       */
    /* mapped file.                                                         */
    /************************************************************************/
    return(trcpOutputBuffer);

} /* TRC_GetBuffer */


/**PROC+*********************************************************************/
/* TRC_TraceBuffer(...)                                                     */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCVOID DCAPI DCEXPORT TRC_TraceBuffer(DCUINT   traceLevel,
                                      DCUINT   traceComponent,
                                      DCUINT   lineNumber,
                                      PDCTCHAR funcName,
                                      PDCTCHAR fileName)
{
    DCTCHAR  fieldSeperator;
    DCTCHAR  frmtString[TRC_FRMT_BUFFER_SIZE] = {0};
    DCTCHAR  tempString[TRC_FRMT_BUFFER_SIZE] = {0};
    DCUINT32 processId;
    DCUINT32 threadId;
    DCUINT   length;
    DC_TIME  theTime;
    HRESULT  hr;

    /************************************************************************/
    /* First of all we need to decide if we are going to trace this line.   */
    /*                                                                      */
    /* Note that the decision to trace a line based on its level is taken   */
    /* in the TRACEX macro.                                                 */
    /************************************************************************/
    if (!TRCShouldTraceThis(traceComponent, traceLevel, fileName, lineNumber))
    {
        /********************************************************************/
        /* Don't bother tracing this line.                                  */
        /********************************************************************/
        DC_QUIT;
    }

    /************************************************************************/
    /* We need to trace this line.  First of all create the formatted       */
    /* output text string.  Determine the field seperator for the trace     */
    /* line.  Errors use a star (*), alerts a plus (+), asserts an          */
    /* exclamation mark (!) while normal and debug trace lines both use a   */
    /* space ( ).                                                           */
    /************************************************************************/
    switch(traceLevel)
    {
        case TRC_LEVEL_ASSERT:
        {
            fieldSeperator = '!';
        }
        break;

        case TRC_LEVEL_ERR:
        {
            fieldSeperator = '*';
        }
        break;

        case TRC_LEVEL_ALT:
        {
            fieldSeperator = '+';
        }
        break;

        case TRC_LEVEL_NRM:
        {
            fieldSeperator = ' ';
        }
        break;

        case TRC_LEVEL_DBG:
        {
            fieldSeperator = ' ';
        }
        break;

        case TRC_PROFILE_TRACE:
        {
            fieldSeperator = ' ';
        }
        break;

        default:
        {
            fieldSeperator = '?';
        }
        break;
    }

    /************************************************************************/
    /* Get the current process and thread Ids.                              */
    /************************************************************************/
    processId = TRCGetCurrentProcessId();
    threadId  = TRCGetCurrentThreadId();

    /************************************************************************/
    /* Build the string to be printed out.  First of all get the current    */
    /* time.                                                                */
    /************************************************************************/
    TRCGetCurrentTime(&theTime);

    /************************************************************************/
    /* Now format the string.  Note that the function name is of variable   */
    /* length and given by <trcpConfig->funcNameLength>.                    */
    /************************************************************************/

    /************************************************************************/
    /* Go through each optional field and decide whether to add it to the   */
    /* string or not.  They are:                                            */
    /* TRC_OPT_PROCESS_ID                                                   */
    /* TRC_OPT_THREAD_ID                                                    */
    /* TRC_OPT_TIME_STAMP                                                   */
    /* TRC_OPT_RELATIVE_TIME_STAMP                                          */
    /************************************************************************/
    if (TEST_FLAG(trcpConfig->flags, TRC_OPT_TIME_STAMP))
    {
        hr = StringCchPrintf(
            tempString,
            SIZE_TCHARS(tempString),
            TRC_TIME_FMT _T("%c"),
            theTime.hour,
            theTime.min,
            theTime.sec,
            theTime.hundredths,
            fieldSeperator
            );
        if (SUCCEEDED(hr)) {
            hr = StringCchCat(frmtString, SIZE_TCHARS(frmtString), tempString);
            if (FAILED(hr)) {
                DC_QUIT;
            }
        }
        else {
            DC_QUIT;
        }
    }

    if (TEST_FLAG(trcpConfig->flags, TRC_OPT_PROCESS_ID))
    {
        hr = StringCchPrintf(tempString,
                             SIZE_TCHARS(tempString),
                             TRC_PROC_FMT,
                             processId);
        if (SUCCEEDED(hr)) {
            hr = StringCchCat(frmtString, SIZE_TCHARS(frmtString), tempString);
            if (FAILED(hr)) {
                DC_QUIT;
            }
        }
        else {
            DC_QUIT;
        }
    }

#ifdef OS_WIN32
    if (TEST_FLAG(trcpConfig->flags, TRC_OPT_THREAD_ID))
    {
        /********************************************************************/
        /* Always put the colon before the thread ID so that, when only one */
        /* of the IDs is present, it is clear which it is.                  */
        /********************************************************************/
        hr = StringCchPrintf(tempString,
                             SIZE_TCHARS(tempString),
                             _T(":") TRC_THRD_FMT,
                             threadId);
        if (SUCCEEDED(hr)) {
            hr = StringCchCat(frmtString, SIZE_TCHARS(frmtString), tempString);
            if (FAILED(hr)) {
                DC_QUIT;
            }
        }
        else {
            DC_QUIT;
        }
    }
#endif

#ifdef DC_OMIT
    if (TEST_FLAG(trcpConfig->flags, TRC_OPT_RELATIVE_TIME_STAMP))
    {
        /********************************************************************/
        /* @@@ SJ - 090297                                                  */
        /* The idea is to show some low-order portion of the timestamp      */
        /* relative to the start time, in order to track timing issues.     */
        /********************************************************************/
    }
#endif

    hr = StringCchPrintf(tempString,
                         SIZE_TCHARS(tempString),
                         _T("%c") TRC_FUNC_FMT _T("%c") TRC_LINE_FMT _T("%c%s"),
                         fieldSeperator,
                         (DCINT)trcpConfig->funcNameLength,
                         (DCINT)trcpConfig->funcNameLength,
                         funcName,
                         fieldSeperator,
                         lineNumber,
                         fieldSeperator,
                         trcpOutputBuffer);
    if (SUCCEEDED(hr)) {
        hr = StringCchCat(frmtString, SIZE_TCHARS(frmtString), tempString);
        if (FAILED(hr)) {
            DC_QUIT;
        }
    }
    else {
        DC_QUIT;
    }

    /************************************************************************/
    /* Add CR:LF to the end and update the length of the string.            */
    /************************************************************************/
    hr = StringCchCat(frmtString, SIZE_TCHARS(frmtString), TRC_CRLF);
    if (FAILED(hr)) {
        DC_QUIT;
    }

    length = DC_TSTRLEN(frmtString) * sizeof(DCTCHAR);

    /************************************************************************/
    /* Now that we have got the trace string, we need to write it out.      */
    /************************************************************************/
    TRCOutput(frmtString, length, traceLevel);

    /************************************************************************/
    /* If this is an assert trace then we need to reformat the string for   */
    /* use in the assert box.  We must do this before we release the        */
    /* mutex.                                                               */
    /************************************************************************/
    hr = StringCchPrintf(frmtString,
                         SIZE_TCHARS(frmtString),
                         TRC_ASSERT_TEXT,
                         trcpOutputBuffer,
                         funcName,
                         fileName,
                         lineNumber);
    if (FAILED(hr)) {
        DC_QUIT;
    }

    /************************************************************************/
    /* Decide if we need to do a stack trace.  We must do this after        */
    /* reformating the string as we use the shared trace buffer - if we     */
    /* don't then we'll overwrite the original trace string!                */
    /************************************************************************/
    if ((traceLevel >= TRC_LEVEL_ERR) && (traceLevel != TRC_PROFILE_TRACE))
    {
        TRCStackTrace(traceLevel);
    }

DC_EXIT_POINT:

    /************************************************************************/
    /* Release the mutex.                                                   */
    /************************************************************************/
    TRCReleaseMutex();

    /************************************************************************/
    /* Now display the assert box - if an assert is already displayed then  */
    /* <TRCDisplayAssertBox> will just return.                              */
    /************************************************************************/
    if (TRC_LEVEL_ASSERT == traceLevel)
    {
        if (TEST_FLAG(trcpConfig->flags, TRC_OPT_BREAK_ON_ASSERT))
        {
            //
            // Break on assert so that we can actually get to see the assert
            // in situations like stress where the user may not be
            // watching for popups.
            //
            DebugBreak();
        }
        else
        {
            TRCDisplayAssertBox(frmtString);
        }
    }

    /************************************************************************/
    /* If this was an error level trace then we need to decide if we        */
    /* should beep, and then if we should break into the debugger.          */
    /************************************************************************/
    if (TRC_LEVEL_ERR == traceLevel)
    {
        /********************************************************************/
        /* Test if we should beep.                                          */
        /********************************************************************/
        if (TEST_FLAG(trcpConfig->flags, TRC_OPT_BEEP_ON_ERROR))
        {
            TRCBeep();
        }

        /********************************************************************/
        /* Test if we should break into the debugger.  Note that we have    */
        /* released the mutex, so other processes can continue to trace.    */
        /********************************************************************/
        if (TEST_FLAG(trcpConfig->flags, TRC_OPT_BREAK_ON_ERROR))
        {
            TRCDebugBreak();
        }
    }

} /* TRC_TraceBuffer */


/**PROC+*********************************************************************/
/* TRC_GetConfig(...)                                                       */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCBOOL DCAPI DCEXPORT TRC_GetConfig(PTRC_CONFIG pTraceConfig,
                                    DCUINT length)
{
    DCBOOL rc                = TRUE;

    /************************************************************************/
    /* Check to ensure that the current state is valid.  If it is not then  */
    /* just quit.                                                           */
    /************************************************************************/
    if ( trcpConfig == NULL )
    {
        TRCOpenSharedData();
    }
    else
    {
        TRCReadSharedDataConfig();
    }

    /************************************************************************/
    /* Copy information from fixed structure to callers structure.          */
    /************************************************************************/
    DC_MEMCPY(pTraceConfig,
              trcpConfig,
              DC_MIN(length, sizeof(TRC_CONFIG)));

DC_EXIT_POINT:
    return(rc);

} /* TRC_GetConfig */


/**PROC+*********************************************************************/
/* TRC_SetConfig(...)                                                       */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCBOOL DCAPI DCEXPORT TRC_SetConfig(PTRC_CONFIG pTraceConfig,
                                    DCUINT length)
{
    DCBOOL   rc              = TRUE;
    DCUINT   i;
    DCUINT32 maxFileSize;
    DCTCHAR  fileNames[TRC_NUM_FILES][TRC_FILE_NAME_SIZE];
    HRESULT  hr;

    /************************************************************************/
    /* Check to ensure that the current state is valid.  If it is not then  */
    /* just quit.                                                           */
    /************************************************************************/
    if ( trcpConfig == NULL )
    {
        TRCOpenSharedData();
    }
    else
    {
        TRCReadSharedDataConfig();
    }

    /************************************************************************/
    /* We do not support dynamic modification of the maximum trace file     */
    /* size or of the trace file names.  Therefore we store these before a  */
    /* change and overwrite the new values to ensure that they do not       */
    /* change.                                                              */
    /************************************************************************/
    maxFileSize = trcpConfig->maxFileSize;
    for (i = 0; i < TRC_NUM_FILES; i++)
    {
        StringCchCopy(fileNames[i], TRC_FILE_NAME_SIZE,
                      trcpConfig->fileNames[i]);
    }

    /************************************************************************/
    /* Copy information from fixed structure to callers structure.          */
    /************************************************************************/
    DC_MEMCPY(trcpConfig,
              pTraceConfig,
              DC_MIN(length, sizeof(TRC_CONFIG)));

    /************************************************************************/
    /* Now restore the maximum trace file size and the trace file names.    */
    /************************************************************************/
    trcpConfig->maxFileSize = maxFileSize;
    for (i = 0; i < TRC_NUM_FILES; i++)
    {
        StringCchCopy(trcpConfig->fileNames[i],
                      SIZE_TCHARS(trcpConfig->fileNames[i]),
                      fileNames[i]);
    }

    /************************************************************************/
    /* Split the prefix list.                                               */
    /************************************************************************/
    TRCSplitPrefixes();

    /************************************************************************/
    /* Store the new configuration data.                                    */
    /************************************************************************/
    TRCWriteSharedDataConfig();

DC_EXIT_POINT:
    return(rc);

} /* TRC_SetConfig */


/**PROC+*********************************************************************/
/* TRC_TraceData(...)                                                       */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCVOID DCAPI DCEXPORT TRC_TraceData(DCUINT   traceLevel,
                                    DCUINT   traceComponent,
                                    DCUINT   lineNumber,
                                    PDCTCHAR funcName,
                                    PDCTCHAR fileName,
                                    PDCUINT8 buffer,
                                    DCUINT   bufLength)
{
    DCUINT i;

    /************************************************************************/
    /* If the trace checks fail then exit immediately.                      */
    /************************************************************************/
    if (!TRCShouldTraceThis(traceComponent, traceLevel, fileName, lineNumber))
    {
        /********************************************************************/
        /* Don't bother tracing this data.                                  */
        /********************************************************************/
        DC_QUIT;
    }

    /************************************************************************/
    /* Truncate the length, if necessary.                                   */
    /************************************************************************/
    if (bufLength > trcpConfig->dataTruncSize)
    {
        bufLength = (DCUINT)trcpConfig->dataTruncSize;
    }

    /************************************************************************/
    /* TRC_TraceBuffer will decrement the mutex usage count for us - so we  */
    /* need to pre-increment it before calling TRC_BufferTrace.  This       */
    /* ensures that we still have the mutex when we come to trace the data  */
    /* out.                                                                 */
    /************************************************************************/
    TRCGrabMutex();

    /************************************************************************/
    /* Now trace out the description string.                                */
    /************************************************************************/
    TRC_TraceBuffer(traceLevel,
                    traceComponent,
                    lineNumber,
                    funcName,
                    fileName);

    /************************************************************************/
    /* Now trace the data portion.                                          */
    /************************************************************************/
    for (i = 0; (i + 15) < bufLength; i += 16)
    {
        TRCDumpLine(buffer, 16, i, traceLevel);
        buffer += 16;
    }

    /************************************************************************/
    /* Check to see if we have a partial line to output.                    */
    /************************************************************************/
    if ((bufLength%16) > 0)
    {
        /********************************************************************/
        /* Do partial line last.                                            */
        /********************************************************************/
        TRCDumpLine(buffer, (bufLength%16), i, (DCUINT)traceLevel);
    }

DC_EXIT_POINT:

    /************************************************************************/
    /* Finally free the mutex.                                              */
    /************************************************************************/
    TRCReleaseMutex();

    return;

} /* TRC_TraceData */


/**PROC+*********************************************************************/
/* TRC_GetTraceLevel(...)                                                   */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCUINT DCAPI DCEXPORT TRC_GetTraceLevel(DCVOID)
{
    DCUINT32 rc = TRC_LEVEL_DIS;

    /************************************************************************/
    /* Check to ensure that the current state is valid.  If it is not then  */
    /* just quit.                                                           */
    /************************************************************************/
    if (!TRCCheckState())
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* Get the current trace level.                                         */
    /************************************************************************/
    rc = trcpConfig->traceLevel;

DC_EXIT_POINT:
    return((DCUINT)rc);

} /* TRC_GetTraceLevel */


/**PROC+*********************************************************************/
/* TRC_ProfileTraceEnabled                                                  */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCBOOL DCAPI DCEXPORT TRC_ProfileTraceEnabled(DCVOID)
{
    DCBOOL prfTrace = FALSE;

    /************************************************************************/
    /* Check to ensure that the current state is valid.  If it is not then  */
    /* just quit.                                                           */
    /************************************************************************/
    if (!TRCCheckState())
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* Get the setting of the flag and return TRUE if function profile      */
    /* tracing is supported.                                                */
    /************************************************************************/
    prfTrace = TEST_FLAG(trcpConfig->flags, TRC_OPT_PROFILE_TRACING);

DC_EXIT_POINT:
    return(prfTrace);

} /* TRC_ProfileTraceEnabled */


/**PROC+*********************************************************************/
/* TRC_ResetTraceFiles                                                      */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCBOOL DCAPI DCEXPORT TRC_ResetTraceFiles(DCVOID)
{
    DCBOOL rc = TRUE;

    /************************************************************************/
    /* Check to ensure that the current state is valid.  If it is not then  */
    /* just quit.                                                           */
    /************************************************************************/
    if (!TRCCheckState())
    {
        rc = FALSE;
        DC_QUIT;
    }

    /************************************************************************/
    /* Grab the mutex.                                                      */
    /************************************************************************/
    TRCGrabMutex();

    /************************************************************************/
    /* Call the OS specific function to reset the trace files.              */
    /************************************************************************/
    TRCResetTraceFiles();

    /************************************************************************/
    /* Release the mutex.                                                   */
    /************************************************************************/
    TRCReleaseMutex();

DC_EXIT_POINT:
    return(rc);

} /* TRC_ResetTraceFiles */

//
// Sprintf that will take care of truncating to the trace buffer size
//
#ifndef TRC_SAFER_SPRINTF
#define TRC_SAFER_SPRINTF
VOID TRCSaferSprintf(PDCTCHAR outBuf, UINT cchLen, const PDCTCHAR format,...)
{
    HRESULT hr;
    va_list vaArgs;

    va_start(vaArgs, format);

    hr = StringCchVPrintf(outBuf,
                          cchLen,
                          format,
                          vaArgs);
    va_end(vaArgs);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\ntrcint.c ===
/****************************************************************************/
/* ntrcint.c                                                                */
/*                                                                          */
/* Internal tracing functions - Windows NT specific                         */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1998                             */
/****************************************************************************/

#include <adcg.h>

/****************************************************************************/
/* Define TRC_FILE and TRC_GROUP.                                           */
/****************************************************************************/
#undef TRC_FILE
#define TRC_FILE    "ntrcint"
#define TRC_GROUP   TRC_GROUP_TRACE

/****************************************************************************/
/* Trace specific includes.                                                 */
/****************************************************************************/
#include <atrcapi.h>
#include <atrcint.h>
#ifndef OS_WINCE
#include <imagehlp.h>
#endif

#include <ndcgver.h>

/****************************************************************************/
/*                                                                          */
/* DATA                                                                     */
/*                                                                          */
/****************************************************************************/
#define DC_INCLUDE_DATA
#include <atrcdata.c>
#undef DC_INCLUDE_DATA

/****************************************************************************/
/*                                                                          */
/* FUNCTIONS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* FUNCTION: DllMain(...)                                                   */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Entry/exit point for the trace DLL.  This function is called whenever a  */
/* process or thread attaches or detaches from this DLL.                    */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* hModule         : a module handle.                                       */
/* reasonForCall   : an enumerated type that indicates which of the four    */
/*                   reasons the DLLMain function is being called: process  */
/*                   attach, thread attach, thread detach or process        */
/*                   detach.                                                */
/* lpReserved      : unused.                                                */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* TRUE if the attachment succeeds and FALSE otherwise.                     */
/*                                                                          */
/****************************************************************************/
#ifndef STATICONLY
int APIENTRY DllMain(HANDLE hModule,
                     DWORD  reasonForCall,
                     LPVOID lpReserved)
{
    DCBOOL  retValue         = TRUE;
    DCUINT  rc               = 0;

    DC_IGNORE_PARAMETER(lpReserved);
#ifdef OS_WINCE
    DC_IGNORE_PARAMETER(hModule);
#endif // OS_WINCE

    /************************************************************************/
    /* Determine the reason for the call.  Note that anything we do in here */
    /* is thread safe as we implicitly have the process critical section.   */
    /************************************************************************/

    switch (reasonForCall)
    {
#ifndef OS_WINCE
        /********************************************************************/
        /* A process is attaching to this DLL.                              */
        /********************************************************************/
        case DLL_PROCESS_ATTACH:
        {
            /****************************************************************/
            /* Call the internal function to initialize the trace DLL.      */
            /* This function sets up the memory mapped shared data, and     */
            /* opens and initializes the trace files.  It may be called     */
            /* either via a process attach or by the first person to call   */
            /* the trace DLL.  The latter case can only occur if another    */
            /* DLL performs trace calls in its <DllMain> function and that  */
            /* DLLs <DllMain> function is called before the trace DLLs      */
            /* <DllMain> function (i.e. this function!).                    */
            /****************************************************************/
            rc = TRC_Initialize(TRUE);

            if (0 != rc)
            {
                retValue = FALSE;
                DC_QUIT;
            }

            /****************************************************************/
            /* Save the module handle.                                      */
            /****************************************************************/
            trchModule = hModule;

            /****************************************************************/
            /* Get the trace DLL module file name.  We use this later when  */
            /* we get a stack trace.                                        */
            /****************************************************************/
            if ( TRCGetModuleFileName(
                        trcpSharedData->trcpModuleFileName,
                        SIZE_TCHARS(trcpSharedData->trcpModuleFileName)) !=
                        DC_RC_OK )
            {
                retValue = FALSE;
                DC_QUIT;
            }

            /****************************************************************/
            /* A process is attaching so trace this fact out.               */
            /****************************************************************/
            TRCInternalTrace(TRC_PROCESS_ATTACH_NOTIFY);
        }
        break;

        /********************************************************************/
        /* A process is detaching from this DLL.                            */
        /********************************************************************/
        case DLL_PROCESS_DETACH:
        {
            /****************************************************************/
            /* Write out the process detach trace line.                     */
            /****************************************************************/
            TRCInternalTrace(TRC_PROCESS_DETACH_NOTIFY);

            /****************************************************************/
            /* Call the trace DLL termination function.  This will close    */
            /* all files, free the shared data and then close the mutex     */
            /* handle.                                                      */
            /****************************************************************/
            TRC_Terminate(TRUE);
        }
        break;

        /********************************************************************/
        /* A thread is attaching to this DLL.                               */
        /********************************************************************/
        case DLL_THREAD_ATTACH:
        {
            /****************************************************************/
            /* Write out the thread attach trace line.                      */
            /****************************************************************/
            TRCInternalTrace(TRC_THREAD_ATTACH_NOTIFY);
        }
        break;

        /********************************************************************/
        /* A thread is detaching from this DLL.                             */
        /********************************************************************/
        case DLL_THREAD_DETACH:
        {
            /****************************************************************/
            /* Write out the thread detach trace line.                      */
            /****************************************************************/
            TRCInternalTrace(TRC_THREAD_DETACH_NOTIFY);
        }
        break;
#endif // OS_WINCE
    }

    /************************************************************************/
    /* Now return the appropriate return value.  NT currently only checks   */
    /* the value for the DLL_PROCESS_ATTACH case - if it is false then the  */
    /* app will fail to initialize.                                         */
    /************************************************************************/
DC_EXIT_POINT:
    return(retValue);

} /* DllMain */
#endif


/****************************************************************************/
/* FUNCTION: TRCBlankFile(...)                                              */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function fills the specified trace file with spaces.                */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* fileNumber      : which file to blank.                                   */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCBlankFile(DCUINT fileNumber)
{
    /************************************************************************/
    /* Use DC_MEMSET to fill the file with spaces.                          */
    /************************************************************************/
    DC_MEMSET(trcpFiles[fileNumber], '\0', trcpConfig->maxFileSize);

    /************************************************************************/
    /* Finally flush this change to disk.  Setting the second parameter to  */
    /* zero flushes the whole file to disk.                                 */
    /************************************************************************/
    FlushViewOfFile(trcpFiles[fileNumber], 0);

    return;

} /* TRC_BlankFile */


/****************************************************************************/
/* FUNCTION: TRCCloseSharedData(...)                                        */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function closes the shared data memory mapped file.                 */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCCloseSharedData(DCVOID)
{
    /************************************************************************/
    /* Now we need to unmap our view of the file.                           */
    /************************************************************************/
    UnmapViewOfFile(trcpSharedData);
    trcpSharedData = NULL;

    /************************************************************************/
    /* Now close the handle to the file mapping object.                     */
    /************************************************************************/
    CloseHandle(trchSharedDataObject);
    trchSharedDataObject = NULL;

    /************************************************************************/
    /* NULL our static pointer to the shared configuration data.            */
    /************************************************************************/
    trcpConfig = NULL;

    /************************************************************************/
    /* That's it so just return.                                            */
    /************************************************************************/
    return;

} /* TRCCloseSharedData */


/****************************************************************************/
/* FUNCTION: TRCCloseSingleFile(...)                                        */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Closes a single trace memory mapped file.                                */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* fileNumber    : which file to close.                                     */
/* seconds       : value to set the seconds time stamp of the file to.      */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCCloseSingleFile(DCUINT fileNumber, DCUINT seconds)
{
    FILETIME   fileTime;
    SYSTEMTIME systemTime;
    DCUINT32   offset;

    /************************************************************************/
    /* We need to reset the size of this file - we do this by determining   */
    /* the trace file offset.  Make sure that we do this before we unmap    */
    /* the file.                                                            */
    /************************************************************************/
    offset = TRCDetermineOffset(fileNumber);

    /************************************************************************/
    /* Unmap the view of the file.                                          */
    /************************************************************************/
    UnmapViewOfFile(trcpFiles[fileNumber]);
    trcpFiles[fileNumber] = NULL;

    /************************************************************************/
    /* Free up the handle to the file mapping object.                       */
    /************************************************************************/
    CloseHandle(trchMappingObjects[fileNumber]);
    trchMappingObjects[fileNumber] = NULL;

    /************************************************************************/
    /* Now set the file pointer to the end of all the trace text and then   */
    /* set the end of the file to this position.                            */
    /************************************************************************/
    SetFilePointer(trchFileObjects[fileNumber],
                   offset,
                   NULL,
                   FILE_BEGIN);

    SetEndOfFile(trchFileObjects[fileNumber]);

    /************************************************************************/
    /* Now we have to do something a little messy - the file time is not    */
    /* properly updated when the memory mapped file is closed and we rely   */
    /* on the file time to decide which file to start tracing to at the     */
    /* start of day.  Therefore we need to force the system to update the   */
    /* file times using SetFileTime (we set the created, modified and       */
    /* accessed times).  On NT4.0 this does not guarantee that the times    */
    /* are the same - one file had a created time of 16:35:16 and a         */
    /* modified time of 16:35:18 after a call to SetFileTime!  Files only   */
    /* have a time resolution of two seconds if they are stored on a FAT    */
    /* partition by NT.                                                     */
    /************************************************************************/
    GetSystemTime(&systemTime);

    /************************************************************************/
    /* Set the number of seconds of the file.                               */
    /************************************************************************/
    systemTime.wSecond = (WORD) seconds;

    /************************************************************************/
    /* Now convert the system time to a file time and update the file time. */
    /************************************************************************/
    SystemTimeToFileTime(&systemTime, &fileTime);
    SetFileTime(trchFileObjects[fileNumber], &fileTime, &fileTime, &fileTime);

    /************************************************************************/
    /* Close the file handle.                                               */
    /************************************************************************/
    CloseHandle(trchFileObjects[fileNumber]);
    trchFileObjects[fileNumber] = NULL;

    return;

} /* TRCCloseSingleFile */


/****************************************************************************/
/* FUNCTION: TRCDetermineIndicator(...)                                     */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function sets the trace file indicator as follows:                  */
/*                                                                          */
/* - No trace files exist    : indicator set to 0                           */
/* - One trace file exists   : indicator set to the existing file (0 or 1)  */
/* - Both trace files exist  : indicator set to the newer file.             */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCDetermineIndicator(DCVOID)
{
    DCINT    i;
    DCBOOL   rc[TRC_NUM_FILES];
    DCINT32  tdRC;
    FILETIME fileTime[TRC_NUM_FILES];

    /************************************************************************/
    /* We also need to set up the trace file indicator.  By default we use  */
    /* trace file 0.                                                        */
    /************************************************************************/
    trcpSharedData->trcIndicator = 0;

    /************************************************************************/
    /* Determine the most recent trace file.  Use GetFileTime to get the    */
    /* date and time of this file.                                          */
    /************************************************************************/
    for (i = 0; i < TRC_NUM_FILES; i++)
    {
        rc[i] = TRCGetFileTime(i, &(fileTime[i]));
    }

    /************************************************************************/
    /* Now check to see which file we should return based on the following  */
    /* options:                                                             */
    /*                                                                      */
    /* Ŀ                        */
    /*  File 0 exists   File 1 exists   return                          */
    /* Ĵ                        */
    /*      No              No          file 0                          */
    /*      No              Yes         file 1                          */
    /*      Yes             Yes         compare                         */
    /*      Yes             No          file 0                          */
    /*                         */
    /************************************************************************/
    /************************************************************************/
    /* If file 1 does not exist then we return file 0 regardless.           */
    /************************************************************************/
    if (FALSE == rc[1])
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* If file 0 does not exist and file 1 does, then return file 1.        */
    /************************************************************************/
    if ((FALSE == rc[0]) && (TRUE == rc[1]))
    {
        trcpSharedData->trcIndicator = 1;
        DC_QUIT;
    }

    /************************************************************************/
    /* If we have got this far then both trace files exist so we need to    */
    /* make a decision based on their ages.  User the Win32 CompareFileTime */
    /* function to do this.                                                 */
    /************************************************************************/
    tdRC = CompareFileTime(&(fileTime[0]), &(fileTime[1]));

    /************************************************************************/
    /* If the file times are equal or the first file is newer than the      */
    /* second then select file 0 (i.e.  just quit).                         */
    /************************************************************************/
    if (tdRC >= 0)
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* If we get here then file 1 is newer than file 0 so set the indicator */
    /* to file 1.                                                           */
    /************************************************************************/
    trcpSharedData->trcIndicator = 1;

DC_EXIT_POINT:
    return;

} /* TRCDetermineIndicator */


/****************************************************************************/
/* FUNCTION: TRCDetermineOffset(...)                                        */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function determines the end-of-file offset in the selected trace    */
/* file.                                                                    */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* fileNum       : the number of the file to determine the offset for.      */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* The offset in that file.                                                 */
/*                                                                          */
/****************************************************************************/
DCUINT32 DCINTERNAL TRCDetermineOffset(DCUINT32 fileNum)
{
    DCUINT32 retVal;
    PDCTCHAR pTemp;
    PDCUINT8 pWork;

    /************************************************************************/
    /* Set the temporary pointer to point at the end of the trace file.     */
    /************************************************************************/
    pWork = (PDCUINT8)(trcpFiles[fileNum]);
    if(NULL == pWork)
    {
        return 0;
    }
    pWork += trcpConfig->maxFileSize - sizeof(DCTCHAR);
    pTemp = (PDCTCHAR)pWork;

    /************************************************************************/
    /* Now run back through the trace file looking for the first non-space  */
    /* character.                                                           */
    /************************************************************************/
    while ((pTemp >= trcpFiles[fileNum]) &&
           (_T('\0') == *pTemp))
    {
        pTemp--;
    }

    /************************************************************************/
    /* Increment forward to the next blank character.  It does not matter   */
    /* if we increment past the end of the file as we check whether we need */
    /* to flip the trace files everytime we write a trace line.             */
    /************************************************************************/
    pTemp++;

    /************************************************************************/
    /* Now set the offset correctly.                                        */
    /************************************************************************/
    retVal = (DCUINT32)(pTemp - trcpFiles[fileNum]);

    return(retVal);

} /* TRCDetermineOffset */


/****************************************************************************/
/* FUNCTION: TRCExitProcess(...)                                            */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function kills the current process.                                 */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* exitCode        : exit code for the terminating process                  */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCExitProcess(DCUINT32 exitCode)
{
#ifndef OS_WINCE
    ExitProcess(exitCode);
#else
    //BUGBUG this is broken if not called from the main
    //thread.
    ExitThread(exitCode);
#endif
}


/****************************************************************************/
/* FUNCTION: TRCGetCurrentDate(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function gets the current local date and returns it in a DC_DATE    */
/* structure.                                                               */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pDate           : a pointer to a DC_DATE structure.                      */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCGetCurrentDate(PDC_DATE pDate)
{
    SYSTEMTIME systemTime;

    /************************************************************************/
    /* Call the Win32 API function to get the current time.                 */
    /************************************************************************/
    GetLocalTime(&systemTime);

    /************************************************************************/
    /* Reformat the date into a DC_DATE structure.                          */
    /************************************************************************/
    pDate->day   = (DCUINT8)  systemTime.wDay;
    pDate->month = (DCUINT8)  systemTime.wMonth;
    pDate->year  = (DCUINT16) systemTime.wYear;

} /* TRCGetCurrentDate */


/****************************************************************************/
/* FUNCTION: TRCGetCurrentTime(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function gets the current local time and returns it in a DC_TIME    */
/* structure.                                                               */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pTime           : a pointer to a DC_TIME structure.                      */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCGetCurrentTime(PDC_TIME pTime)
{
    SYSTEMTIME systemTime;

    /************************************************************************/
    /* Call the Win32 API function to get the current time.                 */
    /************************************************************************/
    GetLocalTime(&systemTime);

    /************************************************************************/
    /* Reformat the time into a DC_TIME structure.                          */
    /************************************************************************/
    pTime->hour       = (DCUINT8)systemTime.wHour;
    pTime->min        = (DCUINT8)systemTime.wMinute;
    pTime->sec        = (DCUINT8)systemTime.wSecond;
    pTime->hundredths = (DCUINT8)(systemTime.wMilliseconds / 10);

} /* TRCGetCurrentTime */


/****************************************************************************/
/* FUNCTION: TRCGetFileTime(...)                                            */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function tests if the specified file exists - if it does it         */
/* returns TRUE and fills in pFileTime with a FILETIME structure.  If the   */
/* file does not exist it returns FALSE.                                    */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* fileNumber      : number of file to query.                               */
/* pFileTime       : a pointer to a FILETIME structure.                     */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCBOOL DCINTERNAL TRCGetFileTime(DCUINT      fileNumber,
                                 PDCFILETIME pFileTime)
{
    DCBOOL        rc           = FALSE;
    HANDLE        hFile;

    /************************************************************************/
    /* Attempt to open the file.  By specifying OPEN_EXISITING, we only try */
    /* to open an existing file - the call will fail if the file doesn't    */
    /* already exist.                                                       */
    /************************************************************************/
    hFile = CreateFile(trcpConfig->fileNames[fileNumber],
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    /************************************************************************/
    /* Now check to see if the file exists - if it is invalid then the file */
    /* doesn't exist.                                                       */
    /************************************************************************/
    if (INVALID_HANDLE_VALUE == hFile)
    {
        /********************************************************************/
        /* The file doesn't exist so return FALSE.                          */
        /********************************************************************/
        DC_QUIT;
    }

    /************************************************************************/
    /* Determine the most recent trace file.  Use GetFileTime to get the    */
    /* date and time of this file.                                          */
    /************************************************************************/
    rc = GetFileTime(hFile, NULL, NULL, pFileTime);

    /************************************************************************/
    /* Finally close the file handle.                                       */
    /************************************************************************/
    CloseHandle(hFile);

DC_EXIT_POINT:
    return(rc);

} /* TRCGetFileTime */


/****************************************************************************/
/* FUNCTION: TRCSystemError(...)                                            */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function obtains the value of the system error flag and outputs it  */
/* to the trace file as an alert level trace.                               */
/*                                                                          */
/* Note that NT maintains the last system error on a per-thread basis and   */
/* that most Win32 API function calls set it if they fail.                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* traceComponent : the trace component.                                    */
/* lineNumber     : the line number.                                        */
/* funcName       : the function name.                                      */
/* fileName       : the file name.                                          */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCSystemError(DCUINT   traceComponent,
                                 DCUINT   lineNumber,
                                 PDCTCHAR funcName,
                                 PDCTCHAR fileName,
                                 PDCTCHAR string)
{
    DCUINT32 length;
    DWORD    lastError;
    DWORD    rc;
    HRESULT  hr;

    /************************************************************************/
    /* Get the last system error for this thread.  We will restore this at  */
    /* the end of this function.                                            */
    /************************************************************************/
    lastError = GetLastError();

    /************************************************************************/
    /* Grab the mutex.                                                      */
    /************************************************************************/
    TRCGrabMutex();

    /************************************************************************/
    /* The output string will be of the format:                             */
    /*                                                                      */
    /* SYSTEM ERROR in <System Call>, <id of error> , <associated string>   */
    /*                                                                      */
    /* So create the first entry in the string.                             */
    /************************************************************************/
    hr = StringCchPrintf(trcpOutputBuffer,
                         TRC_LINE_BUFFER_SIZE,
                         _T("SYSTEM ERROR in %s, %d, "),
                         string,
                         lastError);
    if (SUCCEEDED(hr)) {
        length = DC_TSTRLEN(trcpOutputBuffer);
        rc = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL,
                           lastError,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           &(trcpOutputBuffer[length]),
                           TRC_LINE_BUFFER_SIZE - length * sizeof(DCTCHAR),
                           NULL);
    }
    else {
        DC_QUIT;
    }


    /************************************************************************/
    /* Check the return code.                                               */
    /************************************************************************/
    if (0 == rc)
    {
        hr = StringCchPrintf(trcpOutputBuffer + length,
                             TRC_LINE_BUFFER_SIZE - length -1,
                            _T("<FormatMessage> failed with rc %#hx"),
                            GetLastError());
        if (FAILED(hr)) {
            DC_QUIT;
        }
    }
    else
    {
        /********************************************************************/
        /* <FormatMessage> adds an additional '\r\n' to the end of the      */
        /* message string - however we don't need this so we strip it off.  */
        /********************************************************************/
        length = DC_TSTRLEN(trcpOutputBuffer);
        trcpOutputBuffer[length - 2] = _T('\0');
    }

    /************************************************************************/
    /* Now call our internal trace buffer function to trace this message    */
    /* out.  Note that we don't need to worry about freeing the mutex -     */
    /* <TRC_TraceBuffer> will do that for us.                               */
    /************************************************************************/
    TRC_TraceBuffer(TRC_LEVEL_ALT,
                    traceComponent,
                    lineNumber,
                    funcName,
                    fileName);

DC_EXIT_POINT:

    /************************************************************************/
    /* Finally we will restore the original value of last error.            */
    /************************************************************************/
    SetLastError(lastError);
    

    return;

} /* TRCSystemError */


/****************************************************************************/
/* FUNCTION: TRCOpenAllFiles(...)                                           */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Opens all the trace files.                                               */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0             : Function succeeded.                                      */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCOpenAllFiles(DCVOID)
{
    DCUINT rc                = 0;
    DCUINT i;
    DCUINT j;

    /************************************************************************/
    /* Now if we are the first process to attach then set up the trace      */
    /* indicator.  This tells us which file is currently active (i.e.       */
    /* being used for trace output).  We need to do this before we open the */
    /* files as if they both exist already, they will both be created.      */
    /* File 2 will be created after file 1 and as we trace to the most      */
    /* recent file we will end up tracing to file 2 - and you don't want to */
    /* do that!                                                             */
    /************************************************************************/
    if (trcCreatedTraceFiles)
    {
        TRCDetermineIndicator();
    }

    /************************************************************************/
    /* Open all the trace output files.                                     */
    /************************************************************************/
    for (i = 0; i < TRC_NUM_FILES; i++)
    {
        /********************************************************************/
        /* Call TRCOpenSingleFile to open a single trace file.              */
        /********************************************************************/
        rc = TRCOpenSingleFile(i);

        if (0 != rc)
        {
            DC_QUIT;
        }
    }

    /************************************************************************/
    /* Finally, if we are the first process to attach, then set up the      */
    /* trace offset.  This is the offset within the currently active trace  */
    /* file.                                                                */
    /************************************************************************/
    if (trcCreatedTraceFiles)
    {
        trcpSharedData->trcOffset =
                             TRCDetermineOffset(trcpSharedData->trcIndicator);
    }

DC_EXIT_POINT:

    if (0 != rc)
    {
        /********************************************************************/
        /* Close any files that we may already have opened.  We do not need */
        /* to call TRCCloseSingleFile for the file which failed to open     */
        /* correctly as TRCOpenSingleFile will tidy up that file for us.    */
        /********************************************************************/
        for (j = i; j > 0; j--)
        {
            TRCCloseSingleFile(j - 1, 0);
        }

        /********************************************************************/
        /* Clear the trace-to-file flag - we can't do it.                   */
        /********************************************************************/
        CLEAR_FLAG(trcpConfig->flags, TRC_OPT_FILE_OUTPUT);
    }

    /************************************************************************/
    /* Always return 0 to allow tracing to continue to the debugger.        */
    /************************************************************************/
    return(0);

} /* TRCOpenAllFiles */


/****************************************************************************/
/* FUNCTION: TRCOpenSharedData(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function opens the shared data memory mapped file.                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0                            : Function succeeded                        */
/* TRC_RC_CREATE_MAPPING_FAILED : Failed to create the file mapping         */
/* TRC_RC_MAP_VIEW_FAILED       : MapViewOfFile failed.                     */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCOpenSharedData(DCVOID)
{
    DCUINT rc                = 0;
#ifdef RUN_ON_WINNT
    DWORD  dwrc;
#endif

#ifndef OS_WINCE
    OSVERSIONINFO ver;
    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;
    PSID psidEveryone = NULL;
    SID_IDENTIFIER_AUTHORITY sidEveryoneAuthority = SECURITY_WORLD_SID_AUTHORITY;
    DCUINT32 dwDaclLength;
    PACL pDacl = NULL;
#endif
    /************************************************************************/
    /* Attempt to create the shared data memory mapped file.  If this has   */
    /* already been created by another instance of this DLL then            */
    /* CreateFileMapping will simply return the handle of the existing      */
    /* object.  Passing 0xFFFFFFFF creates a shared data memory mapped      */
    /* file.                                                                */
    /************************************************************************/

#ifdef OS_WINCE
    /************************************************************************/
    /* For Windows CE, just use global data; always reset it.  Note that    */
    /* this prevents shared use of the Trace DLL.                           */
    /************************************************************************/
    trchSharedDataObject = NULL;
    trcpSharedData = &trcSharedData;
    trcCreatedTraceFiles = TRUE;
#else
    
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&ver);
    if (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) {

        /************************************************************************/
        /* Get the SID for the Everyone group                                   */
        /************************************************************************/
        if (!AllocateAndInitializeSid (
                &sidEveryoneAuthority,          // pIdentifierAuthority
                1,                              // count of subauthorities
                SECURITY_WORLD_RID,             // subauthority 0
                0, 0, 0, 0, 0, 0, 0,            // subauthorities n
                &psidEveryone)) {               // pointer to pointer to SID
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("AllocateAndInitializeSid failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Allocate the Dacl                                                    */
        /************************************************************************/
        dwDaclLength = sizeof(ACL);
        dwDaclLength += (sizeof(ACCESS_DENIED_ACE) - sizeof(DWORD)) +
                           GetLengthSid(psidEveryone);
        dwDaclLength += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                           GetLengthSid(psidEveryone);
        pDacl = (PACL)LocalAlloc(LMEM_FIXED, dwDaclLength);
        if (pDacl == NULL) {
            OutputDebugString(_T("Can't allocate Dacl.\n"));
            rc = TRC_RC_MAP_VIEW_FAILED;
            DC_QUIT;
        }

        /************************************************************************/
        /* Initialize it.                                                       */
        /************************************************************************/
        if (!InitializeAcl(pDacl, dwDaclLength, ACL_REVISION)) {
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("InitializeAcl failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Allow all access                                                     */
        /************************************************************************/
        if (!AddAccessAllowedAce(
                        pDacl,
                        ACL_REVISION,
                        GENERIC_ALL,
                        psidEveryone)) {
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("AddAccessAllowedAce failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Block Write-DACL Access                                              */
        /************************************************************************/
        if (!AddAccessDeniedAce(
                        pDacl,
                        ACL_REVISION,
                        WRITE_DAC,
                        psidEveryone)) {
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("AddAccessDeniedAceEx failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Create the File Mapping                                              */
        /************************************************************************/
        InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
        SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE);
        sa.lpSecurityDescriptor = &sd;

        trchSharedDataObject = CreateFileMapping(INVALID_HANDLE_VALUE,
                                                 &sa,
                                                 PAGE_READWRITE,
                                                 0,
                                                 sizeof(TRC_SHARED_DATA),
                                                 TRC_SHARED_DATA_NAME);
    }
    else {
        trchSharedDataObject = CreateFileMapping(INVALID_HANDLE_VALUE,
                                                 NULL,
                                                 PAGE_READWRITE,
                                                 0,
                                                 sizeof(TRC_SHARED_DATA),
                                                 TRC_SHARED_DATA_NAME);
    }

    /************************************************************************/
    /* Check that we succeeded in creating the file mapping.                */
    /************************************************************************/
    if (NULL == trchSharedDataObject)
    {
        TRCDebugOutput(_T("NULL trchSharedDataObject.\n"));
        rc = TRC_RC_CREATE_MAPPING_FAILED;
        DC_QUIT;
    }

    /************************************************************************/
    /* Determine if the file mapping already exists - if it does then we    */
    /* won't bother reading the registry data in or setting up the file     */
    /* offset and indicator values.  Note that up to this point             */
    /* <trcCreatedTraceFiles> has been set to TRUE.                         */
    /************************************************************************/
    if (ERROR_ALREADY_EXISTS == GetLastError())
    {
        trcCreatedTraceFiles = FALSE;
    }

    /************************************************************************/
    /* We now have a handle to the shared data MMF which now needs to be    */
    /* mapped into our address space.  Setting the third, fourth and fifth  */
    /* parameters of MapViewOfFile to zero maps the whole file into our     */
    /* address space starting with the first byte of the file.              */
    /************************************************************************/
    trcpSharedData = (PTRC_SHARED_DATA) MapViewOfFile(trchSharedDataObject,
                                                      FILE_MAP_ALL_ACCESS,
                                                      0,
                                                      0,
                                                      0);
    if (NULL == trcpSharedData)
    {
        /********************************************************************/
        /* Free up the handle to the file mapping object.                   */
        /********************************************************************/
        CloseHandle(trchSharedDataObject);
        trchSharedDataObject = NULL;

        /********************************************************************/
        /* Output a debug string and then quit.                             */
        /********************************************************************/
        TRCDebugOutput(_T("NULL trcpSharedData.\n"));
        rc = TRC_RC_MAP_VIEW_FAILED;
        DC_QUIT;
    }
#endif /* OS_WINCE */

    /************************************************************************/
    /* Set up our static pointer to the shared configuration data and to    */
    /* the filter data.                                                     */
    /************************************************************************/
    trcpConfig       = &(trcpSharedData->trcConfig);
    trcpFilter       = &(trcpSharedData->trcFilter);
    trcpOutputBuffer = trcpSharedData->trcpOutputBuffer;

    /************************************************************************/
    /* Finally initialize the shared data block and then read in the        */
    /* configuration data - but only if we are the first to open the file   */
    /* mapping.                                                             */
    /************************************************************************/
    if (trcCreatedTraceFiles)
    {
        /********************************************************************/
        /* Initialize the shared data memory mapped file.                   */
        /********************************************************************/
        DC_MEMSET(trcpSharedData, 0, sizeof(TRC_SHARED_DATA));

        /********************************************************************/
        /* Initialize the internal status flags.  The following flags apply */
        /* to all the processes.                                            */
        /********************************************************************/
        CLEAR_FLAG(trcpFilter->trcStatus, TRC_STATUS_ASSERT_DISPLAYED);

        /********************************************************************/
        /* The following flags are maintained on a per-process basis.       */
        /********************************************************************/
        CLEAR_FLAG(trcProcessStatus, TRC_STATUS_SYMBOLS_LOADED);

        /********************************************************************/
        /* Read in the configuration data.                                  */
        /********************************************************************/
        TRCReadSharedDataConfig();

        /********************************************************************/
        /* Now split the prefix list.                                       */
        /********************************************************************/
        TRCSplitPrefixes();
    }

DC_EXIT_POINT:

#ifndef OS_WINCE
    if (pDacl) LocalFree(pDacl);
    if (psidEveryone) FreeSid(psidEveryone);
#endif

    return(rc);

} /* TRCOpenSharedData */


/****************************************************************************/
/* FUNCTION: TRCOpenSingleFile(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Opens a single trace memory mapped file.                                 */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* fileNum       : which file to open.                                      */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0                            : Function succeeded                        */
/* TRC_RC_CREATE_FILE_FAILED    : CreateFile call failed                    */
/* TRC_RC_MAP_VIEW_FAILED       : MapViewOfFile failed                      */
/* TRC_RC_CREATE_MAPPING_FAILED : Failed to create the file mapping         */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCOpenSingleFile(DCUINT fileNum)
{
    DCUINT rc                = 0;
    DCBOOL blankFile         = FALSE;
#ifndef OS_WINCE
    DCTCHAR objectName[30];
    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;
    PSID psidEveryone = NULL;
    SID_IDENTIFIER_AUTHORITY sidEveryoneAuthority = SECURITY_WORLD_SID_AUTHORITY;
    DCUINT32 dwDaclLength;
    PACL pDacl = NULL;
    OSVERSIONINFO ver;
    HRESULT hr;
#endif
    /************************************************************************/
    /* Open a single trace file.  First of all we attempt to open the file  */
    /* with read and write access, and shared read and write access.  The   */
    /* OPEN_ALWAYS flag ensures that the file is created if it does not     */
    /* already exist.  We pass NULL for the security attributes and         */
    /* template parameters (4 and 7).                                       */
    /************************************************************************/
    trchFileObjects[fileNum] = CreateFile(trcpConfig->fileNames[fileNum],
                                          GENERIC_READ | GENERIC_WRITE,
                                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                                          NULL,
#ifndef OS_WINCE
                                          OPEN_ALWAYS,
#else
                                          CREATE_ALWAYS,
#endif
                                          FILE_ATTRIBUTE_NORMAL,
                                          NULL);

    /************************************************************************/
    /* Check that the handle returned by CreateFile is valid.  For some     */
    /* peculiar reason it does return NULL if it fails - instead it returns */
    /* -1 (INVALID_HANDLE_VALUE).                                           */
    /************************************************************************/
    if (INVALID_HANDLE_VALUE == trchFileObjects[fileNum])
    {
        TRCDebugOutput(_T("Failed to open trace file.\n"));
        rc = TRC_RC_CREATE_FILE_FAILED;
        DC_QUIT;
    }

    /************************************************************************/
    /* Now check whether the file existed before the call to CreateFile.    */
    /* If it did then GetLastError returns ERROR_ALREADY_EXISTS (even       */
    /* though the function has succeeded).                                  */
    /************************************************************************/
    if (0 == GetLastError())
    {
        /********************************************************************/
        /* If the file did not exist before the call, GetLastError returns  */
        /* zero.  In this case we want to fill the file with spaces.        */
        /********************************************************************/
        blankFile = TRUE;

        /********************************************************************/
        /* We have just created the file - so would expect to need to set   */
        /* the security info to allow all accesses.  However, a) all works  */
        /* just fine without it, b) the attempt to set the security stuff   */
        /* fails if inserted here.  So we'll just go along happily without. */
        /********************************************************************/
    }

#ifdef OS_WINCE
    SetFilePointer(trchFileObjects[fileNum],
                   0,
                   NULL,
                   FILE_END);
#else
    /************************************************************************/
    /* Make sure that the end of the file is correctly set.  The file may   */
    /* be of any size when we open it, but we need it to be                 */
    /* <trcpConfig->maxFileSize> bytes long.                                */
    /************************************************************************/
    SetFilePointer(trchFileObjects[fileNum],
                   trcpConfig->maxFileSize,
                   NULL,
                   FILE_BEGIN);
    SetEndOfFile(trchFileObjects[fileNum]);

    /************************************************************************/
    /* Generate the file mapping object name.  This is used in              */
    /* CreateFileMapping.                                                   */
    /************************************************************************/
    hr = StringCchPrintf(objectName,
                         SIZE_TCHARS(objectName),
                         TRC_TRACE_FILE_NAME _T("%hu"), fileNum);
    if (FAILED(hr)) {
        DC_QUIT;
    }


    /************************************************************************/
    /* Now create the file mapping object.  Again ignore security           */
    /* attributes (parameter 2) and set the high order 32 bits of the       */
    /* object size to 0 (see Win32 SDK for more information).               */
    /*                                                                      */
    /* Create the file mapping object using a NULL Dacl so it works for all */
    /* contexts.                                                            */
    /************************************************************************/
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&ver);
    if (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) {

        /************************************************************************/
        /* Get the SID for the Everyone group                                   */
        /************************************************************************/
        if (!AllocateAndInitializeSid (
                &sidEveryoneAuthority,          // pIdentifierAuthority
                1,                              // count of subauthorities
                SECURITY_WORLD_RID,             // subauthority 0
                0, 0, 0, 0, 0, 0, 0,            // subauthorities n
                &psidEveryone)) {               // pointer to pointer to SID
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("AllocateAndInitializeSid failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Allocate the Dacl                                                    */
        /************************************************************************/
        dwDaclLength = sizeof(ACL);
        dwDaclLength += (sizeof(ACCESS_DENIED_ACE) - sizeof(DWORD)) +
                           GetLengthSid(psidEveryone);
        dwDaclLength += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                           GetLengthSid(psidEveryone);
        pDacl = (PACL)LocalAlloc(LMEM_FIXED, dwDaclLength);
        if (pDacl == NULL) {
            OutputDebugString(_T("Can't allocate Dacl.\n"));
            rc = TRC_RC_MAP_VIEW_FAILED;
            DC_QUIT;
        }

        /************************************************************************/
        /* Initialize it.                                                       */
        /************************************************************************/
        if (!InitializeAcl(pDacl, dwDaclLength, ACL_REVISION)) {
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("InitializeAcl failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Allow all access                                                     */
        /************************************************************************/
        if (!AddAccessAllowedAce(
                        pDacl,
                        ACL_REVISION,
                        GENERIC_ALL,
                        psidEveryone)) {
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("AddAccessAllowedAce failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Block Write-DACL Access                                              */
        /************************************************************************/
        if (!AddAccessDeniedAce(
                        pDacl,
                        ACL_REVISION,
                        WRITE_DAC,
                        psidEveryone)) {
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("AddAccessDeniedAceEx failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Create the File Mapping
        /************************************************************************/
        InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
        SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE);
        sa.lpSecurityDescriptor = &sd;

        trchMappingObjects[fileNum] = CreateFileMapping(trchFileObjects[fileNum],
                                                        &sa,
                                                        PAGE_READWRITE,
                                                        0,
                                                        trcpConfig->maxFileSize,
                                                        objectName);

    }
    else {
        trchMappingObjects[fileNum] = CreateFileMapping(trchFileObjects[fileNum],
                                                        NULL,
                                                        PAGE_READWRITE,
                                                        0,
                                                        trcpConfig->maxFileSize,
                                                        objectName);
    }

    /************************************************************************/
    /* Check that we succeeded in creating the file mapping object.         */
    /* CreateFileMapping returns NULL if it fails.                          */
    /************************************************************************/
    if (NULL == trchMappingObjects[fileNum])
    {
        TRCDebugOutput(_T("Failed to map trace file.\n"));
        rc = TRC_RC_CREATE_MAPPING_FAILED;
        DC_QUIT;    
    }

    /************************************************************************/
    /* Now map a view of the file.  Set the low and high order offsets to   */
    /* zero (parameters 3 and 4).                                           */
    /************************************************************************/
    trcpFiles[fileNum] = (PDCTCHAR)MapViewOfFile(trchMappingObjects[fileNum],
                                                 FILE_MAP_ALL_ACCESS,
                                                 0,
                                                 0,
                                                 trcpConfig->maxFileSize);

    /************************************************************************/
    /* Check that we mapped a view of the file.                             */
    /************************************************************************/
    if (NULL == trcpFiles[fileNum])
    {
        TRCDebugOutput(_T("Failed to map view of trace file.\n"));
        rc = TRC_RC_MAP_VIEW_FAILED;
        DC_QUIT;
    }

    /************************************************************************/
    /* Finally check to see if we need to blank this file.                  */
    /************************************************************************/
    if (blankFile)
    {
        TRCBlankFile(fileNum);
    }
#endif

DC_EXIT_POINT:

    /************************************************************************/
    /* If the return code is non-zero then we need to perform some tidying  */
    /* up.                                                                  */
    /************************************************************************/
    if (0 != rc)
    {
#ifndef OS_WINCE
        /********************************************************************/
        /* Check whether we need to free the handle to the file mapping     */
        /* object.                                                          */
        /********************************************************************/
        if (NULL != trchMappingObjects[fileNum])
        {
            CloseHandle(trchMappingObjects[fileNum]);
            trchMappingObjects[fileNum] = NULL;
        }

#endif
        /********************************************************************/
        /* Check whether we need to free the handle to the file object.     */
        /********************************************************************/
        if (NULL != trchFileObjects[fileNum])
        {
            CloseHandle(trchFileObjects[fileNum]);
            trchFileObjects[fileNum] = NULL;
        }
    }

#ifndef OS_WINCE
    if (pDacl) {
         LocalFree(pDacl);
    }
    if (psidEveryone) { 
        FreeSid(psidEveryone);
    }
#endif


    return(rc);

} /* TRCOpenSingleFile */


/****************************************************************************/
/* FUNCTION: TRCOutputToFile(...)                                           */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function writes a string to the trace file.  It is used to trace    */
/* both normal trace lines and stack trace lines.                           */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pText           : a pointer to the trace text string.                    */
/* length          : length of the string.                                  */
/* traceLevel      : the current trace level.                               */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCOutputToFile(PDCTCHAR pText,
                                  DCUINT   length,
                                  DCUINT   traceLevel)
{
#ifndef OS_WINCE
    PDCUINT8 pFilePos;

    /************************************************************************/
    /* Make sure we have a trace file with enough free space.               */
    /************************************************************************/
    TRCMaybeSwapFile(length);

    /************************************************************************/
    /* We can now write out the trace line.                                 */
    /************************************************************************/
    pFilePos = (PDCUINT8)trcpFiles[trcpSharedData->trcIndicator] +
               trcpSharedData->trcOffset;
    DC_MEMCPY(pFilePos, pText, length);

    /************************************************************************/
    /* Check if we should flush this line to disk immediately.  If this is  */
    /* an error or higher level trace then flush to disk regardless.        */
    /************************************************************************/
    if ((TRUE == TEST_FLAG(trcpConfig->flags, TRC_OPT_FLUSH_ON_TRACE)) ||
        (traceLevel >= TRC_LEVEL_ERR))
    {
        FlushViewOfFile(pFilePos, length);
    }

    /************************************************************************/
    /* Finally update the offset.                                           */
    /************************************************************************/
    trcpSharedData->trcOffset += length;
#else
    DWORD dwRet;
    WriteFile(trchFileObjects[0], pText, length, &dwRet, NULL);
#endif

DC_EXIT_POINT:
    return;

} /* TRCOutputToFile */


/****************************************************************************/
/* FUNCTION: TRCReadEntry(...)                                              */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Read an entry from the given section of the registry.                    */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* topLevelKey      : one of:                                               */
/*                      - HKEY_CURRENT_USER                                 */
/*                      - HKEY_LOCAL_MACHINE                                */
/* pSection         : the section name to read from.  The DC_REG_PREFIX     */
/*                    string is prepended to give the full name.            */
/* pEntry           : the entry name to read.                               */
/* pBuffer          : a buffer to read the entry to.                        */
/* bufferSize       : the size of the buffer.                               */
/* expectedDataType : the type of data stored in the entry.                 */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCReadEntry(HKEY     topLevelKey,
                               PDCTCHAR pEntry,
                               PDCTCHAR pBuffer,
                               DCINT    bufferSize,
                               DCINT32  expectedDataType)
{
    LONG     sysrc;
    HKEY     key;
    DCINT32  dataType;
    DCINT32  dataSize;
    DCTCHAR  subKey[TRC_MAX_SUBKEY];
    DCBOOL   keyOpen         = FALSE;
    DCUINT   rc              = 0;
    HRESULT  hr;

    /************************************************************************/
    /* Get a subkey for the value.                                          */
    /************************************************************************/
    hr = StringCchCopy(subKey,
                       SIZE_TCHARS(subKey),
                       TRC_SUBKEY_NAME);
    if (FAILED(hr)) {
        DC_QUIT;
    }

    /************************************************************************/
    /* Try to open the key.  If the entry does not exist, RegOpenKeyEx will */
    /* fail.                                                                */
    /************************************************************************/
    sysrc = RegOpenKeyEx(topLevelKey,
                         subKey,
                         0,                   /* reserved                 */
                         KEY_ALL_ACCESS,
                         &key);

    if (ERROR_SUCCESS != sysrc)
    {
        /********************************************************************/
        /* Don't trace an error here since the subkey may not exist...      */
        /********************************************************************/
        rc = TRC_RC_IO_ERROR;
        DC_QUIT;
    }
    keyOpen = TRUE;

    /************************************************************************/
    /* We successfully opened the key so now try to read the value.  Again  */
    /* it may not exist.                                                    */
    /************************************************************************/
    dataSize = (DCINT32)bufferSize;
    sysrc    = RegQueryValueEx(key,
                               pEntry,
                               0,          /* reserved */
                               (LPDWORD) &dataType,
                               (LPBYTE)  pBuffer,
                               (LPDWORD) &dataSize);

    if (sysrc != ERROR_SUCCESS)
    {
        rc = TRC_RC_IO_ERROR;
        DC_QUIT;
    }

    /************************************************************************/
    /* Check that the type is correct.  Special case: allow REG_BINARY      */
    /* instead of REG_DWORD, as long as the length is 32 bits.              */
    /************************************************************************/
    if ((dataType != expectedDataType) &&
        ((dataType != REG_BINARY) ||
         (expectedDataType != REG_DWORD) ||
         (dataSize != 4)))
    {
        rc = TRC_RC_IO_ERROR;
        DC_QUIT;
    }

DC_EXIT_POINT:

    /************************************************************************/
    /* Close the key (if required).                                         */
    /************************************************************************/
    if (keyOpen)
    {
        sysrc = RegCloseKey(key);
        if (ERROR_SUCCESS != sysrc)
        {
            TRCDebugOutput(_T("Failed to close key.\n"));
        }
    }

    return(rc);

} /* TRCReadEntry */


/****************************************************************************/
/* FUNCTION: TRCStackTrace(...)                                             */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* traceLevel      : the current trace level which is used to determine     */
/*                   whether this line should be flushed to disk            */
/*                   immediately.                                           */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCStackTrace(DCUINT traceLevel)
{
    DC_IGNORE_PARAMETER(traceLevel);
#ifdef DO_STACK_TRACE
    HANDLE           hProcess;
    HANDLE           hThread;
    DCBOOL           sysrc;
    STACKFRAME       stackFrame;
    DWORD            machineType;
    IMAGEHLP_MODULE  moduleInfo;
    DCINT            i;
    DCTCHAR          formatString[TRC_FRMT_BUFFER_SIZE];
    CONTEXT          threadContext;
    CHAR             symBuffer[sizeof(IMAGEHLP_SYMBOL)+TRC_MAX_SYMNAME_SIZE];
    PIMAGEHLP_SYMBOL pSymbol;
    PCHAR            pFuncName;
    DWORD            displacement   = 0;
    DCBOOL           foundTrace     = FALSE;

    /************************************************************************/
    /* First of all ensure that stack tracing is enabled - if it is not     */
    /* then just return.                                                    */
    /************************************************************************/
    /************************************************************************/
    /* The stack trace code doesn't work for Alpha so don't bother trying.  */
    /************************************************************************/
#ifndef _M_ALPHA
    if (!TEST_FLAG(trcpConfig->flags, TRC_OPT_STACK_TRACING))
#endif
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* Set <pSymbol> to point to the symbol buffer.                         */
    /************************************************************************/
    pSymbol = (PIMAGEHLP_SYMBOL) symBuffer;

    /************************************************************************/
    /* Zero memory structures.                                              */
    /************************************************************************/
    ZeroMemory(&stackFrame, sizeof(stackFrame));
    ZeroMemory(pSymbol, sizeof(IMAGEHLP_SYMBOL));
    ZeroMemory(&threadContext, sizeof(CONTEXT));

    /************************************************************************/
    /* Initialize the symbol buffer.                                        */
    /************************************************************************/
    pSymbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
    pSymbol->MaxNameLength = 1024;

    /************************************************************************/
    /* Get handles to the current process and thread.                       */
    /************************************************************************/
    hProcess = GetCurrentProcess();
    hThread  = GetCurrentThread();

    /************************************************************************/
    /* We need to get the values of the base pointer, stack pointer and the */
    /* instruction pointer.  We can use <GetContextThread> to return this   */
    /* information - but first of all we need to set the <ContextFlags>     */
    /* member of the <threadContext> struture to return the control         */
    /* registers.                                                           */
    /************************************************************************/
    threadContext.ContextFlags = CONTEXT_CONTROL;

    /************************************************************************/
    /* Now attempt to get the thread context.                               */
    /************************************************************************/
    if (!GetThreadContext(hThread, &threadContext))
    {
        /********************************************************************/
        /* If <GetThreadContext> failed then there is not a lot we can do   */
        /* so just quit.                                                    */
        /********************************************************************/
        TRCInternalError(_T("GetThreadContext failed.\n"));
        DC_QUIT;
    }

    /************************************************************************/
    /* Store the instruction pointer in the <stackFrame> structure.         */
    /************************************************************************/
    stackFrame.AddrPC.Mode   = AddrModeFlat;

    /************************************************************************/
    /* Processor dependant section.  We set the image file type here and if */
    /* we are running on Intel hardware we also store the stack pointer and */
    /* base pointer.                                                        */
    /************************************************************************/
#if defined(_M_IX86)
        machineType = IMAGE_FILE_MACHINE_I386;

        stackFrame.AddrPC.Offset    = threadContext.Eip;
        stackFrame.AddrFrame.Offset = threadContext.Ebp;
        stackFrame.AddrFrame.Mode   = AddrModeFlat;
        stackFrame.AddrStack.Offset = threadContext.Esp;
        stackFrame.AddrStack.Mode   = AddrModeFlat;

#elif defined (_M_MRX000)
        machineType = IMAGE_FILE_MACHINE_R4000;
#elif defined (_M_ALPHA)
        machineType = IMAGE_FILE_MACHINE_ALPHA;
#elif defined (_M_PPC)
        machineType = IMAGE_FILE_MACHINE_POWERPC;
#else
#error("Unknown machine type.");
#endif

    /************************************************************************/
    /* Now run down the stack.                                              */
    /************************************************************************/
    for (i = 1; i < TRC_MAX_SIZE_STACK_TRACE; i++)
    {
        /********************************************************************/
        /* Call <StackWalk> to start walking the stack.                     */
        /********************************************************************/
        sysrc = StackWalk(machineType,
                          hProcess,
                          hThread,
                          &stackFrame,
                          &threadContext,
                          NULL,
                          SymFunctionTableAccess,
                          SymGetModuleBase,
                          NULL);

        /********************************************************************/
        /* Check the return code.                                           */
        /********************************************************************/
        if (FALSE == sysrc)
        {
            /****************************************************************/
            /* Don't trace anything here as we enter here when we reach     */
            /* the end of the stack.                                        */
            /****************************************************************/
            DC_QUIT;
        }

        /********************************************************************/
        /* Get the module name.                                             */
        /********************************************************************/
        sysrc = SymGetModuleInfo(hProcess,
                                 stackFrame.AddrPC.Offset,
                                 &moduleInfo);

        /********************************************************************/
        /* Check the return code.                                           */
        /********************************************************************/
        if (FALSE == sysrc)
        {
            /****************************************************************/
            /* Don't trace anything as we enter here when we reach the end  */
            /* of the stack.                                                */
            /****************************************************************/
            DC_QUIT;
        }

        /********************************************************************/
        /* When we start we are somewhere in the midst of                   */
        /* <GetThreadContext>.  Since we're only interested in the stack    */
        /* above the trace module then we need to skip everything until we  */
        /* pass the trace module.                                           */
        /*                                                                  */
        /* Look for the trace module name.                                  */
        /********************************************************************/
        if (DC_TSTRCMPI(trcpSharedData->trcpModuleFileName,
                        moduleInfo.ModuleName) == 0)
        {
            /****************************************************************/
            /* They match so set the <foundTrace> flag and the continue.    */
            /****************************************************************/
            foundTrace = TRUE;
            continue;
        }

        /********************************************************************/
        /* We've not found the trace module yet so just continue.           */
        /********************************************************************/
        if (!foundTrace)
        {
            continue;
        }

        /********************************************************************/
        /* Now get the symbol name.                                         */
        /********************************************************************/
        sysrc = SymGetSymFromAddr(hProcess,
                                  stackFrame.AddrPC.Offset,
                                  &displacement,
                                  pSymbol);

        /********************************************************************/
        /* Check the return code.                                           */
        /********************************************************************/
        if (sysrc)
        {
            /****************************************************************/
            /* We've found some symbols so use them.                        */
            /****************************************************************/
            pFuncName = pSymbol->Name;
        }
        else
        {
            /****************************************************************/
            /* No symbols available.                                        */
            /****************************************************************/
            pFuncName = _T("<nosymbols>");
        }

        /********************************************************************/
        /* Finally format the string.                                       */
        /********************************************************************/
        hr = StringCchPrintf(
                    formatString,
                    SIZE_TCHARS(formatString),
                    _T("    ") TRC_MODL_FMT _T("!") TRC_FUNC_FMT _T(" : ") TRC_STCK_FMT_T("\r\n"),
                    moduleInfo.ModuleName,
                    trcpConfig->funcNameLength,
                    trcpConfig->funcNameLength,
                    pFuncName,
                    displacement,
                    stackFrame.AddrFrame.Offset,
                    stackFrame.AddrReturn.Offset,
                    stackFrame.Params[0],
                    stackFrame.Params[1],
                    stackFrame.Params[2],
                    stackFrame.Params[3]
                    );

        if (SUCCEEDED(hr)) {
            /********************************************************************/
            /* Output this line of the <formatString>.                          */
            /********************************************************************/
            TRCOutput(formatString, DC_TSTRLEN(formatString), traceLevel);
        }
    }

DC_EXIT_POINT:

    return;
#endif /* DO_STACK_TRACE */

} /* TRCStackTrace */


/****************************************************************************/
/* FUNCTION: TRCSymbolsLoad(...)                                            */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Function to load symbolic debugging information.  This function should   */
/* only be called if the trace mutex has been obtained.                     */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0                      : success.                                        */
/* TRC_SYMBOL_LOAD_FAILED : failed to load symbols.                         */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCSymbolsLoad(DCVOID)
{
    DCUINT rc              = 0;
    HANDLE hProcess;
#ifdef DO_STACK_TRACE
    DWORD  options;
#endif

    /************************************************************************/
    /* Get the current process handle.                                      */
    /************************************************************************/
    hProcess = GetCurrentProcess();

    /************************************************************************/
    /* We're about to load symbols - so trace a line out.                   */
    /************************************************************************/
    TRCInternalTrace(TRC_SYMBOLS_LOADING_NOTIFY);

#ifdef DO_STACK_TRACE
    /************************************************************************/
    /* Now set the deferred symbol load option.  For some peculiar reason   */
    /* this is not set by default.                                          */
    /************************************************************************/
    options = SymGetOptions();
    SymSetOptions(options | SYMOPT_DEFERRED_LOADS);

    /************************************************************************/
    /* Initialize the symbol handler for this process.  By setting param 2  */
    /* to NULL the search path for the symbols is as follows:               */
    /*                                                                      */
    /* - Current directory                                                  */
    /* - Env variable _NT_SYMBOL_PATH                                       */
    /* - Env variable _NT_ALTERNATE_SYMBOL_PATH                             */
    /* - Env variable SYSTEMROOT                                            */
    /*                                                                      */
    /* By setting the third parameter to TRUE we tell IMAGEHLP to enumerate */
    /* the loaded modules for this process (this effectively calls          */
    /* <SymLoadModule> for each module).                                    */
    /************************************************************************/

    /************************************************************************/
    /* LAURABU:                                                             */
    /* SymInitialize returns FALSE on Win95.  Moreover, it makes no sense   */
    /* to fail to start up on either NT or Win95 just because this dll      */
    /* couldn't load debug symbols.  Therefore don't fail.                  */
    /************************************************************************/
    if (!(SymInitialize(hProcess, NULL, TRUE)))
    {
#ifdef DC_OMIT
        rc = TRC_RC_SYMBOL_LOAD_FAILED;
#endif
        TRCDebugOutput(_T("SymInitialize failed.\n"));
#ifdef DC_OMIT
        DC_QUIT;
#endif
    }
#endif

    /************************************************************************/
    /* Set the flag to indicate the symbols have been loaded.               */
    /************************************************************************/
    SET_FLAG(trcProcessStatus, TRC_STATUS_SYMBOLS_LOADED);

    /************************************************************************/
    /* Write a status line.  The assumption here is that this is done under */
    /* the mutex.                                                           */
    /************************************************************************/
    TRCInternalTrace(TRC_SYMBOLS_LOADED_NOTIFY);

DC_EXIT_POINT:

    return(rc);

} /* TRCSymbolsLoad */


/****************************************************************************/
/* FUNCTION: TRCSymbolsUnload(...)                                          */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* TRUE if successful and FALSE otherwise.                                  */
/*                                                                          */
/****************************************************************************/
DCBOOL DCINTERNAL TRCSymbolsUnload(DCVOID)
{
    DCBOOL    rc = TRUE;
#ifdef DO_STACK_TRACE
    HANDLE    hProcess;

    /************************************************************************/
    /* Get the current process handle.                                      */
    /************************************************************************/
    hProcess = GetCurrentProcess();

    /************************************************************************/
    /* Cleanup the symbols.                                                 */
    /************************************************************************/
    rc = SymCleanup(hProcess);

    /************************************************************************/
    /* Check the return code.                                               */
    /************************************************************************/
    if (FALSE == rc)
    {
        TRCDebugOutput(_T("SymCleanup failed.\n"));
        DC_QUIT;
    }
#endif

    /************************************************************************/
    /* Clear the symbols loaded flag.                                       */
    /************************************************************************/
    CLEAR_FLAG(trcProcessStatus, TRC_STATUS_SYMBOLS_LOADED);

    /************************************************************************/
    /* Write a status line to the trace file.  The assumption here is that  */
    /* this is done under the mutex.                                        */
    /************************************************************************/
    TRCInternalTrace(TRC_SYMBOLS_UNLOAD_NOTIFY);

DC_EXIT_POINT:

    return(rc);

} /* TRCSymbolsLoad */


/****************************************************************************/
/* FUNCTION: TRCWriteEntry(...)                                             */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Write an entry to the given section of the registry.                     */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* topLevelKey     : one of:                                                */
/*                     - HKEY_CURRENT_USER                                  */
/*                     - HKEY_LOCAL_MACHINE                                 */
/* pEntry          : the entry name to write.                               */
/* pData           : a pointer to the data to be written.                   */
/* dataSize        : the size of the data to be written.  For strings, this */
/*                   should include the NULL terminator.                    */
/* dataType        : the type of the data to be written.                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0               : success                                                */
/* TRC_RC_IO_ERROR : I/O error.                                             */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCWriteEntry(HKEY     topLevelKey,
                                PDCTCHAR pEntry,
                                PDCTCHAR pData,
                                DCINT    dataSize,
                                DCINT32  dataType)
{
    LONG        sysrc;
    HKEY        key;
    DCTCHAR     subKey[TRC_MAX_SUBKEY];
    DWORD       disposition;
    DCBOOL      keyOpen = FALSE;
    DCUINT      rc      = 0;
    HRESULT     hr;

    /************************************************************************/
    /* Get a subkey for the value.                                          */
    /************************************************************************/
    hr = StringCchCopy(subKey,
                       SIZE_TCHARS(subKey),
                       TRC_SUBKEY_NAME);
    if (FAILED(hr)) {
        DC_QUIT;
    }

    /************************************************************************/
    /* Try to create the key.  If the entry already exists, RegCreateKeyEx  */
    /* will open the existing entry.                                        */
    /************************************************************************/
    sysrc = RegCreateKeyEx(topLevelKey,
                           subKey,
                           0,                   /* reserved             */
                           NULL,                /* class                */
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,                /* security attributes  */
                           &key,
                           &disposition);

    if (ERROR_SUCCESS != sysrc)
    {
        DCTCHAR output[12];

        TRCDebugOutput(_T("Failed to create key failed with error "));

        hr = StringCchPrintf(output, SIZE_TCHARS(output),
                             _T("%#lx"), GetLastError());
        if (SUCCEEDED(hr)) {
            TRCDebugOutput(output);
        }

        DC_QUIT;
    }

    keyOpen = TRUE;

    /************************************************************************/
    /* We've got the key, so set the value.                                 */
    /************************************************************************/
    sysrc = RegSetValueEx(key,
                          pEntry,
                          0,                                /* reserved     */
                          dataType,
                          (LPBYTE) pData,
                          (DCINT32) dataSize);

    if (ERROR_SUCCESS != sysrc)
    {
        DCTCHAR output[12];

        TRCDebugOutput(_T("Failed to set value failed with error "));

        hr = StringCchPrintf(output, SIZE_TCHARS(output),
                             _T("%#lx"), GetLastError());
        if (SUCCEEDED(hr)) {
            TRCDebugOutput(output);
        }

        DC_QUIT;
    }

DC_EXIT_POINT:

    /************************************************************************/
    /* Close the key (if required)                                          */
    /************************************************************************/
    if (keyOpen)
    {
        sysrc = RegCloseKey(key);
        if (ERROR_SUCCESS != sysrc)
        {
            TRCDebugOutput(_T("Failed to close key.\n"));
        }
    }

    return(rc);

} /* TRCWriteEntry */

/****************************************************************************/
/* We have our own implementation of DebugBreak that on NT checks if a      */
/* debugger is present first before calling DebugBreak().  Otherwise the    */
/* app will just get terminated due to an unhandled exception.              */
/****************************************************************************/

typedef BOOL (WINAPI * PFN_ISDEBUGGERPRESENT)(void);

DCVOID DCINTERNAL TRCDebugBreak(DCVOID)
{
    static PFN_ISDEBUGGERPRESENT    s_pfnIsDebuggerPresent = NULL;
    static BOOL                     s_fHaveWeTriedToFindIt = FALSE;

    if (! s_pfnIsDebuggerPresent)
    {
        if (!InterlockedExchange((long *)&s_fHaveWeTriedToFindIt, TRUE))
        {
            /****************************************************************/
            /* Try to get the proc address of "IsDebuggerPresent".  Note we */
            /* can just write into this variable without Interlocked stuff  */
            /* since dwords get written to and read from atomically.        */
            /****************************************************************/
#ifndef OS_WINCE
            s_pfnIsDebuggerPresent = (PFN_ISDEBUGGERPRESENT)
                          GetProcAddress(GetModuleHandle(_T("kernel32.dll")),
                                         "IsDebuggerPresent");
#else // OS_WINCE
            HMODULE hmod;
            hmod = LoadLibrary(_T("kernel32.dll"));
            s_pfnIsDebuggerPresent = (PFN_ISDEBUGGERPRESENT)
                           GetProcAddress(hmod,
                                          _T("IsDebuggerPresent"));
            FreeLibrary(hmod);
#endif
        }
    }

    /************************************************************************/
    /* If this api doesn't exist, we are on Win95, so go ahead and call     */
    /* DebugBreak().  If it does, we are on NT 4, so find out if a debugger */
    /* is around.  If a debugger isn't there, then don't break for now      */
    /* since we don't have debuggers attached to most of our NT machines    */
    /* yet.                                                                 */
    /************************************************************************/
    if (!s_pfnIsDebuggerPresent || (s_pfnIsDebuggerPresent()))
        DebugBreak();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\atrcdata.c ===
/**MOD+**********************************************************************/
/* Module:    atrcdata.c                                                    */
/*                                                                          */
/* Purpose:   Internal trace data                                           */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/trc/atrcdata.c_v  $
 *
 *    Rev 1.5   09 Jul 1997 17:59:34   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.4   07 Jul 1997 17:49:24   KH
 * SFR1022: Change trcState to DCUINT
 *
 *    Rev 1.3   03 Jul 1997 13:27:34   AK
 * SFR0000: Initial development completed
**/
/**MOD-**********************************************************************/

#include <adcg.h>

/****************************************************************************/
/* Define TRC_FILE and TRC_GROUP if this file is being compiled - but do    */
/* not define if it is being included.                                      */
/****************************************************************************/
#ifndef DC_INCLUDE_DATA
#define TRC_FILE    "atrcdata"
#define TRC_GROUP   TRC_GROUP_TRACE
#endif

/****************************************************************************/
/* Data header.                                                             */
/****************************************************************************/
#include <adcgdata.h>

/****************************************************************************/
/* Trace specific includes.                                                 */
/****************************************************************************/
#include <atrcapi.h>
#include <atrcint.h>

/****************************************************************************/
/* Pointers to shared data structures.                                      */
/****************************************************************************/
DC_DATA(PTRC_CONFIG,        trcpConfig,              0);
DC_DATA(PTRC_FILTER,        trcpFilter,              0);
DC_DATA(PDCTCHAR,           trcpOutputBuffer,        0);

/****************************************************************************/
/* Flag to indicate if tracing is fully initialized yet.                    */
/****************************************************************************/
DC_DATA(DCUINT,           trcState,            TRC_STATE_UNINITIALIZED);

/****************************************************************************/
/*                                                                          */
/* OPERATING SYSTEM SPECIFIC INCLUDES                                       */
/*                                                                          */
/****************************************************************************/
#include <wtrcdata.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\wtrcrc.h ===
/**INC+**********************************************************************/
/* Header:    wtrcrc.h                                                      */
/*                                                                          */
/* Purpose:   Trace DLL resource header file                                */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log$
**/
/**INC-**********************************************************************/

#define TRC_IDD_ASSERT   1000
#define TRC_ID_TEXT      1001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\wtrcdata.c ===
/**MOD+**********************************************************************/
/* Module:    wtrcdata.c                                                    */
/*                                                                          */
/* Purpose:   Internal tracing data - Windows specific.                     */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/trc/wtrcdata.c_v  $
 *
 *    Rev 1.4   09 Jul 1997 18:03:10   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.3   03 Jul 1997 13:28:56   AK
 * SFR0000: Initial development completed
**/
/**MOD-**********************************************************************/

#ifndef DLL_DISP
/****************************************************************************/
/* Handle to the trace DLL mutex object.                                    */
/****************************************************************************/
DC_DATA(HANDLE,             trchMutex,               0);

/****************************************************************************/
/* Handle and pointer to the trace DLL shared data.                         */
/****************************************************************************/
DC_DATA(PTRC_SHARED_DATA,   trcpSharedData,          0);

/****************************************************************************/
/* Trace file name array.                                                   */
/****************************************************************************/
DC_DATA_ARRAY_NULL(PDCTCHAR, trcpFiles,         TRC_NUM_FILES, DC_STRUCT1(0));

/****************************************************************************/
/* Per-process status flag.                                                 */
/****************************************************************************/
DC_DATA(DCINT32,            trcProcessStatus,        0);

/****************************************************************************/
/* Flag to indicate if we created the shared data MMF, opened/created the   */
/* trace files.  We assume that we have created them.                       */
/****************************************************************************/
DC_DATA(DCBOOL,           trcCreatedTraceFiles,    TRUE);

#endif

#include <ntrcdata.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\ezippy\ezippy.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    eZippy Main

Abstract:

    Entrypoint for eZippy.

Author:

    Marc Reyhner 8/28/00

--*/

#include "stdafx.h"
#include "eZippy.h"
#include "ZippyWindow.h"
#include "TraceManager.h"
#include "resource.h"

// instantiation of the g_hInstance variable
HINSTANCE g_hInstance = NULL;

int
WINAPI WinMain(
	IN HINSTANCE hInstance, 
	IN HINSTANCE hPrevInstance, 
	IN LPSTR lpCmdLine,
	IN int nCmdShow
	)

/*++

Routine Description:

    This sets up the trace manager and the zippy window then does
    the event loop.

Arguments:

    See win32 WinMain docs

Return value:
    
    0 - Success

    Non zero - some error

--*/
{
	INITCOMMONCONTROLSEX controlStruct;
    MSG msg;
    DWORD dwResult;
	CZippyWindow mainWindow;
    CTraceManager tracer;
    LPTSTR lpstrCmdLine;
    HACCEL hAccel;

    g_hInstance = hInstance;

    
    controlStruct.dwSize = sizeof(controlStruct);
    controlStruct.dwICC = ICC_BAR_CLASSES;
    
    InitCommonControlsEx(&controlStruct);

    CTraceManager::_InitTraceManager();
    
	dwResult = mainWindow.Create(&tracer);
    if (lpCmdLine && lpCmdLine[0]) {
        // kill any leading and trailing " marks
        lpstrCmdLine = GetCommandLine();
        if (lpstrCmdLine[0] == '"') {
            lpstrCmdLine++;
            lpstrCmdLine[_tcslen(lpstrCmdLine)-1] = 0;
        }
        mainWindow.LoadConfFile(lpstrCmdLine);
    }

    tracer.StartListenThread(&mainWindow);

    if (dwResult) {
        return dwResult;
    }

    hAccel = LoadAccelerators(hInstance,MAKEINTRESOURCE(IDR_ACCELERATOR));

    while (0 < GetMessage(&msg,NULL,0,0)) {
        if (mainWindow.IsDialogMessage(&msg)) {
            // if it is a dialog message we are done
            // processing this message
            continue;
        }
        if (!mainWindow.TranslateAccelerator(hAccel,&msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    CTraceManager::_CleanupTraceManager();
    return 0;
}

INT
LoadStringSimple(
    IN UINT uID,
    OUT LPTSTR lpBuffer
    )

/*++

Routine Description:

    This will load the given string from the applications string table.  If
    it is longer than MAX_STR_LEN it is truncated.  lpBuffer should be at least
    MAX_STR_LEN characters long.  If the string does not exist we return 0
    and set the buffer to IDS_STRINGMISSING, if that failes then we set it to the
    hard coded STR_RES_MISSING.

Arguments:

    uID - Id of the resource to load.

    lpBuffer - Buffer of MAX_STR_LEN to hold the string

Return value:
    
    0 - String resource could not be loaded.

    postive integer - length of the string loaded.

--*/
{
    INT length;
    
    length = LoadString(g_hInstance,uID,lpBuffer,MAX_STR_LEN);
    if (length == 0) {
        length = LoadString(g_hInstance,IDS_STRINGMISSING,lpBuffer,MAX_STR_LEN);
        if (length == 0) {
            _tcscpy(lpBuffer,_T(""));
        }
        length = 0;
    }

    return length;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\ezippy\modaldialog.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Modal Dialog

Abstract:

    This contains the abstract class CModalDialog and the trivial sub class
    CModalOkDialog which does a simple ok dialog.

Author:

    Marc Reyhner 8/28/2000

--*/

#ifndef __MODALDIALOG_H__
#define __MODALDIALOG_H__



class CModalDialog  
{
public:
	INT_PTR DoModal(LPCTSTR lpTemplate, HWND hWndParent);
	
protected:
    virtual INT_PTR CALLBACK DialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)=0;
	virtual INT_PTR OnCreate(HWND hWnd);

private:

    static INT_PTR CALLBACK _DialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);

};

class CModalOkDialog : public CModalDialog {

protected:
    
    virtual INT_PTR CALLBACK DialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\ezippy\ezippy.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    eZippy Main

Abstract:

    Global variables and functions for zippy.

Author:

    Marc Reyhner 8/28/2000

--*/

#ifndef __EZIPPY_H__
#define __EZIPPY_H__

#define MAX_STR_LEN 2048

#define ZIPPY_FONT                      _T("Courier New")
#define ZIPPY_FONT_SIZE                 8
#define ZIPPY_REG_KEY                   _T("SOFTWARE\\Microsoft\\eZippy")


extern HINSTANCE g_hInstance;


INT LoadStringSimple(UINT uID,LPTSTR lpBuffer);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\ztrcdata.c ===
/**MOD+**********************************************************************/
/* Module:    ztrcdata.c                                                    */
/*                                                                          */
/* Purpose:   Internal tracing data proxy file                              */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/trc/ztrcdata.c_v  $
 *
 *    Rev 1.2   03 Jul 1997 13:29:10   AK
 * SFR0000: Initial development completed
**/
/**MOD-**********************************************************************/

#include <adcg.h>

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Determine our target OS and include the appropriate header file.         */
/* Currently we support:                                                    */
/*                                                                          */
/* Windows NT : wtrcdata.c                                                  */
/* UNIX       : xtrcdata.c                                                  */
/* MacOS 7    : mtrcdata.c                                                  */
/*                                                                          */
/****************************************************************************/
#ifdef OS_WIN32
#include <wtrcdata.c>
#elif defined( OS_UNIX )
#include <xtrcdata.c>
#elif defined( OS_MAC7 )
#include <mtrcdata.c>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\ezippy\modaldialog.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Modal Dialog

Abstract:

    This contains the abstract class CModalDialog and the trivial sub class
    CModalOkDialog which does a simple ok dialog.

Author:

    Marc Reyhner 8/28/2000

--*/

#include "stdafx.h"
#include "ModalDialog.h"
#include "eZippy.h"

INT_PTR
CModalDialog::DoModal(
    IN LPCTSTR lpTemplate,
    IN HWND hWndParent
    )

/*++

Routine Description:

    This does a modal dialog from the given template.

Arguments:

    lpTemplate - Template to use see docs on DialogBoxParam

    hWndParent - Parent window for the dialog

Return value:
    
    Dialog return code see docs on DialogBoxParam

--*/
{
    return DialogBoxParam(g_hInstance,lpTemplate,hWndParent,_DialogProc,(LPARAM)this);
}

INT_PTR CALLBACK 
CModalDialog::_DialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    If this is a WM_INITDIALOG OnCreate is called.  Otherwise the non-static
    DialogProc function is called.

Arguments:

    See win32 DialogProc docs

Return value:
    
    TRUE - Message was handles

    FALSE - We did not handle the message

--*/
{
    CModalDialog *rDialog;

    if (uMsg == WM_INITDIALOG) {
        rDialog = (CModalDialog*)lParam;
        SetWindowLongPtr(hwndDlg,DWLP_USER,lParam);
        return rDialog->OnCreate(hwndDlg);
    }
    rDialog = (CModalDialog*)GetWindowLongPtr(hwndDlg,DWLP_USER);
    if (!rDialog) {
        return FALSE;
    }
    return rDialog->DialogProc(hwndDlg,uMsg,wParam,lParam);
}

INT_PTR
CModalDialog::OnCreate(
    IN HWND hWnd
    )

/*++

Routine Description:

    Empty OnCreate handler for subclasses which don't want to overide this.
    There is no need for a subclass to call this function if it does something
    in OnCreate

Arguments:

    hWnd - the dialog window.

Return value:
    
    TRUE - Always return success (sets keyboard focus).

--*/
{
    return TRUE;
}

INT_PTR CALLBACK
CModalOkDialog::DialogProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    The one override for CModalOkDialog simply terminates
    the dialog when an IDOK or IDCANCEL command is received

Arguments:

    See win32 DialogProc docs

Return value:
    
    TRUE - We handled the message

    FALSE - We didn't handle the message

--*/
{
    WORD command;

    if (uMsg == WM_COMMAND) {
        command = LOWORD(wParam);
        if (command == IDOK||command==IDCANCEL) {
            EndDialog(hwndDlg,command);
            return TRUE;
        }

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\wtrcint.c ===
/**MOD+**********************************************************************/
/* Module:    wtrcint.c                                                     */
/*                                                                          */
/* Purpose:   Internal tracing functions - Windows specific.                */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/trc/wtrcint.c_v  $
 *
 *    Rev 1.10   22 Aug 1997 15:11:48   SJ
 * SFR1291: Win16 Trace DLL doesn't write integers to ini file properly
 *
 *    Rev 1.9   09 Jul 1997 18:03:42   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.8   03 Jul 1997 13:29:04   AK
 * SFR0000: Initial development completed
**/
/**MOD-**********************************************************************/

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
#include <adcg.h>

/****************************************************************************/
/* Define TRC_FILE and TRC_GROUP.                                           */
/****************************************************************************/
#define TRC_FILE    "wtrcint"
#define TRC_GROUP   TRC_GROUP_TRACE

/****************************************************************************/
/* Trace specific includes.                                                 */
/*                                                                          */
/* Note that including atrcapi.h automatically includes wtrcapi.h for us.   */
/****************************************************************************/
#include <atrcapi.h>
#include <atrcint.h>
#include <wtrcrc.h>

#include <ndcgver.h>

/****************************************************************************/
/*                                                                          */
/* DATA                                                                     */
/*                                                                          */
/****************************************************************************/
#define DC_INCLUDE_DATA
#include <atrcdata.c>
#undef DC_INCLUDE_DATA

/****************************************************************************/
/*                                                                          */
/* FUNCTIONS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* FUNCTION: TRCGetModuleFileName(...)                                      */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function gets the DLL module file name, without path or extension.  */
/* Global trchModule must contain the library module handle (WIN32) or      */
/* instance handle (WIN16).                                                 */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pModuleName  : address of buffer into which the module name is written.  */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* DC_RC_OK is successful, error code otherwise.                            */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCGetModuleFileName(PDCTCHAR pModuleName,
                                       UINT cchModuleName)
{
    DCINT rc = DC_RC_OK;
    PDCTCHAR pTemp;
    PDCTCHAR pName;
    DCTCHAR  pModuleFileName[TRC_FILE_NAME_SIZE];
    HRESULT hr;

    /************************************************************************/
    /* Get the trace DLL module file name.  We use this later when we get a */
    /* stack trace.                                                         */
    /************************************************************************/
    if ( GetModuleFileName(trchModule,
                           pModuleFileName,
                           TRC_FILE_NAME_SIZE) != 0 )
    {
        pModuleFileName[TRC_FILE_NAME_SIZE-1] = 0;
        /********************************************************************/
        /* The module file name is currently in the form of a complete      */
        /* path - however we only want the actual module name.              */
        /********************************************************************/
        pName = pModuleFileName;
        pTemp = DC_TSTRCHR(pName, _T('\\'));
        while (NULL != pTemp)
        {
            pName = pTemp + 1;
            pTemp = DC_TSTRCHR(pName, _T('\\'));
        }

        /********************************************************************/
        /* Now remove the file name extension - we do this by replacing     */
        /* the decimal point with a null.                                   */
        /********************************************************************/
        pTemp = DC_TSTRCHR(pName, _T('.'));
        if (NULL != pTemp)
        {
            *pTemp = _T('\0');
        }

        /********************************************************************/
        /* Finally copy what remains into the caller's buffer               */
        /********************************************************************/
        hr = StringCchCopy(pModuleName, cchModuleName, pName);
        if (FAILED(hr)) {
            rc = TRC_RC_IO_ERROR;
        }
    }
    else
    {
        rc = TRC_RC_IO_ERROR;
    }

    return(rc);
}

/**PROC+*********************************************************************/
/* Name:      TRCAssertDlgProc                                              */
/*                                                                          */
/* Purpose:   Dialog Proc for assert box                                    */
/*                                                                          */
/* Returns:   TRUE / FALSE                                                  */
/*                                                                          */
/* Params:    IN  usual Windows parameters                                  */
/*                                                                          */
/**PROC-*********************************************************************/
INT_PTR CALLBACK TRCAssertDlgProc(HWND hwndDlg,
                                  UINT msg,
                                  WPARAM wParam,
                                  LPARAM lParam)
{
    INT_PTR rc = FALSE;
    RECT rect;
    DCINT xPos;
    DCINT yPos;
    PDCTCHAR pText;

    switch (msg)
    {
        case WM_INITDIALOG:
        {
            /****************************************************************/
            /* Set the text                                                 */
            /****************************************************************/
            pText = (PDCTCHAR)lParam;
            SetDlgItemText(hwndDlg, TRC_ID_TEXT, pText);
            SetWindowText(hwndDlg, TRC_ASSERT_TITLE);

            /****************************************************************/
            /* Center on the screen, and set to topmost.                    */
            /****************************************************************/
            GetWindowRect(hwndDlg, &rect);

            xPos = ( GetSystemMetrics(SM_CXSCREEN) -
                     (rect.right - rect.left)) / 2;
            yPos = ( GetSystemMetrics(SM_CYSCREEN) -
                     (rect.bottom - rect.top)) / 2;

            SetWindowPos(hwndDlg,
                         HWND_TOPMOST,
                         xPos, yPos,
                         rect.right - rect.left,
                         rect.bottom - rect.top,
                         SWP_NOACTIVATE);
            rc = TRUE;
        }
        break;

        case WM_COMMAND:
        {
            switch(DC_GET_WM_COMMAND_ID(wParam))
            {
                case IDABORT:
                case IDRETRY:
                case IDIGNORE:
                {
                    PostMessage(hwndDlg,
                                WM_USER + DC_GET_WM_COMMAND_ID(wParam),
                                0, 0);
                    rc = TRUE;
                }
                break;

                default:
                {
                    /********************************************************/
                    /* Ignore other messages                                */
                    /********************************************************/
                }
                break;
            }
        }

        case WM_CLOSE:
        {
            /****************************************************************/
            /* If 'x' selected, treat as 'Ignore'                           */
            /****************************************************************/
            PostMessage(hwndDlg, WM_USER + IDIGNORE, 0, 0);
        }
        break;

        default:
        {
            /****************************************************************/
            /* Ignore                                                       */
            /****************************************************************/
        }
        break;
    }

    return(rc);

} /* TRCAssertDlgProc */


/****************************************************************************/
/* FUNCTION: TRCDisplayAssertBox(...)                                       */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function displays an assert box and then decides (based on the user */
/* action) whether to kill the thread, jump into a debugger or just ignore  */
/* the assert.                                                              */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pText           : a pointer to the null-terminated assert text string.   */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCDisplayAssertBox(PDCTCHAR pText)
{
    HWND  hwndDlg;
    MSG   msg;
    DCINT rc;
    HRESULT hr;
    TCHAR szFormattedText[TRC_FRMT_BUFFER_SIZE];

    /************************************************************************/
    /* If we are not currently displaying an assert dialog box then display */
    /* one.  This function will display an assert box and then handle the   */
    /* user action (i.e.  whether we kill the thread, jump into the         */
    /* debugger or just ignore (!) the assert).                             */
    /*                                                                      */
    /* Note that the testing and setting of the flag is not done under a    */
    /* mutex and therefore can potentially be preempted.  There is          */
    /* therefore the possibility that multiple threads can assert           */
    /* simulataneously (a rare occurance) and thus we end up with multiple  */
    /* assert dialogs on the screen.  However we avoid the cascading assert */
    /* problem.                                                             */
    /************************************************************************/
    if (TEST_FLAG(trcpFilter->trcStatus, TRC_STATUS_ASSERT_DISPLAYED))
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* Set the flag to indicate that an assert is currently displayed,      */
    /* display the assert and then clear the flag.                          */
    /************************************************************************/
    SET_FLAG(trcpFilter->trcStatus, TRC_STATUS_ASSERT_DISPLAYED);

    /************************************************************************/
    /* To prevent re-entrancy, do not use MessageBox.  Create a dialog and  */
    /* use a message loop to handle this until it has been dismissed.  Note */
    /* that this will block the thread which issued the assert.             */
    /* Pass the assert text to the dialog's WM_INITDDIALOG callback.        */
    /************************************************************************/
    hwndDlg = CreateDialogParam(trchModule,
                                MAKEINTRESOURCE(TRC_IDD_ASSERT),
                                NULL,
                                TRCAssertDlgProc,
                                (LPARAM)(pText));

    if (hwndDlg == NULL)
    {
        /********************************************************************/
        /* Use Message Box - but note that this will give reentrancy        */
        /* problems.  Since the choice on this dialog is                    */
        /* Abort/Retry/Ignore, we add an explanatory message to the effect  */
        /* that 'Retry' is really 'Debug'.                                  */
        /********************************************************************/
        
        hr = StringCchPrintf(szFormattedText,
                             SIZE_TCHARS(szFormattedText),
                             _T("%s %s"),
                             pText,
                             TRC_ASSERT_TEXT2);

        if (SUCCEEDED(hr)) {
            rc = MessageBox(NULL,
                            pText,
                            TRC_ASSERT_TITLE,
                            MB_ABORTRETRYIGNORE | MB_ICONSTOP |
                            MB_SETFOREGROUND);
        }
        else {
            DC_QUIT;
        }
    }
    else
    {
        /********************************************************************/
        /* Show the dialog.                                                 */
        /********************************************************************/
        ShowWindow(hwndDlg, SW_SHOW);

        /********************************************************************/
        /* Only pull off messages for this dialog.                          */
        /********************************************************************/
        while (GetMessage (&msg, hwndDlg, 0, 0))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);

            /****************************************************************/
            /* WM_USER + ID??? is used to terminate processing.             */
            /****************************************************************/
            if (msg.message >= WM_USER)
            {
                /************************************************************/
                /* finished                                                 */
                /************************************************************/
                EndDialog(hwndDlg, IDOK);
                break;
            }
        }

        /********************************************************************/
        /* Get the return code from the message ID                          */
        /********************************************************************/
        if (msg.message >= WM_USER)
        {
            rc = msg.message - WM_USER;
        }
        else
        {
            /****************************************************************/
            /* WM_QUIT - treat as an Abort.                                 */
            /****************************************************************/
            rc = IDABORT;
        }
    }

    /************************************************************************/
    /* Now that the assert box is no more, clear the flag.                  */
    /************************************************************************/
    CLEAR_FLAG(trcpFilter->trcStatus, TRC_STATUS_ASSERT_DISPLAYED);

    /************************************************************************/
    /* Switch on the return code from MessageBox.                           */
    /************************************************************************/
    switch (rc)
    {
        case IDABORT:
        {
            /****************************************************************/
            /* Abort selected - so exit the current thread.                 */
            /****************************************************************/
            TRCExitProcess(TRC_THREAD_EXIT);
        }
        break;

        case IDRETRY:
        {
            /****************************************************************/
            /* Retry selected - jump into the debugger if JIT (Just In      */
            /* Time) debugging is enabled.                                  */
            /****************************************************************/
            DebugBreak();
        }
        break;

        case IDIGNORE:
        {
            /****************************************************************/
            /* Ignore selected - just blindly carry on...                   */
            /****************************************************************/
        }
        break;
    }

DC_EXIT_POINT:
    return;

} /* TRCDisplayAssertBox */

/****************************************************************************/
/* FUNCTION: TRCInternalTrace(...)                                          */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function writes a string to the debugger on every process attach    */
/* detach.  Note that in general the mutex will not have been obtained      */
/* when this function is called.                                            */
/*                                                                          */
/* The problem with this function is that DllMain will call this function   */
/* every time a thread attaches / detaches at which point it has the        */
/* process critical section.  However we may be in the middle of a stack    */
/* trace on another thread and holding the trace mutex.  Stack tracing      */
/* requires the process critical section while holding the trace mutex      */
/* which deadlocks if DllMain is waiting on the trace mutex.                */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* type            : is this an process/thread attach/detach or a symbols   */
/*                   loading/loaded/unloaded.                               */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCInternalTrace(DCUINT32 type)
{
    PDCTCHAR  pStatus;
    DC_DATE  theDate;
    DC_TIME  theTime;
    DCUINT32 processId;
    DCUINT32 threadId;
    DCUINT32 length;
    DCTCHAR   szOutputBuffer[TRC_FRMT_BUFFER_SIZE];
    HRESULT  hr;

    /************************************************************************/
    /* Determine whether this is an attach or a detach.                     */
    /************************************************************************/
    switch (type)
    {
        case TRC_TRACE_DLL_INITIALIZE:
        {
            pStatus = _T("Trace initialized");
        }
        break;

        case TRC_TRACE_DLL_TERMINATE:
        {
            pStatus = _T("Trace terminated ");
        }
        break;

        case TRC_PROCESS_ATTACH_NOTIFY:
        {
            pStatus = _T("Process attached ");
        }
        break;

        case TRC_PROCESS_DETACH_NOTIFY:
        {
            pStatus = _T("Process detached ");
        }
        break;

        case TRC_THREAD_ATTACH_NOTIFY:
        {
            pStatus = _T("Thread attached  ");
        }
        break;

        case TRC_THREAD_DETACH_NOTIFY:
        {
            pStatus = _T("Thread detached  ");
        }
        break;

        case TRC_SYMBOLS_LOADING_NOTIFY:
        {
            pStatus = _T("Loading symbols  ");
        }
        break;

        case TRC_SYMBOLS_LOADED_NOTIFY:
        {
            pStatus = _T("Symbols loaded   ");
        }
        break;

        case TRC_SYMBOLS_UNLOAD_NOTIFY:
        {
            pStatus = _T("Symbols freed    ");
        }
        break;

        case TRC_FILES_RESET:
        {
            pStatus = _T("Trace files reset");
        }
        break;

        default:
        {
            pStatus = _T("Undefined       ");
        }
        break;
    }

    /************************************************************************/
    /* Get the current date and time.                                       */
    /************************************************************************/
    TRCGetCurrentDate(&theDate);
    TRCGetCurrentTime(&theTime);

    /************************************************************************/
    /* Get our process and thread IDs.                                      */
    /************************************************************************/
    processId = TRCGetCurrentProcessId();
    threadId  = TRCGetCurrentThreadId();

    /************************************************************************/
    /* Format the attach/detach string.                                     */
    /************************************************************************/
    hr = StringCchPrintf(
                    szOutputBuffer,
                    SIZE_TCHARS(szOutputBuffer),
                    _T("### %s (") TRC_PROC_FMT _T(":") TRC_THRD_FMT _T(") at ")
                    _T("") TRC_TIME_FMT _T(" ") TRC_DATE_FMT _T(" ###\r\n"),
                    pStatus,
                    processId,
                    threadId,
                    theTime.hour,
                    theTime.min,
                    theTime.sec,
                    theTime.hundredths,
                    theDate.day,
                    theDate.month,
                    theDate.year
                    );

    if (SUCCEEDED(hr)) {
        /************************************************************************/
        /* Now output this string to the debugger.  We can't output this to     */
        /* file as we need to have the trace mutex to do that and we may not    */
        /* have the mutex.  To avoid confusion we only write to the debugger.   */
        /************************************************************************/
        length = DC_TSTRLEN(szOutputBuffer);
        OutputDebugString(szOutputBuffer);
    }

    return;

} /* TRCInternalTrace */

/****************************************************************************/
/* FUNCTION: TRCMaybeSwapFile(...)                                          */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function checks if the current trace file has enough space to       */
/* accomodate a string of the supplied length and, if not, makes the other  */
/* trace file current.                                                      */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* length          : length of the string.                                  */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCMaybeSwapFile(DCUINT length)
{
    /************************************************************************/
    /* If the length of the string plus the offset is greater than the      */
    /* length of the trace file then we need to swap trace files.           */
    /************************************************************************/
    if ((trcpSharedData->trcOffset + length) > trcpConfig->maxFileSize)
    {
        /********************************************************************/
        /* We need to swap trace files so set the offset to 0 and then      */
        /* flip the trace file.                                             */
        /********************************************************************/
        trcpSharedData->trcOffset = 0;
        trcpSharedData->trcIndicator++;
        trcpSharedData->trcIndicator %= TRC_NUM_FILES;

        /********************************************************************/
        /* Now we need to reset the new trace file by blanking it out.      */
        /********************************************************************/
        TRCBlankFile(trcpSharedData->trcIndicator);
    }

DC_EXIT_POINT:
    return;

} /* TRCOutputToFile */

/****************************************************************************/
/* FUNCTION: TRCReadProfInt(...)                                            */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This reads a private profile integer from the registry.                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pSection        : section containing the entry to read                   */
/* pEntry          : entry name of integer to retrieve                      */
/* pValue          : buffer to return the entry in                          */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0               : success                                                */
/* TRC_RC_IO_ERROR : I/O error.                                             */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCReadProfInt(PDCTCHAR  pEntry,
                                 PDCUINT32 pValue)
{
    DCUINT rc = 0;

    /************************************************************************/
    /* First try to read the value from the current user section            */
    /************************************************************************/
    rc = TRCReadEntry(HKEY_CURRENT_USER,
                      pEntry,
                      (PDCTCHAR)pValue,
                      sizeof(*pValue),
                      REG_DWORD);
    if (0 != rc)
    {
        /********************************************************************/
        /* Couldn't read the value from the current user section.  Try to   */
        /* pick up a default value from the local machine section.          */
        /********************************************************************/
        rc = TRCReadEntry(HKEY_LOCAL_MACHINE,
                          pEntry,
                          (PDCTCHAR)pValue,
                          sizeof(*pValue),
                          REG_DWORD);
        if (0 != rc)
        {
            /****************************************************************/
            /* There is nothing we can do so just fall through.             */
            /****************************************************************/
        }
    }

    return(rc);

} /* TRCReadProfInt */

/****************************************************************************/
/* FUNCTION: TRCReadProfString(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This reads a private profile string from registry.                       */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pSection        : section containing the entry to read.                  */
/* pEntry          : entry name of string to retrieve (if NULL all entries  */
/*                   in the section are returned).                          */
/* pBuffer         : buffer to return the entry in.                         */
/* bufferSize      : size of the buffer in bytes.                           */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0               : success.                                               */
/* TRC_RC_IO_ERROR : I/O error.                                             */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCReadProfString(PDCTCHAR pEntry,
                                    PDCTCHAR pBuffer,
                                    DCINT16 bufferSize)
{
    DCUINT rc                = 0;

    /************************************************************************/
    /* First try to read the value from the current user section.           */
    /************************************************************************/
    rc = TRCReadEntry(HKEY_CURRENT_USER,
                      pEntry,
                      pBuffer,
                      bufferSize,
                      REG_SZ);
    if (0 != rc)
    {
        /********************************************************************/
        /* Couldn't read the value from the current user section.  Try to   */
        /* pick up a default value from the local machine section.          */
        /********************************************************************/
        rc = TRCReadEntry(HKEY_LOCAL_MACHINE,
                          pEntry,
                          pBuffer,
                          bufferSize,
                          REG_SZ);
        if (0 != rc)
        {
            /****************************************************************/
            /* There is nothing we can do so just fall through.             */
            /****************************************************************/
        }
    }

    return(rc);

} /* TRCReadProfString */

/****************************************************************************/
/* FUNCTION: TRCResetTraceFiles(...)                                        */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function resets the trace files.  It nulls out both trace files     */
/* and then resets the file offset to 0 and the file indicator to file 0.   */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCResetTraceFiles(DCVOID)
{
    DCUINT i;

    /************************************************************************/
    /* Blank out the trace files.  Note that we must have the mutex at this */
    /* point.                                                               */
    /************************************************************************/
    for (i = 0; i < TRC_NUM_FILES; i++)
    {
        TRCBlankFile(i);
    }

    /************************************************************************/
    /* Set the trace file indicator to file 0 and set the file offset to 0. */
    /************************************************************************/
    trcpSharedData->trcIndicator = 0;
    trcpSharedData->trcOffset    = 0;

    /************************************************************************/
    /* Output a debug string.                                               */
    /************************************************************************/
    TRCInternalTrace(TRC_FILES_RESET);

} /* TRCResetTraceFiles */

/****************************************************************************/
/* FUNCTION: TRCWriteProfInt(...)                                           */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This writes a private profile integer to the registry.                   */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pSection        : section containing the entry written                   */
/* pEntry          : entry name of integer to write.  If the entry does not */
/*                   exist it is created and if it is NULL the entire       */
/*                   section is deleted.                                    */
/* pValue          : pointer to the integer to be written.  If the pointer  */
/*                   is NULL the entry is deleted.                          */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0               : success                                                */
/* TRC_RC_IO_ERROR : I/O error.                                             */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCWriteProfInt(PDCTCHAR  pEntry,
                                  PDCUINT32 pValue)
{
    DCUINT rc = 0;

    /************************************************************************/
    /* Write the entry to the current user section.                         */
    /************************************************************************/
    rc = TRCWriteEntry(HKEY_CURRENT_USER,
                       pEntry,
                       (PDCTCHAR)pValue,
                       sizeof(DCINT),
                       REG_DWORD);
    if (0 != rc)
    {
        TRCDebugOutput(_T("Failed to write int"));
    }

    return(rc);

} /* TRCWriteProfInt */

/****************************************************************************/
/* FUNCTION: TRCWriteProfString(...)                                        */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This writes a private profile string to the registry.                    */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pSection        : section containing the entry written                   */
/* pEntry          : entry name of string to write.  If the entry does not  */
/*                   exist it is created and if it is NULL the entire       */
/*                   section is deleted.                                    */
/* pBuffer         : buffer containing the entry.  If the buffer is NULL    */
/*                   the entry is deleted.                                  */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0               : success                                                */
/* TRC_RC_IO_ERROR : I/O error.                                             */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCWriteProfString(PDCTCHAR pEntry,
                                     PDCTCHAR pBuffer)
{
    DCUINT rc = 0;

    /************************************************************************/
    /* Write the entry to the current user section                          */
    /************************************************************************/
    rc = TRCWriteEntry(HKEY_CURRENT_USER,
                       pEntry,
                       pBuffer,
                       DC_TSTRBYTELEN(pBuffer),
                       REG_SZ);
    if (0 != rc)
    {
        TRCDebugOutput(_T("Failed to write string"));
    }

    return(rc);

} /* TRCWriteProfString */

#include <ntrcint.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\ezippy\stdafx.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    StdAfx

Abstract:

    Precompiled headers module.

Author:

    Marc Reyhner 7/5/2000

--*/

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\ezippy\tracemanager.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Trace Manager

Abstract:

    This does all the interfacing with the tracing code.

Author:

    Marc Reyhner 8/28/2000

--*/

#ifndef __TRACEMANAGER_H__
#define __TRACEMANAGER_H__


// We aren't tracing in this app so we only define tracegroup so that
// we can include atrcapi.h
#define TRC_GROUP junk
#define OS_WIN32
#include <adcgbase.h>
#include <atrcapi.h>
#undef TRC_GROUP

class CZippyWindow;

class CTraceManager  
{
public:
	static DWORD _InitTraceManager();
    static VOID _CleanupTraceManager();
    
    CTraceManager();
    virtual ~CTraceManager();
    VOID TRC_ResetTraceFiles();
	BOOL SetCurrentConfig(PTRC_CONFIG lpNewConfig);
	BOOL GetCurrentConfig(PTRC_CONFIG lpConfig);
	DWORD StartListenThread(CZippyWindow *rZippyWindow);
    DWORD StopListenThread();

private:
	
    static HANDLE gm_hDBWinSharedDataHandle;
    static LPVOID gm_hDBWinSharedData;
    static HANDLE gm_hDBWinDataReady;
    static HANDLE gm_hDBWinDataAck;

    CZippyWindow *m_rZippyWindow;
    HANDLE m_hThread;
    BOOL m_bThreadStop;

    static DWORD WINAPI _ThreadProc(LPVOID lpParameter);
    
    DWORD ThreadProc();
    VOID OnNewData();
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\ezippy\stdafx.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    StdAfx

Abstract:

    Precompiled headers module.

Author:

    Marc Reyhner 7/5/2000

--*/

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <windows.h>
#include <tchar.h>
#include <CommCtrl.h>
#include <RichEdit.h>
#include <RichOle.h>

// We include this to get things like ID_EDIT_COPY
#include <AfxRes.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\ezippy\optionsdialog.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Options Dialog

Abstract:

    This class implements the options dialog which sets the
    tracing properties

Author:

    Marc Reyhner 9/12/2000

--*/

#ifndef __OPTIONSDIALOG_H__
#define __OPTIONSDIALOG_H__

class CTraceManager;

class COptionsDialog  
{
public:
	COptionsDialog(CTraceManager *rTracer);
	
    virtual VOID DoDialog(HWND hWndParent);

private:

    HWND m_hFilterDlg;
    HWND m_hTraceDlg;
    HWND m_hFilterSliderControl;
    CTraceManager *m_rTracer;

    static INT_PTR CALLBACK _FilterDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
    static INT_PTR CALLBACK _TraceDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);

    INT_PTR CALLBACK FilterDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
    INT_PTR CALLBACK TraceDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
    INT_PTR OnCreateFilter(HWND hWnd);
    INT_PTR OnCreateTrace(HWND hWnd);
    BOOL TraceVerifyParameters();
	BOOL OnTraceOk();
	VOID OnFilterOk();
	VOID OnFilterSliderMove();
    VOID OnFilterClearAll();
	VOID OnFilterSelectAll();
    BOOL VerifyNumberFormat(LPCTSTR numberFormat);
    VOID LoadPrefixMRU(LPCTSTR currentPrefix);
    VOID StorePrefixMRU(LPCTSTR currentPrefix);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\ezippy\tracemanager.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Trace Manager

Abstract:

    This does all the interfacing with the tracing code.

Author:

    Marc Reyhner 8/28/2000

--*/

#include "stdafx.h"
#include "ZippyWindow.h"
#include "TraceManager.h"
#include "eZippy.h"
#include "resource.h"

// Instantions of all the static class members.
HANDLE CTraceManager::gm_hDBWinSharedDataHandle = NULL;
LPVOID CTraceManager::gm_hDBWinSharedData = NULL;
HANDLE CTraceManager::gm_hDBWinDataReady = NULL;
HANDLE CTraceManager::gm_hDBWinDataAck = NULL;

// Our various defines for dbwin.
#define DBWIN_BUFFER_READY  _T("DBWIN_BUFFER_READY")
#define DBWIN_DATA_READY    _T("DBWIN_DATA_READY")
#define DBWIN_BUFFER_NAME   _T("DBWIN_BUFFER")
#define DBWIN_BUFFER_SIZE   4096



CTraceManager::CTraceManager(
    )

/*++

Routine Description:

    The constructor simply initializes the class variables.

Arguments:

    None

Return value:
    
    None

--*/
{
    m_hThread = NULL;
    m_bThreadStop = FALSE;
}

CTraceManager::~CTraceManager(
    )

/*++

Routine Description:

    The destructor does nothing now.  Don't call this before the 
    listen thread exits or bad things may happen.

Arguments:

    None

Return value:
    
    None

--*/
{

}

DWORD
CTraceManager::StartListenThread(
    IN CZippyWindow *rZippyWindow
    )

/*++

Routine Description:

    This starts a new thread listening for trace output.

Arguments:

    rZippyWindow - The main zippy window which will have data sent
                   to it.

Return value:
    
    0 - Success

    Non zero - a win32 error code

--*/
{
    DWORD dwResult;
    DWORD threadId;

    dwResult = 0;

    m_rZippyWindow = rZippyWindow;

    m_hThread = CreateThread(NULL,0,_ThreadProc,this,0,&threadId);
    if (!m_hThread) {
        dwResult = GetLastError();
    }

    return dwResult;
}

DWORD
CTraceManager::_InitTraceManager(
    )

/*++

Routine Description:

    This initializes all the mutexes and shared memory
    for dbwin.  It also call TRC_Initialize

Arguments:

    None

Return value:
    
    0 - Success

    Non zero - a win32 error code

--*/
{
    DWORD dwResult;
    BOOL bResult;

    dwResult = 0;
    
    TRC_Initialize(TRUE);

    gm_hDBWinDataAck = CreateEvent(NULL,FALSE,FALSE,DBWIN_BUFFER_READY);
    if (!gm_hDBWinDataAck) {
        dwResult = GetLastError();
        goto CLEANUP_AND_EXIT;
    }

    if (ERROR_ALREADY_EXISTS == GetLastError()) {
        TCHAR dlgTitle[MAX_STR_LEN];
        TCHAR dlgMessage[MAX_STR_LEN];

        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);
        LoadStringSimple(IDS_ZIPPYALREADYEXISTS,dlgMessage);

        MessageBox(NULL,dlgMessage,dlgTitle,MB_OK|MB_ICONERROR);

        ExitProcess(1);
    }

    gm_hDBWinDataReady = CreateEvent(NULL,FALSE,FALSE,DBWIN_DATA_READY);
    if (!gm_hDBWinDataReady) {
        dwResult = GetLastError();
        goto CLEANUP_AND_EXIT;
    }

    gm_hDBWinSharedDataHandle = CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READWRITE,
        0,DBWIN_BUFFER_SIZE,DBWIN_BUFFER_NAME);
    if (!gm_hDBWinSharedDataHandle) {
        dwResult = GetLastError();
        goto CLEANUP_AND_EXIT;
    }

    gm_hDBWinSharedData = MapViewOfFile(gm_hDBWinSharedDataHandle,
        FILE_MAP_READ,0,0,0);
    if (!gm_hDBWinSharedData) {
        dwResult = GetLastError();
        goto CLEANUP_AND_EXIT;
    }

CLEANUP_AND_EXIT:
  
    if (dwResult) {
        if (gm_hDBWinSharedData) {
            UnmapViewOfFile(gm_hDBWinSharedData);
            gm_hDBWinSharedData = NULL;
        }
        if (gm_hDBWinSharedDataHandle) {
            CloseHandle(gm_hDBWinSharedDataHandle);
            gm_hDBWinSharedDataHandle = NULL;
        }
        if (gm_hDBWinDataReady) {
            CloseHandle(gm_hDBWinDataReady);
            gm_hDBWinDataReady = NULL;
        }
        if (gm_hDBWinDataAck) {
            CloseHandle(gm_hDBWinDataAck);
            gm_hDBWinDataAck = NULL;
        }

    }

    return dwResult;
}

VOID
CTraceManager::_CleanupTraceManager(
    )

/*++

Routine Description:

    Cleans up all the dbwin stuff.

Arguments:

    None

Return value:
    
    None

--*/
{
    if (gm_hDBWinSharedData) {
        UnmapViewOfFile(gm_hDBWinSharedData);
        gm_hDBWinSharedData = NULL;
    }
    if (gm_hDBWinSharedDataHandle) {
        CloseHandle(gm_hDBWinSharedDataHandle);
        gm_hDBWinSharedDataHandle = NULL;
    }
    if (gm_hDBWinDataReady) {
        CloseHandle(gm_hDBWinDataReady);
        gm_hDBWinDataReady = NULL;
    }
    if (gm_hDBWinDataAck) {
        CloseHandle(gm_hDBWinDataAck);
        gm_hDBWinDataAck = NULL;
    }
}

VOID
CTraceManager::OnNewData(
    )

/*++

Routine Description:

    This is called whenever new data shows up for the trace.  The data
    is then forwarded to the zippy window

Arguments:

    None

Return value:
    
    None

--*/
{
    LPTSTR debugStr;
    LPSTR asciiDebugStr;
    DWORD processID;
    UINT debugStrLen;
#ifdef UNICODE
    INT result;
    TCHAR debugWStr[DBWIN_BUFFER_SIZE];
#endif
    
    debugStr = NULL;
    processID = *(LPDWORD)gm_hDBWinSharedData;
    asciiDebugStr = (LPSTR)((PBYTE)(gm_hDBWinSharedData) + sizeof(DWORD));
    debugStrLen = strlen(asciiDebugStr);
    
#ifdef UNICODE
    debugStr = debugWStr;
    result = MultiByteToWideChar(CP_ACP,0,asciiDebugStr,debugStrLen+1,
        debugStr,DBWIN_BUFFER_SIZE);
    if (!result) {
        // error
        goto CLEANUP_AND_EXIT;
    }
#else
    debugStr = asciiDebugStr;
#endif

    m_rZippyWindow->AppendTextToWindow(processID,debugStr,debugStrLen);

CLEANUP_AND_EXIT:

    return;
}

DWORD WINAPI
CTraceManager::_ThreadProc(
    IN LPVOID lpParameter
    )

/*++

Routine Description:

    Simply calls the non static version of the thread procedure.

Arguments:

    lpParameter - Thread start information

Return value:
    
    See ThreadProc for return values

--*/
{
    return ((CTraceManager*)lpParameter)->ThreadProc();
}

DWORD
CTraceManager::ThreadProc(
    )

/*++

Routine Description:

    This loops catching debug data and then forwarding it to the zippy window.

Arguments:

    None

Return value:
    
    0 - Success

    Non zero - Win32 error code

--*/
{
    DWORD dwResult;

    dwResult = 0;

    SetEvent(gm_hDBWinDataAck);
    while (!m_bThreadStop) {
        dwResult = WaitForSingleObject(gm_hDBWinDataReady,INFINITE);
        if (dwResult != WAIT_OBJECT_0) {
            break;
        }
        OnNewData();
        SetEvent(gm_hDBWinDataAck);

    }

    return dwResult;
}

BOOL
CTraceManager::GetCurrentConfig(
    IN PTRC_CONFIG lpConfig
    )

/*++

Routine Description:

    Returns the current trace configuration

Arguments:

    lpConfig - Pointer to a TRC_CONFIG struct which will receive the configuation.

Return value:
    
    TRUE - config was successfully retrieved.

    FALSE - There was an error getting the config.

--*/
{
    return TRC_GetConfig(lpConfig,sizeof(TRC_CONFIG));
}

BOOL
CTraceManager::SetCurrentConfig(
    IN PTRC_CONFIG lpNewConfig
    )

/*++

Routine Description:

    Sets the trace configuration

Arguments:

    lpConfig - Pointer to the new configuration

Return value:
    
    TRUE - config was successfully set.

    FALSE - There was an error setting the config.

--*/
{
    return TRC_SetConfig(lpNewConfig,sizeof(TRC_CONFIG));
}

VOID
CTraceManager::TRC_ResetTraceFiles(
    )

/*++

Routine Description:

    Just a straight wrapper to the global TRC_ResetTraceFiles function,

Arguments:

    None

Return value:
    
    None

--*/
{
    // The :: is necessary to get the C version of the func.
    ::TRC_ResetTraceFiles();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\ezippy\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ezippy.rc
//
#define IDS_ZIPPYWINDOWTITLE            1
#define IDS_STRINGMISSING               2
#define IDS_ZIPPYALREADYEXISTS          3
#define IDS_FILEOPENERROR               4
#define IDS_FILESAVEERROR               5
#define IDS_SAVEFILEPROMPT              6
#define IDS_SEARCHFAILURE               7
#define IDS_CLEARCONFIRMTITLE           8
#define IDS_CLEARCONFIRMMESSAGE         9
#define IDS_CONFIRMRESETTRACETITLE      10
#define IDS_CONFIRMRESETTRACEMESSAGE    11
#define IDS_ABOUTAPPTITLE               12
#define IDS_ABOUTOTHERSTUFF             13
#define IDS_TRACELEVELDETAILED          14
#define IDS_TRACELEVELNRM               15
#define IDS_TRACELEVELALERT             16
#define IDS_TRACELEVELERROR             17
#define IDS_TRACELEVELASSERT            18
#define IDS_TRACELEVELNONE              19
#define IDS_SETTINGSNOTNUMBER           20
#define IDS_STATUSBARREADY              21
#define IDS_FILELOADERROR               22
#define IDS_FILELOADOPENERROR           23
#define IDS_PREFERENCESDLGTITLE         24
#define IDI_MAINFRAME                   101
#define IDR_MAINMENU                    103
#define IDR_ACCELERATOR                 106
#define IDD_PROPPAGETRACE               106
#define IDD_TRACEOPTIONS                107
#define IDD_FILTEROPTIONS               109
#define IDD_RECORDTRACE                 112
#define IDD_PROPPAGEFILTER              113
#define IDD_PROPPAGE_MEDIUM             114
#define IDD_PROPPAGE_LARGE              115
#define IDC_FILTERLEVEL                 1002
#define IDC_FILTERLEVELDESC             1003
#define IDC_GROUPNETWORK                1005
#define IDC_GROUPSECURITY               1006
#define IDC_GROUPCORE                   1007
#define IDC_GROUPUI                     1008
#define IDC_GROUPUTILITIES              1009
#define IDC_COMBO1                      1010
#define IDC_UNUSED1                     1011
#define IDC_GROUPUNUSED1                1011
#define IDC_UNUSED2                     1012
#define IDC_GROUPUNUSED2                1012
#define IDC_UNUSED3                     1013
#define IDC_GROUPUNUSED3                1013
#define IDC_UNUSED4                     1014
#define IDC_GROUPUNUSED4                1014
#define IDC_UNUSED5                     1015
#define IDC_GROUPUNUSED5                1015
#define IDC_SELECTALL                   1016
#define IDC_CLEARALL                    1017
#define IDC_OUTPUT_FILE                 1019
#define IDC_OUTPUT_DEBUGGER             1020
#define IDC_ERROR_BEEP                  1021
#define IDC_ERROR_BREAK                 1022
#define IDC_OPTION_PROFILE              1023
#define IDC_OPTION_FLUSH                1024
#define IDC_OPTION_STACK                1025
#define IDC_OPTION_STAMP                1026
#define IDC_OPTION_PROCID               1027
#define IDC_OPTION_THREAID              1028
#define IDC_FUNCTION_LENGTH             1029
#define IDC_TRUNCATION_LENGTH           1030
#define IDC_FILTERPREFIX                1031
#define IDC_OPTION_BREAKASSERT          1033
#define ID_HELP_ABOUTEZIPPY             40001
#define ID_FILE_SAVEAS                  40003
#define ID_FILE_EXIT                    40004
#define ID_MONITORING_START             40005
#define ID_MONITORING_STOP              40006
#define ID_VIEW_STATUSBAR               40008
#define ID_EDIT_SELECTALL               40013
#define ID_MONITORING_CLEARSCREEN       40018
#define ID_MONITORING_RESETTRACEFILES   40019
#define ID_EDIT_FINDNEXT                40021
#define ID_OPTIONS_FILTEROPTIONS        40025
#define ID_OPTIONS_FILTER               40026
#define ID_OPTIONS_TRACE                40027
#define ID_FILE_LOADCONF                40028
#define ID_FILE_SAVECONF                40029
#define ID_FILE_SAVECONFAS              40030
#define ID_MONITORING_RECORD            40031
#define ID_MONITORING_PREFERENCES       40037

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        119
#define _APS_NEXT_COMMAND_VALUE         40038
#define _APS_NEXT_CONTROL_VALUE         1034
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\ezippy\optionsdialog.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Options Dialog

Abstract:

    This class implements the options dialog which sets the
    tracing properties

Author:

    Marc Reyhner 9/12/2000

--*/

#include "stdafx.h"
#include "OptionsDialog.h"
#include "eZippy.h"
#include "TraceManager.h"
#include "windows.h"
#include "resource.h"

#define MAX_MRU                 10
#define MRU_STR_PREFIX          _T("PrefixMru")
#define MRU_STR_BUFFER_SIZE     12

COptionsDialog::COptionsDialog(
    IN CTraceManager *rTracer
    )

/*++

Routine Description:

    This just sets the pointer to the trace manager.

Arguments:

    rTracer - Pointer to the trace manager class

Return value:
    
    None

--*/
{
    m_rTracer = rTracer;
}


VOID
COptionsDialog::DoDialog(
    IN HWND hWndParent
    )

/*++

Routine Description:

    This does the dialog modally. We fill in the fields for the two property
    sheet pages and then do the property sheet.  When the user hits OK
    the pages themselves take care of applying the settings.

Arguments:

    hWndParent - Parent window for the dialog

Return value:
    
    None - Since we handle applying the settings within the class
           as well as error UI there is no need for a return value.

--*/
{
    PROPSHEETPAGE pages[2];
    PROPSHEETHEADER psh;
    TCHAR caption[MAX_STR_LEN];

    // filter tab
    pages[0].dwSize = sizeof(PROPSHEETPAGE);
    pages[0].dwFlags = PSP_DEFAULT;
    pages[0].hInstance = g_hInstance;
    pages[0].pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGEFILTER);
    pages[0].pfnDlgProc = _FilterDialogProc;
    pages[0].lParam = (LPARAM)this;

    // trace tab
    pages[1].dwSize = sizeof(PROPSHEETPAGE);
    pages[1].dwFlags = PSP_DEFAULT;
    pages[1].hInstance = g_hInstance;
    pages[1].pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGETRACE);
    pages[1].pfnDlgProc = _TraceDialogProc;
    pages[1].lParam = (LPARAM)this;

    // header

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_NOCONTEXTHELP|PSH_PROPSHEETPAGE|PSH_NOAPPLYNOW;
    psh.hwndParent = hWndParent;
    psh.hInstance = g_hInstance;
    LoadStringSimple(IDS_PREFERENCESDLGTITLE,caption);
    psh.pszCaption = caption;
    psh.nPages = 2;
    psh.nStartPage = 0;
    psh.ppsp = pages;

    PropertySheet(&psh);
}

INT_PTR CALLBACK
COptionsDialog::_FilterDialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    If this is a WM_INITDIALOG OnCreate is called.  Otherwise the non-static
    DialogProc function is called.

Arguments:

    See win32 DialogProc docs

Return value:
    
    TRUE - Message was handles

    FALSE - We did not handle the message

--*/
{
    COptionsDialog *rDialog;

    if (uMsg == WM_INITDIALOG) {
        rDialog = (COptionsDialog*)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hwndDlg,GWLP_USERDATA,(LPARAM)rDialog);
        return rDialog->OnCreateFilter(hwndDlg);
    }
    rDialog = (COptionsDialog*)GetWindowLongPtr(hwndDlg,GWLP_USERDATA);
    if (!rDialog) {
        return FALSE;
    }
    return rDialog->FilterDialogProc(hwndDlg,uMsg,wParam,lParam);
}

INT_PTR CALLBACK
COptionsDialog::_TraceDialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    If this is a WM_INITDIALOG OnCreate is called.  Otherwise the non-static
    DialogProc function is called.

Arguments:

    See win32 DialogProc docs

Return value:
    
    TRUE - Message was handles

    FALSE - We did not handle the message

--*/
{
    COptionsDialog *rDialog;

    if (uMsg == WM_INITDIALOG) {
        rDialog = (COptionsDialog*)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hwndDlg,GWLP_USERDATA,(LPARAM)rDialog);
        return rDialog->OnCreateTrace(hwndDlg);
    }
    rDialog = (COptionsDialog*)GetWindowLongPtr(hwndDlg,GWLP_USERDATA);
    if (!rDialog) {
        return FALSE;
    }
    return rDialog->TraceDialogProc(hwndDlg,uMsg,wParam,lParam);
}

INT_PTR
COptionsDialog::OnCreateFilter(
    IN HWND hWnd
    )

/*++

Routine Description:

    We populate all the filter dialog fields here.

Arguments:

    hWnd - Dialog window

Return value:
    
    FALSE - An error occured.  DestroyWindow was called. This should never
            happen unless someone hosed the template

    TRUE - success in creating everything

--*/
{
    TCHAR traceLevelString[MAX_STR_LEN];
    UINT traceLevelStringId;
    TRC_CONFIG trcConfig;

    m_hFilterDlg = hWnd;

    if (!m_rTracer->GetCurrentConfig(&trcConfig)) {
        DestroyWindow(hWnd);
        return FALSE;
    }

    // Now we set all the fields in the dialog.
    
    
    // Do the slider
    traceLevelStringId = IDS_TRACELEVELDETAILED + trcConfig.traceLevel;
    LoadStringSimple(traceLevelStringId,traceLevelString);
    SetDlgItemText(hWnd,IDC_FILTERLEVELDESC,traceLevelString);
    
    m_hFilterSliderControl = GetDlgItem(hWnd,IDC_FILTERLEVEL);
    if (!m_hFilterSliderControl) {
        DestroyWindow(hWnd);
        return FALSE;
    }

    SendDlgItemMessage(hWnd,IDC_FILTERLEVEL,TBM_SETRANGE,TRUE,MAKELONG(TRC_LEVEL_DBG,TRC_LEVEL_DIS));
    SendDlgItemMessage(hWnd,IDC_FILTERLEVEL,TBM_SETPOS,TRUE,trcConfig.traceLevel);
    
    // Set the first item of the combo box to the prefix string and then
    // select it.
    SendDlgItemMessage(m_hFilterDlg,IDC_FILTERPREFIX,CB_ADDSTRING,0,
            (LPARAM)trcConfig.prefixList);

    SendDlgItemMessage(m_hFilterDlg,IDC_FILTERPREFIX,CB_SETCURSEL,0,0);
    
    // Limit the amount you can enter to the size of the prefix buffer.
    SendDlgItemMessage(hWnd,IDC_FILTERPREFIX,EM_LIMITTEXT,TRC_PREFIX_LIST_SIZE-1,0); 
    
    // Now set the other items to be the prefix MRU.
    LoadPrefixMRU(trcConfig.prefixList);
    
    // The group control stuff
    
    if (trcConfig.components & TRC_GROUP_NETWORK) {
        SendDlgItemMessage(hWnd,IDC_GROUPNETWORK,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.components & TRC_GROUP_SECURITY) {
        SendDlgItemMessage(hWnd,IDC_GROUPSECURITY,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.components & TRC_GROUP_CORE) {
        SendDlgItemMessage(hWnd,IDC_GROUPCORE,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.components & TRC_GROUP_UI) {
        SendDlgItemMessage(hWnd,IDC_GROUPUI,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.components & TRC_GROUP_UTILITIES) {
        SendDlgItemMessage(hWnd,IDC_GROUPUTILITIES,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.components & TRC_GROUP_UNUSED1) {
        SendDlgItemMessage(hWnd,IDC_GROUPUNUSED1,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.components & TRC_GROUP_UNUSED2) {
        SendDlgItemMessage(hWnd,IDC_GROUPUNUSED2,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.components & TRC_GROUP_UNUSED3) {
        SendDlgItemMessage(hWnd,IDC_GROUPUNUSED3,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.components & TRC_GROUP_UNUSED4) {
        SendDlgItemMessage(hWnd,IDC_GROUPUNUSED4,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.components & TRC_GROUP_UNUSED5) {
        SendDlgItemMessage(hWnd,IDC_GROUPUNUSED5,BM_SETCHECK,BST_CHECKED,0);
    }

    return 0;
}

INT_PTR
COptionsDialog::OnCreateTrace(
    IN HWND hWnd
    )

/*++

Routine Description:

    We populate all the trace dialog fields here.

Arguments:

    hWnd - Dialog window

Return value:
    
    FALSE - An error occured.  DestroyWindow was called. This should never
            happen unless someone hosed the template

    TRUE - success in creating everything

--*/
{
    TRC_CONFIG trcConfig;
    // Since the numbers we are outputing are 32bit ints.  They can't go over 4 billion
    // meaning eleven characters is enough to print a UINT plus a null terminator.
    TCHAR numberFormat[11];

    // save the window handle
    m_hTraceDlg = hWnd;

    m_rTracer->GetCurrentConfig(&trcConfig);

    if (trcConfig.flags & TRC_OPT_FILE_OUTPUT) {
        SendDlgItemMessage(hWnd,IDC_OUTPUT_FILE,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.flags & TRC_OPT_DEBUGGER_OUTPUT) {
        SendDlgItemMessage(hWnd,IDC_OUTPUT_DEBUGGER,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.flags & TRC_OPT_BEEP_ON_ERROR) {
        SendDlgItemMessage(hWnd,IDC_ERROR_BEEP,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.flags & TRC_OPT_BREAK_ON_ERROR) {
        SendDlgItemMessage(hWnd,IDC_ERROR_BREAK,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.flags & TRC_OPT_TIME_STAMP) {
        SendDlgItemMessage(hWnd,IDC_OPTION_STAMP,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.flags & TRC_OPT_PROCESS_ID) {
        SendDlgItemMessage(hWnd,IDC_OPTION_PROCID,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.flags & TRC_OPT_THREAD_ID) {
        SendDlgItemMessage(hWnd,IDC_OPTION_THREAID,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.flags & TRC_OPT_BREAK_ON_ASSERT) {
        SendDlgItemMessage(hWnd,IDC_OPTION_BREAKASSERT,BM_SETCHECK,BST_CHECKED,0);
    }
  
    // DCUINT32s are defined as u longs hence use %lu for the wsprintf
    wsprintf(numberFormat,_T("%lu"),trcConfig.funcNameLength);

    SetDlgItemText(hWnd,IDC_FUNCTION_LENGTH,numberFormat);
    // Limit the amount you can enter to the size of a ulong
    SendDlgItemMessage(hWnd,IDC_FUNCTION_LENGTH,EM_LIMITTEXT,10,0); 

    wsprintf(numberFormat,_T("%lu"),trcConfig.dataTruncSize);

    SetDlgItemText(hWnd,IDC_TRUNCATION_LENGTH,numberFormat);
    SendDlgItemMessage(hWnd,IDC_TRUNCATION_LENGTH,EM_LIMITTEXT,10,0); 
    
    if (trcConfig.flags & TRC_OPT_PROFILE_TRACING) {
        SendDlgItemMessage(hWnd,IDC_OPTION_PROFILE,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.flags & TRC_OPT_FLUSH_ON_TRACE) {
        SendDlgItemMessage(hWnd,IDC_OPTION_FLUSH,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.flags & TRC_OPT_STACK_TRACING) {
        SendDlgItemMessage(hWnd,IDC_OPTION_STACK,BM_SETCHECK,BST_CHECKED,0);
    }

    return TRUE;
}

INT_PTR CALLBACK
COptionsDialog::FilterDialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    The FilterDialogProc forwards messages to the appropriate
    handlers.  See the handlers comments for what they do,

Arguments:

    See win32 docs for a DialogProc

Return value:
    
    TRUE - We handled the message

    FALSE - We didn't handle the message.

--*/
{
    WORD command;
    BOOL retValue;

    retValue = FALSE;

    switch (uMsg) {
    case WM_COMMAND:
        command = LOWORD(wParam);
        switch (command) {
        case IDC_SELECTALL:
            OnFilterSelectAll();
            retValue = TRUE;
            break;
        case IDC_CLEARALL:
            OnFilterClearAll();
            retValue = TRUE;
            break;
        }
        break;
    case WM_NOTIFY:
        if (((LPNMHDR)lParam)->code == PSN_APPLY) {
            OnFilterOk();
            retValue = TRUE;
        }
        break;
    case WM_HSCROLL:
        if ((HWND)lParam == m_hFilterSliderControl) {
            OnFilterSliderMove();
            retValue = TRUE;
        }
        break;
    }

    return retValue; 
}

INT_PTR CALLBACK
COptionsDialog::TraceDialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    The TraceDialogProc forwards messages to the appropriate
    handlers.  See the handlers comments for what they do,

Arguments:

    See win32 docs for a DialogProc

Return value:
    
    TRUE - We handled the message

    FALSE - We didn't handle the message.

--*/
{
    if (uMsg == WM_NOTIFY) {
        if (((LPNMHDR)lParam)->code == PSN_APPLY) {
            if (!OnTraceOk()) {
                // invalid fields from the user
                SetWindowLong(hwndDlg,DWLP_MSGRESULT,PSNRET_INVALID); 
            }
            return TRUE;
        } else if (((LPNMHDR)lParam)->code == PSN_KILLACTIVE) {
            if (!TraceVerifyParameters()) {
                SetWindowLong(hwndDlg,DWLP_MSGRESULT,TRUE); 
            }
            return TRUE;
        }
    }
    

    return FALSE;
    
}

VOID
COptionsDialog::OnFilterSelectAll(
    )

/*++

Routine Description:

    This is called when we need to make all the component boxes be checked.

Arguments:

    None

Return value:
    
    None

--*/
{
    // It might not be perfect coding style but harcoding each set is a lot easier
    // than some complicated system constructing an array with the ID of all the buttons.
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPNETWORK,BM_SETCHECK,BST_CHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPSECURITY,BM_SETCHECK,BST_CHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPCORE,BM_SETCHECK,BST_CHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUI,BM_SETCHECK,BST_CHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUTILITIES,BM_SETCHECK,BST_CHECKED,0);

    // If you ever make these groups do something just add the correct items
    // in. It looks weird to have the disabled boxes checked so we don't
    // do it.
/*  
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED1,BM_SETCHECK,BST_CHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED2,BM_SETCHECK,BST_CHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED3,BM_SETCHECK,BST_CHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED4,BM_SETCHECK,BST_CHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED5,BM_SETCHECK,BST_CHECKED,0);
*/
}

VOID
COptionsDialog::OnFilterSliderMove(
    )

/*++

Routine Description:

    This is called whenever the slider is moved.  We update the
    text to the right of the slider to show the new descriptive
    name for the tracing level.

Arguments:

    None

Return value:
    
    None

--*/
{
    UINT sliderPos;
    TCHAR traceLevelString[MAX_STR_LEN];

    sliderPos = (UINT)SendMessage(m_hFilterSliderControl,TBM_GETPOS,0,0);

    // Set the slider description
    LoadStringSimple(IDS_TRACELEVELDETAILED+sliderPos,traceLevelString);
    SetDlgItemText(m_hFilterDlg,IDC_FILTERLEVELDESC,traceLevelString);
}

VOID
COptionsDialog::OnFilterClearAll(
    )

/*++

Routine Description:

    This clears all the component check boxes.

Arguments:

    None

Return value:
    
    None

--*/
{
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPNETWORK,BM_SETCHECK,BST_UNCHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPSECURITY,BM_SETCHECK,BST_UNCHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPCORE,BM_SETCHECK,BST_UNCHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUI,BM_SETCHECK,BST_UNCHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUTILITIES,BM_SETCHECK,BST_UNCHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED1,BM_SETCHECK,BST_UNCHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED2,BM_SETCHECK,BST_UNCHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED3,BM_SETCHECK,BST_UNCHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED4,BM_SETCHECK,BST_UNCHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED5,BM_SETCHECK,BST_UNCHECKED,0);
}

VOID COptionsDialog::OnFilterOk(
    )

/*++

Routine Description:

    This reads in all the dialog parameters and then sets the trace
    filtering parameters accordingly.

Arguments:

    None

Return value:
    
    None

--*/
{
    TRC_CONFIG trcConfig;

    m_rTracer->GetCurrentConfig(&trcConfig);

    // set the trace level.
    trcConfig.traceLevel = (DCUINT32)SendDlgItemMessage(m_hFilterDlg,IDC_FILTERLEVEL,TBM_GETPOS,
        0,0);

    // Get the prefix string

    GetDlgItemText(m_hFilterDlg,IDC_FILTERPREFIX,trcConfig.prefixList,TRC_PREFIX_LIST_SIZE-1);

    // Save the prefix MRU

    StorePrefixMRU(trcConfig.prefixList);

    // Construct the components variable.

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPNETWORK,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_NETWORK;
    } else {
        trcConfig.components &= ~TRC_GROUP_NETWORK;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPSECURITY,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_SECURITY;
    } else {
        trcConfig.components &= ~TRC_GROUP_SECURITY;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPCORE,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_CORE;
    } else {
        trcConfig.components &= ~TRC_GROUP_CORE;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUI,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_UI;
    } else {
        trcConfig.components &= ~TRC_GROUP_UI;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUTILITIES,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_UTILITIES;
    } else {
        trcConfig.components &= ~TRC_GROUP_UTILITIES;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED1,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_UNUSED1;
    } else {
        trcConfig.components &= ~TRC_GROUP_UNUSED1;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED2,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_UNUSED2;
    } else {
        trcConfig.components &= ~TRC_GROUP_UNUSED2;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED3,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_UNUSED3;
    } else {
        trcConfig.components &= ~TRC_GROUP_UNUSED3;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED4,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_UNUSED4;
    } else {
        trcConfig.components &= ~TRC_GROUP_UNUSED4;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED5,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_UNUSED5;
    } else {
        trcConfig.components &= ~TRC_GROUP_UNUSED5;
    }

    m_rTracer->SetCurrentConfig(&trcConfig);
}


BOOL COptionsDialog::OnTraceOk(
    )

/*++

Routine Description:

    This reads in all the dialog parameters and then sets the trace
    parameters accordingly.

Arguments:

    None

Return value:
    
    TRUE - Success in setting the conf.

    FALSE - The user entered invalid data so the dialog should not be closed.

--*/
{
    TRC_CONFIG trcConfig;
    // again enough to hold a string representing a ulong.
    TCHAR numberFormat[11];

    m_rTracer->GetCurrentConfig(&trcConfig);

    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_OUTPUT_FILE,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_FILE_OUTPUT;
    } else {
        trcConfig.flags &= ~TRC_OPT_FILE_OUTPUT;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_OUTPUT_DEBUGGER,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_DEBUGGER_OUTPUT;
    } else {
        trcConfig.flags &= ~TRC_OPT_DEBUGGER_OUTPUT;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_ERROR_BEEP,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_BEEP_ON_ERROR;
    } else {
        trcConfig.flags &= ~TRC_OPT_BEEP_ON_ERROR;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_ERROR_BREAK,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_BREAK_ON_ERROR;
    } else {
        trcConfig.flags &= ~TRC_OPT_BREAK_ON_ERROR;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_OPTION_STAMP,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_TIME_STAMP;
    } else {
        trcConfig.flags &= ~TRC_OPT_TIME_STAMP;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_OPTION_PROCID,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_PROCESS_ID;
    } else {
        trcConfig.flags &= ~TRC_OPT_PROCESS_ID;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_OPTION_THREAID,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_THREAD_ID;
    } else {
        trcConfig.flags &= ~TRC_OPT_THREAD_ID;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_OPTION_BREAKASSERT,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_BREAK_ON_ASSERT;
    } else {
        trcConfig.flags &= ~TRC_OPT_BREAK_ON_ASSERT;
    }    

    GetDlgItemText(m_hTraceDlg,IDC_FUNCTION_LENGTH,numberFormat,10);

    if (!VerifyNumberFormat(numberFormat)) {
        return FALSE;
    }
    trcConfig.funcNameLength = _ttol(numberFormat);

    GetDlgItemText(m_hTraceDlg,IDC_TRUNCATION_LENGTH,numberFormat,10);
    if (!VerifyNumberFormat(numberFormat)) {
        return FALSE;
    }

    trcConfig.dataTruncSize = _ttol(numberFormat);

    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_OPTION_PROFILE,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_PROFILE_TRACING;
    } else {
        trcConfig.flags &= ~TRC_OPT_PROFILE_TRACING;
    }
    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_OPTION_FLUSH,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_FLUSH_ON_TRACE;
    } else {
        trcConfig.flags &= ~TRC_OPT_FLUSH_ON_TRACE;
    }
    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_OPTION_STACK,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_STACK_TRACING;
    } else {
        trcConfig.flags &= ~TRC_OPT_STACK_TRACING;
    }

    m_rTracer->SetCurrentConfig(&trcConfig);

    return TRUE;
}

BOOL
COptionsDialog::VerifyNumberFormat(
    IN LPCTSTR numberFormat
    )

/*++

Routine Description:

    This checks to make sure the passed in string is in the form
    /^\d*$/.  If not a dialog box is popped up telling the user
    that the string must be a valid postive number.

Arguments:

    numberFormat - String to check if it is a number string

Return value:
    
    TRUE - The string only containts the characters 0-9

    FALSE - The string has illegal characters.

--*/
{
    WCHAR current;
    TCHAR dlgTitle[MAX_STR_LEN];
    TCHAR dlgMessage[MAX_STR_LEN];
    
    while (current = *(numberFormat++)) {
        if (!_istdigit(current)) {
            LoadStringSimple(IDS_SETTINGSNOTNUMBER,dlgMessage);
            LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);
            MessageBox(m_hTraceDlg,dlgMessage,dlgTitle,MB_OK|MB_ICONWARNING);
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
COptionsDialog::TraceVerifyParameters(
    )

/*++

Routine Description:

    Makes sure the trace parameters are valid

Arguments:

    None

Return value:
    
    TRUE - Trace parameters are valid.

    FALSE - Trace parameters are invalid.

--*/
{
    TCHAR numberFormat[11];
    
    GetDlgItemText(m_hTraceDlg,IDC_FUNCTION_LENGTH,numberFormat,10);

    if (!VerifyNumberFormat(numberFormat)) {
        return FALSE;
    }
    
    GetDlgItemText(m_hTraceDlg,IDC_TRUNCATION_LENGTH,numberFormat,10);
    if (!VerifyNumberFormat(numberFormat)) {
        return FALSE;
    }

    return TRUE;
}

VOID
COptionsDialog::LoadPrefixMRU(
    IN LPCTSTR currentPrefix
    )

/*++

Routine Description:

    This loads the prefix MRU list into the prefix
    combo box.

Arguments:

    currentPrefix - The current selected prefix

Return value:
    
    None

--*/
{
    TCHAR prefix[TRC_PREFIX_LIST_SIZE];
    TCHAR valueName[MRU_STR_BUFFER_SIZE];
    HKEY hKey;
    INT i;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwResult;

    dwResult = RegOpenKeyEx(HKEY_CURRENT_USER,ZIPPY_REG_KEY,0,KEY_QUERY_VALUE,
        &hKey);
    if (dwResult) {
        // error opening reg key return
        return;
    }

    for (i=0;i<MAX_MRU;i++) {
        wsprintf(valueName,_T("%s%d"),MRU_STR_PREFIX,i);
        dwSize = sizeof(TCHAR)*TRC_PREFIX_LIST_SIZE;
        dwResult = RegQueryValueEx(hKey,valueName,NULL,&dwType,(LPBYTE)prefix,
            &dwSize);
        if (dwResult) {
            // if there is an error loading a value then quit
            break;
        } else if (0 == _tcsicmp(prefix,currentPrefix)) {
            // if the MRU item is the same as the current don't display it
            continue;
        }
        SendDlgItemMessage(m_hFilterDlg,IDC_FILTERPREFIX,CB_ADDSTRING,0,
            (LPARAM)prefix);
    }

    RegCloseKey(hKey);

}

VOID
COptionsDialog::StorePrefixMRU(
    IN LPCTSTR currentPrefix
    )

/*++

Routine Description:

    This updates the registry MRU list to put
    the new prefix at the head of the list.

Arguments:

    currentPrefix - The current selected prefix

Return value:
    
    None

--*/
{
    HKEY hKey;
    TCHAR savedMruPrefix[TRC_PREFIX_LIST_SIZE];
    TCHAR newMruPrefix[TRC_PREFIX_LIST_SIZE];
    TCHAR currentLoadName[MRU_STR_BUFFER_SIZE];
    TCHAR currentSaveName[MRU_STR_BUFFER_SIZE];
    INT loadIndex;
    INT saveIndex;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwResult;


    dwResult = RegOpenKeyEx(HKEY_CURRENT_USER,ZIPPY_REG_KEY,0,
        KEY_QUERY_VALUE|KEY_SET_VALUE,&hKey);
    if (dwResult) {
        // error opening reg key return
        return;
    }

    // The new currentPrefix is the first item in the MRU list
    _tcscpy(newMruPrefix,currentPrefix);

    for (loadIndex=0,saveIndex=0;loadIndex<MAX_MRU;loadIndex++) {
        wsprintf(currentLoadName,_T("%s%d"),MRU_STR_PREFIX,loadIndex);
        wsprintf(currentSaveName,_T("%s%d"),MRU_STR_PREFIX,saveIndex);
        
        dwSize = sizeof(TCHAR)*TRC_PREFIX_LIST_SIZE;
        dwResult = RegQueryValueEx(hKey,currentLoadName,NULL,&dwType,
            (LPBYTE)savedMruPrefix,&dwSize);
        if (dwResult) {
            // no more valid keys.  Write out the current and exit.
            RegSetValueEx(hKey,currentLoadName,0,REG_SZ,(LPBYTE)newMruPrefix,sizeof(TCHAR) * 
            (_tcslen(newMruPrefix)+1));
            break;
        } else if (0 == _tcsicmp(savedMruPrefix,currentPrefix)) {
            // if this MRU is the same as the currentPrefix we already have saved it.
            // so we will advance i and leave the currentMru the same
            
            if (loadIndex == MAX_MRU-1) {
                // If this is the last MRU to load then we need to save
                RegSetValueEx(hKey,currentSaveName,0,REG_SZ,(LPBYTE)newMruPrefix,sizeof(TCHAR) * 
                    (_tcslen(newMruPrefix)+1));
            }
            continue;
        } else {
            // we are going to save in this position so advance the index
            saveIndex++;
        }
        RegSetValueEx(hKey,currentSaveName,0,REG_SZ,(LPBYTE)newMruPrefix,sizeof(TCHAR) * 
            (_tcslen(newMruPrefix)+1));

        _tcscpy(newMruPrefix,savedMruPrefix);
    }

    RegCloseKey(hKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\ezippy\zippywindow.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Zippy Main Window

Abstract:

    This class implements the main window for zippy as well as controlling
    its child windows.

Author:

    Marc Reyhner 8/28/2000

--*/

#ifndef __ZIPPYWINDOW_H__
#define __ZIPPYWINDOW_H__

#include "eZippy.h"

//  The number of colors we remember
#define COLOR_HISTORY_COUNT     100

// Struct representing a remembered thread color
typedef struct _THREADCOLOR {
    DWORD processId;
    DWORD threadId;
    COLORREF color;
} THREADCOLOR, FAR *LPTHREADCOLOR;

typedef struct _SAVEDOUTPUT {
    DWORD procID;
    LPTSTR text;
    UINT len;
    struct _SAVEDOUTPUT *next;
} SAVEDOUTPUT, FAR *LPSAVEDOUTPUT;

class CTraceManager;

class CZippyWindow  
{
public:
	CZippyWindow();
	virtual ~CZippyWindow();
    DWORD Create(CTraceManager *rTracer);
    VOID AppendTextToWindow(DWORD processID, LPCTSTR text,UINT len);
    VOID LoadConfFile(LPTSTR confFile);
    BOOL IsDialogMessage(LPMSG lpMsg);
    INT WINAPI TranslateAccelerator(HACCEL hAccTable,LPMSG lpMsg);

private:

	static BOOL gm_Inited;
	static ATOM gm_Atom;
    static UINT gm_FindMessageStringMsg;
    
    HWND m_hWnd;
    HWND m_hControlWnd;
    HWND m_hStatusWnd;
    HWND m_hWndFindReplace;
    BOOL m_bIsTracing;
    BOOL m_bIsStoringTraceData;
    BOOL m_bIsFindNotReplace;
    UINT m_nextThreadIndex;
    UINT m_nextThreadColor;
    DWORD m_lastProcessId;
    DWORD m_LastLogEndedInNewLine;
    HANDLE m_hAppendMutex;
    TCHAR m_SaveFile[MAX_STR_LEN];
    TCHAR m_SaveConfFile[MAX_STR_LEN];
    TCHAR m_LoadConfFile[MAX_STR_LEN];
	FINDREPLACE m_FindReplace;
    THREADCOLOR m_threadHistory[COLOR_HISTORY_COUNT];
    LPSAVEDOUTPUT m_lpSavedOutputStart;
    LPSAVEDOUTPUT m_lpSavedOutputTail;
    CTraceManager *m_rTracer;

    static DWORD _InitClassStaticMembers();
    static LRESULT CALLBACK _WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, 
        LPARAM lParam);
    
    LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, 
        LPARAM lParam);
    
    // Window message handlers
    LRESULT OnCreate(HWND hWnd);
    VOID OnMenuSelect(WPARAM wParam, LPARAM lParam);
	VOID OnSize(INT width, INT height);
	VOID OnSetFocus();
    VOID OnInitMenuPopup(WPARAM wParam, LPARAM lParam);
	VOID OnFindMessageString(LPARAM lParam);
    VOID OnClose();
    VOID OnDestroy();
    
    //
    //  WM_COMMAND handler and all the helper functions for the various
    //  command.
    //
    VOID OnCommand(WPARAM wParam, LPARAM lParam);
	VOID OnSave();
    VOID OnSaveAs();
    VOID OnLoadConfiguration();
	VOID OnSaveConfiguration();
	VOID OnSaveConfigurationAs();
	VOID OnExit();
	VOID OnUndo();
	VOID OnRedo();
	VOID OnCut();
	VOID OnCopy();
	VOID OnPaste();
	VOID OnSelectAll();
	VOID OnFind();
	VOID OnFindNext();
	VOID OnReplace();
	VOID OnChangeStatusBar();
	VOID OnStartTracing();
	VOID OnStopTracing();
    VOID OnRecordTracing();
	VOID OnClearScreen();
	VOID OnResetTraceFiles();
	VOID OnPreferences();
    VOID OnAbout();
	
	// Internal helper functions
    VOID DoLoadConfInternal();
	VOID DoSaveConfInternal();
    VOID DoReplaceAll(LPFINDREPLACE lpFindReplace);
	BOOL DoReplace(LPFINDREPLACE lpFindReplace);
	BOOL DoFindNext(LPFINDREPLACE lpFindReplace);
	VOID DoSaveInternal();
    LPTHREADCOLOR FindColorForThread(DWORD processId, DWORD threadId);
	DWORD ConvertHexStrToDword(LPCTSTR str, UINT strLen);
	BOOL ComputeNewColor(DWORD processID, LPCTSTR text, UINT len, CHARFORMAT *lpFormat);
	
    VOID GetSavedWindowPos(LPRECT savedPos);
    VOID SaveWindowPos(LPRECT newPos);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\trace\ezippy\zippywindow.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Zippy Main Window

Abstract:

    This class implements the main window for zippy as well as controlling
    its child windows.

Author:

    Marc Reyhner 8/28/2000

--*/

#include "stdafx.h"
#include "ZippyWindow.h"
#include "resource.h"
#include "eZippy.h"
#include "richedit.h"
#include "ModalDialog.h"
#include "TraceManager.h"
#include "OptionsDialog.h"


BOOL CZippyWindow::gm_Inited = FALSE;
ATOM CZippyWindow::gm_Atom = NULL;
UINT CZippyWindow::gm_FindMessageStringMsg = 0;

static DWORD CALLBACK SaveCallback(DWORD_PTR dwCookie,LPBYTE pbBuff,LONG cb,LONG *pcb);


#define TRC_PROC_FMT                    _T("%04.4lx")
#define SAVE_FILE_TYPE                  _T("Text Files (*.txt)\0*.txt\0")
#define SAVE_FILE_EXTENSION             _T("txt")
#define SAVE_CONF_FILE_TYPE             _T("Trace Configuration Files (*.tcf)\0*.tcf\0")
#define SAVE_CONF_FILE_EXTENSION        _T("tcf")
#define NUM_COLORS                      15
#define APPENDMUTEXNAME                 _T("Local\\MicrosoftTerminalServerTraceViewerAppendMutex")
#define ZIPPY_WINDOW_POS_VALUE          _T("WindowPosition")
#define WINDOW_DEF_TOP                  50
#define WINDOW_DEF_BOTTOM               530
#define WINDOW_DEF_RIGHT                690
#define WINDOW_DEF_LEFT                 50

// We use an 80 character buffer for find
// and replace operations.
#define FIND_REPLACE_BUFFER_SIZE        80

// This list of colors we cycle through.  Note if you change this
// list you need to update NUM_COLORS to the new count.
static COLORREF colors[NUM_COLORS] = {
    RGB(153,51,0),  /* Brown */
    RGB(0,51,102),  /* Dark Teal */
    RGB(51,51,153), /* Indigo */
    RGB(128,0,0),   /* Dark Red */
    RGB(255,102,0), /* Orange */
    RGB(0,128,0),   /* Green */
    RGB(0,0,255),   /* Blue */
    RGB(255,0,0),   /* Red */
    RGB(51,204,204),/* Acqua */
    RGB(128,0,128), /* Violet */
    RGB(255,0,255), /* Pink */
    RGB(255,255,0), /* Yellow */
    RGB(0,255,0),   /* Bright Green */
    RGB(0,255,255), /* Turquoise */
    RGB(204,153,255)/* Lavender */
    };

//
//  *** Public Class Members ***
//

CZippyWindow::CZippyWindow(
    )

/*++

Routine Description:

    The constructor simply initializes the class variables.

Arguments:

    None

Return value:
    
    None

--*/
{
    m_bIsTracing = TRUE;
    m_bIsStoringTraceData = FALSE;
    ZeroMemory(m_threadHistory,sizeof(m_threadHistory));
    m_nextThreadIndex = 0;
    m_nextThreadColor = 0;
    m_lastProcessId = 0;
    m_LastLogEndedInNewLine = TRUE;
    m_hWnd = NULL;
    m_hStatusWnd = NULL;
    m_hControlWnd = NULL;
    m_hWndFindReplace = NULL;
    m_lpSavedOutputStart = NULL;
    m_lpSavedOutputTail = NULL;
    ZeroMemory(&m_FindReplace,sizeof(m_FindReplace));
    ZeroMemory(m_SaveFile,sizeof(m_SaveFile));
    ZeroMemory(m_SaveConfFile,sizeof(m_SaveConfFile));
    ZeroMemory(m_LoadConfFile,sizeof(m_LoadConfFile));
}

CZippyWindow::~CZippyWindow(
    )

/*++

Routine Description:

    Cleans up any dynamicly allocated memory,

Arguments:

    None

Return value:
    
    None

--*/
{
    if (m_FindReplace.lpstrFindWhat) {
        HeapFree(GetProcessHeap(),0,m_FindReplace.lpstrFindWhat);
    }
    if (m_FindReplace.lpstrReplaceWith) {
        HeapFree(GetProcessHeap(),0,m_FindReplace.lpstrReplaceWith);
    }
}



DWORD CZippyWindow::Create(
    IN CTraceManager *rTracer
    )

/*++

Routine Description:

    Actually creates the zippy window.

Arguments:

    rTracer - A pointer to the trace manager

Return value:
    
    0 - Success

    Non zero - An error occurred creating the window

--*/
{
	DWORD dwResult;
    DWORD dwWindowStyleEx;
    DWORD dwWindowStyle;
    TCHAR wndTitle[MAX_STR_LEN];
    RECT wndRect;

    m_rTracer = rTracer;
	if (!gm_Inited) {
		dwResult = _InitClassStaticMembers();
		if (dwResult != ERROR_SUCCESS) {
			return dwResult;
		}
	}
    
    m_hAppendMutex = CreateMutex(NULL,FALSE,APPENDMUTEXNAME);

    m_FindReplace.lStructSize = sizeof(m_FindReplace);

    m_FindReplace.lpstrFindWhat = (LPTSTR)HeapAlloc(GetProcessHeap(),
        HEAP_ZERO_MEMORY,FIND_REPLACE_BUFFER_SIZE*sizeof(TCHAR));
    if (!m_FindReplace.lpstrFindWhat) {
        return GetLastError();
    }

    m_FindReplace.lpstrReplaceWith = (LPTSTR)HeapAlloc(GetProcessHeap(),
        HEAP_ZERO_MEMORY,FIND_REPLACE_BUFFER_SIZE*sizeof(TCHAR));
    if (!m_FindReplace.lpstrReplaceWith) {
        return GetLastError();
    }

    LoadStringSimple(IDS_ZIPPYWINDOWTITLE,wndTitle);
    
    GetSavedWindowPos(&wndRect);

    dwWindowStyleEx = WS_EX_WINDOWEDGE;
    dwWindowStyle = WS_OVERLAPPEDWINDOW|WS_CLIPSIBLINGS|WS_VISIBLE;
    m_hWnd = CreateWindowEx(dwWindowStyleEx, (LPTSTR)gm_Atom, wndTitle,
        dwWindowStyle, wndRect.left, wndRect.top, wndRect.right,
        wndRect.bottom,NULL,NULL,g_hInstance,this);
    if (!m_hWnd) {
        return GetLastError();
    }

	return ERROR_SUCCESS;
}

VOID
CZippyWindow::AppendTextToWindow(
    IN DWORD processID,
    IN LPCTSTR text,
    IN UINT len
    )

/*++

Routine Description:

    Appends new trace data to the end of the rich edit contrl

Arguments:

    processID - Process ID of the process sending the debug string

    text - The data sent via OutputDebugString

    len - Length of the data

Return value:
    
    None

--*/
{
    UINT controlTextLength;
    CHARRANGE newSel;
    BOOL computeColor;
    BOOL setNewColor;
    CHARFORMAT newFormat;
    LPSAVEDOUTPUT lpSave;

    if (!m_bIsTracing) {
        return;
    }

    WaitForSingleObject(m_hAppendMutex,INFINITE);

    if (m_bIsStoringTraceData) {
        // This is kinda sketchy but what we do is to allocate room for the string
        // at the end of the structure. There shouldn't be any alignment problems
        // since we need to align on a short and the structure has no items
        // to get that off.
        lpSave = (LPSAVEDOUTPUT)HeapAlloc(GetProcessHeap(),0,sizeof(SAVEDOUTPUT) + 
            (sizeof(TCHAR) * (len+1)));
        if (!lpSave) {
            // eom error?
            goto CLEANUP_AND_EXIT;
        }
        lpSave->procID = processID;
        lpSave->text = (LPTSTR)((BYTE)lpSave + sizeof(SAVEDOUTPUT));
        _tcscpy(lpSave->text,text);
        lpSave->len = len;
        lpSave->next = NULL;

        if (!m_lpSavedOutputTail) {
            m_lpSavedOutputStart = lpSave;
        } else {
            m_lpSavedOutputTail->next = lpSave;
        }
        m_lpSavedOutputTail = lpSave;
        goto CLEANUP_AND_EXIT;
    }

    if (m_lastProcessId != processID ||
        m_LastLogEndedInNewLine) {
        computeColor = TRUE;
    } else {
        computeColor = FALSE;
    }

    setNewColor = ComputeNewColor(processID,text,len,&newFormat);

    m_LastLogEndedInNewLine = (text[len-1] == '\n') ? TRUE : FALSE;
    m_lastProcessId = processID;

    controlTextLength = (UINT)SendMessage(m_hControlWnd,WM_GETTEXTLENGTH,0,0);
    newSel.cpMin = controlTextLength;
    newSel.cpMax = controlTextLength+1;

    
    // set the new text
    SendMessage(m_hControlWnd,EM_EXSETSEL,0,(LPARAM)&newSel);
    if (setNewColor) {
        SendMessage(m_hControlWnd,EM_SETCHARFORMAT,SCF_SELECTION,(LPARAM)&newFormat);
    }
    SendMessage(m_hControlWnd,EM_REPLACESEL,0,(LPARAM)text);
    
CLEANUP_AND_EXIT:

    ReleaseMutex(m_hAppendMutex);
}

VOID
CZippyWindow::LoadConfFile(
    IN LPTSTR confFile
    )

/*++

Routine Description:

    This sets the tracing configuration using the given file

Arguments:

    confFile - File containing the tracing configuration

Return value:
    
    None

--*/
{
    _tcscpy(m_LoadConfFile,confFile);
    DoLoadConfInternal();
}

BOOL
CZippyWindow::IsDialogMessage(
    IN LPMSG lpMsg
    )

/*++

Routine Description:

    This calls IsDialogMessage on any non modal dialogs that this window
    is hosting to see if the message is for them

Arguments:

    lpMsg - Message to check if it is a dialog message

Return value:
    
    TRUE - The message did belong to a dialog

    FALSE - The message did not belong to a dialog

--*/
{
    if (IsWindow(m_hWndFindReplace)) {
        // The :: below is necessary to make it use the Win32 function
        // not our method
        return ::IsDialogMessage(m_hWndFindReplace,lpMsg);
    }
    return FALSE;
}

INT WINAPI
CZippyWindow::TranslateAccelerator(
    IN HACCEL hAccTable,
    IN LPMSG lpMsg
    )

/*++

Routine Description:

    This calls the win32 TranslateAccelerator to determine
    if the given message is an accelerator for this window

Arguments:

    hAccTable - Accelerator table to use

    lpMsg - Message to check

Return value:
    
    See Win32 TranslateAccelerator documentation

--*/
{
    // :: Necessary to get the win32 call.
    return ::TranslateAccelerator(m_hWnd,hAccTable,lpMsg);
}


//
//  *** Private Class Members ***
//

// static members


DWORD
CZippyWindow::_InitClassStaticMembers(
	)

/*++

Routine Description:

    Creates the window class for zippy and registers
    for the FINDMSGSTRING windows message

Arguments:

    None

Return value:
    
    0 - Success

    Non zero - Win32 error code

--*/
{
	WNDCLASS wndClass;
    HMODULE hLibrary;

    // We want to load RichEdit for the lifetime of our app.
    hLibrary = LoadLibrary(_T("Riched20.dll"));
    if (!hLibrary) {
        return GetLastError();
    }

    ZeroMemory(&wndClass,sizeof(wndClass));

	wndClass.style = CS_PARENTDC;
	wndClass.lpfnWndProc = _WindowProc;
    wndClass.hInstance = g_hInstance;
    wndClass.hIcon = (HICON)LoadImage(g_hInstance,MAKEINTRESOURCE(IDI_MAINFRAME),
        IMAGE_ICON,0,0,LR_SHARED);
    wndClass.hbrBackground = (HBRUSH)COLOR_WINDOWFRAME;
    wndClass.lpszMenuName = MAKEINTRESOURCE(IDR_MAINMENU);
	wndClass.lpszClassName = _T("ZippyWindowClass");

    gm_Atom = RegisterClass(&wndClass);
    if (!gm_Atom) {
        return GetLastError();
    }

    gm_FindMessageStringMsg = RegisterWindowMessage(FINDMSGSTRING);
    if (!gm_FindMessageStringMsg) {
        return GetLastError();
    }

    gm_Inited = TRUE;

    return ERROR_SUCCESS;
}

LRESULT CALLBACK
CZippyWindow::_WindowProc(
    IN HWND hWnd,
    IN UINT uMsg,
    IN WPARAM wParam, 
    IN LPARAM lParam)

/*++

Routine Description:

    Static version of the window proc.  On WM_CREATE it calls OnCreate,
    otherwise it calls the non-static window proc

Arguments:

    See Win32 Window Proc docs

Return value:
    
    Message specific.  See individual handlers for detail.

--*/
{
    CZippyWindow *theClass;

    if (uMsg == WM_CREATE) {
        SetLastError(0);
        theClass = (CZippyWindow *)((LPCREATESTRUCT)lParam)->lpCreateParams;
        SetWindowLongPtr(hWnd,GWLP_USERDATA,(LONG_PTR)theClass);
        if (GetLastError()) {
            return -1;
        }
        return theClass->OnCreate(hWnd);
    }
    theClass = (CZippyWindow*)GetWindowLongPtr(hWnd,GWLP_USERDATA);
    if (theClass) {
        return theClass->WindowProc(hWnd,uMsg,wParam,lParam);
    } else {
        return DefWindowProc(hWnd,uMsg,wParam,lParam);
    }
}

LRESULT CALLBACK
CZippyWindow::WindowProc(
    IN HWND hWnd,
    IN UINT uMsg,
    IN WPARAM wParam, 
    IN LPARAM lParam)

/*++

Routine Description:

    Non-static window proc.  Either calls the default window proc or
    refers to the individual message handlers

Arguments:

    See Win32 Window Proc docs

Return value:
    
    Message specific.  See individual handlers for detail.

--*/
{
    
    LRESULT retCode = 0;

    switch (uMsg) {
    case WM_COMMAND:
        OnCommand(wParam,lParam);
        break;
    case WM_SETFOCUS:
        OnSetFocus();
        break;
    case WM_SIZE:
        OnSize(LOWORD(lParam),HIWORD(lParam));
        break;
    case WM_INITMENUPOPUP:
        OnInitMenuPopup(wParam,lParam);
        break;
    case WM_MENUSELECT:
        OnMenuSelect(wParam,lParam);
        break;
    case WM_CLOSE:
        OnClose();
        break;
    case WM_DESTROY:
        OnDestroy();
        break;
    default:
        if (uMsg == gm_FindMessageStringMsg) {
            OnFindMessageString(lParam);
        } else {
            retCode = DefWindowProc(hWnd,uMsg,wParam,lParam);
        }
        break;
    }

    return retCode;
}


LRESULT
CZippyWindow::OnCreate(
    IN HWND hWnd
    )

/*++

Routine Description:

    Creates the child windows and sets their initial parameters

Arguments:

    hWnd - Pointer to the new main window

Return value:
    
    0 - Window was created

    -1 - Error occurred

--*/
{
    DWORD dwStyle;
    CHARFORMAT charFormat;
    TCHAR readyString[MAX_STR_LEN];

    dwStyle = WS_CHILD|WS_VISIBLE|WS_VSCROLL|WS_HSCROLL|ES_SUNKEN|
        ES_MULTILINE|ES_LEFT|ES_AUTOHSCROLL|ES_AUTOVSCROLL|ES_NOHIDESEL;
    m_hControlWnd = CreateWindow(RICHEDIT_CLASS,_T(""),
        dwStyle,0,0,0,0,hWnd,NULL,g_hInstance,NULL);
    if (!m_hControlWnd) {
        return -1;
    }
    
    dwStyle = SBARS_SIZEGRIP|WS_CHILD|WS_VISIBLE;

    m_hStatusWnd = CreateWindow(STATUSCLASSNAME,NULL,dwStyle,0,0,0,0,hWnd,NULL,
        g_hInstance,NULL);
    if (!m_hStatusWnd) {
        return -1;
    }

    LoadStringSimple(IDS_STATUSBARREADY,readyString);
    SendMessage(m_hStatusWnd,SB_SETTEXT,0|SBT_NOBORDERS,(LPARAM)readyString);


    charFormat.cbSize = sizeof(charFormat);
    charFormat.dwMask = CFM_FACE|CFM_SIZE;
    charFormat.yHeight = ZIPPY_FONT_SIZE*20;
    _tcscpy(charFormat.szFaceName,ZIPPY_FONT);

    // 4 billion characters should be a large enough limit...
    SendMessage(m_hControlWnd,EM_EXLIMITTEXT,0,0xFFFFFFFF);

    SendMessage(m_hControlWnd,EM_SETCHARFORMAT,SCF_ALL,(LPARAM)&charFormat);

    SendMessage(m_hControlWnd,EM_SETMODIFY,FALSE,0);

    SendMessage(m_hControlWnd,EM_EMPTYUNDOBUFFER,0,0);


    return 0;
}

VOID
CZippyWindow::OnMenuSelect(
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Sets the help string in the status bar for the selected menu.

Arguments:

    wParam - menu itemid (LOWORD) and flags (HIWORD)

    lParam - menu handle

Return value:
    
    None

--*/
{
    UINT item;
    UINT flags;
    HMENU hMenu;
    TCHAR statusMessage[MAX_STR_LEN];

    item = LOWORD(wParam);
    flags = HIWORD(wParam);
    hMenu = (HMENU)lParam;

    if (!item && flags == 0xFFFF) {
        // the menu was closed.  Go back to the ready string.
        LoadStringSimple(IDS_STATUSBARREADY,statusMessage);
        SendMessage(m_hStatusWnd,SB_SETTEXT,0|SBT_NOBORDERS,(LPARAM)statusMessage);
        return;
    }
    if (flags & MF_POPUP) {
        statusMessage[0] = 0;
    } else if (!LoadStringSimple(item,statusMessage)) {
        // if we can't find the help string use the empty string.
        statusMessage[0] = 0;
    }
    SendMessage(m_hStatusWnd,SB_SETTEXT,0|SBT_NOBORDERS,(LPARAM)statusMessage);

}

VOID
CZippyWindow::OnSize(
    IN INT width,
    IN INT height
    )

/*++

Routine Description:

    Resizes client windows to reflect the new size of the main window

Arguments:

    width - New width of the client area

    height - New height of the client area

Return value:
    
    None

--*/
{
    RECT statusBarArea;
    UINT statusBarHeight;
    RECT wndRect;

    if (!(width==0&&height==0)) {
        if (GetWindowRect(m_hWnd,&wndRect)) {
            SaveWindowPos(&wndRect);
        }
    }
    if (IsWindowVisible(m_hStatusWnd)) {
        GetWindowRect(m_hStatusWnd,&statusBarArea);
        statusBarHeight = statusBarArea.bottom - statusBarArea.top;

        SetWindowPos(m_hControlWnd,NULL,0,0,width,height-statusBarHeight,SWP_NOZORDER);
        
        // the status bar autosizes.  We just need to tell it that it should
        SetWindowPos(m_hStatusWnd,NULL,0,0,0,0,SWP_NOZORDER);
    } else {
        SetWindowPos(m_hControlWnd,NULL,0,0,width,height,SWP_NOZORDER);
    }
}

VOID
CZippyWindow::OnSetFocus(
    )

/*++

Routine Description:

    When we get focus we kick it down to the rich edit control

Arguments:

    None

Return value:
    
    None

--*/
{
    SetFocus(m_hControlWnd);
}

VOID
CZippyWindow::OnInitMenuPopup(
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    When the user opens the menus we need to specify
    which are disabled and which are checked. Note that
    the menu id's are hard coded.  I've commented which
    corespond to which for the switch statement

Arguments:

    wParam - The menu handle

    lParam - (loword) the menu item id

Return value:
    
    None

--*/
{
    HMENU hMenu;
    WORD item;
    
    item = LOWORD(lParam);
    hMenu = (HMENU)wParam;

    switch (item) {
        case 1: // Edit Menu
            UINT canUndo;
            UINT canRedo;
            UINT cutCopyEnabled;
            UINT pasteEnabled;
            UINT selectAllEnabled;
            UINT findEnabled;
            UINT findNextEnabled;
            UINT replaceEnabled;
            LRESULT textLength;
            CHARRANGE selRegion;

            if (SendMessage(m_hControlWnd,EM_CANUNDO,0,0)) {
                canUndo = MF_ENABLED;
            } else {
                canUndo = MF_GRAYED;
            }
            if (SendMessage(m_hControlWnd,EM_CANREDO,0,0)) {
                canRedo = MF_ENABLED;
            } else {
                canRedo = MF_GRAYED;
            }

            textLength = SendMessage(m_hControlWnd,WM_GETTEXTLENGTH,0,0);
            if (textLength == 0) {
                selectAllEnabled = MF_GRAYED;
                findEnabled = MF_GRAYED;
                findNextEnabled = MF_GRAYED;
                replaceEnabled = MF_GRAYED;
            } else {
                selectAllEnabled = MF_ENABLED;
                findEnabled = MF_ENABLED;
                replaceEnabled = MF_ENABLED;
                if (m_FindReplace.lpstrFindWhat[0] != 0) {
                    findNextEnabled = MF_ENABLED;
                } else {
                    findNextEnabled = MF_GRAYED;
                }
            }
                            
            SendMessage(m_hControlWnd,EM_EXGETSEL,0,(LPARAM)&selRegion);
            if (selRegion.cpMax == selRegion.cpMin) {
                cutCopyEnabled = MF_GRAYED;
            } else {
                cutCopyEnabled = MF_ENABLED;
                // override select all since they selected the next character
                // to be typed
                selectAllEnabled = MF_ENABLED;
            }

            if (SendMessage(m_hControlWnd,EM_CANPASTE,0,0)) {
                pasteEnabled = MF_ENABLED;
            } else {
                pasteEnabled = MF_GRAYED;
            }
            
            EnableMenuItem(hMenu,ID_EDIT_UNDO,MF_BYCOMMAND|canUndo);
            EnableMenuItem(hMenu,ID_EDIT_REDO,MF_BYCOMMAND|canRedo);
            EnableMenuItem(hMenu,ID_EDIT_CUT,MF_BYCOMMAND|cutCopyEnabled);
            EnableMenuItem(hMenu,ID_EDIT_COPY,MF_BYCOMMAND|cutCopyEnabled);
            EnableMenuItem(hMenu,ID_EDIT_PASTE,MF_BYCOMMAND|pasteEnabled);
            EnableMenuItem(hMenu,ID_EDIT_SELECTALL,MF_BYCOMMAND|selectAllEnabled);
            EnableMenuItem(hMenu,ID_EDIT_FIND,MF_BYCOMMAND|findEnabled);
            EnableMenuItem(hMenu,ID_EDIT_FINDNEXT,MF_BYCOMMAND|findNextEnabled);
            EnableMenuItem(hMenu,ID_EDIT_REPLACE,MF_BYCOMMAND|replaceEnabled);
            break;
        case 2: // View Menu
            UINT statusBarChecked;

            if (IsWindowVisible(m_hStatusWnd)) {
                statusBarChecked = MF_CHECKED;
            } else {
                statusBarChecked = MF_UNCHECKED;
            }
            CheckMenuItem(hMenu,ID_VIEW_STATUSBAR,MF_BYCOMMAND|statusBarChecked);
            
            break;
        case 3: // Monitoring Menu
            UINT startActivated;
            UINT stopActivated;

            if (m_bIsTracing) {
                startActivated = MF_GRAYED;
                stopActivated = MF_ENABLED;
            } else {
                startActivated = MF_ENABLED;
                stopActivated = MF_GRAYED;
            }

            EnableMenuItem(hMenu,ID_MONITORING_START,MF_BYCOMMAND|startActivated);
            EnableMenuItem(hMenu,ID_MONITORING_STOP,MF_BYCOMMAND|stopActivated);
            // record is activated when stop is.
            EnableMenuItem(hMenu,ID_MONITORING_RECORD,MF_BYCOMMAND|stopActivated);
            break;
    }
}

VOID
CZippyWindow::OnFindMessageString(
    IN LPARAM lParam
    )

/*++

Routine Description:

    This handles a message from the find/replace
    dialog when a user hits a button

Arguments:

    lParam - LPFINDREPLACE struct for the dialog

Return value:
    
    None

--*/
{
    LPFINDREPLACE lpFindReplace;
    
    lpFindReplace = (LPFINDREPLACE)lParam;

    if (lpFindReplace->Flags & FR_DIALOGTERM) {
        // the dialog is closing
        m_hWndFindReplace = NULL;
    } else if (lpFindReplace->Flags & FR_FINDNEXT) {
        // the user selected find
        DoFindNext(lpFindReplace);
    } else if (lpFindReplace->Flags & FR_REPLACE) {
        DoReplace(lpFindReplace);
    } else if (lpFindReplace->Flags & FR_REPLACEALL) {
        DoReplaceAll(lpFindReplace);
    }
}

VOID
CZippyWindow::OnClose(
    )

/*++

Routine Description:

    When we receive a close window request we prompt
    the user to sace the trace if they have changed it.

Arguments:

    None

Return value:
    
    None

--*/
{
    INT result;
    TCHAR dlgMessage[MAX_STR_LEN];
    TCHAR dlgTitle[MAX_STR_LEN];

    if (SendMessage(m_hControlWnd,EM_GETMODIFY,0,0)) {
        LoadStringSimple(IDS_SAVEFILEPROMPT,dlgMessage);
        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);

        result = MessageBox(m_hWnd,dlgMessage,dlgTitle,MB_YESNOCANCEL|MB_ICONQUESTION);
        switch (result) {
        case IDYES:
            OnSave();
            if (SendMessage(m_hControlWnd,EM_GETMODIFY,0,0)) {
                // if there was an error saving we will try again.
                PostMessage(m_hWnd,WM_CLOSE,0,0);
                return;
            }
        case IDNO:
            DestroyWindow(m_hWnd);
            break;
        }
    } else {
        DestroyWindow(m_hWnd);
    }
}

VOID
CZippyWindow::OnDestroy(
    )

/*++

Routine Description:

    When the main window exits we halt the message loop

Arguments:

    None

Return value:
    
    None

--*/
{
    // If we don't clean up the tracing stuff here. There is a long
    // delay exiting for some reason.
    CTraceManager::_CleanupTraceManager();
    PostQuitMessage(0);
}



VOID
CZippyWindow::OnCommand(
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Below is WM_COMMAND and all the handler functions.
    The individual handler funcitons are not
    that interesting so I didn't individually comment them.

Arguments:

    wParam - (loword) command the user selected

    lParam - not used but it is the control

Return value:
    
    None

--*/
{
    WORD command;

    command = LOWORD(wParam);

    switch (command) {
    case ID_FILE_SAVE:
        OnSave();
        break;
    case ID_FILE_SAVEAS:
        OnSaveAs();
        break;
    case ID_FILE_LOADCONF:
        OnLoadConfiguration();
        break;
    case ID_FILE_SAVECONF:
        OnSaveConfiguration();
        break;
    case ID_FILE_SAVECONFAS:
        OnSaveConfigurationAs();
        break;
    case ID_FILE_EXIT:
        OnExit();
        break;
    case ID_EDIT_UNDO:
        OnUndo();
        break;
    case ID_EDIT_REDO:
        OnRedo();
        break;
    case ID_EDIT_CUT:
        OnCut();
        break;
    case ID_EDIT_COPY:
        OnCopy();
        break;
    case ID_EDIT_PASTE:
        OnPaste();
        break;
    case ID_EDIT_FIND:
        OnFind();
        break;
    case ID_EDIT_FINDNEXT:
        OnFindNext();
        break;
    case ID_EDIT_REPLACE:
        OnReplace();
        break;
    case ID_EDIT_SELECTALL:
        OnSelectAll();
        break;
    case ID_VIEW_STATUSBAR:
        OnChangeStatusBar();
        break;
    case ID_MONITORING_START:
        OnStartTracing();
        break;
    case ID_MONITORING_STOP:
        OnStopTracing();
        break;
    case ID_MONITORING_RECORD:
        OnRecordTracing();
        break;
    case ID_MONITORING_CLEARSCREEN:
        OnClearScreen();
        break;
    case ID_MONITORING_RESETTRACEFILES:
        OnResetTraceFiles();
        break;
    case ID_MONITORING_PREFERENCES:
        OnPreferences();
        break;
    case ID_HELP_ABOUTEZIPPY:
        OnAbout();
        break;
    }
}

VOID CZippyWindow::OnSave()
{
    if (m_SaveFile[0] == 0) {
        // if we don't have a file name do the
        // Save As version
        OnSaveAs();
    } else {
        DoSaveInternal();
    }
}

VOID CZippyWindow::OnSaveAs()
{
    OPENFILENAME fileInfo;
    BOOL bResult;

    ZeroMemory(&fileInfo,sizeof(fileInfo));

    fileInfo.lStructSize = sizeof(fileInfo);
    fileInfo.hwndOwner = m_hWnd;
    fileInfo.hInstance = g_hInstance;
    fileInfo.lpstrFilter = SAVE_FILE_TYPE;
    fileInfo.lpstrFile = m_SaveFile;
    fileInfo.nMaxFile = MAX_STR_LEN;
    fileInfo.Flags = OFN_OVERWRITEPROMPT;
    fileInfo.lpstrDefExt = SAVE_FILE_EXTENSION;

    bResult = GetSaveFileName(&fileInfo);
    if (!bResult) {
        return;
    }

    DoSaveInternal();
}

VOID CZippyWindow::OnLoadConfiguration()
{
    OPENFILENAME fileInfo;
    BOOL bResult;

    ZeroMemory(&fileInfo,sizeof(fileInfo));

    fileInfo.lStructSize = sizeof(fileInfo);
    fileInfo.hwndOwner = m_hWnd;
    fileInfo.hInstance = g_hInstance;
    fileInfo.lpstrFilter = SAVE_CONF_FILE_TYPE;
    fileInfo.lpstrFile = m_LoadConfFile;
    fileInfo.nMaxFile = MAX_STR_LEN;
    fileInfo.Flags = OFN_FILEMUSTEXIST;
    fileInfo.lpstrDefExt = SAVE_CONF_FILE_EXTENSION;

    bResult = GetOpenFileName(&fileInfo); 
    if (!bResult) {
        return;
    }

    DoLoadConfInternal();
}

VOID CZippyWindow::OnSaveConfiguration()
{
    if (m_SaveConfFile[0] == 0) {
        // if we don't have a file name do the
        // Save As version
        OnSaveConfigurationAs();
    } else {
        DoSaveConfInternal();
    }
}

VOID CZippyWindow::OnSaveConfigurationAs()
{
    OPENFILENAME fileInfo;
    BOOL bResult;

    ZeroMemory(&fileInfo,sizeof(fileInfo));

    fileInfo.lStructSize = sizeof(fileInfo);
    fileInfo.hwndOwner = m_hWnd;
    fileInfo.hInstance = g_hInstance;
    fileInfo.lpstrFilter = SAVE_CONF_FILE_TYPE;
    fileInfo.lpstrFile = m_SaveConfFile;
    fileInfo.nMaxFile = MAX_STR_LEN;
    fileInfo.Flags = OFN_OVERWRITEPROMPT;
    fileInfo.lpstrDefExt = SAVE_CONF_FILE_EXTENSION;

    bResult = GetSaveFileName(&fileInfo);
    if (!bResult) {
        return;
    }

    DoSaveConfInternal();
    
}

VOID CZippyWindow::OnExit()
{
    PostMessage(m_hWnd,WM_CLOSE,0,0);
}

// All the edit menu commands.  Except for select all they just call the
// corresponding message in the rich edit control. Select all has to
// manually set the selection

VOID CZippyWindow::OnUndo()
{
    SendMessage(m_hControlWnd,WM_UNDO,0,0);
}

VOID CZippyWindow::OnRedo()
{
    SendMessage(m_hControlWnd,EM_REDO,0,0);
}

VOID CZippyWindow::OnCut()
{
    SendMessage(m_hControlWnd,WM_CUT,0,0);
}

VOID CZippyWindow::OnCopy()
{
    SendMessage(m_hControlWnd,WM_COPY,0,0);
}

VOID CZippyWindow::OnPaste()
{
    SendMessage(m_hControlWnd,WM_PASTE,0,0);
}

VOID CZippyWindow::OnSelectAll()
{
    CHARRANGE selection;
    
    selection.cpMin = 0;
    selection.cpMax = -1;

    SendMessage(m_hControlWnd,EM_EXSETSEL,0,(LPARAM)&selection);
}

VOID CZippyWindow::OnFind()
{
    CHARRANGE currentSel;
    TEXTRANGE textRange;

    if (IsWindow(m_hWndFindReplace) && !m_bIsFindNotReplace) {
        // If they were in a replace dialog we destroy it and then
        // start over with a find dialog
        DestroyWindow(m_hWndFindReplace);
        m_hWndFindReplace = NULL;
    }
    if (!IsWindow(m_hWndFindReplace)) {
        SendMessage(m_hControlWnd,EM_EXGETSEL,0,(LPARAM)&currentSel);
    
        textRange.chrg.cpMin = currentSel.cpMin;
        if (currentSel.cpMax - currentSel.cpMin >=  FIND_REPLACE_BUFFER_SIZE) {
            textRange.chrg.cpMax = currentSel.cpMin + FIND_REPLACE_BUFFER_SIZE-1;
        } else {
            textRange.chrg.cpMax = currentSel.cpMax;
        }
        textRange.lpstrText = m_FindReplace.lpstrFindWhat;

        SendMessage(m_hControlWnd,EM_GETTEXTRANGE,0,(LPARAM)&textRange);

        m_bIsFindNotReplace = TRUE;
        m_FindReplace.hwndOwner = m_hWnd;
        m_FindReplace.hInstance = g_hInstance;
        m_FindReplace.Flags = FR_DOWN|FR_HIDEUPDOWN;
        m_FindReplace.wFindWhatLen = FIND_REPLACE_BUFFER_SIZE;
        m_hWndFindReplace = FindText(&m_FindReplace);
    } else {
        SetActiveWindow(m_hWndFindReplace);
    }

}

VOID CZippyWindow::OnFindNext()
{
    DoFindNext(&m_FindReplace);
}

VOID CZippyWindow::OnReplace()
{
    CHARRANGE currentSel;
    TEXTRANGE textRange;

    if (IsWindow(m_hWndFindReplace) && m_bIsFindNotReplace) {
        // If they were in a replace dialog we destroy it and then
        // start over with a find dialog
        DestroyWindow(m_hWndFindReplace);
        m_hWndFindReplace = NULL;
    }
    if (!IsWindow(m_hWndFindReplace)) {
        SendMessage(m_hControlWnd,EM_EXGETSEL,0,(LPARAM)&currentSel);
    
        textRange.chrg.cpMin = currentSel.cpMin;
        if (currentSel.cpMax - currentSel.cpMin >=  FIND_REPLACE_BUFFER_SIZE) {
            textRange.chrg.cpMax = currentSel.cpMin + FIND_REPLACE_BUFFER_SIZE-1;
        } else {
            textRange.chrg.cpMax = currentSel.cpMax;
        }
        textRange.lpstrText = m_FindReplace.lpstrFindWhat;
        SendMessage(m_hControlWnd,EM_GETTEXTRANGE,0,(LPARAM)&textRange);
        
        m_bIsFindNotReplace = FALSE;
        m_FindReplace.hwndOwner = m_hWnd;
        m_FindReplace.hInstance = g_hInstance;
        m_FindReplace.Flags = FR_DOWN;
        m_FindReplace.wFindWhatLen = FIND_REPLACE_BUFFER_SIZE;
        m_FindReplace.wReplaceWithLen = FIND_REPLACE_BUFFER_SIZE;
        m_hWndFindReplace = ReplaceText(&m_FindReplace);
    } else {
        SetActiveWindow(m_hWndFindReplace);
    }
}

VOID CZippyWindow::OnChangeStatusBar()
{
    RECT clientRect;
    
    if (IsWindowVisible(m_hStatusWnd)) {
        ShowWindow(m_hStatusWnd,SW_HIDE);
    } else {
        ShowWindow(m_hStatusWnd,SW_SHOW);
    }
    // we do this to make the client windows resize themselves
    // around the status bar

    GetClientRect(m_hWnd,&clientRect);
    OnSize(clientRect.right,clientRect.bottom);
}

VOID CZippyWindow::OnStartTracing()
{
    m_bIsTracing = TRUE;
}

VOID CZippyWindow::OnStopTracing()
{
    m_bIsTracing = FALSE;
}

VOID CZippyWindow::OnRecordTracing()
{
    CModalOkDialog recordDialog;
    LPSAVEDOUTPUT lpTemp;

    m_bIsStoringTraceData = TRUE;
    recordDialog.DoModal(MAKEINTRESOURCE(IDD_RECORDTRACE),m_hWnd);

    WaitForSingleObject(m_hAppendMutex,INFINITE);

    m_bIsStoringTraceData = FALSE;
    while (m_lpSavedOutputStart) {
        AppendTextToWindow(m_lpSavedOutputStart->procID,
            m_lpSavedOutputStart->text,m_lpSavedOutputStart->len);
        lpTemp = m_lpSavedOutputStart;
        m_lpSavedOutputStart = m_lpSavedOutputStart->next;
        HeapFree(GetProcessHeap(),0,lpTemp);
    }
    m_lpSavedOutputTail = NULL;

    ReleaseMutex(m_hAppendMutex);
}

VOID CZippyWindow::OnClearScreen()
{
    TCHAR dlgTitle[MAX_STR_LEN];
    TCHAR dlgMessage[MAX_STR_LEN];

    LoadStringSimple(IDS_CLEARCONFIRMTITLE,dlgTitle);
    LoadStringSimple(IDS_CLEARCONFIRMMESSAGE,dlgMessage);

    if (IDYES != MessageBox(m_hWnd,dlgMessage,dlgTitle,MB_YESNO)) {
        return;
    }

    OnSelectAll();
    SendMessage(m_hControlWnd, EM_REPLACESEL,FALSE,(LPARAM)_T(""));
}

VOID CZippyWindow::OnResetTraceFiles()
{
    TCHAR dlgTitle[MAX_STR_LEN];
    TCHAR dlgMessage[MAX_STR_LEN];

    LoadStringSimple(IDS_CONFIRMRESETTRACETITLE,dlgTitle);
    LoadStringSimple(IDS_CONFIRMRESETTRACEMESSAGE,dlgMessage);

    if (IDYES != MessageBox(m_hWnd,dlgMessage,dlgTitle,MB_YESNO)) {
        return;
    }

    m_rTracer->TRC_ResetTraceFiles();
}

VOID CZippyWindow::OnPreferences()
{
    COptionsDialog optionsDialog(m_rTracer);

    optionsDialog.DoDialog(m_hWnd);
}

VOID CZippyWindow::OnAbout()
{
    HICON appIcon;
    TCHAR appTitle[MAX_STR_LEN];
    TCHAR appOtherStuff[MAX_STR_LEN];

    LoadStringSimple(IDS_ABOUTAPPTITLE,appTitle);
    LoadStringSimple(IDS_ABOUTOTHERSTUFF,appOtherStuff);
    appIcon = (HICON)LoadImage(g_hInstance,MAKEINTRESOURCE(IDI_MAINFRAME),
        IMAGE_ICON,0,0,LR_SHARED);
    
    if( NULL != appIcon )
    {
      ShellAbout(m_hWnd,appTitle,appOtherStuff,appIcon);
    
    // even though the icon is shared we should destroy it to keep the reference
    // count somewhat sane.
      DestroyIcon(appIcon);
    }
}

//
//  *** Private Helper Functions ***
//

//
// Computes the color for the given debut output.  It parses the text to dtermine
// what the thread id is and then either retrieves the color for that thread or
// picks a new color
//
BOOL CZippyWindow::ComputeNewColor(DWORD processID, LPCTSTR text, UINT len, CHARFORMAT *lpFormat)
{
    LPTSTR procIdStr;
    DWORD threadId;
    LPCTSTR procBase;
    UINT maxStrLen;
    BOOL bSuccess;
    UINT threadLen;
    LPTHREADCOLOR newColor;

    procIdStr = NULL;
    bSuccess = TRUE;

    // first we will just make sure the format struct is in a safe state.
    lpFormat->cbSize = sizeof(CHARFORMAT);
    lpFormat->dwMask = 0;

    maxStrLen = sizeof(DWORD) * 2;
    
    procIdStr = (LPTSTR)HeapAlloc(GetProcessHeap(),0,sizeof(TCHAR) * (maxStrLen+1));
    if (!procIdStr) {
        bSuccess = FALSE;
        goto CLEANUP_AND_EXIT;
    }

    wsprintf(procIdStr,TRC_PROC_FMT,processID);

    procBase = _tcsstr(text,procIdStr);
    if (!procBase) {
        bSuccess = FALSE;
        goto CLEANUP_AND_EXIT;
    }

    procBase += _tcslen(procIdStr);

    if (*procBase != ':') {
        bSuccess = FALSE;
        goto CLEANUP_AND_EXIT;
    }
    procBase++;

    threadLen = 0;
    while (_istxdigit(*(procBase + threadLen))) {
        threadLen++;
    }
    if (!threadLen) {
        bSuccess = FALSE;
        goto CLEANUP_AND_EXIT;
    }
   
    threadId = ConvertHexStrToDword(procBase,threadLen);
    
    newColor = FindColorForThread(processID,threadId);

    lpFormat->crTextColor = newColor->color;
    lpFormat->dwEffects = 0;
    lpFormat->dwMask = CFM_COLOR;

CLEANUP_AND_EXIT:
    
    if (procIdStr) {
        HeapFree(GetProcessHeap(),0,procIdStr);
    }

    return bSuccess;
}

//
// This converts a hex string to the equivalent DWORD value for example
// the string "FF" would cause the function to return 0xFF (255)
//
DWORD CZippyWindow::ConvertHexStrToDword(LPCTSTR str, UINT strLen)
{
    DWORD total;
    TCHAR current;
    INT currentValue;

    total = 0;
    if (strLen == 0) {
        strLen = _tcslen(str);
    }

    while (strLen-- > 0) {
        current = *(str++);
        if (_istdigit(current)) {
            currentValue = current - '0';
        } else {
            current = (TCHAR)tolower((INT)current);
            currentValue = 10 + (current - 'a');
        }
        total = (total * 16) + currentValue;
    }

    return total;
}

// This looks up the color for the given thread.  If the thread has not been
// seen before a new color is picked and the color for the thread is saved.
LPTHREADCOLOR CZippyWindow::FindColorForThread(DWORD processId, DWORD threadId)
{
    int i = 0;
    LPTHREADCOLOR lpThreadColor;

    for (i=0;i<COLOR_HISTORY_COUNT;i++) {
        if (m_threadHistory[i].threadId == threadId &&
            m_threadHistory[i].processId == processId) {
            return &m_threadHistory[i];
        }
    }
    // else this is the first time we saw the thread

    lpThreadColor = &m_threadHistory[m_nextThreadIndex++];
    if (m_nextThreadIndex == COLOR_HISTORY_COUNT) {
        m_nextThreadIndex = 0;
    }
    lpThreadColor->processId = processId;
    lpThreadColor->threadId = threadId;
    lpThreadColor->color = colors[m_nextThreadColor++];
    if (m_nextThreadColor == NUM_COLORS) {
        m_nextThreadColor = 0;
    }

    return lpThreadColor;
}

// This handles actually saving the document.
VOID CZippyWindow::DoSaveInternal()
{
    HANDLE saveFile;
    EDITSTREAM saveStream;
    LRESULT bytesSaved;
    TCHAR dlgTitle[MAX_STR_LEN];
    TCHAR dlgMessage[MAX_STR_LEN];

    saveFile = CreateFile(m_SaveFile,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,
        0,NULL);
    if (saveFile==INVALID_HANDLE_VALUE) {
        LoadStringSimple(IDS_FILEOPENERROR,dlgMessage);
        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);

        MessageBox(m_hWnd,dlgMessage,dlgTitle,MB_OK|MB_ICONERROR);
        return;
    }

    saveStream.dwCookie = (DWORD_PTR)saveFile;
    saveStream.dwError = 0;
    saveStream.pfnCallback = SaveCallback;

    bytesSaved = SendMessage(m_hControlWnd,EM_STREAMOUT,SF_TEXT,(LPARAM)&saveStream);

    CloseHandle(saveFile);

    if (saveStream.dwError != 0) {
        LoadStringSimple(IDS_FILESAVEERROR,dlgMessage);
        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);

        MessageBox(m_hWnd,dlgMessage,dlgTitle,MB_OK|MB_ICONERROR);
    } else {
        SendMessage(m_hControlWnd,EM_SETMODIFY,FALSE,0);
    }


}

// This is a private callback function which rich edit calls when
// saving out the document
static DWORD CALLBACK
SaveCallback(DWORD_PTR dwCookie,LPBYTE pbBuff,LONG cb,LONG *pcb)
{
    HANDLE fileHandle;

    fileHandle = (HANDLE)dwCookie;

    if (!WriteFile(fileHandle,pbBuff,cb,(PULONG)pcb,NULL)) {
        return GetLastError();
    }
    return 0;
}

// As the function name says this does a find next operation
// on the rich edit control
BOOL CZippyWindow::DoFindNext(LPFINDREPLACE lpFindReplace)
{
    FINDTEXTEX findText;
    WPARAM searchOptions;
    CHARRANGE currentSel;
    TCHAR dlgTitle[MAX_STR_LEN];
    TCHAR dlgMessage[MAX_STR_LEN];

    SendMessage(m_hControlWnd,EM_EXGETSEL,0,(LPARAM)&currentSel);
    findText.chrg.cpMin = currentSel.cpMax;
    findText.chrg.cpMax = -1;
    
    findText.lpstrText = lpFindReplace->lpstrFindWhat;

    searchOptions = FR_DOWN;
    if (lpFindReplace->Flags & FR_MATCHCASE) {
        searchOptions |= FR_MATCHCASE;
    }
    if (lpFindReplace->Flags & FR_WHOLEWORD) {
        searchOptions |= FR_WHOLEWORD;
    }
    
    if (0 <= SendMessage(m_hControlWnd, EM_FINDTEXTEX,searchOptions,
        (LPARAM)&findText)) {
        SendMessage(m_hControlWnd, EM_EXSETSEL,0,(LPARAM)&findText.chrgText);
    } else {
        LoadStringSimple(IDS_SEARCHFAILURE,dlgMessage);
        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);

        MessageBox(m_hWndFindReplace,dlgMessage,dlgTitle,MB_OK);

        return FALSE;
    }

    return TRUE;
    
}

// This does a replace operation on the control
BOOL CZippyWindow::DoReplace(LPFINDREPLACE lpFindReplace)
{
    FINDTEXTEX findText;
    WPARAM searchOptions;
    CHARRANGE currentSel;
    TCHAR dlgTitle[MAX_STR_LEN];
    TCHAR dlgMessage[MAX_STR_LEN];

    SendMessage(m_hControlWnd,EM_EXGETSEL,0,(LPARAM)&currentSel);
    findText.chrg.cpMin = currentSel.cpMin;
    findText.chrg.cpMax = -1;
    
    findText.lpstrText = lpFindReplace->lpstrFindWhat;

    searchOptions = FR_DOWN;
    if (lpFindReplace->Flags & FR_MATCHCASE) {
        searchOptions |= FR_MATCHCASE;
    }
    if (lpFindReplace->Flags & FR_WHOLEWORD) {
        searchOptions |= FR_WHOLEWORD;
    }
    
    if (-1 == SendMessage(m_hControlWnd, EM_FINDTEXTEX,searchOptions,
        (LPARAM)&findText)) {
        // if we can't find what they were looking for just give up.
        LoadStringSimple(IDS_SEARCHFAILURE,dlgMessage);
        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);
        
        MessageBox(m_hWndFindReplace,dlgMessage,dlgTitle,MB_OK);
        return FALSE;
    }

    if (currentSel.cpMin == findText.chrgText.cpMin && 
        currentSel.cpMax == findText.chrgText.cpMax) {
        SendMessage(m_hControlWnd,EM_REPLACESEL,0,(LPARAM)lpFindReplace->lpstrReplaceWith);
        // Now select the next occurrence
        return DoFindNext(lpFindReplace);
    } else {
        // They weren't on what they were searching for so select it.
        SendMessage(m_hControlWnd, EM_EXSETSEL,0,(LPARAM)&findText.chrgText);
    }

    return TRUE;

}

// This loops on DoReplace until DoReplace returns FALSE
VOID CZippyWindow::DoReplaceAll(LPFINDREPLACE lpFindReplace)
{
    while (DoReplace(lpFindReplace));
}

// This actually saves the traceconfiguration.  We just write
// out the binary config structure to the file
VOID CZippyWindow::DoSaveConfInternal()
{
    HANDLE saveFile;
    TRC_CONFIG trcConfig;
    TCHAR dlgTitle[MAX_STR_LEN];
    TCHAR dlgMessage[MAX_STR_LEN];
    DWORD bytesWritten;

    saveFile = CreateFile(m_SaveConfFile,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,
        0,NULL);
    if (saveFile==INVALID_HANDLE_VALUE) {
        LoadStringSimple(IDS_FILEOPENERROR,dlgMessage);
        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);

        MessageBox(m_hWnd,dlgMessage,dlgTitle,MB_OK|MB_ICONERROR);
        return;
    }

    m_rTracer->GetCurrentConfig(&trcConfig);

    if (!WriteFile(saveFile,&trcConfig,sizeof(trcConfig),&bytesWritten,NULL) ||
        bytesWritten != sizeof(trcConfig)) {
        
        LoadStringSimple(IDS_FILESAVEERROR,dlgMessage);
        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);

        MessageBox(m_hWnd,dlgMessage,dlgTitle,MB_OK|MB_ICONERROR);
    }
   
    CloseHandle(saveFile);

}

// This reads in the binary configuration structure and then
// sets it as the current tracing config
VOID CZippyWindow::DoLoadConfInternal()
{
    HANDLE openFile;
    DWORD bytesRead;
    TRC_CONFIG trcConfig;
    TCHAR dlgTitle[MAX_STR_LEN];
    TCHAR dlgMessage[MAX_STR_LEN];
    

    openFile = CreateFile(m_LoadConfFile,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,
        0,NULL);
    if (openFile==INVALID_HANDLE_VALUE) {
        LoadStringSimple(IDS_FILELOADOPENERROR,dlgMessage);
        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);

        MessageBox(m_hWnd,dlgMessage,dlgTitle,MB_OK|MB_ICONERROR);
        return;
    }

    if (!ReadFile(openFile,&trcConfig,sizeof(trcConfig),&bytesRead,NULL)||
        bytesRead != sizeof(trcConfig)) {
        LoadStringSimple(IDS_FILELOADERROR,dlgMessage);
        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);

        MessageBox(m_hWnd,dlgMessage,dlgTitle,MB_OK|MB_ICONERROR);
    }
    
    m_rTracer->SetCurrentConfig(&trcConfig);

}

// Reads the saved window position in from the registry.
VOID CZippyWindow::GetSavedWindowPos(LPRECT savedPos)
{
    DWORD dwResult;
    DWORD dwSize;
    DWORD dwType;
    RECT rect;
    HKEY hKey;
    
    savedPos->top = WINDOW_DEF_TOP;
    savedPos->bottom = WINDOW_DEF_BOTTOM;
    savedPos->left = WINDOW_DEF_LEFT;
    savedPos->right = WINDOW_DEF_RIGHT;

    dwResult = RegOpenKeyEx(HKEY_CURRENT_USER,ZIPPY_REG_KEY,0,
        KEY_QUERY_VALUE,&hKey);
    if (dwResult) {
        return;
    }
    dwSize = sizeof(RECT);
    dwResult = RegQueryValueEx(hKey,ZIPPY_WINDOW_POS_VALUE,NULL,&dwType,
        (LPBYTE)&rect,&dwSize);
    RegCloseKey(hKey);
    if (dwResult||dwSize != sizeof(RECT)||dwType!=REG_BINARY) {
        return;
    }

    *savedPos = rect;
}

// Saves the window position out to the registry
VOID CZippyWindow::SaveWindowPos(LPRECT newPos)
{
    DWORD dwResult;
    HKEY hKey;

    dwResult = RegCreateKeyEx(HKEY_CURRENT_USER,ZIPPY_REG_KEY,0,_T(""),0,
        KEY_SET_VALUE,NULL,&hKey,NULL);
    if (dwResult) {
        return;
    }

    RegSetValueEx(hKey,ZIPPY_WINDOW_POS_VALUE,0,REG_BINARY,
        (LPBYTE)newPos,sizeof(RECT));
    
    RegCloseKey(hKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\tssec\encrypt.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    encrypt.c

Abstract:

    Contains functions that encrypt and decrypt data sent accross client and
    server.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include <seccom.h>

VOID
GenerateMACSignature(
    LPBYTE pbData,
    DWORD dwDataLen,
    LPBYTE pbMACSaltKey,
    DWORD dwMACSaltKey,
    LPBYTE pbSignature,
    BOOL   fIncludeEncryptionCount,
    DWORD  dwEncryptionCount
    )
/*++

Routine Description:

    This function generates a message authentication signature.

Arguments:

    pbData - pointer to a data buffer.

    dwDataLen - length of the above data.

    pbMACSaltKey - pointer to a MAC salt key.

    pbSignature - pointer a signature buffer.
    
    fIncludeEncryptionCount - TRUE to salt in the encryption count
    
    dwEncryptionCount - total encryption count

Return Value:

    None.

--*/
{
    A_SHA_CTX       SHAHash;
    MD5_CTX         MD5Hash;
    BYTE            abSHADigest[A_SHA_DIGEST_LEN];

    //
    // make a SHA(MACSalt + g_abPad1 + Length + Content) hash.
    //

    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, pbMACSaltKey, dwMACSaltKey);
    A_SHAUpdate(&SHAHash, (unsigned char *)g_abPad1, 40);
    A_SHAUpdate(&SHAHash, (LPBYTE)&dwDataLen, sizeof(DWORD));
    A_SHAUpdate(&SHAHash, pbData, dwDataLen);
    if (fIncludeEncryptionCount) {
        A_SHAUpdate(&SHAHash, (LPBYTE)&dwEncryptionCount, sizeof(DWORD));
    }
    A_SHAFinal(&SHAHash, abSHADigest);

    //
    // make a MD5(MACSalt + g_abPad2 + SHAHash) hash.
    //

    MD5Init(&MD5Hash);
    MD5Update(&MD5Hash, pbMACSaltKey, dwMACSaltKey);
    MD5Update(&MD5Hash, g_abPad2, 48);
    MD5Update(&MD5Hash, abSHADigest, A_SHA_DIGEST_LEN);
    MD5Final(&MD5Hash);

    ASSERT( DATA_SIGNATURE_SIZE <= MD5DIGESTLEN );
    memcpy(pbSignature, MD5Hash.digest, DATA_SIGNATURE_SIZE);

    return;
}

BOOL
EncryptData(
    DWORD dwEncryptionLevel,
    LPBYTE pSessionKey,
    struct RC4_KEYSTRUCT FAR *prc4EncryptKey,
    DWORD dwKeyLength,
    LPBYTE pbData,
    DWORD dwDataLen,
    LPBYTE pbMACSaltKey,
    LPBYTE pbSignature,
    BOOL   fSecureChecksum,
    DWORD  dwEncryptionCount
    )
/*++

Routine Description:

    Encrypt the given data buffer in place.

Arguments:

    dwEncryptionLevel - encryption level, used to select the encryption
        algorithm.

    pSessionKey - pointer to the session key.

    prc4EncryptKey - pointer to a RC4 key.

    dwKeyLength - length of the session key.

    pbData - pointer to the data buffer being encrypted, encrypted data is
        returned in the same buffer.

    dwDataLen - length of the data buffer.

    pbMACSaltKey - pointer to a message authentication key buffer.

    pbSignature - pointer to a signature buffer where the data signature is
        returned.

    fSecureChecksum - TRUE if the checksum is to be salted with the encryption
                      count
                             
    dwDecryptionCount - running counter of all encryptions

Return Value:

    TRUE - if successfully encrypted the data.

    FALSE - otherwise.

--*/
{
    //
    // generate the MAC signature first.
    //

    GenerateMACSignature (
        pbData,
        dwDataLen,
        pbMACSaltKey,
        dwKeyLength,
        pbSignature,
        fSecureChecksum,
        dwEncryptionCount
        );


    //
    // encrypt data.
    //

    //
    // use microsoft version of rc4 algorithm (super fast!) for level 1 and
    // level 2 encryption, for level 3 use RSA rc4 algorithm.
    //

    if( dwEncryptionLevel <= 2 ) {

        msrc4(prc4EncryptKey, (UINT)dwDataLen, pbData );
    }
    else {

        rc4(prc4EncryptKey, (UINT)dwDataLen, pbData );
    }


    return( TRUE );
}

BOOL
DecryptData(
    DWORD dwEncryptionLevel,
    LPBYTE pSessionKey,
    struct RC4_KEYSTRUCT FAR *prc4DecryptKey,
    DWORD dwKeyLength,
    LPBYTE pbData,
    DWORD dwDataLen,
    LPBYTE pbMACSaltKey,
    LPBYTE pbSignature,
    BOOL   fSecureChecksum,
    DWORD  dwDecryptionCount
    )
/*++

Routine Description:

    Decrypt the given data buffer in place.

Arguments:

    dwEncryptionLevel - encryption level, used to select the encryption
        algorithm.

    pSessionKey - pointer to the session key.

    prc4DecryptKey - pointer to a RC4 key.

    dwKeyLength - length of the session key.

    pbData - pointer to the data buffer being decrypted, decrypted data is
        returned in the same buffer.

    dwDataLen - length of the data buffer.

    pbMACSaltKey - pointer to a message authentication key buffer.

    pbSignature - pointer to a signature buffer where the data signature is
        returned.
        
    fSecureChecksum - TRUE if the checksum is to be salted with the encryption
                      count
                             
    dwDecryptionCount - running counter of all encryptions

Return Value:

    TRUE - if successfully encrypted the data.

    FALSE - otherwise.

--*/
{
    BYTE abSignature[DATA_SIGNATURE_SIZE];

    //
    // decrypt data.
    //

    //
    // use microsoft version of rc4 algorithm (super fast!) for level 1 and
    // level 2 encryption, for level 3 use RSA rc4 algorithm.
    //

    if( dwEncryptionLevel <= 2 ) {
        msrc4(prc4DecryptKey, (UINT)dwDataLen, pbData );
    }
    else {
        rc4(prc4DecryptKey, (UINT)dwDataLen, pbData );
    }

    GenerateMACSignature (
        pbData,
        dwDataLen,
        pbMACSaltKey,
        dwKeyLength,
        (LPBYTE)abSignature,
        fSecureChecksum,
        dwDecryptionCount
        );

    //
    // check to see the sigature match.
    //

    if( memcmp(
            (LPBYTE)abSignature,
            pbSignature,
            sizeof(abSignature) ) ) {
        return( FALSE );
    }

    return( TRUE );
}

#ifdef USE_MSRC4

VOID
msrc4_key(
    struct RC4_KEYSTRUCT FAR *pKS,
    DWORD dwLen,
    LPBYTE pbKey
    )
/*++

Routine Description:

    Generate the key control structure.  Key can be any size.

    Assumes pKS is locked against simultaneous use.

Arguments:

    pKS - pointer to a KEYSTRUCT structure that will be initialized.

    dwLen - Size of the key, in bytes.

    pbKey - Pointer to the key.

Return Value:

    NONE.

--*/
{

#define SWAP(_x_, _y_) { BYTE _t_; _t_ = (_x_); (_x_) = (_y_); (_y_) = _t_; }

    BYTE index1;
    BYTE index2;
    UINT counter;
    BYTE bLen;

    ASSERT( dwLen < 256 );

    bLen = ( dwLen >= 256 ) ? 255 : (BYTE)dwLen;

    for (counter = 0; counter < 256; counter++) {
        pKS->S[counter] = (BYTE) counter;
    }

    pKS->i = 0;
    pKS->j = 0;

    index1 = 0;
    index2 = 0;

    for (counter = 0; counter < 256; counter++) {
        index2 = (pbKey[index1] + pKS->S[counter] + index2);
        SWAP(pKS->S[counter], pKS->S[index2]);
        index1 = (index1 + 1) % bLen;
    }
}

VOID
msrc4(
    struct RC4_KEYSTRUCT FAR *pKS,
    DWORD dwLen,
    LPBYTE pbuf
    )
/*++

Routine Description:

    Performs the actual encryption or decryption.

    Assumes pKS is locked against simultaneous use.

Arguments:

    pKS - Pointer to the KEYSTRUCT created using msrc4_key().

    dwLen - Size of buffer, in bytes.

    pbuf - Buffer to be encrypted.

Return Value:

    NONE.

--*/
{

    BYTE FAR *const s = pKS->S;
    BYTE a, b;

    while(dwLen--) {

        a = s[++(pKS->i)];
        pKS->j += a;
        b = s[pKS->j];
        s[pKS->j] = a;
        a += b;
        s[pKS->i] = b;
        *pbuf++ ^= s[a];
    }
}

#endif // USE_MSRC4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\tssec\genrand.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    tssec.c

Abstract:

    Contains code that generates random keys.

Author:

    Madan Appiah (madana)  1-Jan-1998
    Modified by Nadim Abdo 31-Aug-2001 to use system RNG

Environment:

    User Mode - Win32

Revision History:

--*/

#include <seccom.h>
#include <stdlib.h>

#ifdef OS_WINCE
#include <rng.h>
#endif

#ifndef OS_WINCE
#include <randlib.h>
#endif

VOID
TSRNG_Initialize(
    )
{
#ifndef OS_WINCE
    InitializeRNG(NULL);
#else
    TSInitializeRNG();
#endif
}


VOID
TSRNG_Shutdown(
    )
{
#ifndef OS_WINCE
    ShutdownRNG(NULL);
#endif
}



//
// function definitions
//

BOOL
TSRNG_GenerateRandomBits(
    LPBYTE pbRandomBits,
    DWORD  cbLen
    )
/*++

Routine Description:

    This function returns random bits

Arguments:

    pbRandomBits - pointer to a buffer where a random key is returned.

    cbLen - length of the random key required.

Return Value:

    TRUE - if a random key is generated successfully.
    FALSE - otherwise.

--*/
{
#ifndef OS_WINCE
    BOOL fRet;
    
    fRet = NewGenRandom(NULL, NULL, pbRandomBits, cbLen);

    return fRet;
#else
    GenerateRandomBits(pbRandomBits, cbLen);
    return( TRUE );
#endif
}


BOOL
TSCAPI_GenerateRandomBits(
    LPBYTE pbRandomBits,
    DWORD cbLen
    )
/*++

Routine Description:

    This function generates random number using CAPI in user mode

Arguments:

    pbRandomBits - pointer to a buffer where a random key is returned.

    cbLen - length of the random key required.

Return Value:

    TRUE - if a random number is generated successfully.
    FALSE - otherwise.

--*/
{
    HCRYPTPROV hProv;
    BOOL rc = FALSE;
    DWORD dwExtraFlags = CRYPT_VERIFYCONTEXT;
    DWORD dwError;

    // Get handle to the default provider.
    if(!CryptAcquireContext(&hProv, NULL, 0, PROV_RSA_FULL, dwExtraFlags)) {

        // Could not acquire a crypt context, get the reason of failure
        dwError = GetLastError();

        // If we get this error, it means the caller is impersonating a user (in Remote Assistance)
        // we revert back to the old way of generating random bits
        if (dwError == ERROR_FILE_NOT_FOUND) {
            rc = TSRNG_GenerateRandomBits(pbRandomBits, cbLen);
            goto done;
        }

        // Since default keyset should always exist, we can't hit this code path
        if (dwError == NTE_BAD_KEYSET) {
            //
            //create a new keyset
            //
            if(!CryptAcquireContext(&hProv, NULL, 0, PROV_RSA_FULL, dwExtraFlags | CRYPT_NEWKEYSET)) {
                //printf("Error %x during CryptAcquireContext!\n", GetLastError());
                goto done;
            }
        }
        else {
            goto done;
        }
    }
    
    if (CryptGenRandom(hProv, cbLen, pbRandomBits)) {
        rc = TRUE;
    }

    CryptReleaseContext(hProv, 0); 

done:
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\tssec\fencrypt.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    encrypt.c

Abstract:

    Contains functions that detect the run system is french locale.

Author:

    Madan Appiah (madana)  16-May-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include <seccom.h>

#ifdef OS_WIN32

BOOL
IsFrenchSystem(
    VOID
    )
/*++

Routine Description:

    French laws are strict with respect to the import of software products which
    contain cryptography. Therefore many Microsoft products must check for a locale
    of France and disable cryptographic services if this is the case. There is the
    possibility that forms of cryptography currently restricted may eventually be
    allowed in France. For this reason it is valuable to implement a check for a
    crypto approval indicator which could easily be installed on a Windows system in
    the future. The indicator tells the software that it is OK to enable specific
    cryptographic services which may not have been approved for import to France
    when the software was released, but have been subsequently allowed. Below are
    two code fragments, the first indicates how to check for the locale of France.
    The second code fragment is a simple example of how a check for a cryptographic
    approval indicator might be implemented.


    This function implements France Locale detection.

Arguments:

    None.

Return Value:

    TURE - if the system is French.

    FALSE - if not.

--*/
{
#define MAX_INT_SIZE 16

    LCID dwDefaultSystemLCID;
    LANGID wCurrentLangID;
    DWORD dwLen;
    TCHAR achCountryCode[MAX_INT_SIZE];
    DWORD dwCountryCode;

    //
    // Get system default locale ID.
    //

    dwDefaultSystemLCID = GetSystemDefaultLCID();

    //
    // get language ID from locale ID.
    //

    wCurrentLangID = LANGIDFROMLCID(dwDefaultSystemLCID);

    //
    // check to see the system is running with french locale.
    //

    if( ( PRIMARYLANGID(wCurrentLangID) == LANG_FRENCH) &&
        ( SUBLANGID(wCurrentLangID) == SUBLANG_FRENCH) ) {
        return( TRUE );
    }

    //
    // check to see the user's country code is set to CTRY_FRENCH.
    //

    dwLen =
        GetLocaleInfo(
            dwDefaultSystemLCID,
            LOCALE_ICOUNTRY,
            achCountryCode,
            sizeof(achCountryCode) / sizeof(TCHAR));

    if( dwLen == 0 ) {

        //
        // we could not read the country code ..
        //

        return( FALSE );
    }

    //
    // convert the country code string to integer.
    //

    dwCountryCode = (DWORD)_ttol(achCountryCode);

    if( dwCountryCode != CTRY_FRANCE ) {
        return( FALSE );
    }

    //
    // if we are here, then the system is french locale system.
    //

    return( TRUE );
}

#else // OS_WIN32

BOOL
IsFrenchSystem(
    VOID
    )
/*++

Routine Description:

    This function implements France Locale detection for win3.1.

Arguments:

    None.

Return Value:

    TURE - if the system is French.

    FALSE - if not.

--*/
{
#define MAX_LANG_STRING_SIZE 16

    DWORD dwLen;
    CHAR achLangStr[MAX_LANG_STRING_SIZE];

    //
    // read [intl] section in the win.ini to determine the
    // system locale.
    //

    dwLen =
        GetProfileString(
            "intl",
            "sLanguage",
            "",
            achLangStr,
            sizeof(achLangStr));

    if( (dwLen == 3) &&
        (_stricmp(achLangStr, "fra") == 0) ) {

        //
        // french system.
        //

        return( TRUE );
    }

    //
    // now read country code.
    //


    dwLen =
        GetProfileString(
            "intl",
            "iCountry",
            "",
            achLangStr,
            sizeof(achLangStr));

    if( (dwLen == 2) &&
        (_stricmp(achLangStr, "33") == 0) ) {

        //
        // french system.
        //

        return( TRUE );
    }

    //
    // not a french system.
    //

    return( FALSE );
}

#endif // OS_WIN32

BOOL
FindIsFrenchSystem(
    VOID
    )
/*++

Routine Description:

    The function implements a check for the locale of France.

    Note : it makes system calls to determine the system locale once
    and remembers it for later calls.

Arguments:

    None.

Return Value:

    TURE - if the system is French.

    FALSE - if not.

--*/
{
typedef enum {
    Uninitialized   = 0,
    FrenchSystem    = 1,
    NotFrenchSystem = 2
} FrenchSystemType;

    static FrenchSystemType g_dwIsFrenchSystem = Uninitialized;

    if( g_dwIsFrenchSystem == Uninitialized ) {


        if( IsFrenchSystem() ) {
            g_dwIsFrenchSystem = FrenchSystem;
        }
        else {
            g_dwIsFrenchSystem = NotFrenchSystem;
        }
    }

    if( g_dwIsFrenchSystem == FrenchSystem ) {
        return( TRUE );
    }

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\tssec\global.h ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    global.h

Abstract:

    Global data definitions for tshare security.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _GLOBAL_H_
#define _GLOBAL_H_


//
// global data definitions.
//

extern const BYTE g_abPad1[40];

extern const BYTE g_abPad2[48];

extern LPBSAFE_PUB_KEY g_pPublicKey;

extern BYTE g_abPublicKeyModulus[92];

extern BYTE g_abServerCertificate[184];

extern BYTE g_abServerPrivateKey[380];

extern BOOL g_128bitEncryptionEnabled;

#endif // _GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\tssec\clicert.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    clicert.c

Abstract:

    Contains code related to the tshare certificate validation and data
    encryption using server public key.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include <seccom.h>
BOOL
UnpackServerCert(
    LPBYTE pbCert,
    DWORD dwCertLen,
    PHydra_Server_Cert pServerCert
    )
/*++

Routine Description:

    This function unpacks the blob of server certicate to server certificate
    structure.

Arguments:

    pbCert - pointer to the server public key blob.

    dwCertLen - length of the above server public key.

    pServerCert - pointer to a server certificate structure.

Return Value:

    TRUE - if successfully unpacked.
    FALSE - otherwise.

--*/
{
    LPBYTE pbScan;
    DWORD cbScan;
    //
    // return if the pointer are invalid.
    // return if the certificate is insufficient length.
    //

    if( (pbCert == NULL) ||
        (dwCertLen < (3 * sizeof(DWORD) + 4 * sizeof(WORD))) ||
        (pServerCert == NULL) ) {

        return( FALSE );
    }

    pbScan = pbCert;
    cbScan = dwCertLen;
    //
    // Assign dwVersion
    //

    pServerCert->dwVersion = *(DWORD UNALIGNED FAR *)pbScan;
    pbScan += sizeof(DWORD);
    cbScan -= sizeof(DWORD);
    //
    // Assign dwSigAlgID
    //

    pServerCert->dwSigAlgID = *(DWORD UNALIGNED FAR *)pbScan;
    pbScan += sizeof(DWORD);
    cbScan -= sizeof(DWORD);
    //
    // Assign dwSignID
    //

    pServerCert->dwKeyAlgID  = *(DWORD UNALIGNED FAR *)pbScan;
    pbScan += sizeof(DWORD);
    cbScan -= sizeof(DWORD);
    //
    //Assign PublicKeyData
    //

    pServerCert->PublicKeyData.wBlobType = *(WORD UNALIGNED FAR *)pbScan;
    pbScan += sizeof(WORD);
    cbScan -= sizeof(WORD);

    if( pServerCert->PublicKeyData.wBlobType != BB_RSA_KEY_BLOB ) {
        return( FALSE );
    }

    pServerCert->PublicKeyData.wBlobLen = *(WORD UNALIGNED FAR *)pbScan;
    pbScan += sizeof(WORD);
    cbScan -= sizeof(WORD);
    
    if( pServerCert->PublicKeyData.wBlobLen > 0 ) {
        
        if(cbScan < pServerCert->PublicKeyData.wBlobLen) {
            return ( FALSE );
        }
        pServerCert->PublicKeyData.pBlob = pbScan;
        pbScan += pServerCert->PublicKeyData.wBlobLen;
        cbScan -= pServerCert->PublicKeyData.wBlobLen;
    }
    else {

        pServerCert->PublicKeyData.pBlob = NULL;
    }

    //
    // Assign SignatureBlob
    //
    
    if(cbScan < sizeof(WORD)) {
        return ( FALSE );
    }
    pServerCert->SignatureBlob.wBlobType = *(WORD UNALIGNED *)pbScan;
    pbScan += sizeof(WORD);
    cbScan -= sizeof(WORD);

    if( pServerCert->SignatureBlob.wBlobType != BB_RSA_SIGNATURE_BLOB ) {
        return( FALSE );
    }
    
    if(cbScan < sizeof(WORD)) {
        return ( FALSE );
    }
    pServerCert->SignatureBlob.wBlobLen = *(WORD UNALIGNED FAR *)pbScan;
    pbScan += sizeof(WORD);
    cbScan -= sizeof(WORD);

    if( pServerCert->SignatureBlob.wBlobLen > 0 ) {
        
        if(cbScan < pServerCert->SignatureBlob.wBlobLen) {
            return ( FALSE );
        }
        pServerCert->SignatureBlob.pBlob = pbScan;
    }
    else {

        pServerCert->SignatureBlob.pBlob = NULL;
    }

    return( TRUE );
}

BOOL
ValidateServerCert(
    PHydra_Server_Cert pServerCert
    )
/*++

Routine Description:

    This function validate the server public key.

Arguments:

    pSserverCert - pointer to a server certificate.

Return Value:

    TRUE - if the server public key is valid.
    FALSE - otherwise.

--*/
{

    DWORD dwLen;
    LPBYTE pbSignature;
    MD5_CTX HashState;
    BYTE SignHash[0x48];
    LPBYTE pbScan;

    //
    // pack the certificate data into a byte blob excluding the signature info.
    //

    dwLen =
        3 * sizeof(DWORD) +
        2 * sizeof(WORD) +
        pServerCert->PublicKeyData.wBlobLen;

    //
    // allocated space for the binary blob.
    //

    pbSignature = malloc( (UINT)dwLen );

    if( pbSignature == NULL ) {
        return( FALSE );
    }

    pbScan = pbSignature;

    memcpy( pbScan, &pServerCert->dwVersion, sizeof(DWORD));
    pbScan += sizeof(DWORD);

    memcpy( pbScan, &pServerCert->dwSigAlgID, sizeof(DWORD));
    pbScan += sizeof(DWORD);

    memcpy( pbScan, &pServerCert->dwKeyAlgID, sizeof(DWORD));
    pbScan += sizeof(DWORD);

    memcpy( pbScan, &pServerCert->PublicKeyData.wBlobType, sizeof(WORD));
    pbScan += sizeof(WORD);

    memcpy( pbScan, &pServerCert->PublicKeyData.wBlobLen, sizeof(WORD));
    pbScan += sizeof(WORD);

    memcpy(
        pbScan,
        pServerCert->PublicKeyData.pBlob,
        pServerCert->PublicKeyData.wBlobLen);

    //
    // generate the hash on the data.
    //

    MD5Init( &HashState );
    MD5Update( &HashState, pbSignature, dwLen );
    MD5Final( &HashState );

    //
    // free the signature blob, we don't need it anymore.
    //

    free( pbSignature );

    //
    // initialize the pulic key.
    //

    g_pPublicKey = (LPBSAFE_PUB_KEY)g_abPublicKeyModulus;

    g_pPublicKey->magic = RSA1;
    g_pPublicKey->keylen = 0x48;
    g_pPublicKey->bitlen = 0x0200;
    g_pPublicKey->datalen = 0x3f;
    g_pPublicKey->pubexp = 0xc0887b5b;

    //
    // decrypt the signature.
    //

    memset(SignHash, 0x00, 0x48);
    BSafeEncPublic( g_pPublicKey, pServerCert->SignatureBlob.pBlob, SignHash);

    //
    // compare the hash value.
    //

    if( memcmp( SignHash, HashState.digest, 16 )) {
        return( FALSE );
    }

    //
    // successfully validated the signature.
    //

    return( TRUE );
}


BOOL
EncryptClientRandom(
    LPBYTE pbSrvPublicKey,
    DWORD dwSrvPublicKey,
    LPBYTE pbRandomKey,
    DWORD dwRandomKeyLen,
    LPBYTE pbEncRandomKey,
    LPDWORD pdwEncRandomKey
    )
/*++

Routine Description:

    Encrypt the client random using server's public key.

Arguments:

    pbSrvPublicKey - pointer to the server public key.

    dwSrvPublicKey - length of the server public key.

    pbRandomKey - pointer to a buffer where the client random key.

    dwRandomKeyLen - length of the random key passed in.

    pbEncRandomKey - pointer to a buffer where the encrypted client random is
        returned.

    pdwEncRandomKey - pointer to a place where the length of the above buffer is
        passed in and length of the buffer used/required is returned. 
        In case the function fails for other reasons then insufficient buffer 
        the value of *pdwEncRandomKey is 0.
        
Return Value:

    TRUE - if the key is encrypted successfully.
    FALSE - otherwise.

--*/
{
    LPBSAFE_PUB_KEY pSrvPublicKey;
    BYTE abInputBuffer[512];

    ASSERT( pbSrvPublicKey != NULL );
    pSrvPublicKey = (LPBSAFE_PUB_KEY)pbSrvPublicKey;

    //
    // check to see buffer length pointer is valid.
    //
    
    if( pdwEncRandomKey == NULL ) {
        return( FALSE );
    }

    // 
    //    First we have to check that the keylen makes sense. If it is bigger
    //    then the abInputBuffer we can't use it. So it does not make sense for 
    //    the caller to allocate it. Also if a bad server gives us a big number
    //    in keylen we will just fail the call and not tell the caller to allocate
    //    the buffer and call us back with a buffer we can't use anyway.
    //
    if ((NULL == pSrvPublicKey) ||
        (pSrvPublicKey->datalen >= pSrvPublicKey->keylen) || 
        (pSrvPublicKey->keylen > sizeof(abInputBuffer))) {
        *pdwEncRandomKey = 0;
        return( FALSE );
    }
    

    //
    // check to see a output buffer is specified and
    // the encrypt buffer length is sufficient.
    //

    if( (pbEncRandomKey == NULL) ||
        (*pdwEncRandomKey < pSrvPublicKey->keylen) ) {

        *pdwEncRandomKey = pSrvPublicKey->keylen;
        return( FALSE );
    }

    //    Check if the pbRandomKey and dwRandomKeyLen are valid.
    //    We did not do this in the beginning because we should 
    //    be able to query the needed buffer length by passing 
    //    in just the pSrvPublicKey pointer and the pdwEncRandomKey.
    if ((NULL == pbRandomKey) ||
        (dwRandomKeyLen > pSrvPublicKey->datalen)) {
        *pdwEncRandomKey = 0;
        return( FALSE );
    }

    //
    // init the input buffer.
    //

    memset( abInputBuffer, 0x0, (UINT)pSrvPublicKey->keylen );

    //
    // copy data to be encrypted in the input buffer.
    //

    memcpy( abInputBuffer, pbRandomKey, (UINT)dwRandomKeyLen );

    //
    // initialize the output buffer.
    //

    memset( pbEncRandomKey, 0x0, (UINT)pSrvPublicKey->keylen );

    //
    // encrypt data now.
    //

    if( !BSafeEncPublic(
            pSrvPublicKey,
            (LPBYTE)abInputBuffer,
            pbEncRandomKey ) ) {

        *pdwEncRandomKey = 0;
        return( FALSE );
    }

    //
    // successfully encrypted the client random,
    // return the encrypted data length.
    //

    *pdwEncRandomKey = pSrvPublicKey->keylen;
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\tssec\glodata.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    glodata.c

Abstract:

    Global data definitions for tshare security.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include <seccom.h>

//
// global data definitions.
//

const BYTE g_abPad1[40] = {
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36
};

const BYTE g_abPad2[48] = {
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C
};

LPBSAFE_PUB_KEY g_pPublicKey;

BYTE g_abPublicKeyModulus[] = HYDRA_ROOT_PUBLIC_KEY;
BOOL g_128bitEncryptionEnabled = TRUE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\tssec\hydrakey.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows Terminal Server
//  Copyright (C) Microsoft Corporation, 1989-1998.
//
//  File:       HydraKey.h
//
//  Contents:   Hydra Server "Root" Public Key
//
//--------------------------------------------------------------------

#ifndef __HYDRAKEY__
#define __HYDRAKEY__

//
// This is the public key used to verify a
// hydra server's certificate
//
#define HYDRA_ROOT_PUBLIC_KEY \
     {                                                      \
     0x00, 0x00, 0x00, 0x00,                                \
     0x00, 0x00, 0x00, 0x00,                                \
     0x00, 0x00, 0x00, 0x00,                                \
     0x00, 0x00, 0x00, 0x00,                                \
     0x00, 0x00, 0x00, 0x00,                                \
     0x3d, 0x3a, 0x5e, 0xbd, 0x72, 0x43, 0x3e, 0xc9,        \
     0x4d, 0xbb, 0xc1, 0x1e, 0x4a, 0xba, 0x5f, 0xcb,        \
     0x3e, 0x88, 0x20, 0x87, 0xef, 0xf5, 0xc1, 0xe2,        \
     0xd7, 0xb7, 0x6b, 0x9a, 0xf2, 0x52, 0x45, 0x95,        \
     0xce, 0x63, 0x65, 0x6b, 0x58, 0x3a, 0xfe, 0xef,        \
     0x7c, 0xe7, 0xbf, 0xfe, 0x3d, 0xf6, 0x5c, 0x7d,        \
     0x6c, 0x5e, 0x06, 0x09, 0x1a, 0xf5, 0x61, 0xbb,        \
     0x20, 0x93, 0x09, 0x5f, 0x05, 0x6d, 0xea, 0x87,        \
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00         \
     }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\tssec\seccom.h ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    seccom.h

Abstract:

    Common include file for tshare security security module.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _SECCOM_H_
#define _SECCOM_H_

#include <windows.h>
#include <tchar.h>

#include <license.h>
#include <tssec.h>
#include <hydrakey.h>

#include <sha.h>
#include <md5.h>
#include <rsa.h>

#include <secdbg.h>
#include <global.h>

#endif // _SECCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\tssec\tssec.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    core.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Jan. 14th 1998.

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES = $(C_DEFINES) -DMSWIN16

#
# List of sources
#

SOURCES_PLATFORM =

CLIENT_SOURCES_RC = \

CLIENT_SOURCES_COMMON = \
    ..\clicert.c \
    ..\encrypt.c \
    ..\fencrypt.c \
    ..\local.c \
    ..\genrand.c \
    ..\glodata.c \
    ..\sesskey.c \

CLIENT_SOURCES_LAST  = \

SOURCES = \
    $(CLIENT_SOURCES_RC) \
    $(SOURCES_PLATFORM) \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_LAST)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\tssec\secdbg.h ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    secdbg.h

Abstract:

    Debug macro definition file.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _SECDBG_H_
#define _SECDBG_H_

//
// assert macros.
//

NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    DWORD LineNumber,
    PCHAR Message
    );

#define RTLASSERT( msg, exp)
//        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define RTLASSERTMSG( msg, exp)
//        RtlAssert( #exp, __FILE__, __LINE__, msg )


#ifdef ASSERT
#undef ASSERT
#endif // ASSERT
#ifdef ASSERTMSG
#undef ASSERTMSG
#endif // ASSERTMSG

#if DBG

#define ASSERT( exp ) \
    if (!(exp)) { \
        RTLASSERT( msg, exp); \
    } \

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) { \
        RTLASSERT( msg, exp); \
    } \

#else

#define ASSERT( exp )
#define ASSERTMSG( msg, exp )

#endif // DBG

#endif // _SECDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\tssec\sesskey.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    sesskey.c

Abstract:

    Contains common client/server code that generate session key.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include <seccom.h>

VOID
Salt8ByteKey(
    LPBYTE pbKey,
    DWORD dwSaltBytes
    )
/*++

Routine Description:

    This macro function salts the first 1 or 3 bytes of the 8 bytes key to a
    known value in order to make it a 40-bit key.

Arguments:

    pbKey - pointer to a 8 bytes key buffer.
    dwSaltBytes - this value should be either 1 or 3

Return Value:

    None.

--*/
{
    ASSERT( (dwSaltBytes == 1) || (dwSaltBytes == 3) );

    if( dwSaltBytes == 1 ) {

        //
        // for 56-bit encryption, salt first byte only.
        //

        *pbKey++ = 0xD1 ;
    }
    else if (dwSaltBytes == 3) {

        //
        // for 40-bit encryption, salt first 3 bytes.
        //

        *pbKey++ = 0xD1 ;
        *pbKey++ = 0x26 ;
        *pbKey  = 0x9E ;
    }

    return;
}

VOID
FinalHash(
    LPRANDOM_KEYS_PAIR pKeyPair,
    LPBYTE pbKey
    )
/*++

Routine Description:

    This macro function hashes the final key with the client and server randoms.

Arguments:

    pKeyPair - pointer a random key pair structure.

    pbKey - pointer to a key buffer, the final key is returned back in the same
        buffer.

Return Value:

    None.

--*/
{
    MD5_CTX Md5Hash;

    //
    // final_key = MD5(key + clientRandom + serverRandom)
    //

    MD5Init  (&Md5Hash);

    MD5Update(&Md5Hash, pbKey, MAX_SESSION_KEY_SIZE);
    MD5Update(&Md5Hash, pKeyPair->clientRandom, RANDOM_KEY_LENGTH);
    MD5Update(&Md5Hash, pKeyPair->serverRandom, RANDOM_KEY_LENGTH);
    MD5Final (&Md5Hash);

    //
    // copy the final key back to the input buffer.
    //

    ASSERT( MD5DIGESTLEN >= MAX_SESSION_KEY_SIZE );
    memcpy(pbKey, Md5Hash.digest, MAX_SESSION_KEY_SIZE);

    return;
}

VOID
MakeMasterKey(
    LPRANDOM_KEYS_PAIR pKeyPair,
    LPSTR FAR *ppszSalts,
    LPBYTE pbPreMaster,
    LPBYTE pbMaster
    )
/*++

Routine Description:

    This macro function makes a master secret using a pre-master secret.

Arguments:

    pKeyPair - pointer a key pair structure.

    ppszSalts - pointer to a salt key strings array.

    pbPreMaster - pointer to a pre-master secret key buffer.

    pbMaster - pointer to a master secret key buffer.

Return Value:

    None.

--*/
{
    DWORD i;

    MD5_CTX Md5Hash;
    A_SHA_CTX ShaHash;
    BYTE bShaHashValue[A_SHA_DIGEST_LEN];

    //
    //initialize all buffers with zero
    //

    memset( pbMaster, 0, PRE_MASTER_SECRET_LEN);
    memset( bShaHashValue, 0, A_SHA_DIGEST_LEN);

    for ( i = 0 ; i < 3 ; i++) {

        //
        // SHA(ppszSalts[i] + pre-master + clientRandom +  serverRandom)
        //

        A_SHAInit(&ShaHash);
        A_SHAUpdate(&ShaHash, ppszSalts[i], strlen(ppszSalts[i]));
        A_SHAUpdate(&ShaHash, pbPreMaster, PRE_MASTER_SECRET_LEN );
        A_SHAUpdate(
            &ShaHash,
            pKeyPair->clientRandom,
            sizeof(pKeyPair->clientRandom) );
        A_SHAUpdate(
            &ShaHash,
            pKeyPair->serverRandom,
            sizeof(pKeyPair->serverRandom) );
        A_SHAFinal(&ShaHash, bShaHashValue);

        //
        // MD5(pre_master + SHA-hash)
        //

        MD5Init(&Md5Hash);
        MD5Update(&Md5Hash, pbPreMaster, PRE_MASTER_SECRET_LEN );
        MD5Update(&Md5Hash, bShaHashValue, A_SHA_DIGEST_LEN);
        MD5Final(&Md5Hash);

        //
        // copy part of the master secret.
        //

        memcpy(
            pbMaster + (i * MD5DIGESTLEN),
            Md5Hash.digest,
            MD5DIGESTLEN);
    }

    return;
}

VOID
MakePreMasterSecret(
    LPRANDOM_KEYS_PAIR pKeyPair,
    LPBYTE pbPreMasterSecret
    )
/*++

Routine Description:

    This function makes a pre-master secret for the initial session key.

Arguments:

    pKeyPair - pointer a key pair structure.

    pbPreMasterSecret - pointer to a pre-master secret key buffer, it is
        PRE_MASTER_SECRET_LEN bytes long.

Return Value:

    None.

--*/
{
    //
    // copy PRE_MASTER_SECRET_LEN/2 bytes from clientRandom first.
    //

    memcpy(
        pbPreMasterSecret,
        pKeyPair->clientRandom,
        PRE_MASTER_SECRET_LEN/2 );

    //
    // copy PRE_MASTER_SECRET_LEN/2 bytes from serverRandom next.
    //

    memcpy(
        pbPreMasterSecret + PRE_MASTER_SECRET_LEN/2,
        pKeyPair->serverRandom,
        PRE_MASTER_SECRET_LEN/2 );

    return;
}

VOID
GenerateMasterSecret(
    LPRANDOM_KEYS_PAIR pKeyPair,
    LPBYTE pbPreMasterSecret
    )
/*++

Routine Description:

    This function creates a master secret key using the pre-master key and
    random key pair.

Arguments:

    pKeyPair - pointer a key pair structure.

    pbPreMasterSecret - pointer to a pre-master secret key buffer, it is
        PRE_MASTER_SECRET_LEN bytes long.


Return Value:

    None.

--*/
{
    BYTE abMasterSecret[PRE_MASTER_SECRET_LEN];
    LPSTR apszSalts[3] = { "A","BB","CCC" } ;

    ASSERT( PRE_MASTER_SECRET_LEN == 3 * MD5DIGESTLEN );

    //
    // make master secret.
    //

    MakeMasterKey(
        pKeyPair,
        (LPSTR FAR *)apszSalts,
        pbPreMasterSecret,
        (LPBYTE)abMasterSecret );

    //
    // copy master secret in the return buffer.
    //

    memcpy( pbPreMasterSecret, abMasterSecret, PRE_MASTER_SECRET_LEN);

    return;
}

VOID
UpdateKey(
    LPBYTE pbStartKey,
    LPBYTE pbCurrentKey,
    DWORD dwKeyLength
    )
/*++

Routine Description:

    This function updates a key.

Arguments:

    pbStartKey - pointer to the start session key buffer.

    pbCurrentKey - pointer to the current session key buffer, new session key is
        copied to this buffer on return.

    dwKeyLength - length of the key.

Return Value:

    None.

--*/
{
    A_SHA_CTX       SHAHash;
    MD5_CTX         MD5Hash;
    BYTE            abSHADigest[A_SHA_DIGEST_LEN];

    //
    // make a SHA(pbStartKey + g_abPad1 + pbCurrentKey) hash.
    //

    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, pbStartKey, dwKeyLength);
    A_SHAUpdate(&SHAHash, (unsigned char *)g_abPad1, 40);
    A_SHAUpdate(&SHAHash, pbCurrentKey, dwKeyLength);
    A_SHAFinal(&SHAHash, abSHADigest);

    //
    // make a MD5(pbStartKey + g_abPad2 + SHAHash) hash.
    //

    MD5Init(&MD5Hash);
    MD5Update(&MD5Hash, pbStartKey, dwKeyLength);
    MD5Update(&MD5Hash, g_abPad2, 48);
    MD5Update(&MD5Hash, abSHADigest, A_SHA_DIGEST_LEN);
    MD5Final(&MD5Hash);

    ASSERT( dwKeyLength <= MD5DIGESTLEN );
    memcpy(pbCurrentKey, MD5Hash.digest, (UINT)dwKeyLength);

    return;
}

BOOL
MakeSessionKeys(
    LPRANDOM_KEYS_PAIR pKeyPair,
    LPBYTE pbEncryptKey,
    struct RC4_KEYSTRUCT FAR *prc4EncryptKey,
    LPBYTE pbDecryptKey,
    struct RC4_KEYSTRUCT FAR *prc4DecryptKey,
    LPBYTE pbMACSaltKey,
    DWORD dwKeyStrength,
    LPDWORD pdwKeyLength,
    DWORD dwEncryptionLevel
    )
/*++

Routine Description:

    Make the server session key using the client and server random keys.

    Assume : the encrypt and decrypt buffer presented are
        atleast MAX_SESSION_KEY_SIZE (16) bytes long.

Arguments:

    pKeyPair - pointer a key pair structure.

    pbEncryptKey - pointer to a buffer where the encryption key is stored.

    prc4EncryptKey - pointer to a RC4 encrypt key structure.

    pbDecryptKey - pointer to a buffer where the decryption key is stored.

    prc4DecryptKey - pointer to a RC4 decrypt key structure.

    pbMACSaltKey - pointer to a buffer where the message authentication key is
        stored.

    dwKeyStrength - specify key strength to use.

    pdwKeyLength - pointer to a location where the length of the above
        encryption/decryption key is returned.

    dwEncryptionLevel - encryption level, used to select the encryption
        algorithm.

Return Value:

    TRUE - if successfully created the session key.

    FALSE - otherwise.

--*/
{
    BYTE abPreMasterSecret[PRE_MASTER_SECRET_LEN];
    BYTE abMasterSessionKey[PRE_MASTER_SECRET_LEN];
    LPSTR apszSalts[3] = { "X","YY","ZZZ" } ;
    DWORD dwSaltLen;

    //
    // make a pre-master secret.
    //

    MakePreMasterSecret( pKeyPair, (LPBYTE)abPreMasterSecret );

    //
    // generate master secret.
    //

    GenerateMasterSecret( pKeyPair, (LPBYTE)abPreMasterSecret );

    //
    // make a master session key for all three session keys (encrypt, decrypt
    // and MACSalt).
    //

    MakeMasterKey(
        pKeyPair,
        (LPSTR FAR *)apszSalts,
        (LPBYTE)abPreMasterSecret,
        (LPBYTE)abMasterSessionKey );

    ASSERT( PRE_MASTER_SECRET_LEN == 3 * MAX_SESSION_KEY_SIZE );

    //
    // copy first part of the master key as MAC salt key.
    //

    memcpy(
        pbMACSaltKey,
        (LPBYTE)abMasterSessionKey,
        MAX_SESSION_KEY_SIZE );

    //
    // copy second part of the master key as encrypt key and final hash it.
    //

    memcpy(
        pbEncryptKey,
        (LPBYTE)abMasterSessionKey + MAX_SESSION_KEY_SIZE,
        MAX_SESSION_KEY_SIZE );

    FinalHash( pKeyPair, pbEncryptKey );

    //
    // copy second part of the master key as decrypt key and final hash it.
    //

    memcpy(
        pbDecryptKey,
        (LPBYTE)abMasterSessionKey + MAX_SESSION_KEY_SIZE * 2,
        MAX_SESSION_KEY_SIZE );

    FinalHash( pKeyPair, pbDecryptKey );


    //
    // finally select the key length.
    //

    ASSERT( MAX_SESSION_KEY_SIZE == 16 );

    dwSaltLen = 0;
    switch ( dwKeyStrength ) {

        case SM_40BIT_ENCRYPTION_FLAG:
            *pdwKeyLength = MAX_SESSION_KEY_SIZE/2;
            dwSaltLen = 3;
            break;

        case SM_56BIT_ENCRYPTION_FLAG:
            *pdwKeyLength = MAX_SESSION_KEY_SIZE/2;
            dwSaltLen = 1;
            break;

        case SM_128BIT_ENCRYPTION_FLAG:
            ASSERT( g_128bitEncryptionEnabled );
            *pdwKeyLength = MAX_SESSION_KEY_SIZE;
            break;

        default:

            //
            // we shouldn't reach here.
            //

            ASSERT( FALSE );
            *pdwKeyLength = MAX_SESSION_KEY_SIZE/2;
            dwSaltLen = 1;
            break;
    }

    if( dwSaltLen ) {

        Salt8ByteKey( pbMACSaltKey, dwSaltLen );
        Salt8ByteKey( pbEncryptKey, dwSaltLen );
        Salt8ByteKey( pbDecryptKey, dwSaltLen );
    }

    //
    // finally make rc4 keys.
    //
    // use microsoft version of rc4 algorithm (super fast!) for level 1 and
    // level 2 encryption, for level 3 use RSA rc4 algorithm.
    //

    if( dwEncryptionLevel <= 2 ) {
        msrc4_key( prc4EncryptKey, (UINT)*pdwKeyLength, pbEncryptKey );
        msrc4_key( prc4DecryptKey, (UINT)*pdwKeyLength, pbDecryptKey );
    }
    else {
        rc4_key( prc4EncryptKey, (UINT)*pdwKeyLength, pbEncryptKey );
        rc4_key( prc4DecryptKey, (UINT)*pdwKeyLength, pbDecryptKey );
    }

    return( TRUE );
}

BOOL
UpdateSessionKey(
    LPBYTE pbStartKey,
    LPBYTE pbCurrentKey,
    DWORD dwKeyStrength,
    DWORD dwKeyLength,
    struct RC4_KEYSTRUCT FAR *prc4Key,
    DWORD dwEncryptionLevel
    )
/*++

Routine Description:

    Update the session key using the current and start session keys.

Arguments:

    pbStartKey - pointer to the start session key buffer.

    pbCurrentKey - pointer to the current session key buffer, new session key is
        copied to this buffer on return.

    dwKeyStrength - specify key strength to use.

    dwKeyLength - length of the key.

    prc4Key - pointer to a RC4 key structure.

    dwEncryptionLevel - encryption level, used to select the encryption
        algorithm.

Return Value:

    TRUE - if the successfully update the key.

    FALSE - otherwise.

--*/
{
    DWORD dwSaltLen;

    //
    // update current key first.
    //

    UpdateKey( pbStartKey, pbCurrentKey, dwKeyLength );

    //
    // use microsoft version of rc4 algorithm (super fast!) for level 1 and
    // level 2 encryption, for level 3 use RSA rc4 algorithm.
    //

    if( dwEncryptionLevel <= 2 ) {

        //
        // re-initialized RC4 table.
        //

        msrc4_key( prc4Key, (UINT)dwKeyLength, pbCurrentKey );

        //
        // scramble the current key.
        //

        msrc4( prc4Key, (UINT)dwKeyLength, pbCurrentKey );
    }
    else {

        //
        // re-initialized RC4 table.
        //

        rc4_key( prc4Key, (UINT)dwKeyLength, pbCurrentKey );

        //
        // scramble the current key.
        //

        rc4( prc4Key, (UINT)dwKeyLength, pbCurrentKey );
    }

    //
    // salt the key appropriately.
    //

    dwSaltLen = 0;
    switch ( dwKeyStrength ) {

        case SM_40BIT_ENCRYPTION_FLAG:
            ASSERT( dwKeyLength = MAX_SESSION_KEY_SIZE/2 );
            dwSaltLen = 3;
            break;

        case SM_56BIT_ENCRYPTION_FLAG:
            ASSERT( dwKeyLength = MAX_SESSION_KEY_SIZE/2 );
            dwSaltLen = 1;
            break;

        case SM_128BIT_ENCRYPTION_FLAG:
            ASSERT( g_128bitEncryptionEnabled );
            ASSERT( dwKeyLength = MAX_SESSION_KEY_SIZE );
            break;

        default:

            //
            // we shouldn't reach here.
            //

            ASSERT( FALSE );
            ASSERT( dwKeyLength = MAX_SESSION_KEY_SIZE/2 );
            dwSaltLen = 1;
            break;
    }

    if( dwSaltLen ) {
        Salt8ByteKey( pbCurrentKey, dwSaltLen );
    }

    //
    // re-initialized RC4 table again.
    //

    if( dwEncryptionLevel <= 2 ) {

        msrc4_key( prc4Key, (UINT)dwKeyLength, pbCurrentKey );
    }
    else {

        rc4_key( prc4Key, (UINT)dwKeyLength, pbCurrentKey );
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\tssec\local.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    local.c

Abstract:

    Contains functions that encrypt and decrypt data to be stored locally

Author:

    Adam Overton (adamo)  08-Feb-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include <seccom.h>
#include <tchar.h>
#include <extypes.h>

#include <license.h>
#include <cryptkey.h>

#if defined(OS_WINCE)
BOOL GetUserName(
  LPTSTR lpBuffer,  // address of name buffer
  LPDWORD pdwSize    // address of size of name buffer
)
/*++

Routine Description:

    Provides the GetUserName API on platforms that don't have it

Arguments:

    lpBuffer - pointer to a buffer for the username
    nSize - size of name buffer

Return Value:

    TRUE - successfully retrieved UserName

    FALSE - otherwise

--*/
{
    DWORD dwT;

    memset(lpBuffer, 0, *pdwSize);

    //
    // There doesn't appear to be user name available, just
    // use a default and rely on the machine UUID for security
    //

    dwT = *pdwSize;
#define USER_RANDOM "eefdbcf0001255b4009c9e1800f73774"
    if (dwT > sizeof(USER_RANDOM))
        dwT = sizeof(USER_RANDOM);
    memcpy(lpBuffer, USER_RANDOM, (size_t)dwT);
    return TRUE;
}
#endif // defined(OS_WINCE)


BOOL GetLocalKey(
    struct RC4_KEYSTRUCT *prc4Key
    )
/*++

Routine Description:

    This function creates and caches a rc4 key which can be used to store
    private information locally

Arguments:

    prc4Key - pointer to a buffer to hold the RC4 key

Return Value:

    TRUE - successfully generated key

    FALSE - otherwise

--*/
{
    A_SHA_CTX       SHAHash;
    BYTE            abSHADigest[A_SHA_DIGEST_LEN];
    static BOOL fCreatedKey = FALSE;
    static struct RC4_KEYSTRUCT rc4Key;
    TCHAR   szUserName[SEC_MAX_USERNAME];
    DWORD   dwSize;
    HWID    hwid;

    if (!fCreatedKey) {
        A_SHAInit(&SHAHash);

        //
        // Get the user name
        //

        dwSize = (DWORD)sizeof(szUserName);
        memset(szUserName, 0, (size_t)dwSize);
        if (!GetUserName(szUserName, &dwSize))
            return FALSE;

        A_SHAUpdate(&SHAHash, (unsigned char *)szUserName, dwSize);

        //
        // Get unique machine identifier
        //

        if (LICENSE_STATUS_OK == GenerateClientHWID(&hwid)) {
            A_SHAUpdate(&SHAHash, (unsigned char *)&hwid, sizeof(HWID));
        }

        //
        // Update the Hash with something less guessable
        // but known to our apps
        //

#define RANDOM_CONSTANT "deed047e-a3cb-11d1-b96c-00c04fb15601"
        A_SHAUpdate(&SHAHash, RANDOM_CONSTANT, sizeof(RANDOM_CONSTANT));

        //
        // Finalize the hash
        //

        A_SHAFinal(&SHAHash, abSHADigest);

        //
        // Generate a key based on this hash
        //

        msrc4_key(&rc4Key, (UINT)MAX_SESSION_KEY_SIZE, abSHADigest);

        fCreatedKey = TRUE;
    }

    memcpy(prc4Key, &rc4Key, sizeof(rc4Key));

    return TRUE;
}

BOOL GetLocalKey50(
    struct RC4_KEYSTRUCT *prc4Key,
    LPBYTE pbSalt,
    DWORD dwSaltLength
    )
/*++

Routine Description:

    This function creates and caches a rc4 key which can be used to store
    private information locally

Arguments:

    prc4Key - pointer to a buffer to hold the RC4 key

Return Value:

    TRUE - successfully generated key

    FALSE - otherwise

--*/
{
    A_SHA_CTX       SHAHash;
    BYTE            abSHADigest[A_SHA_DIGEST_LEN];
    struct RC4_KEYSTRUCT rc4Key;
    TCHAR   szUserName[SEC_MAX_USERNAME];
    DWORD   dwSize;
    HWID    hwid;
    DWORD   dw;

    A_SHAInit(&SHAHash);

    //
    // Get the user name
    //

    dwSize = (DWORD)sizeof(szUserName);
    memset(szUserName, 0, (size_t)dwSize);
    if (!GetUserName(szUserName, &dwSize))
        return FALSE;

    A_SHAUpdate(&SHAHash, (unsigned char *)szUserName, dwSize);

    //
    // Get unique machine identifier
    //

    if (LICENSE_STATUS_OK == GenerateClientHWID(&hwid)) {
        A_SHAUpdate(&SHAHash, (unsigned char *)&hwid, sizeof(HWID));
    }

    //
    // Update the Hash with something less guessable
    // but known to our apps
    //

#define RANDOM_CONSTANT "deed047e-a3cb-11d1-b96c-00c04fb15601"
    A_SHAUpdate(&SHAHash, RANDOM_CONSTANT, sizeof(RANDOM_CONSTANT));

    //
    // Finalize the hash
    //

    A_SHAFinal(&SHAHash, abSHADigest);

    //
    // Add salt and stir gently
    //

    for (dw = 0; dw < 256; dw++) {
        A_SHAInit(&SHAHash);
        A_SHAUpdate(&SHAHash, pbSalt, dwSaltLength);
        A_SHAUpdate(&SHAHash, abSHADigest, A_SHA_DIGEST_LEN);
        A_SHAFinal(&SHAHash, abSHADigest);
    }

    //
    // Generate a key based on this hash
    //

    msrc4_key(&rc4Key, (UINT)MAX_SESSION_KEY_SIZE, abSHADigest);

    memcpy(prc4Key, &rc4Key, sizeof(rc4Key));

    return TRUE;
}

BOOL EncryptDecryptLocalData(
    LPBYTE pbData,
    DWORD dwDataLen
    )
/*++

Routine Description:

    This function encrypts/decrypts data to be stored locally, but usable
    only by the current user on the this machine

Arguments:

    pbData - pointer to a data buffer.

    dwDataLen - length of the above data.

Return Value:

    TRUE - successfully encrypted data

    FALSE - otherwise

--*/
{
    struct RC4_KEYSTRUCT rc4Key;

    if (!GetLocalKey(&rc4Key))
        return FALSE;

    msrc4(&rc4Key, (UINT)dwDataLen, pbData);

    return TRUE;
}

BOOL EncryptDecryptLocalData50(
    LPBYTE pbData,
    DWORD dwDataLen,
    LPBYTE pbSalt,
    DWORD dwSaltLen
    )
/*++

Routine Description:

    This function encrypts/decrypts data to be stored locally, but usable
    only by the current user on the this machine

Arguments:

    pbData - pointer to a data buffer.

    dwDataLen - length of the above data.

Return Value:

    TRUE - successfully encrypted data

    FALSE - otherwise

--*/
{
    struct RC4_KEYSTRUCT rc4Key;

    if (!GetLocalKey50(&rc4Key, pbSalt, dwSaltLen))
        return FALSE;

    msrc4(&rc4Key, (UINT)dwDataLen, pbData);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\uniwrap\cstrinout.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-2000
//
//  File:       cstrinout.h
//
//  Contents:   shell-wide string thunkers, for use by unicode wrappers
//
//----------------------------------------------------------------------------

#ifndef _CSTRINOUT_HXX_
#define _CSTRINOUT_HXX_

#include "uniansi.h"

#define CP_ATOM         0xFFFFFFFF          /* not a string at all */

//+---------------------------------------------------------------------------
//
//  Class:      CConvertStr (CStr)
//
//  Purpose:    Base class for conversion classes.
//
//----------------------------------------------------------------------------

class CConvertStr
{
public:
    operator char *();
    inline BOOL IsAtom() { return _uCP == CP_ATOM; }

protected:
    CConvertStr(UINT uCP);
    ~CConvertStr();
    void Free();

    UINT    _uCP;
    LPSTR   _pstr;
    char    _ach[MAX_PATH * sizeof(WCHAR)];
};



//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::CConvertStr
//
//  Synopsis:   ctor.
//
//----------------------------------------------------------------------------

inline
CConvertStr::CConvertStr(UINT uCP)
{
    _uCP = uCP;
    _pstr = NULL;
}



//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::~CConvertStr
//
//  Synopsis:   dtor.
//
//----------------------------------------------------------------------------

inline
CConvertStr::~CConvertStr()
{
    Free();
}





//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::operator char *
//
//  Synopsis:   Returns the string.
//
//----------------------------------------------------------------------------

inline
CConvertStr::operator char *()
{
    return _pstr;
}



//+---------------------------------------------------------------------------
//
//  Class:      CStrIn (CStrI)
//
//  Purpose:    Converts string function arguments which are passed into
//              a Windows API.
//
//----------------------------------------------------------------------------

class CStrIn : public CConvertStr
{
public:
    CStrIn(LPCWSTR pwstr);
    CStrIn(LPCWSTR pwstr, int cwch);
    CStrIn(UINT uCP, LPCWSTR pwstr);
    CStrIn(UINT uCP, LPCWSTR pwstr, int cwch);
    int strlen();

protected:
    CStrIn();
    void Init(LPCWSTR pwstr, int cwch);

    int _cchLen;
};




//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Inits the class with a given length
//
//----------------------------------------------------------------------------

inline
CStrIn::CStrIn(LPCWSTR pwstr, int cwch) : CConvertStr(CP_ACP)
{
    Init(pwstr, cwch);
}

inline
CStrIn::CStrIn(UINT uCP, LPCWSTR pwstr, int cwch) : CConvertStr(uCP)
{
    Init(pwstr, cwch);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Initialization for derived classes which call Init.
//
//----------------------------------------------------------------------------

inline
CStrIn::CStrIn() : CConvertStr(CP_ACP)
{
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::strlen
//
//  Synopsis:   Returns the length of the string in characters, excluding
//              the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrIn::strlen()
{
    return _cchLen;
}



//+---------------------------------------------------------------------------
//
//  Class:      CStrInMulti (CStrIM)
//
//  Purpose:    Converts multiple strings which are terminated by two NULLs,
//              e.g. "Foo\0Bar\0\0"
//
//----------------------------------------------------------------------------

class CStrInMulti : public CStrIn
{
public:
    CStrInMulti(LPCWSTR pwstr);
};


//+---------------------------------------------------------------------------
//
//  Class:      CPPFIn
//
//  Purpose:    Converts string function arguments which are passed into
//              a Win9x PrivateProfile API.  Win9x DBCS has a bug where
//              passing a string longer than MAX_PATH will fault kernel.
//
//              PPF = Private Profile Filename
//
//----------------------------------------------------------------------------

class CPPFIn
{
public:
    operator char *();
    CPPFIn(LPCWSTR pwstr);

private:
    char _ach[MAX_PATH];
};

//+---------------------------------------------------------------------------
//
//  Member:     CPPFIn::operator char *
//
//  Synopsis:   Returns the string.
//
//----------------------------------------------------------------------------

inline
CPPFIn::operator char *()
{
    return _ach;
}

//+---------------------------------------------------------------------------
//
//  Class:      CStrOut (CStrO)
//
//  Purpose:    Converts string function arguments which are passed out
//              from a Windows API.
//
//----------------------------------------------------------------------------

class CStrOut : public CConvertStr
{
public:
    CStrOut(LPWSTR pwstr, int cwchBuf);
    CStrOut(UINT uCP, LPWSTR pwstr, int cwchBuf);
    ~CStrOut();

    int     BufSize();
    int     ConvertIncludingNul();
    int     ConvertExcludingNul();
    int     CopyNoConvert(int srcBytes);
protected:
    void Init(LPWSTR pwstr, int cwchBuf);
private:
    LPWSTR  _pwstr;
    int     _cwchBuf;
};


//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::BufSize
//
//  Synopsis:   Returns the size of the buffer to receive an out argument,
//              including the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrOut::BufSize()
{
    return _cwchBuf * sizeof(WCHAR);
}

//
//	Multi-Byte ---> Unicode conversion
//

//+---------------------------------------------------------------------------
//
//  Class:      CConvertStrW (CStr)
//
//  Purpose:    Base class for multibyte conversion classes.
//
//----------------------------------------------------------------------------

class CConvertStrW
{
public:
    operator WCHAR *();

protected:
    CConvertStrW();
    ~CConvertStrW();
    void Free();

    LPWSTR   _pwstr;
    WCHAR    _awch[MAX_PATH * sizeof(WCHAR)];
};



//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::CConvertStrW
//
//  Synopsis:   ctor.
//
//----------------------------------------------------------------------------

inline
CConvertStrW::CConvertStrW()
{
    _pwstr = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::~CConvertStrW
//
//  Synopsis:   dtor.
//
//----------------------------------------------------------------------------

inline
CConvertStrW::~CConvertStrW()
{
    Free();
}

//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::operator WCHAR *
//
//  Synopsis:   Returns the string.
//
//----------------------------------------------------------------------------

inline 
CConvertStrW::operator WCHAR *()
{
    return _pwstr;
}


//+---------------------------------------------------------------------------
//
//  Class:      CStrInW (CStrI)
//
//  Purpose:    Converts multibyte strings into UNICODE
//
//----------------------------------------------------------------------------

class CStrInW : public CConvertStrW
{
public:
    CStrInW(LPCSTR pstr) { Init(pstr, -1); }
    CStrInW(LPCSTR pstr, int cch) { Init(pstr, cch); }
    int strlen();

protected:
    CStrInW();
    void Init(LPCSTR pstr, int cch);

    int _cwchLen;
};

//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::CStrInW
//
//  Synopsis:   Initialization for derived classes which call Init.
//
//----------------------------------------------------------------------------

inline
CStrInW::CStrInW()
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::strlen
//
//  Synopsis:   Returns the length of the string in characters, excluding
//              the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrInW::strlen()
{
    return _cwchLen;
}

//+---------------------------------------------------------------------------
//
//  Class:      CStrOutW (CStrO)
//
//  Purpose:    Converts returned unicode strings into ANSI.  Used for [out]
//              params (so we initialize with a buffer that should later be
//              filled with the correct ansi data)
//
//
//----------------------------------------------------------------------------

class CStrOutW : public CConvertStrW
{
public:
    CStrOutW(LPSTR pstr, int cchBuf);
    ~CStrOutW();

    int     BufSize();
    int     ConvertIncludingNul();
    int     ConvertExcludingNul();

private:
    LPSTR  	_pstr;
    int     _cchBuf;
};

//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::BufSize
//
//  Synopsis:   Returns the size of the buffer to receive an out argument,
//              including the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrOutW::BufSize()
{
    return _cchBuf;
}

//+---------------------------------------------------------------------------
//
//  Class:      CWin32FindDataInOut
//
//  Purpose:    Converts WIN32_FIND_DATA structures from UNICODE to ANSI
//              on the way in, then ANSI to UNICODE on the way out.
//
//----------------------------------------------------------------------------

class CWin32FindDataInOut
{
public:
    operator LPWIN32_FIND_DATAA();
    CWin32FindDataInOut(LPWIN32_FIND_DATAW pfdW);
    ~CWin32FindDataInOut();

protected:
    LPWIN32_FIND_DATAW _pfdW;
    WIN32_FIND_DATAA _fdA;
};

//+---------------------------------------------------------------------------
//
//  Member:     CWin32FindDataInOut::CWin32FindDataInOut
//
//  Synopsis:   Convert the non-string fields to ANSI.  You'd think this
//              isn't necessary, but it is, because Win95 puts secret
//              goo into the dwReserved fields that must be preserved.
//
//----------------------------------------------------------------------------

inline
CWin32FindDataInOut::CWin32FindDataInOut(LPWIN32_FIND_DATAW pfdW) :
    _pfdW(pfdW)
{
    memcpy(&_fdA, _pfdW, FIELD_OFFSET(WIN32_FIND_DATA, cFileName));

    _fdA.cFileName[0]          = '\0';
    _fdA.cAlternateFileName[0] = '\0';
}

//+---------------------------------------------------------------------------
//
//  Member:     CWin32FindDataInOut::~CWin32FindDataInOut
//
//  Synopsis:   Convert all the fields from ANSI back to UNICODE.
//
//----------------------------------------------------------------------------

inline
CWin32FindDataInOut::~CWin32FindDataInOut()
{
    memcpy(_pfdW, &_fdA, FIELD_OFFSET(WIN32_FIND_DATA, cFileName));

    SHAnsiToUnicode(_fdA.cFileName, _pfdW->cFileName, ARRAYSIZE(_pfdW->cFileName));
    SHAnsiToUnicode(_fdA.cAlternateFileName, _pfdW->cAlternateFileName, ARRAYSIZE(_pfdW->cAlternateFileName));
}

//+---------------------------------------------------------------------------
//
//  Member:     CWin32FindDataInOut::operator LPWIN32_FIND_DATAA
//
//  Synopsis:   Returns the WIN32_FIND_DATAA.
//
//----------------------------------------------------------------------------

inline
CWin32FindDataInOut::operator LPWIN32_FIND_DATAA()
{
    return &_fdA;
}


#endif // _CSTRINOUT_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\uniwrap\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\uniwrap\stdafx.h ===
// stdafx.h : source file that includes just the standard includes

#ifndef _stdafx_h_
#define _stdafx_h_

// Windows Header Files:
#include <windows.h>

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include "shellapi.h" //for ExtractIcon
#include "shlwapi.h"
#include "commdlg.h"
#include "ddeml.h"
#include "winspool.h"

#include "wraputl.h"

#ifdef DBG
//Be careful to use ANSI only APIs for ASSERT
//It would be silly to recursively assert in a wrapped function
//E.g if we used the Wrapped MessageBox and that had an assert...
#define ASSERT( expr ) \
    if( !( expr ) ) \
    { \
       char tchAssertErr[ 80 ]; \
       wsprintfA( tchAssertErr , \
       "UNIWRAP ASSERT in expression ( %s )\nFile - %s\nLine - %d\n Debug?", \
        #expr , (__FILE__) , __LINE__ ); \
       if( MessageBoxA( NULL , tchAssertErr , "ASSERTION FAILURE" , \
           MB_YESNO | MB_ICONERROR )  == IDYES ) \
       {\
            DebugBreak( );\
       }\
    }
#else
#define ASSERT(x) ((void)0)
#endif


#endif //_stdafx_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\uniwrap\prnwrap.cpp ===
//
// prnwrap.cpp
//
// Unicode printer function wrappers
//
// Copyright(C) Microsoft Corporation 2000
//
// Nadim Abdo (nadima)
//

#include "stdafx.h"

#include "uniwrap.h"
#include "cstrinout.h"

//Just include wrap function prototypes
//no wrappers (it would be silly to wrap wrappers)
#define DONOT_REPLACE_WITH_WRAPPERS
#include "uwrap.h"


//
// Printer wrappers.
//

BOOL
WINAPI
EnumPrintersWrapW(
    IN DWORD   Flags,
    IN LPWSTR Name,
    IN DWORD   Level,
    OUT LPBYTE  pPrinterEnum,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned)
{
    BOOL fRet;

    if (g_bRunningOnNT)
    {
        return EnumPrintersW(Flags, Name, Level,
                             pPrinterEnum, cbBuf,
                             pcbNeeded, pcReturned);
    }
    else
    {
        ASSERT(Level == 2); //only supported level
        if(2 == Level)
        {
            CStrIn strName(Name);

            LPBYTE pPrinterEnumA = NULL;
            if(pPrinterEnum && cbBuf)
            {
                pPrinterEnumA = (LPBYTE)LocalAlloc( LPTR, cbBuf );
                if(!pPrinterEnumA)
                {
                    return FALSE;
                }
            }
    
            fRet = EnumPrintersA(Flags,
                                 strName,
                                 Level,
                                 pPrinterEnumA,
                                 cbBuf,
                                 pcbNeeded,
                                 pcReturned);

            if(fRet || (!fRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER))
            {
                if(!pPrinterEnumA)
                {
                    //
                    // This is a size query double the requested space 
                    // so the caller allocates a buffer with enough space
                    // for UNICODE converted sub strings.
                    //
                    *pcbNeeded = *pcbNeeded * 2;
                    return TRUE;
                }
                else
                {
                    //Convert the ANSI structures in the temporary
                    //output buffer to UNICODE structures in the caller's 
                    //buffer.
                    memset( pPrinterEnum, 0, cbBuf );
                    
                    PBYTE pStartStrings = pPrinterEnum + 
                        (*pcReturned * sizeof(PRINTER_INFO_2W));
                    PBYTE pEndUserBuf = pPrinterEnum + cbBuf;
                    LPWSTR szCurOutputString = (LPWSTR)pStartStrings;

                    UINT i =0;
                    //Strings go after the array of structures
                    //compute the string start address
                    for(i = 0 ; i < *pcReturned; i++)
                    {
                        PPRINTER_INFO_2A ppi2a =
                            &(((PRINTER_INFO_2A *)pPrinterEnumA)[i]);
                        PPRINTER_INFO_2W ppi2w =
                            &(((PRINTER_INFO_2W *)pPrinterEnum)[i]);
                        
                        //
                        // First copy over all the static fields
                        //
                        ppi2w->Attributes = ppi2a->Attributes;
                        ppi2w->Priority   = ppi2a->Priority;
                        ppi2w->DefaultPriority = ppi2a->DefaultPriority;
                        ppi2w->StartTime  = ppi2a->StartTime;
                        ppi2w->UntilTime  = ppi2a->UntilTime;
                        ppi2w->Status     = ppi2a->Status;
                        ppi2w->cJobs      = ppi2a->cJobs;
                        ppi2w->AveragePPM = ppi2a->AveragePPM;
                        //Win9x has no security descriptors
                        ppi2w->pSecurityDescriptor  = NULL; 
                        
                        //WARN: RDPDR currently doesn't use DEVMODE
                        //so we don't bother converting it (it's huge)
                        ppi2w->pDevMode = NULL;

                        //
                        // Now convert the strings
                        // for perf reasons we only handle the
                        // strings RDPDR currently uses. The others are set
                        // to null when we memset above.
                        //
                        int cchLen = lstrlenA( ppi2a->pPortName );
                        SHAnsiToUnicode( ppi2a->pPortName,
                                         szCurOutputString,
                                         cchLen + 1 );
                        ppi2w->pPortName = szCurOutputString;
                        szCurOutputString += (cchLen + 2);

                        cchLen = lstrlenA( ppi2a->pPrinterName );
                        SHAnsiToUnicode( ppi2a->pPrinterName,
                                         szCurOutputString,
                                         cchLen + 1 );
                        ppi2w->pPrinterName = szCurOutputString;
                        szCurOutputString += (cchLen + 2);

                        cchLen = lstrlenA( ppi2a->pDriverName );
                        SHAnsiToUnicode( ppi2a->pDriverName,
                                         szCurOutputString,
                                         cchLen + 1 );
                        ppi2w->pDriverName = szCurOutputString;
                        szCurOutputString += (cchLen + 2);
                    }

                    LocalFree(pPrinterEnumA);
                    pPrinterEnumA = NULL;

                    return TRUE;
                }
            }
            else
            {
                LocalFree(pPrinterEnumA);
                return FALSE;
            }
        }
        else
        {
            //We only support level2 for now. Add more if needed.
            SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
            return FALSE;
        }
    }
}

BOOL
WINAPI
OpenPrinterWrapW(
   IN LPWSTR    pPrinterName,
   OUT LPHANDLE phPrinter,
   IN LPPRINTER_DEFAULTSW pDefault)
{
    //We don't support converting the pDev because RDPDR doesn't use
    //it. If you add code that needs it modify this wrapper.
    if(pDefault)
    {
        ASSERT(pDefault->pDevMode == NULL);
    }
    if(g_bRunningOnNT)
    {
        return OpenPrinterW( pPrinterName, phPrinter, pDefault);
    }
    else
    {
        PRINTER_DEFAULTSA pdefa;
        CStrIn strPrinterName(pPrinterName);
        if(pDefault)
        {
            CStrIn strInDataType(pDefault->pDatatype);
            pdefa.DesiredAccess = pDefault->DesiredAccess;
            pdefa.pDevMode = NULL; //UNSUPPORTED conversion see above
            pdefa.pDatatype = strInDataType;
            return OpenPrinterA( strPrinterName,
                                 phPrinter,
                                 &pdefa );
        }
        else
        {
            return OpenPrinterA( strPrinterName,
                                 phPrinter,
                                 NULL );
        }
    }
}


DWORD
WINAPI
StartDocPrinterWrapW(
    IN HANDLE  hPrinter,
    IN DWORD   Level,
    IN LPBYTE  pDocInfo)
{
    if(g_bRunningOnNT)
    {
        return StartDocPrinterW( hPrinter, Level, pDocInfo );
    }
    else
    {
        ASSERT(Level == 1); //we only support this level
        DOC_INFO_1A docinf1a;
        CStrIn strDocName( ((PDOC_INFO_1)pDocInfo)->pDocName );
        CStrIn strOutputFile( ((PDOC_INFO_1)pDocInfo)->pOutputFile );
        CStrIn strDataType( ((PDOC_INFO_1)pDocInfo)->pDatatype );

        docinf1a.pDocName = strDocName;
        docinf1a.pOutputFile = strOutputFile;
        docinf1a.pDatatype = strDataType;
        return StartDocPrinterA( hPrinter, Level, (PBYTE)&docinf1a );
    }
}


DWORD
WINAPI
GetPrinterDataWrapW(
    IN HANDLE   hPrinter,
    IN LPWSTR  pValueName,
    OUT LPDWORD  pType,
    OUT LPBYTE   pData,
    IN DWORD    nSize,
    OUT LPDWORD  pcbNeeded)
{
    if(g_bRunningOnNT)
    {
        return GetPrinterDataW( hPrinter, pValueName, pType,
                                pData, nSize, pcbNeeded );
    }
    else
    {
        CStrIn strValueName(pValueName);
        DWORD ret = 0;
        if(!pData)
        {
            //This is a size query
            ret = GetPrinterDataA( hPrinter,
                                   strValueName,
                                   pType,
                                   NULL,
                                   nSize,
                                   pcbNeeded );
            *pcbNeeded = *pcbNeeded * 2; //double for UNICODE
            return ret;
        }
        else
        {
            CStrOut strDataOut( (LPWSTR)pData, nSize/sizeof(TCHAR));
            //ASSUMPTION is that we get back string data
            ret = GetPrinterDataA( hPrinter,
                                   strValueName,
                                   pType,
                                   (LPBYTE)((LPSTR)strDataOut),
                                   nSize,
                                   pcbNeeded );
            return ret;
        }
    }
}

BOOL
WINAPI
GetPrinterDriverWrapW(
    HANDLE hPrinter,     // printer object
    LPTSTR pEnvironment, // environment name.  NULL is supported.
    DWORD Level,         // information level
    LPBYTE pDriverInfo,  // driver data buffer
    DWORD cbBuf,         // size of buffer
    LPDWORD pcbNeeded    // bytes received or required
    )
{
    BOOL ret;

    // Level 1 is supported at this time.
    ASSERT(Level == 1);

    // pEnvironment better be NULL.
    ASSERT(pEnvironment == NULL);

    if (g_bRunningOnNT) {

        return GetPrinterDriverW(
                    hPrinter, pEnvironment, Level, 
                    pDriverInfo, cbBuf, 
                    pcbNeeded
                    );

    }
    else {

        if (!pDriverInfo) {

            //
            //  This is a size query
            //
            ret = GetPrinterDriverA(
                    hPrinter, NULL, Level, 
                    NULL, cbBuf, pcbNeeded
                    );
            *pcbNeeded = *pcbNeeded * 2; //double for UNICODE
            return ret;

        }
        else {

            PDRIVER_INFO_1 srcP1 = (PDRIVER_INFO_1)LocalAlloc(LPTR, cbBuf);
            if (srcP1 == NULL) {
                return FALSE;
            }
            else {
                ret = GetPrinterDriverA(
                                hPrinter, NULL, Level, 
                                (LPBYTE)srcP1, cbBuf, pcbNeeded
                                );
                if (ret) {
                    int cchLen = lstrlenA((LPCSTR)srcP1->pName);

                    PDRIVER_INFO_1 dstP1 = (PDRIVER_INFO_1)pDriverInfo;
                    dstP1->pName = (LPWSTR)(dstP1 + 1);
                    SHAnsiToUnicode((LPCSTR)srcP1->pName, dstP1->pName, cchLen + 1);
                }
                LocalFree(srcP1);
                return ret;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\uniwrap\strinout.cpp ===
//
// strinout.cpp
//
// Unicode wrappers (String converters)
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//
// based on code from shell\shlwapi\unicwrap.*
//

#include "stdafx.h"
#include "cstrinout.h"

//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void
CConvertStr::Free()
{
    if (_pstr != _ach && HIWORD64(_pstr) != 0 && !IsAtom())
    {
        delete [] _pstr;
    }

    _pstr = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void
CConvertStrW::Free()
{
    if (_pwstr != _awch && HIWORD64(_pwstr) != 0)
    {
        delete [] _pwstr;
    }

    _pwstr = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::Init
//
//  Synopsis:   Converts a LPSTR function argument to a LPWSTR.
//
//  Arguments:  [pstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD64(pwstr) == 0).
//
//              [cch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

void
CStrInW::Init(LPCSTR pstr, int cch)
{
    int cchBufReq;

    _cwchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD64(pstr) == 0)
    {
        _pwstr = (LPWSTR) pstr;
        return;
    }

    ASSERT(cch == -1 || cch > 0);

    //
    // Convert string to preallocated buffer, and return if successful.
    //
    // Since the passed in buffer may not be null terminated, we have
    // a problem if cch==ARRAYSIZE(_awch), because MultiByteToWideChar
    // will succeed, and we won't be able to null terminate the string!
    // Decrease our buffer by one for this case.
    //
    _cwchLen = MultiByteToWideChar(
            CP_ACP, 0, pstr, cch, _awch, ARRAYSIZE(_awch)-1);

    if (_cwchLen > 0)
    {
        // Some callers don't NULL terminate.
        //
        // We could check "if (-1 != cch)" before doing this,
        // but always doing the null is less code.
        //
        _awch[_cwchLen] = 0;

        if (0 == _awch[_cwchLen-1]) // account for terminator
            _cwchLen--;

        _pwstr = _awch;
        return;
    }

    //
    // Alloc space on heap for buffer.
    //

    cchBufReq = MultiByteToWideChar( CP_ACP, 0, pstr, cch, NULL, 0 );

    // Again, leave room for null termination
    cchBufReq++;

    ASSERT(cchBufReq > 0);
    _pwstr = new WCHAR[cchBufReq];
    if (!_pwstr)
    {
        // On failure, the argument will point to the empty string.
        _awch[0] = 0;
        _pwstr = _awch;
        return;
    }

    ASSERT(HIWORD64(_pwstr));
    _cwchLen = MultiByteToWideChar(
            CP_ACP, 0, pstr, cch, _pwstr, cchBufReq );

#if DBG == 1 /* { */
    if (0 == _cwchLen)
    {
        int errcode = GetLastError();
        ASSERT(0 && "MultiByteToWideChar failed in unicode wrapper.");
    }
#endif /* } */

    // Again, make sure we're always null terminated
    ASSERT(_cwchLen < cchBufReq);
    _pwstr[_cwchLen] = 0;

    if (0 == _pwstr[_cwchLen-1]) // account for terminator
        _cwchLen--;

}


//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Inits the class.
//
//  NOTE:       Don't inline this function or you'll increase code size
//              by pushing -1 on the stack for each call.
//
//----------------------------------------------------------------------------

CStrIn::CStrIn(LPCWSTR pwstr) : CConvertStr(CP_ACP)
{
    Init(pwstr, -1);
}


CStrIn::CStrIn(UINT uCP, LPCWSTR pwstr) : CConvertStr(uCP)
{
    Init(pwstr, -1);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::Init
//
//  Synopsis:   Converts a LPWSTR function argument to a LPSTR.
//
//  Arguments:  [pwstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD(pwstr) == 0).
//
//              [cwch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//  Note:       We ignore AreFileApisANSI() and always use CP_ACP.
//              The reason is that nobody uses SetFileApisToOEM() except
//              console apps, and once you set file APIs to OEM, you
//              cannot call shell/user/gdi APIs, since they assume ANSI
//              regardless of the FileApis setting.  So you end up in
//              this horrible messy state where the filename APIs interpret
//              the strings as OEM but SHELL32 interprets the strings
//              as ANSI and you end up with a big mess.
//
//----------------------------------------------------------------------------

void
CStrIn::Init(LPCWSTR pwstr, int cwch)
{
    int cchBufReq;

#if DBG == 1 /* { */
    int errcode;
#endif /* } */

    _cchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD64(pwstr) == 0 || IsAtom())
    {
        _pstr = (LPSTR) pwstr;
        return;
    }

    if ( cwch == 0 )
    {
        *_ach = '\0';
        _pstr = _ach;
        return;
    }

    //
    // Convert string to preallocated buffer, and return if successful.
    //

    _cchLen = WideCharToMultiByte(
            _uCP, 0, pwstr, cwch, _ach, ARRAYSIZE(_ach)-1, NULL, NULL);

    if (_cchLen > 0)
    {
        // This is DBCS safe since byte before _cchLen is last character
        _ach[_cchLen] = 0;
        // this may not be safe if the last character
        // was a multibyte character...
        if (_ach[_cchLen-1]==0)
            _cchLen--;          // account for terminator
        _pstr = _ach;
        return;
    }


    cchBufReq = WideCharToMultiByte(
            CP_ACP, 0, pwstr, cwch, NULL, 0, NULL, NULL);

    cchBufReq++;

    ASSERT(cchBufReq > 0);
    _pstr = new char[cchBufReq];
    if (!_pstr)
    {
        // On failure, the argument will point to the empty string.
        _ach[0] = 0;
        _pstr = _ach;
        return;
    }

    ASSERT(HIWORD64(_pstr));
    _cchLen = WideCharToMultiByte(
            _uCP, 0, pwstr, cwch, _pstr, cchBufReq, NULL, NULL);
#if DBG == 1 /* { */
    if (_cchLen < 0)
    {
        errcode = GetLastError();
        ASSERT(0 && "WideCharToMultiByte failed in unicode wrapper.");
    }
#endif /* } */

    // Again, make sure we're always null terminated
    ASSERT(_cchLen < cchBufReq);
    _pstr[_cchLen] = 0;
    if (0 == _pstr[_cchLen-1]) // account for terminator
        _cchLen--;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrInMulti::CStrInMulti
//
//  Synopsis:   Converts mulitple LPWSTRs to a multiple LPSTRs.
//
//  Arguments:  [pwstr] -- The strings to convert.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

CStrInMulti::CStrInMulti(LPCWSTR pwstr)
{
    LPCWSTR pwstrT;

    // We don't handle atoms because we don't need to.
    ASSERT(HIWORD64(pwstr));

    //
    // Count number of characters to convert.
    //

    pwstrT = pwstr;
    if (pwstr)
    {
        do {
            while (*pwstrT++)
                ;

        } while (*pwstrT++);
    }

    Init(pwstr, (int)(pwstrT - pwstr));
}


//+---------------------------------------------------------------------------
//
//  Member:     CPPFIn::CPPFIn
//
//  Synopsis:   Inits the class.  Truncates the filename to MAX_PATH
//              so Win9x DBCS won't fault.  Win9x SBCS silently truncates
//              to MAX_PATH, so we're bug-for-bug compatible.
//
//----------------------------------------------------------------------------

CPPFIn::CPPFIn(LPCWSTR pwstr)
{
    SHUnicodeToAnsi(pwstr, _ach, ARRAYSIZE(_ach));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::CStrOut
//
//  Synopsis:   Allocates enough space for an out buffer.
//
//  Arguments:  [pwstr]   -- The Unicode buffer to convert to when destroyed.
//                              May be NULL.
//
//              [cwchBuf] -- The size of the buffer in characters.
//
//  Modifies:   [this].
//
//----------------------------------------------------------------------------

CStrOut::CStrOut(LPWSTR pwstr, int cwchBuf) : CConvertStr(CP_ACP)
{
    Init(pwstr, cwchBuf);
}

CStrOut::CStrOut(UINT uCP, LPWSTR pwstr, int cwchBuf) : CConvertStr(uCP)
{
    Init(pwstr, cwchBuf);
}

void
CStrOut::Init(LPWSTR pwstr, int cwchBuf) 
{
    ASSERT(cwchBuf >= 0);

    _pwstr = pwstr;
    _cwchBuf = cwchBuf;

    if (!pwstr)
    {
        // Force cwchBuf = 0 because many callers (in particular, registry
        // munging functions) pass garbage as the length because they know
        // it will be ignored.
        _cwchBuf = 0;
        _pstr = NULL;
        return;
    }

    ASSERT(HIWORD64(pwstr));

    // Initialize buffer in case Windows API returns an error.
    _ach[0] = 0;

    // Use preallocated buffer if big enough.
    if (cwchBuf * 2 <= ARRAYSIZE(_ach))
    {
        _pstr = _ach;
        return;
    }

    // Allocate buffer.
    _pstr = new char[cwchBuf * 2];
    if (!_pstr)
    {
        //
        // On failure, the argument will point to a zero-sized buffer initialized
        // to the empty string.  This should cause the Windows API to fail.
        //

        ASSERT(cwchBuf > 0);
        _pwstr[0] = 0;
        _cwchBuf = 0;
        _pstr = _ach;
        return;
    }

    ASSERT(HIWORD64(_pstr));
    _pstr[0] = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::CStrOutW
//
//  Synopsis:   Allocates enough space for an out buffer.
//
//  Arguments:  [pstr]    -- The MBCS buffer to convert to when destroyed.
//                              May be NULL.
//
//              [cchBuf]  -- The size of the buffer in characters.
//
//  Modifies:   [this].
//
//----------------------------------------------------------------------------

CStrOutW::CStrOutW(LPSTR pstr, int cchBuf)
{
    ASSERT(cchBuf >= 0);

    _pstr = pstr;
    _cchBuf = cchBuf;

    if (!pstr)
    {
        // Force cchBuf = 0 because many callers (in particular, registry
        // munging functions) pass garbage as the length because they know
        // it will be ignored.
        _cchBuf = 0;
        _pwstr = NULL;
        return;
    }

    ASSERT(HIWORD64(pstr));

    // Initialize buffer in case Windows API returns an error.
    _awch[0] = 0;

    // Use preallocated buffer if big enough.
    if (cchBuf <= ARRAYSIZE(_awch))
    {
        _pwstr = _awch;
        return;
    }

    // Allocate buffer.
    _pwstr = new WCHAR[cchBuf];
    if (!_pwstr)
    {
        //
        // On failure, the argument will point to a zero-sized buffer initialized
        // to the empty string.  This should cause the Windows API to fail.
        //

        ASSERT(cchBuf > 0);
        _pstr[0] = 0;
        _cchBuf = 0;
        _pwstr = _awch;
        return;
    }

    ASSERT(HIWORD64(_pwstr));
    _pwstr[0] = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::ConvertIncludingNul
//
//  Synopsis:   Converts the buffer from MBCS to Unicode
//
//  Return:     Character count INCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------

int
CStrOut::ConvertIncludingNul()
{
    int cch;

    if (!_pstr)
        return 0;

    cch = SHAnsiToUnicodeCP(_uCP, _pstr, _pwstr, _cwchBuf);

#if DBG == 1 /* { */
    if (cch == 0 && _cwchBuf > 0)
    {
        int errcode = GetLastError();
        ASSERT(0 && "SHAnsiToUnicode failed in unicode wrapper.");
    }
#endif /* } */

    Free();
    return cch;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::ConvertIncludingNul
//
//  Synopsis:   Converts the buffer from Unicode to MBCS
//
//  Return:     Character count INCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------

int
CStrOutW::ConvertIncludingNul()
{
    int cch;

    if (!_pwstr)
        return 0;

    cch = SHUnicodeToAnsi(_pwstr, _pstr, _cchBuf);

#if DBG == 1 /* { */
    if (cch == 0 && _cchBuf > 0)
    {
        int errcode = GetLastError();
        ASSERT(0 && "SHUnicodeToAnsi failed in unicode wrapper.");
    }
#endif /* } */

    Free();
    return cch;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::ConvertExcludingNul
//
//  Synopsis:   Converts the buffer from MBCS to Unicode
//
//  Return:     Character count EXCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------

int
CStrOut::ConvertExcludingNul()
{
    int ret = ConvertIncludingNul();
    if (ret > 0)
    {
        ret -= 1;
    }
    return ret;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::CopyNoConvert
//
//  Synopsis:   Copies to the output buffer without converting
//
//  Return:     Character count EXCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------
int
CStrOut::CopyNoConvert(int srcBytes)
{
    if (!_pstr || !_pwstr)
    {
        return 0;
    }

    if (srcBytes < (int)(_cwchBuf * sizeof(WCHAR)))
    {
        memcpy(_pwstr, _pstr, srcBytes);
        Free();
        return srcBytes;
    }
    else
    {
        return 0;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::~CStrOut
//
//  Synopsis:   Converts the buffer from MBCS to Unicode.
//
//  Note:       Don't inline this function, or you'll increase code size as
//              both ConvertIncludingNul() and CConvertStr::~CConvertStr will be
//              called inline.
//
//----------------------------------------------------------------------------

CStrOut::~CStrOut()
{
    ConvertIncludingNul();
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::~CStrOutW
//
//  Synopsis:   Converts the buffer from Unicode to MBCS.
//
//  Note:       Don't inline this function, or you'll increase code size as
//              both ConvertIncludingNul() and CConvertStr::~CConvertStr will be
//              called inline.
//
//----------------------------------------------------------------------------

CStrOutW::~CStrOutW()
{
    ConvertIncludingNul();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\uniwrap\uniansi.cpp ===
//============================================================================
//
// UNICODE and ANSI conversion functions
//
//============================================================================

#include "stdafx.h"
#include "uniansi.h"

#define SIZEOF sizeof

#ifdef UNICODE
// SHTruncateString takes a BUFFER SIZE, so subtract 1 to properly null terminate.
//
#define SHTruncateString(wzStr, cch)            ((cch) ? ((wzStr)[cch-1]=L'\0', (cch-1)) : 0)
#else
LWSTDAPI_(int)  SHTruncateString(CHAR *sz, int cchBufferSize);
#endif // UNICODE


/*
 *  @doc    INTERNAL
 *
 *  @func   int | SHAnsiToUnicodeNativeCP |
 *
 *          Convert an ANSI string to a UNICODE string via the
 *          specified Windows code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   UINT | uiCP |
 *
 *          The code page in which to perform the conversion.
 *          This must be a Windows code page.
 *
 *  @parm   LPCSTR | pszSrc |
 *
 *          Source buffer containing ANSI string to be converted.
 *
 *  @parm   int | cchSrc |
 *
 *          Source buffer length, including terminating null.
 *
 *  @parm   LPWSTR | pwszDst |
 *
 *          Destination buffer to receive converted UNICODE string.
 *
 *  @parm   int | cwchBuf |
 *
 *          Size of the destination buffer in <t WCHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 */

int
SHAnsiToUnicodeNativeCP(UINT uiCP,
                        LPCSTR pszSrc, int cchSrc,
                        LPWSTR pwszDst, int cwchBuf)
{
    int cwchRc = 0;             /* Assume failure */

    /*
     *  Checks the caller should've made.
     */
    ASSERT(IS_VALID_STRING_PTRA(pszSrc, -1));
    ASSERT(cchSrc == lstrlenA(pszSrc) + 1);
    ASSERT(IS_VALID_WRITE_BUFFER(pwszDst, WCHAR, cwchBuf));
    ASSERT(pszSrc != NULL);
    ASSERT(uiCP != 1200 && uiCP != 65000 && uiCP != 50000 && uiCP != 65001);
    ASSERT(pwszDst);
    ASSERT(cwchBuf);

    cwchRc = MultiByteToWideChar(uiCP, 0, pszSrc, cchSrc, pwszDst, cwchBuf);
    if (cwchRc) {
        /*
         *  The output buffer was big enough; no double-buffering
         *  needed.
         */
    } else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
        /*
         *  The output buffer wasn't big enough.  Need to double-buffer.
         */

        int cwchNeeded = MultiByteToWideChar(uiCP, 0, pszSrc, cchSrc,
                                             NULL, 0);

        ASSERT(cwchRc == 0);        /* In case we fail later */
        if (cwchNeeded) {
            LPWSTR pwsz = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                             cwchNeeded * SIZEOF(WCHAR));
            if (pwsz) {
                cwchRc = MultiByteToWideChar(uiCP, 0, pszSrc, cchSrc,
                                             pwsz, cwchNeeded);
                if (cwchRc) {
                    wcsncpy(pwszDst, pwsz, cwchBuf);
                    cwchRc = cwchBuf;
                }
                LocalFree(pwsz);
            }
        }
    } else {
        /* Possibly unsupported code page */
        ASSERT(!"Unexpected error in MultiByteToWideChar");
    }

    return cwchRc;
}

/*
 *  @doc    EXTERNAL
 *
 *  @func   int | SHAnsiToUnicodeCP |
 *
 *          Convert an ANSI string to a UNICODE string via the
 *          specified code page, which can be either a native
 *          Windows code page or an Internet code page.
 *          If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   UINT | uiCP |
 *
 *          The code page in which to perform the conversion.
 *
 *  @parm   LPCSTR | pszSrc |
 *
 *          Source buffer containing ANSI string to be converted.
 *
 *  @parm   LPWSTR | pwszDst |
 *
 *          Destination buffer to receive converted UNICODE string.
 *
 *  @parm   int | cwchBuf |
 *
 *          Size of the destination buffer in <t WCHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 */

int
SHAnsiToUnicodeCP(UINT uiCP, LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf)
{
    int cwchRc = 0;             /* Assume failure */

    ASSERT(IS_VALID_STRING_PTRA(pszSrc, -1));
    ASSERT(IS_VALID_WRITE_BUFFER(pwszDst, WCHAR, cwchBuf));

    /*
     *  Sanity check - NULL source string is treated as a null string.
     */
    if (pszSrc == NULL) {
        pszSrc = "";
    }

    /*
     *  Sanity check - Output buffer must be non-NULL and must be of
     *  nonzero size.
     */
    if (pwszDst && cwchBuf) {

        int cchSrc;

        pwszDst[0] = 0;         /* In case of error */

        cchSrc = lstrlenA(pszSrc) + 1;

        /*
         *  Decide what kind of code page it is.
         */
        switch (uiCP) {
        case 1200:                      // UCS-2 (Unicode)
            uiCP = 65001;
            // Fall through
        case 50000:                     // "User Defined"
        case 65000:                     // UTF-7
        case 65001:                     // UTF-8
                //FIXFIX
                //cwchRc = SHAnsiToUnicodeInetCP(uiCP, pszSrc, cchSrc, pwszDst, cwchBuf);
            break;

        default:
            cwchRc = SHAnsiToUnicodeNativeCP(uiCP, pszSrc, cchSrc, pwszDst, cwchBuf);
            break;
        }
    }

    return cwchRc;
}

// This function exists to make sure SHAnsiToAnsi and SHUnicodeToAnsi
// have the same return value.  Callers use SHTCharToAnsi and don't know
// when it callapses to SHAnsiToAnsi.
int SHAnsiToAnsi(LPCSTR pszSrc, LPSTR pszDst, int cchBuf)
{
    strncpy(pszDst, pszSrc, cchBuf);
    return (lstrlenA(pszDst) + 1);      // size including terminator
}

// This function exists to make sure SHUnicodeToUnicode and SHUnicodeToAnsi
// have the same return value.  Callers use SHTCharToUnicode and don't know
// when it callapses to SHUnicodeToUnicode.
int SHUnicodeToUnicode(LPCWSTR pwzSrc, LPWSTR pwzDst, int cchBuf)
{
    wcsncpy(pwzDst, pwzSrc, cchBuf);
    return (lstrlenW(pwzDst) + 1);      // size including terminator
}


/*
 *  @doc    EXTERNAL
 *
 *  @func   int | SHAnsiToUnicode |
 *
 *          Convert an ANSI string to a UNICODE string via the
 *          <c CP_ACP> code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   LPCSTR | pszSrc |
 *
 *          Source buffer containing ANSI string to be converted.
 *
 *  @parm   LPWSTR | pwszDst |
 *
 *          Destination buffer to receive converted UNICODE string.
 *
 *  @parm   int | cwchBuf |
 *
 *          Size of the destination buffer in <t WCHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 *
 */

int
SHAnsiToUnicode(LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf)
{
    return SHAnsiToUnicodeCP(CP_ACP, pszSrc, pwszDst, cwchBuf);
}

/*
 *  @doc    INTERNAL
 *
 *  @func   int | SHUnicodeToAnsiNativeCP |
 *
 *          Convert a UNICODE string to an ANSI string via the
 *          specified Windows code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.  Care is taken not to break a double-byte
 *          character.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   UINT | uiCP |
 *
 *          The code page in which to perform the conversion.
 *          This must be a Windows code page.
 *
 *  @parm   LPCWSTR | pwszSrc |
 *
 *          Source buffer containing UNICODE string to be converted.
 *
 *  @parm   int | cwchSrc |
 *
 *          Number of characters in source buffer, including terminating
 *          null.
 *
 *  @parm   LPSTR | pszDst |
 *
 *          Destination buffer to receive converted ANSI string.
 *
 *  @parm   int | cchBuf |
 *
 *          Size of the destination buffer in <t CHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 *          (For the purpose of this function, a double-byte character
 *          counts as two characters.)
 */

int
SHUnicodeToAnsiNativeCP(UINT uiCP,
                        LPCWSTR pwszSrc, int cwchSrc,
                        LPSTR pszDst, int cchBuf)

{
    int cchRc = 0;          /* Assume failure */

#if DBG
    BOOL fVerify = TRUE;
    BOOL fLossy;
    if (uiCP == CP_ACPNOVALIDATE) {
        // -1 means use CP_ACP, but do *not* verify
        // kind of a hack, but it's DEBUG and leaves 99% of callers unchanged
        uiCP = CP_ACP;
        fVerify = FALSE;
    }
#define USUALLY_NULL    (&fLossy)
#else
#define USUALLY_NULL    NULL
#endif

    /*
     *  Checks the caller should've made.
     */
    ASSERT(IS_VALID_STRING_PTRW(pwszSrc, -1));
    ASSERT(cwchSrc == lstrlenW(pwszSrc) + 1);
    ASSERT(IS_VALID_WRITE_BUFFER(pszDst, CHAR, cchBuf));
    ASSERT(uiCP != 1200 && uiCP != 65000 && uiCP != 50000 && uiCP != 65001);
    ASSERT(pwszSrc);
    ASSERT(pszDst);
    ASSERT(cchBuf);

    cchRc = WideCharToMultiByte(uiCP, 0, pwszSrc, cwchSrc, pszDst, cchBuf,
                                NULL, USUALLY_NULL);
    if (cchRc) {
        /*
         *  The output buffer was big enough; no double-buffering
         *  needed.
         */
    } else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
        /*
         *  The output buffer wasn't big enough.  Need to double-buffer.
         */

        int cchNeeded = WideCharToMultiByte(uiCP, 0, pwszSrc, cwchSrc,
                                            NULL, 0, NULL, NULL);

        ASSERT(cchRc == 0);         /* In case we fail later */
        if (cchNeeded) {
            LPSTR psz = (LPSTR)LocalAlloc(LMEM_FIXED,
                                          cchNeeded * SIZEOF(CHAR));
            if (psz) {
                cchRc = WideCharToMultiByte(uiCP, 0, pwszSrc, cwchSrc,
                                            psz, cchNeeded, NULL, USUALLY_NULL);
                if (cchRc) {
                    // lstrcpyn doesn't check if it's chopping a DBCS char
                    // so we need to use SHTruncateString.
                    //
                    // Add 1 because SHTruncateString doesn't count
                    // the trailing null but we do
                    //
                    // Assert that we meet the preconditions for
                    // SHTruncateString to return a valid value.
                    //
                    ASSERT(cchRc > cchBuf);
                    cchRc = SHTruncateString(psz, cchBuf) + 1;
                    lstrcpynA(pszDst, psz, cchBuf);
                }
                LocalFree(psz);
            }
        }
    } else {
        /* Possibly unsupported code page */
        ASSERT(!"Unexpected error in WideCharToMultiByte");
    }

#if DBG
    ASSERT(!fVerify || !fLossy);
#endif

    return cchRc;
}

#if 0
/*
 *  @doc    INTERNAL
 *
 *  @func   int | SHUnicodeToAnsiInetCP |
 *
 *          Convert a UNICODE string to an ANSI string via the
 *          specified Internet code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.  Care is taken not to break a double-byte
 *          character.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   UINT | uiCP |
 *
 *          The code page in which to perform the conversion.
 *          This must be an Internet code page.
 *
 *  @parm   LPCWSTR | pwszSrc |
 *
 *          Source buffer containing UNICODE string to be converted.
 *
 *  @parm   int | cwchSrc |
 *
 *          Number of characters in source buffer, including terminating
 *          null.
 *
 *  @parm   LPSTR | pszDst |
 *
 *          Destination buffer to receive converted ANSI string.
 *
 *  @parm   int | cchBuf |
 *
 *          Size of the destination buffer in <t CHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 *          (For the purpose of this function, a double-byte character
 *          counts as two characters.)
 */

int
SHUnicodeToAnsiInetCP(UINT uiCP,
                      LPCWSTR pwszSrc, int cwchSrc,
                      LPSTR pszDst, int cchBuf)
{
    int cwchSrcT, cchNeeded;
    int cchRc = 0;          /* Assume failure */
    HRESULT hres;

    /*
     *  Checks the caller should've made.
     */
    ASSERT(IS_VALID_STRING_PTRW(pwszSrc, -1));
    ASSERT(cwchSrc == lstrlenW(pwszSrc) + 1);
    ASSERT(IS_VALID_WRITE_BUFFER(pszDst, CHAR, cchBuf));
    ASSERT(uiCP == 1200 || uiCP == 65000 || uiCP == 65001);
    ASSERT(pwszSrc);
    ASSERT(pszDst);
    ASSERT(cchBuf);

    cwchSrcT = cwchSrc;
    cchNeeded = cchBuf;

    hres = ConvertINetUnicodeToMultiByte(NULL, uiCP, pwszSrc,
                                         &cwchSrcT, pszDst, &cchNeeded);
    if (SUCCEEDED(hres)) {
        if (cwchSrcT >= cwchSrc) {
            /*
             *  The output buffer was big enough; no double-buffering
             *  needed.
             */
        } else {
            /*
             *  The output buffer wasn't big enough.  Need to double-buffer.
             */
            LPSTR psz = (LPSTR)LocalAlloc(LMEM_FIXED,
                                          cchNeeded * SIZEOF(CHAR));
            if (psz) {
                hres = ConvertINetUnicodeToMultiByte(NULL, uiCP, pwszSrc,
                                            &cwchSrc, psz, &cchNeeded);
                if (SUCCEEDED(hres)) {
                    // lstrcpyn doesn't check if it's chopping a DBCS char
                    // so we need to use SHTruncateString.
                    //
                    // Add 1 because SHTruncateString doesn't count
                    // the trailing null but we do
                    //
                    // Assert that we meet the preconditions for
                    // SHTruncateString to return a valid value.
                    //
                    ASSERT(cchNeeded > cchBuf);
                    cchRc = SHTruncateString(psz, cchBuf) + 1;
                    lstrcpynA(pszDst, psz, cchBuf);
                }
                LocalFree(psz);
            }
        }
    } else {
        /* Possibly unsupported code page */
        ASSERT(!"Unexpected error in ConvertInetUnicodeToMultiByte");
    }

    return cchRc;
}
#endif

/*
 *  @doc    EXTERNAL
 *
 *  @func   int | SHUnicodeToAnsiCP |
 *
 *          Convert a UNICODE string to an ANSI string via the
 *          specified code page, which can be either a native
 *          Windows code page or an Internet code page.
 *          If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.  Care is taken not to break a double-byte
 *          character.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   UINT | uiCP |
 *
 *          The code page in which to perform the conversion.
 *
 *  @parm   LPCWSTR | pwszSrc |
 *
 *          Source buffer containing UNICODE string to be converted.
 *
 *  @parm   LPSTR | pszDst |
 *
 *          Destination buffer to receive converted ANSI string.
 *
 *  @parm   int | cchBuf |
 *
 *          Size of the destination buffer in <t CHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 *          (For the purpose of this function, a double-byte character
 *          counts as two characters.)
 *
 */

int
SHUnicodeToAnsiCP(UINT uiCP, LPCWSTR pwszSrc, LPSTR pszDst, int cchBuf)
{
    int cchRc = 0;              /* Assume failure */
#if DBG
#define GET_CP(uiCP)    (((uiCP) == CP_ACPNOVALIDATE) ? CP_ACP : (uiCP))
#else
#define GET_CP(uiCP)    uiCP
#endif

    ASSERT(IS_VALID_STRING_PTRW(pwszSrc, -1));
    ASSERT(IS_VALID_WRITE_BUFFER(pszDst, CHAR, cchBuf));

    /*
     *  Sanity check - NULL source string is treated as a null string.
     */
    if (pwszSrc == NULL) {
        pwszSrc = L"";
    }

    /*
     *  Sanity check - Output buffer must be non-NULL and must be of
     *  nonzero size.
     */
    if (pszDst && cchBuf) {

        int cwchSrc;

        pszDst[0] = 0;          /* In case of error */

        cwchSrc = lstrlenW(pwszSrc) + 1; /* Yes, Win9x has lstrlenW */

        /*
         *  Decide what kind of code page it is.
         */
        switch (GET_CP(uiCP)) {
        case 1200:                      // UCS-2 (Unicode)
            uiCP = 65001;
            // Fall through
            #if 0  //FIXIFX
        case 50000:                     // "User Defined"
        case 65000:                     // UTF-7
        case 65001:                     // UTF-8
                
            cchRc = SHUnicodeToAnsiInetCP(GET_CP(uiCP), pwszSrc, cwchSrc, pszDst, cchBuf);
            break;
            #endif

        default:
            cchRc = SHUnicodeToAnsiNativeCP(uiCP, pwszSrc, cwchSrc, pszDst, cchBuf);
            break;
        }
    }

    return cchRc;
}

/*
 *  @doc    EXTERNAL
 *
 *  @func   int | SHUnicodeToAnsi |
 *
 *          Convert a UNICODE string to an ANSI string via the
 *          <c CP_ACP> code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.  Care is taken not to break a double-byte
 *          character.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   LPCWSTR | pwszSrc |
 *
 *          Source buffer containing UNICODE string to be converted.
 *
 *  @parm   LPSTR | pszDst |
 *
 *          Destination buffer to receive converted ANSI string.
 *
 *  @parm   int | cchBuf |
 *
 *          Size of the destination buffer in <t CHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 *          (For the purpose of this function, a double-byte character
 *          counts as two characters.)
 *
 */

int
SHUnicodeToAnsi(LPCWSTR pwszSrc, LPSTR pszDst, int cchBuf)
{
    return SHUnicodeToAnsiCP(CP_ACP, pwszSrc, pszDst, cchBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\uniwrap\uniansi.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-2000
//
//  File:      Unicode/ANSI conversion fns
//
//  Contents:   shell-wide string thunkers, for use by unicode wrappers
//
//----------------------------------------------------------------------------

#ifndef _UNIANSI_H_
#define _UNIANSI_H_

// HIWORD is typically used to detect whether a pointer parameter
// is a real pointer or is a MAKEINTATOM.  HIWORD64 is the Win64-compatible
// version of this usage.  It does *NOT* return the top word of a 64-bit value.
// Rather, it returns the top 48 bits of the 64-bit value.
//
// Yes, the name isn't very good.  Any better ideas?
//
// BOOLFROMPTR is used when you have a pointer or a ULONG_PTR
// and you want to turn it into a BOOL.  In Win32,
// sizeof(BOOL) == sizeof(LPVOID) so a straight cast works.
// In Win64, you have to do it the slow way because pointers are 64-bit.
//
#ifdef _WIN64
#define HIWORD64(p)     ((ULONG_PTR)(p) >> 16)
#define BOOLFROMPTR(p)  ((p) != 0)
#define SPRINTF_PTR		"%016I64x"
#else
#define HIWORD64        HIWORD
#define BOOLFROMPTR(p)  ((BOOL)(p))
#define SPRINTF_PTR		"%08x"
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif

#if defined(DBG)
#define IS_VALID_STRING_PTRA(psz, cch) (!IsBadStringPtrA((psz), (cch)))
#define IS_VALID_STRING_PTRW(psz, cch) (!IsBadStringPtrW((psz), (cch)))
#define IS_VALID_WRITE_BUFFER(pDest, tDest, ctDest) (!IsBadWritePtr((pDest), sizeof(tDest) * (ctDest)))
#else
#define IS_VALID_STRING_PTRA(psz, cch) TRUE
#define IS_VALID_STRING_PTRW(psz, cch) TRUE
#define IS_VALID_WRITE_BUFFER(pDest, tDest, ctDest) TRUE
#endif

#if defined(UNICODE)
#define IS_VALID_STRING_PTR(psz, cch) IS_VALID_STRING_PTRW((psz), (cch))
#else
#define IS_VALID_STRING_PTR(psz, cch) IS_VALID_STRING_PTRA((psz), (cch))
#endif
// -1 means use CP_ACP, but do *not* verify
// kind of a hack, but it's DBG and leaves 99% of callers unchanged
#define CP_ACPNOVALIDATE    ((UINT)-1)

int  SHAnsiToUnicode(LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf);
int  SHAnsiToUnicodeCP(UINT uiCP, LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf);
int  SHAnsiToAnsi(LPCSTR pszSrc, LPSTR pszDst, int cchBuf);
int  SHUnicodeToAnsi(LPCWSTR pwszSrc, LPSTR pszDst, int cchBuf);
int  SHUnicodeToAnsiCP(UINT uiCP, LPCWSTR pwszSrc, LPSTR pszDst, int cchBuf);
int  SHUnicodeToUnicode(LPCWSTR pwzSrc, LPWSTR pwzDst, int cwchBuf);
BOOL DoesStringRoundTripA(LPCSTR pwszIn, LPSTR pszOut, UINT cchOut);
BOOL DoesStringRoundTripW(LPCWSTR pwszIn, LPSTR pszOut, UINT cchOut);

#endif //_UNIANSI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\uniwrap\strtype.cpp ===
//+------------------------------------------------------------------------
//
//  File:       strtype.cpp
//
//  Contents:   widechar character type function (CT_CTYPE1) and (CT_CTYPE3)
//
//  Synopsis:   We do not have wide char support for IsChar functions
//              under Win95.  The Unicode-Wrapper functions we have
//              in core\wrappers all convert to CP_ACP and then call
//              the A version, which means we will have invalid results
//              for any characters which aren't in CP_ACP.
//
//              The solution is to roll our own, which result in these
//              unfortunately large tables.  Here's how it works:
//
//              bits:   fedc ba98 7654 3210
//                      pppp pppp iiib bbbb
//
//              The 'b' bits form a 32-bit bit mask into our data.  The data
//              entrys boolean, and are thus 4-bytes long.  Of the 2^32
//              possible combinations, we in fact have only 218 distinct
//              values of data.  These are stored in adwData.
//
//              The 'p' bits represent a page.  Each page has eight
//              possible entries, represent by 'i'.  In most pages, the
//              bitfields and data are both uniform.
//
//              adwData[abIndex[abType[page]][index]] represents the data
//
//              1 << bits represents the bitmask.
//
//-------------------------------------------------------------------------


#define __BIT_SHIFT 0
#define __INDEX_SHIFT 5
#define __PAGE_SHIFT 8

#define __BIT_MASK 31
#define __INDEX_MASK 7

// straight lookup functions are inlined.

#define ISCHARFUNC(type, wch) \
    (adwData[abIndex[abType1##type[wch>>__PAGE_SHIFT]] \
                          [(wch>>__INDEX_SHIFT)&__INDEX_MASK]] \
            >> (wch&__BIT_MASK)) & 1 
    
const DWORD adwData[218] =
{
#if 0
    0x00000000, 0x7fffffe0, 0xfffffeff, 0xffffffff,  // 0x00-0x03
    0xfffffd3f, 0xffffff00, 0x0000ffff, 0xff800000,  // 0x04-0x07
    0x02ebffff, 0xdfffffff, 0xfffefe2a, 0xbffff000,  // 0x08-0x0b
    0x7ffbffff, 0xffff7ffb, 0xd000ffff, 0xf998ffff,  // 0x0c-0x0f
    0xfff3fdd0, 0x00007fff, 0xfffffe00, 0x7fffffff,  // 0x10-0x13
    0xff000000, 0xffe0e000, 0x7fe00000, 0xffffff3e,  // 0x14-0x17
    0xfffef400, 0x07ffffff, 0xffffffd0, 0x000000ff,  // 0x18-0x1b
    0xd0000000, 0x07f99fff, 0xffbfa3d0, 0x0000000d,  // 0x1c-0x1f
    0xd000d000, 0x07e19fff, 0xffbfb6d0, 0x0000007a,  // 0x20-0x23
    0x07f5dfff, 0xffbfb7d0, 0x80000000, 0xffbfb3d0,  // 0x24-0x27
    0x07e3bd6b, 0x18e3fdd0, 0x07fbbfff, 0xffbff7d0,  // 0x28-0x2b
    0x00000002, 0xffbfffd0, 0xfffeb000, 0xfd000000,  // 0x2c-0x2f
    0x69a40f7f, 0x75360000, 0x0000000d, 0xfd00ffff,  // 0x30-0x33
    0xffffffd1, 0xe0ffffff, 0xffffffe0, 0xfffffdfd,  // 0x34-0x37
    0xfdfdff55, 0xfffffffd, 0xfffffbf8, 0x3bf8f3f0,  // 0x38-0x3b
    0xfff83bf8, 0x0000000f, 0xffd00000, 0x04000000,  // 0x3c-0x3f
    0xfffff81e, 0xffffffee, 0xfff87fff, 0xfffe0000,  // 0x40-0x43
    0xf0000000, 0xfffd0000, 0xfe001f01, 0xfffffefa,  // 0x44-0x47
    0xdbffffff, 0xffffd000, 0x00001fff, 0xffbfffff,  // 0x48-0x4b
    0xbfffffff, 0xffff3fff, 0x0000fff0, 0xfffffff8,  // 0x4c-0x4f
    0x03ffffff, 0x7ffffffe, 0x3f3f3f38, 0x007d0000,  // 0x50-0x53
    0xfff00000, 0x00000001, 0x7fff003f, 0x8000001f,  // 0x54-0x57
    0x8000001e, 0x00000100, 0x00002000, 0xfffffffe,  // 0x58-0x5b
    0xd0000d22, 0x0d000000, 0x3e000000, 0x0000007f,  // 0x5c-0x5f
    0x00400000, 0x00001800, 0x00080011, 0x801fe000,  // 0x60-0x63
    0x003d8000, 0x00000bff, 0x70000000, 0xfffdf800,  // 0x64-0x67
    0x3d008000, 0x0000000b, 0xf99d0100, 0x30003fe0,  // 0x68-0x6b
    0x20000000, 0xe19d0000, 0x0000f800, 0xfddd8000,  // 0x6c-0x6f
    0xf19d0300, 0x00008000, 0x30000000, 0x00000003,  // 0x70-0x73
    0xe3bd0100, 0xfbbd0600, 0xf3bd0100, 0x00014fe1,  // 0x74-0x77
    0x03ff0030, 0x0001ffdd, 0xfafd0000, 0x00000010,  // 0x78-0x7b
    0x00000007, 0xd0070007, 0x00070006, 0xfffeffff,  // 0x7c-0x7f
    0xfe000000, 0x003f003f, 0x003e0000, 0xffffff80,  // 0x80-0x83
    0xe000ffff, 0xffe00000, 0xf8000000, 0xfffffd00,  // 0x84-0x87
    0xfffbffff, 0xffff0000, 0xfffff03f, 0x7bdfffff,  // 0x88-0x8b
    0xff7fffff, 0xfff5e2fe, 0x7f0003ff, 0xfffff8ff,  // 0x8c-0x8f
    0xffff7ffe, 0xffffff01, 0x0000007e, 0x0000001e,  // 0x90-0x93
    0xfffffff1, 0xffff8000, 0xfff0ffff, 0xfffffe1f,  // 0x94-0x97
    0xf000ffff, 0xf87fefff, 0xfef0ebff, 0x7d008000,  // 0x98-0x9b
    0xfefe0000, 0x0000ffd0, 0x00003040, 0x03ff0000,  // 0x9c-0x9f
    0x01ffe000, 0x00008fd0, 0x7e000000, 0xfffffefe,  // 0xa0-0xa3
    0xaaaaaaaa, 0xaaaaaa55, 0x552aaaaa, 0xaaaaaad4,  // 0xa4-0xa7
    0x6b73db8d, 0xa94b7588, 0x0db55552, 0xaaaa682a,  // 0xa8-0xab
    0xaaaaaa00, 0x02eb7fff, 0xdff00000, 0x0000382a,  // 0xac-0xaf
    0xaaaa0000, 0x8000aaaa, 0x5110aaaa, 0xaaa2a880,  // 0xb0-0xb3
    0xaaaaa800, 0xaaaaaa80, 0x00ff00fd, 0x00ff00ff,  // 0xb4-0xb7
    0x00fd0055, 0x00ff0000, 0x00ff00f8, 0x00f800f0,  // 0xb8-0xbb
    0x00f800f8, 0x000003ff, 0x55555555, 0x555555aa,  // 0xbc-0xbf
    0xaad55555, 0x5555552b, 0x948d2472, 0x54948a64,  // 0xc0-0xc3
    0x06daaaad, 0x5555b415, 0x55555500, 0xdfdff5ff,  // 0xc4-0xc7
    0x3ffef026, 0x9f800000, 0x000fffff, 0xfffed600,  // 0xc8-0xcb
    0x1555f000, 0x40005555, 0x28885555, 0x55515440,  // 0xcc-0xcf
    0x555557e0, 0x55555540, 0xff00fd00, 0xff00ff00,  // 0xd0-0xd3
    0xfd00ff00, 0xff00fffd, 0xff00fb00, 0x3b00f300,  // 0xd4-0xd7
    0xff003b00, 0xfe001f00
#else
    0x00000000, 0x07fffffe, 0xff7fffff, 0xffffffff,  // 0x00-0x03
    0xfc3fffff, 0x00ffffff, 0xffff0000, 0x000001ff,  // 0x04-0x07
    0xffffd740, 0xfffffffb, 0x547f7fff, 0x000ffffd,  // 0x08-0x0b
    0xffffdffe, 0xdffeffff, 0xffff0003, 0xffff199f,  // 0x0c-0x0f
    0x033fcfff, 0xfffe0000, 0x007fffff, 0xfffffffe,  // 0x10-0x13
    0x000000ff, 0x000707ff, 0x000007fe, 0x7cffffff,  // 0x14-0x17
    0x002f7fff, 0xffffffe0, 0x03ffffff, 0xff000000,  // 0x18-0x1b
    0x00000003, 0xfff99fe0, 0x03c5fdff, 0xb0000000,  // 0x1c-0x1f
    0x00030003, 0xfff987e0, 0x036dfdff, 0x5e000000,  // 0x20-0x23
    0xfffbafe0, 0x03edfdff, 0x00000001, 0x03cdfdff,  // 0x24-0x27
    0xd63dc7e0, 0x03bfc718, 0xfffddfe0, 0x03effdff,  // 0x28-0x2b
    0x40000000, 0x03fffdff, 0x000d7fff, 0x0000003f,  // 0x2c-0x2f
    0xfef02596, 0x00006cae, 0x30000000, 0xffff003f,  // 0x30-0x33
    0x83ffffff, 0xffffff07, 0x07ffffff, 0x3f3fffff,  // 0x34-0x37
    0xaaff3f3f, 0x3fffffff, 0x1fdfffff, 0x0fcf1fdc,  // 0x38-0x3b
    0x1fdc1fff, 0xf0000000, 0x000003ff, 0x00000020,  // 0x3c-0x3f
    0x781fffff, 0x77ffffff, 0xfffe1fff, 0x00007fff,  // 0x40-0x43
    0x0000000f, 0x00003fff, 0x80f8007f, 0x5f7fffff,  // 0x44-0x47
    0xffffffdb, 0x0003ffff, 0xfff80000, 0xfffffdff,  // 0x48-0x4b
    0xfffffffd, 0xfffcffff, 0x0fff0000, 0x1fffffff,  // 0x4c-0x4f
    0xffffffc0, 0x7ffffffe, 0x1cfcfcfc, 0x00003e00,  // 0x50-0x53
    0x00000fff, 0x80000000, 0xfc00fffe, 0xf8000001,  // 0x54-0x57
    0x78000001, 0x00800000, 0x00040000, 0x7fffffff,  // 0x58-0x5b
    0x44300003, 0x000000b0, 0x0000007c, 0xfe000000,  // 0x5c-0x5f
    0x00000200, 0x00180000, 0x88001000, 0x0007f801,  // 0x60-0x63
    0x00013c00, 0xffd00000, 0x0000000e, 0x001f3fff,  // 0x64-0x67
    0x0001003c, 0xd0000000, 0x0080399f, 0x07fc000c,  // 0x68-0x6b
    0x00000004, 0x00003987, 0x001f0000, 0x00013bbf,  // 0x6c-0x6f
    0x00c0398f, 0x00010000, 0x0000000c, 0xc0000000,  // 0x70-0x73
    0x00803dc7, 0x00603ddf, 0x00803dcf, 0x87f28000,  // 0x74-0x77
    0x0c00ffc0, 0x3bff8000, 0x00003f5f, 0x08000000,  // 0x78-0x7b
    0xe0000000, 0xe000e003, 0x6000e000, 0xffff7fff,  // 0x7c-0x7f
    0x0000007f, 0xfc00fc00, 0x00007c00, 0x01ffffff,  // 0x80-0x83
    0xffff0007, 0x000007ff, 0x0000001f, 0x003fffff,  // 0x84-0x87
    0xffffdfff, 0x0000ffff, 0xfc0fffff, 0xfffff3de,  // 0x88-0x8b
    0xfffffeff, 0x7f47afff, 0xffc000fe, 0xff1fffff,  // 0x8c-0x8f
    0x7ffeffff, 0x80ffffff, 0x7e000000, 0x78000000,  // 0x90-0x93
    0x8fffffff, 0x0001ffff, 0xffff0fff, 0xf87fffff,  // 0x94-0x97
    0xffff000f, 0xfff7fe1f, 0xffd70f7f, 0x0001003e,  // 0x98-0x9b
    0x00007f7f, 0x03ff0000, 0x020c0000, 0x0000ffc0,  // 0x9c-0x9f
    0x0007ff80, 0x03f10000, 0x0000007e, 0x7f7fffff,  // 0xa0-0xa3
    0x55555555, 0xaa555555, 0x555554aa, 0x2b555555,  // 0xa4-0xa7
    0xb1dbced6, 0x11aed295, 0x4aaaadb0, 0x54165555,  // 0xa8-0xab
    0x00555555, 0xfffed740, 0x00000ffb, 0x541c0000,  // 0xac-0xaf
    0x00005555, 0x55550001, 0x5555088a, 0x01154555,  // 0xb0-0xb3
    0x00155555, 0x01555555, 0x3f00ff00, 0xff00ff00,  // 0xb4-0xb7
    0xaa003f00, 0x0000ff00, 0x1f00ff00, 0x0f001f00,  // 0xb8-0xbb
    0x1f001f00, 0xffc00000, 0xaaaaaaaa, 0x55aaaaaa,  // 0xbc-0xbf
    0xaaaaab55, 0xd4aaaaaa, 0x4e243129, 0x2651292a,  // 0xc0-0xc3
    0xb5555b60, 0xa82daaaa, 0x00aaaaaa, 0xffaffbfb,  // 0xc4-0xc7
    0x640f7ffc, 0x000001f9, 0xfffff000, 0x00637fff,  // 0xc8-0xcb
    0x000faaa8, 0xaaaa0002, 0xaaaa1114, 0x022a8aaa,  // 0xcc-0xcf
    0x07eaaaaa, 0x02aaaaaa, 0x003f00ff, 0x00ff00ff,  // 0xd0-0xd3
    0x00ff003f, 0x3fff00ff, 0x00df00ff, 0x00cf00dc,  // 0xd4-0xd7
    0x00dc00ff, 0x00f8007f
#endif
};

const BYTE abIndex[98][8] =
{
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x00
    { 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x02, 0x02 }, // 0x01
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04 }, // 0x02
    { 0x05, 0x00, 0x06, 0x03, 0x03, 0x07, 0x00, 0x00 }, // 0x03
    { 0x00, 0x00, 0x00, 0x00, 0x08, 0x09, 0x0a, 0x0b }, // 0x04
    { 0x0c, 0x03, 0x0d, 0x03, 0x0e, 0x03, 0x0f, 0x10 }, // 0x05
    { 0x00, 0x11, 0x12, 0x13, 0x14, 0x00, 0x06, 0x15 }, // 0x06
    { 0x00, 0x01, 0x16, 0x11, 0x03, 0x17, 0x18, 0x00 }, // 0x07
    { 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20 }, // 0x08
    { 0x21, 0x22, 0x23, 0x00, 0x24, 0x25, 0x00, 0x26 }, // 0x09
    { 0x1d, 0x27, 0x1f, 0x1c, 0x28, 0x29, 0x00, 0x00 }, // 0x0a
    { 0x2a, 0x2b, 0x00, 0x1c, 0x2a, 0x2b, 0x2c, 0x1c }, // 0x0b
    { 0x2a, 0x2d, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00 }, // 0x0c
    { 0x13, 0x2e, 0x2f, 0x00, 0x30, 0x31, 0x32, 0x00 }, // 0x0d
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x33, 0x12 }, // 0x0e
    { 0x03, 0x03, 0x34, 0x03, 0x03, 0x35, 0x03, 0x1a }, // 0x0f
    { 0x03, 0x03, 0x03, 0x03, 0x36, 0x03, 0x03, 0x1a }, // 0x10
    { 0x37, 0x03, 0x38, 0x39, 0x03, 0x3a, 0x3b, 0x3c }, // 0x11
    { 0x00, 0x00, 0x00, 0x00, 0x3d, 0x03, 0x03, 0x3e }, // 0x12
    { 0x3f, 0x00, 0x13, 0x03, 0x40, 0x13, 0x03, 0x41 }, // 0x13
    { 0x19, 0x42, 0x03, 0x03, 0x43, 0x00, 0x00, 0x00 }, // 0x14
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 }, // 0x15
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x2f, 0x00, 0x00 }, // 0x16
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x44, 0x00, 0x00 }, // 0x17
    { 0x03, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x18
    { 0x46, 0x47, 0x48, 0x03, 0x03, 0x49, 0x4a, 0x4b }, // 0x19
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x4c }, // 0x1a
    { 0x03, 0x39, 0x06, 0x03, 0x4d, 0x03, 0x14, 0x4e }, // 0x1b
    { 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x4f }, // 0x1c
    { 0x00, 0x01, 0x01, 0x50, 0x03, 0x51, 0x52, 0x00 }, // 0x1d
    { 0x53, 0x26, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00 }, // 0x1e
    { 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x1f
    { 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x20
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55 }, // 0x21
    { 0x00, 0x56, 0x57, 0x58, 0x00, 0x13, 0x59, 0x59 }, // 0x22
    { 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00 }, // 0x23
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x5b, 0x3e }, // 0x24
    { 0x03, 0x03, 0x2f, 0x5c, 0x5d, 0x00, 0x00, 0x00 }, // 0x25
    { 0x00, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x00 }, // 0x26
    { 0x00, 0x00, 0x5f, 0x00, 0x60, 0x06, 0x44, 0x61 }, // 0x27
    { 0x62, 0x00, 0x63, 0x64, 0x00, 0x00, 0x65, 0x45 }, // 0x28
    { 0x66, 0x3d, 0x67, 0x68, 0x66, 0x69, 0x6a, 0x6b }, // 0x29
    { 0x6c, 0x69, 0x6d, 0x6e, 0x66, 0x3d, 0x6f, 0x00 }, // 0x2a
    { 0x66, 0x3d, 0x70, 0x71, 0x72, 0x73, 0x74, 0x00 }, // 0x2b
    { 0x66, 0x73, 0x75, 0x00, 0x72, 0x73, 0x75, 0x00 }, // 0x2c
    { 0x72, 0x73, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x2d
    { 0x00, 0x77, 0x78, 0x00, 0x00, 0x79, 0x7a, 0x00 }, // 0x2e
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7b }, // 0x2f
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x7d, 0x7e }, // 0x30
    { 0x03, 0x7f, 0x80, 0x81, 0x82, 0x54, 0x06, 0x1c }, // 0x31
    { 0x03, 0x83, 0x4a, 0x03, 0x84, 0x03, 0x03, 0x85 }, // 0x32
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x49 }, // 0x33
    { 0x4c, 0x03, 0x03, 0x36, 0x00, 0x00, 0x00, 0x00 }, // 0x34
    { 0x03, 0x86, 0x85, 0x03, 0x03, 0x03, 0x03, 0x85 }, // 0x35
    { 0x03, 0x03, 0x03, 0x03, 0x87, 0x88, 0x03, 0x89 }, // 0x36
    { 0x8a, 0x03, 0x03, 0x89, 0x00, 0x00, 0x00, 0x00 }, // 0x37
    { 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x00, 0x00 }, // 0x38
    { 0x13, 0x91, 0x00, 0x00, 0x92, 0x00, 0x00, 0x93 }, // 0x39
    { 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00 }, // 0x3a
    { 0x4f, 0x03, 0x44, 0x94, 0x03, 0x95, 0x96, 0x5b }, // 0x3b
    { 0x03, 0x03, 0x03, 0x97, 0x03, 0x03, 0x39, 0x5b }, // 0x3c
    { 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x3d
    { 0x00, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x3e
    { 0x00, 0x98, 0x99, 0x9a, 0x03, 0x03, 0x03, 0x4f }, // 0x3f
    { 0x56, 0x57, 0x58, 0x9b, 0x73, 0x26, 0x00, 0x9c }, // 0x40
    { 0x00, 0x9d, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00 }, // 0x41
    { 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x9d }, // 0x42
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x9f }, // 0x43
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0xa0 }, // 0x44
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x00 }, // 0x45
    { 0x00, 0x00, 0x9d, 0x00, 0x00, 0x00, 0x9d, 0x00 }, // 0x46
    { 0x00, 0x00, 0x00, 0xa1, 0x3e, 0x00, 0x00, 0x00 }, // 0x47
    { 0x9d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x48
    { 0x00, 0x9d, 0xa2, 0xa2, 0x00, 0x00, 0x00, 0x00 }, // 0x49
    { 0x9d, 0xa2, 0xa2, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x4a
    { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa3, 0x00 }, // 0x4b
    { 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab }, // 0x4c
    { 0xac, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x4d
    { 0x00, 0x00, 0x00, 0x00, 0xad, 0xae, 0xaf, 0xb0 }, // 0x4e
    { 0x0c, 0x89, 0x00, 0xa4, 0xb1, 0xa4, 0xb2, 0xb3 }, // 0x4f
    { 0x00, 0x11, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x50
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x2f, 0x00 }, // 0x51
    { 0xa4, 0xa4, 0xa4, 0xa4, 0xb4, 0xa4, 0xa4, 0xb5 }, // 0x52
    { 0xb6, 0xb7, 0xb8, 0xb9, 0xb7, 0xba, 0xbb, 0xbc }, // 0x53
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0x89, 0x00 }, // 0x54
    { 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x55
    { 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x55, 0x02 }, // 0x56
    { 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5 }, // 0x57
    { 0xc6, 0x00, 0x06, 0xc7, 0xc8, 0xc9, 0x00, 0x00 }, // 0x58
    { 0x00, 0x00, 0x00, 0x00, 0x71, 0xca, 0xcb, 0xcc }, // 0x59
    { 0x00, 0x06, 0x0d, 0xbe, 0xcd, 0xbe, 0xce, 0xcf }, // 0x5a
    { 0x00, 0x00, 0x00, 0x13, 0x14, 0x00, 0x00, 0x00 }, // 0x5b
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x12 }, // 0x5c
    { 0xbe, 0xbe, 0xbe, 0xbe, 0xd0, 0xbe, 0xbe, 0xd1 }, // 0x5d
    { 0xd2, 0xd3, 0xd4, 0xd5, 0xd3, 0xd6, 0xd7, 0xd8 }, // 0x5e
    { 0x00, 0x00, 0x00, 0x00, 0x3d, 0x87, 0x06, 0x3e }, // 0x5f
    { 0xd9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x60
    { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 }  // 0x61
};

const BYTE abType1Alpha[256] = // 154
{
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x00,
    0x00, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x00,
    0x0e, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11,
    0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x13, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x16,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x17,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x15, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d
};

BOOL IsCharSpaceW(WCHAR wch)
{
    int nType;

    switch(wch>>8)
    {
        case 0x00: nType = 0x1e; break;
        case 0x20: nType = 0x1f; break;
        case 0x30: nType = 0x20; break;
        case 0xfe: nType = 0x21; break;
        default:   nType = 0x00; break;
    }

#if 0   
    return adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
           & (1<<(wch&__BIT_MASK));
#endif
   
    return (adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
            >>(wch&__BIT_MASK)) & 1;
}

const BYTE abType1Punct[256] = // 32
{
    0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x00,
    0x00, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x00,
    0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30,
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x39, 0x3a, 0x3b, 0x3c, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x3d, 0x00, 0x3e, 0x3f, 0x40
};

const BYTE abType1Digit[256] = // 11
{
    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x00,
    0x00, 0x43, 0x43, 0x44, 0x43, 0x45, 0x46, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48
};

BOOL IsCharDigitW(WCHAR wch) { return ISCHARFUNC(Digit, wch); }

BOOL IsCharXDigitW(WCHAR wch)
{
    int nType;

    switch(wch>>8)
    {
        case 0x00: nType = 0x49; break;
        case 0xff: nType = 0x4a; break;
        default:   nType = 0x00; break;
    }

    return (adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
            >> (wch&__BIT_MASK)) & 1;
#if 0
    return adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
           & (1<<(wch&__BIT_MASK));
#endif
}

const BYTE abType1Upper[256] = // 12
{
    0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x53,
    0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55
};

const BYTE abType1Lower[256] = // 13
{
    0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x5c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d, 0x5e,
    0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x61
};


BOOL IsCharPunctW(WCHAR wch) { return ISCHARFUNC(Punct, wch); }


BOOL IsCharCntrlW(WCHAR wch)
{
    return    (unsigned)(wch - 0x0000) <= (0x001f - 0x0000)
           || (unsigned)(wch - 0x007f) <= (0x009f - 0x007f);
}

// NB (cthrash) WCH_NBSP is considered blank, for compatibility.

BOOL IsCharBlankW(WCHAR wch)
{
    return    wch == 0x0009
           || wch == 0x0020
           || wch == 0x00a0
           || wch == 0x3000
           || wch == 0xfeff;
}


BOOL WINAPI IsCharAlphaWrapW(WCHAR wch) { return ISCHARFUNC(Alpha, wch); }
BOOL WINAPI IsCharUpperWrapW(WCHAR wch) { return ISCHARFUNC(Upper, wch); }
BOOL WINAPI IsCharLowerWrapW(WCHAR wch) { return ISCHARFUNC(Lower, wch); }

BOOL WINAPI IsCharAlphaNumericWrapW(WCHAR wch)
{
    return ISCHARFUNC(Alpha, wch) || ISCHARFUNC(Digit, wch);
}


static const BYTE abType3PageSub[256] = 
{
    0x00, 0x80, 0x81, 0x82, 0x00, 0x83, 0x84, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 
    0x00, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x8e, 0x8f, 0x90, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x91, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x20, 0x92, 0x00, 0x00, 0x93, 0x94, 0x00
};

static const BYTE abType3Page0[256] = 
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 
    0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 0x09, 0x09, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x09, 0x09, 0x01, 0x09, 0x09, 0x01, 
    0x01, 0x01, 0x00, 0x01, 0x09, 0x01, 0x01, 0x09, 
    0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE abType3Page32[256] = 
{
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 
    0x11, 0x11, 0x01, 0x01, 0x11, 0x11, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x09, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE abType3Page48[256] = 
{
    0x11, 0x11, 0x11, 0x00, 0x00, 0x20, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x11, 0x11, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x06, 0x06, 0x06, 0x06, 0x06, 0x01, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x06, 0x06, 0x16, 0x16, 0x04, 0x04, 0x00, 
    0x00, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x12, 0x02, 0x12, 0x02, 
    0x12, 0x02, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x02, 0x02, 0x12, 0x02, 0x02, 0x12, 0x02, 0x02, 
    0x12, 0x02, 0x02, 0x12, 0x02, 0x02, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x02, 0x12, 
    0x02, 0x02, 0x12, 0x12, 0x02, 0x02, 0x02, 0x02, 
    0x02, 0x02, 0x02, 0x13, 0x06, 0x02, 0x02, 0x00
};

static const BYTE abType3Page255[256] = 
{
    0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0x11, 0x11, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x00, 
    0x00, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0e, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


struct tagType3DualValue
{
    DWORD   adwBitfield[8];
    DWORD   adwValue[2];
}
const aType3DualValue[21] =
{
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page1
      0x00000000, 0x0000000f, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page2
      0x00000000, 0x3f000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x04000000, 0x000000b0,   // Page3
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0xf8000000, 0x00000000, 0x00000200,   // Page5
      0x40000000, 0x00000009, 0x00180000, 0x00000000, 0x00000001 },
    { 0x88001000, 0x00000000, 0x00000000, 0x00003c00, 0x00000000,   // Page6
      0x00000000, 0x00100000, 0x00000200, 0x00000000, 0x00000001 },
    { 0x00000000, 0x80008000, 0x0c008040, 0x00000000, 0x00000000,   // Page14
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page31
      0xe0000000, 0xe000e003, 0x6000e000, 0x00000000, 0x00000001 },
    { 0x00800000, 0x00000000, 0x00000000, 0x00000000, 0xffff0000,   // Page33
      0xffffffff, 0xffffffff, 0x000007ff, 0x00000000, 0x00000001 },
    { 0x40000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page34
      0x00000000, 0x00000000, 0xfffc0000, 0x00000001, 0x00000000 },
    { 0x00000002, 0x00000000, 0x00000000, 0xf8000000, 0xffffffff,   // Page35
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0x00000000, 0xffffffe0, 0xfffff800, 0xffffffff, 0xffffffff,   // Page36
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffc00000,   // Page37
      0x00002000, 0x00000000, 0xffff8000, 0x00000001, 0x00000000 },
    { 0x03f00000, 0x00000000, 0x00000000, 0xffff0000, 0xffffffff,   // Page38
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0xfffff3de, 0xfffffeff, 0x7f47afff, 0x000000fe, 0xff100000,   // Page39
      0x7ffeffff, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0xfffe0000, 0xffffffff, 0x0000001f, 0x00000000,   // Page49
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000010 },
    { 0x00000000, 0x00000000, 0x00000000, 0x80000000, 0x00000000,   // Page50
      0x00000000, 0x00000fff, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0xff000000, 0x0001ffff, 0x00000000,   // Page51
      0x00000000, 0x00000000, 0x7fffffff, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page159
      0xffffffc0, 0xffffffff, 0xffffffff, 0x00000020, 0x00000000 },
    { 0x00000000, 0xffffc000, 0xffffffff, 0xffffffff, 0xffffffff,   // Page250
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000020, 0x00000000 },
    { 0x00000000, 0xc0000000, 0x00000000, 0x00000000, 0x00000000,   // Page253
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0xfff90000, 0xfef7fe1f, 0x00000f77, 0x00000000,   // Page254
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 }
};


//
//  CType 3 Flag Bits.
//
//  In the interest of reducing our table complexity, we've here a reduced
//  bitfield.  Only those bits currently used by IE4 are returned by
//  GetStringType3Ex().
//

// These are the flags are they are defined in winnls.h
//

// C3_NONSPACING    0x0001
// C3_DIACRITIC     0x0002
// C3_VOWELMARK     0x0004
// C3_SYMBOL        0x0008
// C3_KATAKANA      0x0010
// C3_HIRAGANA      0x0020
// C3_HALFWIDTH     0x0040
// C3_FULLWIDTH     0x0080
// C3_IDEOGRAPH     0x0100
// C3_KASHIDA       0x0200
// C3_LEXICAL       0x0400
// C3_ALPHA         0x8000

// The supported flags are encoded by shifting them to the right 3 bits.

// C3_SYMBOL       0x0001
// C3_KATAKANA     0x0002
// C3_HIRAGANA     0x0004
// C3_HALFWIDTH    0x0008
// C3_FULLWIDTH    0x0010
// C3_IDEOGRAPH    0x0020

// GetStringType3Ex returns the correct Win32 flags NOT the compressed flags.


BOOL 
GetStringType3ExW(
    LPCWSTR lpSrcStr,    // string arg
    int     cchSrc,      // length (or -1)
    LPWORD  lpCharType ) // output buffer
{
    LPCWSTR  lpStop = lpSrcStr + ((cchSrc == -1) ? MAXLONG : cchSrc);

    while (lpSrcStr < lpStop)
    {
        WCHAR wch = *lpSrcStr++;
        WORD wCharType;
        BYTE bPageSub;

        if (!wch && cchSrc == -1)
            break;

        switch (wch & (unsigned int)0xff00)
        {
            case 0x0000:
                wCharType = abType3Page0[wch];         // Page0: 4 values
                break;
            case 0x2000:
                wCharType = abType3Page32[wch & 0xff]; // Page32: 4 values
                break;
            case 0x3000:
                wCharType = abType3Page48[wch & 0xff];  // Page48: 10 values
                break;
            case 0xff00:
                wCharType = abType3Page255[wch & 0xff]; // Page255: 7 values
                break;
            default:
                bPageSub = abType3PageSub[wch>>8];

                if (bPageSub & 0x80)                  // 21 pages have 2 values
                {
                    const struct tagType3DualValue *p = aType3DualValue +
                        (bPageSub & 0x7f);

                    wCharType = (BYTE) p->adwValue[(p->adwBitfield[(wch>>5)&7]
                        >> (wch & 0x1f)) & 1];
                }
                else                                  // 231 pages have 1 value
                {
                    wCharType = bPageSub;
                }
                break;
        }

        *lpCharType++ = wCharType << 3;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\uniwrap\uniwrap.h ===
//
// uniwrap.h
//
// Unicode wrappers
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//
// based on code from shell\shlwapi\unicwrap.*
//

#ifndef _uniwrap_h_
#define _uniwrap_h_

extern BOOL g_fUnicodeWrapsInitialized;

#endif //_uniwrap_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\uniwrap\wraputl.cpp ===
//
// uniwrap.cpp
//
// Unicode wrappers
//
// Copyright(C) Microsoft Corporation 2000
// Author: Nadim Abdo (nadima)
//
// Public interface to the wrappers
//

#include "stdafx.h"

BOOL g_bRunningOnNT = FALSE;
BOOL g_fUnicodeWrapsInitialized = FALSE;


//
// The policy behind the wrappers is:
// we run unicode internally for everything.
//
// The wrappers either thunk directly to the unicode system API's
// if they are available or convert to ansi and call the ANSI versions.
//
// If we need 'W' function that is not available on win9x then
// it has to be dynamically bound.
// We can statically bind to the 'A' versions.
//
//

CUnicodeWrapper::CUnicodeWrapper()
{
    //do nada
}

CUnicodeWrapper::~CUnicodeWrapper()
{
    //do nada
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// DO NOT USE ANY TRC FUNCTIONS UNTIL THE WRAPPERS ARE INITIALIZED
//
// This means no DC_BEGIN_FN calls until we wrappers are ready.
BOOL CUnicodeWrapper::InitializeWrappers()
{
    //
    // Determine if we're running on a unicode platform
    // (call A api as that is always present, we can't use
    //  a wrapper function before knowing how to wrap)

    OSVERSIONINFOA   osVersionInfo;
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    if (GetVersionExA(&osVersionInfo))
    {
        //NT is unicode, everything else is NOT.
        //If the CE folks do a port of the shell to their
        //platform they will need to look into this
        g_bRunningOnNT = (osVersionInfo.dwPlatformId !=
                          VER_PLATFORM_WIN32_WINDOWS);
    }
    else
    {
        //Treat as non-fatal, just use ANSI thunks they are slower
        //but always present
        g_bRunningOnNT = FALSE;

    }

    g_fUnicodeWrapsInitialized  = TRUE;
    return TRUE;
}

BOOL CUnicodeWrapper::CleanupWrappers()
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\uniwrap\uniwrap.cpp ===
//
// uniwrap.cpp
//
// Unicode wrappers
//
// Copyright(C) Microsoft Corporation 2000
//
// Heavily based on code from shell\shlwapi\unicwrap.*
// Modifications/additions - Nadim Abdo (nadima)
//

#include "stdafx.h"

#include "uniwrap.h"
#include "cstrinout.h"

//Just include wrap function prototypes
//no wrappers (it would be silly to wrap wrappers)
#define DONOT_REPLACE_WITH_WRAPPERS
#include "uwrap.h"

#ifdef InRange
#undef InRange
#endif
#define InRange(id, idFirst, idLast)      ((UINT)(id-idFirst) <= (UINT)(idLast-idFirst))

//
//  Do this in every wrapper function to make sure the wrapper
//  prototype matches the function it is intending to replace.
//
#define VALIDATE_PROTOTYPE(f) if (f##W == f##WrapW) 0
#define VALIDATE_PROTOTYPE_DELAYLOAD(fWrap, fDelay) if (fDelay##W == fWrap##WrapW) 0
#define VALIDATE_OUTBUF(s, cch)
#define UseUnicodeShell32() ( g_bRunningOnNT )


// compiler should do this opt for us (call-thunk => jmp), but it doesn't
// so we do it ourselves (i raided it and they're adding it to vc6.x so
// hopefully we'll get it someday)
#if _X86_
#define PERF_ASM        1       // turn on inline-asm opts
#endif

// todo??? #ifdef SUNDOWN    #undef PERF_ASM

#if PERF_ASM // {

// BUGBUG workaround compiler bug
// compiler should know this, but doesn't, so we make it explicit
#define IMPORT_PTR  dword ptr       // BUGBUG sundown


//***   FORWARD_AW, THUNK_AW -- simple forwarders and thunks
// ENTRY/EXIT
//  - declare function w/ FORWARD_API
//  - if you're using THUNK_AW, create the 'A' thunk helper
//  - make the body FORWARD_AW or THUNK_AW.
//  - make sure there's *no* other code in the func.  o.w. you'll get bogus
//  code.
// EXAMPLE
//  int FORWARD_API WINAPI FooWrapW(int i, void *p)
//  {
//      VALIDATE_PROTOTYPE(Foo);
//
//      FORWARD_AW(Foo, (i, p));
//  }
//
//  int WINAPI BarAThunk(HWND hwnd, WPARAM wParam)
//  {
//      ... ansi thunk helper ...
//  }
//
//  int FORWARD_API WINAPI BarWrapW(HWND hwnd, WPARAM wParam)
//  {
//      VALIDATE_PROTOTYPE(Bar);
//
//      THUNK_AW(Bar, (hwnd, wParam));
//  }
// NOTES
//  - WARNING: can only be used for 'simple' thunks (NAKED => no non-global
//  vars, etc.).
//  - WARNING: calling func must be declared FORWARD_API.  if not you'll
//  get bogus code.  happily if you forget you get the (obscure) error
//  message "error C4035: 'FooW': no return value"
//  - note that the macro ends up w/ an extra ";" from the caller, oh well...
//  - TODO: perf: better still would be to have a g_pfnCallWndProc, init
//  it 1x, and then jmp indirect w/o the test.  it would cost us a ptr but
//  we only do it for the top-2 funcs (CallWindowProc and SendMessage)
#define FORWARD_API     _declspec(naked)

#define FORWARD_AW(_fn, _args) \
    if (g_bRunningOnNT) { \
        _asm { jmp     IMPORT_PTR _fn##W } \
    } \
    _asm { jmp     IMPORT_PTR _fn##A }

#define THUNK_AW(_fn, _args) \
    if (g_bRunningOnNT) { \
        _asm { jmp     IMPORT_PTR _fn##W } \
    } \
    _asm { jmp     _fn##AThunk }    // n.b. no IMPORT_PTR

#else // }{

#define FORWARD_API     /*NOTHING*/

#define FORWARD_AW(_fn, _args) \
    if (g_bRunningOnNT) { \
        return _fn##W _args; \
    } \
    return _fn##A _args;

#define THUNK_AW(_fn, _args) \
    if (g_bRunningOnNT) { \
        return _fn##W _args; \
    } \
    return _fn##AThunk _args;

#endif // }

//
//  Windows 95 and NT5 do not have the hbmpItem field in their MENUITEMINFO
//  structure.
//
#if (WINVER >= 0x0500)
#define MENUITEMINFOSIZE_WIN95  FIELD_OFFSET(MENUITEMINFOW, hbmpItem)
#else
#define MENUITEMINFOSIZE_WIN95  sizeof(MENUITEMINFOW)
#endif


//
//  Some W functions are implemented on Win95, so complain if anybody
//  writes thunks for them.
//
//  Though Win95's implementation of TextOutW is incomplete for FE languages.
//  Remove this section when we implement FE-aware TextOutW for Win95.
//
#if defined(TextOutWrap)
#error Do not write thunks for TextOutW; Win95 supports it.
#endif

#define SEE_MASK_FILEANDURL 0x00400000  // defined in private\inc\shlapip.h !
#define MFT_NONSTRING 0x00000904  // defined in private\inc\winuserp.h !

#ifdef FUS9xWRAPAPI
#undef FUS9xWRAPAPI
#endif

#define FUS9xWRAPAPI(type) STDAPI_(type)


#include "strtype.cpp"

//+------------------------------------------------------------------------
//
//  Implementation of the wrapped functions
//  This part courtesy of shlwapi's unicwrap.c
//
//-------------------------------------------------------------------------

#define NEED_COMDLG32_WRAPPER
#define NEED_USER32_WRAPPER
#define NEED_KERNEL32_WRAPPER
#define NEED_ADVAPI32_WRAPPER
#define NEED_GDI32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
AppendMenuWrapW(
               HMENU   hMenu,
               UINT    uFlags,
               UINT_PTR uIDnewItem,
               LPCWSTR lpnewItem)
{
    VALIDATE_PROTOTYPE(AppendMenu);

    // Make the InsertMenu wrapper do all the work
    return InsertMenuWrapW(hMenu, (UINT)-1,
                           uFlags | MF_BYPOSITION, uIDnewItem, lpnewItem);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

LRESULT FORWARD_API WINAPI
CallWindowProcWrapW(
                   WNDPROC lpPrevWndFunc,
                   HWND    hWnd,
                   UINT    Msg,
                   WPARAM  wParam,
                   LPARAM  lParam)
{
    VALIDATE_PROTOTYPE(CallWindowProc);

    // perf: better still would be to have a g_pfnCallWndProc, init it 1x,
    // and then jmp indirect w/o the test.  it would cost us a ptr but we
    // only do it for the top-2 funcs (CallWindowProc and SendMessage)
    FORWARD_AW(CallWindowProc, (lpPrevWndFunc, hWnd, Msg, wParam, lParam));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

STDAPI_(BOOL FORWARD_API) CallMsgFilterWrapW(LPMSG lpMsg, int nCode)
{
    VALIDATE_PROTOTYPE(CallMsgFilter);

    FORWARD_AW(CallMsgFilter, (lpMsg, nCode));
}

#endif // NEED_USER32_WRAPPER



//----------------------------------------------------------------------
//
// function:    CharLowerWrapW( LPWSTR pch )
//
// purpose:     Converts character to lowercase.  Takes either a pointer
//              to a string, or a character masquerading as a pointer.
//              In the later case, the HIWORD must be zero.  This is
//              as spec'd for Win32.
//
// returns:     Lowercased character or string.  In the string case,
//              the lowercasing is done inplace.
//
//----------------------------------------------------------------------

#ifdef NEED_USER32_WRAPPER

LPWSTR WINAPI
CharLowerWrapW( LPWSTR pch )
{
    VALIDATE_PROTOTYPE(CharLower);

    if (g_bRunningOnNT)
    {
        return CharLowerW( pch );
    }

    if (!HIWORD64(pch))
    {
        WCHAR ch = (WCHAR)(LONG_PTR)pch;

        CharLowerBuffWrapW( &ch, 1 );

        pch = (LPWSTR)MAKEINTATOM(ch);
    }
    else
    {
        CharLowerBuffWrapW( pch, lstrlenW(pch) );
    }

    return pch;
}

#endif // NEED_USER32_WRAPPER


//----------------------------------------------------------------------
//
// function:    CharLowerBuffWrapW( LPWSTR pch, DWORD cch )
//
// purpose:     Converts a string to lowercase.  String must be cch
//              characters in length.
//
// returns:     Character count (cch).  The lowercasing is done inplace.
//
//----------------------------------------------------------------------

#ifdef NEED_USER32_WRAPPER

DWORD WINAPI
CharLowerBuffWrapW( LPWSTR pch, DWORD cchLength )
{
    VALIDATE_PROTOTYPE(CharLowerBuff);

    if (g_bRunningOnNT)
    {
        return CharLowerBuffW( pch, cchLength );
    }

    DWORD cch;

    for ( cch = cchLength; cch-- ; pch++ )
    {
        WCHAR ch = *pch;

        if (IsCharUpperWrapW(ch))
        {
            if (ch < 0x0100)
            {
                *pch += 32;             // Get Latin-1 out of the way first
            }
            else if (ch < 0x0531)
            {
                if (ch < 0x0391)
                {
                    if (ch < 0x01cd)
                    {
                        if (ch <= 0x178)
                        {
                            if (ch < 0x0178)
                            {
                                *pch += (ch == 0x0130) ? 0 : 1;
                            }
                            else
                            {
                                *pch -= 121;
                            }
                        }
                        else
                        {
                            static const BYTE abLookup[] =
                            {           // 0/8  1/9  2/a  3/b  4/c  5/d  6/e  7/f
                                /* 0x0179-0x17f */1,   0,   1,   0,   1,   0,   0,
                                /* 0x0180-0x187 */      0, 210,   1,   0,   1,   0, 206,   1,
                                /* 0x0188-0x18f */      0, 205, 205,   1,   0,   0,  79, 202,
                                /* 0x0190-0x197 */    203,   1,   0, 205, 207,   0, 211, 209,
                                /* 0x0198-0x19f */      1,   0,   0,   0, 211, 213,   0, 214,
                                /* 0x01a0-0x1a7 */      1,   0,   1,   0,   1,   0,   0,   1,
                                /* 0x01a8-0x1af */      0, 218,   0,   0,   1,   0, 218,   1,
                                /* 0x01b0-0x1b7 */      0, 217, 217,   1,   0,   1,   0, 219,
                                /* 0x01b8-0x1bf */      1,   0,   0,   0,   1,   0,   0,   0,
                                /* 0x01c0-0x1c7 */      0,   0,   0,   0,   2,   0,   0,   2,
                                /* 0x01c8-0x1cb */      0,   0,   2,   0
                            };

                            *pch += abLookup[ch-0x0179];
                        }
                    }
                    else if (ch < 0x0386)
                    {
                        switch (ch)
                        {
                            case 0x01f1: *pch += 2; break;
                            case 0x01f2: break;
                            default: *pch += 1;
                        }
                    }
                    else
                    {
                        static const BYTE abLookup[] =
                        { 38, 0, 37, 37, 37, 0, 64, 0, 63, 63};

                        *pch += abLookup[ch-0x0386];
                    }
                }
                else
                {
                    if (ch < 0x0410)
                    {
                        if (ch < 0x0401)
                        {
                            if (ch < 0x03e2)
                            {
                                if (!InRange(ch, 0x03d2, 0x03d4) &&
                                    !(InRange(ch, 0x3da, 0x03e0) & !(ch & 1)))
                                {
                                    *pch += 32;
                                }
                            }
                            else
                            {
                                *pch += 1;
                            }
                        }
                        else
                        {
                            *pch += 80;
                        }
                    }
                    else
                    {
                        if (ch < 0x0460)
                        {
                            *pch += 32;
                        }
                        else
                        {
                            *pch += 1;
                        }
                    }
                }
            }
            else
            {
                if (ch < 0x2160)
                {
                    if (ch < 0x1fba)
                    {
                        if (ch < 0x1f08)
                        {
                            if (ch < 0x1e00)
                            {
                                *pch += 48;
                            }
                            else
                            {
                                *pch += 1;
                            }
                        }
                        else if (!(InRange(ch, 0x1f88, 0x1faf) && (ch & 15)>7))
                        {
                            *pch -= 8;
                        }
                    }
                    else
                    {
                        static const BYTE abLookup[] =
                        {  // 8    9    a    b    c    d    e    f
                            0,   0,  74,  74,   0,   0,   0,   0,
                            86,  86,  86,  86,   0,   0,   0,   0,
                            8,   8, 100, 100,   0,   0,   0,   0,
                            8,   8, 112, 112,   7,   0,   0,   0,
                            128, 128, 126, 126,   0,   0,   0,   0
                        };
                        int i = (ch-0x1fb0);

                        *pch -= (int)abLookup[((i>>1) & ~7) | (i & 7)];
                    }
                }
                else
                {
                    if (ch < 0xff21)
                    {
                        if (ch < 0x24b6)
                        {
                            *pch += 16;
                        }
                        else
                        {
                            *pch += 26;
                        }
                    }
                    else
                    {
                        *pch += 32;
                    }
                }
            }
        }
        else
        {
            // These are Unicode Number Forms.  They have lowercase counter-
            // parts, but are not considered uppercase.  Why, I don't know.

            if (InRange(ch, 0x2160, 0x216f))
            {
                *pch += 16;
            }
        }
    }

    return cchLength;
}
#endif // NEED_USER32_WRAPPER


//
// BUGBUG - Do CharNextWrap and CharPrevWrap need to call the
//          CharNextW, CharPrevW on WinNT?  Couldn't these be MACROS?
//

LPWSTR WINAPI
CharNextWrapW(LPCWSTR lpszCurrent)
{
    VALIDATE_PROTOTYPE(CharNext);

    if (*lpszCurrent)
    {
        return(LPWSTR) lpszCurrent + 1;
    }
    else
    {
        return(LPWSTR) lpszCurrent;
    }
}

LPWSTR WINAPI
CharPrevWrapW(LPCWSTR lpszStart, LPCWSTR lpszCurrent)
{
    VALIDATE_PROTOTYPE(CharPrev);

    if (lpszCurrent == lpszStart)
    {
        return(LPWSTR) lpszStart;
    }
    else
    {
        return(LPWSTR) lpszCurrent - 1;
    }
}


//----------------------------------------------------------------------
//
// function:    CharUpperWrapW( LPWSTR pch )
//
// purpose:     Converts character to uppercase.  Takes either a pointer
//              to a string, or a character masquerading as a pointer.
//              In the later case, the HIWORD must be zero.  This is
//              as spec'd for Win32.
//
// returns:     Uppercased character or string.  In the string case,
//              the uppercasing is done inplace.
//
//----------------------------------------------------------------------

#ifdef NEED_USER32_WRAPPER

LPWSTR WINAPI
CharUpperWrapW( LPWSTR pch )
{
    VALIDATE_PROTOTYPE(CharUpper);

    if (g_bRunningOnNT)
    {
        return CharUpperW( pch );
    }

    if (!HIWORD64(pch))
    {
        WCHAR ch = (WCHAR)(LONG_PTR)pch;

        CharUpperBuffWrapW( &ch, 1 );

        pch = (LPWSTR)MAKEINTATOM(ch);
    }
    else
    {
        CharUpperBuffWrapW( pch, lstrlenW(pch) );
    }

    return pch;
}

#endif // NEED_USER32_WRAPPER


//----------------------------------------------------------------------
//
// function:    CharUpperBuffWrapW( LPWSTR pch, DWORD cch )
//
// purpose:     Converts a string to uppercase.  String must be cch
//              characters in length.  Note that this function is
//              is messier that CharLowerBuffWrap, and the reason for
//              this is many Unicode characters are considered uppercase,
//              even when they don't have an uppercase counterpart.
//
// returns:     Character count (cch).  The uppercasing is done inplace.
//
//----------------------------------------------------------------------

#ifdef NEED_USER32_WRAPPER

DWORD WINAPI
CharUpperBuffWrapW( LPWSTR pch, DWORD cchLength )
{
    VALIDATE_PROTOTYPE(CharUpperBuff);

    if (g_bRunningOnNT)
    {
        return CharUpperBuffW( pch, cchLength );
    }

    DWORD cch;

    for ( cch = cchLength; cch-- ; pch++ )
    {
        WCHAR ch = *pch;

        if (IsCharLowerWrapW(ch))
        {
            if (ch < 0x00ff)
            {
                *pch -= ((ch != 0xdf) << 5);
            }
            else if (ch < 0x03b1)
            {
                if (ch < 0x01f5)
                {
                    if (ch < 0x01ce)
                    {
                        if (ch < 0x017f)
                        {
                            if (ch < 0x0101)
                            {
                                *pch += 121;
                            }
                            else
                            {
                                *pch -= (ch != 0x0131 &&
                                         ch != 0x0138 &&
                                         ch != 0x0149);
                            }
                        }
                        else if (ch < 0x01c9)
                        {
                            static const BYTE abMask[] =
                            {                       // 6543210f edcba987
                                0xfc, 0xbf,         // 11111100 10111111
                                0xbf, 0x67,         // 10111111 01100111
                                0xff, 0xef,         // 11111111 11101111
                                0xff, 0xf7,         // 11111111 11110111
                                0xbf, 0xfd          // 10111111 11111101
                            };

                            int i = ch - 0x017f;

                            *pch -= ((abMask[i>>3] >> (i&7)) & 1) +
                                    (ch == 0x01c6);
                        }
                        else
                        {
                            *pch -= ((ch != 0x01cb)<<1);
                        }
                    }
                    else
                    {
                        if (ch < 0x01df)
                        {
                            if (ch < 0x01dd)
                            {
                                *pch -= 1;
                            }
                            else
                            {
                                *pch -= 79;
                            }
                        }
                        else
                        {
                            *pch -= 1 + (ch == 0x01f3) -
                                    InRange(ch,0x01f0,0x01f2);
                        }
                    }
                }
                else if (ch < 0x0253)
                {
                    *pch -= (ch < 0x0250);
                }
                else if (ch < 0x03ac)
                {
                    static const BYTE abLookup[] =
                    {                // 0/8  1/9  2/a  3/b  4/c  5/d  6/e  7/f
                        /* 0x0253-0x0257 */210, 206,   0, 205, 205,
                        /* 0x0258-0x025f */   0, 202,   0, 203,   0,   0,   0,   0,
                        /* 0x0260-0x0267 */ 205,   0,   0, 207,   0,   0,   0,   0,
                        /* 0x0268-0x026f */ 209, 211,   0,   0,   0,   0,   0, 211,
                        /* 0x0270-0x0277 */   0,   0, 213,   0,   0, 214,   0,   0,
                        /* 0x0278-0x027f */   0,   0,   0,   0,   0,   0,   0,   0,
                        /* 0x0280-0x0287 */   0,   0,   0, 218,   0,   0,   0,   0,
                        /* 0x0288-0x028f */ 218,   0, 217, 217,   0,   0,   0,   0,
                        /* 0x0290-0x0297 */   0,   0, 219
                    };

                    if (ch <= 0x0292)
                    {
                        *pch -= abLookup[ch - 0x0253];
                    }
                }
                else
                {
                    *pch -= (ch == 0x03b0) ? 0 : (37 + (ch == 0x03ac));
                }
            }
            else
            {
                if (ch < 0x0561)
                {
                    if (ch < 0x0451)
                    {
                        if (ch < 0x03e3)
                        {
                            if (ch < 0x03cc)
                            {
                                *pch -= 32 - (ch == 0x03c2);
                            }
                            else
                            {
                                int i = (ch < 0x03d0);
                                *pch -= (i<<6) - i + (ch == 0x03cc);
                            }
                        }
                        else if (ch < 0x0430)
                        {
                            *pch -= (ch < 0x03f0);
                        }
                        else
                        {
                            *pch -= 32;
                        }
                    }
                    else if (ch < 0x0461)
                    {
                        *pch -= 80;
                    }
                    else
                    {
                        *pch -= 1;
                    }
                }
                else
                {
                    if (ch < 0x1fb0)
                    {
                        if (ch < 0x1f70)
                        {
                            if (ch < 0x1e01)
                            {
                                int i = ch != 0x0587 && ch < 0x10d0;
                                *pch -= ((i<<5)+(i<<4)); /* 48 */
                            }
                            else if (ch < 0x1f00)
                            {
                                *pch -= !InRange(ch, 0x1e96, 0x1e9a);
                            }
                            else
                            {
                                int i = !InRange(ch, 0x1f50, 0x1f56)||(ch & 1);
                                *pch += (i<<3);
                            }
                        }
                        else
                        {
                            static const BYTE abLookup[] =
                            { 74, 86, 86, 100, 128, 112, 126};

                            if ( ch <= 0x1f7d )
                            {
                                *pch += abLookup[(ch-0x1f70)>>1];
                            }
                        }
                    }
                    else
                    {
                        if (ch < 0x24d0)
                        {
                            if (ch < 0x1fe5)
                            {
                                *pch += (0x0023 & (1<<(ch&15))) ? 8 : 0;
                            }
                            else if (ch < 0x2170)
                            {
                                *pch += (0x0023 & (1<<(ch&15))) ? 7 : 0;
                            }
                            else
                            {
                                *pch -= ((ch > 0x24b5)<<4);
                            }
                        }
                        else if (ch < 0xff41)
                        {
                            int i = !InRange(ch, 0xfb00, 0xfb17);
                            *pch -= (i<<4)+(i<<3)+(i<<1); /* 26 */
                        }
                        else
                        {
                            *pch -= 32;
                        }
                    }
                }
            }
        }
        else
        {
            int i = InRange(ch, 0x2170, 0x217f);
            *pch -= (i<<4);
        }
    }

    return cchLength;
}
#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

int FORWARD_API WINAPI
CopyAcceleratorTableWrapW(
                         HACCEL  hAccelSrc,
                         LPACCEL lpAccelDst,
                         int     cAccelEntries)
{
    VALIDATE_PROTOTYPE(CopyAcceleratorTable);

    FORWARD_AW(CopyAcceleratorTable, (hAccelSrc, lpAccelDst, cAccelEntries));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HACCEL FORWARD_API WINAPI
CreateAcceleratorTableWrapW(LPACCEL lpAccel, int cEntries)
{
    VALIDATE_PROTOTYPE(CreateAcceleratorTable);

    FORWARD_AW(CreateAcceleratorTable, (lpAccel, cEntries));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_GDI32_WRAPPER
typedef HDC (*FnCreateHDCA)(LPCSTR, LPCSTR, LPCSTR, CONST DEVMODEA *);

HDC WINAPI
CreateHDCWrapW(
              LPCWSTR             lpszDriver,
              LPCWSTR             lpszDevice,
              LPCWSTR             lpszOutput,
              CONST DEVMODEW *    lpInitData,
              FnCreateHDCA        pfn)
{
    DEVMODEA *  pdevmode = NULL;
    CStrIn      strDriver(lpszDriver);
    CStrIn      strDevice(lpszDevice);
    CStrIn      strOutput(lpszOutput);
    HDC         hdcReturn = 0;

    if (lpInitData)
    {
        pdevmode = (DEVMODEA *) LocalAlloc( LPTR, lpInitData->dmSize + lpInitData->dmDriverExtra );

        if (pdevmode)
        {
            // LPBYTE->LPSTR casts below
            SHUnicodeToAnsi(lpInitData->dmDeviceName, (LPSTR)pdevmode->dmDeviceName, ARRAYSIZE(pdevmode->dmDeviceName));
            memcpy(&pdevmode->dmSpecVersion,
                   &lpInitData->dmSpecVersion,
                   FIELD_OFFSET(DEVMODEW,dmFormName) - FIELD_OFFSET(DEVMODEW,dmSpecVersion));
            SHUnicodeToAnsi(lpInitData->dmFormName, (LPSTR)pdevmode->dmFormName, ARRAYSIZE(pdevmode->dmFormName));
            memcpy(&pdevmode->dmLogPixels,
                   &lpInitData->dmLogPixels,
                   lpInitData->dmDriverExtra + lpInitData->dmSize - FIELD_OFFSET(DEVMODEW, dmLogPixels));

            pdevmode->dmSize -= (sizeof(BCHAR) - sizeof(char)) * (CCHDEVICENAME + CCHFORMNAME);
        }
    }

    hdcReturn = (*pfn)(strDriver, strDevice, strOutput, pdevmode);

    if (pdevmode)
    {
        LocalFree(pdevmode);
    }

    return hdcReturn;
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

HDC WINAPI
CreateDCWrapW(
             LPCWSTR             lpszDriver,
             LPCWSTR             lpszDevice,
             LPCWSTR             lpszOutput,
             CONST DEVMODEW *    lpInitData)
{
    VALIDATE_PROTOTYPE(CreateDC);

    if (g_bRunningOnNT)
    {
        return CreateDCW(lpszDriver, lpszDevice, lpszOutput, lpInitData);
    }
    return CreateHDCWrapW(lpszDriver, lpszDevice, lpszOutput, lpInitData, CreateDCA);
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

HDC WINAPI
CreateICWrapW(
             LPCWSTR             lpszDriver,
             LPCWSTR             lpszDevice,
             LPCWSTR             lpszOutput,
             CONST DEVMODEW *    lpInitData)
{
    VALIDATE_PROTOTYPE(CreateIC);

    if (g_bRunningOnNT)
    {
        return CreateICW(lpszDriver, lpszDevice, lpszOutput, lpInitData);
    }

    return CreateHDCWrapW(lpszDriver, lpszDevice, lpszOutput, lpInitData, CreateICA);
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HWND WINAPI
CreateDialogIndirectParamWrapW(
                              HINSTANCE       hInstance,
                              LPCDLGTEMPLATEW hDialogTemplate,
                              HWND            hWndParent,
                              DLGPROC         lpDialogFunc,
                              LPARAM          dwInitParam)
{
    VALIDATE_PROTOTYPE(CreateDialogIndirectParam);
    if (g_bRunningOnNT)
    {
        return CreateDialogIndirectParamW(
                                         hInstance,
                                         hDialogTemplate,
                                         hWndParent,
                                         lpDialogFunc,
                                         dwInitParam);
    }
    return CreateDialogIndirectParamA(
                                     hInstance,
                                     hDialogTemplate,
                                     hWndParent,
                                     lpDialogFunc,
                                     dwInitParam);
}


HWND WINAPI
CreateDialogParamWrapW(
                      HINSTANCE   hInstance,
                      LPCWSTR     lpTemplateName,
                      HWND        hWndParent,
                      DLGPROC     lpDialogFunc,
                      LPARAM      dwInitParam)
{
    VALIDATE_PROTOTYPE(CreateDialogParam);
    ASSERT(HIWORD64(lpTemplateName) == 0);

    if (g_bRunningOnNT)
    {
        return CreateDialogParamW(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
    }

    return CreateDialogParamA(hInstance, (LPSTR) lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI
CreateDirectoryWrapW(
                    LPCWSTR                 lpPathName,
                    LPSECURITY_ATTRIBUTES   lpSecurityAttributes)
{
    VALIDATE_PROTOTYPE(CreateDirectory);

    if (g_bRunningOnNT)
    {
        return CreateDirectoryW(lpPathName, lpSecurityAttributes);
    }

    CStrIn  str(lpPathName);

    ASSERT(!lpSecurityAttributes);
    return CreateDirectoryA(str, lpSecurityAttributes);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HANDLE WINAPI
CreateEventWrapW(
                LPSECURITY_ATTRIBUTES   lpEventAttributes,
                BOOL                    bManualReset,
                BOOL                    bInitialState,
                LPCWSTR                 lpName)
{
    VALIDATE_PROTOTYPE(CreateEvent);

    //Totally bogus assert.
    //ASSERT(!lpName);

    // cast means we can't use FORWARD_AW
    if (g_bRunningOnNT)
    {
        return CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpName);
    }

    return CreateEventA(lpEventAttributes, bManualReset, bInitialState, (LPCSTR)lpName);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HANDLE WINAPI
CreateFileWrapW(
               LPCWSTR                 lpFileName,
               DWORD                   dwDesiredAccess,
               DWORD                   dwShareMode,
               LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
               DWORD                   dwCreationDisposition,
               DWORD                   dwFlagsAndAttributes,
               HANDLE                  hTemplateFile)
{
    VALIDATE_PROTOTYPE(CreateFile);

    if (g_bRunningOnNT)
    {
        return CreateFileW(
                          lpFileName,
                          dwDesiredAccess,
                          dwShareMode,
                          lpSecurityAttributes,
                          dwCreationDisposition,
                          dwFlagsAndAttributes,
                          hTemplateFile);
    }

    CStrIn  str(lpFileName);

    return CreateFileA(
                      str,
                      dwDesiredAccess,
                      dwShareMode,
                      lpSecurityAttributes,
                      dwCreationDisposition,
                      dwFlagsAndAttributes,
                      hTemplateFile);
}

#endif // NEED_KERNEL32_WRAPPER


#ifdef NEED_GDI32_WRAPPER

HFONT WINAPI
CreateFontIndirectWrapW(CONST LOGFONTW * plfw)
{
    VALIDATE_PROTOTYPE(CreateFontIndirect);

    if (g_bRunningOnNT)
    {
        return CreateFontIndirectW(plfw);
    }

    LOGFONTA  lfa;
    HFONT     hFont;

    memcpy(&lfa, plfw, FIELD_OFFSET(LOGFONTA, lfFaceName));
    SHUnicodeToAnsi(plfw->lfFaceName, lfa.lfFaceName, ARRAYSIZE(lfa.lfFaceName));
    hFont = CreateFontIndirectA(&lfa);

    return hFont;
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HWND WINAPI
CreateWindowExWrapW(
                   DWORD       dwExStyle,
                   LPCWSTR     lpClassName,
                   LPCWSTR     lpWindowName,
                   DWORD       dwStyle,
                   int         X,
                   int         Y,
                   int         nWidth,
                   int         nHeight,
                   HWND        hWndParent,
                   HMENU       hMenu,
                   HINSTANCE   hInstance,
                   LPVOID      lpParam)
{
    VALIDATE_PROTOTYPE(CreateWindowEx);

    if (g_bRunningOnNT)
    {
        return CreateWindowExW(
                              dwExStyle,
                              lpClassName,
                              lpWindowName,
                              dwStyle,
                              X,
                              Y,
                              nWidth,
                              nHeight,
                              hWndParent,
                              hMenu,
                              hInstance,
                              lpParam);
    }

    CStrIn  strClass(lpClassName);
    CStrIn  strWindow(lpWindowName);

    return CreateWindowExA(
                          dwExStyle,
                          strClass,
                          strWindow,
                          dwStyle,
                          X,
                          Y,
                          nWidth,
                          nHeight,
                          hWndParent,
                          hMenu,
                          hInstance,
                          lpParam);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

LRESULT FORWARD_API WINAPI DefWindowProcWrapW(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    VALIDATE_PROTOTYPE(DefWindowProc);

    FORWARD_AW(DefWindowProc, (hWnd, msg, wParam, lParam));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI DeleteFileWrapW(LPCWSTR pwsz)
{
    VALIDATE_PROTOTYPE(DeleteFile);

    if (g_bRunningOnNT)
    {
        return DeleteFileW(pwsz);
    }

    CStrIn  str(pwsz);

    return DeleteFileA(str);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

INT_PTR WINAPI
DialogBoxIndirectParamWrapW(
                           HINSTANCE       hInstance,
                           LPCDLGTEMPLATEW hDialogTemplate,
                           HWND            hWndParent,
                           DLGPROC         lpDialogFunc,
                           LPARAM          dwInitParam)
{
    VALIDATE_PROTOTYPE(DialogBoxIndirectParam);
    ASSERT(HIWORD64(hDialogTemplate) == 0);

    if (g_bRunningOnNT)
    {
        return DialogBoxIndirectParamW(
                                      hInstance,
                                      hDialogTemplate,
                                      hWndParent,
                                      lpDialogFunc,
                                      dwInitParam);
    }

    return DialogBoxIndirectParamA(
                                  hInstance,
                                  hDialogTemplate,
                                  hWndParent,
                                  lpDialogFunc,
                                  dwInitParam);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

INT_PTR WINAPI
DialogBoxParamWrapW(
                   HINSTANCE   hInstance,
                   LPCWSTR     lpszTemplate,
                   HWND        hWndParent,
                   DLGPROC     lpDialogFunc,
                   LPARAM      dwInitParam)
{
    VALIDATE_PROTOTYPE(DialogBoxParam);
    ASSERT(HIWORD64(lpszTemplate) == 0);

    if (g_bRunningOnNT)
    {
        return DialogBoxParamW(
                              hInstance,
                              lpszTemplate,
                              hWndParent,
                              lpDialogFunc,
                              dwInitParam);
    }

    return DialogBoxParamA(hInstance, (LPCSTR) lpszTemplate, hWndParent, lpDialogFunc, dwInitParam);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

LRESULT FORWARD_API WINAPI
DispatchMessageWrapW(CONST MSG * lpMsg)
{
    VALIDATE_PROTOTYPE(DispatchMessage);

    FORWARD_AW(DispatchMessage, (lpMsg));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

int WINAPI
DrawTextWrapW(
             HDC     hDC,
             LPCWSTR lpString,
             int     nCount,
             LPRECT  lpRect,
             UINT    uFormat)
{
    VALIDATE_PROTOTYPE(DrawText);

    if (g_bRunningOnNT)
    {
        return DrawTextW(hDC, lpString, nCount, lpRect, uFormat);
    }

    CStrIn  str(lpString, nCount);

    return DrawTextA(hDC, str, str.strlen(), lpRect, uFormat);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

struct EFFSTAT
{
    LPARAM          lParam;
    FONTENUMPROC    lpEnumFontProc;
    BOOL            fFamilySpecified;
};

int CALLBACK
EnumFontFamiliesCallbackWrap(
                            ENUMLOGFONTA *  lpelf,
                            NEWTEXTMETRIC * lpntm,
                            DWORD           FontType,
                            LPARAM          lParam)
{
    ENUMLOGFONTW    elf;

    //  Convert strings from ANSI to Unicode
    if (((EFFSTAT *)lParam)->fFamilySpecified && (FontType & TRUETYPE_FONTTYPE) )
    {
        // LPBYTE->LPCSTR cast below
        SHAnsiToUnicode((LPCSTR)lpelf->elfFullName, elf.elfFullName, ARRAYSIZE(elf.elfFullName));
        SHAnsiToUnicode((LPCSTR)lpelf->elfStyle, elf.elfStyle, ARRAYSIZE(elf.elfStyle));
    }
    else
    {
        elf.elfStyle[0] = L'\0';
        elf.elfFullName[0] = L'\0';
    }

    SHAnsiToUnicode(lpelf->elfLogFont.lfFaceName, elf.elfLogFont.lfFaceName, ARRAYSIZE(elf.elfLogFont.lfFaceName));

    //  Copy the non-string data
    memcpy(
          &elf.elfLogFont,
          &lpelf->elfLogFont,
          FIELD_OFFSET(LOGFONTA, lfFaceName));

    //  Chain to the original callback function
    return(*((EFFSTAT *) lParam)->lpEnumFontProc)(
                                                 (const LOGFONTW *)&elf,
                                                 (const TEXTMETRICW *) lpntm,
                                                 FontType,
                                                 ((EFFSTAT *) lParam)->lParam);
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

int WINAPI
EnumFontFamiliesWrapW(
                     HDC          hdc,
                     LPCWSTR      lpszFamily,
                     FONTENUMPROC lpEnumFontProc,
                     LPARAM       lParam)
{
    VALIDATE_PROTOTYPE(EnumFontFamilies);

    if (g_bRunningOnNT)
    {
        return EnumFontFamiliesW(
                                hdc,
                                lpszFamily,
                                lpEnumFontProc,
                                lParam);
    }

    CStrIn  str(lpszFamily);
    EFFSTAT effstat;

    effstat.lParam = lParam;
    effstat.lpEnumFontProc = lpEnumFontProc;
    effstat.fFamilySpecified = lpszFamily != NULL;

    return EnumFontFamiliesA(
                            hdc,
                            str,
                            (FONTENUMPROCA) EnumFontFamiliesCallbackWrap,
                            (LPARAM) &effstat);
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

int WINAPI
EnumFontFamiliesExWrapW(
                       HDC          hdc,
                       LPLOGFONTW   lplfw,
                       FONTENUMPROC lpEnumFontProc,
                       LPARAM       lParam,
                       DWORD        dwFlags )
{
    VALIDATE_PROTOTYPE(EnumFontFamiliesEx);

    if (g_bRunningOnNT)
    {
        return EnumFontFamiliesExW(
                                  hdc,
                                  lplfw,
                                  lpEnumFontProc,
                                  lParam,
                                  dwFlags);
    }

    LOGFONTA lfa;
    CStrIn   str(lplfw->lfFaceName);
    EFFSTAT  effstat;

    ASSERT( FIELD_OFFSET(LOGFONTW, lfFaceName) == FIELD_OFFSET(LOGFONTA, lfFaceName) );

    memcpy( &lfa, lplfw, sizeof(LOGFONTA) - FIELD_OFFSET(LOGFONTA, lfFaceName) );
    memcpy( lfa.lfFaceName, str, LF_FACESIZE );

    effstat.lParam = lParam;
    effstat.lpEnumFontProc = lpEnumFontProc;
    effstat.fFamilySpecified = lplfw->lfFaceName != NULL;

    return EnumFontFamiliesExA(
                              hdc,
                              &lfa,
                              (FONTENUMPROCA) EnumFontFamiliesCallbackWrap,
                              (LPARAM) &effstat,
                              dwFlags );
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI
EnumResourceNamesWrapW(
                      HINSTANCE        hModule,
                      LPCWSTR          lpType,
                      ENUMRESNAMEPROCW lpEnumFunc,
                      LPARAM           lParam)
{
    VALIDATE_PROTOTYPE(EnumResourceNames);
    ASSERT(HIWORD64(lpType) == 0);

    if (g_bRunningOnNT)
    {
        return EnumResourceNamesW(hModule, lpType, lpEnumFunc, lParam);
    }

    return EnumResourceNamesA(hModule, (LPCSTR) lpType, (ENUMRESNAMEPROCA)lpEnumFunc, lParam);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HANDLE WINAPI
FindFirstFileWrapW(
                  LPCWSTR             lpFileName,
                  LPWIN32_FIND_DATAW  pwszFd)
{
    VALIDATE_PROTOTYPE(FindFirstFile);

    if (g_bRunningOnNT)
    {
        return FindFirstFileW(lpFileName, pwszFd);
    }

    CStrIn              str(lpFileName);
    CWin32FindDataInOut fd(pwszFd);

    return FindFirstFileA(str, fd);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HRSRC WINAPI
FindResourceWrapW(HINSTANCE hModule, LPCWSTR lpName, LPCWSTR lpType)
{
    VALIDATE_PROTOTYPE(FindResource);

    if (g_bRunningOnNT)
    {
        return FindResourceW(hModule, lpName, lpType);
    }

    CStrIn  strName(lpName);
    CStrIn strType(lpType);

    return FindResourceA(hModule, strName, strType);
}

LPWSTR lstrcpyWrapW(LPWSTR pszDst, LPCWSTR pszSrc)
{
    while((*pszDst++ = *pszSrc++));

    return pszDst;
}

LPWSTR lstrcatWrapW(LPWSTR pszDst, LPCWSTR pszSrc)
{
    return lstrcpyWrapW(pszDst + lstrlenW(pszDst), pszSrc);
}

LPWSTR
lstrcpynWrapW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    )
{
    LPWSTR src,dst;

    __try {
        src = (LPWSTR)lpString2;
        dst = lpString1;

        if ( iMaxLength ) {
            while(iMaxLength && *src){
                *dst++ = *src++;
                iMaxLength--;
                }
            if ( iMaxLength ) {
                *dst = '\0';
                }
            else {
                dst--;
                *dst = '\0';
                }
            }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }

    return lpString1;
}

INT
APIENTRY
lstrcmpiWrapW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    if (g_bRunningOnNT)
    {
        return lstrcmpiW(lpString1, lpString2);
    }

    CStrIn sz1(lpString1);
    CStrIn sz2(lpString2);

    return lstrcmpiA(sz1, sz2);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HWND WINAPI
FindWindowWrapW(LPCWSTR lpClassName, LPCWSTR lpWindowName)
{
    VALIDATE_PROTOTYPE(FindWindow);

    if (g_bRunningOnNT)
    {
        return FindWindowW(lpClassName, lpWindowName);
    }

    // Let FindWindowExWrapW do the thunking
    return FindWindowExWrapW(NULL, NULL, lpClassName, lpWindowName);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HWND WINAPI
FindWindowExWrapW(HWND hwndParent, HWND hwndChildAfter, LPCWSTR pwzClassName, LPCWSTR pwzWindowName)
{
    VALIDATE_PROTOTYPE(FindWindowEx);

    if (g_bRunningOnNT)
        return FindWindowExW(hwndParent, hwndChildAfter, pwzClassName, pwzWindowName);


    CStrIn  strClass(pwzClassName);
    CStrIn  strWindow(pwzWindowName);

    return FindWindowExA(hwndParent, hwndChildAfter, strClass, strWindow);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

DWORD WINAPI
FormatMessageWrapW(
                  DWORD       dwFlags,
                  LPCVOID     lpSource,
                  DWORD       dwMessageId,
                  DWORD       dwLanguageId,
                  LPWSTR      lpBuffer,
                  DWORD       nSize,
                  va_list *   Arguments)
{
    VALIDATE_PROTOTYPE(FormatMessage);
    if (!(dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER))
    {
        VALIDATE_OUTBUF(lpBuffer, nSize);
    }

    DWORD dwResult;

#if DBG
    // If a source string is passed, make sure that all string insertions
    // have explicit character set markers.  Otherwise, you get random
    // behavior depending on whether we need to thunk to ANSI or not.
    // (We are not clever enough to thunk the inserts; that's the caller's
    // responsibility.)
    //
    if (dwFlags & FORMAT_MESSAGE_FROM_STRING)
    {
        LPCWSTR pwsz;
        for (pwsz = (LPCWSTR)lpSource; *pwsz; pwsz++)
        {
            if (*pwsz == L'%')
            {
                pwsz++;
                // Found an insertion.  Get the digit or two.
                if (*pwsz == L'0')
                    continue;       // "%0" is special
                if (*pwsz < L'0' || *pwsz > L'9')
                    continue;        // skip % followed by nondigit
                pwsz++;            // Skip the digit
                if (*pwsz >= L'0' && *pwsz <= L'9')
                    pwsz++;        // Skip the optional second digit
                // The next character MUST be an exclamation point!
                ASSERT(*pwsz == L'!' &&
                       "FormatMessageWrapW: All string insertions must have explicit character sets.");
                // I'm not going to validate that the insertion contains
                // an explicit character set override because if you went
                // so far as to do a %n!...!, you'll get the last bit right too.
            }
        }
    }
#endif

    if (g_bRunningOnNT)
    {
        return FormatMessageW(
                             dwFlags,
                             lpSource,
                             dwMessageId,
                             dwLanguageId,
                             lpBuffer,
                             nSize,
                             Arguments);
    }

    //
    //  FORMAT_MESSAGE_FROM_STRING means that the source is a string.
    //  Otherwise, it's an opaque LPVOID (aka, an atom).
    //
    CStrIn strSource((dwFlags & FORMAT_MESSAGE_FROM_STRING) ? CP_ACP : CP_ATOM,
                     (LPCWSTR)lpSource, -1);

    if (!(dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER))
    {
        CStrOut str(lpBuffer, nSize);
        FormatMessageA(
                      dwFlags,
                      strSource,
                      dwMessageId,
                      dwLanguageId,
                      str,
                      str.BufSize(),
                      Arguments);         // We don't handle Arguments != NULL

        dwResult = str.ConvertExcludingNul();
    }
    else
    {
        LPSTR pszBuffer = NULL;
        LPWSTR * ppwzOut = (LPWSTR *)lpBuffer;

        *ppwzOut = NULL;
        FormatMessageA(
                      dwFlags,
                      strSource,
                      dwMessageId,
                      dwLanguageId,
                      (LPSTR)&pszBuffer,
                      0,
                      Arguments);

        if (pszBuffer)
        {
            DWORD cchSize = (lstrlenA(pszBuffer) + 1);
            LPWSTR pszThunkedBuffer;

            if (cchSize < nSize)
                cchSize = nSize;

            pszThunkedBuffer = (LPWSTR) LocalAlloc(LPTR, cchSize * sizeof(WCHAR));
            if (pszThunkedBuffer)
            {
                *ppwzOut = pszThunkedBuffer;
                SHAnsiToUnicode(pszBuffer, pszThunkedBuffer, cchSize);
            }

            LocalFree(pszBuffer);
        }
        dwResult = (*ppwzOut ? lstrlenW(*ppwzOut) : 0);
    }

    return dwResult;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
GetClassInfoWrapW(HINSTANCE hModule, LPCWSTR lpClassName, LPWNDCLASSW lpWndClassW)
{
    VALIDATE_PROTOTYPE(GetClassInfo);

    if (g_bRunningOnNT)
    {
        return GetClassInfoW(hModule, lpClassName, lpWndClassW);
    }

    BOOL    ret;

    CStrIn  strClassName(lpClassName);

    ASSERT(sizeof(WNDCLASSA) == sizeof(WNDCLASSW));

    ret = GetClassInfoA(hModule, strClassName, (LPWNDCLASSA) lpWndClassW);

    lpWndClassW->lpszMenuName = NULL;
    lpWndClassW->lpszClassName = NULL;
    return ret;
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

DWORD FORWARD_API WINAPI
GetClassLongWrapW(HWND hWnd, int nIndex)
{
    VALIDATE_PROTOTYPE(GetClassLong);

    FORWARD_AW(GetClassLong, (hWnd, nIndex));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

int WINAPI
GetClassNameWrapW(HWND hWnd, LPWSTR lpClassName, int nMaxCount)
{
    VALIDATE_PROTOTYPE(GetClassName);
    VALIDATE_OUTBUF(lpClassName, nMaxCount);

    if (g_bRunningOnNT)
    {
        return GetClassNameW(hWnd, lpClassName, nMaxCount);
    }

    CStrOut strClassName(lpClassName, nMaxCount);

    GetClassNameA(hWnd, strClassName, strClassName.BufSize());
    return strClassName.ConvertIncludingNul();
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

int WINAPI
GetClipboardFormatNameWrapW(UINT format, LPWSTR lpFormatName, int cchFormatName)
{
    VALIDATE_PROTOTYPE(GetClipboardFormatName);
    VALIDATE_OUTBUF(lpFormatName, cchFormatName);

    if (g_bRunningOnNT)
    {
        return GetClipboardFormatNameW(format, lpFormatName, cchFormatName);
    }

    CStrOut strFormatName(lpFormatName, cchFormatName);

    GetClipboardFormatNameA(format, strFormatName, strFormatName.BufSize());
    return strFormatName.ConvertIncludingNul();
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

DWORD WINAPI
GetCurrentDirectoryWrapW(DWORD nBufferLength, LPWSTR lpBuffer)
{
    VALIDATE_PROTOTYPE(GetCurrentDirectory);
    VALIDATE_OUTBUF(lpBuffer, nBufferLength);

    if (g_bRunningOnNT)
    {
        return GetCurrentDirectoryW(nBufferLength, lpBuffer);
    }

    CStrOut str(lpBuffer, nBufferLength);

    GetCurrentDirectoryA(str.BufSize(), str);
    return str.ConvertExcludingNul();
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

UINT WINAPI
GetDlgItemTextWrapW(
                   HWND    hWndDlg,
                   int     idControl,
                   LPWSTR  lpsz,
                   int     cchMax)
{
    VALIDATE_PROTOTYPE(GetDlgItemText);
    VALIDATE_OUTBUF(lpsz, cchMax);

    if (g_bRunningOnNT)
    {
        return GetDlgItemTextW(hWndDlg, idControl, lpsz, cchMax);
    }

    CStrOut str(lpsz, cchMax);

    GetDlgItemTextA(hWndDlg, idControl, str, str.BufSize());
    return str.ConvertExcludingNul();
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

DWORD WINAPI
GetFileAttributesWrapW(LPCWSTR lpFileName)
{
    VALIDATE_PROTOTYPE(GetFileAttributes);

    if (g_bRunningOnNT)
    {
        return GetFileAttributesW(lpFileName);
    }

    CStrIn  str(lpFileName);

    return GetFileAttributesA(str);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

int WINAPI
GetLocaleInfoWrapW(LCID Locale, LCTYPE LCType, LPWSTR lpsz, int cchData)
{
    VALIDATE_PROTOTYPE(GetLocaleInfo);
    VALIDATE_OUTBUF(lpsz, cchData);

    if (g_bRunningOnNT)
    {
        return GetLocaleInfoW(Locale, LCType, lpsz, cchData);
    }

    CStrOut str(lpsz, cchData);

    GetLocaleInfoA(Locale, LCType, str, str.BufSize());
    return str.ConvertIncludingNul();
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

int WINAPI
GetMenuStringWrapW(
                  HMENU   hMenu,
                  UINT    uIDItem,
                  LPWSTR  lpString,
                  int     nMaxCount,
                  UINT    uFlag)
{
    VALIDATE_PROTOTYPE(GetMenuString);
    VALIDATE_OUTBUF(lpString, nMaxCount);

    if (g_bRunningOnNT)
    {
        return GetMenuStringW(hMenu, uIDItem, lpString, nMaxCount, uFlag);
    }

    CStrOut str(lpString, nMaxCount);

    GetMenuStringA(hMenu, uIDItem, str, str.BufSize(), uFlag);
    return str.ConvertExcludingNul();
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL FORWARD_API WINAPI
GetMessageWrapW(
               LPMSG   lpMsg,
               HWND    hWnd,
               UINT    wMsgFilterMin,
               UINT    wMsgFilterMax)
{
    VALIDATE_PROTOTYPE(GetMessage);

    FORWARD_AW(GetMessage, (lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

DWORD WINAPI
GetModuleFileNameWrapW(HINSTANCE hModule, LPWSTR pwszFilename, DWORD nSize)
{
    VALIDATE_PROTOTYPE(GetModuleFileName);
    VALIDATE_OUTBUF(pwszFilename, nSize);

    if (g_bRunningOnNT)
    {
        return GetModuleFileNameW(hModule, pwszFilename, nSize);
    }

    CStrOut str(pwszFilename, nSize);

    GetModuleFileNameA(hModule, str, str.BufSize());
    return str.ConvertIncludingNul();
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

UINT WINAPI
GetSystemDirectoryWrapW(LPWSTR lpBuffer, UINT uSize)
{
    VALIDATE_PROTOTYPE(GetSystemDirectory);
    VALIDATE_OUTBUF(lpBuffer, uSize);

    if (g_bRunningOnNT)
    {
        return GetSystemDirectoryW(lpBuffer, uSize);
    }

    CStrOut str(lpBuffer, uSize);

    GetSystemDirectoryA(str, str.BufSize());
    return str.ConvertExcludingNul();
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

DWORD WINAPI
SearchPathWrapW(
               LPCWSTR lpPathName,
               LPCWSTR lpFileName,
               LPCWSTR lpExtension,
               DWORD   cchReturnBuffer,
               LPWSTR  lpReturnBuffer,
               LPWSTR *  plpfilePart)
{
    VALIDATE_PROTOTYPE(SearchPath);
    VALIDATE_OUTBUF(lpReturnBuffer, cchReturnBuffer);

    if (g_bRunningOnNT)
    {
        return SearchPathW(
                          lpPathName,
                          lpFileName,
                          lpExtension,
                          cchReturnBuffer,
                          lpReturnBuffer,
                          plpfilePart);
    }

    CStrIn  strPath(lpPathName);
    CStrIn  strFile(lpFileName);
    CStrIn  strExtension(lpExtension);
    CStrOut strReturnBuffer(lpReturnBuffer, cchReturnBuffer);

    DWORD dwLen = SearchPathA(
                             strPath,
                             strFile,
                             strExtension,
                             strReturnBuffer.BufSize(),
                             strReturnBuffer,
                             (LPSTR *)plpfilePart);

    //
    // Getting the correct value for plpfilePart requires
    // a strrchr on the converted string.  If this value
    // is needed, just add the code to do it here.
    //

    *plpfilePart = NULL;

    if (cchReturnBuffer == 0)
        dwLen = 2*dwLen;
    else
        dwLen = strReturnBuffer.ConvertExcludingNul();

    return dwLen;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HMODULE WINAPI
GetModuleHandleWrapW(LPCWSTR lpModuleName)
{
    VALIDATE_PROTOTYPE(GetModuleHandle);

    if (g_bRunningOnNT)
    {
        return GetModuleHandleW(lpModuleName);
    }

    CStrIn  str(lpModuleName);
    return GetModuleHandleA(str);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

int WINAPI
GetObjectWrapW(HGDIOBJ hgdiObj, int cbBuffer, LPVOID lpvObj)
{
    VALIDATE_PROTOTYPE(GetObject);

    if (g_bRunningOnNT)
    {
        return GetObjectW(hgdiObj, cbBuffer, lpvObj);
    }

    int nRet;

    if (cbBuffer != sizeof(LOGFONTW))
    {
        nRet = GetObjectA(hgdiObj, cbBuffer, lpvObj);
    }
    else
    {
        LOGFONTA lfa;

        nRet = GetObjectA(hgdiObj, sizeof(lfa), &lfa);
        if (nRet > 0)
        {
            memcpy(lpvObj, &lfa, FIELD_OFFSET(LOGFONTW, lfFaceName));
            SHAnsiToUnicode(lfa.lfFaceName, ((LOGFONTW*)lpvObj)->lfFaceName, ARRAYSIZE(((LOGFONTW*)lpvObj)->lfFaceName));
            nRet = sizeof(LOGFONTW);
        }
    }

    return nRet;
}

#endif // NEED_GDI32_WRAPPER


//
// Demand load shell32 _SHFileOperationW because
// older versions of the Shell on 9x didn't necessarily
// have this function
//
int WINAPI _SHFileOperationW(LPSHFILEOPSTRUCTW pFileOpW)
{
    int result = 1;
    HMODULE hmodSH32DLL;
    typedef HRESULT (STDAPICALLTYPE FNSHFileOperationW)(LPSHFILEOPSTRUCT);
    FNSHFileOperationW *pfnSHFileOperationW;

    // get the handle to shell32.dll library
    hmodSH32DLL = LoadLibraryWrapW(TEXT("SHELL32.DLL"));

    if (hmodSH32DLL != NULL) {
        // get the proc address for SHFileOperation
        pfnSHFileOperationW = (FNSHFileOperationW *)GetProcAddress(
                                                        hmodSH32DLL,
                                                        "SHFileOperationW");

        if (pfnSHFileOperationW != NULL) {
            result = (*pfnSHFileOperationW) (pFileOpW);
        }
        
        FreeLibrary(hmodSH32DLL);
    }

    return result ;
}


int WINAPI SHFileOperationWrapW(LPSHFILEOPSTRUCTW pFileOpW)
{
    VALIDATE_PROTOTYPE_DELAYLOAD(SHFileOperation, _SHFileOperation);
    // We don't thunk multiple files.
    ASSERT(!(pFileOpW->fFlags & FOF_MULTIDESTFILES));

    if (UseUnicodeShell32())
        return _SHFileOperationW(pFileOpW);

    int nResult = 1;    // non-Zero is failure.
    if (pFileOpW)
    {
        SHFILEOPSTRUCTA FileOpA;
        CStrIn strTo(pFileOpW->pTo);
        CStrIn strFrom(pFileOpW->pFrom);
        CStrIn strProgressTitle(pFileOpW->lpszProgressTitle);

        FileOpA = *(LPSHFILEOPSTRUCTA) pFileOpW;
        FileOpA.pFrom = strFrom;
        FileOpA.pTo = strTo;
        FileOpA.lpszProgressTitle = strProgressTitle;


        nResult = SHFileOperationA(&FileOpA);
    }

    return nResult;
}


//
// We don't need many of the shell api's
// so they are no wrapped
//
#ifdef NEED_SHELL32_WRAPPER

LPITEMIDLIST WINAPI SHBrowseForFolderWrapW(LPBROWSEINFOW pbiW)
{
    VALIDATE_PROTOTYPE_DELAYLOAD(SHBrowseForFolder, _SHBrowseForFolder);


    if (UseUnicodeShell32())
        return _SHBrowseForFolderW(pbiW);

    LPITEMIDLIST pidl = NULL;
    if (EVAL(pbiW))
    {
        CStrIn strTitle(pbiW->lpszTitle);
        CStrOut strDisplayName(pbiW->pszDisplayName, MAX_PATH);
        BROWSEINFOA biA;

        biA = * (LPBROWSEINFOA) pbiW;
        biA.lpszTitle = strTitle;
        biA.pszDisplayName = strDisplayName;

        pidl = _SHBrowseForFolderA(&biA);
        if (pidl)
            strDisplayName.ConvertIncludingNul();
    }

    return pidl;
}

#endif // NEED_SHELL32_WRAPPER

#ifdef NEED_SHELL32_WRAPPER

BOOL WINAPI ShellExecuteExWrapW(LPSHELLEXECUTEINFOW pExecInfoW)
{
    VALIDATE_PROTOTYPE_DELAYLOAD(ShellExecuteEx, _ShellExecuteEx);

    if (g_bRunningOnNT)
        return _ShellExecuteExW(pExecInfoW);

    BOOL fResult = FALSE;
    if (EVAL(pExecInfoW))
    {
        SHELLEXECUTEINFOA ExecInfoA;
        CStrIn strVerb(pExecInfoW->lpVerb);
        CStrIn strParameters(pExecInfoW->lpParameters);
        CStrIn strDirectory(pExecInfoW->lpDirectory);
        CStrIn strClass(pExecInfoW->lpClass);
        CHAR szFile[MAX_PATH + INTERNET_MAX_URL_LENGTH + 2];


        ExecInfoA = *(LPSHELLEXECUTEINFOA) pExecInfoW;
        ExecInfoA.lpVerb = strVerb;
        ExecInfoA.lpParameters = strParameters;
        ExecInfoA.lpDirectory = strDirectory;
        ExecInfoA.lpClass = strClass;

        if (pExecInfoW->lpFile)
        {
            ExecInfoA.lpFile = szFile;
            SHUnicodeToAnsi(pExecInfoW->lpFile, szFile, ARRAYSIZE(szFile));

            // SEE_MASK_FILEANDURL passes "file\0url".  What a hack!
            if (pExecInfoW->fMask & SEE_MASK_FILEANDURL)
            {
                // We are so lucky that Win9x implements lstrlenW
                int cch = lstrlenW(pExecInfoW->lpFile) + 1;
                cch += lstrlenW(pExecInfoW->lpFile + cch) + 1;
                if (!WideCharToMultiByte(CP_ACP, 0, pExecInfoW->lpFile, cch, szFile, ARRAYSIZE(szFile), NULL, NULL))
                {
                    // Return a completely random error code
                    pExecInfoW->hInstApp = (HINSTANCE)SE_ERR_OOM;
                    SetLastError(ERROR_INVALID_PARAMETER);
                    return FALSE;
                }
            }
        }

        fResult = _ShellExecuteExA(&ExecInfoA);

        // Out parameters
        pExecInfoW->hInstApp = ExecInfoA.hInstApp;
        pExecInfoW->hProcess = ExecInfoA.hProcess;
    }
    else
        SetLastError(ERROR_INVALID_PARAMETER);

    return fResult;
}

#endif // NEED_SHELL32_WRAPPER

#ifdef NEED_SHELL32_WRAPPER

UINT WINAPI ExtractIconExWrapW(LPCWSTR pwzFile, int nIconIndex, HICON FAR *phiconLarge, HICON FAR *phiconSmall, UINT nIcons)
{
    VALIDATE_PROTOTYPE_DELAYLOAD(ExtractIconEx, _ExtractIconEx);

    if ( UseUnicodeShell32() )
        return _ExtractIconExW(pwzFile, nIconIndex, phiconLarge, phiconSmall, nIcons);

    CStrIn  str(pwzFile);
    return _ExtractIconExA(str, nIconIndex, phiconLarge, phiconSmall, nIcons);
}

#endif // NEED_SHELL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI SetFileAttributesWrapW(LPCWSTR pwzFile, DWORD dwFileAttributes)
{
    VALIDATE_PROTOTYPE(SetFileAttributes);

    if (g_bRunningOnNT)
        return SetFileAttributesW(pwzFile, dwFileAttributes);

    CStrIn  str(pwzFile);
    return SetFileAttributesA(str, dwFileAttributes);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

int WINAPI GetNumberFormatWrapW(LCID Locale, DWORD dwFlags, LPCWSTR pwzValue, CONST NUMBERFMTW * pFormatW, LPWSTR pwzNumberStr, int cchNumber)
{
    VALIDATE_PROTOTYPE(GetNumberFormat);

    if (g_bRunningOnNT)
        return GetNumberFormatW(Locale, dwFlags, pwzValue, pFormatW, pwzNumberStr, cchNumber);

    int nResult;
    NUMBERFMTA FormatA;
    CStrIn  strValue(pwzValue);
    CStrIn  strDecimalSep(pFormatW ? pFormatW->lpDecimalSep : NULL);
    CStrIn  strThousandSep(pFormatW ? pFormatW->lpThousandSep : NULL);
    CStrOut strNumberStr(pwzNumberStr, cchNumber);

    if (pFormatW)
    {
        FormatA = *(NUMBERFMTA *) pFormatW;
        FormatA.lpDecimalSep = strDecimalSep;
        FormatA.lpThousandSep = strThousandSep;
    }

    nResult = GetNumberFormatA(Locale, dwFlags, strValue, (pFormatW ? &FormatA : NULL), strNumberStr, strNumberStr.BufSize());
    if (ERROR_SUCCESS == nResult)
        strNumberStr.ConvertIncludingNul();

    return nResult;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

int WINAPI MessageBoxWrapW(HWND hwnd, LPCWSTR pwzText, LPCWSTR pwzCaption, UINT uType)
{
    VALIDATE_PROTOTYPE(MessageBox);

    if (g_bRunningOnNT)
        return MessageBoxW(hwnd, pwzText, pwzCaption, uType);

    CStrIn  strCaption(pwzCaption);
    CStrIn  strText(pwzText);
    return MessageBoxA(hwnd, strText, strCaption, uType);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI FindNextFileWrapW(HANDLE hSearchHandle, LPWIN32_FIND_DATAW pFindFileDataW)
{
    VALIDATE_PROTOTYPE(FindNextFile);

    if (g_bRunningOnNT)
        return FindNextFileW(hSearchHandle, pFindFileDataW);

    CWin32FindDataInOut fd(pFindFileDataW);
    return FindNextFileA(hSearchHandle, fd);
}
#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

//--------------------------------------------------------------
//      GetFullPathNameWrap
//--------------------------------------------------------------

DWORD
WINAPI
GetFullPathNameWrapW( LPCWSTR lpFileName,
                      DWORD  nBufferLength,
                      LPWSTR lpBuffer,
                      LPWSTR *lpFilePart)
{
    VALIDATE_PROTOTYPE(GetFullPathName);
    VALIDATE_OUTBUF(lpBuffer, nBufferLength);

    if (g_bRunningOnNT)
    {
        return GetFullPathNameW(lpFileName, nBufferLength, lpBuffer, lpFilePart);
    }

    CStrIn  strIn(lpFileName);
    CStrOut  strOut(lpBuffer,nBufferLength);
    LPSTR   pFile;
    DWORD   dwRet;

    dwRet = GetFullPathNameA(strIn, nBufferLength, strOut, &pFile);
    strOut.ConvertIncludingNul();
    // BUGBUG raymondc - This is wrong if we had to do DBCS or related goo
    *lpFilePart = lpBuffer + (pFile - strOut);
    return dwRet;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

DWORD WINAPI
GetShortPathNameWrapW(
                     LPCWSTR lpszLongPath,
                     LPWSTR  lpszShortPath,
                     DWORD   cchBuffer)
{
    VALIDATE_PROTOTYPE(GetShortPathName);

    if (g_bRunningOnNT)
    {
        return GetShortPathNameW(lpszLongPath, lpszShortPath, cchBuffer);

    }

    CStrIn strLongPath(lpszLongPath);
    CStrOut strShortPath(lpszShortPath, cchBuffer);

    return GetShortPathNameA(strLongPath, strShortPath, strShortPath.BufSize());
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI
GetStringTypeExWrapW(LCID lcid, DWORD dwInfoType, LPCTSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
{
    VALIDATE_PROTOTYPE(GetStringTypeEx);

    if (g_bRunningOnNT)
    {
        return GetStringTypeExW(lcid, dwInfoType, lpSrcStr, cchSrc, lpCharType);
    }

    CStrIn  str(lpSrcStr, cchSrc);
    return GetStringTypeExA(lcid, dwInfoType, str, str.strlen(), lpCharType);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

UINT WINAPI
GetPrivateProfileIntWrapW(
                         LPCWSTR lpAppName,
                         LPCWSTR lpKeyName,
                         INT     nDefault,
                         LPCWSTR lpFileName)
{
    VALIDATE_PROTOTYPE(GetPrivateProfileInt);

    if (g_bRunningOnNT)
    {
        return GetPrivateProfileIntW(lpAppName, lpKeyName, nDefault, lpFileName);
    }

    CStrIn  strApp(lpAppName);
    CStrIn  strKey(lpKeyName);
    CStrIn  strFile(lpFileName);

    return GetPrivateProfileIntA(strApp, strKey, nDefault, strFile);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

DWORD WINAPI
GetProfileStringWrapW(
                     LPCWSTR lpAppName,
                     LPCWSTR lpKeyName,
                     LPCWSTR lpDefault,
                     LPWSTR  lpBuffer,
                     DWORD   dwBuffersize)
{
    VALIDATE_PROTOTYPE(GetProfileString);
    VALIDATE_OUTBUF(lpBuffer, dwBuffersize);

    if (g_bRunningOnNT)
    {
        return GetProfileStringW(lpAppName, lpKeyName, lpDefault, lpBuffer, dwBuffersize);
    }

    CStrIn  strApp(lpAppName);
    CStrIn  strKey(lpKeyName);
    CStrIn  strDefault(lpDefault);
    CStrOut strBuffer(lpBuffer, dwBuffersize);

    GetProfileStringA(strApp, strKey, strDefault, strBuffer, dwBuffersize);
    return strBuffer.ConvertIncludingNul();
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HANDLE WINAPI
GetPropWrapW(HWND hWnd, LPCWSTR lpString)
{
    VALIDATE_PROTOTYPE(GetProp);

    if (g_bRunningOnNT)
    {
        return GetPropW(hWnd, lpString);
    }

    CStrIn  str(lpString);

    return GetPropA(hWnd, str);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

UINT WINAPI
GetTempFileNameWrapW(
                    LPCWSTR lpPathName,
                    LPCWSTR lpPrefixString,
                    UINT    uUnique,
                    LPWSTR  lpTempFileName)
{
    VALIDATE_PROTOTYPE(GetTempFileName);
    VALIDATE_OUTBUF(lpTempFileName, MAX_PATH);

    if (g_bRunningOnNT)
    {
        return GetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName);
    }


    CStrIn  strPath(lpPathName);
    CStrIn  strPrefix(lpPrefixString);
    CStrOut strFileName(lpTempFileName, MAX_PATH);

    return GetTempFileNameA(strPath, strPrefix, uUnique, strFileName);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

DWORD WINAPI
GetTempPathWrapW(DWORD nBufferLength, LPWSTR lpBuffer)
{
    VALIDATE_PROTOTYPE(GetTempPath);
    VALIDATE_OUTBUF(lpBuffer, nBufferLength);

    if (g_bRunningOnNT)
    {
        return GetTempPathW(nBufferLength, lpBuffer);
    }


    CStrOut str(lpBuffer, nBufferLength);

    GetTempPathA(str.BufSize(), str);
    return str.ConvertExcludingNul();
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

BOOL APIENTRY
GetTextExtentPoint32WrapW(
                         HDC     hdc,
                         LPCWSTR pwsz,
                         int     cb,
                         LPSIZE  pSize)
{
    VALIDATE_PROTOTYPE(GetTextExtentPoint32);

    if (g_bRunningOnNT)
    {
        return GetTextExtentPoint32W(hdc, pwsz, cb, pSize);
    }


    CStrIn str(pwsz,cb);

    return GetTextExtentPoint32A(hdc, str, str.strlen(), pSize);
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

int WINAPI
GetTextFaceWrapW(
                HDC    hdc,
                int    cch,
                LPWSTR lpFaceName)
{
    VALIDATE_PROTOTYPE(GetTextFace);
    VALIDATE_OUTBUF(lpFaceName, cch);

    if (g_bRunningOnNT)
    {
        return GetTextFaceW(hdc, cch, lpFaceName);
    }


    CStrOut str(lpFaceName, cch);

    GetTextFaceA(hdc, str.BufSize(), str);
    return str.ConvertIncludingNul();
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

BOOL WINAPI
GetTextMetricsWrapW(HDC hdc, LPTEXTMETRICW lptm)
{
    VALIDATE_PROTOTYPE(GetTextMetrics);

    if (g_bRunningOnNT)
    {
        return GetTextMetricsW(hdc, lptm);
    }


    BOOL         ret;
    TEXTMETRICA  tm;

    ret = GetTextMetricsA(hdc, &tm);

    if (ret)
    {
        lptm->tmHeight              = tm.tmHeight;
        lptm->tmAscent              = tm.tmAscent;
        lptm->tmDescent             = tm.tmDescent;
        lptm->tmInternalLeading     = tm.tmInternalLeading;
        lptm->tmExternalLeading     = tm.tmExternalLeading;
        lptm->tmAveCharWidth        = tm.tmAveCharWidth;
        lptm->tmMaxCharWidth        = tm.tmMaxCharWidth;
        lptm->tmWeight              = tm.tmWeight;
        lptm->tmOverhang            = tm.tmOverhang;
        lptm->tmDigitizedAspectX    = tm.tmDigitizedAspectX;
        lptm->tmDigitizedAspectY    = tm.tmDigitizedAspectY;
        lptm->tmItalic              = tm.tmItalic;
        lptm->tmUnderlined          = tm.tmUnderlined;
        lptm->tmStruckOut           = tm.tmStruckOut;
        lptm->tmPitchAndFamily      = tm.tmPitchAndFamily;
        lptm->tmCharSet             = tm.tmCharSet;

        // LPBYTE -> LPCSTR casts below
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&tm.tmFirstChar, 1, &lptm->tmFirstChar, 1);
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&tm.tmLastChar, 1, &lptm->tmLastChar, 1);
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&tm.tmDefaultChar, 1, &lptm->tmDefaultChar, 1);
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&tm.tmBreakChar, 1, &lptm->tmBreakChar, 1);
    }

    return ret;
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

BOOL WINAPI GetUserNameWrapW(LPWSTR pszBuffer, LPDWORD pcch)
{
    VALIDATE_PROTOTYPE(GetUserName);

    BOOL fRet;

    if (UseUnicodeShell32())
    {
        fRet = GetUserNameW(pszBuffer, pcch);
    }
    else
    {
        CStrOut stroBuffer(pszBuffer, *pcch);

        fRet = GetUserNameA(stroBuffer, pcch);

        if (fRet)
            *pcch = stroBuffer.ConvertIncludingNul();
    }

    return fRet;
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_USER32_WRAPPER

LONG FORWARD_API WINAPI
GetWindowLongWrapW(HWND hWnd, int nIndex)
{
    VALIDATE_PROTOTYPE(GetWindowLong);

    FORWARD_AW(GetWindowLong, (hWnd, nIndex));
}

LONG_PTR FORWARD_API WINAPI
GetWindowLongPtrWrapW(
    HWND hWnd,
    int nIndex)
{
    VALIDATE_PROTOTYPE(GetWindowLongPtr);

    FORWARD_AW(GetWindowLongPtr, (hWnd, nIndex));
}


#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

int WINAPI
GetWindowTextWrapW(HWND hWnd, LPWSTR lpString, int nMaxCount)
{
    VALIDATE_PROTOTYPE(GetWindowText);
    VALIDATE_OUTBUF(lpString, nMaxCount);

    if (g_bRunningOnNT)
    {
        return GetWindowTextW(hWnd, lpString, nMaxCount);
    }


    CStrOut str(lpString, nMaxCount);

    GetWindowTextA(hWnd, str, str.BufSize());
    return str.ConvertExcludingNul();
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

int WINAPI
GetWindowTextLengthWrapW(HWND hWnd)
{
    VALIDATE_PROTOTYPE(GetWindowTextLength);

    if (g_bRunningOnNT)
    {
        return GetWindowTextLengthW(hWnd);
    }

    return GetWindowTextLengthA(hWnd);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

UINT WINAPI
GetWindowsDirectoryWrapW(LPWSTR lpWinPath, UINT cch)
{
    VALIDATE_PROTOTYPE(GetWindowsDirectory);
    VALIDATE_OUTBUF(lpWinPath, cch);

    if (g_bRunningOnNT)
    {
        return GetWindowsDirectoryW(lpWinPath, cch);
    }

    CStrOut str(lpWinPath, cch);

    if (!GetWindowsDirectoryA(str, str.BufSize()))
    {
        return 0;
    }

    return str.ConvertExcludingNul();
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
InsertMenuWrapW(
               HMENU   hMenu,
               UINT    uPosition,
               UINT    uFlags,
               UINT_PTR uIDNewItem,
               LPCWSTR lpNewItem)
{
    VALIDATE_PROTOTYPE(InsertMenu);

    if (g_bRunningOnNT)
    {
        return InsertMenuW(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
    }

    //
    //  You can't test for MFT_STRING because MFT_STRING is zero!
    //  So instead you have to check for everything *other* than
    //  a string.
    //
    //  The presence of any non-string menu type turns lpnewItem into
    //  an atom.
    //
    CStrIn str((uFlags & MFT_NONSTRING) ? CP_ATOM : CP_ACP, lpNewItem);

    return InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, str);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL FORWARD_API WINAPI
IsDialogMessageWrapW(HWND hWndDlg, LPMSG lpMsg)
{
    VALIDATE_PROTOTYPE(IsDialogMessage);

    FORWARD_AW(IsDialogMessage, (hWndDlg, lpMsg));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HACCEL WINAPI
LoadAcceleratorsWrapW(HINSTANCE hInstance, LPCWSTR lpTableName)
{
    VALIDATE_PROTOTYPE(LoadAccelerators);
    ASSERT(HIWORD64(lpTableName) == 0);

    if (g_bRunningOnNT)
    {
        return LoadAcceleratorsW(hInstance, lpTableName);
    }

    return LoadAcceleratorsA(hInstance, (LPCSTR) lpTableName);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HBITMAP WINAPI
LoadBitmapWrapW(HINSTANCE hInstance, LPCWSTR lpBitmapName)
{
    VALIDATE_PROTOTYPE(LoadBitmap);
    ASSERT(HIWORD64(lpBitmapName) == 0);

    if (g_bRunningOnNT)
    {
        return LoadBitmapW(hInstance, lpBitmapName);
    }

    return LoadBitmapA(hInstance, (LPCSTR) lpBitmapName);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HCURSOR WINAPI
LoadCursorWrapW(HINSTANCE hInstance, LPCWSTR lpCursorName)
{
    VALIDATE_PROTOTYPE(LoadCursor);
    ASSERT(HIWORD64(lpCursorName) == 0);

    if (g_bRunningOnNT)
    {
        return LoadCursorW(hInstance, lpCursorName);
    }

    return LoadCursorA(hInstance, (LPCSTR) lpCursorName);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HICON WINAPI
LoadIconWrapW(HINSTANCE hInstance, LPCWSTR lpIconName)
{
    VALIDATE_PROTOTYPE(LoadIcon);
    ASSERT(HIWORD64(lpIconName) == 0);

    if (g_bRunningOnNT)
    {
        return LoadIconW(hInstance, lpIconName);
    }

    return LoadIconA(hInstance, (LPCSTR) lpIconName);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HANDLE WINAPI
LoadImageWrapW(
              HINSTANCE hInstance,
              LPCWSTR lpName,
              UINT uType,
              int cxDesired,
              int cyDesired,
              UINT fuLoad)
{
    VALIDATE_PROTOTYPE(LoadImage);

    if (g_bRunningOnNT)
    {
        return LoadImageW(
                         hInstance,
                         lpName,
                         uType,
                         cxDesired,
                         cyDesired,
                         fuLoad);
    }

    CStrIn  str(lpName);

    return LoadImageA(
                     hInstance,
                     str,
                     uType,
                     cxDesired,
                     cyDesired,
                     fuLoad);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HINSTANCE WINAPI
LoadLibraryExWrapW(
                  LPCWSTR lpLibFileName,
                  HANDLE  hFile,
                  DWORD   dwFlags)
{
    VALIDATE_PROTOTYPE(LoadLibraryEx);

    if (g_bRunningOnNT)
        return LoadLibraryExW(lpLibFileName, hFile, dwFlags);

    CStrIn  str(lpLibFileName);

    // Win9X will crash if the pathname is longer than MAX_PATH bytes.

    if (str.strlen() >= MAX_PATH)
    {
        SetLastError( ERROR_BAD_PATHNAME );
        return NULL;
    }
    else
    {
        return LoadLibraryExA(str, hFile, dwFlags);
    }
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HMENU WINAPI
LoadMenuWrapW(HINSTANCE hInstance, LPCWSTR lpMenuName)
{
    VALIDATE_PROTOTYPE(LoadMenu);
    ASSERT(HIWORD64(lpMenuName) == 0);

    if (g_bRunningOnNT)
    {
        return LoadMenuW(hInstance, lpMenuName);
    }

    return LoadMenuA(hInstance, (LPCSTR) lpMenuName);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

int WINAPI
LoadStringWrapW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBufferMax)
{
    VALIDATE_PROTOTYPE(LoadString);

    if (g_bRunningOnNT)
    {
        return LoadStringW(hInstance, uID, lpBuffer, nBufferMax);
    }

    //
    //  Do it manually.  The old code used to call LoadStringA and then
    //  convert it up to unicode, which is bad since resources are
    //  physically already Unicode!  Just take it out directly.
    //
    //  The old code was also buggy in the case where the loaded string
    //  contains embedded NULLs.
    //

    if (nBufferMax <= 0) return 0;                  // sanity check

    PWCHAR pwch;

    /*
     *  String tables are broken up into "bundles" of 16 strings each.
     */
    HRSRC hrsrc;
    int cwch = 0;

    hrsrc = FindResourceA(hInstance, (LPSTR)(LONG_PTR)(1 + uID / 16), (LPSTR)RT_STRING);
    if (hrsrc)
    {
        pwch = (PWCHAR)LoadResource(hInstance, hrsrc);
        if (pwch)
        {
            /*
             *  Now skip over the strings in the resource until we
             *  hit the one we want.  Each entry is a counted string,
             *  just like Pascal.
             */
            for (uID %= 16; uID; uID--)
            {
                pwch += *pwch + 1;
            }
            cwch = min(*pwch, nBufferMax - 1);
            memcpy(lpBuffer, pwch+1, cwch * sizeof(WCHAR)); /* Copy the goo */
        }
    }
    lpBuffer[cwch] = L'\0';                 /* Terminate the string */
    return cwch;
}

#endif // NEED_USER32_WRAPPER

//----------------------------------------------------------------------
//
// function:    TransformCharNoOp1( WCHAR **ppch )
//
// purpose:     Stand-in for TransformCharWidth.  Used by the function
//              CompareStringString.
//
// returns:     Character at *ppch.  The value *ppch is incremented.
//
//----------------------------------------------------------------------

static WCHAR
TransformCharNoOp1( LPCWSTR *ppch, int )
{
    WCHAR ch = **ppch;

    (*ppch)++;

    return ch;
}

//----------------------------------------------------------------------
//
// function:    TransformCharWidth( WCHAR **ppch, cchRemaining )
//
// purpose:     Converts halfwidth characters to fullwidth characters.
//              Also combines voiced (dakuon) and semi-voiced (handakuon)
//              characters.  *pch is advanced by one, unless there is a
//              (semi)voiced character, in which case it is advanced by
//              two characters.
//
//              Note that unlike the full widechar version, we do not
//              combine other characters, notably the combining Hiragana
//              characters (U+3099 and U+309A.)  This is to keep the
//              tables from getting unnecessarily large.
//
//              cchRemaining is passed so as to not include the voiced
//              marks if it's passed the end of the specified buffer.
//
// returns:     Full width character. *pch is incremented.
//
//----------------------------------------------------------------------

static WCHAR
TransformCharWidth( LPCWSTR *ppch, int cchRemaining )
{
    WCHAR ch = **ppch;

    (*ppch)++;

    if (ch == 0x0020)
    {
        ch = 0x3000;
    }
    else if (ch == 0x005c)
    {
        // REVERSE SOLIDUS (aka BACKSLASH) maps to itself
    }
    else if (InRange(ch, 0x0021, 0x07e))
    {
        ch += 65248;
    }
    else if (InRange(ch, 0x00a2, 0x00af))
    {
        static const WCHAR achFull[] =
        {
            0xffe0, 0xffe1, 0x00a4, 0xffe5, 0xffe4, 0x00a7, 0x00a8, // 0xa2-0xa8
            0x00a9, 0x00aa, 0x00ab, 0xffe2, 0x00ad, 0x00ae, 0xffe3  // 0xa9-0xaf
        };

        ch = achFull[ch - 0x00a2];
    }
    else if (ch == 0x20a9) // WON SIGN
    {
        ch = 0xffe6;
    }
    else if (InRange(ch, 0xff61, 0xffdc))
    {
        WCHAR chNext = (cchRemaining > 1) ? **ppch : 0;

        if (chNext == 0xff9e && InRange(ch, 0xff73, 0xff8e))
        {
            if (cchRemaining != 1)
            {
                static const WCHAR achFull[] =
                {  
/* 0xff73-0xff79 */0xb0f4, 0x30a8, 0x30aa, 0xb0ac, 0xb0ae, 0xb0b0, 0xb0b2,
/* 0xff7a-0xff80 */  0xb0b4, 0xb0b6, 0xb0b8, 0xb0ba, 0xb0bc, 0xb0be, 0xb0c0,
/* 0xff81-0xff87 */  0xb0c2, 0xb0c5, 0xb0c7, 0xb0c9, 0x30ca, 0x30cb, 0x30cc,
/* 0xff88-0xff8e */  0x30cd, 0x30ce, 0xb0d0, 0xb0d3, 0xb0d6, 0xb0d9, 0xb0dc
                };

                // HALFWIDTH KATAKANA VOICED SOUND MARK

                WCHAR chTemp = achFull[ch - 0xff73];

                // Some in the range absorb the sound mark.
                // These are indicated by the set high-bit.

                ch = chTemp & 0x7fff;

                if (chTemp & 0x8000)
                {
                    (*ppch)++;
                }
            }
        }
        else if (chNext == 0xff9f && InRange(ch, 0xff8a, 0xff8e))
        {
            // HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK

            ch = 0x30d1 + (ch - 0xff8a) * 3;
            (*ppch)++;
        }
        else
        {
            static const WCHAR achMapFullFFxx[] =
            {
                0x3002, 0x300c, 0x300d, 0x3001, 0x30fb, 0x30f2, 0x30a1,  // 0xff61-0xff67
                0x30a3, 0x30a5, 0x30a7, 0x30a9, 0x30e3, 0x30e5, 0x30e7,  // 0xff68-0xff6e
                0x30c3, 0x30fc, 0x30a2, 0x30a4, 0x30a6, 0x30a8, 0x30aa,  // 0xff6f-0xff75
                0x30ab, 0x30ad, 0x30af, 0x30b1, 0x30b3, 0x30b5, 0x30b7,  // 0xff76-0xff7c
                0x30b9, 0x30bb, 0x30bd, 0x30bf, 0x30c1, 0x30c4, 0x30c6,  // 0xff7d-0xff83
                0x30c8, 0x30ca, 0x30cb, 0x30cc, 0x30cd, 0x30ce, 0x30cf,  // 0xff84-0xff8a
                0x30d2, 0x30d5, 0x30d8, 0x30db, 0x30de, 0x30df, 0x30e0,  // 0xff8b-0xff91
                0x30e1, 0x30e2, 0x30e4, 0x30e6, 0x30e8, 0x30e9, 0x30ea,  // 0xff92-0xff98
                0x30eb, 0x30ec, 0x30ed, 0x30ef, 0x30f3, 0x309b, 0x309c,  // 0xff99-0xff9f
                0x3164, 0x3131, 0x3132, 0x3133, 0x3134, 0x3135, 0x3136,  // 0xffa0-0xffa6
                0x3137, 0x3138, 0x3139, 0x313a, 0x313b, 0x313c, 0x313d,  // 0xffa7-0xffad
                0x313e, 0x313f, 0x3140, 0x3141, 0x3142, 0x3143, 0x3144,  // 0xffae-0xffb4
                0x3145, 0x3146, 0x3147, 0x3148, 0x3149, 0x314a, 0x314b,  // 0xffb5-0xffbb
                0x314c, 0x314d, 0x314e, 0xffbf, 0xffc0, 0xffc1, 0x314f,  // 0xffbc-0xffc2
                0x3150, 0x3151, 0x3152, 0x3153, 0x3154, 0xffc8, 0xffc9,  // 0xffc3-0xffc9
                0x3155, 0x3156, 0x3157, 0x3158, 0x3159, 0x315a, 0xffd0,  // 0xffca-0xffd0
                0xffd1, 0x315b, 0x315c, 0x315d, 0x315e, 0x315f, 0x3160,  // 0xffd1-0xffd7
                0xffd8, 0xffd9, 0x3161, 0x3162, 0x3163                   // 0xffd8-0xffac
            };

            ch = achMapFullFFxx[ch - 0xff61];
        }
    }

    return ch;
}

//----------------------------------------------------------------------
//
// function:    TransformaCharNoOp2( WCHAR ch )
//
// purpose:     Stand-in for CharLowerBuffWrap.  Used by the function
//              CompareStringString.
//
// returns:     Original character
//
//----------------------------------------------------------------------

static WCHAR
TransformCharNoOp2( WCHAR ch )
{
    return ch;
}

//----------------------------------------------------------------------
//
// function:    TransformaCharKana( WCHAR ch )
//
// purpose:     Converts Hiragana characters to Katakana characters
//
// returns:     Original character if not Hiragana,
//              Katanaka character if Hiragana
//
//----------------------------------------------------------------------

static WCHAR
TransformCharKana( WCHAR ch )
{
    if (((ch & 0xff00) == 0x3000) &&
        (InRange(ch, 0x3041, 0x3094) || InRange(ch, 0x309d, 0x309e)))
    {
        ch += 0x060;
    }

    return ch;
}

//----------------------------------------------------------------------
//
// function:    TransformCharNoOp3( LPWSTR pch, DWORD cch )
//
// purpose:     Stand-in for CharLowerBuffWrap.  Used by the function
//              CompareStringString.
//
// returns:     Character count (cch).
//
//----------------------------------------------------------------------

static DWORD
TransformCharNoOp3( LPWSTR, DWORD cch )
{
    return cch;
}

//----------------------------------------------------------------------
//
// function:    TransformaCharFinal( WCHAR ch )
//
// purpose:     Converts "final" forms to regular forms
//
// returns:     Original character if not Hiragana,
//              Katanaka character if Hiragana
//
//----------------------------------------------------------------------

// BUGBUG (cthrash) We do not fold Presentation Forms (Alphabetic or Arabic)

static WCHAR
TransformCharFinal( WCHAR ch )
{
    WCHAR chRet = ch;

    if (ch >= 0x3c2)                    // short-circuit ASCII +
    {
        switch (ch)
        {
            case 0x03c2:                // GREEK SMALL LETTER FINAL SIGMA
            case 0x05da:                // HEBREW LETTER FINAL KAF
            case 0x05dd:                // HEBREW LETTER FINAL MEM
            case 0x05df:                // HEBREW LETTER FINAL NUN
            case 0x05e3:                // HEBREW LETTER FINAL PE
            case 0x05e5:                // HEBREW LETTER FINAL TSADI
            case 0xfb26:                // HEBREW LETTER WIDE FINAL MEM
            case 0xfb3a:                // HEBREW LETTER FINAL KAF WITH DAGESH
            case 0xfb43:                // HEBREW LETTER FINAL PE WITH DAGESH
                chRet++;
                break;
        }
    }

    return ch;
}

//----------------------------------------------------------------------
//
// function:    CompareStringString( ... )
//
// purpose:     Helper for CompareStringWrap.
//
//              We handle the string comparsion for CompareStringWrap.
//              We can convert each character to (1) fullwidth,
//              (2) Katakana, and (3) lowercase, as necessary.
//
// returns:     1 - string A is less in lexical value as string B
//              2 - string B is equal in lexical value as string B
//              3 - string B is greater in lexical value as string B
//
//----------------------------------------------------------------------

#ifdef NEED_USER32_WRAPPER

#if UNUSED_DONOTBUILD
static int
CompareStringString(
                   DWORD   dwFlags,
                   LPCWSTR lpA,
                   int     cchA,
                   LPCWSTR lpB,
                   int     cchB )
{
    int nRet = 0;
    WCHAR wchIgnoreNulA = cchA == -1 ? 0 : -1;
    WCHAR wchIgnoreNulB = cchB == -1 ? 0 : -1;
    WCHAR (*pfnTransformWidth)(LPCWSTR *, int);
    WCHAR (*pfnTransformKana)(WCHAR);
    DWORD (*pfnTransformLower)(LPWSTR, DWORD);
    WCHAR (*pfnTransformFinal)(WCHAR);


    pfnTransformWidth = (dwFlags & NORM_IGNOREWIDTH)
                        ? TransformCharWidth : TransformCharNoOp1;
    pfnTransformKana  = (dwFlags & NORM_IGNOREKANATYPE)
                        ? TransformCharKana : TransformCharNoOp2;
    pfnTransformLower = (dwFlags & NORM_IGNORECASE)
                        ? CharLowerBuffWrap : TransformCharNoOp3;
    pfnTransformFinal = (dwFlags & NORM_IGNORECASE)
                        ? TransformCharFinal : TransformCharNoOp2;

    while (   !nRet
              && cchA
              && cchB
              && (*lpA | wchIgnoreNulA)
              && (*lpB | wchIgnoreNulB) )
    {
        WCHAR chA, chB;
        LPCWSTR lpAOld = lpA;
        LPCWSTR lpBOld = lpB;

        chA = (*pfnTransformWidth)(&lpA, cchA);
        chA = (*pfnTransformKana)(chA);
        (*pfnTransformLower)(&chA, 1);
        chA = (*pfnTransformFinal)(chA);

        chB = (*pfnTransformWidth)(&lpB, cchB);
        chB = (*pfnTransformKana)(chB);
        (*pfnTransformLower)(&chB, 1);
        chB = (*pfnTransformFinal)(chB);

        nRet = (int)chA - (int)chB;
        cchA -= (int) (lpA - lpAOld);
        cchB -= (int) (lpB - lpBOld);
    }

    if (!nRet)
    {
        nRet = cchA - cchB;
    }

    if (nRet)
    {
        nRet = nRet > 0 ? 1 : -1;
    }

    return nRet + 2;
}
#endif //UNUSED_DONOTBUILD
#endif // NEED_USER32_WRAPPER

//----------------------------------------------------------------------
//
// function:    CompareStringWord( ... )
//
// purpose:     Helper for CompareStringWrap.
//
//              We handle the word comparsion for CompareStringWrap.
//
// returns:     1 - string A is less in lexical value as string B
//              2 - string B is equal in lexical value as string B
//              3 - string B is greater in lexical value as string B
//
//----------------------------------------------------------------------

static int
CompareStringWord(
                 LCID    lcid,
                 DWORD   dwFlags,
                 LPCWSTR lpA,
                 int     cchA,
                 LPCWSTR lpB,
                 int     cchB )
{
    // BUGBUG (cthrash) We won't properly support word compare for the
    // time being.  Do the same old CP_ACP trick, which should cover
    // enough cases.

    // fail if either string is NULL, as it causes assert on debug windows
    if (!lpA || !lpB)
        return 0;

    CStrIn strA(lpA, cchA);
    CStrIn strB(lpB, cchB);

    cchA = strA.strlen();
    cchB = strB.strlen();

    return CompareStringA(lcid, dwFlags, strA, cchA, strB, cchB);
}

//----------------------------------------------------------------------
//
// function:    CompareStringWrapW( ... )
//
// purpose:     Unicode wrapper of CompareString for Win95.
//
//              Note not all bits in dwFlags are honored; specifically,
//              since we don't do a true widechar word compare, we
//              won't properly handle NORM_IGNORENONSPACE or
//              NORM_IGNORESYMBOLS for arbitrary widechar strings.
//
// returns:     1 - string A is less in lexical value as string B
//              2 - string B is equal in lexical value as string B
//              3 - string B is greater in lexical value as string B
//
//----------------------------------------------------------------------
#if UNUSED_DONOTBUILD
#ifdef NEED_USER32_WRAPPER
FUS9xWRAPAPI(int)
CompareStringAltW(
                 LCID    lcid,
                 DWORD   dwFlags,
                 LPCWSTR lpA,
                 int     cchA,
                 LPCWSTR lpB,
                 int     cchB )
{
    if (g_bRunningOnNT)
    {
        return CompareStringW(lcid, dwFlags, lpA, cchA, lpB, cchB);
    }

    int nRet;

    if (dwFlags & SORT_STRINGSORT)
    {
        nRet = CompareStringString(dwFlags, lpA, cchA, lpB, cchB);
    }
    else
    {
        nRet = CompareStringWord(lcid, dwFlags, lpA, cchA, lpB, cchB);
    }

    return nRet;
}
#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

int WINAPI
CompareStringWrapW(
                  LCID     Locale,
                  DWORD    dwCmpFlags,
                  LPCWSTR lpString1,
                  int      cchCount1,
                  LPCWSTR lpString2,
                  int      cchCount2)
{
    VALIDATE_PROTOTYPE(CompareString);

    if (g_bRunningOnNT)
    {
        return CompareStringW(Locale,
                              dwCmpFlags,
                              lpString1,
                              cchCount1,
                              lpString2,
                              cchCount2);
    }

    // fail if either string is NULL, as it causes assert on debug windows
    if (!lpString1 || !lpString2)
        return 0;

    CStrIn      strString1(lpString1, cchCount1);
    CStrIn      strString2(lpString2, cchCount2);

    cchCount1 = strString1.strlen();
    cchCount2 = strString2.strlen();

    return CompareStringA(Locale, dwCmpFlags & ~NORM_STOP_ON_NULL,
                          strString1, cchCount1, strString2, cchCount2);
}
#endif // NEED_KERNEL32_WRAPPER
#endif //#if UNUSED_DONOTBUILD

#ifdef NEED_USER32_WRAPPER

#ifndef UNIX
BOOL WINAPI
MessageBoxIndirectWrapW(CONST MSGBOXPARAMS *pmbp)
#else
int WINAPI
MessageBoxIndirectWrapW(LPMSGBOXPARAMS pmbp)
#endif /* UNIX */
{
    VALIDATE_PROTOTYPE(MessageBoxIndirect);
    ASSERT(HIWORD64(pmbp->lpszIcon) == 0);

    if (g_bRunningOnNT)
    {
        return MessageBoxIndirectW(pmbp);
    }

    CStrIn        strText(pmbp->lpszText);
    CStrIn        strCaption(pmbp->lpszCaption);
    MSGBOXPARAMSA mbp;

    memcpy(&mbp, pmbp, sizeof(mbp));
    mbp.lpszText = strText;
    mbp.lpszCaption = strCaption;

    return MessageBoxIndirectA(&mbp);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

DWORD GetCharacterPlacementWrapW(
                                HDC hdc,            // handle to device context
                                LPCTSTR lpString,   // pointer to string
                                int nCount,         // number of characters in string
                                int nMaxExtent,     // maximum extent for displayed string
                                LPGCP_RESULTS lpResults, // pointer to buffer for placement result
                                DWORD dwFlags       // placement flags
                                )
{
    VALIDATE_PROTOTYPE(GetCharacterPlacement);
    // Leave for someone else.
    ASSERT (lpResults->lpOutString == NULL);
    ASSERT (lpResults->lpClass == NULL);

    if (g_bRunningOnNT)
    {
        return GetCharacterPlacementW (hdc,
                                       lpString,
                                       nCount,
                                       nMaxExtent,
                                       lpResults,
                                       dwFlags);
    }

    CStrIn strText(lpString);
    DWORD dwRet;

    dwRet = GetCharacterPlacementA (hdc, strText, nCount, nMaxExtent,
                                    (LPGCP_RESULTSA)lpResults,
                                    dwFlags);
    return dwRet;
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

//
// Note that we're calling get GetCharWidthA instead of GetCharWidth32A
// because the 32 version doesn't exist under Win95.
BOOL WINAPI GetCharWidth32WrapW(
                               HDC hdc,
                               UINT iFirstChar,
                               UINT iLastChar,
                               LPINT lpBuffer)
{
    VALIDATE_PROTOTYPE(GetCharWidth32);

    if (g_bRunningOnNT)
    {
        return GetCharWidth32W (hdc, iFirstChar, iLastChar, lpBuffer);
    }

    // Note that we expect to do only one character at a time for anything but
    // ISO Latin 1.
    if (iFirstChar > 255)
    {
        UINT mbChar=0;
        WCHAR ch;

        // Convert string
        ch = (WCHAR)iFirstChar;
        WideCharToMultiByte(CP_ACP, 0, &ch, 1,
                            (char *)&mbChar, 2, NULL, NULL);
    }

    return(GetCharWidthA (hdc, iFirstChar, iLastChar, lpBuffer));
}

#endif // NEED_GDI32_WRAPPER


//
//  Note:  Win95 does support ExtTextOutW.  This thunk is not for
//  ANSI/UNICODE wrapping.  It's to work around an ISV app bug.
//
//  Y'see, there's an app that patches Win95 GDI and their ExtTextOutW handler
//  is broken.  It always dereferences the lpStr parameter, even if
//  cch is zero.  Consequently, any time we are about to pass NULL as
//  the lpStr, we have to change our mind and pass a null UNICODE string
//  instead.
//
//  The name of this app:  Lotus SmartSuite ScreenCam 97.
//
FUS9xWRAPAPI(BOOL)
ExtTextOutWrapW(HDC hdc, int x, int y, UINT fuOptions, CONST RECT *lprc, LPCWSTR lpStr, UINT cch, CONST INT *lpDx)
{
    VALIDATE_PROTOTYPE(ExtTextOut);
    if (lpStr == NULL)              // Stupid workaround
        lpStr = L"";                // for ScreenCam 97
    return ExtTextOutW(hdc, x, y, fuOptions, lprc, lpStr, cch, lpDx);

}


#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
ModifyMenuWrapW(
               HMENU   hMenu,
               UINT    uPosition,
               UINT    uFlags,
               UINT_PTR uIDNewItem,
               LPCWSTR lpNewItem)
{
    VALIDATE_PROTOTYPE(ModifyMenu);
    ASSERT(!(uFlags & MF_BITMAP) && !(uFlags & MF_OWNERDRAW));

    if (g_bRunningOnNT)
    {
        return ModifyMenuW(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
    }

    CStrIn  str(lpNewItem);

    return ModifyMenuA(hMenu, uPosition, uFlags, uIDNewItem, str);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI
CopyFileWrapW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
{
    VALIDATE_PROTOTYPE(CopyFile);

    if (g_bRunningOnNT)
    {
        return CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);
    }

    CStrIn  strOld(lpExistingFileName);
    CStrIn  strNew(lpNewFileName);

    return CopyFileA(strOld, strNew, bFailIfExists);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI
MoveFileWrapW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
{
    VALIDATE_PROTOTYPE(MoveFile);

    if (g_bRunningOnNT)
    {
        return MoveFileW(lpExistingFileName, lpNewFileName);
    }

    CStrIn  strOld(lpExistingFileName);
    CStrIn  strNew(lpNewFileName);

    return MoveFileA(strOld, strNew);
}


#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HANDLE WINAPI
OpenEventWrapW(
              DWORD                   fdwAccess,
              BOOL                    fInherit,
              LPCWSTR                 lpszEventName)
{
    VALIDATE_PROTOTYPE(OpenEvent);

    if (g_bRunningOnNT)
    {
        return OpenEventW(fdwAccess, fInherit, lpszEventName);
    }

    CStrIn strEventName(lpszEventName);

    return OpenEventA(fdwAccess, fInherit, strEventName);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

VOID WINAPI
OutputDebugStringWrapW(LPCWSTR lpOutputString)
{
    VALIDATE_PROTOTYPE(OutputDebugString);

    if (g_bRunningOnNT)
    {
        OutputDebugStringW(lpOutputString);
        return;
    }

    CStrIn  str(lpOutputString);

    OutputDebugStringA(str);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL FORWARD_API WINAPI
PeekMessageWrapW(
                LPMSG   lpMsg,
                HWND    hWnd,
                UINT    wMsgFilterMin,
                UINT    wMsgFilterMax,
                UINT    wRemoveMsg)
{
    VALIDATE_PROTOTYPE(PeekMessage);

    FORWARD_AW(PeekMessage, (lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_WINMM_WRAPPER

FUS9xWRAPAPI(BOOL)
PlaySoundWrapW(
              LPCWSTR pszSound,
              HMODULE hmod,
              DWORD fdwSound)
{
    VALIDATE_PROTOTYPE_DELAYLOAD(PlaySound, _PlaySound);

    if (g_bRunningOnNT)
    {
        return _PlaySoundW(pszSound, hmod, fdwSound);
    }

    CStrIn strSound(pszSound);

    return _PlaySoundA(strSound, hmod, fdwSound);
}

#endif // NEED_WINMM_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL FORWARD_API WINAPI
PostMessageWrapW(
                HWND    hWnd,
                UINT    Msg,
                WPARAM  wParam,
                LPARAM  lParam)
{
    VALIDATE_PROTOTYPE(PostMessage);

    FORWARD_AW(PostMessage, (hWnd, Msg, wParam, lParam));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL FORWARD_API WINAPI
PostThreadMessageWrapW(
                      DWORD idThread,
                      UINT Msg,
                      WPARAM wParam,
                      LPARAM lParam)
{
    VALIDATE_PROTOTYPE(PostThreadMessage);

    FORWARD_AW(PostThreadMessage, (idThread, Msg, wParam, lParam));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegCreateKeyWrapW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
{
    VALIDATE_PROTOTYPE(RegCreateKey);

    if (g_bRunningOnNT)
    {
        return RegCreateKeyW(hKey, lpSubKey, phkResult);
    }

    CStrIn  str(lpSubKey);

    return RegCreateKeyA(hKey, str, phkResult);
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegCreateKeyExWrapW(HKEY hKey, LPCTSTR lpSubKey, DWORD Reserved, LPTSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
{
    VALIDATE_PROTOTYPE(RegCreateKeyEx);

    if (g_bRunningOnNT)
    {
        return RegCreateKeyExW(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes,  phkResult, lpdwDisposition);
    }

    CStrIn strSubKey(lpSubKey);
    CStrIn strClass(lpClass);

    return RegCreateKeyExA(hKey, strSubKey, Reserved, strClass, dwOptions, samDesired, lpSecurityAttributes,  phkResult, lpdwDisposition);
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

//
//  Subtle difference:  RegDeleteKey on Win9x will recursively delete subkeys.
//  On NT, it fails if the key being deleted has subkeys.  If you need to
//  force NT-style behavior, use SHDeleteEmptyKey.  To force 95-style
//  behavior, use SHDeleteKey.
//
LONG APIENTRY
RegDeleteKeyWrapW(HKEY hKey, LPCWSTR pwszSubKey)
{
    VALIDATE_PROTOTYPE(RegDeleteKey);

    if (g_bRunningOnNT)
    {
        return RegDeleteKeyW(hKey, pwszSubKey);
    }

    CStrIn  str(pwszSubKey);

    return RegDeleteKeyA(hKey, str);
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegDeleteValueWrapW(HKEY hKey, LPCWSTR pwszSubKey)
{
    VALIDATE_PROTOTYPE(RegDeleteValue);

    if (g_bRunningOnNT)
    {
        return RegDeleteValueW(hKey, pwszSubKey);
    }

    CStrIn  str(pwszSubKey);

    return RegDeleteValueA(hKey, str);
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegEnumKeyWrapW(
               HKEY    hKey,
               DWORD   dwIndex,
               LPWSTR  lpName,
               DWORD   cbName)
{
    VALIDATE_PROTOTYPE(RegEnumKey);
    VALIDATE_OUTBUF(lpName, cbName);

    if (g_bRunningOnNT)
    {
        return RegEnumKeyW(hKey, dwIndex, lpName, cbName);
    }

    CStrOut str(lpName, cbName);

    return RegEnumKeyA(hKey, dwIndex, str, str.BufSize());
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegEnumKeyExWrapW(
                 HKEY        hKey,
                 DWORD       dwIndex,
                 LPWSTR      lpName,
                 LPDWORD     lpcbName,
                 LPDWORD     lpReserved,
                 LPWSTR      lpClass,
                 LPDWORD     lpcbClass,
                 PFILETIME   lpftLastWriteTime)
{
    VALIDATE_PROTOTYPE(RegEnumKeyEx);
    if (lpcbName)
    {
        VALIDATE_OUTBUF(lpName, *lpcbName);
    }
    if (lpcbClass)
    {
        VALIDATE_OUTBUF(lpClass, *lpcbClass);
    }

    if (g_bRunningOnNT)
    {
        return RegEnumKeyExW(
                            hKey,
                            dwIndex,
                            lpName,
                            lpcbName,
                            lpReserved,
                            lpClass,
                            lpcbClass,
                            lpftLastWriteTime);
    }

    long    ret;
    DWORD   dwClass = 0;

    if (!lpcbClass)
    {
        lpcbClass = &dwClass;
    }

    CStrOut strName(lpName, *lpcbName);
    CStrOut strClass(lpClass, *lpcbClass);

    ret = RegEnumKeyExA(
                       hKey,
                       dwIndex,
                       strName,
                       lpcbName,
                       lpReserved,
                       strClass,
                       lpcbClass,
                       lpftLastWriteTime);

    *lpcbName = strName.ConvertExcludingNul();
    *lpcbClass = strClass.ConvertExcludingNul();

    return ret;
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG WINAPI RegEnumValueWrapW(HKEY hkey, DWORD dwIndex, LPWSTR lpValueName,
                              LPDWORD lpcbValueName, LPDWORD lpReserved,
                              LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
    VALIDATE_PROTOTYPE(RegEnumValue);

    LONG lRet;

    if (UseUnicodeShell32())
    {
        lRet = RegEnumValueW(hkey, dwIndex, lpValueName, lpcbValueName,
                             lpReserved, lpType, lpData, lpcbData);
    }
    else
    {
        CStrOut stroValueName(lpValueName, *lpcbValueName);
        DWORD   dwTypeTemp;

        if (lpData)
        {
            ASSERT(lpcbData);

            CStrOut stroData((LPWSTR)lpData, (*lpcbData) / sizeof(WCHAR));

            lRet = RegEnumValueA(hkey, dwIndex, stroValueName, lpcbValueName,
                                 lpReserved, &dwTypeTemp,
                                 (LPBYTE)(LPSTR)stroData, lpcbData);

            if (ERROR_SUCCESS == lRet)
            {
                if (REG_SZ == dwTypeTemp)
                {
                    *lpcbData = sizeof(WCHAR) * stroData.ConvertIncludingNul();
                }
                else if (REG_BINARY == dwTypeTemp)
                {
                    stroData.CopyNoConvert(*lpcbData);
                }
            }
        }
        else
        {
            lRet = RegEnumValueA(hkey, dwIndex, stroValueName, lpcbValueName,
                                 lpReserved, &dwTypeTemp, lpData, lpcbData);
        }

        if (ERROR_SUCCESS == lRet)
            *lpcbValueName = stroValueName.ConvertExcludingNul();

        if (lpType)
            *lpType = dwTypeTemp;
    }

    return lRet;
}

#endif // NEED_ADVAPI32_WRAPPER


#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegOpenKeyWrapW(HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult)
{
    VALIDATE_PROTOTYPE(RegOpenKey);

    if (g_bRunningOnNT)
    {
        return RegOpenKeyW(hKey, pwszSubKey, phkResult);
    }

    CStrIn  str(pwszSubKey);

    return RegOpenKeyA(hKey, str, phkResult);
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegOpenKeyExWrapW(
                 HKEY    hKey,
                 LPCWSTR lpSubKey,
                 DWORD   ulOptions,
                 REGSAM  samDesired,
                 PHKEY   phkResult)
{
    VALIDATE_PROTOTYPE(RegOpenKeyEx);

    if (g_bRunningOnNT)
    {
        return RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);
    }

    CStrIn  str(lpSubKey);

    return RegOpenKeyExA(hKey, str, ulOptions, samDesired, phkResult);
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegQueryInfoKeyWrapW(
                    HKEY hKey,
                    LPWSTR lpClass,
                    LPDWORD lpcbClass,
                    LPDWORD lpReserved,
                    LPDWORD lpcSubKeys,
                    LPDWORD lpcbMaxSubKeyLen,
                    LPDWORD lpcbMaxClassLen,
                    LPDWORD lpcValues,
                    LPDWORD lpcbMaxValueNameLen,
                    LPDWORD lpcbMaxValueLen,
                    LPDWORD lpcbSecurityDescriptor,
                    PFILETIME lpftLastWriteTime)
{
    VALIDATE_PROTOTYPE(RegQueryInfoKey);

    if (g_bRunningOnNT)
    {
        return RegQueryInfoKeyW(
                               hKey,
                               lpClass,
                               lpcbClass,
                               lpReserved,
                               lpcSubKeys,
                               lpcbMaxSubKeyLen,
                               lpcbMaxClassLen,
                               lpcValues,
                               lpcbMaxValueNameLen,
                               lpcbMaxValueLen,
                               lpcbSecurityDescriptor,
                               lpftLastWriteTime);

    }

    CStrIn  str(lpClass);

    return RegQueryInfoKeyA(
                           hKey,
                           str,
                           lpcbClass,
                           lpReserved,
                           lpcSubKeys,
                           lpcbMaxSubKeyLen,
                           lpcbMaxClassLen,
                           lpcValues,
                           lpcbMaxValueNameLen,
                           lpcbMaxValueLen,
                           lpcbSecurityDescriptor,
                           lpftLastWriteTime);
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegQueryValueWrapW(
                  HKEY    hKey,
                  LPCWSTR pwszSubKey,
                  LPWSTR  pwszValue,
                  PLONG   lpcbValue)
{
    VALIDATE_PROTOTYPE(RegQueryValue);
    if (lpcbValue)
    {
        VALIDATE_OUTBUF(pwszValue, *lpcbValue);
    }

    if (g_bRunningOnNT)
    {
        return RegQueryValueW(hKey, pwszSubKey, pwszValue, lpcbValue);
    }

    long    ret;
    long    cb;
    CStrIn  strKey(pwszSubKey);
    CStrOut strValue(pwszValue, (lpcbValue ? ((*lpcbValue) / sizeof(WCHAR)) : 0));

    cb = strValue.BufSize();
    ret = RegQueryValueA(hKey, strKey, strValue, (lpcbValue ? &cb : NULL));
    if (ret != ERROR_SUCCESS)
        goto Cleanup;

    if (strValue)
    {
        cb = strValue.ConvertIncludingNul();
    }

    if (lpcbValue)
        *lpcbValue = cb * sizeof(WCHAR);

    Cleanup:
    return ret;
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegQueryValueExWrapW(
                    HKEY    hKey,
                    LPCWSTR lpValueName,
                    LPDWORD lpReserved,
                    LPDWORD lpType,
                    LPBYTE  lpData,
                    LPDWORD lpcbData)
{
    VALIDATE_PROTOTYPE(RegQueryValueEx);
    if (lpcbData)
    {
        VALIDATE_OUTBUF(lpData, *lpcbData);
    }

    LONG    ret;
    DWORD   dwTempType;

    if (g_bRunningOnNT)
    {
#if DBG
        if (lpType == NULL)
            lpType = &dwTempType;
#endif
        ret = RegQueryValueExW(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);

        if (ret == ERROR_SUCCESS)
        {
            // The Win9x wrapper does not support REG_MULTI_SZ, so it had
            // better not be one
            ASSERT(*lpType != REG_MULTI_SZ);
        }

        return ret;
    }

    CStrIn  strValueName(lpValueName);
    DWORD   cb;

    //
    // Determine the type of buffer needed
    //

    ret = RegQueryValueExA(hKey, strValueName, lpReserved, &dwTempType, NULL, (lpcbData ? &cb : NULL));
    if (ret != ERROR_SUCCESS)
        goto Cleanup;

    ASSERT(dwTempType != REG_MULTI_SZ);

    switch (dwTempType)
    {
        case REG_EXPAND_SZ:
        case REG_SZ:
            {
                CStrOut strData((LPWSTR) lpData, (lpcbData ? ((*lpcbData) / sizeof(WCHAR)) : 0));

                cb = strData.BufSize();
                ret = RegQueryValueExA(hKey, strValueName, lpReserved, lpType, (LPBYTE)(LPSTR)strData, (lpcbData ? &cb : NULL));
                if (ret != ERROR_SUCCESS)
                    break;

                if (strData)
                {
                    cb = strData.ConvertIncludingNul();
                }

                if (lpcbData)
                    *lpcbData = cb * sizeof(WCHAR);
                break;
            }

        default:
            {
                ret = RegQueryValueExA(
                                      hKey,
                                      strValueName,
                                      lpReserved,
                                      lpType,
                                      lpData,
                                      lpcbData);

                break;
            }
    }

    Cleanup:
    return ret;
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegSetValueWrapW(
                HKEY    hKey,
                LPCWSTR lpSubKey,
                DWORD   dwType,
                LPCWSTR lpData,
                DWORD   cbData)
{
    VALIDATE_PROTOTYPE(RegSetValue);

    if (g_bRunningOnNT)
    {
        return RegSetValueW(hKey, lpSubKey, dwType, lpData, cbData);
    }

    CStrIn  strKey(lpSubKey);
    CStrIn  strValue(lpData);

    return RegSetValueA(hKey, strKey, dwType, strValue, cbData);
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_ADVAPI32_WRAPPER

LONG APIENTRY
RegSetValueExWrapW(
                  HKEY        hKey,
                  LPCWSTR     lpValueName,
                  DWORD       Reserved,
                  DWORD       dwType,
                  CONST BYTE* lpData,
                  DWORD       cbData)
{
    VALIDATE_PROTOTYPE(RegSetValueEx);
    ASSERT(dwType != REG_MULTI_SZ);

    if (g_bRunningOnNT)
    {
        return RegSetValueExW(
                             hKey,
                             lpValueName,
                             Reserved,
                             dwType,
                             lpData,
                             cbData);
    }


    CStrIn      strKey(lpValueName);
    CStrIn      strSZ((dwType == REG_SZ || dwType == REG_EXPAND_SZ) ? (LPCWSTR) lpData : NULL);

    if (strSZ)
    {
        lpData = (LPBYTE) (LPSTR) strSZ;
        cbData = strSZ.strlen() + 1;
    }

    return RegSetValueExA(
                         hKey,
                         strKey,
                         Reserved,
                         dwType,
                         lpData,
                         cbData);
}

#endif // NEED_ADVAPI32_WRAPPER

#ifdef NEED_USER32_WRAPPER

ATOM WINAPI
RegisterClassWrapW(CONST WNDCLASSW * lpWndClass)
{
    VALIDATE_PROTOTYPE(RegisterClass);

    if (g_bRunningOnNT)
    {
        return RegisterClassW(lpWndClass);
    }

    WNDCLASSA   wc;
    CStrIn      strMenuName(lpWndClass->lpszMenuName);
    CStrIn      strClassName(lpWndClass->lpszClassName);

    ASSERT(sizeof(wc) == sizeof(*lpWndClass));
    memcpy(&wc, lpWndClass, sizeof(wc));

    wc.lpszMenuName = strMenuName;
    wc.lpszClassName = strClassName;

    return RegisterClassA(&wc);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

UINT WINAPI
RegisterClipboardFormatWrapW(LPCWSTR lpString)
{
    VALIDATE_PROTOTYPE(RegisterClipboardFormat);

    if (g_bRunningOnNT)
    {
        return RegisterClipboardFormatW(lpString);
    }

    CStrIn  str(lpString);

    return RegisterClipboardFormatA(str);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

UINT WINAPI
RegisterWindowMessageWrapW(LPCWSTR lpString)
{
    VALIDATE_PROTOTYPE(RegisterWindowMessage);

    if (g_bRunningOnNT)
    {
        return RegisterWindowMessageW(lpString);
    }

    CStrIn  str(lpString);

    return RegisterWindowMessageA(str);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI
RemoveDirectoryWrapW(LPCWSTR lpszDir)
{
    VALIDATE_PROTOTYPE(RemoveDirectory);

    if (g_bRunningOnNT)
    {
        return RemoveDirectoryW(lpszDir);
    }

    CStrIn  strDir(lpszDir);

    return RemoveDirectoryA(strDir);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HANDLE WINAPI
RemovePropWrapW(
               HWND    hWnd,
               LPCWSTR lpString)
{
    VALIDATE_PROTOTYPE(RemoveProp);

    if (g_bRunningOnNT)
    {
        return RemovePropW(hWnd, lpString);
    }

    CStrIn  str(lpString);

    return RemovePropA(hWnd, str);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

LRESULT WINAPI SendMessageWrapW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
//  NOTE (SumitC) Instead of calling SendDlgItemMessageA below, I'm forwarding to
//       SendMessageWrap so as not to have to re-do the special-case processing.
LRESULT WINAPI
SendDlgItemMessageWrapW(
                       HWND    hDlg,
                       int     nIDDlgItem,
                       UINT    Msg,
                       WPARAM  wParam,
                       LPARAM  lParam)
{
    VALIDATE_PROTOTYPE(SendDlgItemMessage);

    if (g_bRunningOnNT)
    {
        return SendDlgItemMessageW(hDlg, nIDDlgItem, Msg, wParam, lParam);
    }

    HWND hWnd;

    hWnd = GetDlgItem(hDlg, nIDDlgItem);

    return SendMessageWrapW(hWnd, Msg, wParam, lParam);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

#if DBG
int g_cSMTot, g_cSMHit;
int g_cSMMod = 100;
#endif

LRESULT WINAPI
SendMessageAThunk(
                 HWND    hWnd,
                 UINT    Msg,
                 WPARAM  wParam,
                 LPARAM  lParam)
{
#if 0 && DBG
    if ((g_cSMTot % g_cSMMod) == 0)
        TraceMsg(DM_PERF, "sm: tot=%d hit=%d", g_cSMTot, g_cSMHit);
#endif
#if 0  //nadima took this out
    DBEXEC(TRUE, g_cSMTot++);
    // todo: perf? seems to be pretty common case, at least for now...
    DBEXEC(Msg > WM_USER, g_cSMHit++);
#endif
#if 0
    if (Msg > WM_USER)
        goto Ldef;
#endif

    switch (Msg)
    {
        case WM_GETTEXT:
            {
                CStrOut str((LPWSTR)lParam, (int) wParam);
                return SendMessageA(hWnd, Msg, (WPARAM) str.BufSize(), (LPARAM) (LPSTR) str);
            }

        case EM_GETLINE:
            {
                LRESULT nLen;

                CStrOut str((LPWSTR) lParam, (* (SHORT *) lParam) + 1);
                * (SHORT *) (LPSTR) str = * (SHORT *) lParam;
                nLen = SendMessageA(hWnd, Msg, (WPARAM) wParam, (LPARAM) (LPSTR) str);
                if (nLen > 0)
                    ((LPSTR) str)[nLen] = '\0';

                return nLen;
            }

        case WM_SETTEXT:
        case CB_ADDSTRING:
        case EM_REPLACESEL:
            ASSERT(wParam == 0 && "wParam should be 0 for these messages");
            // fall through
        case CB_SELECTSTRING:
        case CB_FINDSTRINGEXACT:
        case CB_FINDSTRING:
        case CB_INSERTSTRING:
            {
                CStrIn  str((LPWSTR) lParam);
                return SendMessageA(hWnd, Msg, wParam, (LPARAM) (LPSTR) str);
            }

        case LB_ADDSTRING:
        case LB_INSERTSTRING:
        case LB_FINDSTRINGEXACT:
            {
                LONG wndStyle = GetWindowLongA( hWnd, GWL_STYLE);
                // (nadima)
                // If the control is an ownerdraw and does not have
                // LBS_HASSTRINGS then treat lParam as an opaque ptr
                // NOT a string. This fixes a bug in this original code
                // which would mess up our browse for servers UI
                //
                if(hWnd && !(wndStyle & LBS_HASSTRINGS) &&
                   (wndStyle & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE)))
                {
                    return SendMessageA(hWnd, Msg, wParam, lParam);
                }
                else
                {
                    //Otherwise it really is a string so convert it
                    CStrIn str((LPWSTR) lParam);
                    return SendMessageA(hWnd, Msg, wParam, (LPARAM) (LPSTR) str);
                }
            }

        case LB_GETTEXT:
        case CB_GETLBTEXT:
            {
                CStrOut str((LPWSTR)lParam, 255);
                return SendMessageA(hWnd, Msg, wParam, (LPARAM) (LPSTR) str);
            }

        case EM_SETPASSWORDCHAR:
            {
                WPARAM  wp = 0;

                ASSERT(HIWORD64(wParam) == 0);
                SHUnicodeToAnsi((LPWSTR) &wParam, (LPSTR) &wp, sizeof(wp));
                ASSERT(HIWORD64(wp) == 0);

                return SendMessageA(hWnd, Msg, wp, lParam);
            }

        case TCM_INSERTITEM:
            {
                LPTCITEM lptc = (LPTCITEM) lParam;
                LPWSTR wszOldStr = NULL;
                LRESULT lr;

                if(lptc && (lptc->mask & TCIF_TEXT) && lptc->pszText)
                {
                    //
                    // Cheat by using the same LPTCITEM but converting
                    // the text field
                    //
                    wszOldStr = lptc->pszText;
                    CStrIn str(lptc->pszText);
                    // hack to force str to convert to ANSI and then assign
                    // back to the same structure.
                    lptc->pszText = (LPTSTR)((char*) str);
                    //translate the message TCM_INSERTITEMA is a different
                    //value than TCM_INSERTITEMW
                    lr = SendMessageA( hWnd, TCM_INSERTITEMA, wParam, (LPARAM) lptc);

                    //
                    // replace the old string
                    //
                    lptc->pszText = wszOldStr;
                    return lr;
                }
                else
                {
                    //translate the message TCM_INSERTITEMA is a different
                    //value than TCM_INSERTITEMW
                    return SendMessageA( hWnd, TCM_INSERTITEMA, wParam, lParam);
                }
            }
            break;

        case CBEM_INSERTITEM:
            {
                LPWSTR wszOldStr = NULL;
                LRESULT lr;
                PCOMBOBOXEXITEM pcex = (PCOMBOBOXEXITEM)lParam;
                if(pcex && (pcex->mask & CBEIF_TEXT) && pcex->pszText)
                {
                    //
                    // Cheat by using the same PCOMBOBOXEXITEM but converting
                    // the text field
                    //
                    wszOldStr = pcex->pszText;
                    CStrIn str(pcex->pszText);
                    // hack to force str to convert to ANSI and then assign
                    // back to the same structure.
                    pcex->pszText = (LPTSTR)((char*) str);
                    //translate the message CBEM_INSERTITEMW is a different
                    //value than CBEM_INSERTITEMA
                    lr = SendMessageA( hWnd, CBEM_INSERTITEMA, wParam, (LPARAM) pcex);

                    //
                    // replace the old string
                    //
                    pcex->pszText = wszOldStr;
                    return lr;
                }
                else
                {
                    //Just translate the message
                    return SendMessageA( hWnd, CBEM_INSERTITEMA, wParam, lParam);
                }
            }
            break;

        case TVM_INSERTITEM:
            {
                LPWSTR wszOldStr = NULL;
                LRESULT lr;
                LPTVINSERTSTRUCT lptv = (LPTVINSERTSTRUCT) lParam;
                if(lptv && (lptv->item.mask & TVIF_TEXT) && lptv->item.pszText)
                {
                    //
                    // Cheat by using the same LPTVINSERTSTRUCT but converting
                    // the text field
                    //
                    wszOldStr = lptv->item.pszText;
                    CStrIn str(lptv->item.pszText);
                    // hack to force str to convert to ANSI and then assign
                    // back to the same structure.
                    lptv->item.pszText = (LPTSTR)((char*) str);
                    //translate the message TVM_INSERTITEMW is a different
                    //value than TVM_INSERTITEMA
                    lr = SendMessageA( hWnd, TVM_INSERTITEMA, wParam, (LPARAM) lptv);

                    //
                    // replace the old string
                    //
                    lptv->item.pszText = wszOldStr;
                    return lr;
                }
                else
                {
                    //Just translate the message
                    return SendMessageA( hWnd, TVM_INSERTITEMA, wParam, lParam);
                }

                return 0;
            }
            break;

        case TVM_GETITEM:
            {
                //UNHANDLED case: retreiving text from the tree
                //this is a nightmare because the memory could normally
                //be allocated by the tree control and so there would be
                //no good place to free it in UNIWRAP. Luckily nothing in tsclient
                //does this right now, but if that changes pop an assert and
                //add support.
                LPTVITEM ptvi = (LPTVITEM)lParam;
                if(ptvi)
                {
                    //Unsupported
                    ASSERT(!((ptvi->mask & TVIF_TEXT)));
                }
                return SendMessageA( hWnd, Msg, wParam, lParam);
            }
            break;

        case CBEM_SETITEM:
        case CBEM_GETITEM:
        case TCM_GETITEM:
        case TCM_SETITEM:
        case TTM_DELTOOL:
        case TTM_ADDTOOL:
        case TVM_SETITEM:
            {
                //UNHANDLED case, need to add support if we start using these
                ASSERT(0);
                // Bad things can happen here if UNICODE strings
                // are not converted
                return SendMessageA(hWnd, Msg, wParam, lParam);
            }
            break;

        case TB_ADDBUTTONS:
            {
                //Translate to the A version
                return SendMessageA(hWnd, TB_ADDBUTTONSA, wParam, lParam);
            }
            break;

        default:
//Ldef:
            return SendMessageA(hWnd, Msg, wParam, lParam);
    }
}


LRESULT FORWARD_API WINAPI
SendMessageWrapW(
                HWND    hWnd,
                UINT    Msg,
                WPARAM  wParam,
                LPARAM  lParam)
{
    VALIDATE_PROTOTYPE(SendMessage);

    // perf: we should do _asm here (see CallWindowProcWrapW), but
    // to do that we need to 'outline' the below switch (o.w. we
    // can't be 'naked').  that in turn slows down the non-NT case...

    // n.b. THUNK not FORWARD
    THUNK_AW(SendMessage, (hWnd, Msg, wParam, lParam));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI
SetCurrentDirectoryWrapW(LPCWSTR lpszCurDir)
{
    VALIDATE_PROTOTYPE(SetCurrentDirectory);

    if (g_bRunningOnNT)
    {
        return SetCurrentDirectoryW(lpszCurDir);
    }

    CStrIn  str(lpszCurDir);

    return SetCurrentDirectoryA(str);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
SetDlgItemTextWrapW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString)
{
    VALIDATE_PROTOTYPE(SetDlgItemText);
    if (g_bRunningOnNT)
    {
        return SetDlgItemTextW(hDlg, nIDDlgItem, lpString);
    }

    CStrIn  str(lpString);

    return SetDlgItemTextA(hDlg, nIDDlgItem, str);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
SetMenuItemInfoWrapW(
                    HMENU hMenu,
                    UINT uItem,
                    BOOL fByPosition,
                    LPCMENUITEMINFOW lpmiiW)
{
    VALIDATE_PROTOTYPE(SetMenuItemInfo);
    ASSERT(lpmiiW->cbSize == MENUITEMINFOSIZE_WIN95); // Ensure Win95 compatibility

    if (g_bRunningOnNT)
    {
        return SetMenuItemInfoW( hMenu, uItem, fByPosition, lpmiiW);
    }

    BOOL fRet;

    ASSERT( sizeof(MENUITEMINFOW) == sizeof(MENUITEMINFOA) &&
            FIELD_OFFSET(MENUITEMINFOW, dwTypeData) ==
            FIELD_OFFSET(MENUITEMINFOA, dwTypeData) );

    if ( (MIIM_TYPE & lpmiiW->fMask) &&
         0 == (lpmiiW->fType & (MFT_BITMAP | MFT_SEPARATOR)))
    {
        MENUITEMINFOA miiA;
        // the cch is ignored on SetMenuItemInfo
        CStrIn str((LPWSTR)lpmiiW->dwTypeData, -1);

        memcpy( &miiA, lpmiiW, sizeof(MENUITEMINFOA) );
        miiA.dwTypeData = (LPSTR)str;
        miiA.cch = str.strlen();

        fRet = SetMenuItemInfoA( hMenu, uItem, fByPosition, &miiA );
    }
    else
    {
        fRet = SetMenuItemInfoA( hMenu, uItem, fByPosition,
                                 (LPCMENUITEMINFOA)lpmiiW );
    }

    return fRet;
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
SetPropWrapW(
            HWND    hWnd,
            LPCWSTR lpString,
            HANDLE  hData)
{
    VALIDATE_PROTOTYPE(SetProp);

    if (g_bRunningOnNT)
    {
        return SetPropW(hWnd, lpString, hData);
    }

    CStrIn  str(lpString);

    return SetPropA(hWnd, str, hData);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

LONG FORWARD_API WINAPI
SetWindowLongWrapW(HWND hWnd, int nIndex, LONG dwNewLong)
{
    VALIDATE_PROTOTYPE(SetWindowLong);

    FORWARD_AW(SetWindowLong, (hWnd, nIndex, dwNewLong));
}

LONG_PTR FORWARD_API WINAPI
SetWindowLongPtrWrapW(
    HWND hWnd,
    int nIndex,
    LONG_PTR dwNewLong)
{
    VALIDATE_PROTOTYPE(SetWindowLongPtr);

    FORWARD_AW(SetWindowLongPtr, (hWnd, nIndex, dwNewLong));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HHOOK
FORWARD_API WINAPI
SetWindowsHookExWrapW(
                     int idHook,
                     HOOKPROC lpfn,
                     HINSTANCE hmod,
                     DWORD dwThreadId)
{
    VALIDATE_PROTOTYPE(SetWindowsHookEx);

    FORWARD_AW(SetWindowsHookEx, (idHook, lpfn, hmod, dwThreadId));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
SetWindowTextWrapW(HWND hWnd, LPCWSTR lpString)
{
    VALIDATE_PROTOTYPE(SetWindowText);

    if (g_bRunningOnNT)
    {
        return SetWindowTextW(hWnd, lpString);
    }

    CStrIn  str(lpString);

    return SetWindowTextA(hWnd, str);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
SystemParametersInfoWrapW(
                         UINT    uiAction,
                         UINT    uiParam,
                         PVOID   pvParam,
                         UINT    fWinIni)
{
    VALIDATE_PROTOTYPE(SystemParametersInfo);

    if (g_bRunningOnNT)
    {
        return SystemParametersInfoW(
                                    uiAction,
                                    uiParam,
                                    pvParam,
                                    fWinIni);
    }

    BOOL        ret;
    char        ach[LF_FACESIZE];

    if (uiAction == SPI_SETDESKWALLPAPER)
    {
        CStrIn str((LPCWSTR) pvParam);

        ret = SystemParametersInfoA(
                                   uiAction,
                                   uiParam,
                                   str,
                                   fWinIni);
    }
    else
        ret = SystemParametersInfoA(
                                   uiAction,
                                   uiParam,
                                   pvParam,
                                   fWinIni);

    if ((uiAction == SPI_GETICONTITLELOGFONT) && ret)
    {
        strcpy(ach, ((LPLOGFONTA)pvParam)->lfFaceName);
        SHAnsiToUnicode(ach, ((LPLOGFONTW)pvParam)->lfFaceName, ARRAYSIZE(((LPLOGFONTW)pvParam)->lfFaceName));
    }

    return ret;
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

int FORWARD_API WINAPI
TranslateAcceleratorWrapW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
{
    VALIDATE_PROTOTYPE(TranslateAccelerator);

    FORWARD_AW(TranslateAccelerator, (hWnd, hAccTable, lpMsg));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
UnregisterClassWrapW(LPCWSTR lpClassName, HINSTANCE hInstance)
{
    VALIDATE_PROTOTYPE(UnregisterClass);

    if (g_bRunningOnNT)
    {
        return UnregisterClassW(lpClassName, hInstance);
    }

    CStrIn  str(lpClassName);

    return UnregisterClassA(str, hInstance);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

SHORT
WINAPI
VkKeyScanWrapW(WCHAR ch)
{
    VALIDATE_PROTOTYPE(VkKeyScan);

    if (g_bRunningOnNT)
    {
        return VkKeyScanW(ch);
    }

    CStrIn str(&ch, 1);

    return VkKeyScanA(*(char *)str);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI
WinHelpWrapW(HWND hwnd, LPCWSTR szFile, UINT uCmd, ULONG_PTR dwData)
{
    VALIDATE_PROTOTYPE(WinHelp);

    if (g_bRunningOnNT)
    {
        return WinHelpW(hwnd, szFile, uCmd, dwData);
    }

    CStrIn  str(szFile);

    return WinHelpA(hwnd, str, uCmd, dwData);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

//+---------------------------------------------------------------------------
//
//  Function:   wsprintfW
//
//  Synopsis:   Nightmare string function
//
//  Arguments:  [pwszOut]    --
//              [pwszFormat] --
//              [...]        --
//
//  Returns:
//
//  History:    1-06-94   ErikGav   Created
//
//  Notes:      If you're reading this, you're probably having a problem with
//              this function.  Make sure that your "%s" in the format string
//              says "%ws" if you are passing wide strings.
//
//              %s on NT means "wide string"
//              %s on Chicago means "ANSI string"
//
//  BUGBUG:     This function should not be used.  Use Format instead.
//
//----------------------------------------------------------------------------

int WINAPI
wvsprintfWrapW(LPWSTR pwszOut, LPCWSTR pwszFormat, va_list arglist)
{
    VALIDATE_PROTOTYPE(wvsprintf);

    if (g_bRunningOnNT)
    {
        return wvsprintfW(pwszOut, pwszFormat, arglist);
    }

    // Consider: Out-string bufsize too large or small?

    CStrOut strOut(pwszOut, 1024);
    CStrIn  strFormat(pwszFormat);

#if DBG == 1 /* { */
    {
        LPCWSTR  pwch;
        for (pwch = pwszFormat; *pwch; pwch++)
        {
            ASSERT(pwch[0] != L'%' || pwch[1] != L's');
        }
    }
#endif /* } */

    wvsprintfA(strOut, strFormat, arglist);

    return strOut.ConvertExcludingNul();
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_MPR_WRAPPER

//+---------------------------------------------------------------------------
//
//  Function:   WNetRestoreConnectionWrapW
//
//----------------------------------------------------------------------------

DWORD WINAPI WNetRestoreConnectionWrapW(IN HWND hwndParent, IN LPCWSTR pwzDevice)
{
    VALIDATE_PROTOTYPE(WNetRestoreConnection);

    if (g_bRunningOnNT)
    {
        return WNetRestoreConnectionW(hwndParent, pwzDevice);
    }

    CStrIn  strIn(pwzDevice);
    return WNetRestoreConnectionA(hwndParent, strIn);
}

#endif // NEED_MPR_WRAPPER

#ifdef NEED_MPR_WRAPPER

//+---------------------------------------------------------------------------
//
//  Function:   WNetGetLastErrorWrapW
//
//
//----------------------------------------------------------------------------

DWORD WINAPI WNetGetLastErrorWrapW(OUT LPDWORD pdwError, OUT LPWSTR pwzErrorBuf, IN DWORD cchErrorBufSize, OUT LPWSTR pwzNameBuf, IN DWORD cchNameBufSize)
{
    VALIDATE_PROTOTYPE(WNetGetLastError);

    if (g_bRunningOnNT)
    {
        return WNetGetLastErrorW(pdwError, pwzErrorBuf, cchErrorBufSize, pwzNameBuf, cchNameBufSize);
    }

    // Consider: Out-string bufsize too large or small?
    CStrOut strErrorOut(pwzErrorBuf, cchErrorBufSize);
    CStrOut strNameOut(pwzNameBuf, cchNameBufSize);

    DWORD dwResult = WNetGetLastErrorA(pdwError, strErrorOut, strErrorOut.BufSize(), strNameOut, strNameOut.BufSize());

    strErrorOut.ConvertExcludingNul();
    strNameOut.ConvertExcludingNul();
    return dwResult;
}

#endif // NEED_MPR_WRAPPER

#ifdef NEED_USER32_WRAPPER

int WINAPI DrawTextExWrapW(
                          HDC hdc,    // handle of device context
                          LPWSTR pwzText, // address of string to draw
                          int cchText,    // length of string to draw
                          LPRECT lprc,    // address of rectangle coordinates
                          UINT dwDTFormat,    // formatting options
                          LPDRAWTEXTPARAMS lpDTParams // address of structure for more options
                          )
{
    VALIDATE_PROTOTYPE(DrawTextEx);
    if (g_bRunningOnNT)
        return DrawTextExW(hdc, pwzText, cchText, lprc, dwDTFormat, lpDTParams);

    CStrIn strText(pwzText, cchText);
    return DrawTextExA(hdc, strText, strText.strlen(), lprc, dwDTFormat, lpDTParams);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

void SetThunkMenuItemInfoWToA(LPCMENUITEMINFOW pmiiW, LPMENUITEMINFOA pmiiA, LPSTR pszBuffer, DWORD cchSize)
{
    *pmiiA = *(LPMENUITEMINFOA) pmiiW;


    // MFT_STRING is Zero. So MFT_STRING & anything evaluates to False.
    if ((pmiiW->dwTypeData) && (MFT_STRING & pmiiW->fType) == 0)
    {
        pmiiA->dwTypeData = pszBuffer;
        pmiiA->cch = cchSize;
        SHUnicodeToAnsi(pmiiW->dwTypeData, pmiiA->dwTypeData, cchSize);
    }
}

void GetThunkMenuItemInfoWToA(LPCMENUITEMINFOW pmiiW, LPMENUITEMINFOA pmiiA, LPSTR pszBuffer, DWORD cchSize)
{
    *pmiiA = *(LPMENUITEMINFOA) pmiiW;

    if ((pmiiW->dwTypeData) && (MFT_STRING & pmiiW->fType))
    {
        pszBuffer[0] = 0;
        pmiiA->dwTypeData = pszBuffer;
        pmiiA->cch = cchSize;
    }
}

void GetThunkMenuItemInfoAToW(LPCMENUITEMINFOA pmiiA, LPMENUITEMINFOW pmiiW)
{
    LPWSTR pwzText = pmiiW->dwTypeData;

    *pmiiW = *(LPMENUITEMINFOW) pmiiA;
    pmiiW->dwTypeData = pwzText;

    if ((pmiiA->dwTypeData) && (pwzText) && !((MFT_SEPARATOR | MFT_BITMAP) & pmiiW->fType))
        SHAnsiToUnicode(pmiiA->dwTypeData, pmiiW->dwTypeData, (pmiiW->cch + 1));
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

#if UNUSED_DONOTBUILD
BOOL WINAPI GetMenuItemInfoWrapW(
                                HMENU  hMenu,
                                UINT  uItem,
                                BOOL  fByPosition,
                                LPMENUITEMINFOW  pmiiW)
{
    BOOL fResult;
    VALIDATE_PROTOTYPE(GetMenuItemInfo);
    ASSERT(pmiiW->cbSize == MENUITEMINFOSIZE_WIN95); // Ensure Win95 compatibility

#ifndef UNIX
    // Widechar API's are messed up in MAINWIN. For now assume not ruuning on
    // NT for this.
    if (g_bRunningOnNT)
        fResult = GetMenuItemInfoW(hMenu, uItem, fByPosition, pmiiW);
    else
#endif
    {
        if (pmiiW->fMask & MIIM_TYPE)
        {
            MENUITEMINFOA miiA = *(LPMENUITEMINFOA)pmiiW;
            LPSTR pszText = NULL;

            if (pmiiW->cch > 0)
                pszText = NEW(char[pmiiW->cch]);

            miiA.dwTypeData = pszText;
            fResult = GetMenuItemInfoA(hMenu, uItem, fByPosition, &miiA);
            GetThunkMenuItemInfoAToW(&miiA, pmiiW);

            if (pszText)
                delete pszText;
        }
        else
            fResult = GetMenuItemInfoA(hMenu, uItem, fByPosition, (LPMENUITEMINFOA) pmiiW); // It doesn't contain a string so W and A are the same.
    }

    return fResult;
}
#endif // UNUSED_DONOTBUILD

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

BOOL WINAPI InsertMenuItemWrapW(
                               HMENU hMenu,
                               UINT uItem,
                               BOOL fByPosition,
                               LPCMENUITEMINFOW pmiiW)
{
    VALIDATE_PROTOTYPE(InsertMenuItem);
    ASSERT(pmiiW->cbSize == MENUITEMINFOSIZE_WIN95); // Ensure Win95 compatibility

    BOOL fResult;

    if (g_bRunningOnNT)
        return InsertMenuItemW(hMenu, uItem, fByPosition, pmiiW);

    MENUITEMINFOA miiA;
    CHAR szText[MAX_PATH*3]; //nadima changed from INTERNET_MAX_URL_LENGTH

    SetThunkMenuItemInfoWToA(pmiiW, &miiA, szText, ARRAYSIZE(szText));
    fResult = InsertMenuItemA(hMenu, uItem, fByPosition, &miiA);

    return fResult;
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

HFONT WINAPI
CreateFontWrapW(int  nHeight,   // logical height of font
                int  nWidth,    // logical average character width
                int  nEscapement,   // angle of escapement
                int  nOrientation,  // base-line orientation angle
                int  fnWeight,  // font weight
                DWORD  fdwItalic,   // italic attribute flag
                DWORD  fdwUnderline,    // underline attribute flag
                DWORD  fdwStrikeOut,    // strikeout attribute flag
                DWORD  fdwCharSet,  // character set identifier
                DWORD  fdwOutputPrecision,  // output precision
                DWORD  fdwClipPrecision,    // clipping precision
                DWORD  fdwQuality,  // output quality
                DWORD  fdwPitchAndFamily,   // pitch and family
                LPCWSTR  pwzFace)   // address of typeface name string )
{
    VALIDATE_PROTOTYPE(CreateFont);

    if (g_bRunningOnNT)
    {
        return CreateFontW(nHeight, nWidth, nEscapement, nOrientation, fnWeight, fdwItalic,
                           fdwUnderline, fdwStrikeOut, fdwCharSet, fdwOutputPrecision,
                           fdwClipPrecision, fdwQuality, fdwPitchAndFamily, pwzFace);
    }

    CStrIn  str(pwzFace);
    return CreateFontA(nHeight, nWidth, nEscapement, nOrientation, fnWeight, fdwItalic,
                       fdwUnderline, fdwStrikeOut, fdwCharSet, fdwOutputPrecision,
                       fdwClipPrecision, fdwQuality, fdwPitchAndFamily, str);
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HANDLE WINAPI CreateMutexWrapW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR pwzName)
{
    VALIDATE_PROTOTYPE(CreateMutex);

    if (g_bRunningOnNT)
        return CreateMutexW(lpMutexAttributes, bInitialOwner, pwzName);

    CStrIn strText(pwzName);
    return CreateMutexA(lpMutexAttributes, bInitialOwner, strText);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_GDI32_WRAPPER

HDC WINAPI CreateMetaFileWrapW(LPCWSTR pwzFile)
{
    VALIDATE_PROTOTYPE(CreateMetaFile);

    if (g_bRunningOnNT)
        return CreateMetaFileW(pwzFile);

    CStrIn strText(pwzFile);
    return CreateMetaFileA(strText);
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

DWORD WINAPI ExpandEnvironmentStringsWrapW(LPCWSTR pwzSrc, LPWSTR pwzDst, DWORD cchSize)
{
    VALIDATE_PROTOTYPE(ExpandEnvironmentStrings);
    if (pwzDst)
    {
        VALIDATE_OUTBUF(pwzDst, cchSize);
    }


    if (g_bRunningOnNT)
        return ExpandEnvironmentStringsW(pwzSrc, pwzDst, cchSize);

    CStrIn strTextIn(pwzSrc);
    CStrOut strTextOut(pwzDst, cchSize);
    DWORD dwResult = ExpandEnvironmentStringsA(strTextIn, strTextOut, strTextOut.BufSize());
    strTextOut.ConvertIncludingNul();

    return dwResult;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HANDLE WINAPI CreateSemaphoreWrapW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR pwzName)
{
    VALIDATE_PROTOTYPE(CreateSemaphore);
    if (g_bRunningOnNT)
        return CreateSemaphoreW(lpSemaphoreAttributes, lInitialCount, lMaximumCount, pwzName);

    CStrIn strText(pwzName);
    return CreateSemaphoreA(lpSemaphoreAttributes, lInitialCount, lMaximumCount, strText);
}

#endif // NEED_KERNEL32_WRAPPER

// BUGBUG: Todo - GetStartupInfoWrapW

#ifdef NEED_KERNEL32_WRAPPER

#define ISGOOD 0
#define ISBAD 1

BOOL WINAPI IsBadStringPtrWrapW(LPCWSTR pwzString, UINT_PTR ucchMax)
{
    VALIDATE_PROTOTYPE(IsBadStringPtr);
    if (g_bRunningOnNT)
        return IsBadStringPtrW(pwzString, ucchMax);

    if (!ucchMax)
        return ISGOOD;

    if (!pwzString)
        return ISBAD;

    LPCWSTR pwzStartAddress = pwzString;
    // ucchMax maybe -1 but that's ok because the loop down below will just
    // look for the terminator.
    LPCWSTR pwzEndAddress = &pwzStartAddress[ucchMax - 1];
    TCHAR chTest;

    _try
    {
        chTest = *(volatile WCHAR *)pwzStartAddress;
        while (chTest && (pwzStartAddress != pwzEndAddress))
        {
            pwzStartAddress++;
            chTest = *(volatile WCHAR *)pwzStartAddress;
        }
    }
    _except (EXCEPTION_EXECUTE_HANDLER)
    {
        return ISBAD;
    }

    return ISGOOD;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

HINSTANCE WINAPI LoadLibraryWrapW(LPCWSTR pwzLibFileName)
{
    VALIDATE_PROTOTYPE(LoadLibrary);

    if (g_bRunningOnNT)
        return LoadLibraryW(pwzLibFileName);

    CStrIn  strFileName(pwzLibFileName);
    return LoadLibraryA(strFileName);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

int WINAPI GetTimeFormatWrapW(LCID Locale, DWORD dwFlags, CONST SYSTEMTIME * lpTime, LPCWSTR pwzFormat, LPWSTR pwzTimeStr, int cchTime)
{
    VALIDATE_PROTOTYPE(GetTimeFormat);
    if (g_bRunningOnNT)
        return GetTimeFormatW(Locale, dwFlags, lpTime, pwzFormat, pwzTimeStr, cchTime);

    CStrIn strTextIn(pwzFormat);
    CStrOut strTextOut(pwzTimeStr, cchTime);
    int nResult = GetTimeFormatA(Locale, dwFlags, lpTime, strTextIn, strTextOut, strTextOut.BufSize());
    strTextOut.ConvertIncludingNul();

    return nResult;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

int WINAPI GetDateFormatWrapW(LCID Locale, DWORD dwFlags, CONST SYSTEMTIME * lpDate, LPCWSTR pwzFormat, LPWSTR pwzDateStr, int cchDate)
{
    VALIDATE_PROTOTYPE(GetDateFormat);
    if (g_bRunningOnNT)
        return GetDateFormatW(Locale, dwFlags, lpDate, pwzFormat, pwzDateStr, cchDate);

    CStrIn strTextIn(pwzFormat);
    CStrOut strTextOut(pwzDateStr, cchDate);
    int nResult = GetDateFormatA(Locale, dwFlags, lpDate, strTextIn, strTextOut, strTextOut.BufSize());
    strTextOut.ConvertIncludingNul();

    return nResult;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI WritePrivateProfileStringWrapW(LPCWSTR pwzAppName, LPCWSTR pwzKeyName, LPCWSTR pwzString, LPCWSTR pwzFileName)
{
    VALIDATE_PROTOTYPE(WritePrivateProfileString);
    if (g_bRunningOnNT)
        return WritePrivateProfileStringW(pwzAppName, pwzKeyName, pwzString, pwzFileName);

    CStrIn strTextAppName(pwzAppName);
    CStrIn strTextKeyName(pwzKeyName);
    CStrIn strTextString(pwzString);
    CStrIn strTextFileName(pwzFileName);

    return WritePrivateProfileStringA(strTextAppName, strTextKeyName, strTextString, strTextFileName);
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

DWORD WINAPI GetPrivateProfileStringWrapW(LPCWSTR pwzAppName, LPCWSTR pwzKeyName, LPCWSTR pwzDefault, LPWSTR pwzReturnedString, DWORD cchSize, LPCWSTR pwzFileName)
{
    VALIDATE_PROTOTYPE(GetPrivateProfileString);
    if (g_bRunningOnNT)
        return GetPrivateProfileStringW(pwzAppName, pwzKeyName, pwzDefault, pwzReturnedString, cchSize, pwzFileName);

    CStrIn strTextAppName(pwzAppName);
    CStrIn strTextKeyName(pwzKeyName);
    CStrIn strTextDefault(pwzDefault);
    CStrIn strTextFileName(pwzFileName);

    CStrOut strTextOut(pwzReturnedString, cchSize);
    DWORD dwResult = GetPrivateProfileStringA(strTextAppName, strTextKeyName, strTextDefault, strTextOut, cchSize, strTextFileName);
    strTextOut.ConvertIncludingNul();

    return dwResult;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_SHELL32_WRAPPER

STDAPI_(DWORD_PTR) SHGetFileInfoWrapW(LPCWSTR pwzPath, DWORD dwFileAttributes, SHFILEINFOW FAR  *psfi, UINT cbFileInfo, UINT uFlags)
{
    VALIDATE_PROTOTYPE_DELAYLOAD(SHGetFileInfo, _SHGetFileInfo);
    if (g_bRunningOnNT)
        return _SHGetFileInfoW(pwzPath, dwFileAttributes, psfi, cbFileInfo, uFlags);

    SHFILEINFOA shFileInfo;
    DWORD_PTR dwResult;

    shFileInfo.szDisplayName[0] = 0;        // Terminate so we can always thunk afterward.
    shFileInfo.szTypeName[0] = 0;           // Terminate so we can always thunk afterward.

    // Do we need to thunk the Path?
    if (SHGFI_PIDL & uFlags)
    {
        // No, because it's really a pidl pointer.
        dwResult = _SHGetFileInfoA((LPCSTR)pwzPath, dwFileAttributes, &shFileInfo, sizeof(shFileInfo), uFlags);
    }
    else
    {
        // Yes
        CStrIn strPath(pwzPath);
        dwResult = _SHGetFileInfoA(strPath, dwFileAttributes, &shFileInfo, sizeof(shFileInfo), uFlags);
    }

    psfi->hIcon = shFileInfo.hIcon;
    psfi->iIcon = shFileInfo.iIcon;
    psfi->dwAttributes = shFileInfo.dwAttributes;
    SHAnsiToUnicode(shFileInfo.szDisplayName, psfi->szDisplayName, ARRAYSIZE(shFileInfo.szDisplayName));
    SHAnsiToUnicode(shFileInfo.szTypeName, psfi->szTypeName, ARRAYSIZE(shFileInfo.szTypeName));

    return dwResult;
}

#endif // NEED_SHELL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

STDAPI_(ATOM) RegisterClassExWrapW(CONST WNDCLASSEXW FAR * pwcx)
{
    VALIDATE_PROTOTYPE(RegisterClassEx);
    if (g_bRunningOnNT)
        return RegisterClassExW(pwcx);

    CStrIn strMenuName(pwcx->lpszMenuName);
    CStrIn strClassName(pwcx->lpszClassName);
    WNDCLASSEXA wcx = *(CONST WNDCLASSEXA FAR *) pwcx;
    wcx.cbSize = sizeof(wcx);
    wcx.lpszMenuName = strMenuName;
    wcx.lpszClassName = strClassName;

    return RegisterClassExA(&wcx);
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

STDAPI_(BOOL) GetClassInfoExWrapW(HINSTANCE hinst, LPCWSTR pwzClass, LPWNDCLASSEXW lpwcx)
{
    VALIDATE_PROTOTYPE(GetClassInfoEx);
    if (g_bRunningOnNT)
        return GetClassInfoExW(hinst, pwzClass, lpwcx);

    BOOL fResult;
    CStrIn strClassName(pwzClass);
    WNDCLASSEXA wcx;
    wcx.cbSize = sizeof(wcx);

    fResult = GetClassInfoExA(hinst, strClassName, &wcx);
    *(WNDCLASSEXA FAR *) lpwcx = wcx;
    lpwcx->lpszMenuName = NULL;        // GetClassInfoExA makes this point off to private data that they own.
    lpwcx->lpszClassName = pwzClass;

    return fResult;
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_GDI32_WRAPPER
                
//+---------------------------------------------------------------------------
//      StartDoc
//----------------------------------------------------------------------------

int
StartDocWrapW( HDC hDC, const DOCINFO * lpdi )
{
    VALIDATE_PROTOTYPE(StartDoc);

    if (g_bRunningOnNT)
    {
        return StartDocW( hDC, lpdi );
    }

    CStrIn  strDocName( lpdi->lpszDocName );
    CStrIn  strOutput( lpdi->lpszOutput );
    CStrIn  strDatatype( lpdi->lpszDatatype );
    DOCINFOA dia;

    dia.cbSize = sizeof(DOCINFO);
    dia.lpszDocName = strDocName;
    dia.lpszOutput = strOutput;
    dia.lpszDatatype = strDatatype;
    dia.fwType = lpdi->fwType;

    return StartDocA( hDC, &dia );
}

#endif // NEED_GDI32_WRAPPER

#ifdef NEED_SHELL32_WRAPPER

STDAPI_(UINT) DragQueryFileWrapW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch)
{
    VALIDATE_PROTOTYPE_DELAYLOAD(DragQueryFile, _DragQueryFile);
    VALIDATE_OUTBUF(lpszFile, cch);

    //
    //  We are lazy and do not support lpszFile == NULL to query the length
    //  of an individual string.
    //
    ASSERT(iFile == 0xFFFFFFFF || lpszFile);

    if (g_bRunningOnNT)
        return _DragQueryFileW(hDrop, iFile, lpszFile, cch);

    //
    //  If iFile is 0xFFFFFFFF, then lpszFile and cch are ignored.
    //
    if (iFile == 0xFFFFFFFF)
        return _DragQueryFileA(hDrop, iFile, NULL, 0);

    CStrOut str(lpszFile, cch);

    _DragQueryFileA(hDrop, iFile, str, str.BufSize());
    return str.ConvertExcludingNul();
}

#endif // NEED_SHELL32_WRAPPER

#ifdef NEED_VERSION_WRAPPER

//
//  the version APIs are not conducive to using
//  wrap versions of the APIs, but we are going to
//  do something reasonable....
//
#define VERSIONINFO_BUFF   (MAX_PATH * SIZEOF(WCHAR))

STDAPI_(DWORD)
GetFileVersionInfoSizeWrapW(LPWSTR pwzFilename,  LPDWORD lpdwHandle)
{
    if (g_bRunningOnNT)
    {
        return GetFileVersionInfoSizeW(pwzFilename, lpdwHandle);
    }
    else
    {
        char szFilename[MAX_PATH];
        DWORD dwRet;

        ASSERT(pwzFilename);
        SHUnicodeToAnsi(pwzFilename, szFilename, ARRAYSIZE(szFilename));
        dwRet = GetFileVersionInfoSizeA(szFilename, lpdwHandle);
        if (dwRet > 0)
        {
            // Add a scratch buffer to front for converting to UNICODE
            dwRet += VERSIONINFO_BUFF;
        }
        return dwRet;
    }
}

#endif // NEED_VERSION_WRAPPER

#ifdef NEED_VERSION_WRAPPER

STDAPI_(BOOL)
GetFileVersionInfoWrapW(LPWSTR pwzFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
{
    if (g_bRunningOnNT)
    {
        return GetFileVersionInfoW(pwzFilename, dwHandle, dwLen, lpData);
    }
    else
    {
        char szFilename[MAX_PATH];
        BYTE* pb;

        if (dwLen <= VERSIONINFO_BUFF)
        {
            return FALSE;
        }

        ASSERT(pwzFilename);
        SHUnicodeToAnsi(pwzFilename, szFilename, ARRAYSIZE(szFilename));
        //Skip over our scratch buffer at the beginning
        pb = (BYTE*)lpData + VERSIONINFO_BUFF;

        return GetFileVersionInfoA(szFilename, dwHandle, dwLen - VERSIONINFO_BUFF, (void*)pb);
    }
}

#endif // NEED_VERSION_WRAPPER

#ifdef NEED_VERSION_WRAPPER

STDAPI_(BOOL)
VerQueryValueWrapW(const LPVOID pBlock, LPWSTR pwzSubBlock, LPVOID *ppBuffer, PUINT puLen)
{
    if (g_bRunningOnNT)
    {
        return VerQueryValueW(pBlock, pwzSubBlock, ppBuffer, puLen);
    }
    else
    {
        const WCHAR pwzStringFileInfo[] = L"\\StringFileInfo";

        //
        // WARNING: This function wipes out any string previously returned
        // for this pBlock because a common buffer at the beginning of the
        // block is used for ansi/unicode translation!
        //
        char szSubBlock[MAX_PATH];
        BOOL fRet;
        BYTE* pb;

        ASSERT(pwzSubBlock);
        SHUnicodeToAnsi(pwzSubBlock, szSubBlock, ARRAYSIZE(szSubBlock));

        // The first chunk is our scratch buffer for converting to UNICODE
        pb = (BYTE*)pBlock + VERSIONINFO_BUFF;
        fRet = VerQueryValueA((void*)pb, szSubBlock, ppBuffer, puLen);

        // Convert to unicode if ansi string returned
        if (fRet && StrCmpNIW(pwzSubBlock, pwzStringFileInfo, ARRAYSIZE(pwzStringFileInfo) - 1) == 0)
        {
            // Convert returned string to UNICODE.  We use the scratch buffer
            // at the beginning of pBlock
            LPWSTR pwzBuff = (LPWSTR)pBlock;
            if (*puLen == 0)
            {
                pwzBuff[0] = L'\0';
            }
            else
            {
                SHAnsiToUnicode((LPCSTR)*ppBuffer, pwzBuff, VERSIONINFO_BUFF/sizeof(WCHAR));
            }
            *ppBuffer = pwzBuff;
        }
        return fRet;
    }
}

#endif // NEED_VERSION_WRAPPER

#ifdef NEED_SHELL32_WRAPPER

HRESULT WINAPI SHDefExtractIconWrapW(LPCWSTR pszFile, int nIconIndex,
                                     UINT uFlags, HICON *phiconLarge,
                                     HICON *phiconSmall, UINT nIconSize)
{
    VALIDATE_PROTOTYPE_DELAYLOAD(SHDefExtractIcon, _SHDefExtractIcon);

    HRESULT hr;

    if (UseUnicodeShell32())
    {
        hr = _SHDefExtractIconW(pszFile, nIconIndex, uFlags, phiconLarge,
                                phiconSmall, nIconSize);
    }
    else
    {
        CStrIn striFile(pszFile);

        hr = _SHDefExtractIconA(striFile, nIconIndex, uFlags, phiconLarge,
                                phiconSmall, nIconSize);
    }

    return hr;
}

#endif // NEED_SHELL32_WRAPPER

#ifdef NEED_SHELL32_WRAPPER

BOOL WINAPI SHGetNewLinkInfoWrapW(LPCWSTR pszpdlLinkTo, LPCWSTR pszDir, LPWSTR pszName, BOOL *pfMustCopy, UINT uFlags)
{
    VALIDATE_PROTOTYPE_DELAYLOAD(SHGetNewLinkInfo, _SHGetNewLinkInfo);

    BOOL fRet;

    if (UseUnicodeShell32())
    {
        fRet =  _SHGetNewLinkInfoW(pszpdlLinkTo, pszDir, pszName, pfMustCopy,
                                   uFlags);
    }
    else
    {
        CStrIn  striDir(pszDir);
        CStrOut stroName(pszName, MAX_PATH);

        if (SHGNLI_PIDL & uFlags)
        {
            fRet = _SHGetNewLinkInfoA((LPCSTR)pszpdlLinkTo, striDir,
                                      stroName, pfMustCopy, uFlags);
        }
        else
        {
            CStrIn striLinkTo(pszpdlLinkTo);

            fRet = _SHGetNewLinkInfoA(striLinkTo, striDir, stroName,
                                      pfMustCopy, uFlags);
        }

        if (fRet)
            stroName.ConvertIncludingNul();
    }

    return fRet;
}

#endif // NEED_SHELL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI WritePrivateProfileStructWrapW(LPCWSTR lpszSection, LPCWSTR lpszKey,
                                           LPVOID lpStruct, UINT uSizeStruct,
                                           LPCWSTR szFile)
{
    VALIDATE_PROTOTYPE(WritePrivateProfileStruct);

    BOOL fRet;

    if (UseUnicodeShell32())
    {
        fRet = WritePrivateProfileStructW(lpszSection, lpszKey, lpStruct,
                                          uSizeStruct, szFile);
    }
    else
    {
        CStrIn striSection(lpszSection);
        CStrIn striKey(lpszKey);
        CStrIn striFile(szFile);

        fRet = WritePrivateProfileStructA(striSection, striKey, lpStruct,
                                          uSizeStruct, striFile);
    }

    return fRet;
}

#endif // NEED_KERNEL32_WRAPPER

#ifdef NEED_KERNEL32_WRAPPER

BOOL WINAPI GetPrivateProfileStructWrapW(LPCWSTR lpszSection, LPCWSTR lpszKey,
                                         LPVOID lpStruct, UINT uSizeStruct,
                                         LPCWSTR szFile)
{
    VALIDATE_PROTOTYPE(GetPrivateProfileStruct);

    BOOL fRet;

    if (UseUnicodeShell32())
    {
        fRet = GetPrivateProfileStructW(lpszSection, lpszKey, lpStruct,
                                        uSizeStruct, szFile);
    }
    else
    {
        CStrIn striSection(lpszSection);
        CStrIn striKey(lpszKey);
        CStrIn striFile(szFile);

        fRet = GetPrivateProfileStructA(striSection, striKey, lpStruct,
                                        uSizeStruct, striFile);
    }

    return fRet;
}

#endif // NEED_KERNEL32_WRAPPER

BOOL WINAPI CreateProcessWrapW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine,
                               LPSECURITY_ATTRIBUTES lpProcessAttributes,
                               LPSECURITY_ATTRIBUTES lpThreadAttributes,
                               BOOL bInheritHandles,
                               DWORD dwCreationFlags,
                               LPVOID lpEnvironment,
                               LPCWSTR lpCurrentDirectory,
                               LPSTARTUPINFOW lpStartupInfo,
                               LPPROCESS_INFORMATION lpProcessInformation)
{
    BOOL fRet;

    if (UseUnicodeShell32())
    {
        fRet = CreateProcessW(lpApplicationName, lpCommandLine,
                              lpProcessAttributes, lpThreadAttributes,
                              bInheritHandles, dwCreationFlags, lpEnvironment,
                              lpCurrentDirectory, lpStartupInfo,
                              lpProcessInformation);
    }
    else
    {
        CStrIn striApplicationName(lpApplicationName);
        CStrIn striCommandLine(lpCommandLine);
        CStrIn striCurrentDirectory(lpCurrentDirectory);

        if (NULL == lpStartupInfo)
        {
            fRet = CreateProcessA(striApplicationName, striCommandLine,
                                  lpProcessAttributes, lpThreadAttributes,
                                  bInheritHandles, dwCreationFlags,
                                  lpEnvironment, striCurrentDirectory,
                                  NULL, lpProcessInformation);
        }
        else
        {
            STARTUPINFOA si = *(STARTUPINFOA*)lpStartupInfo;

            CStrIn striReserved(lpStartupInfo->lpReserved);
            CStrIn striDesktop(lpStartupInfo->lpDesktop);
            CStrIn striTitle(lpStartupInfo->lpTitle);

            si.lpReserved = striReserved;
            si.lpDesktop  = striDesktop;
            si.lpTitle   = striTitle;

            fRet = CreateProcessA(striApplicationName, striCommandLine,
                                  lpProcessAttributes, lpThreadAttributes,
                                  bInheritHandles, dwCreationFlags,
                                  lpEnvironment, striCurrentDirectory,
                                  &si, lpProcessInformation);
        }

    }

    return fRet;
}

#ifdef NEED_SHELL32_WRAPPER
HICON WINAPI ExtractIconWrapW(HINSTANCE hInst, LPCWSTR lpszExeFileName, UINT nIconIndex)
{
    HICON hicon;

    if (UseUnicodeShell32())
    {
        hicon = _ExtractIconW(hInst, lpszExeFileName, nIconIndex);
    }
    else
    {
        CStrIn striExeFileName(lpszExeFileName);

        hicon = _ExtractIconA(hInst, striExeFileName, nIconIndex);
    }

    return hicon;
}

#endif // NEED_SHELL32_WRAPPER

#ifdef NEED_USER32_WRAPPER

UINT WINAPI DdeInitializeWrapW(LPDWORD pidInst, PFNCALLBACK pfnCallback,
                               DWORD afCmd, DWORD ulRes)
{
    UINT uRet;

    if (UseUnicodeShell32())
    {
        uRet = DdeInitializeW(pidInst, pfnCallback, afCmd, ulRes);
    }
    else
    {
        //
        // This assumes the callback function will used the wrapped dde
        // string functions (DdeCreateStringHandle and DdeQueryString)
        // to access strings.
        //

        uRet = DdeInitializeA(pidInst, pfnCallback, afCmd, ulRes);
    }

    return uRet;
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

HSZ WINAPI DdeCreateStringHandleWrapW(DWORD idInst, LPCWSTR psz, int iCodePage)
{
    HSZ hszRet;

    if (UseUnicodeShell32())
    {
        hszRet = DdeCreateStringHandleW(idInst, psz, iCodePage);
    }
    else
    {
        CStrIn stripsz(psz);

        hszRet = DdeCreateStringHandleA(idInst, stripsz, CP_WINANSI);
    }

    return hszRet;
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_USER32_WRAPPER

DWORD WINAPI DdeQueryStringWrapW(DWORD idInst, HSZ hsz, LPWSTR psz,
                                 DWORD cchMax, int iCodePage)
{
    DWORD dwRet;

    if (UseUnicodeShell32())
    {
        dwRet = DdeQueryStringW(idInst, hsz, psz, cchMax, iCodePage);
    }
    else
    {
        CStrOut stropsz(psz, cchMax);

        dwRet = DdeQueryStringA(idInst, hsz, stropsz, stropsz.BufSize(),
                                CP_WINANSI);

        if (dwRet && psz)
            dwRet = stropsz.ConvertExcludingNul();
    }

    return dwRet;
}

#endif // NEED_USER32_WRAPPER

#ifdef NEED_COMDLG32_WRAPPER

LPWSTR xxxPathFindExtensionW(
    LPWSTR pszPath)
{
    LPWSTR pszDot;

    for (pszDot = NULL; *pszPath; pszPath = CharNextWrapW(pszPath)) {

        switch (*pszPath) {
        case L'.':
            pszDot = pszPath;    // remember the last dot
            break;

        case L'\\':
        case L' ':               // extensions can't have spaces
            pszDot = NULL;       // forget last dot, it was in a directory
            break;
        }
    }

    /*
     * if we found the extension, return ptr to the dot, else
     * ptr to end of the string (NULL extension) (cast->non const)
     */
    return pszDot ? (LPWSTR)pszDot : (LPWSTR)pszPath;
}

//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo


LPTSTR xxxPathFindFileNameW(LPWSTR pPath)
{
    LPWSTR pT;

    for (pT = pPath; *pPath; pPath = CharNextWrapW(pPath)) {
        if ((pPath[0] == TEXT('\\') || pPath[0] == TEXT(':') || pPath[0] == TEXT('/'))
            && pPath[1] &&  pPath[1] != TEXT('\\')  &&   pPath[1] != TEXT('/'))
            pT = pPath + 1;
    }

    return (LPTSTR)pT;   // const -> non const
}



BOOL WINAPI GetSaveFileNameWrapW(LPOPENFILENAMEW lpofn)
{
    BOOL fRet;

    if (UseUnicodeShell32())
    {
        fRet = GetSaveFileNameW(lpofn);
    }
    else
    {
        ASSERT(lpofn);
        ASSERT(sizeof(OPENFILENAMEA) == sizeof(OPENFILENAMEW));

        OPENFILENAMEA ofnA = *(LPOPENFILENAMEA)lpofn;

        // In parameters
        CStrInMulti strimFilter(lpofn->lpstrFilter);
        CStrIn      striInitialDir(lpofn->lpstrInitialDir);
        CStrIn      striTitle(lpofn->lpstrTitle);
        CStrIn      striDefExt(lpofn->lpstrDefExt);
        CStrIn      striTemplateName(lpofn->lpTemplateName);

        ASSERT(NULL == lpofn->lpstrCustomFilter); // add support if you need it.

        // Out parameters
        CStrOut     stroFile(lpofn->lpstrFile, lpofn->nMaxFile);
        CStrOut     stroFileTitle(lpofn->lpstrFileTitle, lpofn->nMaxFileTitle);

        //In Out parameters
        SHUnicodeToAnsi(lpofn->lpstrFile, stroFile, stroFile.BufSize());

        // Set up the parameters
        ofnA.lpstrFilter        = strimFilter;
        ofnA.lpstrInitialDir    = striInitialDir;
        ofnA.lpstrTitle         = striTitle;
        ofnA.lpstrDefExt        = striDefExt;
        ofnA.lpTemplateName     = striTemplateName;
        ofnA.lpstrFile          = stroFile;
        ofnA.lpstrFileTitle     = stroFileTitle;

        fRet = GetSaveFileNameA(&ofnA);

        if (fRet)
        {
            // Copy the out parameters
            lpofn->nFilterIndex = ofnA.nFilterIndex;
            lpofn->Flags        = ofnA.Flags;

            // Get the offset to the filename
            stroFile.ConvertIncludingNul();
            LPWSTR psz = xxxPathFindFileNameW(lpofn->lpstrFile);

            if (psz)
            {
                lpofn->nFileOffset = (int) (psz-lpofn->lpstrFile);

                // Get the offset of the extension
                psz = xxxPathFindExtensionW(psz);

                lpofn->nFileExtension = psz ? (int)(psz-lpofn->lpstrFile) : 0; 
            }
            else
            {
                lpofn->nFileOffset    = 0;
                lpofn->nFileExtension = 0;
            }

        }
    }

    return fRet;
}

#endif // NEED_COMDLG32_WRAPPER

#ifdef NEED_COMDLG32_WRAPPER

BOOL WINAPI GetOpenFileNameWrapW(LPOPENFILENAMEW lpofn)
{
    BOOL fRet;
    
    //VALIDATE_PROTOTYPE_DELAYLOAD(GetOpenFileName, _GetOpenFileName);

    if (UseUnicodeShell32())
    {
        fRet = GetOpenFileNameW(lpofn);
    }
    else
    {
        ASSERT(lpofn);
        ASSERT(sizeof(OPENFILENAMEA) == sizeof(OPENFILENAMEW));

        OPENFILENAMEA ofnA = *(LPOPENFILENAMEA)lpofn;

        // In parameters
        CStrInMulti strimFilter(lpofn->lpstrFilter);
        CStrIn      striInitialDir(lpofn->lpstrInitialDir);
        CStrIn      striTitle(lpofn->lpstrTitle);
        CStrIn      striDefExt(lpofn->lpstrDefExt);
        CStrIn      striTemplateName(lpofn->lpTemplateName);

        ASSERT(NULL == lpofn->lpstrCustomFilter); // add support if you need it.

        // Out parameters
        CStrOut     stroFile(lpofn->lpstrFile, lpofn->nMaxFile);
        CStrOut     stroFileTitle(lpofn->lpstrFileTitle, lpofn->nMaxFileTitle);

        //In Out parameters
        SHUnicodeToAnsi(lpofn->lpstrFile, stroFile, stroFile.BufSize());

        // Set up the parameters
        ofnA.lpstrFilter        = strimFilter;
        ofnA.lpstrInitialDir    = striInitialDir;
        ofnA.lpstrTitle         = striTitle;
        ofnA.lpstrDefExt        = striDefExt;
        ofnA.lpTemplateName     = striTemplateName;
        ofnA.lpstrFile          = stroFile;
        ofnA.lpstrFileTitle     = stroFileTitle;

        fRet = GetOpenFileNameA(&ofnA);

        if (fRet)
        {
            // Copy the out parameters
            lpofn->nFilterIndex = ofnA.nFilterIndex;
            lpofn->Flags        = ofnA.Flags;

            // Get the offset to the filename
            stroFile.ConvertIncludingNul();
            LPWSTR psz = xxxPathFindFileNameW(lpofn->lpstrFile);

            if (psz)
            {
                lpofn->nFileOffset = (int) (psz-lpofn->lpstrFile);

                // Get the offset of the extension
                psz = xxxPathFindExtensionW(psz);

                lpofn->nFileExtension = psz ? (int)(psz-lpofn->lpstrFile) : 0; 
            }
            else
            {
                lpofn->nFileOffset    = 0;
                lpofn->nFileExtension = 0;
            }

        }
    }

    return fRet;
}

#endif // NEED_COMDLG32_WRAPPER

#ifdef NEED_SHELL32_WRAPPER

#define SHCNF_HAS_WSTR_PARAMS(f)   ((f & SHCNF_TYPE) == SHCNF_PATHW     ||    \
                                    (f & SHCNF_TYPE) == SHCNF_PRINTERW  ||    \
                                    (f & SHCNF_TYPE) == SHCNF_PRINTJOBW    )

void SHChangeNotifyWrap(LONG wEventId, UINT uFlags, LPCVOID dwItem1,
                        LPCVOID dwItem2)
{
    // Can't do this because this is not a "W" function
    // VALIDATE_PROTOTYPE(SHChangeNotify);

    if (UseUnicodeShell32() || !SHCNF_HAS_WSTR_PARAMS(uFlags))
    {
        _SHChangeNotify(wEventId, uFlags, dwItem1, dwItem2);
    }
    else
    {
        CStrIn striItem1((LPWSTR)dwItem1);
        CStrIn striItem2((LPWSTR)dwItem2);

        if ((uFlags & SHCNF_TYPE) == SHCNF_PATHW)
        {
            uFlags = (uFlags & ~SHCNF_TYPE) | SHCNF_PATHA;
        }
        else if ((uFlags & SHCNF_TYPE) == SHCNF_PRINTERW)
        {
            uFlags = (uFlags & ~SHCNF_TYPE) | SHCNF_PRINTERA;
        }
        else
        {
            uFlags = (uFlags & ~SHCNF_TYPE) | SHCNF_PRINTJOBA;
        }

        _SHChangeNotify(wEventId, uFlags, (void*)(LPSTR)striItem1,
                        (void*)(LPSTR)striItem2);
    }

    return;
}

#endif // NEED_SHELL32_WRAPPER

#ifdef NEED_COMDLG32_WRAPPER

//+---------------------------------------------------------------------------
// PrintDlgWrap, PageSetupDlgWrap - wrappers
// DevNamesAFromDevNamesW, DevNamesWFromDevNamesA - helper functions
//
//        Copied from mshtml\src\core\wrappers\unicwrap.cpp with some
//        cosmetic changes (peterlee)
//        
//+---------------------------------------------------------------------------

HGLOBAL
DevNamesAFromDevNamesW( HGLOBAL hdnw )
{
    HGLOBAL         hdna = NULL;

    if (hdnw)
    {
        LPDEVNAMES lpdnw = (LPDEVNAMES) GlobalLock( hdnw );
        if (lpdnw)
        {
            CStrIn      strDriver( (LPCWSTR) lpdnw + lpdnw->wDriverOffset );
            CStrIn      strDevice( (LPCWSTR) lpdnw + lpdnw->wDeviceOffset );
            CStrIn      strOutput( (LPCWSTR) lpdnw + lpdnw->wOutputOffset );
            int         cchDriver = strDriver.strlen() + 1;
            int         cchDevice = strDevice.strlen() + 1;
            int         cchOutput = strOutput.strlen() + 1;

            hdna = GlobalAlloc( GHND, sizeof(DEVNAMES) +
                                cchDriver + cchDevice + cchOutput );
            if (hdna)
            {
                LPDEVNAMES lpdna = (LPDEVNAMES) GlobalLock( hdna );
                if (!lpdna)
                {
                    GlobalFree( hdna );
                    hdna = NULL;
                }
                else
                {
                    lpdna->wDriverOffset = sizeof(DEVNAMES);
                    lpdna->wDeviceOffset = lpdna->wDriverOffset + cchDriver;
                    lpdna->wOutputOffset = lpdna->wDeviceOffset + cchDevice;
                    lpdna->wDefault = lpdnw->wDefault;

                    lstrcpyA( (LPSTR) lpdna + lpdna->wDriverOffset, strDriver );
                    lstrcpyA( (LPSTR) lpdna + lpdna->wDeviceOffset, strDevice );
                    lstrcpyA( (LPSTR) lpdna + lpdna->wOutputOffset, strOutput );

                    GlobalUnlock( hdna );
                }
            }

            GlobalUnlock( hdnw );
            GlobalFree( hdnw );
        }
    }

    return hdna;
}

HGLOBAL
DevNamesWFromDevNamesA( HGLOBAL hdna )
{
    HGLOBAL         hdnw = NULL;

    if (hdna)
    {
        LPDEVNAMES lpdna = (LPDEVNAMES) GlobalLock( hdna );
        if (lpdna)
        {
            LPCSTR      lpszDriver = (LPCSTR) lpdna + lpdna->wDriverOffset;
            LPCSTR      lpszDevice = (LPCSTR) lpdna + lpdna->wDeviceOffset;
            LPCSTR      lpszOutput = (LPCSTR) lpdna + lpdna->wOutputOffset;
            int         cchDriver = lstrlenA( lpszDriver ) + 1;
            int         cchDevice = lstrlenA( lpszDevice ) + 1;
            int         cchOutput = lstrlenA( lpszOutput ) + 1;

            // assume the wide charcount won't exceed the multibyte charcount

            hdnw = GlobalAlloc( GHND, sizeof(DEVNAMES) +
                                sizeof(WCHAR) * (cchDriver + cchDevice + cchOutput)  );
            if (hdnw)
            {
                LPDEVNAMES lpdnw = (LPDEVNAMES) GlobalLock( hdnw );
                if (!lpdnw)
                {
                    GlobalFree( hdnw );
                    hdnw = NULL;
                }
                else
                {
                    lpdnw->wDriverOffset = sizeof(DEVNAMES) / sizeof(WCHAR);
                    lpdnw->wDeviceOffset = lpdnw->wDriverOffset + cchDriver;
                    lpdnw->wOutputOffset = lpdnw->wDeviceOffset + cchDevice;
                    lpdnw->wDefault = lpdna->wDefault;

                    SHAnsiToUnicode( (LPSTR) lpszDriver, (LPWSTR) lpdnw + lpdnw->wDriverOffset,
                                     cchDriver );
                    SHAnsiToUnicode( lpszDevice, (LPWSTR) lpdnw + lpdnw->wDeviceOffset,
                                     cchDevice);
                    SHAnsiToUnicode( lpszOutput, (LPWSTR) lpdnw + lpdnw->wOutputOffset,
                                     cchOutput);

                    GlobalUnlock( hdnw );
                }
            }

            GlobalUnlock( hdna );
            GlobalFree( hdna );
        }
    }

    return hdnw;
}

#endif // NEED_COMDLG32_WRAPPER

#ifdef NEED_COMDLG32_WRAPPER

//--------------------------------------------------------------
//      PrintDlgW wrapper
//--------------------------------------------------------------
#if UNUSED_DONOTBUILD
BOOL WINAPI
PrintDlgWrapW(LPPRINTDLGW lppd)
{
    BOOL        fRet;

    VALIDATE_PROTOTYPE_DELAYLOAD(PrintDlg, _PrintDlg);   

    if (UseUnicodeShell32())
    {
        fRet = _PrintDlgW(lppd);
    }
    else
    {
        PRINTDLGA   pda;
        LPCWSTR     lpPrintTemplateName = lppd->lpPrintTemplateName;
        LPCWSTR     lpSetupTemplateName = lppd->lpSetupTemplateName;
        CStrIn      strPrintTemplateName( lpPrintTemplateName );
        CStrIn      strSetupTemplateName( lpSetupTemplateName );

        ASSERT( sizeof(pda) == sizeof( *lppd ));

        memcpy( &pda, lppd, sizeof(pda) );

        // IMPORTANT: We are not converting the DEVMODE structure back and forth
        // from ASCII to Unicode on Win95 anymore because we are not touching the
        // two strings or any other member.  Converting the DEVMODE structure can
        // be tricky because of potential and common discrepancies between the
        // value of the dmSize member and sizeof(DEVMODE).  (25155)

        // So instead of: pda.hDevMode = DevModeAFromDevModeW( lppd->hDevMode );
        // we just forward the DEVMODE handle:
        pda.hDevMode = lppd->hDevMode;
        pda.hDevNames = DevNamesAFromDevNamesW( lppd->hDevNames );
        pda.lpPrintTemplateName = strPrintTemplateName;
        pda.lpSetupTemplateName = strSetupTemplateName;

        fRet = _PrintDlgA( &pda );

        // copy back wholesale, then restore strings.

        memcpy( lppd, &pda, sizeof(pda) );

        lppd->lpSetupTemplateName = lpSetupTemplateName;
        lppd->lpPrintTemplateName = lpPrintTemplateName;
        lppd->hDevNames = DevNamesWFromDevNamesA( pda.hDevNames );

        // And instead of: lppd->hDevMode = DevModeWFromDevModeA( pda.hDevMode );
        // we just forward the DEVMODE handle:
        lppd->hDevMode = pda.hDevMode;
    }

    return fRet;
}
#endif // UNUSED_DONOTBUILD
#endif // NEED_COMDLG32_WRAPPER

#ifdef NEED_COMDLG32_WRAPPER

//--------------------------------------------------------------
//      PageSetupDlgW wrapper
//--------------------------------------------------------------
#if UNUSED_DONOTBUILD
BOOL WINAPI
PageSetupDlgWrapW(LPPAGESETUPDLGW lppsd)
{
    BOOL fRet;

    VALIDATE_PROTOTYPE_DELAYLOAD(PageSetupDlg, _PageSetupDlg);     

    if (UseUnicodeShell32())
    {
        fRet = _PageSetupDlgW(lppsd);
    }
    else
    {
        PAGESETUPDLGA   psda;
        LPCWSTR         lpPageSetupTemplateName = lppsd->lpPageSetupTemplateName;
        CStrIn          strPageSetupTemplateName( lpPageSetupTemplateName );

        ASSERT( sizeof(psda) == sizeof( *lppsd ) );

        memcpy( &psda, lppsd, sizeof(psda));

        // IMPORTANT: We are not converting the DEVMODE structure back and forth
        // from ASCII to Unicode on Win95 anymore because we are not touching the
        // two strings or any other member.  Converting the DEVMODE structure can
        // be tricky because of potential and common discrepancies between the
        // value of the dmSize member and sizeof(DEVMODE).  (25155)

        // So instead of: psda.hDevMode = DevModeAFromDevModeW( lppsd->hDevMode );
        // we just forward the DEVMODE handle:
        psda.hDevMode = lppsd->hDevMode;
        psda.hDevNames = DevNamesAFromDevNamesW( lppsd->hDevNames );
        psda.lpPageSetupTemplateName = strPageSetupTemplateName;

        fRet = _PageSetupDlgA( (LPPAGESETUPDLGA) &psda );

        // copy back wholesale, then restore string.

        memcpy( lppsd, &psda, sizeof(psda) );

        lppsd->lpPageSetupTemplateName = lpPageSetupTemplateName;
        lppsd->hDevNames = DevNamesWFromDevNamesA( psda.hDevNames );

        // And instead of: lppsd->hDevMode = DevModeWFromDevModeA( psda.hDevMode );
        // we just forward the DEVMODE handle:
        lppsd->hDevMode = psda.hDevMode;            
    }

    return fRet;
}
#endif // UNUSED_DONOTBUILD
#endif // NEED_COMDLG32_WRAPPER



// Newly added wrappers specifically for ts client (nadima)

HANDLE
WINAPI
CreateFileMappingWrapW(
    IN HANDLE hFile,
    IN LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    IN DWORD flProtect,
    IN DWORD dwMaximumSizeHigh,
    IN DWORD dwMaximumSizeLow,
    IN LPCWSTR lpName
    )
{
    VALIDATE_PROTOTYPE(CreateMutex);

    if (g_bRunningOnNT)
    {
        return CreateFileMappingW(hFile, lpFileMappingAttributes,
                                  flProtect, dwMaximumSizeHigh,
                                  dwMaximumSizeLow, lpName);
    }
    else
    {
        CStrIn strText(lpName);
        return CreateFileMappingA(hFile, lpFileMappingAttributes,
                                  flProtect, dwMaximumSizeHigh,
                                  dwMaximumSizeLow, strText);
    }

}


HICON
ExtractIconWrapW(
    HINSTANCE hInst,
    LPCWSTR lpszExeFileName,
    UINT nIconIndex)
{
    VALIDATE_PROTOTYPE(ExtractIcon);

    if(g_bRunningOnNT)
    {
        return ExtractIconW( hInst,
                             lpszExeFileName,
                             nIconIndex);
    }
    else
    {
        CStrIn strText(lpszExeFileName);
        return ExtractIconA( hInst,
                             strText,
                             nIconIndex);
    }

}


BOOL WINAPI SHGetPathFromIDListWrapW(LPCITEMIDLIST pidl, LPWSTR pwzPath)
{
    //VALIDATE_PROTOTYPE_DELAYLOAD(SHGetPathFromIDList, _SHGetPathFromIDList);

    if (g_bRunningOnNT)
    {
        //
        // SHGetPathFromIDListW is not necessarily available
        // as a stub on 9x, so dynamically bind to it for NT
        //
        HRESULT hr = E_NOTIMPL;

        typedef HRESULT (STDAPICALLTYPE FNSHGetPathFromIDListW)
                                        (LPCITEMIDLIST pidl, LPWSTR pwzPath);
        FNSHGetPathFromIDListW *pfnSHGetPathFromIDListW = NULL;

        // get the handle to shell32.dll library
        HMODULE hmodSH32DLL = LoadLibraryWrapW(TEXT("SHELL32.DLL"));

        if (hmodSH32DLL != NULL)
        {
            // get the proc address for SHGetFolderPath
            pfnSHGetPathFromIDListW = (FNSHGetPathFromIDListW*)
                                GetProcAddress(hmodSH32DLL, "SHGetPathFromIDListW");
            if (pfnSHGetPathFromIDListW)
            {
                hr = (*pfnSHGetPathFromIDListW)( pidl, pwzPath );
            }
            FreeLibrary(hmodSH32DLL);
        }
        return hr;
    }
    else
    {
        CStrOut strPathOut(pwzPath, MAX_PATH);
        BOOL fResult = SHGetPathFromIDListA(pidl, strPathOut);
        if (fResult)
            strPathOut.ConvertIncludingNul();

        return fResult;
    }
}

SHORT
WINAPI
GetFileTitleWrapW(
    LPCWSTR lpszFileW,
    LPWSTR lpszTitleW,
    WORD cbBuf)
{
    VALIDATE_PROTOTYPE(GetFileTitle);

    if(g_bRunningOnNT)
    {
        return GetFileTitleW( lpszFileW, lpszTitleW, cbBuf);
    }
    else
    {
        CStrIn  strFileName( lpszFileW);
        CStrOut strOutTitle(lpszTitleW, cbBuf);
        return GetFileTitleA( strFileName, strOutTitle, cbBuf);
    }

}

BOOL
WINAPI
GetKeyboardLayoutNameWrapW(
    OUT LPWSTR pwszKLID)
{
    if(g_bRunningOnNT)
    {
        return GetKeyboardLayoutNameW( pwszKLID);
    }
    else
    {
        CStrOut strOutKeybId( pwszKLID, KL_NAMELENGTH);
        return GetKeyboardLayoutNameA( strOutKeybId);
    }
}


BOOL
APIENTRY
GetTextExtentPointWrapW(HDC hdc,LPCWSTR pwsz,DWORD cwc,LPSIZE psizl)
{
    if(g_bRunningOnNT)
    {
        return GetTextExtentPointW( hdc, pwsz, cwc, psizl);
    }
    else
    {
        CStrIn strIn(pwsz);
        return GetTextExtentPointA( hdc, strIn, cwc, psizl);
    }
}

BOOL
WINAPI
GetDiskFreeSpaceWrapW(
    IN LPCWSTR lpRootPathName,
    OUT LPDWORD lpSectorsPerCluster,
    OUT LPDWORD lpBytesPerSector,
    OUT LPDWORD lpNumberOfFreeClusters,
    OUT LPDWORD lpTotalNumberOfClusters
    )
{
    if(g_bRunningOnNT)
    {
        return GetDiskFreeSpaceW( lpRootPathName, lpSectorsPerCluster,
                                  lpBytesPerSector, lpNumberOfFreeClusters,
                                  lpTotalNumberOfClusters);
    }
    else
    {
        CStrIn strIn(lpRootPathName);
        return GetDiskFreeSpaceA( strIn, lpSectorsPerCluster,
                                  lpBytesPerSector, lpNumberOfFreeClusters,
                                  lpTotalNumberOfClusters);
    }
}

UINT
WINAPI
GetDriveTypeWrapW(
    IN LPCWSTR lpRootPathName
    )
{
    if(g_bRunningOnNT)
    {
        return GetDriveTypeW( lpRootPathName);
    }
    else
    {
        CStrIn strIn(lpRootPathName);
        return GetDriveTypeA(strIn);
    }
}

HANDLE
WINAPI
FindFirstChangeNotificationWrapW(
    IN LPCWSTR lpPathName,
    IN BOOL bWatchSubtree,
    IN DWORD dwNotifyFilter
    )
{
    if(g_bRunningOnNT)
    {
        return FindFirstChangeNotificationW( lpPathName,
                                             bWatchSubtree,
                                             dwNotifyFilter);
    }
    else
    {
        CStrIn strIn(lpPathName);
        return FindFirstChangeNotificationA( strIn,
                                             bWatchSubtree,
                                             dwNotifyFilter);
    }
}

BOOL
WINAPI
GetVolumeInformationWrapW(
    IN LPCWSTR lpRootPathName,
    OUT LPWSTR lpVolumeNameBuffer,
    IN DWORD nVolumeNameSize,
    OUT LPDWORD lpVolumeSerialNumber,
    OUT LPDWORD lpMaximumComponentLength,
    OUT LPDWORD lpFileSystemFlags,
    OUT LPWSTR lpFileSystemNameBuffer,
    IN DWORD nFileSystemNameSize
    )
{
    if(g_bRunningOnNT)
    {
        return GetVolumeInformationW( lpRootPathName,
                                      lpVolumeNameBuffer,
                                      nVolumeNameSize,
                                      lpVolumeSerialNumber,
                                      lpMaximumComponentLength,
                                      lpFileSystemFlags,
                                      lpFileSystemNameBuffer,
                                      nFileSystemNameSize);
    }
    else
    {
        CStrIn  strRootPathName(lpRootPathName);
        CStrOut strOutVolumeNameBuffer(lpVolumeNameBuffer, nVolumeNameSize);
        CStrOut strOutFileSystemName(lpFileSystemNameBuffer, nFileSystemNameSize);
        return GetVolumeInformationA( strRootPathName,
                                      strOutVolumeNameBuffer,
                                      nVolumeNameSize,
                                      lpVolumeSerialNumber,
                                      lpMaximumComponentLength,
                                      lpFileSystemFlags,
                                      strOutFileSystemName,
                                      nFileSystemNameSize);
    }
}

UINT FORWARD_API WINAPI
MapVirtualKeyWrapW(
    IN UINT uCode,
    IN UINT uMapType)
{
    VALIDATE_PROTOTYPE(MapVirtualKey);

    FORWARD_AW(MapVirtualKey, (uCode, uMapType));
}


ULONG_PTR FORWARD_API WINAPI
SetClassLongPtrWrapW(
    IN HWND hWnd,
    IN int nIndex,
    IN LONG_PTR dwNewLong)
{
    VALIDATE_PROTOTYPE(SetClassLongPtr);

    FORWARD_AW(SetClassLongPtr, (hWnd, nIndex, dwNewLong));
}

BOOL
WINAPI
GetComputerNameWrapW (
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    )
{
    VALIDATE_PROTOTYPE(GetComputerName);
    if(g_bRunningOnNT)
    {
        return GetComputerNameW( lpBuffer, nSize);
    }
    else
    {
        CStrOut strOutCompName(lpBuffer, *nSize);
        return GetComputerNameA(strOutCompName, nSize);
    }
}

BOOL
WINAPI
GetFileSecurityWrapW (
    IN LPCWSTR lpFileName,
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN DWORD nLength,
    OUT LPDWORD lpnLengthNeeded
    )
{
    VALIDATE_PROTOTYPE(GetFileSecurity);
    if(g_bRunningOnNT)
    {
        return GetFileSecurityW( lpFileName, RequestedInformation,
                                 pSecurityDescriptor, nLength, lpnLengthNeeded);
    }
    else
    {
        CStrIn strInFileName( lpFileName);
        return GetFileSecurityA( strInFileName,  RequestedInformation,
                                 pSecurityDescriptor, nLength, lpnLengthNeeded);
    }
}

BOOL
WINAPI
SetFileSecurityWrapW (
    IN LPCWSTR lpFileName,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    VALIDATE_PROTOTYPE(SetFileSecurity);

    if(g_bRunningOnNT)
    {
        return SetFileSecurityW( lpFileName, SecurityInformation,
                                 pSecurityDescriptor);
    }
    else
    {
        CStrIn strInFileName( lpFileName);
        return SetFileSecurityA( strInFileName,  SecurityInformation,
                                 pSecurityDescriptor);
    }
}

int WINAPIV wsprintfWrapW(
    LPWSTR lpOut,
    LPCWSTR lpFmt,
    ...)
{
    va_list arglist;
    int ret;

    va_start(arglist, lpFmt);
    ret = wvsprintfWrapW(lpOut, lpFmt, arglist);
    va_end(arglist);
    return ret;
}

//This wrapper dynamically binds to shell32
//because the W or A functions are not necessarily available on 9x
STDAPI SHGetFolderPathWrapW(HWND hwnd, int csidl, HANDLE hToken,
                            DWORD dwFlags, LPWSTR pszPath)
{
    HRESULT hr = E_NOTIMPL;
    
    typedef HRESULT (STDAPICALLTYPE FNSHGetFolderPathW)(HWND, int, HANDLE, DWORD, LPWSTR);
    typedef HRESULT (STDAPICALLTYPE FNSHGetFolderPathA)(HWND, int, HANDLE, DWORD, LPSTR);
    FNSHGetFolderPathW *pfnSHGetFolderPathW = NULL;
    FNSHGetFolderPathA *pfnSHGetFolderPathA = NULL;

    // get the handle to shell32.dll library
    HMODULE hmodSH32DLL = LoadLibraryWrapW(TEXT("SHELL32.DLL"));

    if (hmodSH32DLL != NULL)
    {
        // get the proc address for SHGetFolderPath
        if(g_bRunningOnNT)
        {
            pfnSHGetFolderPathW = (FNSHGetFolderPathW*)GetProcAddress(hmodSH32DLL, "SHGetFolderPathW");
        }
        else
        {
            pfnSHGetFolderPathA = (FNSHGetFolderPathA*)GetProcAddress(hmodSH32DLL, "SHGetFolderPathA");
        }
        if (g_bRunningOnNT && pfnSHGetFolderPathW)
        {
            hr = (*pfnSHGetFolderPathW)( hwnd, csidl, hToken, dwFlags, pszPath);
        }
        else if(pfnSHGetFolderPathA)
        {
            CStrOut strPathOut(pszPath, MAX_PATH);
            hr = (*pfnSHGetFolderPathA)( hwnd, csidl, hToken, dwFlags, strPathOut);
        }
        FreeLibrary(hmodSH32DLL);
    }
    return hr;
}

STDAPI StrRetToStrWrapW(STRRET *pstr,
                        LPCITEMIDLIST pidl,
                        LPWSTR* ppsz)
{
    if(g_bRunningOnNT)
    {
        return StrRetToStrW( pstr, pidl, ppsz);
    }
    else
    {
        LPSTR szAnsiOut = NULL;
        HRESULT hr = StrRetToStrA( pstr, pidl, &szAnsiOut);
        if(SUCCEEDED(hr))
        {
            int numChars = strlen(szAnsiOut);
            *ppsz = (LPWSTR) CoTaskMemAlloc( (numChars + 2) * sizeof(TCHAR) );
            if(*ppsz)
            {
                SHAnsiToUnicode( szAnsiOut, *ppsz, numChars + 1);
                //free temp
                CoTaskMemFree( szAnsiOut );
                return hr;
                
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            return hr;
        }
    }
}


BOOL
WINAPI
GetVersionExWrapW(
    IN OUT LPOSVERSIONINFOW lpVersionInformation
    )
{
    if(g_bRunningOnNT)
    {
        return GetVersionExW( lpVersionInformation );
    }
    else
    {
        //NOTE this API will behave exactly like win9x's
        //i.e it doesn't process the OSVERSIONINFOEX fields
        BOOL ret = FALSE;
        OSVERSIONINFOA osvera;
        osvera.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
        ret = GetVersionExA( &osvera );
        if(ret)
        {
            lpVersionInformation->dwBuildNumber  = osvera.dwBuildNumber;
            lpVersionInformation->dwMajorVersion = osvera.dwMajorVersion;
            lpVersionInformation->dwMinorVersion = osvera.dwMinorVersion;
            lpVersionInformation->dwPlatformId = osvera.dwPlatformId;
            SHAnsiToUnicode( osvera.szCSDVersion, 
                  lpVersionInformation->szCSDVersion,
                  sizeof(lpVersionInformation->szCSDVersion)/sizeof(TCHAR));
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
}

BOOL
WINAPI
GetDefaultCommConfigWrapW(
    IN LPCWSTR lpszName,
    OUT LPCOMMCONFIG lpCC,
    IN OUT LPDWORD lpdwSize
    )
{
    if(g_bRunningOnNT)
    {
        return GetDefaultCommConfigW( lpszName, lpCC, lpdwSize);
    }
    else
    {
        CStrIn strName( lpszName );
        return GetDefaultCommConfigA( strName, lpCC, lpdwSize);
    }
}

//
// IME thunks dyamically bind to IME dlls outside the unicode wrapper
// layer so we get passed in function pointers
//
UINT ImmGetIMEFileName_DynWrapW(
    IN HKL hkl,
    OUT LPWSTR szName,
    IN UINT uBufLen,
    IN PFN_ImmGetIMEFileNameW pfnImmGetIMEFileNameW,
    IN PFN_ImmGetIMEFileNameA pfnImmGetIMEFileNameA)
{
    UINT result = 0; //assume fail
    if (g_bRunningOnNT)
    {
        if (pfnImmGetIMEFileNameW)
        {
            result = pfnImmGetIMEFileNameW(hkl, szName, uBufLen);
        }
    }
    else
    {
        if (pfnImmGetIMEFileNameA)
        {
            CStrOut strOutName(szName, uBufLen/sizeof(WCHAR));
            result =  pfnImmGetIMEFileNameA(hkl, strOutName, uBufLen/2);
        }
    }

    return result;
}

//
// IME thunks dyamically bind to IME dlls outside the unicode wrapper
// layer so we get passed in function pointers
//
BOOL ImpGetIME_DynWrapW(
    IN HWND hWnd,
    OUT LPIMEPROW lpImeProW,
    IN PFN_IMPGetIMEW pfnIMPGetIMEW,
    IN PFN_IMPGetIMEA pfnIMPGetIMEA)
{
    BOOL fRes = FALSE;
    if (g_bRunningOnNT)
    {
        if (pfnIMPGetIMEW)
        {
            fRes = pfnIMPGetIMEW(hWnd, lpImeProW);
        }
    }
    else
    {
        if (pfnIMPGetIMEA)
        {
            IMEPROA imeProA;
            fRes = pfnIMPGetIMEA(hWnd, &imeProA);
            if (fRes)
            {
                lpImeProW->hWnd = imeProA.hWnd;
                lpImeProW->InstDate = imeProA.InstDate;
                lpImeProW->wVersion = imeProA.wVersion;

                SHAnsiToUnicode( (LPCSTR)&imeProA.szDescription, 
                      lpImeProW->szDescription,
                      sizeof(lpImeProW->szDescription)/sizeof(TCHAR));

                SHAnsiToUnicode( (LPCSTR)&imeProA.szName, 
                      lpImeProW->szName,
                      sizeof(lpImeProW->szName)/sizeof(TCHAR));

                SHAnsiToUnicode( (LPCSTR)&imeProA.szOptions, 
                      lpImeProW->szOptions,
                      sizeof(lpImeProW->szOptions)/sizeof(TCHAR));
            }
        }
    }
    return fRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\dload\termsrvpch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\dload\regapi.c ===
#include "termsrvpch.h"
#pragma hdrstop

#include <winsta.h>

static
LONG WINAPI
RegConsoleShadowQueryW( 
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    PWDPREFIXW pWdPrefixName,
    PWINSTATIONCONFIG2W pWinStationConfig,
    ULONG WinStationConfigLength,
    PULONG pReturnLength
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG WINAPI
RegDefaultUserConfigQueryW(
    WCHAR * pServerName,
    PUSERCONFIGW pUserConfig,
    ULONG UserConfigLength,
    PULONG pReturnLength
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOLEAN     
RegDenyTSConnectionsPolicy(
    void
    )
{
    return FALSE; 
}

static
BOOLEAN
RegIsMachineInHelpMode(
    void
    )
{
    return FALSE; 
}

static
BOOLEAN
RegGetMachinePolicyEx( 
    BOOLEAN forcePolicyRead,
    FILETIME *pTime ,    
    PPOLICY_TS_MACHINE pPolicy
    )
{
    return FALSE;
}

static
BOOLEAN    
RegGetUserPolicy( 
    LPWSTR userSID,
    PPOLICY_TS_USER pPolicy,
    PUSERCONFIGW pUser
    )
{
    return FALSE;
}

static
BOOLEAN
RegIsMachinePolicyAllowHelp(
    void
    )
{
    return FALSE;
}

static
BOOLEAN     
RegIsTimeZoneRedirectionEnabled(
    void
    )
{
    return FALSE;
}

static
LONG WINAPI
RegPdEnumerateW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    BOOLEAN bTd,
    PULONG pIndex,
    PULONG pEntries,
    PPDNAMEW pPdName,
    PULONG pByteCount
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG WINAPI
RegUserConfigQuery(
    WCHAR * pServerName,
    WCHAR * pUserName,
    PUSERCONFIGW pUserConfig,
    ULONG UserConfigLength,
    PULONG pReturnLength
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG WINAPI
RegUserConfigSet(
    WCHAR * pServerName,
    WCHAR * pUserName,
    PUSERCONFIGW pUserConfig,
    ULONG UserConfigLength
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
WINAPI
RegWinStationQueryEx(
    HANDLE hServer,
    PPOLICY_TS_MACHINE pMachinePolicy,
    PWINSTATIONNAMEW pWinStationName,
    PWINSTATIONCONFIG2W pWinStationConfig,
    ULONG WinStationConfigLength,
    PULONG pReturnLength,
    BOOLEAN bPerformMerger
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG WINAPI
RegWinStationQueryNumValueW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    LPWSTR pValueName,
    PULONG pValueData
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG WINAPI
RegWinStationQueryValueW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    LPWSTR pValueName,
    PVOID  pValueData,
    ULONG  ValueSize,
    PULONG pValueSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WaitForTSConnectionsPolicyChanges( BOOLEAN bWaitForAccept, HANDLE hEvent )
{
    return ERROR_PROC_NOT_FOUND; 
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(regapi)
{
    DLPENTRY(RegConsoleShadowQueryW)
    DLPENTRY(RegDefaultUserConfigQueryW)
    DLPENTRY(RegDenyTSConnectionsPolicy)
    DLPENTRY(RegGetMachinePolicyEx)
    DLPENTRY(RegGetUserPolicy)
    DLPENTRY(RegIsMachineInHelpMode)
    DLPENTRY(RegIsMachinePolicyAllowHelp)
    DLPENTRY(RegIsTimeZoneRedirectionEnabled)   
    DLPENTRY(RegPdEnumerateW)
    DLPENTRY(RegUserConfigQuery)
    DLPENTRY(RegUserConfigSet)
    DLPENTRY(RegWinStationQueryEx)
    DLPENTRY(RegWinStationQueryNumValueW)
    DLPENTRY(RegWinStationQueryValueW)
    DLPENTRY(WaitForTSConnectionsPolicyChanges)
};

DEFINE_PROCNAME_MAP(regapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\dload\utildll.c ===
#include "termsrvpch.h"
#pragma hdrstop

static
void
WINAPI
CachedGetUserFromSid(
    PSID pSid, PWCHAR pUserName, PULONG cbUserName
    )
{
    // We should properly return the string "(unknown)" but that's
    // kept in utildll.dll, and we're here because utildll failed to load...
    //
    // Original function assumes that *cbUserName > 0 too
    pUserName[*cbUserName-1] = L'\0';
}

static
void
WINAPI
CurrentDateTimeString(
    LPWSTR pString
    )
{
    // original function doesn't check for NULL pointer either
    pString[0] = L'\0';
}

static
LPWSTR
WINAPI
EnumerateMultiUserServers(
    LPWSTR pDomain
    )
{
    return NULL;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(utildll)
{
    DLPENTRY(CachedGetUserFromSid)
    DLPENTRY(CurrentDateTimeString)
    DLPENTRY(EnumerateMultiUserServers)
};

DEFINE_PROCNAME_MAP(utildll)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\dload\winsta.c ===
#include "termsrvpch.h"
#pragma hdrstop

#include <winsta.h>

static
BOOLEAN
WINAPI
_WinStationNotifyLogoff(
    VOID
    )
{
    return FALSE;
}

static
HANDLE
WINAPI
WinStationOpenServerW(
    LPWSTR  pServerName
    )
{
    return INVALID_HANDLE_VALUE;
}

static
BOOLEAN
WINAPI
WinStationCloseServer(
    HANDLE  hServer
    )
{
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationConnectW(
    HANDLE hServer,
    ULONG LogonId,
    ULONG TargetLogonId,
    PWCHAR pPassword,
    BOOLEAN bWait
)
{
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationGetProcessSid(
        HANDLE   hServer,
        DWORD    ProcessId,
        FILETIME ProcessStartTime,
        PBYTE    pProcessUserSid,
        DWORD    *pdwSidSize
)
{
   *pdwSidSize = 0; // an OUT parameter even on failure
   SetLastError(ERROR_PROC_NOT_FOUND); // callers expect LastError to be set
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationQueryInformationA(
    HANDLE hServer,
    ULONG LogonId,
    WINSTATIONINFOCLASS WinStationInformationClass,
    PVOID  pWinStationInformation,
    ULONG WinStationInformationLength,
    PULONG  pReturnLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationQueryInformationW(
    HANDLE hServer,
    ULONG LogonId,
    WINSTATIONINFOCLASS WinStationInformationClass,
    PVOID  pWinStationInformation,
    ULONG WinStationInformationLength,
    PULONG  pReturnLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
BOOL
WINAPI
WinStationRegisterConsoleNotification(
    HANDLE  hServer,
    HWND    hWnd,
    DWORD   dwFlags
    )
{
    return FALSE;
}

BOOLEAN WINAPI
WinStationSendMessageW(
    HANDLE hServer,
    ULONG LogonId,
    LPWSTR  pTitle,
    ULONG TitleLength,
    LPWSTR  pMessage,
    ULONG MessageLength,
    ULONG Style,
    ULONG Timeout,
    PULONG pResponse,
    BOOLEAN DoNotWait
    )
{
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationSetInformationW(
    HANDLE hServer,
    ULONG LogonId,
    WINSTATIONINFOCLASS WinStationInformationClass,
    PVOID  pWinStationInformation,
    ULONG WinStationInformationLength
    )
{
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationShadow(
    HANDLE hServer,
    PWSTR pTargetServerName,
    ULONG TargetLogonId,
    BYTE HotkeyVk,
    USHORT HotkeyModifiers
    )
{
    return FALSE;
}



static
BOOL
WINAPI
WinStationUnRegisterConsoleNotification(
    HANDLE  hServer,
    HWND    hWnd
    )
{
    return FALSE;
}


static
NTSTATUS
WINAPI
_WinStationShadowTarget(
    HANDLE hServer,
    ULONG LogonId,
    PWINSTATIONCONFIG2 pConfig,
    PICA_STACK_ADDRESS pAddress,
    PVOID pModuleData,
    ULONG ModuleDataLength,
    PVOID pThinwireData,
    ULONG ThinwireDataLength,
    PVOID pClientName,
    ULONG ClientNameLength
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}


static
BOOLEAN
WINAPI
_WinStationShadowTargetSetup(
    HANDLE hServer,
    ULONG LogonId
    )
{
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationFreeMemory(
    PVOID  pBuffer
    )
{
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationEnumerateW(
    HANDLE  hServer,
    PLOGONIDW *ppLogonId,
    PULONG  pEntries
    )
{
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationEnumerate_IndexedW(
    HANDLE  hServer,
    PULONG  pEntries,
    PLOGONIDW pLogonId,
    PULONG  pByteCount,
    PULONG  pIndex
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationGetTermSrvCountersValue(
    HANDLE hServer,
    ULONG  dwEntries,
    PVOID  pCounter
    )
{
    return FALSE;
}

static
BOOLEAN 
WinStationIsHelpAssistantSession(
    HANDLE   hServer,
    ULONG    LogonId
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(winsta)
{
    DLPENTRY(WinStationCloseServer)
    DLPENTRY(WinStationConnectW)
    DLPENTRY(WinStationEnumerateW)
    DLPENTRY(WinStationEnumerate_IndexedW)
    DLPENTRY(WinStationFreeMemory)
    DLPENTRY(WinStationGetProcessSid)
    DLPENTRY(WinStationGetTermSrvCountersValue)
    DLPENTRY(WinStationIsHelpAssistantSession)
    DLPENTRY(WinStationOpenServerW)
    DLPENTRY(WinStationQueryInformationA)
    DLPENTRY(WinStationQueryInformationW)
    DLPENTRY(WinStationRegisterConsoleNotification)
    DLPENTRY(WinStationSendMessageW)
    DLPENTRY(WinStationSetInformationW)
    DLPENTRY(WinStationShadow)
    DLPENTRY(WinStationUnRegisterConsoleNotification)
    DLPENTRY(_WinStationNotifyLogoff)
    DLPENTRY(_WinStationShadowTarget)
    DLPENTRY(_WinStationShadowTargetSetup)
};

DEFINE_PROCNAME_MAP(winsta)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\dload\wtsapi32.c ===
#include "termsrvpch.h"
#pragma hdrstop

#include <wtsapi32.h>

//
//  Caution!  Many of these functions must perform a SetLastError() because
//  the callers will call GetLastError() and try to recover based on the
//  error code.  Even more interesting, Taskmgr will sometimes pass the
//  error code to FormatMessage and display it to the end user.  So
//  we can't use ERROR_PROC_NOT_FOUND = "The specified procedure could not be
//  found", because it is meaningless to the end user.
//
//  I have chosen to use ERROR_FUNCTION_NOT_CALLED = "Function could not be
//  executed".
//

static
VOID
WINAPI
WTSCloseServer(
    IN HANDLE hServer
    )
{
    // Not much can be done here.
    // We will probably never hit this code anyway,
    // since you'd need to obtain a handle first
}

static
BOOL
WINAPI
WTSDisconnectSession(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN BOOL bWait
    )
{
    // Taskmgr needs an error code here
    SetLastError(ERROR_FUNCTION_NOT_CALLED);
    return FALSE;
}

BOOL
WINAPI
WTSEnumerateSessionsW(
    IN HANDLE hServer,
    IN DWORD Reserved,
    IN DWORD Version,
    OUT PWTS_SESSION_INFOW * ppSessionInfo,
    OUT DWORD * pCount
    )
{
    //  Windows Update needs an error code here
    SetLastError(ERROR_FUNCTION_NOT_CALLED);
    return FALSE;
}

VOID
WINAPI
WTSFreeMemory(
    IN PVOID pMemory
)
{
    // May as well just implement it directly since we're in kernel32 already.
    // Though theoretically nobody should call us since the only time you
    // WTSFreeMemory is after a successful WTSQuerySessionInformation.
    LocalFree( pMemory );
}

BOOL
WINAPI
WTSLogoffSession(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN BOOL bWait
    )
{
    // Taskmgr needs an error code here
    SetLastError(ERROR_FUNCTION_NOT_CALLED);
    return FALSE;
}

HANDLE
WINAPI
WTSOpenServerW(
    IN LPWSTR pServerName
    )
{
    // This function is doc'd to set the LE
    SetLastError(ERROR_FUNCTION_NOT_CALLED);
    return NULL;
}

BOOL
WINAPI
WTSQuerySessionInformationW(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN WTS_INFO_CLASS WTSInfoClass,
    OUT LPWSTR * ppBuffer,
    OUT DWORD * pBytesReturned
    )
{
    // SessMgr.exe needs an error code here
    SetLastError(ERROR_FUNCTION_NOT_CALLED);
    return FALSE;
}

BOOL
WINAPI
WTSQueryUserToken(
    IN ULONG SessionId,
    IN PHANDLE phToken
    )
{
    // Somebody might need an error code here
    SetLastError(ERROR_FUNCTION_NOT_CALLED);
    return FALSE;
}

BOOL
WINAPI
WTSSendMessageW(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN LPWSTR pTitle,
    IN DWORD TitleLength,
    IN LPWSTR pMessage,
    IN DWORD MessageLength,
    IN DWORD Style,
    IN DWORD Timeout,
    OUT DWORD * pResponse,
    IN BOOL bWait
    )
{
    // Taskmgr needs an error code here
    SetLastError(ERROR_FUNCTION_NOT_CALLED);
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(wtsapi32)
{
    DLPENTRY(WTSCloseServer)
    DLPENTRY(WTSDisconnectSession)
    DLPENTRY(WTSEnumerateSessionsW)
    DLPENTRY(WTSFreeMemory)
    DLPENTRY(WTSLogoffSession)
    DLPENTRY(WTSOpenServerW)
    DLPENTRY(WTSQuerySessionInformationW)
    DLPENTRY(WTSQueryUserToken)
    DLPENTRY(WTSSendMessageW)
};

DEFINE_PROCNAME_MAP(wtsapi32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\inc\sdapi.h ===
/****************************************************************************/
// sdapi.h
//
// TS protocol stack driver common definitions.
//
// Copyright (C) 1998-2000 Microsoft Corporation
/****************************************************************************/
#ifndef __SDAPI_H
#define __SDAPI_H


/*
 *  TRACE defines
 */
#if DBG
#define TRACE(_arg)     IcaStackTrace _arg
#define TRACEBUF(_arg)  IcaStackTraceBuffer _arg
#else
#define TRACE(_arg)
#define TRACEBUF(_arg)
#endif


/*
 * Input buffer data structure
 */
typedef struct _INBUF {

    LIST_ENTRY Links;           // Pointer to previous/next buffer
    PUCHAR pBuffer;             // Pointer to current location in Buffer
    ULONG ByteCount;            // Number of bytes in Buffer
    ULONG MaxByteCount;         // Max size of Buffer

    PIRP pIrp;                  // pointer to Irp to use for I/O
    PMDL pMdl;                  // pointer to MDL to use for I/O
    PVOID pPrivate;             // pointer to private data
} INBUF, *PINBUF;


/*
 *  Outpuf Buffer data structure
 */
typedef struct _OUTBUF {
    /*
     *  Non-inherited fields
     */
    ULONG OutBufLength;         // length of allocated memory for outbuf
    int PoolIndex;              // Stores the buffer pool this buffer goes to.
    LIST_ENTRY Links;           // pointer to previous/next outbuf
    PUCHAR pBuffer;             // pointer within buffer memory
    ULONG ByteCount;            // byte count pointed to by pBuffer
    ULONG MaxByteCount;         // maximum byte count possible (static)
    PETHREAD ThreadId;          // thread id which issued i/o reqst for this buf

    PIRP pIrp;                  // pointer to Irp to use for I/O
    PMDL pMdl;                  // pointer to MDL to use for I/O
    PVOID pPrivate;             // pointer to private data

    /*
     *  Inherited fields (when pd allocates new outbuf and copies the data)
     */
    ULONG StartTime;            // pdreli - transmit time (used to measure roundtrip)
    UCHAR Sequence;             // pdreli - output sequence number
    UCHAR Fragment;             // pdreli - outbuf fragment number
    ULONG fWait : 1;            // pdreli - waits allowed on this outbuf
    ULONG fControl : 1;         // pdreli - control buffer (ack/nak)
    ULONG fRetransmit : 1;      // pdreli - buffer has been retransmited
    ULONG fCompress : 1;        // pdcomp - buffer should be compressed

    // Other flags.
    ULONG fIrpCompleted : 1;    // Used on completion to prevent canceling.
} OUTBUF, * POUTBUF;


/*
 * Typedefs for Stack Driver callup routines
 */
typedef NTSTATUS (*PSDBUFFERALLOC)(
        IN PVOID pContext,
        IN BOOLEAN bWait,
        IN BOOLEAN bControl,
        ULONG ByteCount,
        PVOID pBufferOrig,
        PVOID *pBuffer);

typedef VOID (*PSDBUFFERFREE)(IN PVOID pContext, PVOID pBuffer);

typedef NTSTATUS (*PSDRAWINPUT)(
        IN PVOID pContext,
        IN PINBUF pInBuf OPTIONAL,
        IN PUCHAR pBuffer OPTIONAL,
        IN ULONG ByteCount);

typedef NTSTATUS (*PSDCHANNELINPUT)(
        IN PVOID pContext,
        IN CHANNELCLASS ChannelClass,
        IN VIRTUALCHANNELCLASS VirtualClass,
        IN PINBUF pInBuf OPTIONAL,
        IN PUCHAR pBuffer OPTIONAL,
        IN ULONG ByteCount);


/*
 * Stack Driver callup table
 */
typedef struct _SDCALLUP {
    PSDBUFFERALLOC  pSdBufferAlloc;
    PSDBUFFERFREE   pSdBufferFree;
    PSDBUFFERFREE   pSdBufferError;
    PSDRAWINPUT     pSdRawInput;
    PSDCHANNELINPUT pSdChannelInput;
} SDCALLUP, *PSDCALLUP;


/*
 * Stack Driver Context structure
 * This is filled in by the SD at load time, and is passed
 * as an argument to most ICA driver helper routines.
 */
typedef struct _SDCONTEXT {
    PVOID       pProcedures;    // Pointer to proc table for this driver
    PSDCALLUP   pCallup;        // Pointer to callup table for this driver
    PVOID       pContext;       // Context value passed on calls to driver
} SDCONTEXT, *PSDCONTEXT;


/*
 * Stack Driver Load/Unload procedure prototype
 */
typedef NTSTATUS (_stdcall *PSDLOADPROC)(
        IN OUT PSDCONTEXT pSdContext,
        IN BOOLEAN bLoad);

/*
 * Stack Driver procedure prototype
 */
typedef NTSTATUS (_stdcall *PSDPROCEDURE)(
        IN PVOID pContext,
        IN PVOID pParms);


/*=============================================================================
==   Stack Driver interface
=============================================================================*/

/*
 * Stack Driver (WD/PD/TD) APIs
 */
#define SD$OPEN         0
#define SD$CLOSE        1
#define SD$RAWWRITE     2
#define SD$CHANNELWRITE 3
#define SD$SYNCWRITE    4
#define SD$IOCTL        5
#define SD$COUNT        6


/*
 * SdOpen structure
 */
typedef struct _SD_OPEN {
    STACKCLASS StackClass;          // IN: stack type
    PPROTOCOLSTATUS pStatus;        // IN:
    PCLIENTMODULES pClient;         // IN:
    WDCONFIG WdConfig;              // IN: WD configuration data 
    PDCONFIG PdConfig;              // IN: PD configuration data 
    char  OEMId[4];                 // IN: WinFrame Server OEM Id from registry
    WINSTATIONNAME WinStationRegName; // IN: WinStation registry name
    PDEVICE_OBJECT DeviceObject;    // IN: pointer to device object to use with the unload safe completion routine
    ULONG OutBufHeader;             // IN: number of header bytes to reserve
    ULONG OutBufTrailer;            // IN: number of trailer bytes to reserve
    ULONG SdOutBufHeader;           // OUT: returned by sd
    ULONG SdOutBufTrailer;          // OUT: returned by sd   
} SD_OPEN, *PSD_OPEN;


/*
 * SdClose structure
 */
typedef struct _SD_CLOSE {
    ULONG SdOutBufHeader;           // OUT: returned by sd
    ULONG SdOutBufTrailer;          // OUT: returned by sd   
} SD_CLOSE, *PSD_CLOSE;


/*
 * SdRawWrite structure
 */
typedef struct _SD_RAWWRITE {
    POUTBUF pOutBuf;
    PUCHAR pBuffer;
    ULONG ByteCount;
} SD_RAWWRITE, *PSD_RAWWRITE;

/*
 * SdChannelWrite fFlags Values
 */
 #define SD_CHANNELWRITE_LOWPRIO    0x00000001  // Write can block behind
                                                //  default priority writes.

/*
 * SdChannelWrite structure
 *
 * The flags field is passed to termdd.sys via an IRP_MJ_WRITE 
 * Irp, as a ULONG pointer in the Irp->Tail.Overlay.DriverContext[0] field.
 */
typedef struct _SD_CHANNELWRITE {
    CHANNELCLASS ChannelClass;
    VIRTUALCHANNELCLASS VirtualClass;
    BOOLEAN fScreenData;
    POUTBUF pOutBuf;
    PUCHAR pBuffer;
    ULONG ByteCount;
    ULONG fFlags;
} SD_CHANNELWRITE, *PSD_CHANNELWRITE;

/*
 * SdIoctl structure
 */
typedef struct _SD_IOCTL {
    ULONG IoControlCode;           // IN
    PVOID InputBuffer;             // IN OPTIONAL
    ULONG InputBufferLength;       // IN
    PVOID OutputBuffer;            // OUT OPTIONAL
    ULONG OutputBufferLength;      // OUT
    ULONG BytesReturned;           // OUT
} SD_IOCTL, *PSD_IOCTL;


/*
 * SdSyncWrite structure
 */
typedef struct _SD_SYNCWRITE {
    ULONG notused;
} SD_SYNCWRITE, *PSD_SYNCWRITE;


/*=============================================================================
==   Stack Drivers helper routines
=============================================================================*/

#define ICALOCK_IO      0x00000001
#define ICALOCK_DRIVER  0x00000002

NTSTATUS IcaBufferAlloc(PSDCONTEXT, BOOLEAN, BOOLEAN, ULONG, PVOID, PVOID *);
void IcaBufferFree(PSDCONTEXT, PVOID);
void IcaBufferError(PSDCONTEXT, PVOID);
unsigned IcaBufferGetUsableSpace(unsigned);

NTSTATUS IcaRawInput(PSDCONTEXT, PINBUF, PUCHAR, ULONG);
NTSTATUS IcaChannelInput(PSDCONTEXT, CHANNELCLASS, VIRTUALCHANNELCLASS,
        PINBUF, PUCHAR, ULONG);
NTSTATUS IcaCreateThread(PSDCONTEXT, PVOID, PVOID, ULONG, PHANDLE);
NTSTATUS IcaCallNextDriver(PSDCONTEXT, ULONG, PVOID);

NTSTATUS IcaTimerCreate(PSDCONTEXT, PVOID *);
BOOLEAN IcaTimerStart(PVOID, PVOID, PVOID, ULONG, ULONG);
BOOLEAN IcaTimerCancel(PVOID);
BOOLEAN IcaTimerClose(PVOID);

NTSTATUS IcaQueueWorkItem(PSDCONTEXT, PVOID, PVOID, ULONG);
NTSTATUS IcaSleep(PSDCONTEXT, ULONG);
NTSTATUS IcaWaitForSingleObject(PSDCONTEXT, PVOID, LONG);
NTSTATUS IcaFlowControlSleep(PSDCONTEXT, ULONG);
NTSTATUS IcaFlowControlWait(PSDCONTEXT, PVOID, LONG);
NTSTATUS IcaWaitForMultipleObjects(PSDCONTEXT, ULONG, PVOID [], WAIT_TYPE,
        LONG);

NTSTATUS IcaLogError(PSDCONTEXT, NTSTATUS, LPWSTR *, ULONG, PVOID, ULONG);
VOID _cdecl IcaStackTrace(PSDCONTEXT, ULONG, ULONG, CHAR *, ...);
VOID IcaStackTraceBuffer(PSDCONTEXT, ULONG, ULONG, PVOID, ULONG);


NTSTATUS
IcaQueueWorkItemEx(
    IN PSDCONTEXT pContext,
    IN PVOID pFunc, 
    IN PVOID pParam, 
    IN ULONG LockFlags,
    IN PVOID pIcaWorkItem 
    );

NTSTATUS
IcaAllocateWorkItem(
    OUT PVOID *pParam 
    );

NTSTATUS
IcaCreateHandle(
    PVOID Context,
    ULONG ContextSize,
    PVOID *ppHandle
    );

NTSTATUS
IcaReturnHandle(
    PVOID  Handle,
    PVOID  *ppContext,
    PULONG pContextSize
    );

NTSTATUS
IcaCloseHandle(
    PVOID  Handle,
    PVOID  *ppContext,
    PULONG pContextSize
    );

PVOID IcaStackAllocatePoolWithTag(
        IN POOL_TYPE PoolType,
        IN SIZE_T NumberOfBytes,
        IN ULONG Tag );

PVOID IcaStackAllocatePool(
        IN POOL_TYPE PoolType,
        IN SIZE_T NumberOfBytes);

void IcaStackFreePool(IN PVOID Pointer);

ULONG IcaGetLowWaterMark(IN PSDCONTEXT pContext);

ULONG IcaGetSizeForNoLowWaterMark(IN PSDCONTEXT pContext);
#endif  // __SDAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\ctxdd\muio.c ===
/****************************************************************************/
// io.c
//
// Kernel file I/O utility functions.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <ntddk.h>
#include <ctxdd.h>


//
// External references
//
VOID IoQueueThreadIrp(IN PIRP);


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

NTSTATUS
_CtxDoFileIo(
    IN ULONG MajorFunction,
    IN PFILE_OBJECT fileObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PKEVENT pEvent,
    OUT PIO_STATUS_BLOCK pIosb,
    OUT PIRP *ppIrp 
    );

NTSTATUS
_CtxDeviceControlComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


/*******************************************************************************
 *  CtxReadFile
 *
 *    Kernel read file routine.
 *
 * ENTRY:
 *    fileObject (input)
 *       pointer to file object for I/O
 *    Buffer (input)
 *       pointer to read buffer
 *    Length (input)
 *       length of read buffer
 *    pEvent (input)
 *       pointer to I/O event (optional)
 *    pIosb (output)
 *       pointer to IoStatus block (optional)
 ******************************************************************************/
NTSTATUS CtxReadFile(
        IN PFILE_OBJECT fileObject,
        IN PVOID Buffer,
        IN ULONG Length,
        IN PKEVENT pEvent OPTIONAL,
        OUT PIO_STATUS_BLOCK pIosb OPTIONAL,
        OUT PIRP *ppIrp OPTIONAL)
{
    return _CtxDoFileIo(IRP_MJ_READ, fileObject, Buffer, Length, pEvent, pIosb, ppIrp);
}


/*******************************************************************************
 *  CtxWriteFile
 *
 *    Kernel write file routine.
 *
 * ENTRY:
 *    fileObject (input)
 *       pointer to file object for I/O
 *    Buffer (input)
 *       pointer to write buffer
 *    Length (input)
 *       length of write buffer
 *    pEvent (input) 
 *       pointer to I/O event (optional)
 *    pIosb (output)
 *       pointer to IoStatus block (optional)
 ******************************************************************************/
NTSTATUS CtxWriteFile(
        IN PFILE_OBJECT fileObject,
        IN PVOID Buffer,
        IN ULONG Length,
        IN PKEVENT pEvent OPTIONAL,
        OUT PIO_STATUS_BLOCK pIosb OPTIONAL,
        OUT PIRP *ppIrp OPTIONAL)
{
    return _CtxDoFileIo(IRP_MJ_WRITE, fileObject, Buffer, Length, pEvent, pIosb, ppIrp);
}


NTSTATUS _CtxDoFileIo(
        IN ULONG MajorFunction,
        IN PFILE_OBJECT fileObject,
        IN PVOID Buffer,
        IN ULONG Length,
        IN PKEVENT pEvent,
        OUT PIO_STATUS_BLOCK pIosb,
        OUT PIRP *ppIrp)
{
    PDEVICE_OBJECT deviceObject;
    LARGE_INTEGER Offset;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    KIRQL irql;
    static IO_STATUS_BLOCK Iosb;

    /*
     * We don't support synchronous (i.e. locked) file I/O.
     */
    ASSERT( !(fileObject->Flags & FO_SYNCHRONOUS_IO) );
    if ((fileObject->Flags & FO_SYNCHRONOUS_IO)) {
        return STATUS_INVALID_PARAMETER_MIX;
    }

    /*
     * If caller specified an event, clear it before we begin.
     */
    if (pEvent) {
        KeClearEvent(pEvent);
    }

    /*
     * If the caller does not supply an IOSB, supply
     * a static one to avoid the overhead of the exception
     * handler in the IO completion APC. Since the caller(s)
     * do not care about the result, we can point all such
     * callers to the same one.
     */
    if (pIosb == NULL) {
        pIosb = &Iosb;
    }

    /*
     * Get the DeviceObject for this file
     */
    deviceObject = IoGetRelatedDeviceObject(fileObject);

    /*
     * Build the IRP for this request
     */
    Offset.LowPart = FILE_WRITE_TO_END_OF_FILE;
    Offset.HighPart = -1;
    irp = IoBuildAsynchronousFsdRequest(MajorFunction, deviceObject,
            Buffer, Length, &Offset, pIosb);
    if (irp == NULL)
        return STATUS_INSUFFICIENT_RESOURCES;
   
    /*
     * Save callers event pointer.
     * Also, we must set IRP_SYNCHRONOUS_API in the IRP flags so that
     * the I/O completion code will NOT attempt to dereference the
     * event object, since it is not a real object manager object.
     */
    irp->UserEvent = pEvent;
    irp->Flags |= IRP_SYNCHRONOUS_API;

    /*
     * Reference the file object since it will be dereferenced in the
     * I/O completion code, and save a pointer to it in the IRP.
     */
    ObReferenceObject(fileObject);
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->FileObject = fileObject;

    /*
     * Set the address of the current thread in the packet so the
     * completion code will have a context to execute in.
     */
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Queue the IRP to the current thread
    //
    IoQueueThreadIrp(irp);

    //
    // Call driver
    //
    status = IoCallDriver( deviceObject, irp );

    //
    // If irp->UserEvent == NULL, IO completion will set the file
    // object event and status.
    //
    if (pEvent == NULL) {
        if (status == STATUS_PENDING) {
            status = KeWaitForSingleObject(&fileObject->Event,
                    Executive,
                    KernelMode, // Prevent KSTACK from paging
                    FALSE,      // Non-alertable
                    (PLARGE_INTEGER)NULL);

            ASSERT(status != STATUS_ALERTED);
            ASSERT(status != STATUS_USER_APC);

            status = fileObject->FinalStatus;
        }
    }

    // This crappy function interface is broken -- returning the IRP
    // pointer could corrupt the system, since it could be completed
    // and deallocated before the return completes and the caller
    // attempts to use the pointer. To get the IRP back the caller
    // would have had to set a completion routine, but we use
    // IoBuildAsynchronousFsdRequest() which does not allow that.
    // Want to change the interface to get rid of the OPTIONAL
    // junk -- TermDD only uses the write() interface and always
    // passes NULL for everything -- but who knows whether Citrix
    // uses this internally?
    // Set the return pointer to NULL to cause the caller to fault.
    if (pEvent != NULL && ppIrp != NULL)
        *ppIrp = NULL;

    return status;
}


/*******************************************************************************
 *  CtxDeviceIoControlFile
 *
 *    Kernel DeviceIoControl routine
 *
 * ENTRY:
 *    fileObject (input)
 *       pointer to file object for I/O
 *    IoControlCode (input)
 *       Io control code
 *    InputBuffer (input)
 *       pointer to input buffer (optional)
 *    InputBufferLength (input)
 *       length of input buffer
 *    OutputBuffer (input)
 *       pointer to output buffer (optional)
 *    OutputBufferLength (input)
 *       length of output buffer
 *    InternalDeviceIoControl (input)
 *       if TRUE, use IOCTL_INTERNAL_DEVICE_IO_CONTROL
 *    pEvent (input)
 *       pointer to I/O event (optional)
 *    pIosb (output)
 *       pointer to IoStatus block (optional)
 ******************************************************************************/
NTSTATUS CtxDeviceIoControlFile(
        IN PFILE_OBJECT fileObject,
        IN ULONG IoControlCode,
        IN PVOID InputBuffer OPTIONAL,
        IN ULONG InputBufferLength,
        OUT PVOID OutputBuffer OPTIONAL,
        IN ULONG OutputBufferLength,
        IN BOOLEAN InternalDeviceIoControl,
        IN PKEVENT pEvent OPTIONAL,
        OUT PIO_STATUS_BLOCK pIosb,
        OUT PIRP *ppIrp OPTIONAL)
{
    PDEVICE_OBJECT deviceObject;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    /*
     * We don't support synchronous (i.e. locked) file I/O.
     */
    ASSERT( !(fileObject->Flags & FO_SYNCHRONOUS_IO) );
    if ( (fileObject->Flags & FO_SYNCHRONOUS_IO) ) {
        return( STATUS_INVALID_PARAMETER_MIX );
    }

    /*
     * If caller specified an event, clear it before we begin.
     */
    if (pEvent) {
        KeClearEvent(pEvent);
    }

    /*
     * Get the DeviceObject for this file
     */
    deviceObject = IoGetRelatedDeviceObject( fileObject );

    /*
     * Build the IRP for this request
     */
    irp = IoBuildDeviceIoControlRequest( IoControlCode, deviceObject,
                                         InputBuffer, InputBufferLength,
                                         OutputBuffer, OutputBufferLength,
                                         InternalDeviceIoControl,
                                         pEvent, pIosb );
    if ( irp == NULL )
        return( STATUS_INSUFFICIENT_RESOURCES );

    /*
     * Reference the file object since it will be dereferenced in the
     * I/O completion code, and save a pointer to it in the IRP.
     * Also, we must set IRP_SYNCHRONOUS_API in the IRP flags so that
     * the I/O completion code will NOT attempt to dereference the
     * event object, since it is not a real object manager object.
     */
    ObReferenceObject( fileObject );
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = fileObject;
    irp->Flags |= IRP_SYNCHRONOUS_API;

    /*
     * Call the driver
     */
    status = IoCallDriver(deviceObject, irp);

    /*
     * If the caller did not specify a wait event and the I/O is pending,
     * then we must wait for the I/O to complete before we return.
     */
    if (pEvent == NULL) {
        if (status == STATUS_PENDING) {
            status = KeWaitForSingleObject(&fileObject->Event, UserRequest,
                    KernelMode, FALSE, NULL);
            if (status == STATUS_SUCCESS)
                status = fileObject->FinalStatus;
        }

    /*
     * Caller specified a wait event.
     * Return the Irp pointer if the caller specified a return pointer.
     */
    } else {
        if (ppIrp)
            *ppIrp = irp;
    }

    return status;
}


/*******************************************************************************
 *  CtxInternalDeviceIoControlFile
 *
 *    Kernel DeviceIoControl routine
 *
 * ENTRY:
 *    fileObject (input)
 *       pointer to file object for I/O
 *    IrpParameters (input)
 *       information to write to the parameters section of the
 *       stack location of the IRP.
 *    IrpParametersLength (input)
 *       length of the parameter information.  Cannot be greater than 16.
 *    MdlBuffer (input)
 *       if non-NULL, a buffer of nonpaged pool to be mapped
 *       into an MDL and placed in the MdlAddress field of the IRP.
 *    MdlBufferLength (input)
 *       the size of the buffer pointed to by MdlBuffer.
 *    MinorFunction (input)
 *       the minor function code for the request.
 *    pEvent (input)
 *       pointer to I/O event (optional)
 *    pIosb (output)
 *       pointer to IoStatus block (optional)
 ******************************************************************************/
NTSTATUS CtxInternalDeviceIoControlFile(
        IN PFILE_OBJECT fileObject,
        IN PVOID IrpParameters,
        IN ULONG IrpParametersLength,
        IN PVOID MdlBuffer OPTIONAL,
        IN ULONG MdlBufferLength,
        IN UCHAR MinorFunction,
        IN PKEVENT pEvent OPTIONAL,
        OUT PIO_STATUS_BLOCK pIosb OPTIONAL,
        OUT PIRP *ppIrp OPTIONAL)
{
    PDEVICE_OBJECT deviceObject;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PMDL mdl;
    NTSTATUS status;

    /*
     * We don't support synchronous (i.e. locked) file I/O.
     */
    ASSERT( !(fileObject->Flags & FO_SYNCHRONOUS_IO) );
    if ( (fileObject->Flags & FO_SYNCHRONOUS_IO) ) {
        return( STATUS_INVALID_PARAMETER_MIX );
    }

    /*
     * If caller specified an event, clear it before we begin.
     */
    if ( pEvent ) {
        KeClearEvent( pEvent );
    }

    /*
     * Get the DeviceObject for this file
     */
    deviceObject = IoGetRelatedDeviceObject( fileObject );

    /*
     * Build the IRP for this request
     */
    irp = IoBuildDeviceIoControlRequest( 0, deviceObject,
                                         NULL, 0,
                                         NULL, 0,
                                         TRUE,
                                         pEvent, pIosb );
    if ( irp == NULL )
        return( STATUS_INSUFFICIENT_RESOURCES );

    /*
     * If an MDL buffer was specified, get an MDL, map the buffer,
     * and place the MDL pointer in the IRP.
     */
    if ( MdlBuffer != NULL ) {
        mdl = IoAllocateMdl(
                  MdlBuffer,
                  MdlBufferLength,
                  FALSE,
                  FALSE,
                  irp
                  );
        if ( mdl == NULL ) {
            IoFreeIrp( irp );
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        MmBuildMdlForNonPagedPool( mdl );
    } else {
        irp->MdlAddress = NULL;
    }

    /*
     * Reference the file object since it will be dereferenced in the
     * I/O completion code, and save a pointer to it in the IRP.
     * Also, we must set IRP_SYNCHRONOUS_API in the IRP flags so that
     * the I/O completion code will NOT attempt to dereference the
     * event object, since it is not a real object manager object.
     */
    ObReferenceObject( fileObject );
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = fileObject;
    irp->Flags |= IRP_SYNCHRONOUS_API;

    /*
     * Fill in the service-dependent parameters for the request.
     */
    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = MinorFunction;

    ASSERT( IrpParametersLength <= sizeof(irpSp->Parameters) );
    RtlCopyMemory( &irpSp->Parameters, IrpParameters, IrpParametersLength );

    /*
     * Set up a completion routine which we'll use to free the MDL
     * allocated previously.
     */
    IoSetCompletionRoutine( irp, _CtxDeviceControlComplete, NULL, TRUE, TRUE, TRUE );

    /*
     * Call the driver
     */
    status = IoCallDriver( deviceObject, irp );

    /*
     * If the caller did not specify a wait event and the I/O is pending,
     * then we must wait for the I/O to complete before we return.
     */
    if ( pEvent == NULL ) {
        if ( status == STATUS_PENDING ) {
            status = KeWaitForSingleObject( &fileObject->Event, UserRequest, KernelMode, FALSE, NULL );
            if ( status == STATUS_SUCCESS )
                status = fileObject->FinalStatus;
        }

    /*
     * Caller specified a wait event.
     * Return the Irp pointer if the caller specified a return pointer.
     */
    } else {
        if ( ppIrp )
            *ppIrp = irp;
    }

    return( status );
}


NTSTATUS _CtxDeviceControlComplete(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context)
{
    //
    // If there was an MDL in the IRP, free it and reset the pointer to
    // NULL.  The IO system can't handle a nonpaged pool MDL being freed
    // in an IRP, which is why we do it here.
    //
    if ( Irp->MdlAddress != NULL ) {
        IoFreeMdl( Irp->MdlAddress );
        Irp->MdlAddress = NULL;
    }

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\abacom.c ===
/****************************************************************************/
/* abacom.c                                                                 */
/*                                                                          */
/* BA code common to DD and WD                                              */
/*                                                                          */
/* Copyright(c) Microsoft 1997-1998                                         */
/****************************************************************************/


#ifdef DC_DEBUG

/****************************************************************************/
/* Name:      BACheckList                                                   */
/*                                                                          */
/* Purpose:   Check the integrity of the BA list                            */
/****************************************************************************/
void RDPCALL SHCLASS BACheckList(void)
{
    unsigned usedCount, freeCount;
    unsigned next;
    unsigned prev;
    UINT32 totalArea;
    
    DC_BEGIN_FN("BACheckList");

    /************************************************************************/
    /* Check used list                                                      */
    /************************************************************************/
    usedCount = 0;
    totalArea = 0;
    next = _pShm->ba.firstRect;
    prev = BA_INVALID_RECT_INDEX;
    while (next != BA_INVALID_RECT_INDEX)
    {
        TRC_ASSERT((_pShm->ba.bounds[next].inUse),
                    (TB,"BA used list entry not marked in use"));
        TRC_ASSERT((_pShm->ba.bounds[next].iPrev == prev),
                    (TB,"BA used list entry iPrev not correct (%u, expected %u)",
                    _pShm->ba.bounds[next].iPrev, prev));

        totalArea += _pShm->ba.bounds[next].area;
        usedCount++;
        prev = next;
        next = _pShm->ba.bounds[next].iNext;
    }

    TRC_ASSERT((usedCount == _pShm->ba.rectsUsed),
                (TB,"BA used list inconsistent count (%u, expected %u)",
                _pShm->ba.rectsUsed, usedCount));
    TRC_ASSERT((usedCount <= BA_TOTAL_NUM_RECTS),
                (TB,"Too many used list rectangles (%d)", usedCount));
    TRC_ASSERT((totalArea == _pShm->ba.totalArea),
                (TB,"BA totalArea not correct (shm=%u, elements=%u)",
                _pShm->ba.totalArea, totalArea));

    /************************************************************************/
    /* Check free list                                                      */
    /************************************************************************/
    freeCount = 0;
    next = _pShm->ba.firstFreeRect;
    while (next != BA_INVALID_RECT_INDEX)
    {
        TRC_ASSERT((!_pShm->ba.bounds[next].inUse),
                    (TB,"BA free list entry not marked free"));

        freeCount++;
        next = _pShm->ba.bounds[next].iNext;
    }

    TRC_ASSERT((freeCount == (BA_TOTAL_NUM_RECTS - _pShm->ba.rectsUsed)),
                (TB,"BA free list inconsistent count (%u, expected %u)",
                freeCount, (BA_TOTAL_NUM_RECTS - _pShm->ba.rectsUsed)));
    TRC_ASSERT((freeCount <= BA_TOTAL_NUM_RECTS),
                (TB,"Too many free list rectangles (%d)", freeCount));

    TRC_ASSERT(((freeCount + usedCount) == BA_TOTAL_NUM_RECTS),
                (TB,"Used+free (%u) != total rects", usedCount + freeCount));

    DC_END_FN();
}

#endif  // DC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\abaapi.h ===
/****************************************************************************/
// abaapi.h
//
// RDP Bounds Accumulator API header.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_ABAAPI
#define _H_ABAAPI


#define BA_INVALID_RECT_INDEX ((unsigned)-1)

// We allocate space for one more rectangle than total number we accumulate
// so we have a "work" rectangle.
#define BA_MAX_ACCUMULATED_RECTS  20
#define BA_TOTAL_NUM_RECTS        (BA_MAX_ACCUMULATED_RECTS + 1)


/****************************************************************************/
// BA_RECT_INFO
//
// Information about an accumulated rectangle.
/****************************************************************************/
typedef struct
{
    unsigned iNext;
    unsigned iPrev;
    RECTL    coord;
    UINT32   area;
    BOOL     inUse;
} BA_RECT_INFO, *PBA_RECT_INFO;


/****************************************************************************/
// BA_SHARED_DATA
//
// BA data shared between DD and WD.
/****************************************************************************/
typedef struct
{
    unsigned firstRect;
    unsigned rectsUsed;
    UINT32   totalArea;
    unsigned firstFreeRect;

    // "+ 1" added below to stop retail builds crashing as a result of #123
    // and its relations. Remove when we fix the bug properly.
    BA_RECT_INFO bounds[BA_TOTAL_NUM_RECTS + 1];
} BA_SHARED_DATA, *PBA_SHARED_DATA;



#endif /* _H_ABAAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\abacom.h ===
/****************************************************************************/
// abacom.h
//
// BA inline functions and prototypes common to both DD and WD.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_BACOM
#define _H_BACOM


#ifdef DLL_DISP
#define _pShm pddShm
#else
#define _pShm m_pShm
#endif


#ifdef DC_DEBUG
void RDPCALL BACheckList(void);
#endif


/****************************************************************************/
// BACopyBounds
//
// Copies the current (exclusive) SDA rects.
/****************************************************************************/
__inline void RDPCALL BACopyBounds(PRECTL pRects, unsigned *pNumRects)
{
    unsigned iSrc, iDst;
    PBA_RECT_INFO pRectInfo;

    *pNumRects = _pShm->ba.rectsUsed;

    // Return the bounds that have been accumulated by traversing the
    // in-use list.
    iSrc = _pShm->ba.firstRect;
    iDst = 0;
    while (iSrc != BA_INVALID_RECT_INDEX) {
        pRectInfo = &(_pShm->ba.bounds[iSrc]);
        pRects[iDst] = pRectInfo->coord;
        iDst++;
        iSrc = pRectInfo->iNext;
    }
}


/****************************************************************************/
// BAResetBounds
//
// Clears the bounds list.
/****************************************************************************/
__inline void RDPCALL BAResetBounds(void)
{
    unsigned iRect, iHold;
    BA_RECT_INFO *pRect;
    
    // Restore all rects in used list to the free list.
    iRect = _pShm->ba.firstRect;
    while (iRect != BA_INVALID_RECT_INDEX) {
        pRect = &_pShm->ba.bounds[iRect];
        pRect->inUse = FALSE;
        iHold = iRect;
        iRect = pRect->iNext;
        pRect->iNext = _pShm->ba.firstFreeRect;
        _pShm->ba.firstFreeRect = iHold;
    }

    _pShm->ba.firstRect = BA_INVALID_RECT_INDEX;
    _pShm->ba.rectsUsed = 0;
    _pShm->ba.totalArea = 0;
}


/****************************************************************************/
// BAAddRectList
//
// Adds a rect into the Screen Data Area.
/****************************************************************************/
__inline void RDPCALL BAAddRectList(PRECTL pRect)
{
    unsigned iNewRect;
    BA_RECT_INFO *pNewRect;
    
    // Note it is responsibility of caller to make sure that there is
    // enough space in the bounds array and that the rectangle is valid
    // (the left is not greater than the right, top is less than bottom).
    // The extra rect at the end of the list is extra space that will be
    // used only temporarily by the rect merge code.

    // Add the rect to the bounds. This is essentially a doubly-linked list
    // insertion using the rect at the head of the free list. Order does
    // not matter, so we also insert at the beginning of the in-use list.
    iNewRect = _pShm->ba.firstFreeRect;
    pNewRect = &(_pShm->ba.bounds[iNewRect]);

    // Remove from free list.
    _pShm->ba.firstFreeRect = pNewRect->iNext;

    // Add to beginning of used list.
    pNewRect->iNext = _pShm->ba.firstRect;
    pNewRect->iPrev = BA_INVALID_RECT_INDEX;
    if (pNewRect->iNext != BA_INVALID_RECT_INDEX)
        _pShm->ba.bounds[pNewRect->iNext].iPrev = iNewRect;
    _pShm->ba.firstRect = iNewRect;
    _pShm->ba.rectsUsed++;

    // Fill in data.
    pNewRect->inUse = TRUE;
    pNewRect->coord = *pRect;
    pNewRect->area = COM_SIZEOF_RECT(pNewRect->coord);
    _pShm->ba.totalArea += pNewRect->area;

#ifdef DC_DEBUG
    // Check the list integrity.
    BACheckList();
#endif

}



#endif  // !defined(_H_BACOM)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\abaafn.h ===
/****************************************************************************/
// abaafn.h
//
// Function prototypes for BA API functions.
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

void RDPCALL BA_Init(void);

void RDPCALL BA_UpdateShm(void);


#ifdef __cplusplus

// Include common function defs
#include <abacom.h>


/****************************************************************************/
// BA_Term
/****************************************************************************/
void RDPCALL BA_Term(void)
{
}


/****************************************************************************/
// BA_SyncUpdatesNow
//
// Performs necessary work when a sync is required (reset the bounds).
/****************************************************************************/
void RDPCALL BA_SyncUpdatesNow(void)
{
    baResetBounds = TRUE;
    DCS_TriggerUpdateShmCallback();
}


/****************************************************************************/
// BA_GetBounds
//
// Returns the current SDA rects and resets the list.
/****************************************************************************/
void RDPCALL BA_GetBounds(PRECTL pRects, unsigned *pNumRects)
{
    BACopyBounds(pRects, pNumRects);
    BAResetBounds();
}


/****************************************************************************/
// BA_BoundsAreWaiting
//
// Returns whether there are any accumulated bounding rectangles.
/****************************************************************************/
BOOL RDPCALL BA_BoundsAreWaiting(void)
{
    return (m_pShm->ba.rectsUsed > 0);
}


/****************************************************************************/
// BA_AddRect
//
// Adds a rect into the Screen Data Area.
/****************************************************************************/
void RDPCALL BA_AddRect(PRECTL pRect)
{
    BAAddRectList(pRect);
}



#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\abcafn.h ===
/****************************************************************************/
/* abcafn.h                                                                 */
/*                                                                          */
/* Function prototypes for BC API functions                                 */
/*                                                                          */
/* COPYRIGHT (c) Microsoft 1996-1999                                        */
/****************************************************************************/

#ifdef DC_HICOLOR
BOOL RDPCALL SHCLASS BC_CompressBitmap(
        PBYTE    pSrcBitmap,
        PBYTE    pDstBuffer,
        PBYTE    pBCWorkingBuffer,
        unsigned dstBufferSize,
        unsigned *pCompressedDataSize,
        unsigned bitmapWidth,
        unsigned bitmapHeight,
        unsigned bpp);
#else
BOOL RDPCALL BC_CompressBitmap(
        PBYTE    pSrcBitmap,
        PBYTE    pDstBuffer,
        unsigned dstBufferSize,
        unsigned *pCompressedDataSize,
        unsigned bitmapWidth,
        unsigned bitmapHeight);
#endif


#ifdef DC_HICOLOR
unsigned RDPCALL CompressV2Int(
        PBYTE    pSrc,
        PBYTE    pDst,
        unsigned numBytes,
        unsigned rowDelta,
        unsigned dstBufferSize,
        BYTE *   xorbuf);

unsigned RDPCALL CompressV2Int15(
        PBYTE    pSrc,
        PBYTE    pDst,
        unsigned numBytes,
        unsigned rowDelta,
        unsigned dstBufferSize,
        BYTE *   xorbuf,
        MATCH *  match);

unsigned RDPCALL CompressV2Int16(
        PBYTE    pSrc,
        PBYTE    pDst,
        unsigned numBytes,
        unsigned rowDelta,
        unsigned dstBufferSize,
        BYTE *   xorbuf,
        MATCH *  match);

unsigned RDPCALL CompressV2Int24(
        PBYTE    pSrc,
        PBYTE    pDst,
        unsigned numPels,
        unsigned rowDelta,
        unsigned dstBufferSize,
        BYTE *   xorbuf,
        MATCH *  match);

unsigned RDPCALL CompressV2Int32(
        PBYTE    pSrc,
        PBYTE    pDst,
        unsigned numPels,
        unsigned rowDelta,
        unsigned dstBufferSize,
        BYTE *   xorbuf,
        MATCH *  match);

#else
unsigned RDPCALL CompressV2Int(PBYTE, PBYTE, unsigned,
        unsigned, unsigned, BYTE *);
#endif

/****************************************************************************/
/* API FUNCTION: BC_Init                                                    */
/*                                                                          */
/* Initializes the Bitmap Compressor.                                       */
/****************************************************************************/
//void RDPCALL BC_Init(void)
#define BC_Init()


/****************************************************************************/
/* API FUNCTION: BC_Term                                                    */
/*                                                                          */
/* Terminates the Bitmap Compressor.                                        */
/****************************************************************************/
//void RDPCALL BC_Term(void)
#define BC_Term()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\abcapi.c ===
/****************************************************************************/
/* abcapi.cpp                                                               */
/*                                                                          */
/* Bitmap Compressor API functions.                                         */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1997                             */
/* Copyright(c) Microsoft 1997-1999                                         */
/****************************************************************************/

#ifdef DLL_DISP

#include <adcg.h>
#include <adcs.h>
#include <abcapi.h>
#include <abcdata.c>

#define _pShm pddShm

#else

#include <as_conf.hpp>

#define _pShm m_pShm

#endif


#ifdef COMP_STATS
/****************************************************************************/
/* Define some globals for storing useful stats data.                       */
/****************************************************************************/
UINT32 ulPreCompData = 0;
UINT32 ulTotalCompTime = 0;
UINT32 ulCompRate = 0;
#endif

#ifdef DC_DEBUG
// compression testing
#include <abdapi.h>
#endif

#ifdef Unused
// Restore this instead of macro if data added to abcdata.c
/****************************************************************************/
/* API FUNCTION: BC_Init                                                    */
/*                                                                          */
/* Initializes the Bitmap Compressor.                                       */
/****************************************************************************/
void RDPCALL SHCLASS BC_Init(void)
{
    DC_BEGIN_FN("BC_Init");

#define DC_INIT_DATA
#include <abcdata.c>
#undef DC_INIT_DATA

    DC_END_FN();
}
#endif


/****************************************************************************/
/* API FUNCTION: BC_CompressBitmap                                          */
/*                                                                          */
/* Compresses the supplied bitmap into the supplied memory buffer.          */
/*                                                                          */
/* PARAMETERS:                                                              */
/*                                                                          */
/* pSrcBitmap - a pointer to the source bitmap data bits.                   */
/*                                                                          */
/* pDstBuffer - a pointer to the destination memory buffer (where the       */
/* compressed data will be written).                                        */
/*                                                                          */
/* dstBufferSize - the size in bytes of the destination buffer              */
/*                                                                          */
/* pCompressedDataSize - pointer to variable that receives the compressed   */
/* data size                                                                */
/*                                                                          */
/* bitmapWidth - width of the src bitmap in pels, should be divisible by 4. */
/*                                                                          */
/* bitmapHeight - the height of the source bitmap in pels.                  */
/*                                                                          */
/* RETURNS:                                                                 */
/*                                                                          */
/* TRUE - the bitmap data was successfully compressed.                      */
/* *pCompressedDataSize is updated                                          */
/*                                                                          */
/* FALSE - the bitmap data could not be compressed.                         */
/****************************************************************************/
#ifdef DC_HICOLOR
BOOL RDPCALL SHCLASS BC_CompressBitmap(
        PBYTE    pSrcBitmap,
        PBYTE    pDstBuffer,
        PBYTE    pBCWorkingBuffer,
        unsigned dstBufferSize,
        unsigned *pCompressedDataSize,
        unsigned bitmapWidth,
        unsigned bitmapHeight,
        unsigned bpp)
#else
BOOL RDPCALL SHCLASS BC_CompressBitmap(
        PBYTE    pSrcBitmap,
        PBYTE    pDstBuffer,
        unsigned dstBufferSize,
        unsigned *pCompressedDataSize,
        unsigned bitmapWidth,
        unsigned bitmapHeight)
#endif
{
    BOOL rc;
    PTS_CD_HEADER_UA pCompDataHeader;
    unsigned cbUncompressedDataSize;
    unsigned cbCompMainBodySize;

#ifdef COMP_STATS
    UINT32 ulStartCompTime;
    UINT32 ulEndCompTime;
#endif

    DC_BEGIN_FN("BC_CompressBitmap");

#ifdef COMP_STATS
    /************************************************************************/
    /* Record the start time.                                               */
    /************************************************************************/
    COM_GETTICKCOUNT(ulStartCompTime);
#endif

    TRC_ASSERT(((bitmapWidth & 3) == 0),(TB,"Width not divisible by 4"));
    TRC_ASSERT((dstBufferSize > 0),(TB,"No destination space!"));

    // Trace the important parameters.
    TRC_DBG((TB, "pSrc(%p) pDst(%p) dstBufferSize(%#x)",
            pSrcBitmap, pDstBuffer, dstBufferSize));
    TRC_DBG((TB, "width(%u) height(%u)", bitmapWidth, bitmapHeight));

    // Calculate the size of the uncompressed src data. Make sure it
    // is within our allowed size.
#ifdef DC_HICOLOR
    cbUncompressedDataSize = bitmapWidth * bitmapHeight * ((bpp + 7) / 8);
#else
    cbUncompressedDataSize = bitmapWidth * bitmapHeight;
#endif
    TRC_ASSERT((cbUncompressedDataSize <= MAX_UNCOMPRESSED_DATA_SIZE || pBCWorkingBuffer),
            (TB,"Bitmap size > max: size=%u, max=%u",
            cbUncompressedDataSize, MAX_UNCOMPRESSED_DATA_SIZE));

    // Do we send the bitmap compression header?
    if (_pShm->bc.noBitmapCompressionHdr)
    {
#ifdef DC_HICOLOR
        switch (bpp)
        {
            case 32:
            {
                TRC_DBG((TB, "Compress 32 bpp"));
                cbCompMainBodySize = CompressV2Int32(pSrcBitmap,
                                                     pDstBuffer,
                                                     cbUncompressedDataSize,
                                                     bitmapWidth * 4,
                                                     dstBufferSize,
                                                     pBCWorkingBuffer ? pBCWorkingBuffer :
                                                     _pShm->bc.xor_buffer,
                                                     _pShm->bc.match);
            }
            break;

            case 24:
            {
                TRC_DBG((TB, "Compress 24 bpp"));
                cbCompMainBodySize = CompressV2Int24(pSrcBitmap,
                                                     pDstBuffer,
                                                     cbUncompressedDataSize,
                                                     bitmapWidth * 3,
                                                     dstBufferSize,
                                                     pBCWorkingBuffer ? pBCWorkingBuffer :
                                                     _pShm->bc.xor_buffer,
                                                     _pShm->bc.match);
            }
            break;

            case 16:
            {
                TRC_DBG((TB, "Compress 16bpp"));
                cbCompMainBodySize = CompressV2Int16(pSrcBitmap,
                                                     pDstBuffer,
                                                     cbUncompressedDataSize,
                                                     bitmapWidth * 2,
                                                     dstBufferSize,
                                                     pBCWorkingBuffer ? pBCWorkingBuffer :
                                                     _pShm->bc.xor_buffer,
                                                     _pShm->bc.match);
            }
            break;

            case 15:
            {
                TRC_DBG((TB, "Compress 15bpp"));
                cbCompMainBodySize = CompressV2Int15(pSrcBitmap,
                                                     pDstBuffer,
                                                     cbUncompressedDataSize,
                                                     bitmapWidth * 2,
                                                     dstBufferSize,
                                                     pBCWorkingBuffer ? pBCWorkingBuffer :
                                                     _pShm->bc.xor_buffer,
                                                     _pShm->bc.match);
            }
            break;

            case 8:
            default:
            {
                TRC_DBG((TB, "Compress 8bpp"));
                cbCompMainBodySize = CompressV2Int(pSrcBitmap,
                                                   pDstBuffer,
                                                   cbUncompressedDataSize,
                                                   bitmapWidth,
                                                   dstBufferSize,
                                                   pBCWorkingBuffer ? pBCWorkingBuffer :
                                                   _pShm->bc.xor_buffer);
            }
            break;
        }
#else
        cbCompMainBodySize = CompressV2Int(pSrcBitmap,
                                           pDstBuffer,
                                           cbUncompressedDataSize,
                                           bitmapWidth,
                                           dstBufferSize,
                                           _pShm->bc.xor_buffer);
#endif
        if (cbCompMainBodySize != 0) {
            // Write back the new (compressed) packet size.
            *pCompressedDataSize = cbCompMainBodySize;

            TRC_DBG((TB, "*pCompressedDataSize(%u)",
                    *pCompressedDataSize));
            rc = TRUE;
        }
        else {
            TRC_NRM((TB, "Failed to compress main body"));
            rc = FALSE;
        }
    }
    else {
        if (dstBufferSize > sizeof(TS_CD_HEADER)) {
            // Compress the bitmap data.
#ifdef DC_HICOLOR
            switch (bpp)
            {
                case 32:
                {
                    TRC_DBG((TB, "Compress 32 bpp"));
                    cbCompMainBodySize = CompressV2Int32(pSrcBitmap,
                                                         pDstBuffer + sizeof(TS_CD_HEADER),
                                                         cbUncompressedDataSize,
                                                         bitmapWidth * 4,
                                                         dstBufferSize - sizeof(TS_CD_HEADER),
                                                         pBCWorkingBuffer ? pBCWorkingBuffer :
                                                         _pShm->bc.xor_buffer,
                                                         _pShm->bc.match);
                }
                break;

                case 24:
                {
                    TRC_DBG((TB, "Compress 24 bpp"));
                    cbCompMainBodySize = CompressV2Int24(pSrcBitmap,
                                                         pDstBuffer + sizeof(TS_CD_HEADER),
                                                         cbUncompressedDataSize,
                                                         bitmapWidth * 3,
                                                         dstBufferSize - sizeof(TS_CD_HEADER),
                                                         pBCWorkingBuffer ? pBCWorkingBuffer :
                                                         _pShm->bc.xor_buffer,
                                                         _pShm->bc.match);
                }
                break;

                case 16:
                {
                    TRC_DBG((TB, "Compress 16bpp"));
                    cbCompMainBodySize = CompressV2Int16(pSrcBitmap,
                                                         pDstBuffer + sizeof(TS_CD_HEADER),
                                                         cbUncompressedDataSize,
                                                         bitmapWidth * 2,
                                                         dstBufferSize - sizeof(TS_CD_HEADER),
                                                         pBCWorkingBuffer ? pBCWorkingBuffer :
                                                         _pShm->bc.xor_buffer,
                                                         _pShm->bc.match);
                }
                break;

                case 15:
                {
                    TRC_DBG((TB, "Compress 15bpp"));
                    cbCompMainBodySize = CompressV2Int15(pSrcBitmap,
                                                         pDstBuffer + sizeof(TS_CD_HEADER),
                                                         cbUncompressedDataSize,
                                                         bitmapWidth * 2,
                                                         dstBufferSize - sizeof(TS_CD_HEADER),
                                                         pBCWorkingBuffer ? pBCWorkingBuffer :
                                                         _pShm->bc.xor_buffer,
                                                         _pShm->bc.match);
                }
                break;

                case 8:
                default:
                {
                    TRC_DBG((TB, "Compress 8bpp"));
                    cbCompMainBodySize = CompressV2Int(pSrcBitmap,
                                                       pDstBuffer + sizeof(TS_CD_HEADER),
                                                       cbUncompressedDataSize,
                                                       bitmapWidth,
                                                       dstBufferSize - sizeof(TS_CD_HEADER),
                                                       pBCWorkingBuffer ? pBCWorkingBuffer :
                                                       _pShm->bc.xor_buffer);
                }
                break;
            }
#else
            cbCompMainBodySize = CompressV2Int(pSrcBitmap,
                                               pDstBuffer + sizeof(TS_CD_HEADER),
                                               cbUncompressedDataSize,
                                               bitmapWidth,
                                               dstBufferSize - sizeof(TS_CD_HEADER),
                                               _pShm->bc.xor_buffer);
#endif
            if (cbCompMainBodySize != 0) {
                // Fill in the compressed data header.
                // FirstRowSize is 0 by historical convention.
                pCompDataHeader = (PTS_CD_HEADER_UA)pDstBuffer;
                pCompDataHeader->cbCompFirstRowSize = 0;
                pCompDataHeader->cbCompMainBodySize =
                        (UINT16)cbCompMainBodySize;
                
                if (bpp > 8) {
                    pCompDataHeader->cbScanWidth = TS_BYTES_IN_SCANLINE(bitmapWidth, bpp);
                }
                else {
                    pCompDataHeader->cbScanWidth = (UINT16)bitmapWidth;                    
                }

                pCompDataHeader->cbUncompressedSize =
                        (UINT16)cbUncompressedDataSize;

                // Write back the new (compressed) packet size.
                *pCompressedDataSize = sizeof(TS_CD_HEADER) +
                        cbCompMainBodySize;

                TRC_DBG((TB, "*pCompressedDataSize(%u)",
                        *pCompressedDataSize));
                rc = TRUE;
            }
            else {
                TRC_NRM((TB, "Failed to compress main body"));
                rc = FALSE;
            }
        }
        else {
            TRC_NRM((TB, "Not enough buffer space for header: %u",
                    dstBufferSize));
            rc = FALSE;
        }
    }

#if 0
    /************************************************************************/
    /* Check that the compressed output decompresses to the same thing      */
    /************************************************************************/
    if (cbCompMainBodySize)
    {
        HRESULT hr;
        hr = BD_DecompressBitmap(
#ifndef DLL_DISP
                m_pTSWd,
#endif
                pDstBuffer + (_pShm->bc.noBitmapCompressionHdr ? 0 : 8),
                _pShm->bc.decompBuffer,
                cbCompMainBodySize,
                TRUE,
                (BYTE)bpp,
                (UINT16)bitmapWidth,
                (UINT16)bitmapHeight);

        if (FAILED(hr) || memcmp(pSrcBitmap, _pShm->bc.decompBuffer,cbUncompressedDataSize))
        {
//            TRC_ASSERT(FALSE, (TB, "Decompression failure"));
        }
    }
#endif

#ifdef COMP_STATS
    /************************************************************************/
    /* Work out how long the compression took, in ms.                       */
    /************************************************************************/
    COM_GETTICKCOUNT(ulEndCompTime);
    ulTotalCompTime += (ulEndCompTime - ulStartCompTime) / 10000;
    if (ulTotalCompTime != 0)
        ulCompRate = ulPreCompData / ulTotalCompTime;
#endif

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* Bitmap Compression core code.                                            */
/*                                                                          */
/* A cunning multidimensional RLE compression scheme, particularly suitable */
/* for compressing bitmaps containing captured images of Windows            */
/* applications. For images which use lots of different colors intermixed   */
/* (full-color pictures, etc.) this compression sceme will be inefficient.  */
/*                                                                          */
/* These functions and macros encode a bitmap according to the codes        */
/* defined in abcapi.h.  Although there are some complexities in the        */
/* encoding, the encodings should be self-explanatory. abcapi.h describes   */
/* some nuances of the encoding scheme.                                     */
/****************************************************************************/


/****************************************************************************/
/* Utility macros for encoding orders                                       */
/****************************************************************************/

/****************************************************************************/
/* Encode an order for a standard run                                       */
/****************************************************************************/
#define ENCODE_ORDER_MEGA(buffer,                                            \
                          order_code,                                        \
                          length,                                            \
                          mega_order_code,                                   \
                          DEF_LENGTH_ORDER,                                  \
                          DEF_LENGTH_LONG_ORDER)                             \
    if (length <= DEF_LENGTH_ORDER) {                                        \
        *buffer++ = (BYTE)((BYTE)order_code | (BYTE)length);                 \
    }                                                                        \
    else if (length <= DEF_LENGTH_LONG_ORDER) {                              \
        *buffer++ = (BYTE)order_code;                                        \
        *buffer++ = (BYTE)(length - DEF_LENGTH_ORDER - 1);                   \
    }                                                                        \
    else {                                                                   \
        *buffer++ = (BYTE)mega_order_code;                                   \
        *(PUINT16_UA)(buffer) = (UINT16)length;                              \
        buffer += 2;                                                         \
    }


/****************************************************************************/
/* Encode a special FGBG image                                              */
/****************************************************************************/
#define ENCODE_ORDER_MEGA_FGBG(buffer,                                       \
                          order_code,                                        \
                          length,                                            \
                          mega_order_code,                                   \
                          DEF_LENGTH_ORDER,                                  \
                          DEF_LENGTH_LONG_ORDER)                             \
    if ((length & 0x0007) == 0 && length <= DEF_LENGTH_ORDER) {              \
        *buffer++ = (BYTE)((BYTE)order_code | (BYTE)(length / 8));           \
    }                                                                        \
    else if (length <= DEF_LENGTH_LONG_ORDER) {                              \
        *buffer++ = (BYTE)order_code;                                        \
        *buffer++ = (BYTE)(length-1);                                        \
    }                                                                        \
    else {                                                                   \
        *buffer++ = (BYTE)mega_order_code;                                   \
        *(PUINT16_UA)(buffer) = (UINT16)length;                              \
        buffer += 2;                                                         \
    }


/****************************************************************************/
/* RunSingle                                                                */
/*                                                                          */
/* Determine the length of the current run                                  */
/*                                                                          */
/* RunSingle may only be called if the buffer has at least four             */
/* consecutive identical bytes from the start position                      */
/****************************************************************************/
#define RUNSINGLE(buffer, length, result)                                    \
    {                                                                        \
        BYTE *buf    = buffer + 4;                                           \
        BYTE *endbuf = buffer + length - 4;                                  \
        while (buf < endbuf &&                                               \
                (*(PUINT32_UA)(buf) == *(PUINT32_UA)(buf - 4)))              \
            buf += 4;                                                        \
        endbuf += 4;                                                         \
        while (buf < endbuf && *buf == *(buf - 1))                           \
            buf++;                                                           \
        result = (unsigned)(buf - (buffer));                                 \
    }


/****************************************************************************/
// RunDouble
//
// Determine the length of the current run of dithered bytes. Assumes that
// the dither pattern resides in the first 2 bytes of buffer.
/****************************************************************************/
#define RunDouble(buffer, length, result)                                    \
    {                                                                        \
        int len = ((int)length) - 2;                                         \
        BYTE *buf = (buffer) + 2;                                            \
        UINT16 Pattern = *(PUINT16_UA)(buffer);                              \
        result = 2;                                                          \
        while (len > 1) {                                                    \
            if (*(PUINT16_UA)buf != Pattern)                                 \
                break;                                                       \
            buf += 2;                                                        \
            result += 2;                                                     \
            len    -= 2;                                                     \
        }                                                                    \
    }


/****************************************************************************/
// RUNFGBG
//
// Determine the length of the run of bytes that consist only of black (0x00)
// or a single FG color. We exit the loop when
// - the next character is not a fg or bg color
// - we hit a run of 24 of the FG or BG color
// Example compression calculations:
//   Lookahead   KBytes*   Comp CPU ("hits")
//       24       54846       148497
//       20       54885       151827
//       16       54967       156809
// * = KBytes server->client WinBench98 Graphics WinMark minus CorelDRAW,
//     measured in NetMon on Ethernet.
/****************************************************************************/
#define RUNFGBG(buffer, length, result, work)                                \
    {                                                                        \
        BYTE *buf = buffer;                                                  \
        BYTE *endbuf = buffer + length;                                      \
        result = 0;                                                          \
        work = *buf;                                                         \
        while (TRUE) {                                                       \
            buf++;                                                           \
            result++;                                                        \
            if (buf < endbuf) {                                              \
                if (*buf != work && *buf != 0)                               \
                    break;                                                   \
                                                                             \
                if ((result & 0x0007) == 0) {                                \
                    if ((*buf == *(buf + 1)) &&                              \
                        (*(PUINT16_UA)(buf) == *(PUINT16_UA)(buf + 2)) &&    \
                        (*(PUINT32_UA)(buf) == *(PUINT32_UA)(buf + 4)) &&    \
                        (*(PUINT32_UA)(buf) == *(PUINT32_UA)(buf + 8)) &&    \
                        (*(PUINT32_UA)(buf) == *(PUINT32_UA)(buf + 12)) &&   \
                        (*(PUINT32_UA)(buf) == *(PUINT32_UA)(buf + 16)) &&   \
                        (*(PUINT32_UA)(buf) == *(PUINT32_UA)(buf + 20)))     \
                    {                                                        \
                        break;                                               \
                    }                                                        \
                }                                                            \
            }                                                                \
            else {                                                           \
                break;                                                       \
            }                                                                \
        }                                                                    \
    }


/****************************************************************************/
// Determine whether a run is better than any previous run.
// For efficiency we take the run if over a threshold. Threshold comparisons:
//   Threshold   KBytes*   Comp CPU ("hits")
//       32       54846       148497
//       28       54817       145085
//       24       54825       144366
//       20       54852       143662
//       16       54858       146343
// * = KBytes server->client WinBench98 Graphics WinMark minus CorelDRAW,
//     measured in NetMon on Ethernet.
/****************************************************************************/
#define CHECK_BEST_RUN(run_type, run_length, bestrun_length, bestrun_type)   \
    if (run_length > bestrun_length) {                                       \
        bestrun_length = run_length;                                         \
        bestrun_type = run_type;                                             \
        if (bestrun_length >= 20)                                            \
            break;                                                           \
    }


/****************************************************************************/
/* SETFGCHAR                                                                */
/*                                                                          */
/* Set up a new value in fgChar and recalculate the shift                   */
/****************************************************************************/
#define SETFGCHAR(newchar, curchar, curshift)                                \
     curchar = newchar;                                                      \
     {                                                                       \
         BYTE workchar = curchar;                                            \
         curshift = 0;                                                       \
         while ((workchar & 0x01) == 0) {                                    \
             curshift++;                                                     \
             workchar = (BYTE)(workchar >> 1);                               \
         }                                                                   \
     }


/****************************************************************************/
/* ENCODEFGBG                                                               */
/*                                                                          */
/* Encode 8 bytes of FG and black into a one byte bitmap representation     */
/*                                                                          */
/* The FgChar will always be non-zero, and therefore must have at least one */
/* bit set.                                                                 */
/*                                                                          */
/* We arrange that all bytes have this bit in their lowest position         */
/* The zero pels will still have a 0 in the lowest bit.                     */
/*                                                                          */
/* Getting the result is a 4 stage process                                  */
/*                                                                          */
/*  1) Get the wanted bits into bit 0 of each byte                          */
/*                                                                          */
/*  <***************work1*****************>                                 */
/*  31 0                                                                    */
/*  0000 000d 0000 000c 0000 000b 0000 000a                                 */
/*          ^         ^         ^         ^                                 */
/*  <***************work2*****************>                                 */
/*  31 0                                                                    */
/*  0000 000h 0000 000g 0000 000f 0000 000e                                 */
/*          ^         ^         ^         ^                                 */
/*                                                                          */
/* a..h = bits that we want to output                                       */
/*                                                                          */
/* We just need to collect the indicated bits and squash them into a single */
/* byte.                                                                    */
/*                                                                          */
/*  2) Compress down to 32 bits                                             */
/*                                                                          */
/*  <***************work1*****************>                                 */
/*  31 0                                                                    */
/*  000h 000d 000g 000c 000f 000b 000e 000a                                 */
/*     ^    ^    ^    ^    ^    ^    ^    ^                                 */
/*                                                                          */
/*  3) Compress down to 16 bits                                             */
/*                                                                          */
/*  <******work*******>                                                     */
/*  15 0                                                                    */
/*  0h0f 0d0b 0g0e 0c0a                                                     */
/*   ^ ^  ^ ^  ^ ^  ^ ^                                                     */
/*                                                                          */
/*  4) Compress down to 8 bits                                              */
/*                                                                          */
/*  hgfedcba                                                                */
/****************************************************************************/
#define ENCODEFGBG(result)                                                   \
{                                                                            \
    UINT32 work1;                                                            \
    UINT32 work2;                                                            \
    unsigned work;                                                           \
                                                                             \
    work1 = ((*(PUINT32_UA)(xorbuf + EncodeSrcOffset)) >> fgShift) &         \
            0x01010101;                                                      \
    work2 = ((*(PUINT32_UA)(xorbuf + EncodeSrcOffset + 4)) >> fgShift) &     \
            0x01010101;                                                      \
    work1 = (work2 << 4) | work1;                                            \
    work = work1 | (work1 >> 14);                                            \
    result = ((BYTE)(((BYTE)(work >> 7)) | ((BYTE)work)));                   \
}


#ifndef DC_HICOLOR
/****************************************************************************/
// The following structure contains the results of our intermediate scan of
// the buffer.
/****************************************************************************/
typedef struct {
    unsigned length;
    BYTE     type;
    BYTE     fgChar;
} MATCH;
#endif


/****************************************************************************/
// Critical minimum limit on a run size -- magic number that determines
// color run search characteristics. Minimum is 4 for hard-coded DWORD-size
// checks below. Comparisons of values:
//   MinRunSize  KBytes*   Comp CPU ("hits")
//       4        52487       115842
//       5        52697       115116
//       6        52980       120565
//       7        53306       123680
// * = KBytes server->client WinBench98 Graphics WinMark minus CorelDRAW,
//     measured in NetMon on Ethernet.
/****************************************************************************/
#define MinRunSize 5


/****************************************************************************/
// CompressV2Int
//
// Compresses a bitmap in one call, returning the size of the space used in
// the destination buffer or zero if the buffer was not large enough.
//
// Implementation notes: We use a length-2 array of MATCH elements as a
// running lookbehind buffer, allowing us to combine current run analysis
// results with previous entries before encoding into the destination buffer.
/****************************************************************************/
#ifdef DC_HICOLOR
unsigned RDPCALL SHCLASS CompressV2Int(
        PBYTE pSrc,
        PBYTE pDst,
        unsigned numPels,
        unsigned rowDelta,
        unsigned dstBufferSize,
        BYTE *xorbuf)
{
    unsigned srcOffset;
    unsigned EncodeSrcOffset;
    unsigned bestRunLength;
    unsigned nextRunLength;
    unsigned runLength;
    unsigned bestFGRunLength;
    unsigned scanCount;
    unsigned saveNumPels;
    BOOLEAN inColorRun = FALSE;
    BOOLEAN bEncodeAllMatches;
    BYTE bestRunType = 0;
    BYTE fgPel = 0xFF;
    BYTE fgPelWork = 0xFF;
    BYTE fgShift = 0;
    BYTE EncodeFGPel;
    PBYTE  destbuf = pDst;
    unsigned compressedLength = 0;
    MATCH match[2];

    DC_BEGIN_FN("CompressV2Int");

    /************************************************************************/
    // Validate params.
    /************************************************************************/
    TRC_ASSERT((numPels >= rowDelta),(TB,"numPels < rowDelta"));
    TRC_ASSERT((!(rowDelta & 0x3)),(TB,"rowDelta not multiple of 4"));
    TRC_ASSERT((!(numPels & 0x3)),(TB,"numPels not multiple of 4"));
    TRC_ASSERT((!((UINT_PTR)pSrc & 0x3)),
               (TB, "Possible unaligned access, pSrc = %p", pSrc));

    /************************************************************************/
    // Create XOR buffer - first row is copied from src, succeeding rows
    // are the corresponding src row XOR'd with the next src row.
    /************************************************************************/
    memcpy(xorbuf, pSrc, rowDelta);
    {
        BYTE *srcbuf = pSrc + rowDelta;
        unsigned srclen = numPels - rowDelta;
        UINT32 *dwdest = (UINT32 *)(xorbuf + rowDelta);

        while (srclen >= 8) {
            *dwdest++ = *((PUINT32)srcbuf) ^ *((PUINT32)(srcbuf -
                    (int)rowDelta));
            srcbuf += 4;
            *dwdest++ = *((PUINT32)srcbuf) ^ *((PUINT32)(srcbuf -
                    (int)rowDelta));
            srcbuf += 4;
            srclen -= 8;
        }
        if (srclen) {
            // Since we're 4-byte aligned we can only have a single DWORD
            // remaining.
            *dwdest = *((PUINT32)srcbuf) ^ *((PUINT32)(srcbuf -
                    (int)rowDelta));
        }
    }

    /************************************************************************/
    // Set up encoding state variables.
    /************************************************************************/
    srcOffset = 0;  // Offset in src buf where we are analyzing.
    EncodeSrcOffset = 0;  // Offset in src buf from where we are encoding.
    EncodeFGPel = 0xFF;  // Foreground color for encoding.
    bEncodeAllMatches = FALSE;  // Used to force encoding of all matches.
    match[0].type = 0;  // Initially no match types.
    match[1].type = 0;
    saveNumPels = numPels;
    numPels = rowDelta;

    /************************************************************************/
    // Loop processing the input.
    // We perform the loop twice, the first time for the non-XOR first line
    // of the buffer and the second for the XOR portion, adjusting numPels
    // to the needed value for each pass.
    /************************************************************************/
    for (scanCount = 0; ; scanCount++) {
        while (srcOffset < numPels) {
            /****************************************************************/
            /* Start a while loop to allow a more structured break when we  */
            /* hit the first run type we want to encode (We can't afford    */
            /* the overheads of a function call to provide the scope here.) */
            /****************************************************************/
            while (TRUE) {
                bestRunLength   = 0;
                bestFGRunLength = 0;

                /************************************************************/
                // If we are hitting the end of the buffer then just take
                // color characters now. We will only hit this condition if
                // we break out of a run just before the end of the buffer,
                // so this should not be too common a situation, which is
                // good given that we are encoding the final MinRunSize bytes
                // uncompressed.
                /************************************************************/
                if ((srcOffset + MinRunSize) < numPels) {
                    goto ContinueScan;
                }
                else {
                    bestRunType = IMAGE_COLOR;
                    bestRunLength = numPels - srcOffset;
                    break;
                }
ContinueScan:

                /************************************************************/
                // First do the scans on the XOR buffer. Look for a
                // character run or a BG run.
                // We must do the test independent of how long the run
                // might be because even for a 1 pel BG run our later logic
                // requires that we detect it seperately.  This code is
                // absolute main path so fastpath as much as possible. In
                // particular detect short bg runs early and allow
                // RunSingle to presuppose at least 4 matching bytes.
                /************************************************************/
                if (xorbuf[srcOffset] == 0x00) {
                    if ((srcOffset + 1) >= numPels ||
                            xorbuf[srcOffset + 1] != 0x00) {
                        bestRunType = RUN_BG;
                        bestRunLength = 1;
                        if (!inColorRun)
                            break;
                    }
                    else {
                        if ((srcOffset + 2) >= numPels ||
                                xorbuf[srcOffset + 2] != 0x00) {
                            bestRunType = RUN_BG;
                            bestRunLength = 2;
                            if (!inColorRun)
                                break;
                        }
                        else {
                            if ((srcOffset + 3) >= numPels ||
                                    xorbuf[srcOffset + 3] != 0x00) {
                                bestRunType = RUN_BG;
                                bestRunLength = 3;
                                if (!inColorRun)
                                    break;
                            }
                            else {
                                RUNSINGLE(xorbuf + srcOffset,
                                        numPels - srcOffset,
                                        bestFGRunLength);
                                CHECK_BEST_RUN(RUN_BG,
                                               bestFGRunLength,
                                               bestRunLength,
                                               bestRunType);
                                if (!inColorRun)
                                    break;
                            }
                        }
                    }
                }
                else {
                    /********************************************************/
                    // No point in starting if FG run less than 4 bytes so
                    // check the first dword as quickly as possible.
                    /********************************************************/
                    if (xorbuf[srcOffset] == xorbuf[srcOffset + 1] &&
                            *(PUINT16_UA)(xorbuf + srcOffset) ==
                            *(PUINT16_UA)(xorbuf + srcOffset + 2))
                    {
                        RUNSINGLE(xorbuf+srcOffset,
                                     numPels-srcOffset,
                                     bestFGRunLength);

                        /****************************************************/
                        // Don't permit a short FG run to prevent a FGBG
                        // image from starting up.
                        /****************************************************/
                        if (bestFGRunLength >= MinRunSize) {
                            CHECK_BEST_RUN(RUN_FG,
                                           bestFGRunLength,
                                           bestRunLength,
                                           bestRunType);
                        }
                    }
                }

                /************************************************************/
                // Look for solid or dithered sequences in the normal
                // (non-XOR) buffer.
                /************************************************************/
                if ( (pSrc[srcOffset]     == pSrc[srcOffset + 2]) &&
                     (pSrc[srcOffset + 1] == pSrc[srcOffset + 3])) {
                    /********************************************************/
                    // Now do the scan on the normal buffer for a character
                    // run. Don't bother if first line because we will have
                    // found it already in the XOR buffer, since we just
                    // copy pSrc to xorbuf for the first line. We insist on
                    // a run of at least MinRunSize pixels.
                    /********************************************************/
                    if (*(pSrc + srcOffset) == *(pSrc + srcOffset + 1)) {
                        if (srcOffset >= rowDelta) {
                            RUNSINGLE(pSrc + srcOffset,
                                    numPels - srcOffset,
                                    nextRunLength);
                            if (nextRunLength >= MinRunSize) {
                                CHECK_BEST_RUN(RUN_COLOR,
                                        nextRunLength,
                                        bestRunLength,
                                        bestRunType);
                            }
                        }
                    }
                    else {
                        /****************************************************/
                        // Look for a dither on the nrm buffer. Dithers are
                        // not very efficient for short runs so only take
                        // if 8 or longer. Note that our check against
                        // numPels above for MinRunSize will be overrun here
                        // so we need to make sure we don't go over the
                        // end of the buffer.
                        /****************************************************/
                        if (((numPels - srcOffset) > 8) &&
                                (*(PUINT32_UA)(pSrc + srcOffset) ==
                                *(PUINT32_UA)(pSrc + srcOffset + 4))) {
                            RunDouble(pSrc + srcOffset + 6,
                                    numPels - srcOffset - 6,
                                    nextRunLength);
                            nextRunLength += 6;
                            CHECK_BEST_RUN(RUN_DITHER,
                                    nextRunLength,
                                    bestRunLength,
                                    bestRunType);
                        }
                    }
                }

                /************************************************************/
                // If nothing so far then look for a FGBG run.
                /************************************************************/
                if (bestRunLength < MinRunSize) {
                    // Check this is not a single FG bit breaking up a BG
                    // run. If so then encode a BG_PEL run. Careful of the
                    // enforced BG run break across the first line
                    // non-XOR/XOR boundary.
                    if (*(PUINT32_UA)(xorbuf + srcOffset + 1) != 0 ||
                            *(xorbuf + srcOffset) != fgPel ||
                            match[1].type != RUN_BG ||
                            srcOffset == rowDelta) {
                        // If we have not found a run then look for a FG/BG
                        // image. Bandwidth/CPU comparisons:
                        //   chkFGBGLen*  KBytes**   Comp CPU ("hits")
                        //    48/16/8      54856       140178
                        //    32/16/8      53177       129343
                        //    24/8/8       53020       130583
                        //    16/8/8       52874       126454
                        //    8/8/0        52980       120565
                        //    no check     59753       101091
                        // *  = minimum run length for checking best:
                        //      start val / subtract for workchar==fgPel /
                        //      subtract for nextRunLen divisible by 8
                        // ** = KBytes server->client WinBench98 Graphics
                        //      WinMark minus CorelDRAW, measured in NetMon
                        //      on Ethernet.
                        RUNFGBG(xorbuf + srcOffset, numPels - srcOffset,
                                nextRunLength, fgPelWork);

                        if (fgPelWork == fgPel || nextRunLength >= 8) {
                            CHECK_BEST_RUN(IMAGE_FGBG,
                                           nextRunLength,
                                           bestRunLength,
                                           bestRunType);
                        }
                    }
                    else {
                        RUNSINGLE(xorbuf + srcOffset + 1,
                                numPels - srcOffset - 1,
                                nextRunLength);
                        nextRunLength++;
                        CHECK_BEST_RUN(RUN_BG_PEL,
                                       nextRunLength,
                                       bestRunLength,
                                       bestRunType);
                    }
                }

                /************************************************************/
                /* If nothing useful so far then allow a short run.         */
                /* Don't do this if we are accumulating a color run because */
                /* it will really mess up GDC compression if we allow lots  */
                /* of little runs.  Also require that it is a regular short */
                /* run, rather than one that disturbs the fgPel            */
                /************************************************************/
                if (!inColorRun) {
                    if (bestRunLength < MinRunSize) {
                        if (bestFGRunLength >= MinRunSize &&
                                xorbuf[srcOffset] == fgPel) {
                            /************************************************/
                            /* We mustn't merge with the previous code      */
                            /* if we have just crossed the non-XOR/XOR      */
                            /* boundary.                                    */
                            /************************************************/
                            if (match[1].type == RUN_FG &&
                                    srcOffset != rowDelta) {
                                match[1].length += bestFGRunLength;
                                srcOffset += bestFGRunLength;
                                continue;
                            }
                            else {
                                bestRunLength = bestFGRunLength;
                                bestRunType   = RUN_FG;
                            }
                        }
                        else {
                            /************************************************/
                            /* If we decided to take a run earlier then     */
                            /* allow it now.  (May be a short BG run, for   */
                            /* example) If nothing so far then take color   */
                            /* image)                                       */
                            /************************************************/
                            if (bestRunLength == 0) {
                                bestRunType = IMAGE_COLOR;
                                bestRunLength = 1;
                            }
                        }
                    }
                }
                else {
                    // We're in a color run. Keep small runs of other types
                    // from breaking up the color run and increasing the
                    // encoded size.
                    if (bestRunLength < (unsigned)(bestRunType == RUN_BG ?
                            MinRunSize : (MinRunSize + 2))) {
                        bestRunType = IMAGE_COLOR;
                        bestRunLength = 1;
                    }
                }

                // Get out of the loop after all checks are completed.
                break;
            }

            /****************************************************************/
            /* When we get here we have found the best run.  Now check for  */
            /* various amalgamation conditions with the previous run type.  */
            /* Note that we may already have done amalgamation of short     */
            /* runs, but we had to do multiple samples for the longer runs  */
            /* so we repeat the checks here                                 */
            /****************************************************************/

            /****************************************************************/
            // If we are encoding a color run then combine it with an
            // existing run if possible.
            /****************************************************************/
            if (bestRunType != IMAGE_COLOR) {
                /************************************************************/
                /* We are no longer encoding a COLOR_IMAGE of any kind      */
                /************************************************************/
                inColorRun = FALSE;

                // If we can amalgamate the entry then do so without creating
                // a new array entry. Our search for FGBG runs is dependent
                // upon that type of run being amalgamated because we break
                // every 64 characters so that our mode switch detection
                // works OK.
                //
                // Take care not to merge across the non-xor/xor boundary.
                if (srcOffset != rowDelta) {
                    // Bump srcOffset and try a merge.
                    srcOffset += bestRunLength;

                    switch (bestRunType) {
                        case RUN_BG:
                            // BG runs merge with BG and BG_PEL runs.
                            if (match[1].type == RUN_BG ||
                                    match[1].type == RUN_BG_PEL) {
                                match[1].length += bestRunLength;
                                TRC_DBG((TB, "Merged BG with preceding, "
                                        "giving %u", match[1].length));
                                continue;
                            }

                            // Deliberate fallthrough to BG_PEL.

                        case RUN_BG_PEL:
                            // If it is a BG run following a FGBG run then
                            // merge in the pels to make the FGBG length a
                            // multiple of 8. If the remaining BG run is <= 8
                            // (which would translate to one extra byte in
                            // the previous FGBG as well as one byte of BG),
                            // merge it in also, otherwise just write the
                            // shortened BG run. Note that for RUN_BG_PEL,
                            // FG color will be the same as for the
                            // FGBG, no need to check.
                            if (match[1].type == IMAGE_FGBG &&
                                    match[1].length & 0x0007) {
                                unsigned mergelen = 8 - (match[1].length &
                                        0x0007);

                                if (mergelen > bestRunLength)
                                    mergelen = bestRunLength;
                                match[1].length += mergelen;
                                bestRunLength -= mergelen;
                                TRC_DBG((TB,"Add %u pels to FGBG giving %u "
                                        "leaving %u",
                                        mergelen, match[1].length,
                                        bestRunLength));

                                if (bestRunLength <= 8) {
                                    match[1].length += bestRunLength;
                                    TRC_DBG((TB,"Merge BG with prev FGBG "
                                            "gives %u", match[1].length));
                                    continue;
                                }
                            }

                            break;

                        case RUN_FG:
                            // Keep track of the FG color. Remember to
                            // subtract bestRunLength since we incremented
                            // it before the switch statement.
                            fgPel = xorbuf[srcOffset - bestRunLength];

                            // FG run merges with previous FG if FG color is same.
                            if (match[1].type == RUN_FG &&
                                    match[1].fgPel == fgPel) {
                                match[1].length += bestRunLength;
                                TRC_DBG((TB, "Merged FG with preceding, giving %u",
                                        match[1].length));
                                continue;
                            }

                            break;

                        case IMAGE_FGBG:
                            // FGBG leaves the foreground character in
                            // fgPelWork.
                            fgPel = fgPelWork;

                            // FGBG merges with previous if the FG colors are
                            // the same.
                            if (match[1].type == IMAGE_FGBG &&
                                    match[1].fgPel == fgPel) {
                                match[1].length += bestRunLength;
                                TRC_DBG((TB, "Merged FGBG with preceding "
                                        "FGBG, giving %u", match[1].length));
                                continue;
                            }

                            // FGBG merges with with small BG runs.
                            if (match[1].type == RUN_BG &&
                                    match[1].length < 8) {
                                match[1].type = IMAGE_FGBG;
                                match[1].length += bestRunLength;
                                match[1].fgPel = fgPel;
                                TRC_DBG((TB, "Merged FGBG with preceding "
                                        "BG run -> %u", match[1].length));
                                continue;
                            }

                            break;
                    }
                }
                else {
                    // Keep track of the FG color. The macro that searches for
                    // FGBG runs leaves the character in fgPelWork.
                    // Note this code is inlined into the merging code
                    // before.
                    if (bestRunType == RUN_FG)
                        fgPel = xorbuf[srcOffset];
                    else if (bestRunType == IMAGE_FGBG)
                        fgPel = fgPelWork;

                    // We're at the end of the first line. Just bump the
                    // source offset.
                    srcOffset += bestRunLength;
                }
            }
            else {
                /************************************************************/
                /* Flag that we are within a color run                      */
                /************************************************************/
                inColorRun = TRUE;

                srcOffset += bestRunLength;

                /************************************************************/
                // Merge the color run immediately, if possible. Note color
                // runs are not restricted by the non-XOR/XOR boundary.
                /************************************************************/
                if (match[1].type == IMAGE_COLOR) {
                    match[1].length += bestRunLength;
                    continue;
                }
                if (match[0].type == IMAGE_COLOR && match[1].length == 1) {
                    // If it is a color run spanning any kind of single pel
                    // entity then merge all three runs into one.
                    // We have to create a special match queue condition
                    // here -- the single merged entry needs to be placed
                    // in the match[1] position and a null entry into [0]
                    // to allow the rest of the code to continue to
                    // be hardcoded to merge with [1].
                    match[1].length = match[0].length +
                            bestRunLength + 1;
                    match[1].type = IMAGE_COLOR;
                    match[0].type = 0;

                    TRC_DBG((TB, "Merged color with preceding color gives %u",
                            match[1].length));
                    continue;
                }
            }

            /****************************************************************/
            // The current run could not be merged with a previous match
            // queue entry, We have to encode the [0] slot then add the
            // current run the the queue.
            /****************************************************************/
            TRC_DBG((TB, "Best run of type %u has length %u", bestRunType,
                    bestRunLength));

DoEncoding:

            // First check for our approaching the end of the destination
            // buffer and get out if this is the case. We allow for the
            // largest general run order (a mega-mega set run = 4 bytes).
            // Orders which may be larger are checked within the case arm
            if ((unsigned)(destbuf - pDst + 4) <= dstBufferSize)
                goto ContinueEncoding;
            else
                DC_QUIT;
ContinueEncoding:

            switch (match[0].type) {
                case 0:
                    // Unused entry.
                    break;

                case RUN_BG:
                case RUN_BG_PEL:
                    // Note that for BG_PEL we utilize the code sequence
                    // BG,BG which would not otherwise appear as a special
                    // case meaning insert one current FG char between
                    // the two runs.
                    ENCODE_ORDER_MEGA(destbuf,
                                      CODE_BG_RUN,
                                      match[0].length,
                                      CODE_MEGA_MEGA_BG_RUN,
                                      MAX_LENGTH_ORDER,
                                      MAX_LENGTH_LONG_ORDER);
                    TRC_DBG((TB, "BG RUN %u",match[0].length));
                    EncodeSrcOffset += match[0].length;
                    break;

                case RUN_FG:
                    // If the fg value is different from the current
                    // then encode a set+run code.
                    if (EncodeFGPel != match[0].fgPel) {
                        SETFGCHAR((BYTE)match[0].fgPel, EncodeFGPel, fgShift);
                        ENCODE_ORDER_MEGA(destbuf,
                                          CODE_SET_FG_FG_RUN,
                                          match[0].length,
                                          CODE_MEGA_MEGA_SET_FG_RUN,
                                          MAX_LENGTH_ORDER_LITE,
                                          MAX_LENGTH_LONG_ORDER_LITE);
                        *destbuf++ = EncodeFGPel;
                        TRC_DBG((TB, "SET_FG_FG_RUN %u", match[0].length));
                    }
                    else {
                        ENCODE_ORDER_MEGA(destbuf,
                                          CODE_FG_RUN,
                                          match[0].length,
                                          CODE_MEGA_MEGA_FG_RUN,
                                          MAX_LENGTH_ORDER,
                                          MAX_LENGTH_LONG_ORDER);
                        TRC_DBG((TB, "FG_RUN %u", match[0].length));
                    }
                    EncodeSrcOffset += match[0].length;
                    break;

                case IMAGE_FGBG:
                    runLength = match[0].length;

                    // Check for our approaching the end of the destination
                    // buffer and get out if this is the case.
                    if ((destbuf - pDst + (runLength + 7)/8 + 4) <=
                            dstBufferSize)
                        goto ContinueFGBG;
                    else
                        DC_QUIT;
    ContinueFGBG:

                    // We need to convert FGBG runs into the pixel form.
                    if (EncodeFGPel != match[0].fgPel) {
                        SETFGCHAR((BYTE)match[0].fgPel, EncodeFGPel, fgShift);
                        ENCODE_ORDER_MEGA_FGBG(destbuf,
                                               CODE_SET_FG_FG_BG,
                                               runLength,
                                               CODE_MEGA_MEGA_SET_FGBG,
                                               MAX_LENGTH_FGBG_ORDER_LITE,
                                               MAX_LENGTH_LONG_FGBG_ORDER);
                        *destbuf++ = EncodeFGPel;
                        TRC_DBG((TB, "SET_FG_FG_BG %u", match[0].length));
                        while (runLength >= 8) {
                            ENCODEFGBG(*destbuf);
                            destbuf++;
                            EncodeSrcOffset += 8;
                            runLength -= 8;
                        }
                        if (runLength) {
                            ENCODEFGBG(*destbuf);

                            // Keep the final partial byte clean to help GDC
                            // packing.
                            *destbuf &= ((0x01 << runLength) - 1);
                            destbuf++;
                            EncodeSrcOffset += runLength;
                        }
                    }
                    else {
                        if (runLength == 8) {
                            BYTE fgbgChar;

                            // See if it is one of the high probability bytes.
                            ENCODEFGBG(fgbgChar);

                            // Check for single byte encoding of FGBG images.
                            switch (fgbgChar) {
                                case SPECIAL_FGBG_CODE_1:
                                    *destbuf++ = CODE_SPECIAL_FGBG_1;
                                    break;
                                case SPECIAL_FGBG_CODE_2:
                                    *destbuf++ = CODE_SPECIAL_FGBG_2;
                                    break;
                                default:
                                    ENCODE_ORDER_MEGA_FGBG(destbuf,
                                            CODE_FG_BG_IMAGE,
                                            runLength,
                                            CODE_MEGA_MEGA_FGBG,
                                            MAX_LENGTH_FGBG_ORDER,
                                            MAX_LENGTH_LONG_FGBG_ORDER);
                                    *destbuf++ = fgbgChar;
                                    break;
                            }
                            EncodeSrcOffset += 8;
                        }
                        else {
                            // Encode as standard FGBG.
                            ENCODE_ORDER_MEGA_FGBG(destbuf,
                                                   CODE_FG_BG_IMAGE,
                                                   runLength,
                                                   CODE_MEGA_MEGA_FGBG,
                                                   MAX_LENGTH_FGBG_ORDER,
                                                   MAX_LENGTH_LONG_FGBG_ORDER);
                            TRC_DBG((TB, "FG_BG %u", match[0].length));
                            while (runLength >= 8) {
                                ENCODEFGBG(*destbuf);
                                destbuf++;
                                EncodeSrcOffset += 8;
                                runLength -= 8;
                            }
                            if (runLength) {
                                ENCODEFGBG(*destbuf);
                                *destbuf &= ((0x01 << runLength) - 1);
                                destbuf++;
                                EncodeSrcOffset += runLength;
                            }
                        }
                    }
                    break;


                case RUN_COLOR:
                    ENCODE_ORDER_MEGA(destbuf,
                                      CODE_COLOR_RUN,
                                      match[0].length,
                                      CODE_MEGA_MEGA_COLOR_RUN,
                                      MAX_LENGTH_ORDER,
                                      MAX_LENGTH_LONG_ORDER);
                    TRC_DBG((TB, "COLOR_RUN %u", match[0].length));
                    *destbuf++ = pSrc[EncodeSrcOffset];
                    EncodeSrcOffset += match[0].length;
                    break;

                case RUN_DITHER:
                    {
                        unsigned ditherlen = match[0].length / 2;
                        ENCODE_ORDER_MEGA(destbuf,
                                          CODE_DITHERED_RUN,
                                          ditherlen,
                                          CODE_MEGA_MEGA_DITHER,
                                          MAX_LENGTH_ORDER_LITE,
                                          MAX_LENGTH_LONG_ORDER_LITE);
                        TRC_DBG((TB, "DITHERED_RUN %u", match[0].length));

                        // First check for our approaching the end of the
                        // destination buffer and get out if this is the case.
                        if ((unsigned)(destbuf - pDst + 2) <= dstBufferSize) {
                            *destbuf++ = pSrc[EncodeSrcOffset];
                            *destbuf++ = pSrc[EncodeSrcOffset + 1];
                            EncodeSrcOffset += match[0].length;
                        }
                        else {
                            DC_QUIT;
                        }
                    }
                    break;

                case IMAGE_COLOR:
                    // Length 1 can possibly be encoded as a single BLACK/WHITE.
                    if (match[0].length == 1) {
                        if (pSrc[EncodeSrcOffset] == 0x00) {
                            *destbuf++ = CODE_BLACK;
                            EncodeSrcOffset++;
                            break;
                        }
                        if (pSrc[EncodeSrcOffset] == 0xFF) {
                            *destbuf++ = CODE_WHITE;
                            EncodeSrcOffset++;
                            break;
                        }
                    }

                    // Store the data in non-compressed form.
                    ENCODE_ORDER_MEGA(destbuf,
                                      CODE_COLOR_IMAGE,
                                      match[0].length,
                                      CODE_MEGA_MEGA_CLR_IMG,
                                      MAX_LENGTH_ORDER,
                                      MAX_LENGTH_LONG_ORDER);
                    TRC_DBG((TB, "COLOR_IMAGE %u", match[0].length));

                    // First check for our approaching the end of the
                    // destination buffer and get out if this is the case.
                    if ((destbuf - pDst + (UINT_PTR)match[0].length) <=
                            dstBufferSize) {
                        // Now just copy the data over.
                        memcpy(destbuf, pSrc+EncodeSrcOffset, match[0].length);
                        destbuf += match[0].length;
                        EncodeSrcOffset += match[0].length;
                    }
                    else {
                        DC_QUIT;
                    }

                    break;

#ifdef DC_DEBUG
                default:
                    TRC_ERR((TB, "Invalid run type %u",match[0].type));
                    break;
#endif
            }

            /****************************************************************/
            // Done encoding, what we do next is determined by whether we're
            // flushing the match queue after everything is scanned.
            /****************************************************************/
            match[0] = match[1];
            if (!bEncodeAllMatches) {
                // Push the current run into the top of the queue.
                match[1].type   = bestRunType;
                match[1].length = bestRunLength;
                match[1].fgPel = fgPel;
            }
            else {
                // We need to check to see if we're really finished. Since
                // our maximum queue depth is 2, if we're done then the only
                // remaining entry has an encoding type of 0.
                if (match[0].type == 0) {
                    goto PostScan;
                }
                else {
                    match[1].type = 0;
                    goto DoEncoding;
                }
            }
        }

        if (scanCount == 0) {
            // If we have just done our scan of the first line then now do the
            // rest of the buffer.  Reset our saved pel count.
            numPels = saveNumPels;
        }
        else {
            // When we are done with the second pass (we've reached the end of
            // the buffer) we have to force the remaining items in the match
            // queue to be encoded. Yes this is similar to old BASIC
            // code in using gotos, but we cannot place the encoding code into
            // a function because of the number of params required, and
            // we cannot duplicate it because it is too big. This code is
            // some of the most used in the system so the cost is worth it.
            bEncodeAllMatches = TRUE;
            goto DoEncoding;
        }
    }

PostScan:
    // Success, calculate the amount of space we used.
    compressedLength = (unsigned)(destbuf - pDst);

DC_EXIT_POINT:
    DC_END_FN();
    return compressedLength;
}
#else
unsigned RDPCALL SHCLASS CompressV2Int(
        PBYTE pSrc,
        PBYTE pDst,
        unsigned numPels,
        unsigned rowDelta,
        unsigned dstBufferSize,
        BYTE *xorbuf)
{
    unsigned srcOffset;
    unsigned EncodeSrcOffset;
    unsigned bestRunLength;
    unsigned nextRunLength;
    unsigned runLength;
    unsigned bestFGRunLength;
    unsigned scanCount;
    unsigned saveNumPels;
    BOOLEAN inColorRun = FALSE;
    BOOLEAN bEncodeAllMatches;
    BYTE bestRunType = 0;
    BYTE fgChar = 0xFF;
    BYTE fgCharWork = 0xFF;
    BYTE fgShift = 0;
    BYTE EncodeFGChar;
    PBYTE  destbuf = pDst;
    unsigned compressedLength = 0;
    MATCH match[2];

    DC_BEGIN_FN("CompressV2Int");

    /************************************************************************/
    // Validate params.
    /************************************************************************/
    TRC_ASSERT((numPels >= rowDelta),(TB,"numPels < rowDelta"));
    TRC_ASSERT((!(rowDelta & 0x3)),(TB,"rowDelta not multiple of 4"));
    TRC_ASSERT((!(numPels & 0x3)),(TB,"numPels not multiple of 4"));
    TRC_ASSERT((!((UINT_PTR)pSrc & 0x3)),
               (TB, "Possible unaligned access, pSrc = %p", pSrc));

    /************************************************************************/
    // Create XOR buffer - first row is copied from src, succeeding rows
    // are the corresponding src row XOR'd with the next src row.
    /************************************************************************/
    memcpy(xorbuf, pSrc, rowDelta);
    {
        BYTE *srcbuf = pSrc + rowDelta;
        unsigned srclen = numPels - rowDelta;
        UINT32 *dwdest = (UINT32 *)(xorbuf + rowDelta);

        while (srclen >= 8) {
            *dwdest++ = *((PUINT32)srcbuf) ^ *((PUINT32)(srcbuf -
                    (int)rowDelta));
            srcbuf += 4;
            *dwdest++ = *((PUINT32)srcbuf) ^ *((PUINT32)(srcbuf -
                    (int)rowDelta));
            srcbuf += 4;
            srclen -= 8;
        }
        if (srclen) {
            // Since we're 4-byte aligned we can only have a single DWORD
            // remaining.
            *dwdest = *((PUINT32)srcbuf) ^ *((PUINT32)(srcbuf -
                    (int)rowDelta));
        }
    }

    /************************************************************************/
    // Set up encoding state variables.
    /************************************************************************/
    srcOffset = 0;  // Offset in src buf where we are analyzing.
    EncodeSrcOffset = 0;  // Offset in src buf from where we are encoding.
    EncodeFGChar = 0xFF;  // Foreground color for encoding.
    bEncodeAllMatches = FALSE;  // Used to force encoding of all matches.
    match[0].type = 0;  // Initially no match types.
    match[1].type = 0;
    saveNumPels = numPels;
    numPels = rowDelta;

    /************************************************************************/
    // Loop processing the input.
    // We perform the loop twice, the first time for the non-XOR first line
    // of the buffer and the second for the XOR portion, adjusting numPels
    // to the needed value for each pass.
    /************************************************************************/
    for (scanCount = 0; ; scanCount++) {
        while (srcOffset < numPels) {
            /****************************************************************/
            /* Start a while loop to allow a more structured break when we  */
            /* hit the first run type we want to encode (We can't afford    */
            /* the overheads of a function call to provide the scope here.) */
            /****************************************************************/
            while (TRUE) {
                bestRunLength   = 0;
                bestFGRunLength = 0;

                /************************************************************/
                // If we are hitting the end of the buffer then just take
                // color characters now. We will only hit this condition if
                // we break out of a run just before the end of the buffer,
                // so this should not be too common a situation, which is
                // good given that we are encoding the final MinRunSize bytes
                // uncompressed.
                /************************************************************/
                if ((srcOffset + MinRunSize) < numPels) {
                    goto ContinueScan;
                }
                else {
                    bestRunType = IMAGE_COLOR;
                    bestRunLength = numPels - srcOffset;
                    break;
                }
ContinueScan:

                /************************************************************/
                // First do the scans on the XOR buffer. Look for a
                // character run or a BG run.
                // We must do the test independent of how long the run
                // might be because even for a 1 pel BG run our later logic
                // requires that we detect it seperately.  This code is
                // absolute main path so fastpath as much as possible. In
                // particular detect short bg runs early and allow
                // RunSingle to presuppose at least 4 matching bytes.
                /************************************************************/
                if (xorbuf[srcOffset] == 0x00) {
                    if ((srcOffset + 1) >= numPels ||
                            xorbuf[srcOffset + 1] != 0x00) {
                        bestRunType = RUN_BG;
                        bestRunLength = 1;
                        if (!inColorRun)
                            break;
                    }
                    else {
                        if ((srcOffset + 2) >= numPels ||
                                xorbuf[srcOffset + 2] != 0x00) {
                            bestRunType = RUN_BG;
                            bestRunLength = 2;
                            if (!inColorRun)
                                break;
                        }
                        else {
                            if ((srcOffset + 3) >= numPels ||
                                    xorbuf[srcOffset + 3] != 0x00) {
                                bestRunType = RUN_BG;
                                bestRunLength = 3;
                                if (!inColorRun)
                                    break;
                            }
                            else {
                                RUNSINGLE(xorbuf + srcOffset,
                                        numPels - srcOffset,
                                        bestFGRunLength);
                                CHECK_BEST_RUN(RUN_BG,
                                               bestFGRunLength,
                                               bestRunLength,
                                               bestRunType);
                                if (!inColorRun)
                                    break;
                            }
                        }
                    }
                }
                else {
                    /********************************************************/
                    // No point in starting if FG run less than 4 bytes so
                    // check the first dword as quickly as possible.
                    /********************************************************/
                    if (xorbuf[srcOffset] == xorbuf[srcOffset + 1] &&
                            *(PUINT16_UA)(xorbuf + srcOffset) ==
                            *(PUINT16_UA)(xorbuf + srcOffset + 2))
                    {
                        RUNSINGLE(xorbuf + srcOffset,
                                numPels - srcOffset,
                                bestFGRunLength);

                        /****************************************************/
                        // Don't permit a short FG run to prevent a FGBG
                        // image from starting up.
                        /****************************************************/
                        if (bestFGRunLength >= MinRunSize) {
                            CHECK_BEST_RUN(RUN_FG,
                                    bestFGRunLength,
                                    bestRunLength,
                                    bestRunType);
                        }
                    }
                }

                /************************************************************/
                // Look for solid or dithered sequences in the normal
                // (non-XOR) buffer.
                /************************************************************/
                if ( (pSrc[srcOffset]     == pSrc[srcOffset + 2]) &&
                     (pSrc[srcOffset + 1] == pSrc[srcOffset + 3])) {
                    /********************************************************/
                    // Now do the scan on the normal buffer for a character
                    // run. Don't bother if first line because we will have
                    // found it already in the XOR buffer, since we just
                    // copy pSrc to xorbuf for the first line. We insist on
                    // a run of at least MinRunSize pixels.
                    /********************************************************/
                    if (*(pSrc + srcOffset) == *(pSrc + srcOffset + 1)) {
                        if (srcOffset >= rowDelta) {
                            RUNSINGLE(pSrc + srcOffset,
                                         numPels - srcOffset,
                                         nextRunLength);
                            if (nextRunLength >= MinRunSize) {
                                CHECK_BEST_RUN(RUN_COLOR,
                                               nextRunLength,
                                               bestRunLength,
                                               bestRunType);
                            }
                        }
                    }
                    else {
                        /****************************************************/
                        /* Look for a dither on the nrm buffer Dithers are  */
                        /* not very efficient for short runs so only take   */
                        /* if 8 or longer                                   */
                        /****************************************************/
                        if (*(PUINT32_UA)(pSrc + srcOffset) ==
                                *(PUINT32_UA)(pSrc + srcOffset + 4)) {
                            RunDouble(pSrc + srcOffset + 6,
                                      numPels - srcOffset - 6,
                                      nextRunLength);
                            nextRunLength += 6;
                            CHECK_BEST_RUN(RUN_DITHER,
                                           nextRunLength,
                                           bestRunLength,
                                           bestRunType);
                        }
                    }
                }

                /************************************************************/
                // If nothing so far then look for a FGBG run.
                /************************************************************/
                if (bestRunLength < MinRunSize) {
                    // Check this is not a single FG bit breaking up a BG
                    // run. If so then encode a BG_PEL run. Careful of the
                    // enforced BG run break across the first line
                    // non-XOR/XOR boundary.
                    if (*(PUINT32_UA)(xorbuf + srcOffset + 1) != 0 ||
                            *(xorbuf + srcOffset) != fgChar ||
                            match[1].type != RUN_BG ||
                            srcOffset == rowDelta) {
                        // If we have not found a run then look for a FG/BG
                        // image. Bandwidth/CPU comparisons:
                        //   chkFGBGLen*  KBytes**   Comp CPU ("hits")
                        //    48/16/8      54856       140178
                        //    32/16/8      53177       129343
                        //    24/8/8       53020       130583
                        //    16/8/8       52874       126454
                        //    8/8/0        52980       120565
                        //    no check     59753       101091
                        // *  = minimum run length for checking best:
                        //      start val / subtract for workchar==fgChar /
                        //      subtract for nextRunLen divisible by 8
                        // ** = KBytes server->client WinBench98 Graphics
                        //      WinMark minus CorelDRAW, measured in NetMon
                        //      on Ethernet.
                        RUNFGBG(xorbuf + srcOffset, numPels - srcOffset,
                                nextRunLength, fgCharWork);

                        if (fgCharWork == fgChar || nextRunLength >= 8) {
                            CHECK_BEST_RUN(IMAGE_FGBG,
                                           nextRunLength,
                                           bestRunLength,
                                           bestRunType);
                        }
                    }
                    else {
                        RUNSINGLE(xorbuf + srcOffset + 1,
                                numPels - srcOffset - 1,
                                nextRunLength);
                        nextRunLength++;
                        CHECK_BEST_RUN(RUN_BG_PEL,
                                       nextRunLength,
                                       bestRunLength,
                                       bestRunType);
                    }
                }

                /************************************************************/
                /* If nothing useful so far then allow a short run.         */
                /* Don't do this if we are accumulating a color run because */
                /* it will really mess up GDC compression if we allow lots  */
                /* of little runs.  Also require that it is a regular short */
                /* run, rather than one that disturbs the fgChar            */
                /************************************************************/
                if (!inColorRun) {
                    if (bestRunLength < MinRunSize) {
                        if (bestFGRunLength >= MinRunSize &&
                                xorbuf[srcOffset] == fgChar) {
                            /************************************************/
                            /* We mustn't merge with the previous code      */
                            /* if we have just crossed the non-XOR/XOR      */
                            /* boundary.                                    */
                            /************************************************/
                            if (match[1].type == RUN_FG &&
                                    srcOffset != rowDelta) {
                                match[1].length += bestFGRunLength;
                                srcOffset += bestFGRunLength;
                                continue;
                            }
                            else {
                                bestRunLength = bestFGRunLength;
                                bestRunType   = RUN_FG;
                            }
                        }
                        else {
                            /************************************************/
                            /* If we decided to take a run earlier then     */
                            /* allow it now.  (May be a short BG run, for   */
                            /* example) If nothing so far then take color   */
                            /* image)                                       */
                            /************************************************/
                            if (bestRunLength == 0) {
                                bestRunType = IMAGE_COLOR;
                                bestRunLength = 1;
                            }
                        }
                    }
                }
                else {
                    // We're in a color run. Keep small runs of other types
                    // from breaking up the color run and increasing the
                    // encoded size.
                    if (bestRunLength < (unsigned)(bestRunType == RUN_BG ?
                            MinRunSize : (MinRunSize + 2))) {
                        bestRunType = IMAGE_COLOR;
                        bestRunLength = 1;
                    }
                }

                // Get out of the loop after all checks are completed.
                break;
            }

            /****************************************************************/
            /* When we get here we have found the best run.  Now check for  */
            /* various amalgamation conditions with the previous run type.  */
            /* Note that we may already have done amalgamation of short     */
            /* runs, but we had to do multiple samples for the longer runs  */
            /* so we repeat the checks here                                 */
            /****************************************************************/

            /****************************************************************/
            // If we are encoding a color run then combine it with an
            // existing run if possible.
            /****************************************************************/
            if (bestRunType != IMAGE_COLOR) {
                /************************************************************/
                /* We are no longer encoding a COLOR_IMAGE of any kind      */
                /************************************************************/
                inColorRun = FALSE;

                // If we can amalgamate the entry then do so without creating
                // a new array entry. Our search for FGBG runs is dependent
                // upon that type of run being amalgamated because we break
                // every 64 characters so that our mode switch detection
                // works OK.
                //
                // Take care not to merge across the non-xor/xor boundary.
                if (srcOffset != rowDelta) {
                    // Bump srcOffset and try a merge.
                    srcOffset += bestRunLength;

                    switch (bestRunType) {
                        case RUN_BG:
                            // BG runs merge with BG and BG_PEL runs.
                            if (match[1].type == RUN_BG ||
                                    match[1].type == RUN_BG_PEL) {
                                match[1].length += bestRunLength;
                                TRC_DBG((TB, "Merged BG with preceding, "
                                        "giving %u", match[1].length));
                                continue;
                            }

                            // Deliberate fallthrough to BG_PEL.

                        case RUN_BG_PEL:
                            // If it is a BG run following a FGBG run then
                            // merge in the pels to make the FGBG length a
                            // multiple of 8. If the remaining BG run is <= 8
                            // (which would translate to one extra byte in
                            // the previous FGBG as well as one byte of BG),
                            // merge it in also, otherwise just write the
                            // shortened BG run. Note that for RUN_BG_PEL,
                            // FG color will be the same as for the
                            // FGBG, no need to check.
                            if (match[1].type == IMAGE_FGBG &&
                                    match[1].length & 0x0007) {
                                unsigned mergelen = 8 - (match[1].length &
                                        0x0007);

                                if (mergelen > bestRunLength)
                                    mergelen = bestRunLength;
                                match[1].length += mergelen;
                                bestRunLength -= mergelen;
                                TRC_DBG((TB,"Add %u pels to FGBG giving %u "
                                        "leaving %u",
                                        mergelen, match[1].length,
                                        bestRunLength));

                                if (bestRunLength <= 8) {
                                    match[1].length += bestRunLength;
                                    TRC_DBG((TB,"Merge BG with prev FGBG "
                                            "gives %u", match[1].length));
                                    continue;
                                }
                            }

                            break;

                        case RUN_FG:
                            // Keep track of the FG color. Remember to
                            // subtract bestRunLength since we incremented
                            // it before the switch statement.
                            fgChar = xorbuf[srcOffset - bestRunLength];

                            // FG run merges with previous FG if FG color is same.
                            if (match[1].type == RUN_FG &&
                                    match[1].fgChar == fgChar) {
                                match[1].length += bestRunLength;
                                TRC_DBG((TB, "Merged FG with preceding, giving %u",
                                        match[1].length));
                                continue;
                            }

                            break;

                        case IMAGE_FGBG:
                            // FGBG leaves the foreground character in
                            // fgCharWork.
                            fgChar = fgCharWork;

                            // FGBG merges with previous if the FG colors are
                            // the same.
                            if (match[1].type == IMAGE_FGBG &&
                                    match[1].fgChar == fgChar) {
                                match[1].length += bestRunLength;
                                TRC_DBG((TB, "Merged FGBG with preceding "
                                        "FGBG, giving %u", match[1].length));
                                continue;
                            }

                            // FGBG merges with with small BG runs.
                            if (match[1].type == RUN_BG &&
                                    match[1].length < 8) {
                                match[1].type = IMAGE_FGBG;
                                match[1].length += bestRunLength;
                                match[1].fgChar = fgChar;
                                TRC_DBG((TB, "Merged FGBG with preceding "
                                        "BG run -> %u", match[1].length));
                                continue;
                            }

                            break;
                    }
                }
                else {
                    // Keep track of the FG color. The macro that searches for
                    // FGBG runs leaves the character in fgCharWork.
                    // Note this code is inlined into the merging code
                    // before.
                    if (bestRunType == RUN_FG)
                        fgChar = xorbuf[srcOffset];
                    else if (bestRunType == IMAGE_FGBG)
                        fgChar = fgCharWork;

                    // We're at the end of the first line. Just bump the
                    // source offset.
                    srcOffset += bestRunLength;
                }
            }
            else {
                /************************************************************/
                /* Flag that we are within a color run                      */
                /************************************************************/
                inColorRun = TRUE;

                srcOffset += bestRunLength;

                /************************************************************/
                // Merge the color run immediately, if possible. Note color
                // runs are not restricted by the non-XOR/XOR boundary.
                /************************************************************/
                if (match[1].type == IMAGE_COLOR) {
                    match[1].length += bestRunLength;
                    continue;
                }
                if (match[0].type == IMAGE_COLOR && match[1].length == 1) {
                    // If it is a color run spanning any kind of single pel
                    // entity then merge all three runs into one.
                    // We have to create a special match queue condition
                    // here -- the single merged entry needs to be placed
                    // in the match[1] position and a null entry into [0]
                    // to allow the rest of the code to continue to
                    // be hardcoded to merge with [1].
                    match[1].length = match[0].length +
                            bestRunLength + 1;
                    match[1].type = IMAGE_COLOR;
                    match[0].type = 0;

                    TRC_DBG((TB, "Merged color with preceding color gives %u",
                            match[1].length));
                    continue;
                }
            }

            /****************************************************************/
            // The current run could not be merged with a previous match
            // queue entry, We have to encode the [0] slot then add the
            // current run the the queue.
            /****************************************************************/
            TRC_DBG((TB, "Best run of type %u has length %u", bestRunType,
                    bestRunLength));

DoEncoding:

            // First check for our approaching the end of the destination
            // buffer and get out if this is the case. We allow for the
            // largest general run order (a mega-mega set run = 4 bytes).
            // Orders which may be larger are checked within the case arm
            if ((unsigned)(destbuf - pDst + 4) <= dstBufferSize)
                goto ContinueEncoding;
            else
                DC_QUIT;
ContinueEncoding:

            switch (match[0].type) {
                case 0:
                    // Unused entry.
                    break;

                case RUN_BG:
                case RUN_BG_PEL:
                    // Note that for BG_PEL we utilize the code sequence
                    // BG,BG which would not otherwise appear as a special
                    // case meaning insert one current FG char between
                    // the two runs.
                    ENCODE_ORDER_MEGA(destbuf,
                                      CODE_BG_RUN,
                                      match[0].length,
                                      CODE_MEGA_MEGA_BG_RUN,
                                      MAX_LENGTH_ORDER,
                                      MAX_LENGTH_LONG_ORDER);
                    TRC_DBG((TB, "BG RUN %u",match[0].length));
                    EncodeSrcOffset += match[0].length;
                    break;

                case RUN_FG:
                    // If the fg value is different from the current
                    // then encode a set+run code.
                    if (EncodeFGChar != match[0].fgChar) {
                        SETFGCHAR(match[0].fgChar, EncodeFGChar, fgShift);
                        ENCODE_ORDER_MEGA(destbuf,
                                          CODE_SET_FG_FG_RUN,
                                          match[0].length,
                                          CODE_MEGA_MEGA_SET_FG_RUN,
                                          MAX_LENGTH_ORDER_LITE,
                                          MAX_LENGTH_LONG_ORDER_LITE);
                        *destbuf++ = EncodeFGChar;
                        TRC_DBG((TB, "SET_FG_FG_RUN %u", match[0].length));
                    }
                    else {
                        ENCODE_ORDER_MEGA(destbuf,
                                          CODE_FG_RUN,
                                          match[0].length,
                                          CODE_MEGA_MEGA_FG_RUN,
                                          MAX_LENGTH_ORDER,
                                          MAX_LENGTH_LONG_ORDER);
                        TRC_DBG((TB, "FG_RUN %u", match[0].length));
                    }
                    EncodeSrcOffset += match[0].length;
                    break;

                case IMAGE_FGBG:
                    runLength = match[0].length;

                    // Check for our approaching the end of the destination
                    // buffer and get out if this is the case.
                    if ((destbuf - pDst + (runLength + 7)/8 + 4) <=
                            dstBufferSize)
                        goto ContinueFGBG;
                    else
                        DC_QUIT;
    ContinueFGBG:

                    // We need to convert FGBG runs into the pixel form.
                    if (EncodeFGChar != match[0].fgChar) {
                        SETFGCHAR(match[0].fgChar, EncodeFGChar, fgShift);
                        ENCODE_ORDER_MEGA_FGBG(destbuf,
                                               CODE_SET_FG_FG_BG,
                                               runLength,
                                               CODE_MEGA_MEGA_SET_FGBG,
                                               MAX_LENGTH_FGBG_ORDER_LITE,
                                               MAX_LENGTH_LONG_FGBG_ORDER);
                        *destbuf++ = EncodeFGChar;
                        TRC_DBG((TB, "SET_FG_FG_BG %u", match[0].length));
                        while (runLength >= 8) {
                            ENCODEFGBG(*destbuf);
                            destbuf++;
                            EncodeSrcOffset += 8;
                            runLength -= 8;
                        }
                        if (runLength) {
                            ENCODEFGBG(*destbuf);

                            // Keep the final partial byte clean to help GDC
                            // packing.
                            *destbuf &= ((0x01 << runLength) - 1);
                            destbuf++;
                            EncodeSrcOffset += runLength;
                        }
                    }
                    else {
                        if (runLength == 8) {
                            BYTE fgbgChar;

                            // See if it is one of the high probability bytes.
                            ENCODEFGBG(fgbgChar);

                            // Check for single byte encoding of FGBG images.
                            switch (fgbgChar) {
                                case SPECIAL_FGBG_CODE_1:
                                    *destbuf++ = CODE_SPECIAL_FGBG_1;
                                    break;
                                case SPECIAL_FGBG_CODE_2:
                                    *destbuf++ = CODE_SPECIAL_FGBG_2;
                                    break;
                                default:
                                    ENCODE_ORDER_MEGA_FGBG(destbuf,
                                            CODE_FG_BG_IMAGE,
                                            runLength,
                                            CODE_MEGA_MEGA_FGBG,
                                            MAX_LENGTH_FGBG_ORDER,
                                            MAX_LENGTH_LONG_FGBG_ORDER);
                                    *destbuf++ = fgbgChar;
                                    break;
                            }
                            EncodeSrcOffset += 8;
                        }
                        else {
                            // Encode as standard FGBG.
                            ENCODE_ORDER_MEGA_FGBG(destbuf,
                                                   CODE_FG_BG_IMAGE,
                                                   runLength,
                                                   CODE_MEGA_MEGA_FGBG,
                                                   MAX_LENGTH_FGBG_ORDER,
                                                   MAX_LENGTH_LONG_FGBG_ORDER);
                            TRC_DBG((TB, "FG_BG %u", match[0].length));
                            while (runLength >= 8) {
                                ENCODEFGBG(*destbuf);
                                destbuf++;
                                EncodeSrcOffset += 8;
                                runLength -= 8;
                            }
                            if (runLength) {
                                ENCODEFGBG(*destbuf);
                                *destbuf &= ((0x01 << runLength) - 1);
                                destbuf++;
                                EncodeSrcOffset += runLength;
                            }
                        }
                    }
                    break;


                case RUN_COLOR:
                    ENCODE_ORDER_MEGA(destbuf,
                                      CODE_COLOR_RUN,
                                      match[0].length,
                                      CODE_MEGA_MEGA_COLOR_RUN,
                                      MAX_LENGTH_ORDER,
                                      MAX_LENGTH_LONG_ORDER);
                    TRC_DBG((TB, "COLOR_RUN %u", match[0].length));
                    *destbuf++ = pSrc[EncodeSrcOffset];
                    EncodeSrcOffset += match[0].length;
                    break;

                case RUN_DITHER:
                    {
                        unsigned ditherlen = match[0].length / 2;
                        ENCODE_ORDER_MEGA(destbuf,
                                          CODE_DITHERED_RUN,
                                          ditherlen,
                                          CODE_MEGA_MEGA_DITHER,
                                          MAX_LENGTH_ORDER_LITE,
                                          MAX_LENGTH_LONG_ORDER_LITE);
                        TRC_DBG((TB, "DITHERED_RUN %u", match[0].length));

                        // First check for our approaching the end of the
                        // destination buffer and get out if this is the case.
                        if ((unsigned)(destbuf - pDst + 2) <= dstBufferSize) {
                            *destbuf++ = pSrc[EncodeSrcOffset];
                            *destbuf++ = pSrc[EncodeSrcOffset + 1];
                            EncodeSrcOffset += match[0].length;
                        }
                        else {
                            DC_QUIT;
                        }
                    }
                    break;

                case IMAGE_COLOR:
                    // Length 1 can possibly be encoded as a single BLACK/WHITE.
                    if (match[0].length == 1) {
                        if (pSrc[EncodeSrcOffset] == 0x00) {
                            *destbuf++ = CODE_BLACK;
                            EncodeSrcOffset++;
                            break;
                        }
                        if (pSrc[EncodeSrcOffset] == 0xFF) {
                            *destbuf++ = CODE_WHITE;
                            EncodeSrcOffset++;
                            break;
                        }
                    }

                    // Store the data in non-compressed form.
                    ENCODE_ORDER_MEGA(destbuf,
                                      CODE_COLOR_IMAGE,
                                      match[0].length,
                                      CODE_MEGA_MEGA_CLR_IMG,
                                      MAX_LENGTH_ORDER,
                                      MAX_LENGTH_LONG_ORDER);
                    TRC_DBG((TB, "COLOR_IMAGE %u", match[0].length));

                    // First check for our approaching the end of the
                    // destination buffer and get out if this is the case.
                    if ((destbuf - pDst + (UINT_PTR)match[0].length) <=
                            dstBufferSize) {
                        // Now just copy the data over.
                        memcpy(destbuf, pSrc+EncodeSrcOffset, match[0].length);
                        destbuf += match[0].length;
                        EncodeSrcOffset += match[0].length;
                    }
                    else {
                        DC_QUIT;
                    }

                    break;

#ifdef DC_DEBUG
                default:
                    TRC_ERR((TB, "Invalid run type %u",match[0].type));
                    break;
#endif
            }

            /****************************************************************/
            // Done encoding, what we do next is determined by whether we're
            // flushing the match queue after everything is scanned.
            /****************************************************************/
            match[0] = match[1];
            if (!bEncodeAllMatches) {
                // Push the current run into the top of the queue.
                match[1].type   = bestRunType;
                match[1].length = bestRunLength;
                match[1].fgChar = fgChar;
            }
            else {
                // We need to check to see if we're really finished. Since
                // our maximum queue depth is 2, if we're done then the only
                // remaining entry has an encoding type of 0.
                if (match[0].type == 0) {
                    goto PostScan;
                }
                else {
                    match[1].type = 0;
                    goto DoEncoding;
                }
            }
        }

        if (scanCount == 0) {
            // If we have just done our scan of the first line then now do the
            // rest of the buffer.  Reset our saved pel count.
            numPels = saveNumPels;
        }
        else {
            // When we are done with the second pass (we've reached the end of
            // the buffer) we have to force the remaining items in the match
            // queue to be encoded. Yes this is similar to old BASIC
            // code in using gotos, but we cannot place the encoding code into
            // a function because of the number of params required, and
            // we cannot duplicate it because it is too big. This code is
            // some of the most used in the system so the cost is worth it.
            bEncodeAllMatches = TRUE;
            goto DoEncoding;
        }
    }

PostScan:
    // Success, calculate the amount of space we used.
    compressedLength = (unsigned)(destbuf - pDst);

DC_EXIT_POINT:
    DC_END_FN();
    return compressedLength;
}
#endif

#ifdef DC_HICOLOR
/****************************************************************************/
/* Hi res color compression functions                                       */
/****************************************************************************/
/****************************************************************************/
/* 15bpp version of CompressV2Int                                           */
/****************************************************************************/
unsigned RDPCALL SHCLASS CompressV2Int15(PBYTE    pSrc,
                                         PBYTE    pDst,
                                         unsigned numBytes,
                                         unsigned rowDelta,
                                         unsigned dstBufferSize,
                                         BYTE *   xorbuf,
                                         MATCH *  match)
{
/****************************************************************************/
/* Function name                                                            */
/****************************************************************************/
#define BC_FN_NAME              "CompressV2Int15"

/****************************************************************************/
/* Data type of a pixel                                                     */
/****************************************************************************/
#define BC_PIXEL                TSUINT16

/****************************************************************************/
/* Length in bytes of a pixel                                               */
/****************************************************************************/
#define BC_PIXEL_LEN            2

/****************************************************************************/
/* Default fgPel                                                            */
/****************************************************************************/
#define BC_DEFAULT_FGPEL        0x0000FF7F

/****************************************************************************/
/* Macro to move to the next pixel in the buffer (modifies pPos)            */
/****************************************************************************/
#define BC_TO_NEXT_PIXEL(pPos)  pPos += 2

/****************************************************************************/
/* Macro to returns the value of the pixel at pPos (doesn't modify pPos)    */
/****************************************************************************/
#define BC_GET_PIXEL(pPos)      ((TSUINT16)  ((((PTSUINT8)(pPos))[1]) & 0x7f) |       \
                                 (TSUINT16) (((((PTSUINT8)(pPos))[0])) << 8) )

/****************************************************************************/
/* Macro to insert a pixel value pel at position pPos (doesn't modify pPos) */
/*                                                                          */
/* pel may well be an expression (e.g.  a BC_GET_PIXEL macro) so evaluate   */
/* it once into a local variable.                                           */
/****************************************************************************/
#define BC_SET_PIXEL(pPos, pel)                                              \
{                                                                            \
    BC_PIXEL val = pel;                                                      \
    (((PTSUINT8)(pPos))[1]) = (TSUINT8)( (val)       & 0x007F);              \
    (((PTSUINT8)(pPos))[0]) = (TSUINT8)(((val) >> 8) & 0x00FF);              \
}

/****************************************************************************/
/* Include the function body                                                */
/****************************************************************************/
#include <abccom.c>

/****************************************************************************/
/* Undefine everything                                                      */
/****************************************************************************/
#undef BC_FN_NAME
#undef BC_PIXEL
#undef BC_PIXEL_LEN
#undef BC_TO_NEXT_PIXEL
#undef BC_GET_PIXEL
#undef BC_SET_PIXEL
#undef BC_DEFAULT_FGPEL
}


/****************************************************************************/
/* 16bpp version of CompressV2Int                                           */
/****************************************************************************/
unsigned RDPCALL SHCLASS CompressV2Int16(PBYTE    pSrc,
                                         PBYTE    pDst,
                                         unsigned numBytes,
                                         unsigned rowDelta,
                                         unsigned dstBufferSize,
                                         BYTE *   xorbuf,
                                         MATCH *  match)
{
/****************************************************************************/
/* Function name                                                            */
/****************************************************************************/
#define BC_FN_NAME              "CompressV2Int16"

/****************************************************************************/
/* Data type of a pixel                                                     */
/****************************************************************************/
#define BC_PIXEL                TSUINT16

/****************************************************************************/
/* Length in bytes of a pixel                                               */
/****************************************************************************/
#define BC_PIXEL_LEN            2

/****************************************************************************/
/* Default fgPel                                                            */
/****************************************************************************/
#define BC_DEFAULT_FGPEL        0x0000FFFF

/****************************************************************************/
/* Macro to move to the next pixel in the buffer (modifies pPos)            */
/****************************************************************************/
#define BC_TO_NEXT_PIXEL(pPos)  pPos += 2

/****************************************************************************/
/* Macro to returns the value of the pixel at pPos (doesn't modify pPos)    */
/****************************************************************************/
#define BC_GET_PIXEL(pPos)      ((TSUINT16)  (((PTSUINT8)(pPos))[1]) |       \
                                 (TSUINT16) ((((PTSUINT8)(pPos))[0]) << 8) )

/****************************************************************************/
/* Macro to insert a pixel value pel at position pPos (doesn't modify pPos) */
/*                                                                          */
/* pel may well be an expression (e.g.  a BC_GET_PIXEL macro) so evaluate   */
/* it once into a local variable.                                           */
/****************************************************************************/
#define BC_SET_PIXEL(pPos, pel)                                              \
{                                                                            \
    BC_PIXEL val = pel;                                                      \
    (((PTSUINT8)(pPos))[1]) = (TSUINT8)( (val) & 0x00FF);                    \
    (((PTSUINT8)(pPos))[0]) = (TSUINT8)(((val)>>8) & 0x00FF);                \
}

/****************************************************************************/
/* Include the function body                                                */
/****************************************************************************/
#include <abccom.c>

/****************************************************************************/
/* Undefine everything                                                      */
/****************************************************************************/
#undef BC_FN_NAME
#undef BC_PIXEL
#undef BC_PIXEL_LEN
#undef BC_TO_NEXT_PIXEL
#undef BC_GET_PIXEL
#undef BC_SET_PIXEL
#undef BC_DEFAULT_FGPEL
}


/****************************************************************************/
/* 24bpp version of CompressV2Int                                           */
/****************************************************************************/
unsigned RDPCALL SHCLASS CompressV2Int24(PBYTE    pSrc,
                                         PBYTE    pDst,
                                         unsigned numBytes,
                                         unsigned rowDelta,
                                         unsigned dstBufferSize,
                                         BYTE *   xorbuf,
                                         MATCH *  match)

{
/****************************************************************************/
/* Function name                                                            */
/****************************************************************************/
#define BC_FN_NAME              "CompressV2Int24"

/****************************************************************************/
/* Data type of a pixel                                                     */
/****************************************************************************/
#define BC_PIXEL                TSUINT32

/****************************************************************************/
/* Length in bytes of a pixel                                               */
/****************************************************************************/
#define BC_PIXEL_LEN            3

/****************************************************************************/
/* Default fgPel                                                            */
/****************************************************************************/
#define BC_DEFAULT_FGPEL        0x00FFFFFF

/****************************************************************************/
/* Macro to move to the next pixel in the buffer (modifies pPos)            */
/****************************************************************************/
#define BC_TO_NEXT_PIXEL(pPos)  pPos += 3

/****************************************************************************/
/* Macro to returns the value of the pixel at pPos (doesn't modify pPos)    */
/****************************************************************************/
#define BC_GET_PIXEL(pPos)      ((TSUINT32)  (((PTSUINT8)(pPos))[2]) |       \
                                 (TSUINT32) ((((PTSUINT8)(pPos))[1]) << 8) | \
                                 (TSUINT32) ((((PTSUINT8)(pPos))[0]) << 16) )

/****************************************************************************/
/* Macro to insert a pixel value pel at position pPos (doesn't modify pPos) */
/*                                                                          */
/* pel may well be an expression (e.g.  a BC_GET_PIXEL macro) so evaluate   */
/* it once into a local variable.                                           */
/****************************************************************************/
#define BC_SET_PIXEL(pPos, pel)                                              \
{                                                                            \
    BC_PIXEL val = pel;                                                      \
    (((PTSUINT8)(pPos))[2]) = (TSUINT8)((val) & 0x000000FF);                 \
    (((PTSUINT8)(pPos))[1]) = (TSUINT8)(((val)>>8) & 0x000000FF);            \
    (((PTSUINT8)(pPos))[0]) = (TSUINT8)(((val)>>16) & 0x000000FF);           \
}

/****************************************************************************/
/* Include the function body                                                */
/****************************************************************************/
#include <abccom.c>

/****************************************************************************/
/* Undefine everything                                                      */
/****************************************************************************/
#undef BC_FN_NAME
#undef BC_PIXEL
#undef BC_PIXEL_LEN
#undef BC_TO_NEXT_PIXEL
#undef BC_GET_PIXEL
#undef BC_SET_PIXEL
#undef BC_DEFAULT_FGPEL
}

/****************************************************************************/
/* 32bpp version of CompressV2Int                                           */
/****************************************************************************/
unsigned RDPCALL SHCLASS CompressV2Int32(PBYTE    pSrc,
                                         PBYTE    pDst,
                                         unsigned numBytes,
                                         unsigned rowDelta,
                                         unsigned dstBufferSize,
                                         BYTE *   xorbuf,
                                         MATCH *  match)
{
/****************************************************************************/
/* Function name                                                            */
/****************************************************************************/
#define BC_FN_NAME              "CompressV2Int32"

/****************************************************************************/
/* Data type of a pixel                                                     */
/****************************************************************************/
#define BC_PIXEL                TSUINT32

/****************************************************************************/
/* Length in bytes of a pixel                                               */
/****************************************************************************/
#define BC_PIXEL_LEN            4

/****************************************************************************/
/* Default fgPel                                                            */
/****************************************************************************/
#define BC_DEFAULT_FGPEL        0xFFFFFFFF

/****************************************************************************/
/* Macro to move to the next pixel in the buffer (modifies pPos)            */
/****************************************************************************/
#define BC_TO_NEXT_PIXEL(pPos)  pPos += 4

/****************************************************************************/
/* Macro to returns the value of the pixel at pPos (doesn't modify pPos)    */
/****************************************************************************/
#define BC_GET_PIXEL(pPos) (                                                 \
                 (TSUINT32) ( (TSUINT16)(((PTSUINT8)(pPos))[3])       ) |    \
                 (TSUINT32) (((TSUINT16)(((PTSUINT8)(pPos))[2])) <<  8) |    \
                 (TSUINT32) (((TSUINT32)(((PTSUINT8)(pPos))[1])) << 16) |    \
                 (TSUINT32) (((TSUINT32)(((PTSUINT8)(pPos))[0])) << 24))

/****************************************************************************/
/* Macro to insert a pixel value pel at position pPos (doesn't modify pPos) */
/*                                                                          */
/* pel may well be an expression (e.g.  a BC_GET_PIXEL macro) so evaluate   */
/* it once into a local variable.                                           */
/****************************************************************************/
#define BC_SET_PIXEL(pPos, pel)                                              \
{                                                                            \
    BC_PIXEL val = pel;                                                      \
    (((PTSUINT8)(pPos))[3]) = (TSUINT8)((val) & 0x000000FF);                 \
    (((PTSUINT8)(pPos))[2]) = (TSUINT8)(((val)>>8) & 0x000000FF);            \
    (((PTSUINT8)(pPos))[1]) = (TSUINT8)(((val)>>16) & 0x000000FF);           \
    (((PTSUINT8)(pPos))[0]) = (TSUINT8)(((val)>>24) & 0x000000FF);           \
}

/****************************************************************************/
/* Include the function body                                                */
/****************************************************************************/
#include <abccom.c>

/****************************************************************************/
/* Undefine everything                                                      */
/****************************************************************************/
#undef BC_FN_NAME
#undef BC_PIXEL
#undef BC_PIXEL_LEN
#undef BC_TO_NEXT_PIXEL
#undef BC_GET_PIXEL
#undef BC_SET_PIXEL
#undef BC_DEFAULT_FGPEL
}

#endif /* DC_HICOLOR */

#ifdef DC_DEBUG
// compression testing
#include <abdapi.c>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\abccom.c ===
/****************************************************************************/
/*                                                                          */
/* abccom.c                                                                 */
/*                                                                          */
/* Copyright (c) Data Connection Limited 1998                               */
/*                                                                          */
/*                                                                          */
/* Bitmap compression routine and macros for 16 and 24bpp protocol          */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* We override the following macros to provide 16bpp/24bpp versions         */
/*                                                                          */
/*  RUNSINGLE_NRM                                                           */
/*  RunDouble                                                               */
/*  RUNFGBG                                                                 */
/*  SETFGPEL                                                                */
/*  ENCODE_SET_ORDER_MEGA                                                   */
/*  ENCODE_SET_ORDER_FGBG                                                   */
/*  ENCODEFGBG                                                              */
/****************************************************************************/

#ifdef BC_TRACE
#define BCTRACE TRC_DBG
#else
#define BCTRACE(string)
#endif


/****************************************************************************/
/* RUNSINGLE_NRM                                                            */
/*                                                                          */
/* Determine the length of the current run                                  */
/*                                                                          */
/* RunSingle may only be called if the buffer has at least four             */
/* consecutive identical pixels from the start position                     */
/*                                                                          */
/* length is the number of bytes we should search                           */
/* result is the number of pixels found in the run                          */
/****************************************************************************/
#undef  RUNSINGLE_NRM
#define RUNSINGLE_NRM(buffer, length, result)                                \
     {                                                                       \
         BYTE    * buf      = buffer + (BC_PIXEL_LEN * 4);                   \
         BYTE    * endbuf   = buffer + length - (BC_PIXEL_LEN * 4);          \
         BC_PIXEL  tmpPixel = BC_GET_PIXEL(buf - BC_PIXEL_LEN);              \
                                                                             \
         result = 4;                                                         \
         while (((buf + (BC_PIXEL_LEN - 1)) < endbuf) &&                     \
                (BC_GET_PIXEL(buf) == tmpPixel))                             \
         {                                                                   \
             result++;                                                       \
             buf += BC_PIXEL_LEN;                                            \
         }                                                                   \
     }


/****************************************************************************/
/* RunDouble                                                                */
/*                                                                          */
/* Determine the length of the current run of paired bytes                  */
/*                                                                          */
/* length is the number of bytes we should search                           */
/* result is the number of pixels found in the run                          */
/****************************************************************************/
#undef  RunDouble
#define RunDouble(buffer, length, result)                                    \
    {                                                                        \
        int    len  = ((short)length);                                       \
        BYTE * buf = buffer;                                                 \
        BC_PIXEL testPel1 = BC_GET_PIXEL(buf);                               \
        BC_PIXEL testPel2 = BC_GET_PIXEL(buf + BC_PIXEL_LEN);                \
        result = 0;                                                          \
        while(len > BC_PIXEL_LEN)                                            \
        {                                                                    \
            if (BC_GET_PIXEL(buf) != testPel1)                               \
            {                                                                \
                break;                                                       \
            }                                                                \
                                                                             \
            BC_TO_NEXT_PIXEL(buf);                                           \
                                                                             \
            if (BC_GET_PIXEL(buf) != testPel2)                               \
            {                                                                \
                break;                                                       \
            }                                                                \
                                                                             \
            BC_TO_NEXT_PIXEL(buf);                                           \
                                                                             \
            result += 2;                                                     \
            len    -= (BC_PIXEL_LEN * 2);                                    \
        }                                                                    \
    }

/****************************************************************************/
/* RUNFGBG                                                                  */
/*                                                                          */
/* Determine the length of the run of bytes that consist                    */
/* only of black or a single FG color                                       */
/* We exit the loop when                                                    */
/* - the next character is not a fg or bg color                             */
/* - we hit a run of 24 of the FG or BG color when result is an exact       */
/* multiple of eight (we'll be creating a bitmask of result bits long,      */
/* hence this calculation)                                                  */
/*                                                                          */
/* length is the number of bytes we should search                           */
/* result is the number of pixels in the run                                */
/* work is a BC_PIXEL for us to leave the fgPel in                          */
/****************************************************************************/
#undef  RUNFGBG
#define RUNFGBG(buffer, length, result, work)                                \
    {                                                                        \
        BYTE * buf = buffer;                                               \
        BYTE * endbuf = buffer + length;                                   \
        int    ii;                                                         \
        BOOLEAN   exitWhile = FALSE;                                          \
        BC_PIXEL tmpPixel;                                                   \
        result = 0;                                                          \
        work = BC_GET_PIXEL(buf);                                            \
        while(!exitWhile)                                                    \
        {                                                                    \
            BC_TO_NEXT_PIXEL(buf);                                           \
            result++;                                                        \
            if (buf >= endbuf)                                               \
            {                                                                \
                break;                                                       \
            }                                                                \
                                                                             \
            tmpPixel = BC_GET_PIXEL(buf);                                    \
            if ((tmpPixel != work) && (tmpPixel != (BC_PIXEL)0))             \
            {                                                                \
                break;                                                       \
            }                                                                \
                                                                             \
            if ((result & 0x0007) == 0)                                      \
            {                                                                \
                /***********************************************************/\
                /* Check for 24 consecutive identical pixels starting at   */\
                /* buf                                                     */\
                /*                                                         */\
                /* We wouldn't have got this far unless                    */\
                /*  - the value we're checking for is 'work'               */\
                /*  - the pixel at buf already contains 'work'             */\
                /***********************************************************/\
                if ((buf + (24 * BC_PIXEL_LEN)) < endbuf)                    \
                {                                                            \
                    for (ii = BC_PIXEL_LEN;                                  \
                         ii < (24 * BC_PIXEL_LEN);                           \
                         ii += BC_PIXEL_LEN)                                 \
                    {                                                        \
                        if (BC_GET_PIXEL(buf + ii) != work)                  \
                        {                                                    \
                            break;                                           \
                        }                                                    \
                                                                             \
                        /***************************************************/\
                        /* Found them!  Break out of the while loop.       */\
                        /***************************************************/\
                        exitWhile = TRUE;                                    \
                    }                                                        \
                }                                                            \
            }                                                                \
        }                                                                    \
    }


/****************************************************************************/
/* SETFGPEL                                                                 */
/*                                                                          */
/* Set up a new value in fgPel.  We don't calculate a shift as ENCODEFGBG   */
/* doesn't need it in the 16/24bpp implementation.                          */
/*                                                                          */
/* This is the hi-res version of SETFGCHAR.  As the macros are named        */
/* differently we will only need to undef this one on the second pass,      */
/* hence the #ifdef/#endif surrounding it                                   */
/****************************************************************************/
#ifdef  SETFGPEL
#undef  SETFGPEL
#endif

#define SETFGPEL(newPel, curPel)                                             \
     curPel = (BC_PIXEL)newPel;

/****************************************************************************/
/* ENCODE_SET_ORDER_MEGA                                                    */
/*                                                                          */
/* Encode a combined order and set fg color                                 */
/****************************************************************************/
#undef  ENCODE_SET_ORDER_MEGA
#define ENCODE_SET_ORDER_MEGA(buffer,                                        \
                              order_code,                                    \
                              length,                                        \
                              mega_order_code,                               \
                              DEF_LENGTH_ORDER,                              \
                              DEF_LENGTH_LONG_ORDER)                         \
        if (length <= DEF_LENGTH_ORDER)                                      \
        {                                                                    \
            *buffer++ = (BYTE)((BYTE)order_code | (BYTE)length);             \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            if (length <= DEF_LENGTH_LONG_ORDER)                             \
            {                                                                \
                *buffer++ = (BYTE)order_code;                                \
                *buffer++ = (BYTE)(length-DEF_LENGTH_ORDER-1);               \
            }                                                                \
            else                                                             \
            {                                                                \
                *buffer++ = (BYTE)mega_order_code;                           \
                *(PUINT16_UA)(buffer) = (TSUINT16)length;                    \
                buffer += 2;                                                 \
            }                                                                \
        }                                                                    \
        BC_SET_PIXEL(buffer, fgPel);                                         \
        BC_TO_NEXT_PIXEL(buffer);

/****************************************************************************/
/* Encode a combined order and set fg color for a special FGBG image        */
/****************************************************************************/
#undef  ENCODE_SET_ORDER_MEGA_FGBG
#define ENCODE_SET_ORDER_MEGA_FGBG(buffer,                                   \
                                   order_code,                               \
                                   length,                                   \
                                   mega_order_code,                          \
                                   DEF_LENGTH_ORDER,                         \
                                   DEF_LENGTH_LONG_ORDER)                    \
        if (((length & 0x0007) == 0) &&                                      \
            (length <= DEF_LENGTH_ORDER))                                    \
        {                                                                    \
            *buffer++ = (BYTE)((BYTE)order_code | (BYTE)(length/8));         \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            if (length <= DEF_LENGTH_LONG_ORDER)                             \
            {                                                                \
                *buffer++ = (BYTE)order_code;                                \
                *buffer++ = (BYTE)(length-1);                                \
            }                                                                \
            else                                                             \
            {                                                                \
                *buffer++ = (BYTE)mega_order_code;                           \
                *(PUINT16_UA)(buffer) = (TSUINT16)length;                    \
                buffer += 2;                                                 \
            }                                                                \
        }                                                                    \
        BC_SET_PIXEL(buffer, fgPel);                                         \
        BC_TO_NEXT_PIXEL(buffer);

/****************************************************************************/
/* ENCODEFGBG                                                               */
/*                                                                          */
/* Encode 8 pixels of FG and black into a one byte bitmap representation.   */
/*                                                                          */
/* We start reading at xorbuf[srcOffset] and don't try to be clever.        */
/*                                                                          */
/* We encode a row of pixels abcdefgh as a bitmask thus:                    */
/*                                                                          */
/*  bit 7 6 5 4 3 2 1 0                                                     */
/*  pel h g f e d c b a                                                     */
/*                                                                          */
/* where 7 is the most significant bit.                                     */
/*                                                                          */
/****************************************************************************/
#undef  ENCODEFGBG
#define ENCODEFGBG(result)                                                   \
{                                                                            \
    BYTE * buf = xorbuf + srcOffset;                                         \
                                                                             \
    result = 0;                                                              \
                                                                             \
    if (BC_GET_PIXEL(buf) != (BC_PIXEL)0)                                    \
    {                                                                        \
        result |= 0x01;                                                      \
    }                                                                        \
    BC_TO_NEXT_PIXEL(buf);                                                   \
                                                                             \
    if (BC_GET_PIXEL(buf) != (BC_PIXEL)0)                                    \
    {                                                                        \
        result |= 0x02;                                                      \
    }                                                                        \
    BC_TO_NEXT_PIXEL(buf);                                                   \
                                                                             \
    if (BC_GET_PIXEL(buf) != (BC_PIXEL)0)                                    \
    {                                                                        \
        result |= 0x04;                                                      \
    }                                                                        \
    BC_TO_NEXT_PIXEL(buf);                                                   \
                                                                             \
    if (BC_GET_PIXEL(buf) != (BC_PIXEL)0)                                    \
    {                                                                        \
        result |= 0x08;                                                      \
    }                                                                        \
    BC_TO_NEXT_PIXEL(buf);                                                   \
                                                                             \
    if (BC_GET_PIXEL(buf) != (BC_PIXEL)0)                                    \
    {                                                                        \
        result |= 0x10;                                                      \
    }                                                                        \
    BC_TO_NEXT_PIXEL(buf);                                                   \
                                                                             \
    if (BC_GET_PIXEL(buf) != (BC_PIXEL)0)                                    \
    {                                                                        \
        result |= 0x20;                                                      \
    }                                                                        \
    BC_TO_NEXT_PIXEL(buf);                                                   \
                                                                             \
    if (BC_GET_PIXEL(buf) != (BC_PIXEL)0)                                    \
    {                                                                        \
        result |= 0x40;                                                      \
    }                                                                        \
    BC_TO_NEXT_PIXEL(buf);                                                   \
                                                                             \
    if (BC_GET_PIXEL(buf) != (BC_PIXEL)0)                                    \
    {                                                                        \
        result |= 0x80;                                                      \
    }                                                                        \
    BC_TO_NEXT_PIXEL(buf);                                                   \
}


/****************************************************************************/
/* Compress function starts here                                            */
/****************************************************************************/
/****************************************************************************/
/*                                                                          */
/*  BYTE     * pSrc,                                                        */
/*  BYTE     * pDst,                                                        */
/*  unsigned   numBytes,            total bytes in image                    */
/*  unsigned   rowDelta,            scanline length in bytes                */
/*  unsigned   dstBufferSize,                                               */
/*  unsigned * xorbuf,                                                      */
/*  MATCH    * match                                                        */
/*                                                                          */
/****************************************************************************/
{
    int       i;
    unsigned  srcOffset;
    unsigned  matchindex;
    unsigned  bestRunLength;
    unsigned  nextRunLength;
    unsigned  runLength;
    unsigned  bestFGRunLength;
    unsigned  checkFGBGLength;
    unsigned  scanCount;
    BOOLEAN   firstLine;
    unsigned  saveNumBytes;
    BYTE      bestRunType      = 0;
    BYTE    * destbuf          = pDst;
    BC_PIXEL  fgPel            = BC_DEFAULT_FGPEL;
    BC_PIXEL  fgPelWork        = BC_DEFAULT_FGPEL;
    BOOLEAN   inColorRun       = FALSE;
    unsigned  compressedLength = 0;
    BC_PIXEL  pixelA;
    BC_PIXEL  pixelB;

    DC_BEGIN_FN(BC_FN_NAME);

    /************************************************************************/
    /* Validate the line length                                             */
    /************************************************************************/
    if ((numBytes < rowDelta) ||
        (rowDelta & 0x0003) || (numBytes & 0x0003) ||
        ((numBytes % BC_PIXEL_LEN) != 0))
    {
        TRC_ALT((TB, "Lines must be a multiple of 4 pels and there must be"
                " a whole number of pixels in the buffer"
                " (numBytes = %d, rowDelta = %d)", numBytes, rowDelta));
        DC_QUIT;
    }

    /************************************************************************/
    /* The first line of the XORBUF is identical to the first line of the   */
    /* source buffer.  Set it up.                                           */
    /************************************************************************/
    memcpy(xorbuf, pSrc, rowDelta);

    /************************************************************************/
    /* The remaining lines in the XORBUF are the XOR against the previous   */
    /* line.  Calculate the rest of the XOR buffer.                         */
    /*                                                                      */
    /* Note that this calculation is NOT pel-size dependent                 */
    /************************************************************************/
    {
        BYTE   * srcbuf = pSrc + rowDelta;
        unsigned srclen = numBytes - rowDelta;
        UINT32 * dwdest = (UINT32 *)(xorbuf + rowDelta);

        while (srclen >= 8)
        {
            *dwdest++ = *((PUINT32)srcbuf) ^ *((PUINT32)(srcbuf - rowDelta));
            srcbuf += 4;

            *dwdest++ = *((PUINT32)srcbuf) ^ *((PUINT32)(srcbuf - rowDelta));
            srcbuf += 4;

            srclen -= 8;
        }

        if (srclen)
        {
            // Since we're 4-byte aligned we can only have a single DWORD
            // remaining.
            *dwdest = *((PUINT32)srcbuf) ^ *((PUINT32)(srcbuf - rowDelta));
        }
    }

    /************************************************************************/
    /* Loop processing the input                                            */
    /* We perform the loop twice, the first time for the non-xor portion    */
    /* of the buffer and the second for the XOR portion                     */
    /*                                                                      */
    /* Note that we start the run at a match index of 2 to avoid having     */
    /* to special case the startup condition in some of the match           */
    /* merging code                                                         */
    /************************************************************************/
    srcOffset     = 0;
    firstLine     = TRUE;
    match[0].type = 0;
    match[1].type = 0;
    matchindex    = 2;
    saveNumBytes  = numBytes;

    /************************************************************************/
    /* On the first iteration numBytes stores the length of a scanline, on  */
    /* the second the total number of bytes.                                */
    /*                                                                      */
    /* srcOffset is the position we are currently examining.                */
    /************************************************************************/
    numBytes = rowDelta;

    for (scanCount = 0; scanCount < 2; scanCount++)
    {
        while (srcOffset < numBytes)
        {
            /****************************************************************/
            /* Give up if we are nearing the end of the match array         */
            /****************************************************************/
            if (matchindex >= 8192)
            {
                DC_QUIT;
            }

            /****************************************************************/
            /* Start a while loop to allow a more structured break when we  */
            /* hit the first run type we want to encode (We can't afford    */
            /* the overheads of a function call to provide the scope here.) */
            /****************************************************************/
            while (TRUE)
            {
                bestRunLength      = 0;
                bestFGRunLength    = 0;

                /************************************************************/
                /* If we are hitting the end of the buffer then just take   */
                /* color characters now - take them one at a time so that   */
                /* lossy encoding still works.  We will only hit this       */
                /* condition if we break out of a run just before the end   */
                /* of the buffer, so this should not be too common a        */
                /* situation, which is good given that we are encoding the  */
                /* final 6 pixels uncompressed.                             */
                /************************************************************/
                if (srcOffset + (6 * BC_PIXEL_LEN) >= numBytes)
                {
                    bestRunType = IMAGE_COLOR;
                    bestRunLength = 1;
                    break;
                }

                /************************************************************/
                /* First do the scans on the XOR buffer.  Look for a        */
                /* character run or a BG run.  Note that if there is no row */
                /* delta then xorbuf actually points to the normal buffer.  */
                /* We must do the test independent of how long the run      */
                /* might be because even for a 1 pel BG run our later logic */
                /* requires that we detect it separately.  This code is     */
                /* absolute main path so fastpath as much as possible.  In  */
                /* particular detect short bg runs early and allow          */
                /* RunSingle to presuppose at least 4 matching bytes        */
                /************************************************************/
                if (BC_GET_PIXEL(xorbuf + srcOffset) == (BC_PIXEL)0)
                {
                    /********************************************************/
                    /* First pixel is 0, so look for BG runs                */
                    /********************************************************/
                    if (((srcOffset + BC_PIXEL_LEN) >= numBytes) ||
                        (BC_GET_PIXEL(xorbuf + srcOffset + BC_PIXEL_LEN) !=
                                                                 (BC_PIXEL)0))
                    {
                        /****************************************************/
                        /* One pixel BG run                                 */
                        /****************************************************/
                        bestRunType = RUN_BG;
                        bestRunLength = 1;
                        if (!inColorRun)
                        {
                            break;
                        }
                    }
                    else if (((srcOffset + (BC_PIXEL_LEN * 2)) >= numBytes) ||
                            (BC_GET_PIXEL(xorbuf +
                                          srcOffset +
                                          (BC_PIXEL_LEN * 2)) != (BC_PIXEL)0))
                    {
                        /****************************************************/
                        /* Two pixel BG run                                 */
                        /****************************************************/
                        bestRunType = RUN_BG;
                        bestRunLength = 2;
                        if (!inColorRun)
                        {
                            break;
                        }
                    }
                    else if (((srcOffset + (BC_PIXEL_LEN * 3)) >= numBytes) ||
                            (BC_GET_PIXEL(xorbuf +
                                          srcOffset +
                                          (BC_PIXEL_LEN * 3)) != (BC_PIXEL)0))
                    {
                        /****************************************************/
                        /* Three pixel BG run                               */
                        /****************************************************/
                        bestRunType = RUN_BG;
                        bestRunLength = 3;
                        if (!inColorRun)
                        {
                            break;
                        }
                    }
                    else
                    {
                        /****************************************************/
                        /* Four or more pixel BG run                        */
                        /****************************************************/
                        RUNSINGLE_NRM(xorbuf + srcOffset,
                                      numBytes - srcOffset,
                                      bestFGRunLength);
                        CHECK_BEST_RUN(RUN_BG,
                                       bestFGRunLength,
                                       bestRunLength,
                                       bestRunType);
                        if (!inColorRun)
                        {
                             break;
                        }
                    }
                }
                else
                {
                    /********************************************************/
                    /* First pixel is non-zero, so look for FG runs         */
                    /********************************************************/

                    /********************************************************/
                    /* No point in starting if FG run less than 4 bytes so  */
                    /* check the first dword as quickly as possible Note    */
                    /* that we don't need to check for an end-buffer        */
                    /* condition here because our XOR buffer always has     */
                    /* some free space at the end and the RUNSINGLE_NRM     */
                    /* will break at the correct place                      */
                    /********************************************************/
                    BC_PIXEL tmpPixel = BC_GET_PIXEL(xorbuf + srcOffset);

                    if ( (tmpPixel ==
                           BC_GET_PIXEL(xorbuf + srcOffset + BC_PIXEL_LEN)) &&
                         (tmpPixel ==
                           BC_GET_PIXEL(xorbuf +
                                        srcOffset +
                                        (BC_PIXEL_LEN * 2))) &&
                         (tmpPixel ==
                           BC_GET_PIXEL(xorbuf +
                                        srcOffset +
                                        (BC_PIXEL_LEN * 3))) )
                    {
                        RUNSINGLE_NRM(xorbuf + srcOffset,
                                      numBytes - srcOffset,
                                      bestFGRunLength);

                        /****************************************************/
                        /* Don't permit a short FG run to prevent a FGBG    */
                        /* image from starting up.  Only take if >= 5       */
                        /****************************************************/
                        if (bestFGRunLength > 5)
                        {
                            CHECK_BEST_RUN(RUN_FG,
                                           bestFGRunLength,
                                           bestRunLength,
                                           bestRunType);
                        }
                    }
                }


                /************************************************************/
                /* Look for color runs and dithered runs.                   */
                /*                                                          */
                /* Start by checking for the pattern                        */
                /*  A B A B A B                                             */
                /*                                                          */
                /* If we find it, then if A == B, it's a color run else     */
                /* it's a dithered run.                                     */
                /*                                                          */
                /* Look for sequences in the non XOR buffer In this case we */
                /* insist upon a run of at least 6 pels                     */
                /************************************************************/
                pixelA = BC_GET_PIXEL(pSrc + srcOffset);
                pixelB = BC_GET_PIXEL(pSrc + srcOffset + BC_PIXEL_LEN);

                if ( (pixelA ==
                     BC_GET_PIXEL(pSrc + srcOffset + (BC_PIXEL_LEN * 2))) &&
                     (pixelA ==
                     BC_GET_PIXEL(pSrc + srcOffset + (BC_PIXEL_LEN * 4))) &&
                     (pixelB ==
                     BC_GET_PIXEL(pSrc + srcOffset + (BC_PIXEL_LEN * 3))) &&
                     (pixelB ==
                     BC_GET_PIXEL(pSrc + srcOffset + (BC_PIXEL_LEN * 5))) )
                {
                    /********************************************************/
                    /* Now do the scan on the normal buffer for a character */
                    /* run Don't bother if first line because we will have  */
                    /* found it already in the XOR buffer, since we just    */
                    /* copy pSrc to xorbuf for the first line             */
                    /********************************************************/
                    if (pixelA == pixelB)
                    {
                        if (!firstLine)
                        {
                            RUNSINGLE_NRM(pSrc + srcOffset,
                                          numBytes - srcOffset,
                                          nextRunLength);
                            if (nextRunLength > 5)
                            {
                                CHECK_BEST_RUN(RUN_COLOR,
                                               nextRunLength,
                                               bestRunLength,
                                               bestRunType);
                            }
                        }
                    }
                    else
                    {
                        /****************************************************/
                        /* Look for a dither on the nrm buffer.  Dithers    */
                        /* are not very efficient for short runs so only    */
                        /* take if 8 or longer                              */
                        /****************************************************/
                        RunDouble(pSrc + srcOffset,
                                  numBytes - srcOffset,
                                  nextRunLength);
                        if (nextRunLength > 9)
                        {
                            CHECK_BEST_RUN(RUN_DITHER,
                                           nextRunLength,
                                           bestRunLength,
                                           bestRunType);
                        }
                    }
                }

                /************************************************************/
                /* If nothing so far then look for a FGBG run (The 6 is     */
                /* carefully tuned!)                                        */
                /************************************************************/
                if (bestRunLength < 6)
                {
                    /********************************************************/
                    /* But first look for a single fg bit breaking up a BG  */
                    /* run.  If so then encode a BG run.  Careful of the    */
                    /* enforced BG run break across the first line          */
                    /* non-XOR/XOR boundary.                                */
                    /*                                                      */
                    /* So...                                                */
                    /*  - check that the next four pixels are 0 (BG)        */
                    /*  - check that the pel in the middle is the fgPel     */
                    /*  - check that the previous run code is indeed RUN_BG */
                    /*  - check for the break over the boundary             */
                    /********************************************************/
                    if ( (BC_GET_PIXEL(xorbuf +
                                       srcOffset +
                                       BC_PIXEL_LEN) == (BC_PIXEL)0) &&
                         (BC_GET_PIXEL(xorbuf +
                                       srcOffset +
                                       (BC_PIXEL_LEN * 2)) == (BC_PIXEL)0) &&
                         (BC_GET_PIXEL(xorbuf +
                                       srcOffset +
                                       (BC_PIXEL_LEN * 3)) == (BC_PIXEL)0) &&
                         (BC_GET_PIXEL(xorbuf +
                                       srcOffset +
                                       (BC_PIXEL_LEN * 4)) == (BC_PIXEL)0) &&
                         (BC_GET_PIXEL(xorbuf + srcOffset) == fgPel) &&
                         (match[matchindex-1].type == RUN_BG) &&
                         (srcOffset != (TSUINT16)rowDelta))
                    {
                        RUNSINGLE_NRM(xorbuf + srcOffset + BC_PIXEL_LEN,
                                      numBytes - srcOffset - BC_PIXEL_LEN,
                                      nextRunLength);
                        nextRunLength++;
                        CHECK_BEST_RUN(RUN_BG_PEL,
                                       nextRunLength,
                                       bestRunLength,
                                       bestRunType);
                    }
                    else
                    {
                        /****************************************************/
                        /* If we have not found a run then look for a FG/BG */
                        /* image.  The disruptive effect of a short FGBG    */
                        /* run bandwidth and CPU is such that it is worth   */
                        /* preventing one unless we are certain of the      */
                        /* benefits.  However, if the alternative is a      */
                        /* color run then allow a lower value.              */
                        /****************************************************/
                        BCTRACE((TB, "FGBG: Checking %d bytes",
                                numBytes - srcOffset));
                        RUNFGBG(xorbuf + srcOffset,
                                numBytes - srcOffset,
                                nextRunLength,
                                fgPelWork);

                        checkFGBGLength = 48;
                        if (fgPelWork == fgPel)
                        {
                            /************************************************/
                            /* Cool: we don't need to issue a SET directive */
                            /* as the fgPel is correct.                     */
                            /************************************************/
                            checkFGBGLength -= 16;
                        }
                        if ((nextRunLength & 0x0007) == 0)
                        {
                            /************************************************/
                            /* Our bitmask will fit in an exact number of   */
                            /* bytes.  This is a Good Thing.                */
                            /************************************************/
                            checkFGBGLength -= 8;
                        }


                        BCTRACE((TB, "FGBG: resulting run %d, checklen %d ",
                                nextRunLength, checkFGBGLength ));

                        if (nextRunLength >= checkFGBGLength)
                        {
                            CHECK_BEST_RUN(IMAGE_FGBG,
                                           nextRunLength,
                                           bestRunLength,
                                           bestRunType);
                            BCTRACE((TB, "FGBG: resulting best run %d, type %d",
                                     bestRunLength, bestRunType ));
                        }
                    }
                }

                /************************************************************/
                /* If nothing useful so far then allow a short run, if any. */
                /* Don't do this if we are accumulating a color run because */
                /* it will really screw up GDC compression if we allow lots */
                /* of little runs.  Also require that it is a regular short */
                /* run, rather than one that disturbs the fgPel.            */
                /************************************************************/
                if (!inColorRun)
                {
                    if (bestRunLength < 6)
                    {
                        if ((bestFGRunLength > 4) &&
                            (BC_GET_PIXEL(xorbuf + srcOffset) == fgPel))
                        {
                            /************************************************/
                            /* We mustn't merge with the previous code      */
                            /* if we have just crossed the non-XOR/XOR      */
                            /* boundary.                                    */
                            /************************************************/
                            if ((match[matchindex-1].type == RUN_FG) &&
                                (srcOffset != rowDelta))
                            {
                                match[matchindex-1].length += bestFGRunLength;
                                srcOffset += (bestFGRunLength * BC_PIXEL_LEN);
                                continue;
                            }
                            else
                            {
                                bestRunLength = bestFGRunLength;
                                bestRunType   = RUN_FG;
                            }

                        }
                        else
                        {
                            /************************************************/
                            /* If we decided to take a run earlier then     */
                            /* allow it now.  (May be a short BG run, for   */
                            /* example) If nothing so far then take color   */
                            /* image)                                       */
                            /************************************************/
                            if (bestRunLength == 0)
                            {
                                bestRunType = IMAGE_COLOR;
                                bestRunLength = 1;
                            }
                        }
                    }
                }
                else if ((bestRunLength < 6) ||
                        ((bestRunType != RUN_BG) && (bestRunLength < 8)))
                {
                    bestRunType = IMAGE_COLOR;
                    bestRunLength = 1;
                }

                break;
            }

            /****************************************************************/
            /* When we get here we have found the best run.  Now check for  */
            /* various amalamation conditions with the previous run type.   */
            /* Note that we may already have done amalgamation of short     */
            /* runs, but we had to do multiple samples for the longer runs  */
            /* so we repeat the checks here                                 */
            /****************************************************************/

            /****************************************************************/
            /* If we are encoding a color run then                          */
            /*     - combine it with an existing run if possible            */
            /****************************************************************/
            if (bestRunType == IMAGE_COLOR)
            {
                /************************************************************/
                /* Flag that we are within a color run                      */
                /************************************************************/
                inColorRun = TRUE;

                /************************************************************/
                /* Merge the color run immediately, if possible             */
                /************************************************************/
                if (match[matchindex-1].type == IMAGE_COLOR)
                {
                    match[matchindex-1].length += bestRunLength;
                    srcOffset += (bestRunLength * BC_PIXEL_LEN);
                    continue;
                }
            }
            else
            {
                /************************************************************/
                /* We are no longer encoding a COLOR_IMAGE of any kind      */
                /************************************************************/
                inColorRun = FALSE;

                /************************************************************/
                /* Keep track of the fg Color.  The macro that searches for */
                /* FGBG runs leaves the character in fgPelWork.             */
                /************************************************************/
                if (bestRunType == RUN_FG)
                {
                    fgPel = BC_GET_PIXEL(xorbuf + srcOffset);
                }
                else if (bestRunType == IMAGE_FGBG)
                {
                    fgPel = fgPelWork;
                }
            }

            /****************************************************************/
            /* If we can amalgamate the entry then do so without creating a */
            /* new array entry insertion.  Our search for FGBG runs is      */
            /* dependent upon that type of run being amalgamated because we */
            /* break every 64 characters so that our mode switch detection  */
            /* works OK.                                                    */
            /*                                                              */
            /* Take care not to merge across the non-xor/xor boundary       */
            /****************************************************************/
            if (srcOffset == (TSUINT16)rowDelta)
            {
                /************************************************************/
                /* Just bump the source offset                              */
                /************************************************************/
                srcOffset += (bestRunLength * BC_PIXEL_LEN);
            }
            else
            {
                /************************************************************/
                /* Bump srcOffset and try a merge                           */
                /************************************************************/
                srcOffset += (bestRunLength * BC_PIXEL_LEN);

                /************************************************************/
                /* The simpler merges are where the types are identical     */
                /************************************************************/
                if (bestRunType == match[matchindex-1].type)
                {
                    /********************************************************/
                    /* COLOR IMAGES and BG images are trivial               */
                    /********************************************************/
                    if (bestRunType == RUN_BG)
                    {
                        match[matchindex-1].length += bestRunLength;
                        continue;
                    }

                    /********************************************************/
                    /* FG runs and FGBG images merge if fgPels match        */
                    /********************************************************/
                    if (((bestRunType == RUN_FG) ||
                         (bestRunType == IMAGE_FGBG)) &&
                         (fgPel == match[matchindex-1].fgPel))
                    {
                        match[matchindex-1].length += bestRunLength;
                        BCTRACE((TB, "Merged %u with preceding, giving %u",
                                 match[matchindex-1].type,
                                 match[matchindex-1].length));
                        continue;
                    }
                }

                /************************************************************/
                /* BG RUNs merge with LOSSY odd lines It is important that  */
                /* we do this merging because otherwise we will get         */
                /* inadvertent pel insertion due to the broken BG runs.     */
                /************************************************************/
                if ((bestRunType == RUN_BG) &&
                    ((match[matchindex-1].type == RUN_BG) ||
                     (match[matchindex-1].type == RUN_BG_PEL)))
                {
                    match[matchindex-1].length += bestRunLength;
                    continue;
                }

                /************************************************************/
                /* If it is a normal FGBG run which follows a short BG run  */
                /* then it is better to merge them.                         */
                /************************************************************/
                if ((bestRunType == IMAGE_FGBG) &&
                    (match[matchindex-1].type == RUN_BG) &&
                    (match[matchindex-1].length < 8))
                {
                    match[matchindex-1].type   = IMAGE_FGBG;
                    match[matchindex-1].length += bestRunLength;
                    match[matchindex-1].fgPel = fgPel;
                    BCTRACE((TB, "Merged FGBG with preceding BG run -> %u",
                             match[matchindex-1].length));
                    continue;

                }

                /************************************************************/
                /* If it is a BG run following a FGBG run then merge in the */
                /* pels to make the FGBG a multiple of 8 bits.  The if the  */
                /* remaining BG run is < 16 merge it in also otherwise just */
                /* write the shortened BG run                               */
                /************************************************************/
                if (((bestRunType == RUN_BG) ||
                     (bestRunType == RUN_BG_PEL)) &&
                    (match[matchindex-1].type == IMAGE_FGBG) &&
                    (match[matchindex-1].length & 0x0007))
                {
                    /********************************************************/
                    /* mergelen is the number of pixels we want to merge.   */
                    /********************************************************/
                    unsigned mergelen = 8 -
                                        (match[matchindex-1].length & 0x0007);
                    if (mergelen > bestRunLength)
                    {
                        mergelen = bestRunLength;
                    }
                    match[matchindex-1].length += mergelen;
                    bestRunLength -= mergelen;
                    BCTRACE((TB, "Added %u pels to FGBG giving %u leaving %u",
                       mergelen, match[matchindex-1].length,bestRunLength));

                    if (bestRunLength < 9)
                    {
                        match[matchindex-1].length += bestRunLength;
                        BCTRACE((TB, "Merged BG with preceding FGBG gives %u",
                             match[matchindex-1].length));
                        continue;
                    }
                }

                /************************************************************/
                /* Finally, if it is a color run spanning any kind of       */
                /* single pel entity then merge that last two entries.      */
                /************************************************************/
                if ((bestRunType == IMAGE_COLOR) &&
                    (match[matchindex-2].type == IMAGE_COLOR) &&
                    (match[matchindex-1].length == 1))
                {
                    match[matchindex-2].length += bestRunLength + 1;
                    matchindex--;
                    BCTRACE((TB, "Merged color with preceding color gives %u",
                         match[matchindex-1].length));
                    continue;
                }
            }

            /****************************************************************/
            /* Handle runs that will not amalgamate by adding a new array   */
            /* entry                                                        */
            /****************************************************************/
            match[matchindex].type   = bestRunType;
            match[matchindex].length = bestRunLength;
            match[matchindex].fgPel = fgPel;

            BCTRACE((TB, "Best run of type %u (index %u) has length %u",
                                     match[matchindex-1].type,
                                     matchindex-1,
                                     match[matchindex-1].length));
            BCTRACE((TB, "Trying run of type %u (index %u) length %u",
                                     match[matchindex].type,
                                     matchindex,
                                     match[matchindex].length));

            matchindex++;

        }

        /********************************************************************/
        /* If we have just done our scan of the first line then now do the  */
        /* rest of the buffer.  Reset our saved pel count.                  */
        /********************************************************************/
        numBytes  = saveNumBytes;
        firstLine = FALSE;
    }
    /************************************************************************/
    /* END OF INITIAL TWO PASS SCAN OF THE INPUT                            */
    /************************************************************************/

    /************************************************************************/
    /* Now do the encoding                                                  */
    /************************************************************************/
    srcOffset = 0;
    firstLine = TRUE;
    fgPel    = BC_DEFAULT_FGPEL;

    for (i = 2; i < (int)matchindex; i++)
    {
        /********************************************************************/
        /* First check for our approaching the end of the destination       */
        /* buffer and get out if this is the case.  We allow for the        */
        /* largest general run order (a mega-mega set run = 3 bytes + pixel */
        /* length).  Orders which may be larger are checked within the case */
        /* arm                                                              */
        /********************************************************************/
        if ((unsigned)(destbuf - pDst + 3 + BC_PIXEL_LEN) > dstBufferSize)
        {
            /****************************************************************/
            /* We are about to blow it so just get out                      */
            /****************************************************************/
            DC_QUIT;
        }

        /********************************************************************/
        /* While we are encoding the first line keep checking for the end   */
        /* of line to switch encoding states                                */
        /********************************************************************/
        if (firstLine)
        {
            if (srcOffset >= rowDelta)
            {
                firstLine = FALSE;
            }
        }

        switch (match[i].type)
        {
                /************************************************************/
                /* BG_RUN, FG_RUN, COLOR, PACKED COLOR and FGBG are normal  */
                /* precision codes                                          */
                /************************************************************/
            case RUN_BG:
            case RUN_BG_PEL:
                ENCODE_ORDER_MEGA(destbuf,
                                  CODE_BG_RUN,
                                  match[i].length,
                                  CODE_MEGA_MEGA_BG_RUN,
                                  MAX_LENGTH_ORDER,
                                  MAX_LENGTH_LONG_ORDER);
                BCTRACE((TB, "BG_RUN %u",match[i].length));
                srcOffset += (match[i].length * BC_PIXEL_LEN);
                break;

            case RUN_FG:
                /************************************************************/
                /* If the fg char is not yet set then encode a set+run code */
                /************************************************************/
                if (fgPel != match[i].fgPel)
                {
                    SETFGPEL(match[i].fgPel, fgPel);
                    /********************************************************/
                    /* Encode the order                                     */
                    /********************************************************/
                    ENCODE_SET_ORDER_MEGA(destbuf,
                                          CODE_SET_FG_FG_RUN,
                                          match[i].length,
                                          CODE_MEGA_MEGA_SET_FG_RUN,
                                          MAX_LENGTH_ORDER_LITE,
                                          MAX_LENGTH_LONG_ORDER_LITE);
                    BCTRACE((TB, "SET_FG_FG_RUN %u",match[i].length));
                    srcOffset += (match[i].length * BC_PIXEL_LEN);
                }
                else
                {
                    ENCODE_ORDER_MEGA(destbuf,
                                      CODE_FG_RUN,
                                      match[i].length,
                                      CODE_MEGA_MEGA_FG_RUN,
                                      MAX_LENGTH_ORDER,
                                      MAX_LENGTH_LONG_ORDER);
                    BCTRACE((TB, "FG_RUN %u",match[i].length));
                    srcOffset += (match[i].length * BC_PIXEL_LEN);
                }
                break;

            case IMAGE_FGBG:
                /************************************************************/
                /* IMAGE_FGBG                                               */
                /************************************************************/
                runLength = match[i].length;

                /************************************************************/
                /* First check for our approaching the end of the           */
                /* destination buffer and get out if this is the case.      */
                /*                                                          */
                /* The IMAGE_FGBG consists of a set of byte-long bit masks  */
                /* designed to hold runLength bits.                         */
                /************************************************************/
                if ((destbuf - pDst + ((runLength+7)/8) + 3 + BC_PIXEL_LEN)
                                                              > dstBufferSize)
                {
                    /********************************************************/
                    /* We are about to blow it so just get out              */
                    /********************************************************/
                    DC_QUIT;
                }

                if (fgPel != match[i].fgPel)
                {
                    /********************************************************/
                    /* We need to include a SET directive as fgPel has      */
                    /* changed                                              */
                    /********************************************************/
                    SETFGPEL(match[i].fgPel, fgPel);

                    ENCODE_SET_ORDER_MEGA_FGBG(destbuf,
                                               CODE_SET_FG_FG_BG,
                                               runLength,
                                               CODE_MEGA_MEGA_SET_FGBG,
                                               MAX_LENGTH_FGBG_ORDER_LITE,
                                               MAX_LENGTH_LONG_FGBG_ORDER);
                    BCTRACE((TB, "SET_FG_FG_BG %u, fgPel %06lx",
                                                     match[i].length, fgPel));

                    /********************************************************/
                    /* For every eight pixels...                            */
                    /********************************************************/
                    while (runLength >= 8)
                    {
                        ENCODEFGBG(*destbuf);
                        BCTRACE((TB, "Encoded as %08lx", *destbuf));
                        destbuf++;
                        srcOffset += (8 * BC_PIXEL_LEN);
                        runLength -= 8;
                    }
                    if (runLength)
                    {
                        ENCODEFGBG(*destbuf);
                        /****************************************************/
                        /* Keep the final partial byte clean to help GDC    */
                        /* packing                                          */
                        /****************************************************/
                        *destbuf &= ((0x01 << runLength) - 1);
                        destbuf++;
                        srcOffset += (runLength * BC_PIXEL_LEN);
                    }
                }
                else
                {
                    /********************************************************/
                    /* fgPel is already the correct value                   */
                    /********************************************************/
                    if (runLength == 8)
                    {
                        BYTE fgbgChar;

                        /****************************************************/
                        /* See if it is one of the high probability bytes   */
                        /****************************************************/
                        ENCODEFGBG(fgbgChar);

                        /****************************************************/
                        /* Check for single byte encoding of FGBG images    */
                        /****************************************************/
                        switch (fgbgChar)
                        {
                            case SPECIAL_FGBG_CODE_1:
                                *destbuf++ = CODE_SPECIAL_FGBG_1;
                                BCTRACE((TB, "SPECIAL FGBG_1"));
                                break;
                            case SPECIAL_FGBG_CODE_2:
                                *destbuf++ = CODE_SPECIAL_FGBG_2;
                                BCTRACE((TB, "SPECIAL FGBG_2"));
                                break;
                            default:

                                ENCODE_ORDER_MEGA_FGBG(destbuf,
                                                  CODE_FG_BG_IMAGE,
                                                  runLength,
                                                  CODE_MEGA_MEGA_FGBG,
                                                  MAX_LENGTH_FGBG_ORDER,
                                                  MAX_LENGTH_LONG_FGBG_ORDER);
                                *destbuf++ = fgbgChar;
                                break;
                        }
                        srcOffset += (8 * BC_PIXEL_LEN);
                    }
                    else
                    {
                        /****************************************************/
                        /* Encode as standard FGBG                          */
                        /****************************************************/
                        ENCODE_ORDER_MEGA_FGBG(destbuf,
                                               CODE_FG_BG_IMAGE,
                                               runLength,
                                               CODE_MEGA_MEGA_FGBG,
                                               MAX_LENGTH_FGBG_ORDER,
                                               MAX_LENGTH_LONG_FGBG_ORDER);
                        BCTRACE((TB, "FG_BG %u",match[i].length));
                        while (runLength >= 8)
                        {
                            ENCODEFGBG(*destbuf);
                            destbuf++;
                            srcOffset += (8 * BC_PIXEL_LEN);
                            runLength -= 8;
                        }
                        if (runLength)
                        {
                            /************************************************/
                            /* Keep the final partial byte clean to help    */
                            /* GDC packing                                  */
                            /************************************************/
                            ENCODEFGBG(*destbuf);
                            *destbuf &= ((0x01 << runLength) - 1);
                            destbuf++;
                            srcOffset += (runLength * BC_PIXEL_LEN);
                        }
                    }
                }
                break;


            case RUN_COLOR:
                /************************************************************/
                /* COLOR RUN                                                */
                /************************************************************/
                ENCODE_ORDER_MEGA(destbuf,
                                  CODE_COLOR_RUN,
                                  match[i].length,
                                  CODE_MEGA_MEGA_COLOR_RUN,
                                  MAX_LENGTH_ORDER,
                                  MAX_LENGTH_LONG_ORDER);
                BCTRACE((TB, "COLOR_RUN %u",match[i].length));

                BC_SET_PIXEL(destbuf, BC_GET_PIXEL(pSrc + srcOffset));
                BC_TO_NEXT_PIXEL(destbuf);

                srcOffset += (match[i].length * BC_PIXEL_LEN);
                break;

            case RUN_DITHER:
                /************************************************************/
                /* DITHERED RUN                                             */
                /************************************************************/
                {
                    unsigned ditherlen = match[i].length/2;
                    ENCODE_ORDER_MEGA(destbuf,
                                      CODE_DITHERED_RUN,
                                      ditherlen,
                                      CODE_MEGA_MEGA_DITHER,
                                      MAX_LENGTH_ORDER_LITE,
                                      MAX_LENGTH_LONG_ORDER_LITE);
                    BCTRACE((TB, "DITHERED_RUN %u",match[i].length));
                    /********************************************************/
                    /* First check for our approaching the end of the       */
                    /* destination buffer and get out if this is the case.  */
                    /********************************************************/
                    if ((unsigned)(destbuf - pDst + (2 * BC_PIXEL_LEN))
                                                              > dstBufferSize)
                    {
                        /****************************************************/
                        /* We are about to blow it so just get out          */
                        /****************************************************/
                        DC_QUIT;
                    }

                    /********************************************************/
                    /* Put the two pixels to dither with into the output    */
                    /* buffer                                               */
                    /********************************************************/
                    BC_SET_PIXEL(destbuf, BC_GET_PIXEL(pSrc + srcOffset));
                    BC_TO_NEXT_PIXEL(destbuf);

                    BC_SET_PIXEL(destbuf,
                             BC_GET_PIXEL(pSrc + srcOffset + BC_PIXEL_LEN));
                    BC_TO_NEXT_PIXEL(destbuf);

                    srcOffset += (match[i].length * BC_PIXEL_LEN);
                }
                break;

            case IMAGE_COLOR:
                /************************************************************/
                /* IMAGE_COLOR                                              */
                /************************************************************/
                /************************************************************/
                /* A length of 1 can possibly be encoded as a single        */
                /* "BLACK" or "WHITE"                                       */
                /************************************************************/
                if (match[i].length == 1)
                {
                    if (BC_GET_PIXEL(pSrc + srcOffset) == (BC_PIXEL)0)
                    {
                        *destbuf++ = CODE_BLACK;
                        srcOffset += BC_PIXEL_LEN;
                        BCTRACE((TB, "CODE_BLACK"));
                        break;
                    }
                    if (BC_GET_PIXEL(pSrc + srcOffset) == BC_DEFAULT_FGPEL)
                    {
                        *destbuf++ = CODE_WHITE;
                        srcOffset += BC_PIXEL_LEN;
                        BCTRACE((TB, "CODE_WHITE"));
                        break;
                    }
                }

                ENCODE_ORDER_MEGA(destbuf,
                                  CODE_COLOR_IMAGE,
                                  match[i].length,
                                  CODE_MEGA_MEGA_CLR_IMG,
                                  MAX_LENGTH_ORDER,
                                  MAX_LENGTH_LONG_ORDER);
                BCTRACE((TB, "COLOR_IMAGE %u",match[i].length));

                /************************************************************/
                /* First check for our approaching the end of the           */
                /* destination buffer and get out if this is the case.      */
                /************************************************************/
                if ((destbuf - pDst + (match[i].length * BC_PIXEL_LEN))
                                                              > dstBufferSize)
                {
                    /********************************************************/
                    /* We are about to blow it so just get out              */
                    /********************************************************/
                    DC_QUIT;
                }

                /************************************************************/
                /* Now just copy the data over                              */
                /************************************************************/
                memcpy(destbuf,
                       pSrc + srcOffset,
                       match[i].length * BC_PIXEL_LEN);
                destbuf   += match[i].length * BC_PIXEL_LEN;
                srcOffset += match[i].length * BC_PIXEL_LEN;

                break;

            default:
            {
                TRC_ERR((TB, "Invalid run type %u",match[i].type));
            }
        }
    }

    /************************************************************************/
    /* return the size of the compressed buffer                             */
    /************************************************************************/
    compressedLength = (unsigned)(destbuf - pDst);

DC_EXIT_POINT:
    DC_END_FN();
    return compressedLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\abcapi.h ===
/****************************************************************************/
/* abcapi.h                                                                 */
/*                                                                          */
/* Bitmap Compressor API Header File.                                       */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1996                             */
/* (C) 1997-1999 Microsoft Corp.                                            */
/****************************************************************************/
#ifndef _H_ABCAPI
#define _H_ABCAPI


/****************************************************************************/
/* Define the maximum amount of uncompressed data that we can handle in     */
/* one go.                                                                  */
/****************************************************************************/
#define MAX_UNCOMPRESSED_DATA_SIZE 32000L

#ifdef DC_HICOLOR
/****************************************************************************/
// The following structure contains the results of our intermediate scan of
// the buffer.
/****************************************************************************/
typedef struct {
    unsigned fgPel;
    unsigned length;
    BYTE     type;
} MATCH;
#endif

/****************************************************************************/
// Shared memory data. Since BC is present in both the WD and DD, we should
// only alloc this memory once. Note that it does not need to be zero-
// initialized.
/****************************************************************************/
typedef struct {
    // noBitmapCompressionHdr: flag to indidate if the client supports
    // compressed bitmap without redundent BC header or not.  The value
    // for this is TS_EXTRA_NO_BITMAP_COMPRESSION_HDR defined in REV2 bitmap
    // shm date needs to be aligned, so we need to add a pad.
    UINT16 noBitmapCompressionHdr;
    UINT16 pad1;

    // Work buffer. Note it is set to the max size we ever expect to see.
    // This has to include screen data buffers from SSI, and compressed
    // bitmaps from SBC.
//erikma: Adjust normal and xor bufs to 65536 and change BC_CompressBitmap
//to handle new size when we allow caches 4 and 5 to be activated.
    BYTE xor_buffer[MAX_UNCOMPRESSED_DATA_SIZE];

#ifdef DC_HICOLOR
    MATCH match[8192];
#ifdef DC_DEBUG
    BYTE  decompBuffer[MAX_UNCOMPRESSED_DATA_SIZE];
#endif
#endif

} BC_SHARED_DATA, *PBC_SHARED_DATA;


/****************************************************************************/
/* RLE codes                                                                */
/****************************************************************************/
/* The following codes fill a full single byte address space.  The approach */
/* is to use the high order bits to identify the code type and the low      */
/* order bits to encode the length of the associated run.  There are two    */
/* forms of order                                                           */
/* - regular orders which have a 5 bit length field (31 bytes of data)      */
/* - "lite" orders with a 4 bit length                                      */
/*                                                                          */
/* A value of 0 in the length field indicates an extended length, where     */
/* the following byte contains the length of the data.  There is also a     */
/* "mega mega" form which has a two byte length field. (See end of          */
/* codespace of the codes that define the megamega form).                   */
/*                                                                          */
/* A set of codes at the high end of the address space is used to encode    */
/* commonly occuring short sequences, in particular                         */
/* - certain single byte FGBG codings                                       */
/* - single bytes of BLACK and WHITE                                        */
/*                                                                          */
/*                                                                          */
/* SUMMARY                                                                  */
/* *******                                                                  */
/*                      7 6 5 4 3 2 1 0  76543210  76543210  76543210       */
/*                                                                          */
/* MEGA_BG_RUN          0 0 0 0 0 0 0 0  <length>                           */
/*                                                                          */
/* BG_RUN               0 0 0 <length->                                     */
/*                                                                          */
/* MEGA_FG_RUN          0 0 1 0 0 0 0 0  <length>                           */
/*                                                                          */
/* FG_RUN               0 0 1 <length->                                     */
/*                                                                          */
/* MEGA_FG_BG_IMAGE     0 1 0 0 0 0 0 0  <length>  <-data->  ...            */
/*                                                                          */
/* FG_BG_IMAGE          0 1 0 <length->  <-data->  ...                      */
/*                                                                          */
/* MEGA_COLOR_RUN       0 1 1 0 0 0 0 0  <length>  <-color>                 */
/*                                                                          */
/* COLOR_RUN            0 1 1 <length->  <color->                           */
/*                                                                          */
/* MEGA_COLOR_IMAGE     1 0 0 0 0 0 0 0  <length>  <-data->  ...            */
/*                                                                          */
/* COLOR_IMAGE          1 0 0 <length->  <-data->  ...                      */
/*                                                                          */
/* MEGA_PACKED_CLR_IMG  1 0 1 0 0 0 0 0  <length>  <-data->  ...            */
/*                                                                          */
/* PACKED COLOR IMAGE   1 0 1 <length->  <-data->  ...                      */
/*                                                                          */
/* SET_FG_MEGA_FG_RUN   1 1 0 0 0 0 0 0  <length>  <-color>                 */
/*                                                                          */
/* SET_FG_FG_RUN        1 1 0 0 <-len->  <color->                           */
/*                                                                          */
/* SET_FG_MEGA_FG_BG    1 1 0 1 0 0 0 0  <length>  <-color>  <-data->  ...  */
/*                                                                          */
/* SET_FG_FG_BG         1 1 0 1 <-len->  <color->  <-data->  ...            */
/*                                                                          */
/* MEGA_DITHERED_RUN    1 1 1 0 0 0 0 0  <length>  <-data->  <-data->       */
/*                                                                          */
/* DITHERED_RUN         1 1 1 0 <-len->  <-data->  <-data->                 */
/*                                                                          */
/* MEGA_MEGA_BG_RUN     1 1 1 1 0 0 0 0                                     */
/*                                                                          */
/* MEGA_MEGA_FG_RUN     1 1 1 1 0 0 0 1                                     */
/*                                                                          */
/* MEGA_MEGA_FGBG       1 1 1 1 0 0 1 0                                     */
/*                                                                          */
/* MEGA_MEGA_COLOR_RUN  1 1 1 1 0 0 1 1                                     */
/*                                                                          */
/* MEGA_MEGA_CLR_IMG    1 1 1 1 0 1 0 0                                     */
/*                                                                          */
/* MEGA_MEGA_PACKED_CLR 1 1 1 1 0 1 0 1                                     */
/*                                                                          */
/* MEGA_MEGA_SET_FG_RUN 1 1 1 1 0 1 1 0                                     */
/*                                                                          */
/* MEGA_MEGA_SET_FGBG   1 1 1 1 0 1 1 1                                     */
/*                                                                          */
/* MEGA_MEGA_DITHER     1 1 1 1 1 0 0 0                                     */
/*                                                                          */
/* Special FGBG code 1  1 1 1 1 1 0 0 1  FGBG code 0x03 = 11000000          */
/* (Note that 0x01 will generally handled by the single pel insertion code) */
/*                                                                          */
/* Special FBBG code 2  1 1 1 1 1 0 1 0  FGBG code 0x05 = 10100000          */
/*                                                                          */
#ifndef DC_HICOLOR
/* Special FBBG code 3  1 1 1 1 1 0 1 1  FGBG code 0x07 = 11100000          */
/*                                                                          */
/* Special FBBG code 4  1 1 1 1 1 1 0 0  FGBG code 0x0F = 11110000          */
/*                                                                          */
#endif
/* BLACK                1 1 1 1 1 1 0 1                                     */
/*                                                                          */
/* WHITE                1 1 1 1 1 1 1 0                                     */
/*                                                                          */
#ifndef DC_HICOLOR
/* START_LOSSY          1 1 1 1 1 1 1 1                                     */
/*                                                                          */
#endif
/****************************************************************************/
/* GENERAL NOTES                                                            */
/****************************************************************************/
/* - For MEGA runs the length encoded is the length of the run minus the    */
/*   maximum length of the non-mega form.                                   */
/*   In  the mega-mega form we encode the plain 16 bit length, to keep      */
/*   encoding/deconding simple.                                             */
/*                                                                          */
/* - The sequence BG_RUN,BG_RUN is not exactly what it appears.  We         */
/*   use the fact that this is not generated in normal encoding to          */
/*   encode <n background><1 foreground><n background>.  The same pel       */
/*   insertion convention applies to any combination of MEGA_BG run and     */
/*   BG_RUN                                                                 */
/*                                                                          */
/* - A packed image is encoded when we find that all the color fields in a  */
/*   run have 0 in the high order nibble. We do not currently use this code */
/*   for 8 bit compression, but it is supported by the V2 decoder.          */
/*                                                                          */
/* - The set fg color code (Used to exist in V1) has been retired in favor  */
/*   of separate commands for those codes that may embed a color.  Generally*/
/*   This saves one byte for every foreground color transition for 8bpp.    */
/*                                                                          */
/* - The color run code is new for V2.  It indicates a color run where the  */
/*   XOR is not performed.  This applies to, for example, the line of bits  */
/*   immediately below a text line.  (There is no special case for runs of  */
/*   the bg color - these are treated as any other color run.)              */
/*                                                                          */
/* - Observation shows a high occurrence of BG runs split by single FGBG    */
/*   codes.  In decreasing probability these are 3,5,7,9,f,11,1f,3f (1 is   */
/*   handled by the implicit BG run break). Save 1 byte by encoding as      */
/*   single codes                                                           */
/*                                                                          */
/* - There is a relatively high occurrence of single pel color codes ff and */
/*   00.  Save 1 byte by encoding as special characters                     */
/*                                                                          */
/* - The length in a FGBG run is slightly strange.  Because they generally  */
/*   occur in multiples of 8 bytes we get a big saving if we encode the     */
/*   length of a short run as length/8.  However, for those special         */
/*   cases where the length is not a multiple of 8 we encode a long run.    */
/*   Therefore the long form can only cover the range 1-256 bytes.          */
/*   beyond that we use the mega-mega form.                                 */
/*                                                                          */
/****************************************************************************/
/* DETAILS OF COMPRESSION CODES                                             */
/****************************************************************************/
// BG_RUN: Represents a background run (black:0) in the XOR buffer of the
// specified length.
//
// FG_BG_IMAGE/SET_FG_FG_BG_IMAGE: Represents a binary image containing only
// the current foreground(1) and background(0) colors from the XOR buffer.
//
// FG_RUN/SET_FG_FG_RUN: Represents a continuous foreground run of the
// specified length, in the XOR buffer. The foreground color is white (0xFF)
// by default, and is changed by the SET_FG_FG_RUN version of this code.
//
// DITHERED_RUN: Represents a run of alternating colors of the specified
// length from the normal (non-XOR) buffer.
//
// COLOR_IMAGE: Represents a color image of the specified length, taken
// from the normal (non-XOR) buffer. This data is uncompressed, so we hope
// that we won't see many of these codes!
//
// COLOR_RUN: Represents a color run of the specified length, taken from
// the normal (non-XOR) buffer. Since the color is not XORed, it is unlikely
// to match the running foreground color information. Therefore this code
// always carries a color byte and there is no SET_FG_COLOR_RUN form of the
// code.
//
// PACKED_COLOR_IMAGE (unused): Represents a color image of the specified
// length, with pairs of colors packed into a single byte. (This can only be
// done when the color info is zero in the high order nibble.)
//
// START_LOSSY (unused): Informs the decoder that lossy mode has been
// established and any of the following color runs will need pixel doubling
// performed. RLE decoding will remain in this mode until the end of this
// block.

#define CODE_MASK                   0xE0
#define CODE_MASK_LITE              0xF0

#define CODE_BG_RUN                 0x00   /* 20 */
#define CODE_FG_RUN                 0x20   /* 20 */
#define CODE_FG_BG_IMAGE            0x40   /* 20 */
#define CODE_COLOR_RUN              0x60   /* 20 */
#define CODE_COLOR_IMAGE            0x80   /* 20 */

#ifndef DC_HICOLOR // not used
#define CODE_PACKED_COLOR_IMAGE     0xA0   /* 20 */
#endif

#define CODE_SET_FG_FG_RUN          0xC0   /* 10 */
#define CODE_SET_FG_FG_BG           0xD0   /* 10 */
#define CODE_DITHERED_RUN           0xE0   /* 10 */
#define CODE_MEGA_MEGA_BG_RUN       0xF0
#define CODE_MEGA_MEGA_FG_RUN       0xF1
#define CODE_MEGA_MEGA_FGBG         0xF2
#define CODE_MEGA_MEGA_COLOR_RUN    0xF3
#define CODE_MEGA_MEGA_CLR_IMG      0xF4

#ifndef DC_HICOLOR // not used
#define CODE_MEGA_MEGA_PACKED_CLR   0xF5
#endif

#define CODE_MEGA_MEGA_SET_FG_RUN   0xF6
#define CODE_MEGA_MEGA_SET_FGBG     0xF7
#define CODE_MEGA_MEGA_DITHER       0xF8
#define CODE_SPECIAL_FGBG_1         0xF9
#define CODE_SPECIAL_FGBG_2         0xFA

#ifndef DC_HICOLOR // not used
#define CODE_SPECIAL_FGBG_3         0xFB
#define CODE_SPECIAL_FGBG_4         0xFC
#endif

#define CODE_WHITE                  0xFD
#define CODE_BLACK                  0xFE

#ifndef DC_HICOLOR // not used
#define CODE_START_LOSSY            0xFF
#endif

#define MAX_LENGTH_ORDER            31
#define MAX_LENGTH_LONG_ORDER       287

#define MAX_LENGTH_ORDER_LITE       15
#define MAX_LENGTH_LONG_ORDER_LITE  271

#define MAX_LENGTH_FGBG_ORDER       (31*8)
#define MAX_LENGTH_FGBG_ORDER_LITE  (15*8)
#define MAX_LENGTH_LONG_FGBG_ORDER  255

/****************************************************************************/
/* The special FGBG codes that correspond to codes F0-F7                    */
/****************************************************************************/
#define SPECIAL_FGBG_CODE_1         0x03
#define SPECIAL_FGBG_CODE_2         0x05
#define SPECIAL_FGBG_CODE_3         0x07
#define SPECIAL_FGBG_CODE_4         0x0F

/****************************************************************************/
/* Run types as stored in the run index array                               */
/****************************************************************************/
#define RUN_BG                      1
#define RUN_BG_PEL                  2
#define RUN_FG                      3
#define RUN_COLOR                   4
#define RUN_DITHER                  5
#define IMAGE_FGBG                  6
#define IMAGE_COLOR                 7

#ifndef DC_HICOLOR
#define IMAGE_LOSSY_ODD             8
#endif


// ShareClass includes the afn file directly, but in the DD we need these
// defs.
#ifdef DLL_DISP
#include <abcafn.h>
#endif



#endif   /* #ifndef _H_ABCAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\abcdata.c ===
/****************************************************************************/
/* abcdata.c                                                                */
/*                                                                          */
/* BC's data, replicated in each of WD and DD.                              */
/*                                                                          */
/* COPYRIGHT(C) Microsoft 1997-1999                                         */
/****************************************************************************/

#ifdef Unused
#include <ndcgdata.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\abdapi.h ===
/****************************************************************************/
/* abdapi.h                                                                 */
/*                                                                          */
/* Bitmap Decompression API header file                                     */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/****************************************************************************/
#ifndef _H_ABDAPI
#define _H_ABDAPI

/****************************************************************************/
/* RLE codes                                                                */
/****************************************************************************/
/*                                                                          */
/* The following codes fill a full single byte address space.  The approach */
/* is to use the high order bits to identify the code type and the low      */
/* order bits to encode the length of the associated run.  There are two    */
/* forms of order                                                           */
/* - regular orders which have a 5 bit length field (31 bytes of data)      */
/* - "lite" orders with a 4 bit length                                      */
/*                                                                          */
/* A value of 0 in the length field indicates an extended length, where     */
/* the following byte contains the length of the data.  There is also a     */
/* "mega mega" form which has a two byte length field. (See end of          */
/* codespace of the codes that define the megamega form).                   */
/*                                                                          */
/* A set of codes at the high end of the address space is used to encode    */
/* commonly occuring short sequences, in particular                         */
/* - certain single byte FGBG codings                                       */
/* - single bytes of BLACK and WHITE                                        */
/*                                                                          */
/*                                                                          */
/* SUMMARY                                                                  */
/* *******                                                                  */
/*                      7 6 5 4 3 2 1 0  76543210  76543210  76543210       */
/*                                                                          */
/* MEGA_BG_RUN          0 0 0 0 0 0 0 0  <length>                           */
/*                                                                          */
/* BG_RUN               0 0 0 <length->                                     */
/*                                                                          */
/* MEGA_FG_RUN          0 0 1 0 0 0 0 0  <length>                           */
/*                                                                          */
/* FG_RUN               0 0 1 <length->                                     */
/*                                                                          */
/* MEGA_FG_BG_IMAGE     0 1 0 0 0 0 0 0  <length>  <-data->  ...            */
/*                                                                          */
/* FG_BG_IMAGE          0 1 0 <length->  <-data->  ...                      */
/*                                                                          */
/* MEGA_COLOR_RUN       0 1 1 0 0 0 0 0  <length>  <-color>                 */
/*                                                                          */
/* COLOR_RUN            0 1 1 <length->  <color->                           */
/*                                                                          */
/* MEGA_COLOR_IMAGE     1 0 0 0 0 0 0 0  <length>  <-data->  ...            */
/*                                                                          */
/* COLOR_IMAGE          1 0 0 <length->  <-data->  ...                      */
/*                                                                          */
/* MEGA_PACKED_CLR_IMG  1 0 1 0 0 0 0 0  <length>  <-data->  ...            */
/*                                                                          */
/* PACKED COLOR IMAGE   1 0 1 <length->  <-data->  ...                      */
/*                                                                          */
/* SET_FG_MEGA_FG_RUN   1 1 0 0 0 0 0 0  <length>  <-color>                 */
/*                                                                          */
/* SET_FG_FG_RUN        1 1 0 0 <-len->  <color->                           */
/*                                                                          */
/* SET_FG_MEGA_FG_BG    1 1 0 1 0 0 0 0  <length>  <-color>  <-data->  ...  */
/*                                                                          */
/* SET_FG_FG_BG         1 1 0 1 <-len->  <color->  <-data->  ...            */
/*                                                                          */
/* MEGA_DITHERED_RUN    1 1 1 0 0 0 0 0  <length>  <-data->  <-data->       */
/*                                                                          */
/* DITHERED_RUN         1 1 1 0 <-len->  <-data->  <-data->                 */
/*                                                                          */
/* MEGA_MEGA_BG_RUN     1 1 1 1 0 0 0 0                                     */
/*                                                                          */
/* MEGA_MEGA_FG_RUN     1 1 1 1 0 0 0 1                                     */
/*                                                                          */
/* MEGA_MEGA_FGBG       1 1 1 1 0 0 1 0                                     */
/*                                                                          */
/* MEGA_MEGA_COLOR_RUN  1 1 1 1 0 0 1 1                                     */
/*                                                                          */
/* MEGA_MEGA_CLR_IMG    1 1 1 1 0 1 0 0                                     */
/*                                                                          */
/* MEGA_MEGA_PACKED_CLR 1 1 1 1 0 1 0 1                                     */
/*                                                                          */
/* MEGA_MEGA_SET_FG_RUN 1 1 1 1 0 1 1 0                                     */
/*                                                                          */
/* MEGA_MEGA_SET_FGBG   1 1 1 1 0 1 1 1                                     */
/*                                                                          */
/* MEGA_MEGA_DITHER     1 1 1 1 1 0 0 0                                     */
/*                                                                          */
/* Special FGBG code 1  1 1 1 1 1 0 0 1  FGBG code 0x03 = 11000000          */
/* (Note that 0x01 will generally handled by the single pel insertion code) */
/*                                                                          */
/* Special FBBG code 2  1 1 1 1 1 0 1 0  FGBG code 0x05 = 10100000          */
/*                                                                          */
/* Special FBBG code 3  1 1 1 1 1 0 1 1  FGBG code 0x07 = 11100000          */
/*                                                                          */
/* Special FBBG code 4  1 1 1 1 1 1 0 0  FGBG code 0x0F = 11110000          */
/*                                                                          */
/* BLACK                1 1 1 1 1 1 0 1                                     */
/*                                                                          */
/* WHITE                1 1 1 1 1 1 1 0                                     */
/*                                                                          */
/* START_LOSSY          1 1 1 1 1 1 1 1                                     */
/*                                                                          */
/*                                                                          */
/****************************************************************************/
/* GENERAL NOTES                                                            */
/****************************************************************************/
/*                                                                          */
/* - For MEGA runs the length encoded is the length of the run minus the    */
/*   maximum length of the non-mega form.                                   */
/*   In  the mega-mega form we encode the plain 16 bit length, to keep      */
/*   encoding/deconding simple.                                             */
/*                                                                          */
/* - The sequence BG_RUN,BG_RUN is not exactly what it appears.  We         */
/*   use the fact that this is not generated in normal encoding to          */
/*   encode <n background><1 foreground><n background>.  The same pel       */
/*   insertion convention applies to any combination of MEGA_BG run and     */
/*   BG_RUN                                                                 */
/*                                                                          */
/* - A packed image is encoded when we find that all the color fields in a  */
/*   run have 0 in the high order nibble. We do not currently use this code */
/*   for 8 bit compression, but it is supported by the V2 decoder.          */
/*                                                                          */
/* - The set fg color code (Used to exist in V1) has been retired in favor  */
/*   of separate commands for those codes that may embed a color.  Generally*/
/*   This saves one byte for every foreground color transition for 8bpp.    */
/*                                                                          */
/* - The color run code is new for V2.  It indicates a color run where the  */
/*   XOR is not performed.  This applies to, for example, the line of bits  */
/*   immediately below a text line.  (There is no special case for runs of  */
/*   the bg color - these are treated as any other color run.)              */
/*                                                                          */
/* - Observation shows a high occurrence of BG runs split by single FGBG    */
/*   codes.  In decreasing probability these are 3,5,7,9,f,11,1f,3f (1 is   */
/*   handled by the implicit BG run break). Save 1 byte by encoding as      */
/*   single codes                                                           */
/*                                                                          */
/* - There is a relatively high occurrence of single pel color codes ff and */
/*   00.  Save 1 byte by encoding as special characters                     */
/*                                                                          */
/* - The length in a FGBG run is slightly strange.  Because they generally  */
/*   occur in multiples of 8 bytes we get a big saving if we encode the     */
/*   length of a short run as length/8.  However, for those special         */
/*   cases where the length is not a multiple of 8 we encode a long run.    */
/*   Therefore the long form can only cover the range 1-256 bytes.          */
/*   beyond that we use the mega-mega form.                                 */
/*                                                                          */
/****************************************************************************/
/* DETAILS OF COMPRESSION CODES                                             */
/****************************************************************************/
/*                                                                          */
/* BG_RUN                                                                   */
/*                                                                          */
/* Represents a background run (black:0) of the specified length.           */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* FG_BG_IMAGE/SET_FG_FG_BG_IMAGE                                           */
/*                                                                          */
/* Represents a binary image containing only the current foreground(1) and  */
/* background(0) colors.                                                    */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* FG_RUN/SET_FG_FG_RUN                                                     */
/*                                                                          */
/* Represents a continuous foreground run of the specified length.          */
/* The foreground color is white by default, and is changed by the          */
/* SET_FG_FG_RUN version of this code.                                      */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* DITHERED_RUN                                                             */
/*                                                                          */
/* Represents a run of alternating colors of the specified length.          */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* COLOR_IMAGE                                                              */
/*                                                                          */
/* Represents a color image of the specified length.  No XOR is performed.  */
/* This data is uncompressed, so we hope that we won't see                  */
/* many of these codes!                                                     */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* COLOR_RUN                                                                */
/*                                                                          */
/* Represents a color run of the specified length.  No XOR is performed.    */
/* Since the color is not XORed, it is unlikely to match the running        */
/* foreground color information.  Therefore this code always carries a      */
/* color byte and there is no SET_FG_COLOR_RUN form of the code.            */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* PACKED_COLOR_IMAGE                                                       */
/*                                                                          */
/* Represents a color image of the specified length, with pairs of colors   */
/* packed into a single byte.  (This can only be done when the color info   */
/* is zero in the high order nibble.)                                       */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* START_LOSSY                                                              */
/*                                                                          */
/* Informs the decoder that lossy mode has been established and any of the  */
/* following color runs will need pixel doubling performing.                */
/* RLE decoding will remain in this mode until the end of this block        */
/*                                                                          */
/****************************************************************************/

#define CODE_MASK                   0xE0
#define CODE_MASK_LITE              0xF0

#define CODE_BG_RUN                 0x00   /* 20 */
#define CODE_FG_RUN                 0x20   /* 20 */
#define CODE_FG_BG_IMAGE            0x40   /* 20 */
#define CODE_COLOR_RUN              0x60   /* 20 */
#define CODE_COLOR_IMAGE            0x80   /* 20 */

#ifndef DC_HICOLOR // not used
#define CODE_PACKED_COLOR_IMAGE     0xA0   /* 20 */
#endif

#define CODE_SET_FG_FG_RUN          0xC0   /* 10 */
#define CODE_SET_FG_FG_BG           0xD0   /* 10 */
#define CODE_DITHERED_RUN           0xE0   /* 10 */
#define CODE_MEGA_MEGA_BG_RUN       0xF0
#define CODE_MEGA_MEGA_FG_RUN       0xF1
#define CODE_MEGA_MEGA_FGBG         0xF2
#define CODE_MEGA_MEGA_COLOR_RUN    0xF3
#define CODE_MEGA_MEGA_CLR_IMG      0xF4

#ifndef DC_HICOLOR // not used
#define CODE_MEGA_MEGA_PACKED_CLR   0xF5
#endif

#define CODE_MEGA_MEGA_SET_FG_RUN   0xF6
#define CODE_MEGA_MEGA_SET_FGBG     0xF7
#define CODE_MEGA_MEGA_DITHER       0xF8
#define CODE_SPECIAL_FGBG_1         0xF9
#define CODE_SPECIAL_FGBG_2         0xFA

#ifndef DC_HICOLOR // not used
#define CODE_SPECIAL_FGBG_3         0xFB
#define CODE_SPECIAL_FGBG_4         0xFC
#endif

#define CODE_WHITE                  0xFD
#define CODE_BLACK                  0xFE
#define CODE_START_LOSSY            0xFF

#define MAX_LENGTH_ORDER            31
#define MAX_LENGTH_LONG_ORDER       287

#define MAX_LENGTH_ORDER_LITE       15
#define MAX_LENGTH_LONG_ORDER_LITE  271

#define MAX_LENGTH_FGBG_ORDER       (31*8)
#define MAX_LENGTH_FGBG_ORDER_LITE  (15*8)
#define MAX_LENGTH_LONG_FGBG_ORDER  255

/****************************************************************************/
/* The special FGBG codes that correspond to codes F0-F7                    */
/****************************************************************************/
#define SPECIAL_FGBG_CODE_1         0x03
#define SPECIAL_FGBG_CODE_2         0x05
#define SPECIAL_FGBG_CODE_3         0x07
#define SPECIAL_FGBG_CODE_4         0x0F

/****************************************************************************/
/*                                                                          */
/* TYPES                                                                    */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* The Compressed Data header structure.                                    */
/****************************************************************************/
typedef struct _CD_HEADER
{
    TSUINT16    cbCompFirstRowSize;
    TSUINT16    cbCompMainBodySize;
    TSUINT16    cbScanWidth;
    TSUINT16    cbUncompressedSize;
} CD_HEADER;
typedef CD_HEADER *PCD_HEADER;

/****************************************************************************/
/*                                                                          */
/* FUNCTIONS                                                                */
/*                                                                          */
/****************************************************************************/

#ifdef DLL_DISP
HRESULT RDPCALL BD_DecompressBitmap( PBYTE  pCompressedData,
                                  PBYTE  pDstBitmap,
                                  unsigned int  srcDataSize,
                                  unsigned int  dstBufferSize,
                                  unsigned int    noBCHeader,
                                  BYTE   bitmapBitsPerPel,
                                  unsigned short  bitmapWidth,
                                  unsigned short  bitmapHeight );
#else
HRESULT RDPCALL BD_DecompressBitmap( PTSHARE_WD m_pTSWd,
                                  PBYTE  pCompressedData,
                                  PBYTE  pDstBitmap,
                                  unsigned int    srcDataSize,
                                  unsigned int    dstBufferSize,
                                  unsigned int    noBCHeader,
                                  BYTE   bitmapBitsPerPel,
                                  unsigned short  bitmapWidth,
                                  unsigned short  bitmapHeight );
#endif

#endif /* H_ABDAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\acaapi.h ===
/****************************************************************************/
/* acaapi.h                                                                 */
/*                                                                          */
/* RDP Control arbitrator API include file                                  */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1993-1997                             */
/* Copyright(c) Microsoft 1997-1999                                         */
/****************************************************************************/
#ifndef _H_ACAAPI
#define _H_ACAAPI


#define CA_EVENT_CANT_CONTROL       6
#define CA_EVENT_BEGIN_UNATTENDED   8
#define CA_EVENT_OLD_UNATTENDED     9

#define CA_EVENT_TAKE_CONTROL       50
#define CA_EVENT_COOPERATE_CONTROL  51
#define CA_EVENT_DETACH_CONTROL     52

#define CA_SEND_EVENT       (unsigned)1
#define CA_ALLOW_EVENT      (unsigned)2

#define CA_GIVE_MOUSE_TO_CA     1
#define CA_GIVE_MOUSE_TO_CM     2
#define CA_DISCARD_MOUSE        3

#define CA_LOCAL_KEYBOARD_DOWN  1
#define CA_LOCAL_KEYBOARD_UP    2


/****************************************************************************/
/* CA internal events                                                       */
/****************************************************************************/
#define CA_EVENTI_REQUEST_CONTROL           10
#define CA_EVENTI_TRY_GIVE_CONTROL          11
#define CA_EVENTI_GIVEN_CONTROL             12
#define CA_EVENTI_GRANTED_CONTROL           13
#define CA_EVENTI_ENTER_DETACHED_MODE       14
#define CA_EVENTI_ENTER_COOP_MODE           15
#define CA_EVENTI_ENTER_CONTROL_MODE        16
#define CA_EVENTI_ENTER_VIEWING_MODE        17
#define CA_EVENTI_REMOTE_DETACH             18
#define CA_EVENTI_REMOTE_COOPERATE          19
#define CA_EVENTI_SHARE_START               20
#define CA_EVENTI_GRAB_CONTROL              24

#define CA_STATE_DETACHED              1
#define CA_STATE_IN_CONTROL            2
#define CA_STATE_VIEWING               3

#define CA_DONT_SEND_MSG               1

/****************************************************************************/
/* Special message code for CAFlushAndSendMsg                               */
/****************************************************************************/
#define CA_NO_MESSAGE           0


/****************************************************************************/
/* TYPEDEFS                                                                 */
/****************************************************************************/

// Holds message info waiting to be sent.
typedef struct tagCAMSGDATA {
    BOOLEAN pending;
    UINT16  grantId;
    UINT32  controlId;
} CAMSGDATA, *PCAMSGDATA;


#endif /* _H_ACAAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\acaafn.h ===
/****************************************************************************/
// acaafn.h
//
// Function prototypes for CA API functions
//
// Copyright (C) 1996-2000 Microsoft Corporation
/****************************************************************************/

void RDPCALL CA_Init(void);

void RDPCALL SHCLASS CA_ReceivedPacket(PTS_CONTROL_PDU, unsigned,
        LOCALPERSONID);

BOOL RDPCALL CA_PartyJoiningShare(LOCALPERSONID, unsigned);

void RDPCALL CA_PartyLeftShare(LOCALPERSONID, unsigned);

void RDPCALL CA_SyncNow(void);

BOOL RDPCALL CASendMsg(UINT16, UINT16, UINT32);

BOOL RDPCALL CAFlushAndSendMsg(UINT16, UINT16, UINT32);

void RDPCALL CAEvent(unsigned, UINT32);


/****************************************************************************/
// CA_Term
/****************************************************************************/
void RDPCALL SHCLASS CA_Term()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\abdcom.c ===
/****************************************************************************/
/*                                                                          */
/* abdcom.c                                                                 */
/*                                                                          */
/* Copyright (c) Data Connection Limited 1998                               */
/*                                                                          */
/*                                                                          */
/* Bitmap decompression routine and macros for 16 and 24bpp protocol        */
/*                                                                          */
/****************************************************************************/

//  #ifdef BC_TRACE
//  #define BCTRACE TRC_DBG
//  #else
#define BCTRACE(string)
// #endif

/****************************************************************************/
/* We use the same helper macros as the 8bpp code except for STORE_FGBG.    */
/****************************************************************************/
/****************************************************************************/
/* Macro to store an FGBG image at destbuf                                  */
/*                                                                          */
/*  xorPel is either the value 0 or an expression containing the local      */
/*  variable destbuf.                                                       */
/*                                                                          */
/*  THIS MEANS THAT xorPel HAS A DIFFERENT VALUE EVERY TIME destbuf IS      */
/*  CHANGED.                                                                */
/*                                                                          */
/*  fgPel is a BC_PIXEL and the FG color to XOR with xorbyte                */
/*  fgbgChar is a bitmask telling which color to put where                  */
/*                                                                          */
/* This macro expects that the function defines pDst, pEndDst, hr           */
/* If there is not enough data to write the full run, this will set error   */
/* and quit                                                                 */
/****************************************************************************/
#undef  STORE_FGBG
#define STORE_FGBG(xorPelIn, fgbgChar, fgPel, bits)                          \
      {                                                                      \
        UINT   numbits = bits;                                             \
        BC_PIXEL xorPel;                                                     \
        BD_CHECK_WRITE_N_BYTES( destbuf, pEndDst, max(1, min(numbits, 8)) * BC_PIXEL_LEN, hr )           \
                                                                             \
        xorPel = BC_GET_PIXEL(xorPelIn);                                     \
        if (fgbgChar & 0x01)                                                 \
        {                                                                    \
            BC_SET_PIXEL(destbuf, xorPel ^ fgPel);                           \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            BC_SET_PIXEL(destbuf, xorPel);                                   \
        }                                                                    \
        BC_TO_NEXT_PIXEL(destbuf);                                           \
                                                                             \
        if (--numbits > 0)                                                   \
        {                                                                    \
          xorPel = BC_GET_PIXEL(xorPelIn);                                   \
          if (fgbgChar & 0x02)                                               \
          {                                                                  \
              BC_SET_PIXEL(destbuf, xorPel ^ fgPel);                         \
          }                                                                  \
          else                                                               \
          {                                                                  \
              BC_SET_PIXEL(destbuf, xorPel)                                  \
          }                                                                  \
          BC_TO_NEXT_PIXEL(destbuf);                                         \
                                                                             \
          if (--numbits > 0)                                                 \
          {                                                                  \
            xorPel = BC_GET_PIXEL(xorPelIn);                                 \
            if (fgbgChar & 0x04)                                             \
            {                                                                \
                BC_SET_PIXEL(destbuf, xorPel ^ fgPel);                       \
            }                                                                \
            else                                                             \
            {                                                                \
                BC_SET_PIXEL(destbuf, xorPel)                                \
            }                                                                \
            BC_TO_NEXT_PIXEL(destbuf);                                       \
                                                                             \
            if (--numbits > 0)                                               \
            {                                                                \
              xorPel = BC_GET_PIXEL(xorPelIn);                               \
              if (fgbgChar & 0x08)                                           \
              {                                                              \
                  BC_SET_PIXEL(destbuf, xorPel ^ fgPel);                     \
              }                                                              \
              else                                                           \
              {                                                              \
                  BC_SET_PIXEL(destbuf, xorPel);                             \
              }                                                              \
              BC_TO_NEXT_PIXEL(destbuf);                                     \
                                                                             \
              if (--numbits > 0)                                             \
              {                                                              \
                xorPel = BC_GET_PIXEL(xorPelIn);                             \
                if (fgbgChar & 0x10)                                         \
                {                                                            \
                    BC_SET_PIXEL(destbuf, xorPel ^ fgPel);                   \
                }                                                            \
                else                                                         \
                {                                                            \
                    BC_SET_PIXEL(destbuf, xorPel);                           \
                }                                                            \
                BC_TO_NEXT_PIXEL(destbuf);                                   \
                                                                             \
                if (--numbits > 0)                                           \
                {                                                            \
                  xorPel = BC_GET_PIXEL(xorPelIn);                           \
                  if (fgbgChar & 0x20)                                       \
                  {                                                          \
                      BC_SET_PIXEL(destbuf, xorPel ^ fgPel);                 \
                  }                                                          \
                  else                                                       \
                  {                                                          \
                      BC_SET_PIXEL(destbuf, xorPel);                         \
                  }                                                          \
                  BC_TO_NEXT_PIXEL(destbuf);                                 \
                                                                             \
                  if (--numbits > 0)                                         \
                  {                                                          \
                    xorPel = BC_GET_PIXEL(xorPelIn);                         \
                    if (fgbgChar & 0x40)                                     \
                    {                                                        \
                        BC_SET_PIXEL(destbuf, xorPel ^ fgPel);               \
                    }                                                        \
                    else                                                     \
                    {                                                        \
                        BC_SET_PIXEL(destbuf, xorPel);                       \
                    }                                                        \
                    BC_TO_NEXT_PIXEL(destbuf);                               \
                                                                             \
                    if (--numbits > 0)                                       \
                    {                                                        \
                      xorPel = BC_GET_PIXEL(xorPelIn);                       \
                      if (fgbgChar & 0x80)                                   \
                      {                                                      \
                          BC_SET_PIXEL(destbuf, xorPel ^ fgPel);             \
                      }                                                      \
                      else                                                   \
                      {                                                      \
                          BC_SET_PIXEL(destbuf, xorPel);                     \
                      }                                                      \
                      BC_TO_NEXT_PIXEL(destbuf);                             \
                    }                                                        \
                  }                                                          \
                }                                                            \
              }                                                              \
            }                                                                \
          }                                                                  \
        }                                                                    \
      }


#define STORE_LINE1_FGBG(fgbgChar, fgPel, bits)                              \
      {                                                                      \
        UINT   numbits = bits;                                             \
        BD_CHECK_WRITE_N_BYTES( destbuf, pEndDst, max(1, min(numbits, 8)) * BC_PIXEL_LEN, hr )           \
                                                                             \
        if (fgbgChar & 0x01)                                                 \
        {                                                                    \
            BC_SET_PIXEL(destbuf,  fgPel);                                   \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            BC_SET_PIXEL(destbuf, 0);                                        \
        }                                                                    \
        BC_TO_NEXT_PIXEL(destbuf);                                           \
                                                                             \
        if (--numbits > 0)                                                   \
        {                                                                    \
          if (fgbgChar & 0x02)                                               \
          {                                                                  \
              BC_SET_PIXEL(destbuf, fgPel);                                  \
          }                                                                  \
          else                                                               \
          {                                                                  \
              BC_SET_PIXEL(destbuf, 0)                                       \
          }                                                                  \
          BC_TO_NEXT_PIXEL(destbuf);                                         \
                                                                             \
          if (--numbits > 0)                                                 \
          {                                                                  \
            if (fgbgChar & 0x04)                                             \
            {                                                                \
                BC_SET_PIXEL(destbuf,  fgPel);                               \
            }                                                                \
            else                                                             \
            {                                                                \
                BC_SET_PIXEL(destbuf, 0)                                     \
            }                                                                \
            BC_TO_NEXT_PIXEL(destbuf);                                       \
                                                                             \
            if (--numbits > 0)                                               \
            {                                                                \
              if (fgbgChar & 0x08)                                           \
              {                                                              \
                  BC_SET_PIXEL(destbuf,  fgPel);                             \
              }                                                              \
              else                                                           \
              {                                                              \
                  BC_SET_PIXEL(destbuf, 0);                                  \
              }                                                              \
              BC_TO_NEXT_PIXEL(destbuf);                                     \
                                                                             \
              if (--numbits > 0)                                             \
              {                                                              \
                if (fgbgChar & 0x10)                                         \
                {                                                            \
                    BC_SET_PIXEL(destbuf,  fgPel);                           \
                }                                                            \
                else                                                         \
                {                                                            \
                    BC_SET_PIXEL(destbuf, 0);                                \
                }                                                            \
                BC_TO_NEXT_PIXEL(destbuf);                                   \
                                                                             \
                if (--numbits > 0)                                           \
                {                                                            \
                  if (fgbgChar & 0x20)                                       \
                  {                                                          \
                      BC_SET_PIXEL(destbuf,  fgPel);                         \
                  }                                                          \
                  else                                                       \
                  {                                                          \
                      BC_SET_PIXEL(destbuf, 0);                              \
                  }                                                          \
                  BC_TO_NEXT_PIXEL(destbuf);                                 \
                                                                             \
                  if (--numbits > 0)                                         \
                  {                                                          \
                    if (fgbgChar & 0x40)                                     \
                    {                                                        \
                        BC_SET_PIXEL(destbuf,  fgPel);                       \
                    }                                                        \
                    else                                                     \
                    {                                                        \
                        BC_SET_PIXEL(destbuf, 0);                            \
                    }                                                        \
                    BC_TO_NEXT_PIXEL(destbuf);                               \
                                                                             \
                    if (--numbits > 0)                                       \
                    {                                                        \
                      if (fgbgChar & 0x80)                                   \
                      {                                                      \
                          BC_SET_PIXEL(destbuf,  fgPel);                     \
                      }                                                      \
                      else                                                   \
                      {                                                      \
                          BC_SET_PIXEL(destbuf, 0);                          \
                      }                                                      \
                      BC_TO_NEXT_PIXEL(destbuf);                             \
                    }                                                        \
                  }                                                          \
                }                                                            \
              }                                                              \
            }                                                                \
          }                                                                  \
        }                                                                    \
      }

/****************************************************************************/
/* Decompression function begins here                                       */
/****************************************************************************/
/****************************************************************************/
/*                                                                          */
/*  PBYTE pSrc                                                           */
/*  PBYTE pDstBuffer                                                     */
/*  UINT   srcDataSize          total bytes in image                      */
/*  UINT   rowDelta             scanline length in bytes                  */
/*                                                                          */
/****************************************************************************/
{
    HRESULT hr = S_OK;
    UINT    codeLength;
    int     pixelLength;
    BYTE   bitMask;
    BYTE   decode;
    BYTE   decodeLite;
    BYTE   decodeMega;
    BC_PIXEL  fgPel              = BC_DEFAULT_FGPEL;
    BC_PIXEL  pixelA;
    BC_PIXEL  pixelB;
    PBYTE  destbuf            = pDstBuffer;
    PBYTE  endSrc             = pSrc + srcDataSize;
    PBYTE pEndDst  = destbuf + dstBufferSize;
    BOOL    backgroundNeedsPel = FALSE;
    BOOL    firstLine          = TRUE;

    DC_BEGIN_FN(BC_FN_NAME);

    /************************************************************************/
    /* Loop processing the input                                            */
    /************************************************************************/
    while (pSrc < endSrc)
    {
        /********************************************************************/
        /* While we are processing the first line we should keep a look out */
        /* for the end of the line                                          */
        /********************************************************************/
        if (firstLine)
        {
            if ((UINT)(destbuf - pDstBuffer) >= rowDelta)
            {
                firstLine = FALSE;
                backgroundNeedsPel = FALSE;
            }
        }

        /********************************************************************/
        /* Get the decode                                                   */
        /********************************************************************/
        BD_CHECK_READ_ONE_BYTE(pSrc, endSrc, hr);
        decode     = (BYTE)(*pSrc & CODE_MASK);
        decodeLite = (BYTE)(*pSrc & CODE_MASK_LITE);
        decodeMega = (BYTE)(*pSrc);

        /********************************************************************/
        /* BG RUN                                                           */
        /********************************************************************/
        if ((decode == CODE_BG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_BG_RUN))
        {
            if (decode == CODE_BG_RUN)
            {
                EXTRACT_LENGTH(pSrc, endSrc, codeLength, hr);
            }
            else
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, endSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            BCTRACE((TB, "Background run %u",codeLength));

            if (!firstLine)
            {
                if (backgroundNeedsPel)
                {
                    BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, BC_PIXEL_LEN, hr);
                    BD_CHECK_READ_N_BYTES_2ENDED(destbuf - rowDelta, pDstBuffer, pEndDst, BC_PIXEL_LEN, hr)
                    
                    BC_SET_PIXEL(destbuf,
                                 BC_GET_PIXEL(destbuf - rowDelta) ^ fgPel);
                    BC_TO_NEXT_PIXEL(destbuf);
                    codeLength--;
                }

                BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, BC_PIXEL_LEN * codeLength, hr);
                 
                while (codeLength-- > 0)
                {
                    BD_CHECK_READ_N_BYTES_2ENDED(destbuf - rowDelta, pDstBuffer, pEndDst, BC_PIXEL_LEN, hr)
                    BC_SET_PIXEL(destbuf, BC_GET_PIXEL(destbuf - rowDelta));
                    BC_TO_NEXT_PIXEL(destbuf);
                }
            }
            else
            {
                if (backgroundNeedsPel)
                {
                    BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, BC_PIXEL_LEN, hr);
                    BC_SET_PIXEL(destbuf, fgPel);
                    BC_TO_NEXT_PIXEL(destbuf);
                    codeLength--;
                }
                BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, BC_PIXEL_LEN * codeLength, hr);
                while (codeLength-- > 0)
                {
                    /********************************************************/
                    /* On the first line BG colour means 0                  */
                    /********************************************************/
                    BC_SET_PIXEL(destbuf, (BC_PIXEL)0);
                    BC_TO_NEXT_PIXEL(destbuf);
                }
            }
            /****************************************************************/
            /* A follow on BG run will need a pel inserted                  */
            /****************************************************************/
            backgroundNeedsPel = TRUE;
            continue;
        }

        /********************************************************************/
        /* For any of the other runtypes a follow on BG run does not need   */
        /* a FG pel inserted                                                */
        /********************************************************************/
        backgroundNeedsPel = FALSE;

        /********************************************************************/
        /* FGBG IMAGE                                                       */
        /********************************************************************/
        if ((decode == CODE_FG_BG_IMAGE)      ||
            (decodeLite == CODE_SET_FG_FG_BG) ||
            (decodeMega == CODE_MEGA_MEGA_FGBG)    ||
            (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
        {
            if ((decodeMega == CODE_MEGA_MEGA_FGBG) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, endSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                if (decode == CODE_FG_BG_IMAGE)
                {
                    EXTRACT_LENGTH_FGBG(pSrc, endSrc, codeLength, hr);
                }
                else
                {
                    EXTRACT_LENGTH_FGBG_LITE(pSrc, endSrc, codeLength, hr);
                }
            }

            if ((decodeLite == CODE_SET_FG_FG_BG) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
            {
                BD_CHECK_READ_N_BYTES(pSrc, endSrc, BC_PIXEL_LEN, hr);
                fgPel = BC_GET_PIXEL(pSrc);
                BC_TO_NEXT_PIXEL(pSrc);
                BCTRACE((TB, "Set FGBG image %u, fgPel %06lx",
                                                codeLength, (TSUINT32)fgPel));
            }
            else
            {
                BCTRACE((TB, "FGBG image     %u",codeLength));
            }

            while (codeLength > 8)
            {
                /************************************************************/
                /* A FGBG image is a set of bitmasks describing the         */
                /* positions of the FG and BG colors.                       */
                /************************************************************/
                BD_CHECK_READ_ONE_BYTE(pSrc, endSrc, hr);
                bitMask  = *pSrc++;
                if (!firstLine)
                {
                    BD_CHECK_READ_N_BYTES_2ENDED(destbuf - rowDelta, pDstBuffer, pEndDst, BC_PIXEL_LEN, hr)
                    STORE_FGBG((destbuf - rowDelta),
                               bitMask,
                               fgPel,
                               8);
                }
                else
                {
                    STORE_LINE1_FGBG(bitMask, fgPel, 8);
                }
                codeLength -= 8;
            }
            if (codeLength > 0)
            {
                BD_CHECK_READ_ONE_BYTE(pSrc, endSrc, hr);
                bitMask  = *pSrc++;
                if (!firstLine)
                {
                    BD_CHECK_READ_N_BYTES_2ENDED(destbuf - rowDelta, pDstBuffer, pEndDst, BC_PIXEL_LEN, hr)
                    STORE_FGBG((destbuf - rowDelta),
                               bitMask,
                               fgPel,
                               codeLength);
                }
                else
                {
                    STORE_LINE1_FGBG(bitMask, fgPel, codeLength);
                }
            }
            continue;
        }

        /********************************************************************/
        /* FG RUN                                                           */
        /********************************************************************/
        if ((decode == CODE_FG_RUN) ||
            (decodeLite == CODE_SET_FG_FG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_FG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_SET_FG_RUN))
        {

            if ((decodeMega == CODE_MEGA_MEGA_FG_RUN) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FG_RUN))
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, endSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                if (decode == CODE_FG_RUN)
                {
                    EXTRACT_LENGTH(pSrc, endSrc, codeLength, hr);
                }
                else
                {
                    EXTRACT_LENGTH_LITE(pSrc, endSrc, codeLength, hr);
                }
            }

            /****************************************************************/
            /* Push the old fgPel down to the ALT position                  */
            /****************************************************************/
            if ((decodeLite == CODE_SET_FG_FG_RUN) ||
                (decodeMega  == CODE_MEGA_MEGA_SET_FG_RUN))
            {
                BD_CHECK_READ_N_BYTES(pSrc, endSrc, BC_PIXEL_LEN, hr);
                BCTRACE((TB, "Set FG run     %u",codeLength));
                fgPel = BC_GET_PIXEL(pSrc);
                BC_TO_NEXT_PIXEL(pSrc);
            }
            else
            {
                BCTRACE((TB, "FG run         %u",codeLength));
            }

            BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, BC_PIXEL_LEN * codeLength, hr)
            while (codeLength-- > 0)
            {
                if (!firstLine)
                {
                    BD_CHECK_READ_N_BYTES_2ENDED(destbuf - rowDelta, pDstBuffer, pEndDst, BC_PIXEL_LEN, hr)
                    BC_SET_PIXEL(destbuf,
                                 BC_GET_PIXEL(destbuf - rowDelta) ^ fgPel);
                    BC_TO_NEXT_PIXEL(destbuf);
                }
                else
                {
                    BC_SET_PIXEL(destbuf, fgPel);
                    BC_TO_NEXT_PIXEL(destbuf);
                }
            }
            continue;
        }

        /********************************************************************/
        /* DITHERED RUN                                                     */
        /********************************************************************/
        if ((decodeLite == CODE_DITHERED_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_DITHER))
        {
            if (decodeMega == CODE_MEGA_MEGA_DITHER)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, endSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH_LITE(pSrc, endSrc, codeLength, hr);
            }
            BCTRACE((TB, "Dithered run   %u",codeLength));

            BD_CHECK_READ_N_BYTES(pSrc, endSrc, BC_PIXEL_LEN * 2, hr);
            pixelA = BC_GET_PIXEL(pSrc);
            BC_TO_NEXT_PIXEL(pSrc);
            pixelB = BC_GET_PIXEL(pSrc);
            BC_TO_NEXT_PIXEL(pSrc);

            BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, 2 * codeLength * BC_PIXEL_LEN, hr)
            while (codeLength-- > 0)
            {
                BC_SET_PIXEL(destbuf, pixelA);
                BC_TO_NEXT_PIXEL(destbuf);

                BC_SET_PIXEL(destbuf, pixelB);
                BC_TO_NEXT_PIXEL(destbuf);
            }
            continue;
        }

        /********************************************************************/
        /* COLOR IMAGE                                                      */
        /********************************************************************/
        if ((decode == CODE_COLOR_IMAGE) ||
            (decodeMega == CODE_MEGA_MEGA_CLR_IMG))
        {
            if (decodeMega == CODE_MEGA_MEGA_CLR_IMG)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, endSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, endSrc, codeLength, hr);
            }
            BCTRACE((TB, "Color image    %u",codeLength));

            /****************************************************************/
            /* Just copy the pixel values across                            */
            /****************************************************************/
            pixelLength = (codeLength * BC_PIXEL_LEN);
            BD_CHECK_READ_N_BYTES(pSrc, endSrc, pixelLength, hr);
            BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, pixelLength, hr);
            while (pixelLength-- > 0)
            {
                *destbuf++ = *pSrc++;
            }

            continue;
        }

        /********************************************************************/
        /* COLOR RUN                                                        */
        /********************************************************************/
        if ((decode == CODE_COLOR_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_COLOR_RUN))
        {
            if (decodeMega == CODE_MEGA_MEGA_COLOR_RUN)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, endSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, endSrc, codeLength, hr);
            }
            BCTRACE((TB, "Color run      %u",codeLength));

            BD_CHECK_READ_N_BYTES(pSrc, endSrc, BC_PIXEL_LEN, hr);
            pixelA = BC_GET_PIXEL(pSrc);
            BC_TO_NEXT_PIXEL(pSrc);

            BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, codeLength * BC_PIXEL_LEN, hr)
            while (codeLength-- > 0)
            {
                BC_SET_PIXEL(destbuf, pixelA);
                BC_TO_NEXT_PIXEL(destbuf);
            }
            continue;
        }


        /********************************************************************/
        /* If we get here then the code must be a special one               */
        /********************************************************************/
        BCTRACE((TB, "Special code   %x",decodeMega));
        switch (decodeMega)
        {
            case CODE_BLACK:
                BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, BC_PIXEL_LEN, hr)
                BC_SET_PIXEL(destbuf, (BC_PIXEL)0);
                BC_TO_NEXT_PIXEL(destbuf);
                break;

            case CODE_WHITE:
                BD_CHECK_WRITE_N_BYTES(destbuf, pEndDst, BC_PIXEL_LEN, hr)
                BC_SET_PIXEL(destbuf, BC_DEFAULT_FGPEL);
                BC_TO_NEXT_PIXEL(destbuf);
                break;

            /****************************************************************/
            /* Ignore the unreachable code warnings that follow             */
            /* Simply because we use the STORE_FGBG macro with a constant   */
            /* value                                                        */
            /****************************************************************/
            case CODE_SPECIAL_FGBG_1:
                if (!firstLine)
                {
                    BD_CHECK_READ_N_BYTES_2ENDED(destbuf - rowDelta, pDstBuffer, pEndDst, BC_PIXEL_LEN, hr)
                    STORE_FGBG((destbuf - rowDelta),
                               SPECIAL_FGBG_CODE_1,
                               fgPel,
                               8);
                }
                else
                {
                    STORE_LINE1_FGBG(SPECIAL_FGBG_CODE_1, fgPel, 8);
                }
                break;

            case CODE_SPECIAL_FGBG_2:
                if (!firstLine)
                {
                    BD_CHECK_READ_N_BYTES_2ENDED(destbuf - rowDelta, pDstBuffer, pEndDst, BC_PIXEL_LEN, hr)
                    STORE_FGBG((destbuf - rowDelta),
                               SPECIAL_FGBG_CODE_2,
                               fgPel,
                               8);
                }
                else
                {
                    STORE_LINE1_FGBG(SPECIAL_FGBG_CODE_2, fgPel, 8);
                }
                break;


            default:
                {
                    BCTRACE((TB, "Invalid compression data %x",decodeMega));
                }
                break;
        }
        pSrc++;

    }

    BCTRACE((TB, "Decompressed to %u bytes", destbuf - pDstBuffer));

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\abdapi.c ===
#include <winerror.h>

/****************************************************************************/
/* abdapi.c                                                                 */
/*                                                                          */
/* Bitmap Decompression API functions                                       */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1996-1999                             */
/****************************************************************************/
#define DC_EXTRACT_UINT16_UA(pA) ((unsigned short)  (((PBYTE)(pA))[0]) |        \
                                  (unsigned short) ((((PBYTE)(pA))[1]) << 8) )


/****************************************************************************/
/* Name:      BDMemcpy                                                      */
/*                                                                          */
/* Purpose:   Copies a given number of bytes from source to destination.    */
/*            Source and destination may overlap, but copy is always        */
/*            performed upwards (from start address onwards).               */
/*                                                                          */
/* Params:    pDst - pointer to destination                                 */
/*            pSrc - pointer to source data                                 */
/*            count - number of bytes to copy                               */
/****************************************************************************/
_inline void RDPCALL BDMemcpy(PBYTE pDst, PBYTE pSrc, unsigned int count)
{
#if defined(DC_DEBUG) || defined(DC_NO_UNALIGNED) || defined(_M_IA64)
    unsigned int      i;
#endif

    DC_BEGIN_FN("BDMemcpy");

    /************************************************************************/
    /* Bitmap decompression deliberately does overlapped memcpys, e.g.      */
    /* from the previous bitmap row to the current bitmap row for more than */
    /* one row.                                                             */
    /*                                                                      */
    /* When using the intrinsic memcpy (in the retail build) this works     */
    /* fine (in the current implementation of the MS compiler), as the copy */
    /* always goes upwards through memory.  However, if we use the MSVC     */
    /* run-time library (in the debug build) then memcpy appears to check   */
    /* for overlap and performs the copy so as to avoid clashing of src and */
    /* dst (i.e.  effectively performs a memmove).  Therefore this does not */
    /* do what we want, so manually copy the bytes in a debug build.        */
    /*                                                                      */
    /* This solution is a little unsatisfactory, as the operation of memset */
    /* is officially undefined, but the performance-critical nature of      */
    /* this bit of code means that we really do want to use a memcpy.       */
    /*                                                                      */
    /* For non-Intel platforms, cannot rely on the above - so always use    */
    /* manual version.                                                      */
    /*                                                                      */
    /************************************************************************/

#if defined(DC_DEBUG) || defined(DC_NO_UNALIGNED) || defined(_M_IA64)
    /************************************************************************/
    /* Debug build implementation.                                          */
    /************************************************************************/
    for (i = 0; i < count; i++)
    {
        *pDst++ = *pSrc++;
    }
#else
    /************************************************************************/
    /* Retail build implementation.                                         */
    /************************************************************************/
    DC_MEMCPY(pDst, pSrc, count);
#endif

    DC_END_FN();
    return;
}

/****************************************************************************/
/* Utility macros for decoding codes                                        */
/****************************************************************************/
#define CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr, trc )     \
{\
    if (((BYTE*)(pBuffer)) >= (BYTE*)(pEnd)) {      \
        BCTRACE( trc );        \
        hr = E_FAIL;        \
        DC_QUIT;        \
    } \
}

#define CHECK_READ_ONE_BYTE_2ENDED(pBuffer, pStart, pEnd, hr, trc )     \
{\
    if (((BYTE*)(pBuffer)) >= (BYTE*)(pEnd) || \
        (BYTE*)(pBuffer) < (BYTE*)(pStart)) {      \
        BCTRACE( trc );        \
        hr = E_FAIL;        \
        DC_QUIT;        \
    } \
}

#define CHECK_WRITE_ONE_BYTE(pBuffer, pEnd, hr, trc )     \
{\
    if (((BYTE*)(pBuffer)) >= (BYTE*)(pEnd)) {      \
        BCTRACE( trc );        \
        hr = E_FAIL;        \
        DC_QUIT;        \
    } \
}

#define CHECK_WRITE_ONE_BYTE_NO_HR(pBuffer, pEnd, trc )     \
{\
    if (((BYTE*)(pBuffer)) >= (BYTE*)(pEnd)) {      \
        BCTRACE( trc );        \
        DC_QUIT;        \
    } \
}

#define CHECK_READ_N_BYTES(pBuffer, pEnd, N, hr, trc )     \
{\
    if (((BYTE*)(pBuffer)) + (N) > (BYTE*)(pEnd)) {      \
        BCTRACE( trc );        \
        hr = E_FAIL;        \
        DC_QUIT;        \
    }  \
}

#define CHECK_READ_N_BYTES_NO_HR(pBuffer, pEnd, N, trc )     \
{\
    if (((BYTE*)(pBuffer)) + (N) > (BYTE*)(pEnd)) {      \
        BCTRACE( trc );        \
        DC_QUIT;        \
    }  \
}

#define CHECK_READ_N_BYTES_2ENDED(pBuffer, pStart, pEnd, N, hr, trc )     \
{\
    if (((BYTE*)(pBuffer)) + (N) > (BYTE*)(pEnd) || \
        ((BYTE*)(pBuffer) < (BYTE*)(pStart)) ) {      \
        BCTRACE( trc );        \
        hr = E_FAIL;        \
        DC_QUIT;        \
    }  \
}

#define CHECK_WRITE_N_BYTES(pBuffer, pEnd, N, hr, trc )     \
{\
    if (((BYTE*)(pBuffer)) + (N) > (BYTE*)(pEnd)) {      \
        BCTRACE( trc );        \
        hr = E_FAIL;        \
        DC_QUIT;        \
    }  \
}

#define CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEnd, N, trc )     \
{\
    if (((BYTE*)(pBuffer)) + (N) > (BYTE*)(pEnd)) {      \
        BCTRACE( trc );        \
        DC_QUIT;        \
    }  \
}

#define BD_CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr )     \
    CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr, \
        (TB, "Decompress reads one byte end of buffer; [p=0x%x pEnd=0x%x]", \
        (pBuffer), (pEnd) ))

#define BD_CHECK_READ_ONE_BYTE_2ENDED(pBuffer, pStart, pEnd, hr )     \
    CHECK_READ_ONE_BYTE_2ENDED(pBuffer, pStart, pEnd, hr, (TB, "Decompress reads one byte off end of buffer; [p=0x%x pStart=0x%x pEnd=0x%x]", \
        (pBuffer), (pStart), (pEnd) ))

#define BD_CHECK_WRITE_ONE_BYTE(pBuffer, pEnd, hr )     \
    CHECK_WRITE_ONE_BYTE(pBuffer, pEnd, hr, (TB, "Decompress writes one byte off end of buffer; [p=0x%x pEnd=0x%x]", \
        (pBuffer), (pEnd) ))

#define BD_CHECK_READ_N_BYTES(pBuffer, pEnd, N, hr )     \
    CHECK_READ_N_BYTES(pBuffer, pEnd, N, hr, (TB, "Decompress reads off end of buffer; [p=0x%x pEnd=0x%x N=%u]", \
        (pBuffer), (pEnd), (ULONG)(N)))

#define BD_CHECK_READ_N_BYTES_2ENDED(pBuffer, pStart, pEnd, N, hr )     \
    CHECK_READ_N_BYTES_2ENDED(pBuffer, pStart, pEnd, N, hr, (TB, "Decompress reads off end of buffer; [p=0x%x pStart=0x%x pEnd=0x%x N=%u]", \
        (pBuffer), (pStart), (pEnd), (ULONG)(N) ))

#define BD_CHECK_WRITE_N_BYTES(pBuffer, pEnd, N, hr )     \
    CHECK_WRITE_N_BYTES(pBuffer, pEnd, N, hr, (TB, "Decompress write off end of buffer; [p=0x%x pEnd=0x%x N=%u]", \
        (pBuffer), (pEnd), (ULONG)(N)))


/****************************************************************************/
/* Macros to extract the length from order codes                            */
/****************************************************************************/
#define EXTRACT_LENGTH(pBuffer, pEnd, length, hr)                                      \
        BD_CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr )         \
        length = *pBuffer++ & MAX_LENGTH_ORDER;                              \
	if (length == 0)									\
	{												\
            BD_CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr )         \
            length = *pBuffer++ + MAX_LENGTH_ORDER + 1;                      \
        }

#define EXTRACT_LENGTH_LITE(pBuffer, pEnd, length, hr )                                 \
        BD_CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr )         \
        length = *pBuffer++ & MAX_LENGTH_ORDER_LITE;                         \
        if (length == 0)                                                     \
        {                                                                    \
            BD_CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr )         \
            length = *pBuffer++ + MAX_LENGTH_ORDER_LITE + 1;                 \
        }

#define EXTRACT_LENGTH_FGBG(pBuffer, pEnd, length, hr )                                 \
        BD_CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr )         \
        length = *pBuffer++ & MAX_LENGTH_ORDER;                              \
        if (length == 0)                                                     \
        {                                                                    \
            BD_CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr )         \
            length = *pBuffer++ + 1;                                         \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            length = length << 3;                                            \
        }

#define EXTRACT_LENGTH_FGBG_LITE(pBuffer, pEnd, length, hr)                            \
        BD_CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr )         \
        length = *pBuffer++ & MAX_LENGTH_ORDER_LITE;                         \
        if (length == 0)                                                     \
        {                                                                    \
            BD_CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr )         \
            length = *pBuffer++ + 1;                                         \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            length = length << 3;                                            \
        }

/****************************************************************************/
/* Macro to store an FGBG image                                             */
/* This macro expects that the function defines pDst, pEndDst, hr           */
/* If there is not enough data to write the full run, this will set error   */
/* and quit                                                                 */
/****************************************************************************/
#define STORE_FGBG(xorbyte, fgbgChar, fgChar, bits)                          \
{                                                                            \
    unsigned int   numbits = bits;                                                 \
    BD_CHECK_WRITE_N_BYTES( pDst, pEndDst, max(1, min(numbits, 8)), hr )           \
    if (fgbgChar & 0x01)                                                     \
    {                                                                        \
        *pDst++ = (BYTE)(xorbyte ^ fgChar);                               \
    }                                                                        \
    else                                                                     \
    {                                                                        \
        *pDst++ = xorbyte;                                                   \
    }                                                                        \
    if (--numbits > 0)                                                       \
    {                                                                        \
      if (fgbgChar & 0x02)                                                   \
      {                                                                      \
          *pDst++ = (BYTE)(xorbyte ^ fgChar);                             \
      }                                                                      \
      else                                                                   \
      {                                                                      \
          *pDst++ = xorbyte;                                                 \
      }                                                                      \
      if (--numbits > 0)                                                     \
      {                                                                      \
        if (fgbgChar & 0x04)                                                 \
        {                                                                    \
            *pDst++ = (BYTE)(xorbyte ^ fgChar);                           \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            *pDst++ = xorbyte;                                               \
        }                                                                    \
        if (--numbits > 0)                                                   \
        {                                                                    \
          if (fgbgChar & 0x08)                                               \
          {                                                                  \
              *pDst++ = (BYTE)(xorbyte ^ fgChar);                         \
          }                                                                  \
          else                                                               \
          {                                                                  \
              *pDst++ = xorbyte;                                             \
          }                                                                  \
          if (--numbits > 0)                                                 \
          {                                                                  \
            if (fgbgChar & 0x10)                                             \
            {                                                                \
                *pDst++ = (BYTE)(xorbyte ^ fgChar);                       \
            }                                                                \
            else                                                             \
            {                                                                \
                *pDst++ = xorbyte;                                           \
            }                                                                \
            if (--numbits > 0)                                               \
            {                                                                \
              if (fgbgChar & 0x20)                                           \
              {                                                              \
                  *pDst++ = (BYTE)(xorbyte ^ fgChar);                     \
              }                                                              \
              else                                                           \
              {                                                              \
                  *pDst++ = xorbyte;                                         \
              }                                                              \
              if (--numbits > 0)                                             \
              {                                                              \
                if (fgbgChar & 0x40)                                         \
                {                                                            \
                    *pDst++ = (BYTE)(xorbyte ^ fgChar);                   \
                }                                                            \
                else                                                         \
                {                                                            \
                    *pDst++ = xorbyte;                                       \
                }                                                            \
                if (--numbits > 0)                                           \
                {                                                            \
                  if (fgbgChar & 0x80)                                       \
                  {                                                          \
                      *pDst++ = (BYTE)(xorbyte ^ fgChar);                 \
                  }                                                          \
                  else                                                       \
                  {                                                          \
                      *pDst++ = xorbyte;                                     \
                  }                                                          \
                }                                                            \
              }                                                              \
            }                                                                \
          }                                                                  \
        }                                                                    \
      }                                                                      \
    }                                                                        \
}

#ifdef DC_HICOLOR
/****************************************************************************/
/* 8bpp decompression                                                       */
/****************************************************************************/
#define BCTRACE(string)
_inline HRESULT RDPCALL  BDDecompressBitmap8( PBYTE  pSrc,
                                          PBYTE  pDstBuffer,
                                          unsigned int    compressedDataSize,
                                          unsigned int    dstBufferSize,
                                          BYTE   bitmapBitsPerPel,
                                          unsigned short  rowDelta)
{
    HRESULT hr = S_OK;
    unsigned int     codeLength;
    BYTE    codeByte;
    BYTE    codeByte2;
    BYTE    decode;
    BYTE    decodeLite;
    BYTE    decodeMega;
    BYTE    fgChar;
    PBYTE   pDst;
    PBYTE   pEndSrc;
    PBYTE   pEndDst;
    BOOL     backgroundNeedsPel;
    BOOL     firstLine;

    DC_BEGIN_FN("BDDecompressBitmap8");

    pEndSrc = pSrc + compressedDataSize;
    pDst    = pDstBuffer;
    pEndDst = pDst + dstBufferSize;

    fgChar = 0xFF;
    backgroundNeedsPel = FALSE;
    firstLine = TRUE;

    /************************************************************************/
    /*                                                                      */
    /* Main decompression loop                                              */
    /*                                                                      */
    /************************************************************************/
    while (pSrc < pEndSrc)
    {
        /********************************************************************/
        /* While we are processing the first line we should keep a look out */
        /* for the end of the line                                          */
        /********************************************************************/
        if (firstLine)
        {
            if ((unsigned int)(pDst - pDstBuffer) >= rowDelta)
            {
                firstLine = FALSE;
                backgroundNeedsPel = FALSE;
            }
        }

        /********************************************************************/
        /* Get the decode                                                   */
        /********************************************************************/
        BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
        decode     = (BYTE)(*pSrc & CODE_MASK);
        decodeLite = (BYTE)(*pSrc & CODE_MASK_LITE);
        decodeMega = (BYTE)(*pSrc);

        /********************************************************************/
        /* BG RUN                                                           */
        /********************************************************************/
        if ((decode == CODE_BG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_BG_RUN))
        {
            if (decode == CODE_BG_RUN)
            {
                EXTRACT_LENGTH(pSrc, pEndSrc, codeLength, hr);
            }
            else
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            BCTRACE((TB, "Background run %u",codeLength));

            if (!firstLine)
            {
                if (backgroundNeedsPel)
                {
                    BD_CHECK_WRITE_ONE_BYTE(pDst, pEndDst, hr);
                    BD_CHECK_READ_ONE_BYTE_2ENDED(pDst - rowDelta, pDstBuffer, pEndDst, hr);
                    *pDst++ = (BYTE)(*(pDst - rowDelta) ^ fgChar);
                    codeLength--;
                }

                BD_CHECK_READ_N_BYTES_2ENDED(pDst-rowDelta, pDstBuffer, pEndDst, codeLength, hr)
                BD_CHECK_WRITE_N_BYTES( pDst, pEndDst, codeLength, hr)
                BDMemcpy(pDst, pDst-rowDelta, codeLength);
                pDst += codeLength;
            }
            else
            {
                if (backgroundNeedsPel)
                {
                    BD_CHECK_WRITE_ONE_BYTE(pDst, pEndDst, hr)
                    *pDst++ = fgChar;
                    codeLength--;
                }

                BD_CHECK_WRITE_N_BYTES( pDst, pEndDst, codeLength, hr)
                memset(pDst, 0x00, codeLength);
                pDst += codeLength;
            }

            /****************************************************************/
            /* A follow on BG run will need a pel inserted                  */
            /****************************************************************/
            backgroundNeedsPel = TRUE;
            continue;
        }

        /********************************************************************/
        /* For any of the other runtypes a follow on BG run does not need   */
        /* a FG pel inserted                                                */
        /********************************************************************/
        backgroundNeedsPel = FALSE;

        /********************************************************************/
        /* FGBG IMAGE                                                       */
        /********************************************************************/
        if ((decode == CODE_FG_BG_IMAGE)      ||
            (decodeLite == CODE_SET_FG_FG_BG) ||
            (decodeMega == CODE_MEGA_MEGA_FGBG)    ||
            (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
        {
            if ((decodeMega == CODE_MEGA_MEGA_FGBG) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                if (decode == CODE_FG_BG_IMAGE)
                {
                    EXTRACT_LENGTH_FGBG(pSrc, pEndSrc, codeLength, hr);
                }
                else
                {
                    EXTRACT_LENGTH_FGBG_LITE(pSrc, pEndSrc, codeLength, hr);
                }
            }

            if ((decodeLite == CODE_SET_FG_FG_BG) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
            {
                BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
                fgChar = *pSrc++;
                BCTRACE((TB, "Set FGBG image %u",codeLength));
            }
            else
            {
                BCTRACE((TB, "FGBG image     %u",codeLength));
            }

            while (codeLength > 8)
            {
                BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
                codeByte  = *pSrc++;
                if (firstLine)
                {
                    STORE_FGBG(0x00, codeByte, fgChar, 8);
                }
                else
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED( pDst-rowDelta, pDstBuffer, pEndDst, hr )
                    STORE_FGBG(*(pDst - rowDelta), codeByte, fgChar, 8);
                }
                codeLength -= 8;
            }
            if (codeLength > 0)
            {
                BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
                codeByte  = *pSrc++;
                if (firstLine)
                {
                    STORE_FGBG(0x00, codeByte, fgChar, codeLength);
                }
                else
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED( pDst -rowDelta, pDstBuffer, pEndDst, hr )
                   STORE_FGBG(*(pDst - rowDelta),
                              codeByte,
                              fgChar,
                              codeLength);
                }
            }
            continue;
        }

        /********************************************************************/
        /* FG RUN                                                           */
        /********************************************************************/
        if ((decode == CODE_FG_RUN) ||
            (decodeLite == CODE_SET_FG_FG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_FG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_SET_FG_RUN))
        {
            if ((decodeMega == CODE_MEGA_MEGA_FG_RUN) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FG_RUN))
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                if (decode == CODE_FG_RUN)
                {
                    EXTRACT_LENGTH(pSrc, pEndSrc, codeLength, hr);
                }
                else
                {
                    EXTRACT_LENGTH_LITE(pSrc, pEndSrc, codeLength, hr);
                }
            }

            /****************************************************************/
            /* Push the old fgChar down to the ALT position                 */
            /****************************************************************/
            if ((decodeLite == CODE_SET_FG_FG_RUN) ||
                (decodeMega  == CODE_MEGA_MEGA_SET_FG_RUN))
            {
                BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
                BCTRACE((TB, "Set FG run     %u",codeLength));
                fgChar    = *pSrc++;
            }
            else
            {
                BCTRACE((TB, "FG run         %u",codeLength));
            }

            BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength, hr)
            while (codeLength-- > 0)
            {
                if (!firstLine)
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED((pDst -rowDelta), pDstBuffer, pEndDst, hr)
                    *pDst++ = (BYTE)(*(pDst - rowDelta) ^ fgChar);
                }
                else
                {
                    *pDst++ = fgChar;
                }
            }
            continue;
        }

        /********************************************************************/
        /* DITHERED RUN                                                     */
        /********************************************************************/
        if ((decodeLite == CODE_DITHERED_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_DITHER))
        {
            if (decodeMega == CODE_MEGA_MEGA_DITHER)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH_LITE(pSrc, pEndSrc, codeLength, hr);
            }
            BCTRACE((TB, "Dithered run   %u",codeLength));

            BD_CHECK_READ_N_BYTES(pSrc, pEndSrc, 2, hr);
            codeByte  = *pSrc++;
            codeByte2 = *pSrc++;

            BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength * 2, hr)
            while (codeLength-- > 0)
            {
                *pDst++ = codeByte;
                *pDst++ = codeByte2;
            }
            continue;
        }

        /********************************************************************/
        /* COLOR IMAGE                                                      */
        /********************************************************************/
        if ((decode == CODE_COLOR_IMAGE) ||
            (decodeMega == CODE_MEGA_MEGA_CLR_IMG))
        {
            if (decodeMega == CODE_MEGA_MEGA_CLR_IMG)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, pEndSrc, codeLength, hr);
            }
            BCTRACE((TB, "Color image    %u",codeLength));

            BD_CHECK_READ_N_BYTES(pSrc, pEndSrc, codeLength, hr)
            BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength, hr)
            BDMemcpy(pDst, pSrc, codeLength);

            pDst += codeLength;
            pSrc += codeLength;

            continue;
        }

        /********************************************************************/
        /* COLOR RUN                                                        */
        /********************************************************************/
        if ((decode == CODE_COLOR_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_COLOR_RUN))
        {
            if (decodeMega == CODE_MEGA_MEGA_COLOR_RUN)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, pEndSrc, codeLength, hr);
            }
            BCTRACE((TB, "Color run      %u",codeLength));

            BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr)
            codeByte = *pSrc++;

            BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength, hr)
            memset(pDst, codeByte, codeLength);
            pDst += codeLength;

            continue;
        }

        /********************************************************************/
        /* If we get here then the code must be a special one               */
        /********************************************************************/
        BCTRACE((TB, "Special code   %#x",decodeMega));
        switch (decodeMega)
        {
            case CODE_BLACK:
            {
                BD_CHECK_WRITE_ONE_BYTE(pDst, pEndDst, hr);
                *pDst++ = 0x00;
            }
            break;

            case CODE_WHITE:
            {
                BD_CHECK_WRITE_ONE_BYTE(pDst, pEndDst, hr);
                *pDst++ = 0xFF;
            }
            break;

            /****************************************************************/
            /* Ignore the unreachable code warnings that follow             */
            /* Simply because we use the STORE_FGBG macro with a constant   */
            /* value                                                        */
            /****************************************************************/
            case CODE_SPECIAL_FGBG_1:
            {
                if (firstLine)
                {
                    STORE_FGBG(0x00, SPECIAL_FGBG_CODE_1, fgChar, 8);
                }
                else
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED(pDst-rowDelta, pDstBuffer, pEndDst, hr);
                    STORE_FGBG(*(pDst - rowDelta),
                               SPECIAL_FGBG_CODE_1,
                               fgChar,
                               8);
                }

            }
            break;

            case CODE_SPECIAL_FGBG_2:
            {
                if (firstLine)
                {
                    STORE_FGBG(0x00,
                               SPECIAL_FGBG_CODE_2,
                               fgChar,
                               8);
                }
                else
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED(pDst-rowDelta, pDstBuffer, pEndDst, hr);
                    STORE_FGBG(*(pDst - rowDelta),
                               SPECIAL_FGBG_CODE_2,
                               fgChar,
                               8);
                }
            }
            break;

            default:
            {
                BCTRACE((TB, "Invalid compression data %x",decodeMega));
            }
            break;
        }
        pSrc++;
    }

    BCTRACE((TB, "Decompressed to %d", pDst-pDstBuffer));

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}

/****************************************************************************/
/* 15bpp decompression                                                      */
/****************************************************************************/
_inline HRESULT RDPCALL BDDecompressBitmap15(PBYTE  pSrc,
                                          PBYTE  pDstBuffer,
                                          unsigned int    srcDataSize,
                                          unsigned int    dstBufferSize,
                                          unsigned short  rowDelta)

/****************************************************************************/
/* Function name                                                            */
/****************************************************************************/
#define BC_FN_NAME              "BDDecompressBitmap15"

/****************************************************************************/
/* Data type of a pixel                                                     */
/****************************************************************************/
#define BC_PIXEL                unsigned short

/****************************************************************************/
/* Length in bytes of a pixel                                               */
/****************************************************************************/
#define BC_PIXEL_LEN            2

/****************************************************************************/
/* Default fgPel                                                            */
/****************************************************************************/
#define BC_DEFAULT_FGPEL        0x0000FF7F

/****************************************************************************/
/* Macro to move to the next pixel in the buffer (modifies pPos)            */
/****************************************************************************/
#define BC_TO_NEXT_PIXEL(pPos)  pPos += 2

/****************************************************************************/
/* Macro to returns the value of the pixel at pPos (doesn't modify pPos)    */
/****************************************************************************/
#define BC_GET_PIXEL(pPos)      ((unsigned short)  (((PBYTE)(pPos))[1]) |       \
                                 (unsigned short) ((((PBYTE)(pPos))[0]) << 8) )

/****************************************************************************/
/* Macro to insert a pixel value pel at position pPos (doesn't modify pPos) */
/*                                                                          */
/* pel may well be an expression (e.g.  a BC_GET_PIXEL macro) so evaluate   */
/* it once into a local variable.                                           */
/****************************************************************************/
#define BC_SET_PIXEL(pPos, pel)                                              \
{                                                                            \
    BC_PIXEL val = pel;                                                      \
    (((PBYTE)(pPos))[1]) = (BYTE)( (val) & 0x00FF);                    \
    (((PBYTE)(pPos))[0]) = (BYTE)(((val)>>8) & 0x00FF);                \
}

/****************************************************************************/
/* Include the function body                                                */
/****************************************************************************/
#include <abdcom.c>

/****************************************************************************/
/* Undefine everything                                                      */
/****************************************************************************/
#undef BC_FN_NAME
#undef BC_PIXEL
#undef BC_PIXEL_LEN
#undef BC_TO_NEXT_PIXEL
#undef BC_GET_PIXEL
#undef BC_SET_PIXEL
#undef BC_DEFAULT_FGPEL

/****************************************************************************/
/* 16bpp decompression                                                      */
/****************************************************************************/
_inline HRESULT  BDDecompressBitmap16(PBYTE  pSrc,
                                          PBYTE  pDstBuffer,
                                          unsigned int    srcDataSize,
                                          unsigned int    dstBufferSize,
                                          unsigned short  rowDelta)

/****************************************************************************/
/* Function name                                                            */
/****************************************************************************/
#define BC_FN_NAME              "BDDecompressBitmap16"

/****************************************************************************/
/* Data type of a pixel                                                     */
/****************************************************************************/
#define BC_PIXEL                unsigned short

/****************************************************************************/
/* Length in bytes of a pixel                                               */
/****************************************************************************/
#define BC_PIXEL_LEN            2

/****************************************************************************/
/* Default fgPel                                                            */
/****************************************************************************/
#define BC_DEFAULT_FGPEL        0x0000FFFF

/****************************************************************************/
/* Macro to move to the next pixel in the buffer (modifies pPos)            */
/****************************************************************************/
#define BC_TO_NEXT_PIXEL(pPos)  pPos += 2

/****************************************************************************/
/* Macro to returns the value of the pixel at pPos (doesn't modify pPos)    */
/****************************************************************************/
#define BC_GET_PIXEL(pPos)      ((unsigned short)  (((PBYTE)(pPos))[1]) |       \
                                 (unsigned short) ((((PBYTE)(pPos))[0]) << 8) )

/****************************************************************************/
/* Macro to insert a pixel value pel at position pPos (doesn't modify pPos) */
/*                                                                          */
/* pel may well be an expression (e.g.  a BC_GET_PIXEL macro) so evaluate   */
/* it once into a local variable.                                           */
/****************************************************************************/
#define BC_SET_PIXEL(pPos, pel)                                              \
{                                                                            \
    BC_PIXEL val = pel;                                                      \
    (((PBYTE)(pPos))[1]) = (BYTE)( (val) & 0x00FF);                    \
    (((PBYTE)(pPos))[0]) = (BYTE)(((val)>>8) & 0x00FF);                \
}

/****************************************************************************/
/* Include the function body                                                */
/****************************************************************************/
#include <abdcom.c>

/****************************************************************************/
/* Undefine everything                                                      */
/****************************************************************************/
#undef BC_FN_NAME
#undef BC_PIXEL
#undef BC_PIXEL_LEN
#undef BC_TO_NEXT_PIXEL
#undef BC_GET_PIXEL
#undef BC_SET_PIXEL
#undef BC_DEFAULT_FGPEL

/****************************************************************************/
/* 24bpp decompression                                                      */
/****************************************************************************/
_inline HRESULT  BDDecompressBitmap24(PBYTE  pSrc,
                                          PBYTE  pDstBuffer,
                                          unsigned int    srcDataSize,
                                          unsigned int    dstBufferSize,
                                          unsigned short  rowDelta)

/****************************************************************************/
/* Function name                                                            */
/****************************************************************************/
#define BC_FN_NAME              "BDDecompressBitmap24"

/****************************************************************************/
/* Data type of a pixel                                                     */
/****************************************************************************/
#define BC_PIXEL                TSUINT32

/****************************************************************************/
/* Length in bytes of a pixel                                               */
/****************************************************************************/
#define BC_PIXEL_LEN            3

/****************************************************************************/
/* Default fgPel                                                            */
/****************************************************************************/
#define BC_DEFAULT_FGPEL        0x00FFFFFF

/****************************************************************************/
/* Macro to move to the next pixel in the buffer (modifies pPos)            */
/****************************************************************************/
#define BC_TO_NEXT_PIXEL(pPos)  pPos += 3

/****************************************************************************/
/* Macro to returns the value of the pixel at pPos (doesn't modify pPos)    */
/****************************************************************************/
#define BC_GET_PIXEL(pPos) (                                                 \
                 (TSUINT32) ( (unsigned short)(((PBYTE)(pPos))[2])       ) |    \
                 (TSUINT32) (((unsigned short)(((PBYTE)(pPos))[1])) <<  8) |    \
                 (TSUINT32) (((TSUINT32)(((PBYTE)(pPos))[0])) << 16) )

/****************************************************************************/
/* Macro to insert a pixel value pel at position pPos (doesn't modify pPos) */
/*                                                                          */
/* pel may well be an expression (e.g.  a BC_GET_PIXEL macro) so evaluate   */
/* it once into a local variable.                                           */
/****************************************************************************/

#define BC_SET_PIXEL(pPos, pel)                                              \
{                                                                            \
    BC_PIXEL val = pel;                                                      \
    (((PBYTE)(pPos))[2]) = (BYTE)((val) & 0x000000FF);                 \
    (((PBYTE)(pPos))[1]) = (BYTE)(((val)>>8) & 0x000000FF);            \
    (((PBYTE)(pPos))[0]) = (BYTE)(((val)>>16) & 0x000000FF);           \
}

/****************************************************************************/
/* Include the function body                                                */
/****************************************************************************/
#include <abdcom.c>

/****************************************************************************/
/* Undefine everything                                                      */
/****************************************************************************/
#undef BC_FN_NAME
#undef BC_PIXEL
#undef BC_PIXEL_LEN
#undef BC_TO_NEXT_PIXEL
#undef BC_GET_PIXEL
#undef BC_SET_PIXEL
#undef BC_DEFAULT_FGPEL


/****************************************************************************/
/* Name:      BD_DecompressBitmap                                           */
/*                                                                          */
/* Purpose:   Decompresses compressed bitmap data                           */
/*                                                                          */
/* Params:    IN -  pCompressedData: pointer to compressed bitmap data      */
/*            OUT - pDstBitmap: pointer to buffer for decompressed data     */
/*            IN -  srcDataSize: the compressed data size                   */
/*            IN -  bitmapBitsPerPel: the bits per pel of the data          */
/****************************************************************************/
HRESULT BD_DecompressBitmap(
#ifndef DLL_DISP
        PTSHARE_WD m_pTSWd,
#endif
        PBYTE  pCompressedData,
        PBYTE  pDstBuffer,
        unsigned int    srcDataSize,
        unsigned int    dstBufferSize,
        unsigned int    noBCHeader,
        BYTE   bitmapBitsPerPel,
        unsigned short  bitmapWidth,
        unsigned short  bitmapHeight)
{
    HRESULT hr = S_OK;
    PBYTE      pSrc;
    unsigned short      rowDelta;
    unsigned int        compressedDataSize;
    PTS_CD_HEADER pCompDataHeader;
#ifdef DC_NO_UNALIGNED
    TS_CD_HEADER  compDataHeader;
#endif

    DC_BEGIN_FN("BD_DecompressBitmap");

    TRC_ASSERT( (pCompressedData != NULL),
                (TB, "Invalid pCompressedData(%p)", pCompressedData) );
    TRC_ASSERT( (pDstBuffer != NULL),
                (TB, "Invalid pDstBuffer(%p)", pDstBuffer) );
    TRC_ASSERT( (dstBufferSize != 0),
                (TB, "Invalid dstBufferSize(%u)", dstBufferSize) );
    TRC_ASSERT( (srcDataSize != 0),
                (TB, "Invalid srcDataSize(%u)", srcDataSize) );
    TRC_ASSERT( (dstBufferSize != 0),
                (TB, "Invalid dstBufferSize(%u)", dstBufferSize) );
#ifdef DC_HICOLOR
#else
    TRC_ASSERT( (bitmapBitsPerPel == 8),
                (TB, "Invalid bitmapBitsPerPel(%u)", bitmapBitsPerPel) );
#endif

    /************************************************************************/
    /* Initialize variables before main loop.                               */
    /*                                                                      */
    /* No bitmap compression header included                                */
    /************************************************************************/
    if (noBCHeader)
    {
        compressedDataSize = srcDataSize;
        pSrc               = pCompressedData;
        rowDelta           = TS_BYTES_IN_SCANLINE(bitmapWidth,
                                                  bitmapBitsPerPel);
    }
    else
    {
        /************************************************************************/
        /* Work out the location in the source data of each component.          */
        /* Make sure this is naturally aligned (for RISC platforms)             */
        /************************************************************************/
        BD_CHECK_READ_N_BYTES(pCompressedData, pCompressedData + srcDataSize, 
            sizeof(TS_CD_HEADER), hr );
#ifdef DC_NO_UNALIGNED
        DC_MEMCPY(&compDataHeader, pCompressedData, sizeof(TS_CD_HEADER));
        pCompDataHeader = &compDataHeader;
#else
        pCompDataHeader = (PTS_CD_HEADER)pCompressedData;
#endif
        
        /********************************************************************/
        /* Bitmap compression header included                               */
        /********************************************************************/
        compressedDataSize = pCompDataHeader->cbCompMainBodySize;
        BD_CHECK_READ_N_BYTES(pCompressedData, pCompressedData + srcDataSize, 
            compressedDataSize + sizeof(TS_CD_HEADER), hr );
        
        pSrc               = pCompressedData + sizeof(TS_CD_HEADER);
        rowDelta           = pCompDataHeader->cbScanWidth;
        if (rowDelta != TS_BYTES_IN_SCANLINE(bitmapWidth, bitmapBitsPerPel)) {
            TRC_ABORT((TB, "rowDelta in TS_CD_HEADER incorrect "
                "[got %u expected %u]", rowDelta,
                TS_BYTES_IN_SCANLINE(bitmapWidth, bitmapBitsPerPel)));
            hr = E_FAIL;
            DC_QUIT;
        }
    }

    /************************************************************************/
    /* Call the appropriate decompress function, based on the color depth   */
    /************************************************************************/
    switch (bitmapBitsPerPel)
    {
        case 24:
        {
            hr = BDDecompressBitmap24 (pSrc,
                                  pDstBuffer,
                                  compressedDataSize,
                                  dstBufferSize,
                                  rowDelta);
        }
        break;

        case 16:
        {
            hr = BDDecompressBitmap16 (pSrc,
                                  pDstBuffer,
                                  compressedDataSize,
                                  dstBufferSize,
                                  rowDelta);
        }
        break;

        case 15:
        {
            hr = BDDecompressBitmap15 (pSrc,
                                  pDstBuffer,
                                  compressedDataSize,
                                  dstBufferSize,
                                  rowDelta);
        }
        break;

        case 8:
        default:
        {
            hr = BDDecompressBitmap8  (pSrc,
                                  pDstBuffer,
                                  compressedDataSize,
                                  dstBufferSize,
                                  bitmapBitsPerPel,
                                  rowDelta);
        }
        break;
    }

DC_EXIT_POINT:
    return hr;
}

#else
/****************************************************************************/
/* Name:      BD_DecompressBitmap                                           */
/*                                                                          */
/* Purpose:   Decompresses compressed bitmap data                           */
/*                                                                          */
/* Params:    IN -  pCompressedData: pointer to compressed bitmap data      */
/*            OUT - pDstBitmap: pointer to buffer for decompressed data     */
/*            IN -  srcDataSize: the compressed data size                   */
/*            IN -  bitmapBitsPerPel: the bits per pel of the data          */
/****************************************************************************/
HRESULT RDPCALL  BD_DecompressBitmap( PBYTE  pCompressedData,
                                  PBYTE  pDstBuffer,
                                  unsigned int    srcDataSize,
                                  unsigned int    dstBufferSize,
                                  unsigned int    noBCHeader,
                                  BYTE   bitmapBitsPerPel,
                                  unsigned short  bitmapWidth,
                                  unsigned short  bitmapHeight )
{
    HRESULT hr = S_OK;
#ifdef DC_NO_UNALIGNED
    TS_CD_HEADER  compDataHeader;
#endif
    PTS_CD_HEADER pCompDataHeader;
    unsigned int     compressedDataSize;
    unsigned int     codeLength;
    BYTE    codeByte;
    BYTE    codeByte2;
    BYTE    decode;
    BYTE    decodeLite;
    BYTE    decodeMega;
    BYTE    fgChar;
    PBYTE   pSrc;
    PBYTE   pDst;
    PBYTE   pEndSrc;
    PBYTE   pEndDst;
    BOOL     backgroundNeedsPel;
    BOOL     firstLine;
    unsigned int     rowDelta;

    DC_BEGIN_FN("BD_DecompressBitmap");

    TRC_ASSERT( (pCompressedData != NULL),
                (TB, "Invalid pCompressedData(%p)", pCompressedData) );
    TRC_ASSERT( (pDstBuffer != NULL),
                (TB, "Invalid pDstBuffer(%p)", pDstBuffer) );
    TRC_ASSERT( (srcDataSize != 0),
                (TB, "Invalid srcDataSize(%u)", srcDataSize) );
    TRC_ASSERT( (dstBufferSize != 0),
            (TB, "Invalid dstBufferSize(%u)", dstBufferSize) );
    TRC_ASSERT( (bitmapBitsPerPel == 8),
                (TB, "Invalid bitmapBitsPerPel(%u)", bitmapBitsPerPel) );

    /************************************************************************/
    /* Trace the important parameters.                                      */
    /************************************************************************/
    TRC_DBG((TB, "pData(%p) pDst(%p) cbSrc(%u) cbDst(%u)",
       pCompressedData, pDstBuffer, srcDataSize, dstBufferSize));

    /************************************************************************/
    /* Initialize variables before main loop.                               */
    /************************************************************************/
    // no bitmap compression header included
    if (noBCHeader) {
        compressedDataSize = srcDataSize;
        pSrc = pCompressedData;
        rowDelta = TS_BYTES_IN_SCANLINE(bitmapWidth, bitmapBitsPerPel);

    }
    // bitmap compression header included
    else {
        /************************************************************************/
        /* Work out the location in the source data of each component.          */
        /* Make sure this is naturally aligned (for RISC platforms)             */
        /************************************************************************/
        BD_CHECK_READ_N_BYTES(pCompressedData, pCompressedData + srcDataSize, 
            sizeof(TS_CD_HEADER), hr );
        
#ifdef DC_NO_UNALIGNED
        DC_MEMCPY(&compDataHeader, pCompressedData, sizeof(TS_CD_HEADER));
        pCompDataHeader = &compDataHeader;
#else
        pCompDataHeader = (PTS_CD_HEADER)pCompressedData;
#endif

        compressedDataSize = pCompDataHeader->cbCompMainBodySize;
        BD_CHECK_READ_N_BYTES(pCompressedData, pCompressedData + srcDataSize, 
            compressedDataSize + sizeof(TS_CD_HEADER), hr );
        
        pSrc = pCompressedData + sizeof(TS_CD_HEADER);
        rowDelta = pCompDataHeader->cbScanWidth;
        if (rowDelta != TS_BYTES_IN_SCANLINE(bitmapWidth, bitmapBitsPerPel)) {
            TRC_ABORT((TB, "rowDelta in TS_CD_HEADER incorrect "
                "[got %u expected %u]", rowDelta,
                TS_BYTES_IN_SCANLINE(bitmapWidth, bitmapBitsPerPel)));
            hr = E_FAIL;
            DC_QUIT;
        }
    }

    pEndSrc = pSrc + compressedDataSize;
    pDst = pDstBuffer;
    pEndDst = pDst + dstBufferSize;

    fgChar = 0xFF;
    backgroundNeedsPel = FALSE;
    firstLine = TRUE;

    /************************************************************************/
    /*                                                                      */
    /* Main decompression loop                                              */
    /*                                                                      */
    /************************************************************************/
    while(pSrc < pEndSrc)
    {
        /********************************************************************/
        /* While we are processing the first line we should keep a look out */
        /* for the end of the line                                          */
        /********************************************************************/
        if (firstLine)
        {
            if ((unsigned int)(pDst - pDstBuffer) >= rowDelta)
            {
                firstLine = FALSE;
                backgroundNeedsPel = FALSE;
            }
        }

        /********************************************************************/
        /* Get the decode                                                   */
        /********************************************************************/
        BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
        decode     = (BYTE)(*pSrc & CODE_MASK);
        decodeLite = (BYTE)(*pSrc & CODE_MASK_LITE);
        decodeMega = (BYTE)(*pSrc);

        /********************************************************************/
        /* BG RUN                                                           */
        /********************************************************************/
        if ((decode == CODE_BG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_BG_RUN))
        {
            if (decode == CODE_BG_RUN)
            {
                EXTRACT_LENGTH(pSrc, pEndSrc, codeLength, hr);
            }
            else
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            TRC_DBG((TB, "Background run %u",codeLength));

            if (!firstLine)
            {
                if (backgroundNeedsPel)
                {
                    BD_CHECK_WRITE_ONE_BYTE(pDst, pEndDst, hr);
                    BD_CHECK_READ_ONE_BYTE_2ENDED(pDst - rowDelta, pDstBuffer, pEndDst, hr);
                    *pDst++ = (BYTE)(*(pDst - rowDelta) ^ fgChar);
                    codeLength--;
                }

                BD_CHECK_READ_N_BYTES_2ENDED(pDst - rowDelta, pDstBuffer, pEndDst, codeLength, hr);
                BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength, hr);

                BDMemcpy(pDst, pDst-rowDelta, codeLength);
                pDst += codeLength;
            }
            else
            {
                if (backgroundNeedsPel)
                {
                    BD_CHECK_WRITE_ONE_BYTE(pDst, pEndDst, hr);
                    *pDst++ = fgChar;
                    codeLength--;
                }

                BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength, hr);
                memset(pDst, 0x00, codeLength);
                pDst += codeLength;
            }

            /****************************************************************/
            /* A follow on BG run will need a pel inserted                  */
            /****************************************************************/
            backgroundNeedsPel = TRUE;
            continue;
        }

        /********************************************************************/
        /* For any of the other runtypes a follow on BG run does not need   */
        /* a FG pel inserted                                                */
        /********************************************************************/
        backgroundNeedsPel = FALSE;

        /********************************************************************/
        /* FGBG IMAGE                                                       */
        /********************************************************************/
        if ((decode == CODE_FG_BG_IMAGE)      ||
            (decodeLite == CODE_SET_FG_FG_BG) ||
            (decodeMega == CODE_MEGA_MEGA_FGBG)    ||
            (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
        {
            if ((decodeMega == CODE_MEGA_MEGA_FGBG) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                if (decode == CODE_FG_BG_IMAGE)
                {
                    EXTRACT_LENGTH_FGBG(pSrc, pEndSrc, codeLength, hr);
                }
                else
                {
                    EXTRACT_LENGTH_FGBG_LITE(pSrc, pEndSrc, codeLength, hr);
                }
            }

            if ((decodeLite == CODE_SET_FG_FG_BG) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
            {
                BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
                fgChar = *pSrc++;
                TRC_DBG((TB, "Set FGBG image %u",codeLength));
            }
            else
            {
                TRC_DBG((TB, "FGBG image     %u",codeLength));
            }

            while (codeLength > 8)
            {
                BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
                codeByte  = *pSrc++;
                if (firstLine)
                {
                    STORE_FGBG(0x00, codeByte, fgChar, 8);
                }
                else
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED(pDst - rowDelta, pDstBuffer, pEndDst, hr)
                    STORE_FGBG(*(pDst - rowDelta), codeByte, fgChar, 8);
                }
                codeLength -= 8;
            }
            if (codeLength > 0)
            {
                BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
                codeByte  = *pSrc++;
                if (firstLine)
                {
                    STORE_FGBG(0x00, codeByte, fgChar, codeLength);
                }
                else
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED(pDst - rowDelta, pDstBuffer, pEndDst, hr)
                   STORE_FGBG(*(pDst - rowDelta),
                              codeByte,
                              fgChar,
                              codeLength);
                }
            }
            continue;
        }

        /********************************************************************/
        /* FG RUN                                                           */
        /********************************************************************/
        if ((decode == CODE_FG_RUN) ||
            (decodeLite == CODE_SET_FG_FG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_FG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_SET_FG_RUN))
        {
            if ((decodeMega == CODE_MEGA_MEGA_FG_RUN) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FG_RUN))
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                if (decode == CODE_FG_RUN)
                {
                    EXTRACT_LENGTH(pSrc, pEndSrc, codeLength, hr);
                }
                else
                {
                    EXTRACT_LENGTH_LITE(pSrc, pEndSrc, codeLength, hr);
                }
            }

            /****************************************************************/
            /* Push the old fgChar down to the ALT position                 */
            /****************************************************************/
            if ((decodeLite == CODE_SET_FG_FG_RUN) ||
                (decodeMega  == CODE_MEGA_MEGA_SET_FG_RUN))
            {
                BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
                TRC_DBG((TB, "Set FG run     %u",codeLength));
                fgChar    = *pSrc++;
            }
            else
            {
                TRC_DBG((TB, "FG run         %u",codeLength));
            }

            BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength, hr)
            while (codeLength-- > 0)
            {
                if (!firstLine)
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED(pDst - rowDelta, pDstBuffer, pEndDst, hr)
                    *pDst++ = (BYTE)(*(pDst - rowDelta) ^ fgChar);
                }
                else
                {
                    *pDst++ = fgChar;
                }
            }
            continue;
        }

        /********************************************************************/
        /* DITHERED RUN                                                     */
        /********************************************************************/
        if ((decodeLite == CODE_DITHERED_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_DITHER))
        {
            if (decodeMega == CODE_MEGA_MEGA_DITHER)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH_LITE(pSrc, pEndSrc, codeLength, hr);
            }
            TRC_DBG((TB, "Dithered run   %u",codeLength));

            BD_CHECK_READ_N_BYTES(pSrc, pEndSrc, 2, hr);
            codeByte  = *pSrc++;
            codeByte2 = *pSrc++;

            BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength * 2, hr)
            while (codeLength-- > 0)
            {
                *pDst++ = codeByte;
                *pDst++ = codeByte2;
            }
            continue;
        }

        /********************************************************************/
        /* COLOR IMAGE                                                      */
        /********************************************************************/
        if ((decode == CODE_COLOR_IMAGE) ||
            (decodeMega == CODE_MEGA_MEGA_CLR_IMG))
        {
            if (decodeMega == CODE_MEGA_MEGA_CLR_IMG)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, pEndSrc, codeLength, hr);
            }
            TRC_DBG((TB, "Color image    %u",codeLength));

            BD_CHECK_READ_N_BYTES(pSrc, pEndSrc, codeLength, hr);
            BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength, hr);
            BDMemcpy(pDst, pSrc, codeLength);

            pDst += codeLength;
            pSrc += codeLength;

            continue;
        }

        /********************************************************************/
        /* PACKED COLOR IMAGE                                               */
        /********************************************************************/
        if ((decode == CODE_PACKED_COLOR_IMAGE) ||
            (decodeMega == CODE_MEGA_MEGA_PACKED_CLR))
        {
            if (decodeMega == CODE_MEGA_MEGA_PACKED_CLR)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, pEndSrc, codeLength, hr);
            }
            TRC_DBG((TB, "Packed color   %u",codeLength));

            if (bitmapBitsPerPel == 4)
            {
                unsigned int   worklen = (codeLength)/2;
                BYTE  workchar;
                BD_CHECK_READ_N_BYTES(pSrc, pEndSrc, worklen, hr);
                BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, worklen * 2, hr);
                while (worklen--)
                {
                    workchar   = *pSrc++;
                    *pDst++ = (BYTE)(workchar >> 4);
                    *pDst++ = (BYTE)(workchar & 0x0F);
                }
                if (codeLength & 0x0001)
                {
                    BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
                    BD_CHECK_WRITE_ONE_BYTE(pDst, pEndDst, hr);                    
                    *pDst++ = (BYTE)(*pSrc++>>4);
                }
            }
            else
            {
                TRC_ERR((TB, "Don't support packed color for 8bpp"));
            }
            continue;
        }

        /********************************************************************/
        /* COLOR RUN                                                        */
        /********************************************************************/
        if ((decode == CODE_COLOR_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_COLOR_RUN))
        {
            if (decodeMega == CODE_MEGA_MEGA_COLOR_RUN)
            {
                BD_CHECK_READ_N_BYTES(pSrc+1, pEndSrc, 2, hr);
                codeLength = DC_EXTRACT_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, pEndSrc, codeLength, hr);
            }
            TRC_DBG((TB, "Color run      %u",codeLength));

            BD_CHECK_READ_ONE_BYTE(pSrc, pEndSrc, hr);
            codeByte = *pSrc++;

            BD_CHECK_WRITE_N_BYTES(pDst, pEndDst, codeLength, hr);
            memset(pDst, codeByte, codeLength);
            pDst += codeLength;

            continue;
        }

        /********************************************************************/
        /* If we get here then the code must be a special one               */
        /********************************************************************/
        TRC_DBG((TB, "Special code   %#x",decodeMega));
        switch (decodeMega)
        {
            case CODE_BLACK:
            {
                BD_CHECK_WRITE_ONE_BYTE(pDst, pEndDst, hr);
                *pDst++ = 0x00;
            }
            break;

            case CODE_WHITE:
            {
                BD_CHECK_WRITE_ONE_BYTE(pDst, pEndDst, hr);
                *pDst++ = 0xFF;
            }
            break;

            /****************************************************************/
            /* Ignore the unreachable code warnings that follow             */
            /* Simply because we use the STORE_FGBG macro with a constant   */
            /* value                                                        */
            /****************************************************************/
            case CODE_SPECIAL_FGBG_1:
            {
                if (firstLine)
                {
                    STORE_FGBG(0x00, SPECIAL_FGBG_CODE_1, fgChar, 8);
                }
                else
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED(pDst - rowDelta, pDstBuffer, pEndDst, hr)
                    STORE_FGBG(*(pDst - rowDelta),
                               SPECIAL_FGBG_CODE_1,
                               fgChar,
                               8);
                }

            }
            break;

            case CODE_SPECIAL_FGBG_2:
            {
                if (firstLine)
                {
                    STORE_FGBG(0x00,
                               SPECIAL_FGBG_CODE_2,
                               fgChar,
                               8);
                }
                else
                {
                    BD_CHECK_READ_ONE_BYTE_2ENDED(pDst - rowDelta, pDstBuffer, pEndDst, hr)
                    STORE_FGBG(*(pDst - rowDelta),
                               SPECIAL_FGBG_CODE_2,
                               fgChar,
                               8);
                }
            }
            break;

            default:
            {
                TRC_ERR((TB, "Invalid compression data %x",decodeMega));
            }
            break;
        }
        pSrc++;
    }

    TRC_DBG((TB, "Decompressed to %d", pDst-pDstBuffer));

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}
#endif

#ifdef OS_WINDOWS
#pragma warning (default: 4127)
#endif /* OS_WINDOWS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\achapi.h ===
/* (C) 1997-1998 Microsoft Corp.
 *
 * file: ch.h
 *
 * description: Main CH header.
 */

#ifndef _H_CH
#define _H_CH


/*
 * Defines
 */

#define CH_EVT_ENTRYREMOVED     0
#define CH_EVT_QUERYREMOVEENTRY 1

#define CH_KEY_UNCACHABLE ((unsigned)-1)

// Used in debug build to determine display frequency of cache search stats.
#define CH_STAT_DISPLAY_FREQ 64

// Max number of caches that can be created at once.
#define CH_MAX_NUM_CACHES 20



/*
 * Typedefs
 */

typedef void *CHCACHEHANDLE;
typedef CHCACHEHANDLE *PCHCACHEHANDLE;

typedef BOOLEAN (__fastcall *CHCACHECALLBACK)(
        CHCACHEHANDLE hCache,
        unsigned      Event,
        unsigned      iCacheEntry,
        void          *UserDefined);

// Node in a CH cache.
typedef struct
{
    LIST_ENTRY    HashList;
    UINT32        Key1, Key2;  // 64-bit hash value broken in two.
    LIST_ENTRY    MRUList;
    void          *UserDefined;  // Associated data, used by SBC for fast-path.
    CHCACHEHANDLE hCache;  // Used by SBC fast-path to get to the cache.
} CHNODE, *PCHNODE;


// Primary data structure containing the cache info and the hash bucket array.
// CHNODEs are allocated at end of bucket array.
typedef struct
{
    unsigned        bNotifyRemoveLRU : 1;
    unsigned        bQueryRemoveLRU : 1;
    UINT32          HashKeyMask;
    CHCACHECALLBACK pfnCacheCallback;
    void            *pContext;
    CHNODE          *NodeArray;
    unsigned        NumEntries;

    LIST_ENTRY      MRUList;
    LIST_ENTRY      FreeList;

#ifdef DC_DEBUG
    // Statistics gathered in debug builds.
    unsigned MaxEntries;
    unsigned NumSearches;
    unsigned DeepestSearch;
    unsigned NumHits;
    unsigned TotalDepthOnHit;
    unsigned SearchHitDepthHistogram[8];
    unsigned TotalDepthOnMiss;
    unsigned SearchMissDepthHistogram[8];
#endif

    LIST_ENTRY HashBuckets[1];
} CHCACHEDATA, *PCHCACHEDATA;


/*
 * Inlines.
 */


/****************************************************************************/
// Given a pointer to a CHNODE, returns the containing hCache.
/****************************************************************************/
//__inline CHCACHEHANDLE RDPCALL CH_GetCacheHandleFromNode(CHNODE *pNode)
#define CH_GetCacheHandleFromNode(_pNode) ((_pNode)->hCache)


/****************************************************************************/
// Given a cache handle, returns the stored pContext information passed
// into CH_CreateCache().
/****************************************************************************/
//__inline void * RDPCALL CH_GetCacheContextFromHandle(CHCACHEHANDLE hCache)
#define CH_GetCacheContext(_hCache) \
        (((PCHCACHEDATA)(_hCache))->pContext)


/****************************************************************************/
// Given a cache handle, sets the stored pContext information passed into
// CH_CreateCache().
/****************************************************************************/
//__inline void * RDPCALL CH_GetCacheContextFromHandle(CHCACHEHANDLE hCache)
#define CH_SetCacheContext(_hCache, _pContext) \
        (((PCHCACHEDATA)(_hCache))->pContext) = (_pContext)


/****************************************************************************/
// Given a pointer to a CHNODE, returns the node's index.
/****************************************************************************/
//__inline unsigned RDPCALL CH_GetCacheIndexFromNode(CHNODE *pNode)
#define CH_GetCacheIndexFromNode(_pNode) \
        ((unsigned)((_pNode) - ((PCHCACHEDATA)((_pNode)->hCache))->NodeArray))


/****************************************************************************/
// Given a cache handle and an index, returns a pointer to the node.
/****************************************************************************/
//__inline PCHNODE RDPCALL CH_GetNodeFromCacheIndex(
//        CHCACHEHANDLE hCache,
//        unsigned      CacheIndex)
#define CH_GetNodeFromCacheIndex(_hCache, _CacheIndex) \
        (&(((PCHCACHEDATA)(_hCache))->NodeArray[_CacheIndex]))


/****************************************************************************/
// Given a cache handle and an index, changes the node's UserDefined value.
/****************************************************************************/
//__inline void RDPCALL CH_SetUserDefined(
//        CHCACHEHANDLE hCache,
//        unsigned      CacheIndex,
//        void          *UserDefined)
#define CH_SetUserDefined(_hCache, _CacheIndex, _UserDefined) \
        (((PCHCACHEDATA)(_hCache))->NodeArray[_CacheIndex].UserDefined = \
        _UserDefined)


/****************************************************************************/
// Given a cache handle and an index, returns the node's UserDefined value.
/****************************************************************************/
//__inline void * RDPCALL CH_GetUserDefined(
//        CHCACHEHANDLE hCache,
//        unsigned      CacheIndex)
#define CH_GetUserDefined(_hCache, _CacheIndex) \
        (((PCHCACHEDATA)(_hCache))->NodeArray[_CacheIndex].UserDefined)


/****************************************************************************/
// Given a node, changes its UserDefined value.
/****************************************************************************/
//__inline void RDPCALL CH_SetNodeUserDefined(CHNODE *pNode, void *UserDefined)
#define CH_SetNodeUserDefined(_pNode, _UserDefined) \
        ((_pNode)->UserDefined = (_UserDefined))


/****************************************************************************/
// Given a node, returns its UserDefined value.
/****************************************************************************/
//__inline void * RDPCALL CH_GetNodeUserDefined(CHNODE *pNode)
#define CH_GetNodeUserDefined(_pNode) ((_pNode)->UserDefined)


/****************************************************************************/
// Returns the number of cached entries in a cache.
/****************************************************************************/
//__inline unsigned RDPCALL CH_GetNumEntries(CHCACHEHANDLE hCache)
#define CH_GetNumEntries(_hCache) (((PCHCACHEDATA)(_hCache))->NumEntries)


#endif  // !defined(_H_CH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\acmafn.h ===
/****************************************************************************/
// acmafn.h
//
// Cursor Manager API prototypes
//
// Copyright (c) Microsoft 1996 - 1999
/****************************************************************************/

void RDPCALL CM_Init(void);

void RDPCALL CM_UpdateShm(void);

BOOL RDPCALL CM_PartyJoiningShare(LOCALPERSONID locPersonID,
                                  unsigned          oldShareSize);

void RDPCALL CMEnumCMCaps(LOCALPERSONID, UINT_PTR, PTS_CAPABILITYHEADER);

void RDPCALL CM_SendCursorMovedPacket(PPDU_PACKAGE_INFO);

BOOL RDPCALL CMSendCachedCursor(unsigned, PPDU_PACKAGE_INFO);

BOOL RDPCALL CMSendCursorShape(PPDU_PACKAGE_INFO);

BOOL RDPCALL CMSendSystemCursor(UINT32, PPDU_PACKAGE_INFO);

BOOL RDPCALL CMSendColorBitmapCursor(PCM_CURSORSHAPE, unsigned,
        PPDU_PACKAGE_INFO);

void RDPCALL CMGetColorCursorDetails(
        PCM_CURSORSHAPE  pCursor,
        PUINT16_UA    pcxWidth,
        PUINT16_UA    pcyHeight,
        PUINT16_UA    pxHotSpot,
        PUINT16_UA    pyHotSpot,
        PBYTE        pANDMask,
        PUINT16_UA    pcbANDMask,
        PBYTE        pXORBitmap,
        PUINT16_UA    pcbXORBitmap);


#ifdef __cplusplus


/****************************************************************************/
/* CM_Term()                                                                */
/*                                                                          */
/* Terminates the Cursor Manager.                                           */
/****************************************************************************/
void RDPCALL CM_Term(void)
{
}


/****************************************************************************/
/* CM_PartyLeftShare()                                                      */
/*                                                                          */
/* Cursor Manager function called when a party has left the share.          */
/*                                                                          */
/* PARAMETERS:                                                              */
/* locPersonID - local person ID of remote person leaving the share.        */
/* newShareSize - the number of the parties now in the share (ie excludes   */
/*     the leaving party).                                                  */
/****************************************************************************/
void RDPCALL SHCLASS CM_PartyLeftShare(
        LOCALPERSONID locPersonID,
        unsigned      newShareSize)
{
    if (locPersonID != SC_LOCAL_PERSON_ID) {
        // Do any cleanup required (none at present).
    }
}


/****************************************************************************/
// CM_Periodic
//
// Called during output processing to send cursor packets if need be.
/****************************************************************************/
_inline void RDPCALL CM_Periodic(PPDU_PACKAGE_INFO pPkgInfo)
{
    // Check to see if the cursor has changed at all.
    if (!cmNeedToSendCursorShape &&
            m_pShm->cm.cmCursorStamp == cmLastCursorStamp &&
            m_pShm->cm.cmHidden == cmCursorHidden)
        return;

    // Save the 'hidden' state.
    cmCursorHidden = m_pShm->cm.cmHidden;

    // We have output to send, so set a reschedule regardless of whether we
    // succeed.
    SCH_ContinueScheduling(SCH_MODE_NORMAL);

    // Send the cursor, or a null cursor if the cursor is hidden.
    if (!cmCursorHidden) {
        if (CMSendCursorShape(pPkgInfo)) {
            cmLastCursorStamp = m_pShm->cm.cmCursorStamp;
            cmNeedToSendCursorShape = FALSE;
        }
        else {
            // We failed to send the bitmap cursor, so we just exit without
            // updating cmLastCursorSent.  We will attempt to send it again
            // on the next call to CM_Periodic.
        }
    }
    else {
        // If cursor is hidden, send null cursor. No need to update
        // cmLastCursorStamp since hidden state is separate from stamping.
        CMSendSystemCursor(TS_SYSPTR_NULL, pPkgInfo);
    }
}


/****************************************************************************/
/* API FUNCTION: CM_GetCursorPos                                            */
/*                                                                          */
/* Returns CM's idea of the cursor position                                 */
/****************************************************************************/
_inline PPOINTL RDPCALL CM_GetCursorPos()
{
    return &m_pShm->cm.cmCursorPos;
}


/****************************************************************************/
/* API FUNCTION: CM_CursorMoved                                             */
/****************************************************************************/
_inline BOOLEAN RDPCALL CM_CursorMoved(void)
{
    return m_pShm->cm.cmCursorMoved;
}


/****************************************************************************/
/* API FUNCTION: CM_ClearCursorMoved                                        */
/****************************************************************************/
_inline void RDPCALL CM_ClearCursorMoved(void)
{
    m_pShm->cm.cmCursorMoved = FALSE;
}


/****************************************************************************/
/* API FUNCTION: CM_IsCursorVisible                                         */
/*                                                                          */
/* Returns CM's idea of the cursor visibility                               */
/****************************************************************************/
_inline BOOLEAN RDPCALL CM_IsCursorVisible(void)
{
    return !cmCursorHidden;
}


/****************************************************************************/
/* FUNCTION: CMGetCursorShape                                               */
/*                                                                          */
/* Returns a pointer to a CM_CURSORSHAPE structure that defines the bit     */
/* definition of the currently displayed cursor.                            */
/*                                                                          */
/* The PCM_CURSORSHAPE returned is passed back to CMGetColorCursorDetails   */
/* to retrieve the specific details.                                        */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ppCursorShape - pointer to a PCM_CURSORSHAPE variable that receives the  */
/*     pointer to the CM_CURSORSHAPE structure                              */
/* pcbCursorDataSize - pointer to a unsigned variable that receives the size*/
/*     in bytes of the CM_CURSORSHAPE structure                             */
/*                                                                          */
/* RETURNS: Success TRUE/FALSE                                              */
/****************************************************************************/
__inline BOOL RDPCALL CMGetCursorShape(
        PCM_CURSORSHAPE *ppCursorShape,
        PUINT        pcbCursorDataSize)
{
    /************************************************************************/
    /* Check that a cursor has been written to shared memory - may happen   */
    /* on start-up before the display driver has written a cursor - or if   */
    /* the display driver is not working.                                   */
    /************************************************************************/
    if (m_pShm->cm.cmCursorShapeData.hdr.cBitsPerPel != 0)
    {
        *ppCursorShape = (PCM_CURSORSHAPE)&(m_pShm->cm.cmCursorShapeData);
        *pcbCursorDataSize = CURSORSHAPE_SIZE(&m_pShm->cm.cmCursorShapeData);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\acpcapi.h ===
/****************************************************************************/
/* acpcapi.h                                                                */
/*                                                                          */
/* RDP Capabilities Coordinator API header file.                            */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1996                             */
/* (C) 1997-1999 Microsoft Corp.                                            */
/****************************************************************************/
#ifndef _H_ACPCAPI
#define _H_ACPCAPI


typedef void (RDPCALL SHCLASS *PCAPSENUMERATEFN)(LOCALPERSONID, UINT_PTR,
         PTS_CAPABILITYHEADER pCapabilities);


/****************************************************************************/
/* CPC_MAX_LOCAL_CAPS_SIZE is the number of bytes of memory allocated to    */
/* contain the capabilities passed to both CPC_RegisterCapabilities and     */
/* CPC_RegisterCapabilities.  CPC_MAX_LOCAL_CAPS_SIZE can be increased at   */
/* any time (it does not form part of the protocol).                        */
/****************************************************************************/
#define CPC_MAX_LOCAL_CAPS_SIZE 400


#endif   /* #ifndef _H_ACPCAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\acomapi.h ===
/****************************************************************************/
// acomapi.h
//
// RDP common functions API header
//
// Copyright (C) Microsoft, PictureTel 1992-1997
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_ACOMAPI
#define _H_ACOMAPI

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include <atrcapi.h>


/****************************************************************************/
/* We have a circular structure dependency, so prototype the necessary data */
/* here.                                                                    */
/****************************************************************************/
typedef struct tagTSHARE_WD TSHARE_WD, *PTSHARE_WD;


/****************************************************************************/
// COM_Malloc
//
// Wrapper for paged pool allocation with WD tag.
/****************************************************************************/
#ifndef DLL_DISP

#ifndef DC_DEBUG
/****************************************************************************/
/* For a free build, just call ExAllocatePoolWithTag                        */
/****************************************************************************/
__inline PVOID RDPCALL COM_Malloc(UINT32 length)
{
    return ExAllocatePoolWithTag(PagedPool, length, WD_ALLOC_TAG);
}

#else /* DC_DEBUG */
/****************************************************************************/
/* Checked COM_Malloc - call WDW_Malloc                                     */
/****************************************************************************/
PVOID RDPCALL WDW_Malloc(PTSHARE_WD, ULONG);
#define COM_Malloc(len) WDW_Malloc(pTRCWd, len)
#endif /* DC_DEBUG */
#endif /* DLL_DISP */


/****************************************************************************/
// COM_Free
//
// Wrapper for pool deallocator.
/****************************************************************************/
#ifndef DLL_DISP

#ifndef DC_DEBUG
/****************************************************************************/
/* Free build - just call ExFreePool                                        */
/****************************************************************************/
__inline void RDPCALL COM_Free(PVOID pMemory)
{
    ExFreePool(pMemory);
}

#else /* DC_DEBUG */
/****************************************************************************/
/* Checked build - call WDW_Free                                            */
/****************************************************************************/
void RDPCALL WDW_Free(PVOID);
#define COM_Free(pMem) WDW_Free(pMem)
#endif /* DC_DEBUG */
#endif /* DLL_DISP */


/****************************************************************************/
/* Name:      COM_GETTICKCOUNT                                              */
/*                                                                          */
/* Purpose:   Gets a tick count                                             */
/*                                                                          */
/* Returns:   Relative time in units of 100ns. This will wrap after 429     */
/*            seconds.                                                      */
/****************************************************************************/
#ifndef DLL_DISP
#define COM_GETTICKCOUNT(A)                                                 \
    {                                                                       \
        LARGE_INTEGER sysTime;                                              \
        KeQuerySystemTime((PLARGE_INTEGER)&sysTime);                        \
        A = sysTime.LowPart;                                                \
    }
#endif /* ndef DLL_DISP */


/****************************************************************************/
/* Prototypes for COM registry access functions                             */
/****************************************************************************/
BOOL RDPCALL COM_OpenRegistry(PTSHARE_WD pTSWd,
                              PWCHAR     pSection);

void RDPCALL COM_CloseRegistry(PTSHARE_WD pTSWd);

void RDPCALL COM_ReadProfInt32(PTSHARE_WD pTSWd,
                               PWCHAR     pEntry,
                               INT32      defaultValue,
                               long       *pValue);

NTSTATUS RDPCALL COMReadEntry(PTSHARE_WD pTSWd,
                              PWCHAR     pEntry,
                              PVOID      pBuffer,
                              unsigned   bufferSize,
                              UINT32     expectedDataType);


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* _H_ACOMAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\adcs.h ===
/****************************************************************************/
/* adcs.h                                                                   */
/*                                                                          */
/* RDP application initialization include file                              */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1997                             */
/* Copyright(c) Microsoft 1997-1999                                         */
/****************************************************************************/

#include <acomapi.h>

/****************************************************************************/
/* Make sure we use a standard trace group if the module has not defined a  */
/* custom one.                                                              */
/****************************************************************************/
#ifndef TRC_GROUP
#define TRC_GROUP TRC_GROUP_DCSHARE
#endif

#include <atrcapi.h>


#include "license.h"
#include <at120ex.h>
#include <mcskernl.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\acpcafn.h ===
/****************************************************************************/
/* Header:    acpcafn.h                                                     */
/*                                                                          */
/* Purpose:   Function prototypes for CPC API functions                     */
/*                                                                          */
/* COPYRIGHT (c) Microsoft 1996-1999                                        */
/****************************************************************************/

void RDPCALL CPC_Init(void);

void RDPCALL CPC_Term(void);

void RDPCALL CPC_RegisterCapabilities(PTS_CAPABILITYHEADER pCapabilities,
                                      UINT16             sizeOfCaps);

void RDPCALL CPC_EnumerateCapabilities(unsigned, UINT_PTR, PCAPSENUMERATEFN);

void RDPCALL CPC_GetCombinedCapabilities(
                                     LOCALPERSONID             localID,
                                     PUINT                     pSizeOfCaps,
                                     PTS_COMBINED_CAPABILITIES * ppCaps);

void RDPCALL CPC_SetCombinedCapabilities(
                                     UINT                      cbSizeOfCaps,
                                     PTS_COMBINED_CAPABILITIES pCaps);

BOOL RDPCALL CPC_PartyJoiningShare(LOCALPERSONID personID,
                                   unsigned          oldShareSize,
                                   unsigned          sizeOfCapsData,
                                   PVOID         pCapsData );

void RDPCALL CPC_PartyLeftShare(LOCALPERSONID personID,
                                unsigned          newShareSize);

PTS_CAPABILITYHEADER RDPCALL CPCGetCapabilities(
        LOCALPERSONID localID,
        unsigned capabilitiesID);


#ifdef __cplusplus

/****************************************************************************/
/* API FUNCTION: CPC_GetCapabilitiesForPerson                               */
/*                                                                          */
/* Returns the capabilities for one person in the share.  Components are    */
/* STRONGLY discouraged from using this function to cache pointers to       */
/* capabilities themselves.                                                 */
/*                                                                          */
/* This function can return the capabilities for BOTH local and remote      */
/* parties.                                                                 */
/*                                                                          */
/* Use CPC_EnumerateCapabilities() if you need the capabilities of all      */
/* people in the share.                                                     */
/*                                                                          */
/* Use CPC_GetCapabilitiesForPerson() when you need capabilities for only   */
/* ONE person in the share.                                                 */
/*                                                                          */
/* Use CPC_GetCapabilitiesForLocalPerson() when you need the capabilities   */
/* for the local person and there is not be a share active.                 */
/*                                                                          */
/* PARAMETERS:                                                              */
/* personID - local personid for capabilities to query.                     */
/*                                                                          */
/* capabilitiesID - the ID of the capabilities (group structure) to be      */
/* queried.                                                                 */
/*                                                                          */
/* RETURNS:                                                                 */
/* Pointer to a structure containing the capabilities ID, the size of the   */
/* capabilities, and any number of capability fields. The                   */
/* values used in these fields should be non-zero.  A zero in any           */
/* capability field is used to indicate that the capability is either       */
/* unknown or undefined by the remote.  This pointer is ONLY valid while    */
/* the person is in the share.                                              */
/*                                                                          */
/* If the person has no capabilities with capabilitiesID, a NULL pointer is */
/* returned.                                                                */
/****************************************************************************/
PTS_CAPABILITYHEADER RDPCALL SHCLASS CPC_GetCapabilitiesForPerson(
        LOCALPERSONID personID,
        unsigned      capabilitiesID)
{
    return CPCGetCapabilities(personID, capabilitiesID);
}


/****************************************************************************/
/* API FUNCTION: CPC_GetCapabilitiesForLocalPerson()                        */
/*                                                                          */
/* Returns the capabilities for the local person.  This function can be     */
/* called when a share is not active.                                       */
/*                                                                          */
/* Use CPC_EnumerateCapabilities() if you need the capabilities of all      */
/* people in the share.                                                     */
/*                                                                          */
/* Use CPC_GetCapabilitiesForPerson() when you need capabilities for only   */
/* ONE person in the share and you know a share is active.                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* capabilitiesID - the ID of the capabilities (group structure) to be      */
/* queried.                                                                 */
/*                                                                          */
/* RETURNS:                                                                 */
/* Pointer to a structure containing the capabilities ID, the size of the   */
/* capabilities, and any number of capability fields.                       */
/*                                                                          */
/* If the local person has no capabilities with capabilitiesID, a NULL      */
/* pointer is returned.                                                     */
/****************************************************************************/
PTS_CAPABILITYHEADER RDPCALL SHCLASS CPC_GetCapabilitiesForLocalPerson(
        unsigned capabilitiesID)
{
    return CPCGetCapabilities(0, capabilitiesID);
}


#endif  // defined(__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\rdp\inc\acmapi.h ===
/****************************************************************************/
/* acmapi.h                                                                 */
/*                                                                          */
/* Cursor Manager API Header File.                                          */
/*                                                                          */
/* Copyright(c) Microsoft, PictureTel 1992-1996                             */
/* Copyright (c) Microsoft 1997-1999                                        */
/****************************************************************************/
#ifndef _H_ACMAPI
#define _H_ACMAPI


// Default capabilities.
#define CM_DEFAULT_TX_CACHE_ENTRIES 25
#define CM_DEFAULT_RX_CACHE_ENTRIES 25


/****************************************************************************/
/* Maximum cursor sizes.                                                    */
/****************************************************************************/
#define CM_MAX_CURSOR_WIDTH            32
#define CM_MAX_CURSOR_HEIGHT           32


/****************************************************************************/
/* This is the maximum size of the cursor data for the combined 1bpp AND    */
/* mask and n bpp XOR mask.  We currently allow for a 32x32 cursor at       */
/* 32bpp.  In this case the AND mask consumes 32*32/8 bytes (128) and the   */
/* XOR mask consumes 32*32*4 (4096) bytes.                                  */
/****************************************************************************/
#define CM_MAX_CURSOR_DATA_SIZE        \
                        ((CM_MAX_CURSOR_WIDTH * CM_MAX_CURSOR_HEIGHT * 33)/8)


#define CURSOR_AND_MASK_SIZE(pCursorShape) \
    ((pCursorShape)->hdr.cbMaskRowWidth * (pCursorShape)->hdr.cy)


#define ROW_WORD_PAD(cbUnpaddedRow) \
    (((cbUnpaddedRow) + 1) & ~1)


#define CURSOR_DIB_BITS_SIZE(cx, cy, bpp)   \
        ((((cx) * (bpp) + 15) & ~15) / 8 * (cy))

#define CURSOR_XOR_BITMAP_SIZE(pCursorShape)                                  \