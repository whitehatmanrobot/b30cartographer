src\admin\mqsnap\admmsg.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

   admmsg.h

Abstract:

   Definition of functions used for Admin messages

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////


HRESULT RequestPrivateQueues(const GUID& gMachineID, PUCHAR *ppListofPrivateQ, DWORD *pdwNoofQ);
HRESULT RequestDependentClient(const GUID& gMachineID, CList<LPWSTR, LPWSTR&>& DependentMachineList);
HRESULT MQPing(const GUID& gMachineID);
HRESULT SendQMTestMessage(GUID &gMachineID, GUID &gQueueId);
HRESULT GetQMReportQueue(const GUID& gMachineID, CString& strRQPathname, BOOL fLocalMgmt, const CString& strDomainController);
HRESULT SetQMReportQueue(const GUID& gDesMachine, const GUID& gReportQueue);
HRESULT GetQMReportState(const GUID& gMachineID, BOOL& fReportState);
HRESULT SetQMReportState(const GUID& gMachineID, BOOL fReportState);

const LPCTSTR x_strAdminResponseQName = TEXT("msmqadminresp");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\certgen.h ===
#if !defined(AFX_CERTGEN_H__3FE71264_DA70_11D1_9C86_006008764D0E__INCLUDED_)
#define AFX_CERTGEN_H__3FE71264_DA70_11D1_9C86_006008764D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CertGen.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCertGen dialog

class CCertGen : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CCertGen)

// Construction
public:
	CCertGen();
	~CCertGen();

    void
    Initialize(
        CMQSigCertificate** pCertList,
        DWORD NumOfCertificate,
        SID  *pSid
        );

// Dialog Data
	//{{AFX_DATA(CCertGen)
	enum { IDD = IDD_USER_CERTIFICATE };
	CString	m_Label;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCertGen)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCertGen)
	virtual BOOL OnInitDialog();
	afx_msg void OnCertView();
	afx_msg void OnCertRemove();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    void
    FillCertsList(
        void
        );

    CListBox* m_pCertListBox;

    CMQSigCertificate** m_pCertList;
    DWORD m_NumOfCertificate;

    SID *m_pSid ;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CERTGEN_H__3FE71264_DA70_11D1_9C86_006008764D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\alloc.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    alloc.cpp

Abstract:
    Memory Allocation functions module. Mqsnap needs it own memory allocation
	function and cannot use those  implemented in mm.lib because
	it's allocator needs to be  compatibile with crt allocator since
	mfc deletes objects that mqsnap allocates at start up. 

Author:

    Gil Shafriri (gilsh) 04-Jan-2001

--*/
#include "stdafx.h"

#include "alloc.tmh"

using std::nothrow_t;
using std::bad_alloc;


static bad_alloc s_bad_alloc;

__declspec(noreturn) void MmThrowBadAlloc() throw(bad_alloc)
{
	throw s_bad_alloc;
}


void* MmAllocate(size_t s) throw(bad_alloc)
{
    void* p = malloc(s);

    if(p != 0)
		return p;

	MmThrowBadAlloc();
}


void* MmAllocate(size_t s, const nothrow_t&) throw()
{
    return malloc(s);
}


void* MmAllocate(size_t s, const char* /* fn */, int /* l */) throw(bad_alloc)
{
    void* p = malloc(s);

    if(p != 0)
		return p;

	MmThrowBadAlloc();
}


void* MmAllocate(size_t s, const char* /* fn */, int /* l */, const nothrow_t&) throw()
{

    return malloc(s);
}


void MmDeallocate(void* p) throw()
{
    free(p);
}

PVOID ADAllocateMemory(IN DWORD size)
{
	return MQAllocateMemory(size);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\atlmyimpl.cpp ===
#include "stdafx.h"

#pragma warning(disable: 4100)  // unreferenced formal parameter
#pragma warning(disable: 4267)  // conversion from 'size_t' to 'DWORD', possible loss of data
#pragma warning(disable: 4505)  // unreferenced local function has been removed

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>

#include <statreg.cpp>

#endif


//#define ATL_NO_NAMESPACE

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\atlapp.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLAPP_H__
#define __ATLAPP_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlapp.h requires atlbase.h to be included first
#endif

//#ifndef ATL_NO_NAMESPACE
//namespace ATL
//{
//#endif

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

class CMessageFilter;
class CUpdateUIObject;
class CMessageLoop;


/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap for ATL 2.0/2.1

#if (_ATL_VER < 0x0300)

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

#ifndef ATLTRACE2
#define ATLTRACE2(cat, lev, msg)	ATLTRACE(msg)
#endif

#ifndef ATLINLINE
#define ATLINLINE inline
#endif

template <class T>
class CSimpleArray
{
public:
	T* m_aT;
	int m_nSize;
	int m_nAllocSize;

// Construction/destruction
	CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{ }

	~CSimpleArray()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(T& t)
	{
		if(m_nSize == m_nAllocSize)
		{
			T* aT;
			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
			aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
			if(aT == NULL)
				return FALSE;
			m_nAllocSize = nNewAllocSize;
			m_aT = aT;
		}
		m_nSize++;
		SetAtIndex(m_nSize - 1, t);
		return TRUE;
	}
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
		if(nIndex != (m_nSize - 1))
			memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_nSize > 0)
		{
			free(m_aT);
			m_aT = NULL;
			m_nSize = 0;
			m_nAllocSize = 0;
		}
	}
	T& operator[] (int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}
	T* GetData() const
	{
		return m_aT;
	}

// Implementation
	void SetAtIndex(int nIndex, T& t)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aT[nIndex] = t;
	}
	int Find(T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};

// for arrays of simple types
template <class T>
class CSimpleValArray : public CSimpleArray< T >
{
public:
	BOOL Add(T t)
	{
		return CSimpleArray< T >::Add(t);
	}
	BOOL Remove(T t)
	{
		return CSimpleArray< T >::Remove(t);
	}
	T operator[] (int nIndex) const
	{
		return CSimpleArray< T >::operator[](nIndex);
	}
};


// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CSimpleMap
{
public:
	TKey* m_aKey;
	TVal* m_aVal;
	int m_nSize;

// Construction/destruction
	CSimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
	{ }

	~CSimpleMap()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(TKey key, TVal val)
	{
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
		if(pKey == NULL)
			return FALSE;
		m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
		if(pVal == NULL)
			return FALSE;
		m_aVal = pVal;
		m_nSize++;
		SetAtIndex(m_nSize - 1, key, val);
		return TRUE;
	}
	BOOL Remove(TKey key)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		if(nIndex != (m_nSize - 1))
		{
			memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
			memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
		}
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
		if(pKey != NULL || m_nSize == 1)
			m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
		if(pVal != NULL || m_nSize == 1)
			m_aVal = pVal;
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_nSize > 0)
		{
			free(m_aKey);
			free(m_aVal);
			m_aKey = NULL;
			m_aVal = NULL;
			m_nSize = 0;
		}
	}
	BOOL SetAt(TKey key, TVal val)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		SetAtIndex(nIndex, key, val);
		return TRUE;
	}
	TVal Lookup(TKey key) const
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetValueAt(nIndex);
	}
	TKey ReverseLookup(TVal val) const
	{
		int nIndex = FindVal(val);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetKeyAt(nIndex);
	}
	TKey& GetKeyAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aKey[nIndex];
	}
	TVal& GetValueAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aVal[nIndex];
	}

// Implementation
	void SetAtIndex(int nIndex, TKey& key, TVal& val)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aKey[nIndex] = key;
		m_aVal[nIndex] = val;
	}
	int FindKey(TKey& key) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aKey[i] == key)
				return i;
		}
		return -1;	// not found
	}
	int FindVal(TVal& val) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aVal[i] == val)
				return i;
		}
		return -1;	// not found
	}
};

// WM_FORWARDMSG - used to forward a message to another window for processing
// WPARAM - DWORD dwUserData - defined by user
// LPARAM - LPMSG pMsg - a pointer to the MSG structure
// return value - 0 if the message was not processed, nonzero if it was
#define WM_FORWARDMSG		0x037F

#endif //(_ATL_VER < 0x0300)

/////////////////////////////////////////////////////////////////////////////
// CMessageFilter - Interface for message filter support

class ATL_NO_VTABLE CMessageFilter
{
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// CUpdateUIObject - Interface for update UI support

class ATL_NO_VTABLE CUpdateUIObject
{
public:
	virtual BOOL DoUpdate() = 0;
};

/////////////////////////////////////////////////////////////////////////////
// CMessageLoop - message loop implementation

class CMessageLoop
{
public:
	CSimpleArray<CMessageFilter*> m_aMsgFilter;
	CSimpleArray<CUpdateUIObject*> m_aUpdateUI;
	MSG m_msg;

// Message filter operations
	BOOL AddMessageFilter(CMessageFilter* pMessageFilter)
	{
		return m_aMsgFilter.Add(pMessageFilter);
	}
	BOOL RemoveMessageFilter(CMessageFilter* pMessageFilter)
	{
		return m_aMsgFilter.Remove(pMessageFilter);
	}
// Update UI operations
	BOOL AddUpdateUI(CUpdateUIObject* pUpdateUI)
	{
		return m_aUpdateUI.Add(pUpdateUI);
	}
	BOOL RemoveUpdateUI(CUpdateUIObject* pUpdateUI)
	{
		return m_aUpdateUI.Remove(pUpdateUI);
	}
// message loop
	int Run()
	{
		BOOL bDoIdle = TRUE;
		int nIdleCount = 0;
		BOOL bRet;

		for(;;)
		{
			while(!::PeekMessage(&m_msg, NULL, 0, 0, PM_NOREMOVE) && bDoIdle)
			{
				if(!OnIdle(nIdleCount++))
					bDoIdle = FALSE;
			}

			bRet = ::GetMessage(&m_msg, NULL, 0, 0);

			if(bRet == -1)
			{
				ATLTRACE2(atlTraceWindowing, 0, _T("::GetMessage returned -1 (error)\n"));
				continue;	// error, don't process
			}
			else if(!bRet)
			{
				ATLTRACE2(atlTraceWindowing, 0, _T("CMessageLoop::Run - exiting\n"));
				break;		// WM_QUIT, exit message loop
			}

			if(!PreTranslateMessage(&m_msg))
			{
				::TranslateMessage(&m_msg);
				::DispatchMessage(&m_msg);
			}

			if(IsIdleMessage(&m_msg))
			{
				bDoIdle = TRUE;
				nIdleCount = 0;
			}
		}

		return (int)m_msg.wParam;
	}

	static BOOL IsIdleMessage(MSG* pMsg)
	{
		// These messages should NOT cause idle processing
		switch(pMsg->message)
		{
		case WM_MOUSEMOVE:
#ifndef UNDER_CE
		case WM_NCMOUSEMOVE:
#endif //!UNDER_CE
		case WM_PAINT:
		case 0x0118:	// WM_SYSTIMER (caret blink)
			return FALSE;
		}

		return TRUE;
	}

// Overrideables
	// Override to change message filtering
	virtual BOOL PreTranslateMessage(MSG* pMsg)
	{
		// loop backwards
		for(int i = m_aMsgFilter.GetSize() - 1; i >= 0; i--)
		{
			CMessageFilter* pMessageFilter = m_aMsgFilter[i];
			if(pMessageFilter != NULL && pMessageFilter->PreTranslateMessage(pMsg))
				return TRUE;
		}
		return FALSE;	// not translated
	}
	// override to change idle UI updates
	virtual BOOL OnIdle(int /*nIdleCount*/)
	{
		for(int i = 0; i < m_aUpdateUI.GetSize(); i++)
		{
			CUpdateUIObject* pUpdateUI = m_aUpdateUI[i];
			if(pUpdateUI != NULL)
				pUpdateUI->DoUpdate();
		}
		return FALSE;	// don't continue
	}
};


//#ifndef ATL_NO_NAMESPACE
//}; //namespace ATL
//#endif

#endif // __ATLAPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\client.cpp ===
// ClientPage.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqppage.h"
#include <rt.h>
#include "_registr.h"
#include "localutl.h"
#include "client.h"
#include "mqcast.h"

#include "client.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CClientPage property page

IMPLEMENT_DYNCREATE(CClientPage, CMqPropertyPage)

CClientPage::CClientPage() : CMqPropertyPage(CClientPage::IDD)
{
	//{{AFX_DATA_INIT(CClientPage)
	m_szServerName = _T("");
	//}}AFX_DATA_INIT  
    DWORD dwType = REG_SZ ;
    TCHAR szRemoteMSMQServer[ MAX_COMPUTERNAME_LENGTH+1 ];
    DWORD dwSize = sizeof(szRemoteMSMQServer) ;
    HRESULT rc = GetFalconKeyValue( RPC_REMOTE_QM_REGNAME,
                                    &dwType,
                                    (PVOID) szRemoteMSMQServer,
                                    &dwSize ) ;
    if (rc != ERROR_SUCCESS)
    {
        DisplayFailDialog();
        return;
    }
    m_szServerName = szRemoteMSMQServer;
    m_fModified = FALSE;
}

CClientPage::~CClientPage()
{
}

void CClientPage::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);

    if(pDX->m_bSaveAndValidate == FALSE)
    {   
        // 
        // On entry save current state
        //
       _tcscpy(m_szOldServer, m_szServerName);
    }

	//{{AFX_DATA_MAP(CClientPage)
	DDX_Text(pDX, IDC_ServerName, m_szServerName);
	//}}AFX_DATA_MAP

    if(pDX->m_bSaveAndValidate)
    {
        //
        // Trim spaces from server name
        //
        m_szServerName.TrimLeft();
        m_szServerName.TrimRight();

        //
        // On exit, check changes
        //
        if(m_szServerName != m_szOldServer)
            m_fModified = TRUE;
    }
}

BOOL CClientPage::OnApply()
{
    if (!m_fModified || !UpdateData(TRUE))
    {
        return TRUE;     
    }

    //
    // Set changes in the registry
    //
    //ConvertToWideCharString(pageClient.m_szServerName,wszServer);	
    DWORD dwType = REG_SZ;
    DWORD dwSize = (numeric_cast<DWORD>(_tcslen(m_szServerName) + 1)) * sizeof(TCHAR);
    HRESULT rc = SetFalconKeyValue(RPC_REMOTE_QM_REGNAME,&dwType,m_szServerName,&dwSize);

    m_fNeedReboot = TRUE;
    return CMqPropertyPage::OnApply();
}

BEGIN_MESSAGE_MAP(CClientPage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CClientPage)
		// NOTE: the ClassWizard will add message map macros here
        ON_EN_CHANGE(IDC_ServerName, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClientPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\atlsnap.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATL_SNAPIN_H__
#define __ATL_SNAPIN_H__

#include <mmc.h>
#include <commctrl.h>
#pragma comment(lib, "mmc.lib")
#pragma comment(lib, "comctl32.lib")

extern HMODULE	    g_hResourceMod;

template <class T, bool bAutoDelete = TRUE>
class ATL_NO_VTABLE CSnapInPropertyPageImpl : public CDialogImplBase
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CSnapInPropertyPageImpl(LPCTSTR lpszTitle = NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK;
		m_psp.hInstance = g_hResourceMod;
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc =  T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
		m_psp.lParam = (LPARAM)this;

		if(lpszTitle != NULL)
		{
			m_psp.pszTitle = lpszTitle;
			m_psp.dwFlags |= PSP_USETITLE;
		}
	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		ATLASSERT(hWnd == NULL);
        UNREFERENCED_PARAMETER(hWnd);
		if(uMsg == PSPCB_CREATE)
		{
			CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}
		if (bAutoDelete && uMsg == PSPCB_RELEASE)
		{
			T* pPage = (T*)ppsp->lParam;
			delete pPage;
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		return ::CreatePropertySheetPage(&m_psp);
	}

	BOOL EndDialog(int)
	{
		// do nothing here, calling ::EndDialog will close the whole sheet
		ATLASSERT(FALSE);
		return FALSE;
	}

// Operations
	void CancelToClose()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
	}
	void SetModified(BOOL bChanged = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		if(bChanged)
			::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
		else
			::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0L);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam);
	}

	typedef CSnapInPropertyPageImpl< T, bAutoDelete > _thisClass;
	BEGIN_MSG_MAP(_thisClass)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()

// Message handler
	LRESULT OnNotify(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		NMHDR* pNMHDR = (NMHDR*)lParam;

		// don't handle messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = (T*)this;
		LRESULT lResult = 0;
		// handle default
		switch(pNMHDR->code)
		{
		case PSN_SETACTIVE:
			lResult = pT->OnSetActive() ? 0 : -1;
			break;
		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;
		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;
		case PSN_RESET:
			pT->OnReset();
			break;
		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;
		case PSN_WIZNEXT:
			lResult = !pT->OnWizardNext();
			break;
		case PSN_WIZBACK:
			lResult = !pT->OnWizardBack();
			break;
		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;
		case PSN_HELP:
			lResult = pT->OnHelp();
			break;
		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

// Overridables
	BOOL OnSetActive()
	{
		return TRUE;
	}
	BOOL OnKillActive()
	{
		return TRUE;
	}
	BOOL OnApply()
	{
		return TRUE;
	}
	void OnReset()
	{
	}
	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	BOOL OnWizardBack()
	{
		return TRUE;
	}
	BOOL OnWizardNext()
	{
		return TRUE;
	}
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	BOOL OnHelp()
	{
		return TRUE;
	}
};

#if _ATL_VER < 0x0300
// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CMySimpleMap
{
public:
	TKey* m_aKey;
	TVal* m_aVal;
	int m_nSize;

// Construction/destruction
	CMySimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
	{ }

	~CMySimpleMap()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(TKey key, TVal val)
	{
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
		if(pKey == NULL)
			return FALSE;
		m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
		if(pVal == NULL)
			return FALSE;
		m_aVal = pVal;
		m_nSize++;
		SetAtIndex(m_nSize - 1, key, val);
		return TRUE;
	}
	BOOL Remove(TKey key)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		if(nIndex != (m_nSize - 1))
		{
			memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
			memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
		}
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
		if(pKey != NULL || m_nSize == 1)
			m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
		if(pVal != NULL || m_nSize == 1)
			m_aVal = pVal;
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_nSize > 0)
		{
			free(m_aKey);
			free(m_aVal);
			m_aKey = NULL;
			m_aVal = NULL;
			m_nSize = 0;
		}
	}
	BOOL SetAt(TKey key, TVal val)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		SetAtIndex(nIndex, key, val);
		return TRUE;
	}
	TVal Lookup(TKey key) const
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetValueAt(nIndex);
	}
	TKey ReverseLookup(TVal val) const
	{
		int nIndex = FindVal(val);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetKeyAt(nIndex);
	}
	TKey& GetKeyAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aKey[nIndex];
	}
	TVal& GetValueAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aVal[nIndex];
	}

// Implementation
	void SetAtIndex(int nIndex, TKey& key, TVal& val)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aKey[nIndex] = key;
		m_aVal[nIndex] = val;
	}
	int FindKey(TKey& key) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aKey[i] == key)
				return i;
		}
		return -1;	// not found
	}
	int FindVal(TVal& val) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aVal[i] == val)
				return i;
		}
		return -1;	// not found
	}
};
#endif


class CSnapInItem;
class CSnapInObjectRootBase;

class CObjectData
{
public:
	CSnapInItem* m_pItem;
	DATA_OBJECT_TYPES m_type;
};

class ATL_NO_VTABLE CSnapInItem 
{
public:
	virtual ~CSnapInItem()
	{
	}
    STDMETHOD(Notify)(MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM  *pScopeDataItem) = 0;
    
    STDMETHOD(GetResultViewType)(LPOLESTR  *ppViewType,
        long  *pViewOptions) = 0;
    
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM  *pResultDataItem) = 0;
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long  *pInsertionAllowed,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(Command)(long lCommandID,		
		CSnapInObjectRootBase* pObj,		
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(SetControlbar)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
		CMySimpleMap<UINT, IUnknown*>* pToolbarMap) = 0;
    
    STDMETHOD(ControlbarNotify)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
		CMySimpleMap<UINT, IUnknown*>* pToolbarMap,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(GetScopeData)(SCOPEDATAITEM  * *pScopeDataItem) = 0;
    
    STDMETHOD(GetResultData)(RESULTDATAITEM  * *pResultDataItem) = 0;

	STDMETHOD(FillData)(CLIPFORMAT cf, 
		LPSTREAM pStream) = 0;

	virtual void InitDataClass(IDataObject* /*pDataObject*/, CSnapInItem* /*pDefault*/)
	{
		_ASSERTE(0 && "Override this function in derived class");
	}

	static HRESULT GetDataClass(IDataObject* pDataObj, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
	{
		if (ppItem == NULL)
			return E_POINTER;
		if (pType == NULL)
			return E_POINTER;

		*ppItem = NULL;
		*pType = CCT_UNINITIALIZED;

		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
		FORMATETC formatetc = { m_CCF_SNAPIN_GETOBJECTDATA, 
			NULL, 
			DVASPECT_CONTENT, 
			-1, 
			TYMED_HGLOBAL 
		};

		stgmedium.hGlobal = GlobalAlloc(0, sizeof(CObjectData));
		if (stgmedium.hGlobal == NULL)
			return E_OUTOFMEMORY;

		HRESULT hr = pDataObj->GetDataHere(&formatetc, &stgmedium);
		if (SUCCEEDED(hr))
		{
			CObjectData* pData = (CObjectData*)stgmedium.hGlobal;
			 *ppItem = pData->m_pItem;
			 *pType = pData->m_type;
		}
		
		GlobalFree(stgmedium.hGlobal);
		
		return hr;
	}


	virtual HRESULT STDMETHODCALLTYPE GetDataObject(IDataObject** pDataObj, DATA_OBJECT_TYPES type) = 0;

	static void Init()
	{
		m_CCF_NODETYPE			= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_NODETYPE"));
		m_CCF_SZNODETYPE		= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SZNODETYPE"));  
		m_CCF_DISPLAY_NAME		= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_DISPLAY_NAME")); 
		m_CCF_SNAPIN_CLASSID	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SNAPIN_CLASSID"));
		m_CCF_SNAPIN_GETOBJECTDATA	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_GETOBJECTDATA"));
		m_CCF_MMC_MULTISELECT_DATAOBJECT	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_MMC_MULTISELECT_DATAOBJECT"));
	}
public:
	static CLIPFORMAT m_CCF_NODETYPE;
	static CLIPFORMAT m_CCF_SZNODETYPE;
	static CLIPFORMAT m_CCF_DISPLAY_NAME;
	static CLIPFORMAT m_CCF_SNAPIN_CLASSID;
	static CLIPFORMAT m_CCF_SNAPIN_GETOBJECTDATA;
	static CLIPFORMAT m_CCF_MMC_MULTISELECT_DATAOBJECT;
};

class CSnapInObjectRootBase
{
public:
	CComPtr <IControlbar> m_spControlbar;
	CMySimpleMap <UINT, IUnknown*> m_toolbarMap;
	const int m_nType;

	CSnapInObjectRootBase(int n = 0) : m_nType(n)
	{
	}
	HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
	{
		return CSnapInItem::GetDataClass(pDataObject, ppItem, pType);
	}
};

template <int n, class ComponentData>
class CSnapInObjectRoot : public CSnapInObjectRootBase
{
public :
	CSnapInObjectRoot() : CSnapInObjectRootBase(n)
	{
		m_pComponentData = NULL;
	}
	ComponentData* m_pComponentData;
};

#define EXTENSION_SNAPIN_DATACLASS(dataClass) dataClass m_##dataClass;

#define BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(classname) \
	HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType) \
	{ \
		if (ppItem == NULL) \
			return E_POINTER; \
		if (pType == NULL) \
			return E_POINTER; \
\
		*ppItem = NULL; \
\
		*pType = CCT_UNINITIALIZED; \
\
		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL }; \
		FORMATETC formatetc = { CSnapInItem::m_CCF_NODETYPE, \
			NULL, \
			DVASPECT_CONTENT, \
			-1, \
			TYMED_HGLOBAL \
		}; \
\
		stgmedium.hGlobal = GlobalAlloc(0, sizeof(GUID)); \
		if (stgmedium.hGlobal == NULL) \
			return E_OUTOFMEMORY; \
\
		HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium); \
		if (FAILED(hr)) \
		{ \
			GlobalFree(stgmedium.hGlobal); \
			return hr; \
		} \
\
		GUID guid; \
		memcpy(&guid, stgmedium.hGlobal, sizeof(GUID)); \
\
		GlobalFree(stgmedium.hGlobal); \
		hr = S_OK;

#define EXTENSION_SNAPIN_NODEINFO_ENTRY(dataClass) \
		if (IsEqualGUID(guid, *(GUID*)m_##dataClass.GetNodeType())) \
		{ \
			*ppItem = m_##dataClass.GetExtNodeObject(pDataObject, &m_##dataClass); \
			_ASSERTE(*ppItem != NULL); \
			(*ppItem)->InitDataClass(pDataObject, &m_##dataClass); \
			return hr; \
		}

#define END_EXTENSION_SNAPIN_NODEINFO_MAP() \
			return CSnapInItem::GetDataClass(pDataObject, ppItem, pType); \
	};

class ATL_NO_VTABLE CSnapInDataObjectImpl : public IDataObject,
	public CComObjectRoot
{
public:
	BEGIN_COM_MAP(CSnapInDataObjectImpl)
		COM_INTERFACE_ENTRY(IDataObject)
	END_COM_MAP()
	STDMETHOD(GetData)(FORMATETC * /*pformatetcIn*/, STGMEDIUM * /*pmedium*/)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetData\n"));
	}

	STDMETHOD(GetDataHere)(FORMATETC* pformatetc, STGMEDIUM* pmedium)
	{
		ATLTRACE(_T("SnapInDataObjectImpl::GetDataHere\n"));
		if (pmedium == NULL)
			return E_POINTER;

		HRESULT hr = DV_E_TYMED;
		// Make sure the type medium is HGLOBAL
		if (pmedium->tymed == TYMED_HGLOBAL)
		{
			// Create the stream on the hGlobal passed in
			CComPtr<IStream> spStream;
			hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &spStream);
			if (SUCCEEDED(hr))
				if (pformatetc->cfFormat == CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA)
				{
					hr = DV_E_CLIPFORMAT;
					ULONG uWritten;
					hr = spStream->Write(&m_objectData, sizeof(CObjectData), &uWritten);
				}
				else
					hr = m_objectData.m_pItem->FillData(pformatetc->cfFormat, spStream);
		}
		return hr;
	}

	STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::QueryGetData\n"));
	}
	STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetCanonicalFormatEtc\n"));
	}
	STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::EnumFormatEtc\n"));
	}
	STDMETHOD(DAdvise)(FORMATETC * /*pformatetc*/, DWORD /*advf*/, IAdviseSink * /*pAdvSink*/,
		DWORD * /*pdwConnection*/)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(DUnadvise)(DWORD /*dwConnection*/)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetDatan\n"));
	}
	STDMETHOD(EnumDAdvise)(IEnumSTATDATA ** /*ppenumAdvise*/)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}

	CObjectData m_objectData;
};


template <class T, class Component>
class ATL_NO_VTABLE IComponentDataImpl : public IComponentData 
{
public :
	IComponentDataImpl()
	{
		m_pNode = NULL;
	}

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown)
	{
		ATLTRACE(_T("IComponentDataImpl::Initialize\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pUnknown != NULL);
		if (pUnknown == NULL)
			ATLTRACE(_T("IComponentData::Initialize called with pUnknown == NULL\n"));
		else
		{
			hr = pUnknown->QueryInterface(IID_IConsole, (void**)&m_spConsole);
			if (FAILED(hr))
				ATLTRACE(_T("QI for IConsole failed\n"));
		}

		return hr;
	}

	STDMETHOD(CreateComponent)(LPCOMPONENT *ppComponent)
	{
		ATLTRACE(_T("IComponentDataImpl::CreateComponent\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(ppComponent != NULL);
		if (ppComponent == NULL)
			ATLTRACE(_T("IComponentData::CreateComponent called with ppComponent == NULL\n"));
		else
		{
			*ppComponent = NULL;
			
			CComObject< Component >* pComponent;
			hr = CComObject< Component >::CreateInstance(&pComponent);
			ATLASSERT(SUCCEEDED(hr));
			if (FAILED(hr))
				ATLTRACE(_T("IComponentData::CreateComponent : Could not create IComponent object\n"));
			else
			{
				pComponent->m_pComponentData = static_cast<T*>(this);
				hr = pComponent->QueryInterface(IID_IComponent, (void**)ppComponent);
			}
		}
		return hr;
	}

    
    STDMETHOD(Notify)( 
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
	{
		ATLTRACE(_T("IComponentDataImpl::Notify\n"));
		ATLASSERT(lpDataObject != NULL && _T("Override Notify in derived class handle notifications for which lpDataObject == NULL"));		
		HRESULT hr = E_POINTER;

		ATLASSERT(lpDataObject != NULL);
		if (lpDataObject == NULL)
			ATLTRACE(_T("IComponentData::Notify called with lpDataObject == NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
			ATLASSERT(SUCCEEDED(hr));
			if (SUCCEEDED(hr))
				hr = pItem->Notify(event, arg, param, pT, NULL, type);
		}
		return hr;
	}

    STDMETHOD(Destroy)(void)
	{
		ATLTRACE(_T("IComponentDataImpl::Destroy\n"));

		T* pT = static_cast<T*>(this);
		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		m_spConsole.Release();
		return S_OK;
	}

    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
	{
		ATLTRACE(_T("IComponentDataImpl::QueryDataObject\n"));
		HRESULT hr = E_POINTER;
		
		ATLASSERT(ppDataObject != NULL);
		if (ppDataObject == NULL)
			ATLTRACE(_T("IComponentData::QueryDataObject called with ppDataObject == NULL\n"));
		else
		{
			*ppDataObject = NULL;
			
			CSnapInItem* pItem = (CSnapInItem*) cookie;
			if (cookie == NULL)
				pItem = m_pNode;

			hr = pItem->GetDataObject(ppDataObject, type);
		}
		return hr;
	}
    
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		ATLTRACE(_T("IComponentDataImpl::GetDisplayInfo\n"));


		HRESULT hr = E_POINTER;
		
		ATLASSERT(pScopeDataItem != NULL);
		if (pScopeDataItem == NULL)
			ATLTRACE(_T("IComponentData::GetDisplayInfo called with pScopeDataItem == NULL\n"));
		else
		{
			CSnapInItem* pItem= (CSnapInItem*) pScopeDataItem->lParam;
			if (pItem == NULL)
				pItem = m_pNode;

			hr = E_UNEXPECTED;
			if (pItem != NULL)
				hr = pItem->GetScopePaneInfo(pScopeDataItem);
		}
		return hr;
	}
    
    STDMETHOD(CompareObjects)(LPDATAOBJECT /*lpDataObjectA*/,
        LPDATAOBJECT /*lpDataObjectB*/)
	{
		ATLTRACENOTIMPL(_T("IComponentDataImpl::CompareObjects\n"));
    }

	CComPtr<IConsole> m_spConsole;
	CSnapInItem* m_pNode;
};


template <class T>
class ATL_NO_VTABLE IComponentImpl : public IComponent
{
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole)
	{
		ATLTRACE(_T("IComponentImpl::Initialize\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(lpConsole != NULL);
		if (lpConsole == NULL)
			ATLTRACE(_T("lpConsole is NULL\n"));
		else
		{
			m_spConsole = lpConsole;
	
			CComPtr<IHeaderCtrl> spHeaderCtrl;
			hr = m_spConsole->QueryInterface(IID_IHeaderCtrl, (void**)&spHeaderCtrl);
			if (FAILED(hr))
				ATLTRACE(_T("QI for IHeaderCtrl failed\n"));
			else
			{
				hr = m_spConsole->SetHeader(spHeaderCtrl);
				if (FAILED(hr))
					ATLTRACE(_T("IConsole::SetHeader failed (HRESULT = %x)\n"), hr);
			}
		}
		return hr;
	}
    
	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param);
    
    STDMETHOD(Destroy)(MMC_COOKIE /*cookie*/)
	{
		ATLTRACE(_T("IComponentImpl::Destroy\n"));

		T* pT = static_cast<T*>(this);

		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		m_spConsole->SetHeader(NULL);
		m_spConsole.Release();
		return S_OK;
	}
    
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
	{
		ATLTRACE(_T("IComponentImpl::QueryDataObject\n"));

		ATLASSERT(ppDataObject != NULL);
		if (ppDataObject == NULL)
		{
			ATLTRACE(_T("IComponent::QueryDataObject called with ppDataObject==NULL \n"));
			return E_POINTER;
		}
		
		if (cookie == NULL)
		{
			ATLTRACE(_T("IComponent::QueryDataObject called with cookie==NULL \n"));
			return E_UNEXPECTED;
		}

		*ppDataObject = NULL;
		if (cookie == MMC_MULTI_SELECT_COOKIE)
		{
			ATLTRACE(_T("Override QueryDataObject to handle multiselect\n"));
			return E_UNEXPECTED;
		}

		CSnapInItem* pItem = (CSnapInItem*) cookie;
		return pItem->GetDataObject(ppDataObject, type);
	}
    
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,
        LPOLESTR  *ppViewType,
        long  *pViewOptions);
    
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM *pResultDataItem)
	{
		ATLTRACE(_T("IComponentImpl::GetDisplayInfo\n"));

		ATLASSERT(pResultDataItem != NULL);
		if (pResultDataItem == NULL)
		{
			ATLTRACE(_T("IComponent::GetDisplayInfo called with pResultDataItem==NULL\n"));
			return E_POINTER;
		}

		CSnapInItem* pItem = (CSnapInItem*) pResultDataItem->lParam;

		if (pItem == NULL)
		{
			ATLTRACE(_T("Invalid Item\n"));
			return E_UNEXPECTED;
		}
		return pItem->GetResultPaneInfo(pResultDataItem);
	}
    
    STDMETHOD(CompareObjects)( LPDATAOBJECT /*lpDataObjectA*/,
        LPDATAOBJECT /*lpDataObjectB*/)
	{
		ATLTRACENOTIMPL(_T("IComponentImpl::CompareObjects\n"));
	}

	CComPtr<IConsole> m_spConsole;
};

template <class T>
HRESULT IComponentImpl<T>::Notify(LPDATAOBJECT lpDataObject,
    MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM param)
{
	ATLTRACE(_T("IComponentImpl::Notify\n"));
	ATLASSERT(lpDataObject != NULL && _T("Override Notify in derived class handle notifications for which lpDataObject == NULL"));		
	HRESULT hr = E_POINTER;

	if (lpDataObject == NULL)
		ATLTRACE(_T("IComponent::Notify called with lpDataObject==NULL \n"));
	else
	{
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;
		// Make sure that the object is derived from CSnapInObjectRoot
		hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
		if (SUCCEEDED(hr))
			hr = pItem->Notify(event, arg, param, NULL, pT, type);
	}
	return hr;
}

template <class T>
HRESULT IComponentImpl<T>::GetResultViewType(MMC_COOKIE cookie,
    LPOLESTR  *ppViewType,
    long  *pViewOptions)
{
	ATLTRACE(_T("IComponentImpl::GetResultViewType\n"));

	HRESULT hr = E_FAIL;
	if (cookie == NULL)
	{
		T* pT = static_cast<T*> (this);
		ATLASSERT( pT->m_pComponentData != NULL );
		ATLASSERT( pT->m_pComponentData->m_pNode != NULL );
		hr = pT->m_pComponentData->m_pNode->GetResultViewType(ppViewType, pViewOptions);
	}
	else
	{
		CSnapInItem* pItem = (CSnapInItem*)cookie;
		hr = pItem->GetResultViewType(ppViewType, pViewOptions);
	}
	return hr;
}

template <class T, class D>        
class ATL_NO_VTABLE IResultDataCompareImpl : public IResultDataCompare
{
public:
    STDMETHOD(Compare)(LPARAM lUserParam,
        MMC_COOKIE cookieA,
        MMC_COOKIE cookieB,
        int *pnResult)
	{
		ATLTRACENOTIMPL(_T("IResultDataCompareImpl::Compare"));
	}
};


template <class T>
class ATL_NO_VTABLE IExtendContextMenuImpl : public IExtendContextMenu
{
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
        LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed);
	
    STDMETHOD(Command)(long lCommandID,
        LPDATAOBJECT pDataObject);
};

template <class T>
inline HRESULT IExtendContextMenuImpl<T>::AddMenuItems(LPDATAOBJECT pDataObject,
    LPCONTEXTMENUCALLBACK piCallback,
    long *pInsertionAllowed)
{
	ATLTRACE(_T("IExtendContextMenuImpl::AddMenuItems\n"));

	HRESULT hr = E_POINTER;

	ATLASSERT(pDataObject != NULL);
	if (pDataObject == NULL)
		ATLTRACE(_T("IExtendContextMenu::AddMenuItems called with pDataObject==NULL\n"));
	else
	{
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;
		hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

		if (SUCCEEDED(hr))
			hr = pItem->AddMenuItems(piCallback, pInsertionAllowed, type);
	}
	return hr;
}

template <class T>
inline HRESULT IExtendContextMenuImpl<T>::Command(long lCommandID,
    LPDATAOBJECT pDataObject)
{
	ATLTRACE(_T("IExtendContextMenuImpl::Command\n"));

	HRESULT hr = E_POINTER;

	ATLASSERT(pDataObject != NULL);
	if (pDataObject == NULL)
		ATLTRACE(_T("IExtendContextMenu::Command called with pDataObject==NULL\n"));
	else
	{
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;
		hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);
		
		if (SUCCEEDED(hr))
			hr = pItem->Command(lCommandID, (CSnapInObjectRootBase*)pT, type);
	}
	return hr;
}

template<class T>
class ATL_NO_VTABLE IExtendPropertySheetImpl : public IExtendPropertySheet
{
public:
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        LPDATAOBJECT pDataObject);
    
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);
};

template<class T>
inline HRESULT IExtendPropertySheetImpl<T>::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle,
    LPDATAOBJECT pDataObject)
{
	ATLTRACE(_T("IExtendPropertySheetImpl::CreatePropertyPages\n"));

	HRESULT hr = E_POINTER;

	ATLASSERT(pDataObject != NULL);
	if (pDataObject == NULL)
		ATLTRACE(_T("IExtendPropertySheetImpl::CreatePropertyPages called with pDataObject==NULL\n"));
	else
	{
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;
		hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

		if (SUCCEEDED(hr))
			hr = pItem->CreatePropertyPages(lpProvider, handle, this, type);
	}

	return hr;
}

template <class T>
inline HRESULT IExtendPropertySheetImpl<T>::QueryPagesFor(LPDATAOBJECT pDataObject)
{
	ATLTRACE(_T("IExtendPropertySheetImpl::QueryPagesFor\n"));
	

	HRESULT hr = E_POINTER;
	
	ATLASSERT(pDataObject != NULL);
	if (pDataObject == NULL)
		ATLTRACE(_T("IExtendPropertySheetImpl::QueryPagesFor called with pDataObject==NULL\n"));
	else
	{
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;
		hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

		if (SUCCEEDED(hr))
			hr = pItem->QueryPagesFor(type);
	}
	return hr;
}

template <class T>
class ATL_NO_VTABLE IExtendControlbarImpl : public IExtendControlbar
{
public:
	STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar)
	{
		ATLTRACE(_T("IExtendControlbarImpl::SetControlbar\n"));
		T* pT = static_cast<T*>(this);

		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		pT->m_spControlbar = pControlbar;
		return S_OK;
	}
    
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param);
};

template <class T>
inline HRESULT IExtendControlbarImpl<T>::ControlbarNotify(MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM param)
{
	ATLTRACE(_T("IExtendControlbarImpl::ControlbarNotify\n"));

	CSnapInItem* pItem = NULL;
	DATA_OBJECT_TYPES type = CCT_UNINITIALIZED;
	HRESULT hr = S_OK;
	T* pT = static_cast<T*>(this);

	if (event == MMCN_BTN_CLICK)
		hr = pT->m_pComponentData->GetDataClass((IDataObject*) arg, &pItem, &type);
	else if (event == MMCN_SELECT)
	{
		hr = pT->m_pComponentData->GetDataClass((IDataObject*) param, &pItem, &type);
		BOOL bSelect = (BOOL) HIWORD (arg);
		BOOL bScope = (BOOL) LOWORD(arg); 
		if (bSelect)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
					pT->m_spControlbar->Detach(pToolbar);
			}
		}
	}

	if (SUCCEEDED(hr))
		hr = pItem->ControlbarNotify(pT->m_spControlbar, this, &(pT->m_toolbarMap), event, arg, param, (CSnapInObjectRootBase*) pT, type);

	return hr;
}
#define SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define EXT_SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define BEGIN_SNAPINCOMMAND_MAP(theClass, bIsExtension) \
	HRESULT ProcessCommand(UINT nID, \
		bool& bHandled, \
		CSnapInObjectRootBase* pObj, \
		DATA_OBJECT_TYPES type) \
	{ \
			bHandled = true; \
			HRESULT hr = S_OK; \
			UNREFERENCED_PARAMETER(nID); \
			UNREFERENCED_PARAMETER(pObj); \
			UNREFERENCED_PARAMETER(type);

#define SNAPINCOMMAND_ENTRY(id, func) \
		if (id == nID) \
		{ \
			hr = func(bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

#define SNAPINCOMMAND_RANGE_ENTRY(id1, id2, func) \
		if (id1 >= nID && nID <= id2) \
		{ \
			hr = func(nID, bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

#define CHAIN_SNAPINCOMMAND_MAP(theChainClass) \
	{ \
		hr = theChainClass::ProcessCommand(nID, bHandled, pObj, type); \
		if (bHandled) \
			return hr; \
	}

#define END_SNAPINCOMMAND_MAP() \
			return hr; \
	}

struct CSnapInToolBarData
{
	WORD wVersion;
	WORD wWidth;
	WORD wHeight;
	WORD wItemCount;
	//WORD aItems[wItemCount]

	WORD* items()
		{ return (WORD*)(this+1); }
};

#define RT_TOOLBAR  MAKEINTRESOURCE(241)
	
class CSnapInToolbarInfo
{
public:
	~CSnapInToolbarInfo()
	{
		CleanUp();
	}

	HRESULT CleanUp()
	{
		if (m_pStrToolTip)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrToolTip[i];
				m_pStrToolTip[i] = NULL;
			}
			delete [] m_pStrToolTip;
			m_pStrToolTip = NULL;
		}

		if (m_pStrButtonText)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrButtonText[i];
				m_pStrButtonText[i] = NULL;
			}

			delete [] m_pStrButtonText;
			m_pStrButtonText = NULL;
		}
		if (m_pnButtonID)
		{
			delete m_pnButtonID;
			m_pnButtonID = NULL;
		}

		m_nButtonCount = 0;
		return S_OK;
	}

	OLECHAR** m_pStrToolTip;
	OLECHAR** m_pStrButtonText;
	UINT* m_pnButtonID;
	UINT m_idToolbar;
	UINT m_nButtonCount;
};

#define BEGIN_SNAPINTOOLBARID_MAP(theClass) \
public: \
	static CSnapInToolbarInfo* GetToolbarInfo() \
	{ \
		static CSnapInToolbarInfo m_toolbarInfo[] = \
		{

#define SNAPINTOOLBARID_ENTRY(id) \
			{ NULL, NULL, NULL, id, 0},

#define END_SNAPINTOOLBARID_MAP() \
			{ NULL, NULL, NULL, 0, 0} \
		}; \
		return m_toolbarInfo; \
	}	

template <class T, BOOL bIsExtension = FALSE>
class ATL_NO_VTABLE CSnapInItemImpl : public CSnapInItem
{
public:
	CSnapInItemImpl()
	{
	}

	virtual ~CSnapInItemImpl()
	{
	}    

public:

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE /*event*/,
        LPARAM /*arg*/,
        LPARAM /*param*/,
		IComponentData* /*pComponentData*/,
		IComponent* /*pComponent*/,
		DATA_OBJECT_TYPES /*type*/)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::Notify"));
	}
    
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM * /*pScopeDataItem*/)
	{
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetScopePaneInfo"));
	}
    
    STDMETHOD(GetResultViewType)(LPOLESTR *ppViewType,
        long *pViewOptions)
	{
		ATLTRACE(_T("CSnapInItemImpl::GetResultViewType\n"));
		*ppViewType = NULL;
		*pViewOptions = MMC_VIEW_OPTIONS_NONE;
		return S_FALSE;
	}
    
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM * /*pResultDataItem*/)
	{
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetResultPaneInfo"));
	}
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed,
		DATA_OBJECT_TYPES /*type*/)
	{
		ATLTRACE(_T("CSnapInItemImpl::AddMenuItems\n"));
		T* pT = static_cast<T*>(this);

		if (!bIsExtension)
			pT->SetMenuInsertionFlags(true, pInsertionAllowed);

				
		UINT menuID = pT->GetMenuID();
		if (menuID == 0)
			return S_OK;

		HMENU hMenu = LoadMenu(g_hResourceMod, MAKEINTRESOURCE(menuID));
		long insertionID;
		if (hMenu)
		{
			for (int i = 0; 1; i++)
			{
				HMENU hSubMenu = GetSubMenu(hMenu, i);
				if (hSubMenu == NULL)
					break;
				
				MENUITEMINFO menuItemInfo;
				memset(&menuItemInfo, 0, sizeof(menuItemInfo));
				menuItemInfo.cbSize = sizeof(menuItemInfo);

				switch (i)
				{
				case 0:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
					break;

				case 1:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_NEW;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
					break;

				case 2:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
					break;
				case 3:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
					break;
				default:
					{
						insertionID = 0;
						continue;
					}
					break;
				}

				menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
				menuItemInfo.fType = MFT_STRING;
				TCHAR szMenuText[128];

				for (int j = 0; 1; j++)
				{
					menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
					menuItemInfo.fType = MFT_STRING;
					menuItemInfo.cch = 128;
					menuItemInfo.dwTypeData = szMenuText;
					TCHAR szStatusBar[256];

					if (!GetMenuItemInfo(hSubMenu, j, TRUE, &menuItemInfo))
						break;
					if (menuItemInfo.fType != MFT_STRING)
						continue;

					pT->UpdateMenuState(menuItemInfo.wID, szMenuText, &menuItemInfo.fState);
					LoadString(g_hResourceMod, menuItemInfo.wID, szStatusBar, 256);

					OLECHAR wszStatusBar[256];
					OLECHAR wszMenuText[128];
					USES_CONVERSION;
					ocscpy(wszMenuText, T2OLE(szMenuText));
					ocscpy(wszStatusBar, T2OLE(szStatusBar));

					CONTEXTMENUITEM contextMenuItem;
					contextMenuItem.strName = wszMenuText;
					contextMenuItem.strStatusBarText = wszStatusBar;
					contextMenuItem.lCommandID = menuItemInfo.wID;
					contextMenuItem.lInsertionPointID = insertionID;
					contextMenuItem.fFlags = menuItemInfo.fState;
					contextMenuItem.fSpecialFlags = 0;
					
					HRESULT hr = piCallback->AddItem(&contextMenuItem);
					ATLASSERT(SUCCEEDED(hr));
				}
			}
			DestroyMenu(hMenu);
		}

		if (!bIsExtension)
			pT->SetMenuInsertionFlags(true, pInsertionAllowed);

		return S_OK;
	}
    
    STDMETHOD(Command)(long lCommandID,		
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(_T("CSnapInItemImpl::Command\n"));
		bool bHandled;
		T* pT = static_cast<T*>(this);
		return pT->ProcessCommand(lCommandID, bHandled, pObj, type);
	}
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK /*lpProvider*/,
        LONG_PTR /*handle*/, 
		IUnknown* /*pUnk*/,
		DATA_OBJECT_TYPES /*type*/)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::CreatePropertyPages"));
	}
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES /*type*/)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::QueryPagesFor"));
	}

    STDMETHOD(SetControlbar)(IControlbar *pControlbar, 
		IExtendControlbar* pExtendControlBar,
		CMySimpleMap<UINT, IUnknown*>* pToolbarMap)
	{
		ATLTRACE(_T("CSnapInItemImpl::SetControlbar\n"));
		T* pT = static_cast<T*>(this);

		CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
		if (pInfo == NULL)
			return S_OK;

		for( ; pInfo->m_idToolbar; pInfo++)
		{
			IToolbar* p = (IToolbar*) pToolbarMap->Lookup(pInfo->m_idToolbar);
			if (p != NULL)
				continue;

			HBITMAP hBitmap = LoadBitmap(g_hResourceMod, MAKEINTRESOURCE(pInfo->m_idToolbar));
			if (hBitmap == NULL)
				return S_OK;

			HRSRC hRsrc = ::FindResource(g_hResourceMod, MAKEINTRESOURCE(pInfo->m_idToolbar), RT_TOOLBAR);
			if (hRsrc == NULL)
				return S_OK;

			HGLOBAL hGlobal = LoadResource(g_hResourceMod, hRsrc);
			if (hGlobal == NULL)
				return S_OK;

			CSnapInToolBarData* pData = (CSnapInToolBarData*)LockResource(hGlobal);
			if (pData == NULL)
				return S_OK;
			ATLASSERT(pData->wVersion == 1);
			ATLASSERT(pData->wWidth == 16);
			ATLASSERT(pData->wHeight == 16);

			pInfo->m_nButtonCount = pData->wItemCount;
			if (pInfo->m_pnButtonID == NULL)
				pInfo->m_pnButtonID = new UINT[pInfo->m_nButtonCount];

			if (pInfo->m_pnButtonID == NULL)
				continue;

			MMCBUTTON *pButtons = new MMCBUTTON[pData->wItemCount];
			if (pButtons == NULL)
			{
				delete []pInfo->m_pnButtonID;
				continue;
			}
			
			if (pInfo->m_pStrToolTip == NULL)
			{
				pInfo->m_pStrToolTip = new OLECHAR* [pData->wItemCount];
				if (pInfo->m_pStrToolTip)
					memset(pInfo->m_pStrToolTip, 0, sizeof(OLECHAR*) * pData->wItemCount);
			}

			if (pInfo->m_pStrToolTip == NULL)
			{
				delete []pInfo->m_pnButtonID;
				delete []pButtons;
				continue;
			}


			for (int i = 0, j = 0; i < pData->wItemCount; i++)
			{
				pInfo->m_pnButtonID[i] = pButtons[i].idCommand = pData->items()[i];
				if (pButtons[i].idCommand)
				{
					pButtons[i].nBitmap = j++;
					// get the statusbar string and allow modification of the button state
					TCHAR szStatusBar[512];
					LoadString(g_hResourceMod, pButtons[i].idCommand, szStatusBar, 512);

					if (pInfo->m_pStrToolTip[i] == NULL)
						pInfo->m_pStrToolTip[i] = new OLECHAR[lstrlen(szStatusBar) + 1];
					if (pInfo->m_pStrToolTip[i] == NULL)
						continue;
					USES_CONVERSION;
					ocscpy(pInfo->m_pStrToolTip[i], T2OLE(szStatusBar));
					pButtons[i].lpTooltipText = pInfo->m_pStrToolTip[i];
					pButtons[i].lpButtonText = OLESTR("");
					pButtons[i].fsState = TBSTATE_ENABLED;
					pButtons[i].fsType = TBSTYLE_BUTTON;
					pT->SetToolbarButtonInfo(pButtons[i].idCommand, &pButtons[i].fsState, &pButtons[i].fsType);
				}
				else
				{
					pButtons[i].lpTooltipText = OLESTR("");
					pButtons[i].lpButtonText = OLESTR("");
					pButtons[i].fsType = TBSTYLE_SEP;
					pButtons[i].fsState = 0;
				}
			}

			IToolbar* pToolbar;
	        HRESULT hr = pControlbar->Create(TOOLBAR, pExtendControlBar, reinterpret_cast<LPUNKNOWN*>(&pToolbar));
			if (SUCCEEDED(hr))
			{

				hr = pToolbar->AddBitmap(pData->wItemCount, hBitmap, pData->wWidth, pData->wHeight, RGB(192, 192, 192));
				if (SUCCEEDED(hr))
				{
					hr = pToolbar->AddButtons(pData->wItemCount, pButtons);
					if (SUCCEEDED(hr))
					{
						pToolbar->AddRef();
						pToolbarMap->Add(pInfo->m_idToolbar, (IUnknown*)pToolbar);
					}
				}
			}
			pToolbar->Release();
			delete [] pButtons;
		}
		return S_OK;
	}
    
    STDMETHOD(ControlbarNotify)(IControlbar *pControlbar,
        IExtendControlbar *pExtendControlbar,
		CMySimpleMap<UINT, IUnknown*>* pToolbarMap,
		MMC_NOTIFY_TYPE event,
        LPARAM arg, 
		LPARAM param,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(_T("CSnapInItemImpl::ControlbarNotify\n"));
		T* pT = static_cast<T*>(this);

		SetControlbar(pControlbar, pExtendControlbar, pToolbarMap);

		if(event == MMCN_SELECT)
		{
			if (pControlbar == NULL)
				return S_OK;

			BOOL bSelect = (BOOL) HIWORD (arg);
			if (!bSelect)
				return S_OK;
			BOOL bScope = (BOOL) LOWORD(arg); 

			CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
			if (pInfo == NULL)
				return S_OK;

			for(; pInfo->m_idToolbar; pInfo++)
			{
				IToolbar* pToolbar = (IToolbar*)pToolbarMap->Lookup(pInfo->m_idToolbar);
				if (pToolbar == NULL)
					continue;

				pControlbar->Attach(TOOLBAR, pToolbar);
				for (UINT i = 0; i < pInfo->m_nButtonCount; i++)
				{
					if (pInfo->m_pnButtonID[i])
					{
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							ENABLED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								ENABLED));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							CHECKED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								CHECKED));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							HIDDEN,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								HIDDEN));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							INDETERMINATE,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								INDETERMINATE));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							BUTTONPRESSED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								BUTTONPRESSED));
					}
				}
			}
			return S_OK;
		}
		else if (event == MMCN_BTN_CLICK)
		{
			bool bHandled;
			return pT->ProcessCommand((UINT) param, bHandled, pObj, type);
		}

		return E_UNEXPECTED;
	}

	STDMETHOD(GetScopeData)(SCOPEDATAITEM **pScopeDataItem)
	{
		if (pScopeDataItem == NULL)
			return E_FAIL;

		*pScopeDataItem = &m_scopeDataItem;
		return S_OK;
	}
        
    STDMETHOD(GetResultData)(RESULTDATAITEM **pResultDataItem)
	{
		if (pResultDataItem == NULL)
			return E_FAIL;

		*pResultDataItem = &m_resultDataItem;
		return S_OK;
	}

	STDMETHOD(GetDataObject)(IDataObject** pDataObj, DATA_OBJECT_TYPES type)
	{
		CComObject<CSnapInDataObjectImpl>* pData;
		HRESULT hr = CComObject<CSnapInDataObjectImpl>::CreateInstance(&pData);
		if (FAILED(hr))
			return hr;

		T* pT = static_cast<T*> (this);
		pData->m_objectData.m_pItem = pT;
		pData->m_objectData.m_type = type;

		hr = pData->QueryInterface(IID_IDataObject, (void**)(pDataObj));
		return hr;
	}

	void UpdateMenuState(UINT /*id*/, LPTSTR /*pBuf*/, UINT * /*flags*/)
	{
		return;
	}

	void SetToolbarButtonInfo(UINT /*id*/, BYTE *pfsState, BYTE *pfsType)
	{
		*pfsState = TBSTATE_ENABLED;
		*pfsType = TBSTYLE_BUTTON;
	}

	BOOL UpdateToolbarButton(UINT /*id*/, BYTE fsState)
	{
		if (fsState == ENABLED)
			return TRUE;
		return FALSE;
	}

	HRESULT ProcessCommand(UINT nID, 
		bool& /*bHandled*/,
		CSnapInObjectRootBase* /*pObj*/,
		DATA_OBJECT_TYPES /*type*/)
	{
		ATLTRACE(_T("No handler for item with ID %d\n"), nID);
		return S_OK;
	}

	STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream)
	{
		HRESULT hr = DV_E_CLIPFORMAT;
		ULONG uWritten;

		T* pT = static_cast<T*> (this);

		if (cf == m_CCF_NODETYPE)
		{
			hr = pStream->Write(pT->GetNodeType(), sizeof(GUID), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SZNODETYPE)
		{
			hr = pStream->Write(pT->GetSZNodeType(), (ocslen((OLECHAR*)pT->GetSZNodeType()) + 1 )* sizeof(OLECHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_DISPLAY_NAME)
		{
			hr = pStream->Write(pT->GetDisplayName(), (ocslen((OLECHAR*)pT->GetDisplayName()) + 1) * sizeof(OLECHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SNAPIN_CLASSID)
		{
			hr = pStream->Write(pT->GetSnapInCLSID(), sizeof(GUID), &uWritten);
			return hr;
		}

		return hr;
	}

	static CSnapInToolbarInfo* GetToolbarInfo()
	{
		return NULL;
	}

	static const UINT GetMenuID() 
	{
		return 0;
	}

	void SetMenuInsertionFlags(bool /*bBeforeInsertion*/, long* /*pInsertionAllowed*/)
	{
	}

	void* GetNodeType()
	{
		return (void*)T::m_NODETYPE;
	}
	void* GetSZNodeType()
	{
		return (void*)T::m_SZNODETYPE;
	}

	void* GetDisplayName()
	{
		return (void*)T::m_SZDISPLAY_NAME;
	}

	void* GetSnapInCLSID()
	{
		return (void*)T::m_SNAPIN_CLASSID;
	}

	CComBSTR m_bstrDisplayName;
	SCOPEDATAITEM m_scopeDataItem;
	RESULTDATAITEM m_resultDataItem;
};


_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_NODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SZNODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_DISPLAY_NAME = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_CLASSID = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_MMC_MULTISELECT_DATAOBJECT = 0;

#endif //__ATL_SNAPIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\certgen.cpp ===
// CertGen.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqcert.h"
#include "mqPPage.h"
#include "CertGen.h"
#include "mqcertui.h"
#include "rtcert.h"

#include "certgen.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCertGen property page

IMPLEMENT_DYNCREATE(CCertGen, CMqPropertyPage)

CCertGen::CCertGen() :
    CMqPropertyPage(CCertGen::IDD),
    m_pCertListBox(NULL),
    m_pCertList(NULL),
    m_NumOfCertificate(0),
    m_pSid(NULL)
{
	//{{AFX_DATA_INIT(CCertGen)
	m_Label = _T("");
	//}}AFX_DATA_INIT
}

CCertGen::~CCertGen()
{
    for(DWORD i = 0; i < m_NumOfCertificate; ++i)
    {
        m_pCertList[i]->Release();
    }

    delete [] m_pCertList;

    if (m_pSid != NULL)
    {
        delete m_pSid ;
    }
}

void CCertGen::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCertGen)
	DDX_Text(pDX, IDC_CERTLABEL, m_Label);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCertGen, CMqPropertyPage)
	//{{AFX_MSG_MAP(CCertGen)
	ON_BN_CLICKED(IDC_CERT_VIEW, OnCertView)
	ON_BN_CLICKED(IDC_CERT_REMOVE, OnCertRemove)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


void
CCertGen::Initialize(
    CMQSigCertificate** ppCertList,
    DWORD NumOfCertificate,
    SID  *pSid
    )
{
    m_pCertList = ppCertList;
    m_NumOfCertificate = NumOfCertificate;

    if (pSid != NULL)
    {
        DWORD dwLen = GetLengthSid(pSid) ;
        m_pSid = (SID *) new BYTE[ dwLen ] ;
        BOOL fCopy = CopySid(dwLen, m_pSid, pSid) ;
        if (!fCopy)
        {
            ASSERT(fCopy) ;
            delete m_pSid ;
            m_pSid = NULL ;
        }
    }
}

//
// Function -
//      FillCertsList
//
// Parameters
//      None.
//
// Description -
//      Goes over the entries in p509List, for each entry puts the common name
//      of the X509 cert subject in the list box.
//
void
CCertGen::FillCertsList(
    void
    )
{
    DWORD i;
    CMQSigCertificate* pCert ;

    ASSERT(m_pCertList != NULL);
    ASSERT(m_NumOfCertificate != 0);


    for (i = 0; i < m_NumOfCertificate; ++i)
    {
        HRESULT hr;
        pCert = m_pCertList[i];

        CAutoMQFree<CERT_NAME_INFO> pNameInfo ;

        hr = pCert->GetSubjectInfo(&pNameInfo);
        if (SUCCEEDED(hr))
        {
            CAutoMQFree<WCHAR> wszCommonName = NULL;
            hr = pCert->GetNames(
                            pNameInfo,
                            NULL,
                            NULL,
                            NULL,
                            &wszCommonName
                            );


            if (SUCCEEDED(hr) && (wszCommonName != NULL) )
            {
                int iNewItem;

                VERIFY(CB_ERR != (iNewItem = m_pCertListBox->AddString(wszCommonName)));
                VERIFY(CB_ERR != m_pCertListBox->SetItemData(iNewItem, i));
            }
        }
    }
}

BOOL CCertGen::OnInitDialog()
{
    //
    // This closure is used to keep the DLL state. For UpdateData we need
    // the mmc.exe state.
    //
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        //
        // Load Label
        //
        m_Label.LoadString(IDS_SHOWCERTINSTR);

        //
        // Initialize pointer to ListBox
        //
        m_pCertListBox = (CListBox *)GetDlgItem(IDC_CERT_LIST);
        FillCertsList();
    }

    UpdateData(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CCertGen::OnCertView()
{
    HRESULT hr;
    BOOL fInternal = FALSE;

    DWORD_PTR Index;
    int iSelected;

    //
    // Get the index of the selected cell on the Certificate array
    //
    iSelected = m_pCertListBox->GetCurSel();
    if (CB_ERR == iSelected)
    {
        return;
    }

    VERIFY(CB_ERR != (Index = m_pCertListBox->GetItemData(iSelected)));

    CMQSigCertificate *pCertSel = m_pCertList[Index];

    CAutoMQFree<CERT_NAME_INFO> pNameInfo ;

    hr =  pCertSel->GetSubjectInfo(&pNameInfo);
    if (SUCCEEDED(hr))
    {
        CAutoMQFree<WCHAR> wszLocality = NULL;
        hr = pCertSel->GetNames(
                            pNameInfo,
                            &wszLocality,
                            NULL,
                            NULL,
                            NULL
                            );

        if (SUCCEEDED(hr) && (wszLocality != NULL) )
        {
            fInternal = (wcscmp(wszLocality, L"MSMQ") == 0);
        }
    }

    ShowCertificate(m_hWnd, pCertSel, fInternal);

}


void CCertGen::OnCertRemove()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr;
    DWORD_PTR Index;
    int iSelected;

    //
    // Get the index of the selected cell on the Certificate array
    //
    iSelected = m_pCertListBox->GetCurSel();
    if (CB_ERR == iSelected)
    {
        return;
    }
    VERIFY(CB_ERR != (Index = m_pCertListBox->GetItemData(iSelected)));

    CMQSigCertificate *pCertSel = m_pCertList[Index];

    hr = RTRemoveUserCert(pCertSel);

    if ((hr == MQDS_OBJECT_NOT_FOUND) && (m_pSid != NULL))
    {
        //
        // Try to delete by SID.
        // NT bug 516098.
        //
        hr = RTRemoveUserCertSid(pCertSel, m_pSid);
    }

    if (FAILED(hr))
    {
        CString  strErrorMessage;

        strErrorMessage.FormatMessage(IDS_DELETE_USER_CERT_ERROR, hr);
        AfxMessageBox(strErrorMessage, MB_OK | MB_ICONEXCLAMATION);
        return;
    }

    VERIFY(LB_ERR != m_pCertListBox->DeleteString(iSelected));

    if (m_pCertListBox->GetCount() == 0)
    {
        CWnd* pWin;

        pWin = GetDlgItem(IDC_CERT_VIEW);
        pWin->EnableWindow(FALSE);
        pWin = GetDlgItem(IDC_CERT_REMOVE);
        pWin->EnableWindow(FALSE);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\client.h ===
// ClientPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CClientPage dialog

class CClientPage : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CClientPage)

// Construction
public:
	CClientPage();
	~CClientPage();

// Dialog Data
	//{{AFX_DATA(CClientPage)
	enum { IDD = IDD_CLIENT };
	CString	m_szServerName;
	//}}AFX_DATA
	TCHAR   m_szOldServer[1000];  

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CClientPage)
    public:
    virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CClientPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\compdiag.cpp ===
// CompDiag.cpp : implementation file
//

#include "stdafx.h"
#include <_mqini.h>

#include "resource.h"
#include "globals.h"
#include "admmsg.h"
#include "mqsnap.h"
#include "mqPPage.h"
#include "testmsg.h"
#include "machtrac.h"
#include "CompDiag.h"

#include "compdiag.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqDiag property page

IMPLEMENT_DYNCREATE(CComputerMsmqDiag, CMqPropertyPage)

CComputerMsmqDiag::CComputerMsmqDiag(
	) : 
	CMqPropertyPage(CComputerMsmqDiag::IDD),
	m_fLocalMgmt(FALSE)
{
	//{{AFX_DATA_INIT(CComputerMsmqDiag)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CComputerMsmqDiag::~CComputerMsmqDiag()
{
}

void CComputerMsmqDiag::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CComputerMsmqDiag)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CComputerMsmqDiag, CMqPropertyPage)
	//{{AFX_MSG_MAP(CComputerMsmqDiag)
	ON_BN_CLICKED(IDC_DIAG_PING, OnDiagPing)
	ON_BN_CLICKED(IDC_DIAG_SEND_TEST, OnDiagSendTest)
	ON_BN_CLICKED(IDC_DIAG_TRACKING, OnDiagTracking)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqDiag message handlers

void CComputerMsmqDiag::OnDiagPing() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    MQPing(m_guidQM);

}

LONG
MQUTIL_EXPORT
APIENTRY
GetFalconKeyValue(  LPCWSTR  pszValueName,
                    PDWORD   pdwType,
                    PVOID    pData,
                    PDWORD   pdwSize,
                    LPCWSTR  pszDefValue = NULL ) ;

BOOL CComputerMsmqDiag::OnInitDialog() 
{
	CString label;
	CString localComputerName;
	GetComputerNameIntoString(localComputerName);
	localComputerName.MakeUpper();

	label.FormatMessage(IDS_DIAG_PING_LABEL, localComputerName, m_strMsmqName);
	(GetDlgItem(IDC_DIAG_PING_LABEL))->SetWindowText(label);

	label.FormatMessage(IDS_DIAG_SENDTEST_LABEL, m_strMsmqName);
	(GetDlgItem(IDC_DIAG_SENDTEST_LABEL))->SetWindowText(label);

	label.FormatMessage(IDS_DIAG_TRACKING_LABEL, m_strMsmqName);
	(GetDlgItem(IDC_DIAG_TRACKING_LABEL))->SetWindowText(label);

	//
	//check if tracking messages is enabled by looking 
	//at the EnableReportMessages registry key
	//
	DWORD dwType = REG_DWORD;
    DWORD dwData=0;
    DWORD dwSize = sizeof(DWORD) ;
    HRESULT rc = GetFalconKeyValue(
    					MSMQ_REPORT_MESSAGES_REGNAME,
                        &dwType,
                        (PVOID)&dwData,
						&dwSize 
						);
    //
	//enable the tracking window only if 
	//EnableReportMessages registry is valid and is 1.
	//
	if(dwData==0)
	{
		(GetDlgItem(IDC_DIAG_TRACKING))->EnableWindow(FALSE);
		(GetDlgItem(IDC_DIAG_SEND_TEST))->EnableWindow(FALSE);
	}

	UpdateData( FALSE );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CComputerMsmqDiag::OnDiagSendTest() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CTestMsgDlg testMsgDlg(m_guidQM, m_strMsmqName, m_strDomainController, m_fLocalMgmt, this);	
    testMsgDlg.DoModal();
}

void CComputerMsmqDiag::OnDiagTracking() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CMachineTracking machTracking(m_guidQM, m_strDomainController, m_fLocalMgmt);
    machTracking.DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\cmpmrout.h ===
#if !defined(AFX_CMPMROUT_H__E62F8209_B71C_11D1_808D_00A024C48131__INCLUDED_)
#define AFX_CMPMROUT_H__E62F8209_B71C_11D1_808D_00A024C48131__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CmpMRout.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqRouting dialog
const DWORD x_dwMaxNumOfFrs = 3;

class CComputerMsmqRouting : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CComputerMsmqRouting)

// Construction
public:
	CACLSID m_guidSiteIDs;
	CComputerMsmqRouting();
	~CComputerMsmqRouting();

    void InitiateOutFrsValues(const CACLSID *pcauuid);
    void InitiateInFrsValues(const CACLSID *pcauuid);
	void InitiateSiteIDsValues(const CACLSID *pcauuid);
	
// Dialog Data
	//{{AFX_DATA(CComputerMsmqRouting)
	enum { IDD = IDD_COMPUTER_MSMQ_ROUTING };
	//}}AFX_DATA
	CString	m_strMsmqName;
	CString	m_strDomainController;

	BOOL m_fLocalMgmt;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CComputerMsmqRouting)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation

protected:
   	HRESULT InitiateInFrsControls();
   	HRESULT InitiateOutFrsControls();
   	HRESULT InitiateFrsControls(CACLSID &cauuid, CFrsList *pfrsListArray);
   	void CopyCaclsid(CACLSID &cauuidResult, const CACLSID *pcauuidSource);

    CACLSID m_caclsidOutFrs;
    CACLSID m_caclsidInFrs;
    GUID m_OutFrsGuids[x_dwMaxNumOfFrs];
    GUID m_InFrsGuids[x_dwMaxNumOfFrs];

	CFrsList m_frscmbInFrs[x_dwMaxNumOfFrs];
	CFrsList m_frscmbOutFrs[x_dwMaxNumOfFrs];
    void SetOutFrsCauuid();
    void SetInFrsCauuid();
    void SetFrsCauuid(CACLSID &cauuid, GUID *aguid, CFrsList *frscmb);
	// Generated message map functions
	//{{AFX_MSG(CComputerMsmqRouting)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

inline void CComputerMsmqRouting::InitiateOutFrsValues(const CACLSID *pcauuid)
{
    CopyCaclsid(m_caclsidOutFrs, pcauuid);
}

inline void CComputerMsmqRouting::InitiateInFrsValues(const CACLSID *pcauuid)
{
    CopyCaclsid(m_caclsidInFrs, pcauuid);
}

inline void CComputerMsmqRouting::InitiateSiteIDsValues(const CACLSID *pcauuid)
{
	m_guidSiteIDs.cElems = pcauuid->cElems;
	m_guidSiteIDs.pElems = new GUID[m_guidSiteIDs.cElems];
    CopyCaclsid(m_guidSiteIDs, pcauuid);
}

inline HRESULT CComputerMsmqRouting::InitiateInFrsControls()
{
    return InitiateFrsControls(m_caclsidInFrs, m_frscmbInFrs);
}

inline HRESULT CComputerMsmqRouting::InitiateOutFrsControls()
{
    return InitiateFrsControls(m_caclsidOutFrs, m_frscmbOutFrs);
}

inline void CComputerMsmqRouting::SetOutFrsCauuid()
{
    SetFrsCauuid(m_caclsidOutFrs, m_OutFrsGuids, m_frscmbOutFrs);
}

inline void CComputerMsmqRouting::SetInFrsCauuid()
{
    SetFrsCauuid(m_caclsidInFrs, m_InFrsGuids, m_frscmbInFrs);
}

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMPMROUT_H__E62F8209_B71C_11D1_808D_00A024C48131__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\compext.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	compext.cpp

Abstract:
    Implementation of the Computer extension snapin

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "rt.h"
#include "dataobj.h"
#include "sysq.h"
#include "compext.h"
#include "ldaputl.h"
#include "dsext.h"
#include "qnmsprov.h"
#include "localfld.h"
#include "singelton.h"
#include "compext.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

template <class T>class CSingletonCS;
class CPublicQueuesDisplayBehavior
{
public:
    bool IsScopePopulated()
    {
        return m_bPopulateScope;
    }

private:
    CPublicQueuesDisplayBehavior():m_bPopulateScope(true)
    {
        LPCWSTR x_AttrPossibleInferiors[1] = {L"possibleInferiors"};
        const WCHAR x_DnMsmqQueueClassSchema[] = L"CN=MSMQ-Queue";

        CComVariant var;
        HRESULT hr = ADGetGenObjectProperties(
                           eSchema,
                           NULL,
                           false,
                           x_DnMsmqQueueClassSchema,
                           1,
                           x_AttrPossibleInferiors,
                           &var
                           );

        if( FAILED(hr) || V_VT(&var) == VT_EMPTY )
            return;

        //
        // The value must be the safearray
        //
        if((V_VT(&var) & VT_ARRAY) && (V_ARRAY(&var)->rgsabound[0].cElements > 0))
        {
            m_bPopulateScope = false;
            return;
        }

        //
        // .. or string
        //
        if( V_VT(&var) == VT_BSTR && SysStringLen(V_BSTR(&var)) )
        {
            m_bPopulateScope = false;
            return;
        }
    }

private:
    friend CSingletonCS<CPublicQueuesDisplayBehavior>; // this object can only be created by CSingelton<CPublicQueuesDisplayBehavior>
    bool m_bPopulateScope;
};


/****************************************************

CSnapinComputer Class

 ****************************************************/

/////////////////////////////////////////////////////////////////////////////
// {3FDC5B21-D4EB-11d1-9B9D-00E02C064C39}
static const GUID CSnapinComputerGUID_NODETYPE =
{ 0x3fdc5b21, 0xd4eb, 0x11d1, { 0x9b, 0x9d, 0x0, 0xe0, 0x2c, 0x6, 0x4c, 0x39 } };

const GUID*  CSnapinComputer::m_NODETYPE = &CSnapinComputerGUID_NODETYPE;
const OLECHAR* CSnapinComputer::m_SZNODETYPE = OLESTR("3FDC5B21-D4EB-11d1-9B9D-00E02C064C39");
const OLECHAR* CSnapinComputer::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CSnapinComputer::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComputer::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinComputer::PopulateScopeChildrenList()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (m_fDontExpand)
    {
        //
        // We don't need the scode data item if we do not expand the node
        //
       	memset(&m_scopeDataItem, 0, sizeof(m_scopeDataItem));
        return m_hrError;
    }

    HRESULT hr = S_OK;
    CString strTitle;
    //
    // Add a system queue folder
    //
    CSystemQueues *pQ;

    pQ = new CSystemQueues(this, m_pComponentData, m_pwszComputerName);
    strTitle.LoadString(IDS_SYSTEM_QUEUES);
    pQ->m_bstrDisplayName = strTitle;
    pQ->m_pwszGuid = m_pwszGuid;
    memcpy(&pQ->m_guidId, &m_guidId, sizeof(GUID));

   	AddChild(pQ, &pQ->m_scopeDataItem);


    //
    // Add a private queue folder
    //
    CPrivateFolder * pF;

    pF = new CPrivateFolder(this, m_pComponentData, m_pwszComputerName);
    strTitle.LoadString(IDS_PRIVATE_FOLDER);
    pF->m_bstrDisplayName = strTitle;
    pF->m_pwszGuid = m_pwszGuid;
    memcpy(&pF->m_guidId, &m_guidId, sizeof(GUID));

	AddChild(pF, &pF->m_scopeDataItem);


    //
    // Check if we need to add the public queues to the scope pane
    //
    if( !CSingletonCS<CPublicQueuesDisplayBehavior>::get().IsScopePopulated() )
        return(hr);

    //
    // Add a public queues folder
    //
    strTitle.LoadString(IDS_LOCALPUBLIC_FOLDER);
    CLocalPublicFolder * lpubF = new CLocalPublicFolder(
                                           this,
                                           m_pComponentData,
                                           m_pwszComputerName,
                                           strTitle,
                                           FALSE
                                           );

    AddChild(lpubF, &lpubF->m_scopeDataItem);


    return(hr);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComputer::OnRemoveChildren

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSnapinComputer::OnRemoveChildren(
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{

    ((CComputerExtData *)m_pParentNode)->RemoveChild(m_pwszComputerName);

	return (S_OK);
}


/****************************************************

        CComputerExt Class

 ****************************************************/
//
// Extending the DS msmqconfiguration node type
//  taken from object:   GC://CN=MSMQ-Configuration,CN=Schema,CN=Configuration,DC=raphirdom,DC=Com
//             property: schemaIDGUID
//             value:    x44 xc3 x0d x9a x00 xc1 xd1 x11 xbb xc5 x00 x80 xc7 x66 x70 xc01
//

static const GUID CComputerExtDataGUID_NODETYPE =
//{ 0x3c6e5d82, 0xc4b5, 0x11d1, { 0x9d, 0xb4, 0x9c, 0x71, 0xe8, 0x56, 0x3c, 0x51 } };
  { 0x9a0dc344, 0xc100, 0x11d1, { 0xbb, 0xc5, 0x00, 0x80, 0xc7, 0x66, 0x70, 0xc0 } };

const GUID*  CComputerExtData::m_NODETYPE = &CComputerExtDataGUID_NODETYPE;
//const OLECHAR* CComputerExtData::m_SZNODETYPE = OLESTR("3c6e5d82-c4b5-11d1-9db4-9c71e8563c51");
const OLECHAR* CComputerExtData::m_SZNODETYPE = OLESTR("9a0dc344-c100-11d1-bbc5-0080c76670c0");
const OLECHAR* CComputerExtData::m_SZDISPLAY_NAME = OLESTR("MSMQAdmin");
const CLSID* CComputerExtData::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;



//////////////////////////////////////////////////////////////////////////////
/*++

CComputerExtData::CreatePropertyPages

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CComputerExtData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK /*lpProvider*/,
    LONG_PTR /*handle*/,
	IUnknown* /*pUnk*/,
	DATA_OBJECT_TYPES type)
{
	if (type == CCT_SCOPE || type == CCT_RESULT)
	{
//		CSnapPage* pPage = new CSnapPage(_T("Snap"));
//		lpProvider->AddPage(pPage->Create());

		// TODO : Add code here to add additional pages
		return S_OK;
	}
	return E_UNEXPECTED;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CComputerExtData::GetExtNodeObject

  Called with a node that we need to expand.
  Check if we have already a snapin object corresponding to this node,
  else create a new one.

--*/
//////////////////////////////////////////////////////////////////////////////
CSnapInItem* CComputerExtData::GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
{

    CString             strComputerName;
    CSnapinComputer *   pComp;

	LPWSTR              lpwstrLdapName;
    LPDSOBJECTNAMES     pDSObj;

	m_pDataObject = pDataObject;

	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc =  {  0, 0,  DVASPECT_CONTENT,  -1,  TYMED_HGLOBAL  };

    //
    // Get the LDAP name of the computer from the DS Snapin
    //
   	formatetc.cfFormat = DWORD_TO_WORD(RegisterClipboardFormat(CFSTR_DSOBJECTNAMES));
	HRESULT hr = pDataObject->GetData(&formatetc, &stgmedium);

    if(FAILED(hr))
    {
        ATLTRACE(_T("CComputerExtData::GetExtNodeObject - Get clipboard format from DS failed\n"));
        return(pDefault);
    }

    pDSObj = (LPDSOBJECTNAMES)stgmedium.hGlobal;
    lpwstrLdapName = (LPWSTR)((BYTE*)pDSObj + pDSObj->aObjects[0].offsetName);

	//
	// Get Domain Controller name
	//
    CString strDomainController;
	hr = ExtractDCFromLdapPath(strDomainController, lpwstrLdapName);
	ASSERT(("Failed to Extract DC name", SUCCEEDED(hr)));

	//
    // Translate (and keep) the LDAP name to a computer name
    //
    ExtractComputerMsmqPathNameFromLdapName(strComputerName, lpwstrLdapName);
	GlobalFree(stgmedium.hGlobal);

    //
    // Do we already have this object
    //
    BOOL fComputerExist = m_mapComputers.Lookup(strComputerName, pComp);
    if(fComputerExist == TRUE)
    {
        if (SUCCEEDED(pComp->m_hrError))
        {
            //
            // If there was no error last time, simply return the cashed
            // result. Otherwise continue.
            //
            return(pComp);
        }
    }
    else
    {
        //
        // Not in the list, so create a queue object
        //
        pComp = new CSnapinComputer(this, m_pComponentData);
    }

    pComp->m_pwszComputerName = strComputerName;
    //
    // Get the GUID & foreign flag of the computer
    //
    PROPVARIANT   aPropVar[2];
    PROPID        aPropId[2];

    aPropVar[0].vt = VT_NULL;
    aPropVar[0].puuid = NULL;
    aPropId[0] = PROPID_QM_MACHINE_ID;

    aPropVar[1].vt = VT_NULL;
    aPropVar[1].bVal = FALSE;
    aPropId[1] = PROPID_QM_FOREIGN;


    hr = ADGetObjectProperties(
                eMACHINE,
                GetDomainController(strDomainController),
				true,	// fServerName
                strComputerName,
                ARRAYSIZE(aPropId),
                aPropId,
                aPropVar
                );

    if(SUCCEEDED(hr))
    {
        ASSERT(PROPID_QM_MACHINE_ID == aPropId[0]);
        //
        // Keep the guid
        //
        memcpy(&(pComp->m_guidId), aPropVar[0].puuid, sizeof(GUID));

        //
        // And a stringize version of the guid
        //
        g_VTCLSID.Display(&aPropVar[0], pComp->m_pwszGuid);

        //
        // Free memory
        //
        MQFreeMemory(aPropVar[0].puuid);

        ASSERT(PROPID_QM_FOREIGN == aPropId[1]);
        //
        // if Foreign - do not extend (IE do not create system / private queues sub folders)
        //
        if (aPropVar[1].bVal)
        {
            pComp->m_fDontExpand = TRUE;
        }
        else
        {
            pComp->m_fDontExpand = FALSE;
        }

    }
    else
    {
        //
        // Most probably, MSMQ is not running. We do not want to report an
        // error - we simply don't display the system / private queues.
        //
        pComp->m_pwszGuid = L"";
        pComp->m_fDontExpand = TRUE;
    }
    pComp->m_hrError=hr;

    //
    // Add the computer to the map if it was not there
    //
    if (FALSE == fComputerExist)
    {
        m_mapComputers.SetAt(strComputerName, pComp);
    }

    return(pComp);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CComputerExtData::~CComputerExtData

  Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CComputerExtData::~CComputerExtData()
{

    RemoveAllChildrens();
}

//////////////////////////////////////////////////////////////////////////////
/*++

CComputerExtData::RemoveAllChildrens


--*/
//////////////////////////////////////////////////////////////////////////////
void CComputerExtData::RemoveAllChildrens(void)
{

    POSITION pos;
    CString str;
    CSnapinComputer * pComp;

    //
    // Delete all the nodes from the map
    //
    pos = m_mapComputers.GetStartPosition();
    while(pos != NULL)
    {

        m_mapComputers.GetNextAssoc(pos, str, pComp);
        delete pComp;
    }

    //
    // Empty the map
    //
    m_mapComputers.RemoveAll();

}

//////////////////////////////////////////////////////////////////////////////
/*++

CComputerExtData::RemoveChild


--*/
//////////////////////////////////////////////////////////////////////////////
void CComputerExtData::RemoveChild(CString& strName)
{
    BOOL rc;
    CSnapinComputer * pComp;

    rc = m_mapComputers.Lookup(strName, pComp);

    if(rc == FALSE)
    {
        ASSERT(0);
        return;
    }

    rc = m_mapComputers.RemoveKey(strName);
    ASSERT(rc == TRUE);

    delete pComp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\cmpmrout.cpp ===
// CmpMRout.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "frslist.h"
#include "globals.h"
#include "mqPPage.h"
#include "CmpMRout.h"

#include "cmpmrout.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqRouting property page

IMPLEMENT_DYNCREATE(CComputerMsmqRouting, CMqPropertyPage)

CComputerMsmqRouting::CComputerMsmqRouting() : CMqPropertyPage(CComputerMsmqRouting::IDD),
  	m_strMsmqName(_T("")),
	m_fLocalMgmt(FALSE)
{
	//{{AFX_DATA_INIT(CComputerMsmqRouting)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_caclsidOutFrs.cElems = 0;
    m_caclsidOutFrs.pElems = m_OutFrsGuids;

    m_caclsidInFrs.cElems = 0;
    m_caclsidInFrs.pElems = m_InFrsGuids;
}

CMap<GUID, const GUID&, CString, LPCTSTR> CFrsList::m_mapFrsCache;

CComputerMsmqRouting::~CComputerMsmqRouting()
{
}

void CComputerMsmqRouting::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CComputerMsmqRouting)
	//}}AFX_DATA_MAP
    BOOL fFirstTime = (m_frscmbInFrs[0].m_hWnd  == NULL);

	DDX_Control(pDX, IDC_INROUTCOMBO_0,  m_frscmbInFrs[0]);
	DDX_Control(pDX, IDC_INROUTCOMBO_1,  m_frscmbInFrs[1]);
	DDX_Control(pDX, IDC_INROUTCOMBO_2,  m_frscmbInFrs[2]);
	DDX_Control(pDX, IDC_OUTROUTCOMBO_0, m_frscmbOutFrs[0]);
	DDX_Control(pDX, IDC_OUTROUTCOMBO_1, m_frscmbOutFrs[1]);
	DDX_Control(pDX, IDC_OUTROUTCOMBO_2, m_frscmbOutFrs[2]);

    //
    // Exchange FRS values
    //
    if (!pDX->m_bSaveAndValidate)
    {
        if (fFirstTime)
        {
	        m_frscmbInFrs[0].InitFrsList(m_guidSiteIDs, m_fLocalMgmt, m_strDomainController);

            m_frscmbOutFrs[2] = m_frscmbOutFrs[1] = m_frscmbOutFrs[0] = 
                m_frscmbInFrs[2] = m_frscmbInFrs[1] = m_frscmbInFrs[0];
        }

        InitiateOutFrsControls();
        InitiateInFrsControls();
    }
    else
    {
        SetOutFrsCauuid();
        SetInFrsCauuid();
    }
}


BEGIN_MESSAGE_MAP(CComputerMsmqRouting, CMqPropertyPage)
	//{{AFX_MSG_MAP(CComputerMsmqRouting)
	ON_CBN_SELCHANGE(IDC_INROUTCOMBO_0, OnChangeRWField)
	ON_CBN_SELCHANGE(IDC_INROUTCOMBO_1, OnChangeRWField)
	ON_CBN_SELCHANGE(IDC_INROUTCOMBO_2, OnChangeRWField)
	ON_CBN_SELCHANGE(IDC_OUTROUTCOMBO_0, OnChangeRWField)
	ON_CBN_SELCHANGE(IDC_OUTROUTCOMBO_1, OnChangeRWField)
	ON_CBN_SELCHANGE(IDC_OUTROUTCOMBO_2, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqRouting message handlers

BOOL CComputerMsmqRouting::OnInitDialog() 
{	
	UpdateData( FALSE );
    m_fModified = FALSE;

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

HRESULT CComputerMsmqRouting::InitiateFrsControls(CACLSID &cauuid, CFrsList *pfrsListArray)
{
    ASSERT(cauuid.cElems <= x_dwMaxNumOfFrs);

    for (DWORD i = 0; i<min(cauuid.cElems, x_dwMaxNumOfFrs); i++)
    {
        if (FAILED(pfrsListArray[i].SelectGuid(cauuid.pElems[i], m_fLocalMgmt, m_strDomainController)))
        {
            return E_UNEXPECTED;
        }
    }

    return S_OK;
}

BOOL CComputerMsmqRouting::OnApply() 
{
    if (!m_fModified)
    {
        return TRUE;
    }

    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        //
        // Write the R/W properties to the DS
        //
	    PROPID paPropid[] = 
            {PROPID_QM_OUTFRS, PROPID_QM_INFRS};

	    const DWORD x_iPropCount = sizeof(paPropid) / sizeof(paPropid[0]);
	    PROPVARIANT apVar[x_iPropCount];
    
	    DWORD iProperty = 0;

        //
        // PROPID_QM_OUTFRS
        //
        ASSERT(paPropid[iProperty] == PROPID_QM_OUTFRS);
        apVar[iProperty].vt = VT_CLSID|VT_VECTOR;
	    apVar[iProperty++].cauuid = m_caclsidOutFrs;

        //
        // PROPID_QM_INFRS
        //
        ASSERT(paPropid[iProperty] == PROPID_QM_INFRS);
        apVar[iProperty].vt = VT_CLSID|VT_VECTOR;
	    apVar[iProperty++].cauuid = m_caclsidInFrs;
    
        HRESULT hr = ADSetObjectProperties(
                eMACHINE,
                m_fLocalMgmt ? MachineDomain() : GetDomainController(m_strDomainController),
				m_fLocalMgmt ? false : true,	// fServerName
                m_strMsmqName,
                x_iPropCount, 
                paPropid, 
                apVar
                );

        if (MQ_OK != hr)
        {
            MessageDSError(hr, IDS_OP_SET_PROPERTIES_OF, m_strMsmqName);
            return FALSE;
        }
    }
	
	return CMqPropertyPage::OnApply();
}


void CComputerMsmqRouting::SetFrsCauuid(CACLSID &cauuid, GUID *aguid, CFrsList *frscmb)
{
    DWORD i,j;
    DWORD dwFrsCount = 0;
    for (i=0; i<x_dwMaxNumOfFrs; i++)
    {
        if (frscmb[i].GetSelectedGuid(aguid[dwFrsCount]))
        {
            dwFrsCount++;
        }
    }

    //
    // Remove duplicates
    //
    for (i=0; i<dwFrsCount; i++)
    {
        for(j=i+1; j<dwFrsCount; j++)
        {
            if (aguid[i] == aguid[j])
            {
                dwFrsCount--;
                aguid[j] = aguid[dwFrsCount];
                j--;
            }
        }
    }

    //
    // Set the CLSID set
    //
    cauuid.cElems = dwFrsCount;
    cauuid.pElems = aguid;
}

void CComputerMsmqRouting::CopyCaclsid(CACLSID &cauuidResult, const CACLSID *pcauuidSource)
{
    ASSERT(pcauuidSource->cElems <= x_dwMaxNumOfFrs);

    DWORD dwCElems = min(pcauuidSource->cElems, x_dwMaxNumOfFrs);

    cauuidResult.cElems = dwCElems;

    if (dwCElems > 0)
    {
        memcpy(cauuidResult.pElems, pcauuidSource->pElems, dwCElems*sizeof(GUID));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\compdiag.h ===
#if !defined(AFX_COMPDIAG_H__F791A865_D91B_11D1_8091_00A024C48131__INCLUDED_)
#define AFX_COMPDIAG_H__F791A865_D91B_11D1_8091_00A024C48131__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CompDiag.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqDiag dialog

class CComputerMsmqDiag : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CComputerMsmqDiag)

// Construction
public:
	CString m_strMsmqName;
	CString	m_strDomainController;
	CComputerMsmqDiag();
	~CComputerMsmqDiag();
	GUID m_guidQM;
	BOOL m_fLocalMgmt;

// Dialog Data
	//{{AFX_DATA(CComputerMsmqDiag)
	enum { IDD = IDD_COMPUTER_MSMQ_DIAGNOSTICS };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CComputerMsmqDiag)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CComputerMsmqDiag)
	afx_msg void OnDiagPing();
	virtual BOOL OnInitDialog();
	afx_msg void OnDiagSendTest();
	afx_msg void OnDiagTracking();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COMPDIAG_H__F791A865_D91B_11D1_8091_00A024C48131__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\compext.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	compext.h

Abstract:

	Definition for the computer extension snapnin node class.

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __COMPEXT_H_
#define __COMPEXT_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"


/****************************************************

        CSnapinComputer Class
    
 ****************************************************/

class CSnapinComputer : public CNodeWithScopeChildrenList<CSnapinComputer, TRUE>
{
public:

	GUID    m_guidId;
	CString m_pwszComputerName;
    CString m_pwszGuid;
    BOOL    m_fDontExpand;
    HRESULT m_hrError;

   	BEGIN_SNAPINCOMMAND_MAP(CSnapinComputer, FALSE)
	END_SNAPINCOMMAND_MAP()

    CSnapinComputer(CSnapInItem * pParentNode, CSnapin * pComponentData) : 
        CNodeWithScopeChildrenList<CSnapinComputer, TRUE>(pParentNode, pComponentData ),
        m_hrError(MQ_OK)
    {
   		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
    }

	~CSnapinComputer()
    {
    }

	virtual HRESULT PopulateScopeChildrenList();


    virtual HRESULT OnRemoveChildren( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			);

private:
};





/****************************************************

        CComputerExtData Class
    
 ****************************************************/

class CComputerExtData : public CSnapInItemImpl<CComputerExtData, TRUE>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

    CSnapin *   m_pComponentData;


	BEGIN_SNAPINCOMMAND_MAP(CComputerExtData, FALSE)
	END_SNAPINCOMMAND_MAP()

	BEGIN_SNAPINTOOLBARID_MAP(CComputerExtData)
		// Create toolbar resources with button dimensions 16x16 
		// and add an entry to the MAP. You can add multiple toolbars
		// SNAPINTOOLBARID_ENTRY(Toolbar ID)
	END_SNAPINTOOLBARID_MAP()

    CComputerExtData()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CComputerExtData();

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES /*type*/)
	{
		//if (type == CCT_SCOPE || type == CCT_RESULT)
		//	return S_OK;
		return S_FALSE;
	}

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* /*pDefault*/)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault);

   void RemoveAllChildrens(void);

   void RemoveChild(CString& strName);


private:

    CMap< CString, LPCWSTR, CSnapinComputer*, CSnapinComputer* > m_mapComputers;


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\compgen.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    compgen.cpp

Abstract:

    Computer MSMQ/General property page implementation

Author:

    Yoel Arnon (yoela)

--*/

#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "mqPPage.h"
#include "CompGen.h"
#include "_registr.h"


#include "compgen.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqGeneral property page

IMPLEMENT_DYNCREATE(CComputerMsmqGeneral, CMqPropertyPage)

CComputerMsmqGeneral::CComputerMsmqGeneral() : 
    CMqPropertyPage(CComputerMsmqGeneral::IDD),
	m_dwQuota(0),
	m_dwJournalQuota(0),
	m_fIsWorkgroup(FALSE),
	m_fLocalMgmt(FALSE),
	m_fForeign(FALSE)
{
	//{{AFX_DATA_INIT(CComputerMsmqGeneral)
	m_strMsmqName = _T("");
	m_strService = _T("");
	m_guidID = GUID_NULL;
	//}}AFX_DATA_INIT
}


CComputerMsmqGeneral::~CComputerMsmqGeneral()
{
}

void CComputerMsmqGeneral::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CComputerMsmqGeneral)
	DDX_Text(pDX, IDC_COMPUTER_MSMQ_NAME, m_strMsmqName);
	DDX_Text(pDX, IDC_COMPUTER_MSMQ_SERVICE, m_strService);
	DDX_Text(pDX, IDC_COMPUTER_MSMQ_ID, m_guidID);
	//}}AFX_DATA_MAP
	DDX_NumberOrInfinite(pDX, IDC_COMPUTER_MSMQ_QUOTA, IDC_COMPUTER_MSMQ_MQUOTA_CHECK, m_dwQuota);
	DDX_NumberOrInfinite(pDX, IDC_COMPUTER_MSMQ_JOURNAL_QUOTA, IDC_COMPUTER_MSMQ_JQUOTA_CHECK, m_dwJournalQuota);
}


BEGIN_MESSAGE_MAP(CComputerMsmqGeneral, CMqPropertyPage)
	//{{AFX_MSG_MAP(CComputerMsmqGeneral)
	ON_BN_CLICKED(IDC_COMPUTER_MSMQ_MQUOTA_CHECK, OnComputerMsmqMquotaCheck)
	ON_BN_CLICKED(IDC_COMPUTER_MSMQ_JQUOTA_CHECK, OnComputerMsmqJquotaCheck)
	ON_EN_CHANGE(IDC_COMPUTER_MSMQ_QUOTA, OnChangeRWField)
	ON_EN_CHANGE(IDC_COMPUTER_MSMQ_JOURNAL_QUOTA, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


void CComputerMsmqGeneral::DisableStorageLimitsWindows()
{
	GetDlgItem(IDC_COMPUTER_MSMQ_GROUPBOX)->ShowWindow(FALSE);
	GetDlgItem(IDC_COMPUTER_MSMQ_MQUOTA_CHECK)->ShowWindow(FALSE);
	GetDlgItem(IDC_COMPUTER_MSMQ_QUOTA)->ShowWindow(FALSE);
	GetDlgItem(IDC_COMPUTER_MSMQ_JQUOTA_CHECK)->ShowWindow(FALSE);
	GetDlgItem(IDC_COMPUTER_MSMQ_JOURNAL_QUOTA)->ShowWindow(FALSE);
}
/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqGeneral message handlers

BOOL CComputerMsmqGeneral::OnInitDialog() 
{

	UpdateData( FALSE );

    m_fModified = FALSE;

	if (m_fForeign)
	{
		DisableStorageLimitsWindows();
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CComputerMsmqGeneral::OnComputerMsmqMquotaCheck() 
{
	OnNumberOrInfiniteCheck(this, IDC_COMPUTER_MSMQ_QUOTA, IDC_COMPUTER_MSMQ_MQUOTA_CHECK);
    OnChangeRWField();
}

void CComputerMsmqGeneral::OnComputerMsmqJquotaCheck() 
{
	OnNumberOrInfiniteCheck(this, IDC_COMPUTER_MSMQ_JOURNAL_QUOTA, IDC_COMPUTER_MSMQ_JQUOTA_CHECK);
    OnChangeRWField();
}

BOOL CComputerMsmqGeneral::OnApply() 
{
    if (!m_fModified)
    {
        return TRUE;
    }
    //
    // Write the R/W properties to the DS
    //
	PROPID paPropid[] = 
        {PROPID_QM_QUOTA, PROPID_QM_JOURNAL_QUOTA};

	const DWORD x_iPropCount = sizeof(paPropid) / sizeof(paPropid[0]);
	PROPVARIANT apVar[x_iPropCount];
    
	DWORD iProperty = 0;

    //
    // PROPID_Q_QUOTA
    //
    apVar[iProperty].vt = VT_UI4;
	apVar[iProperty++].ulVal = m_dwQuota ;

    //
    // PROPID_QM_JOURNAL_QUOTA
    //
    apVar[iProperty].vt = VT_UI4;
	apVar[iProperty++].ulVal = m_dwJournalQuota;
    	
	HRESULT hr = ADSetObjectProperties(
                        eMACHINE,
                        m_fLocalMgmt ? MachineDomain() : GetDomainController(m_strDomainController),
						m_fLocalMgmt ? false : true,	// fServerName
                        m_strMsmqName,
                        x_iPropCount, 
                        paPropid, 
                        apVar
                        );

    if (FAILED(hr))
    {
		if (!m_fIsWorkgroup || IsClusterVirtualServer(m_strMsmqName))
		{
			MessageDSError(hr, IDS_OP_SET_PROPERTIES_OF, m_strMsmqName);
			return FALSE;
		}

		//
		// This function will check MSMQ service state, ask the user
		// whether to stop it, and stop the service. Error messages inside.
		//
		BOOL fServiceWasRunning;
		if (!TryStopMSMQServiceIfStarted(&fServiceWasRunning, this))
		{
			return FALSE;
		}

		//
		// Set machine quota from registry
		//
		DWORD dwValueType = REG_DWORD;
		DWORD dwValueSize = sizeof(DWORD);

		LONG rc = SetFalconKeyValue(
					MSMQ_MACHINE_QUOTA_REGNAME,
					&dwValueType,
					&m_dwQuota,
					&dwValueSize
					);

		if (FAILED(rc))
		{			
			MessageDSError(rc, IDS_OP_SET_PROPERTIES_OF, m_strMsmqName);
			return FALSE;
		}


		//
		// Set machine journal quota from registry
		//
		dwValueType = REG_DWORD;
		dwValueSize = sizeof(DWORD);

		rc = SetFalconKeyValue(
				MSMQ_MACHINE_JOURNAL_QUOTA_REGNAME,
				&dwValueType,
				&m_dwJournalQuota,
				&dwValueSize
				);

		if (FAILED(rc))
		{			
			MessageDSError(rc, IDS_OP_SET_PROPERTIES_OF, m_strMsmqName);
			return FALSE;
		}

		if (fServiceWasRunning)
		{
			m_fNeedReboot = TRUE;
		}
    }
	
	return CMqPropertyPage::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\compsite.cpp ===
// CompSite.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "globals.h"
#include "dsext.h"
#include "mqsnap.h"
#include "mqPPage.h"
#include "CompSite.h"

#include "compsite.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqSites dialog
IMPLEMENT_DYNCREATE(CComputerMsmqSites, CMqPropertyPage)


CComputerMsmqSites::CComputerMsmqSites(BOOL fIsServer)
	: CMqPropertyPage(CComputerMsmqSites::IDD),
    m_fIsServer(fIsServer),
    m_fForeign(FALSE),
    m_nSites(0),
	m_fLocalMgmt(FALSE)
{
	//{{AFX_DATA_INIT(CComputerMsmqSites)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CComputerMsmqSites::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);

    BOOL fFirstTime = (m_clistAllSites.m_hWnd == NULL);

	//{{AFX_DATA_MAP(CComputerMsmqSites)
	DDX_Control(pDX, IDC_CURRENTSITES_LABEL, m_staticCurrentSitesLabel);
	DDX_Control(pDX, IDC_SITES_REMOVE, m_buttonRemove);
	DDX_Control(pDX, IDC_SITES_ADD, m_buttonAdd);
	DDX_Control(pDX, IDC_CURRENTSITES_LIST, m_clistCurrentSites);
	DDX_Control(pDX, IDC_ALLSITES_LIST, m_clistAllSites);
	//}}AFX_DATA_MAP

    if (fFirstTime)
    {
        InitiateSitesList();
    }

    ExchangeSites(pDX);

    if (!pDX->m_bSaveAndValidate)
    {
        EnableButtons();
    }
}


BEGIN_MESSAGE_MAP(CComputerMsmqSites, CMqPropertyPage)
	//{{AFX_MSG_MAP(CComputerMsmqSites)
	ON_BN_CLICKED(IDC_SITES_ADD, OnSitesAdd)
	ON_BN_CLICKED(IDC_SITES_REMOVE, OnSitesRemove)
	ON_LBN_SELCHANGE(IDC_CURRENTSITES_LIST, EnableButtons)
	ON_LBN_SELCHANGE(IDC_ALLSITES_LIST, EnableButtons)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqSites message handlers


HRESULT CComputerMsmqSites::InitiateSitesList()
{
    //
    // Initiate the label of current sites
    //
    ASSERT(m_staticCurrentSitesLabel.m_hWnd != NULL);

    CString strLabelFormat, strLabelFinal;
    
    m_staticCurrentSitesLabel.GetWindowText(strLabelFormat);

    strLabelFinal.FormatMessage(strLabelFormat, m_strMsmqName);

    m_staticCurrentSitesLabel.SetWindowText(strLabelFinal);

    //
    // Prepare list of sites
    //
    ASSERT(m_clistAllSites.m_hWnd != NULL);

    DWORD dwSiteIndex = 0;
    m_clistAllSites.ResetContent();
    
    //
    // Initialize the full sites list
    //
	PROPID aPropId[] = {PROPID_S_SITEID, PROPID_S_PATHNAME};
	const DWORD x_nProps = sizeof(aPropId) / sizeof(aPropId[0]);

	PROPVARIANT apResultProps[x_nProps];

	CColumns columns;
	for (DWORD i=0; i<x_nProps; i++)
	{
		columns.Add(aPropId[i]);
	}
       
    HANDLE hEnume;
    HRESULT hr;
    {
        CWaitCursor wc; //display wait cursor while query DS
        if (m_fForeign)
        {
            hr = ADQueryForeignSites(
						m_fLocalMgmt ? MachineDomain() : GetDomainController(m_strDomainController),
						m_fLocalMgmt ? false : true,		// fServerName
                        columns.CastToStruct(),
                        &hEnume
                        );
        }
        else
        {
            hr = ADQueryAllSites(
						m_fLocalMgmt ? MachineDomain() : GetDomainController(m_strDomainController),
						m_fLocalMgmt ? false : true,		// fServerName
                        columns.CastToStruct(),
                        &hEnume
                        );
        }
    }

    DSLookup dslookup(hEnume, hr);

    if (!dslookup.HasValidHandle())
    {
        return E_UNEXPECTED;
    }

	DWORD dwPropCount = x_nProps;
	while ( SUCCEEDED(dslookup.Next(&dwPropCount, apResultProps))
			&& (dwPropCount != 0) )
	{
        DWORD iProperty = 0;

        //
        // PROPID_S_SITEID
        //
        ASSERT(PROPID_S_SITEID == aPropId[iProperty]);
        CAutoMQFree<GUID> pguidSite = apResultProps[iProperty].puuid;
        iProperty++;

        //
        // PROPID_S_PATHNAME
        //
        ASSERT(PROPID_S_PATHNAME == aPropId[iProperty]);
        CAutoMQFree<WCHAR> lpwstrSiteName = apResultProps[iProperty].pwszVal;
        iProperty++;
        
        int nIndex = m_clistAllSites.AddString(lpwstrSiteName);
        if (FAILED(nIndex))
        {
            return E_UNEXPECTED;
        }

        m_aguidAllSites.SetAtGrow(dwSiteIndex, *(GUID *)pguidSite);
        m_clistAllSites.SetItemData(nIndex, dwSiteIndex);
        dwSiteIndex++;

		dwPropCount = x_nProps;
	}
    //
    // Sets the sites change flags array. This array will contain non zero
    // for a site that was changed (deleted from or added to the list) 
    // and zero otherwise.
    //
    if (m_piSitesChanges != 0)
    {
        delete m_piSitesChanges.detach();
    }

    m_nSites = DWORD_PTR_TO_DWORD(m_aguidAllSites.GetSize());
    m_piSitesChanges = new int[m_nSites];
    memset(m_piSitesChanges, 0, m_nSites*sizeof(m_piSitesChanges[0]));

    return S_OK;
}

BOOL CComputerMsmqSites::OnInitDialog() 
{
	UpdateData( FALSE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CComputerMsmqSites::MoveClistItem(CListBox &clistDest, CListBox &clistSrc, int iIndex /* = -1 */)
{
    if ((-1) == iIndex)
    {
        iIndex = clistSrc.GetCurSel();
        if (LB_ERR == iIndex)
        {
            return;
        }
    }

    CString strItem;
    clistSrc.GetText(iIndex, strItem);

    int iIndexDest = clistDest.AddString(strItem);
    ASSERT(LB_ERR != iIndexDest);

    VERIFY(LB_ERR != clistDest.SetItemData(iIndexDest, clistSrc.GetItemData(iIndex)));

    VERIFY(LB_ERR != clistSrc.DeleteString(iIndex));
}

//
// MarkSitesChanged
// Return value: TRUE if there is net change in the sites since initialization.
// FALSE otherwise.
//
BOOL CComputerMsmqSites::MarkSitesChanged(CListBox* plb, BOOL fAdded)
{
    int nSelItems = plb->GetSelCount();
    BOOL fWasChange = FALSE;
    AP<int> piRgIndex = new int[nSelItems];
    plb->GetSelItems(nSelItems, piRgIndex );
    int i;
    for (i=0; i<nSelItems; i++)
    {
        DWORD_PTR dwSiteIndex = plb->GetItemData(piRgIndex[i]);
        if (fAdded)
        {
            m_piSitesChanges[dwSiteIndex]++;
        }
        else
        {
            m_piSitesChanges[dwSiteIndex]--;
        }


        if (m_piSitesChanges[dwSiteIndex] != 0)
        {
            fWasChange = TRUE;
        }
    }
    //
    // If this change only reverse past changes, go over all the array to see if 
    // there are changes left
    //
    if (!fWasChange)
    {
        for (i=0; i<(int)m_nSites; i++)
        {
            if (m_piSitesChanges[i] != 0)
            {
                fWasChange = TRUE;
                break;
            }
        }
    }

    return fWasChange;
}

void CComputerMsmqSites::OnSitesAdd() 
{
    BOOL fWasChange = MarkSitesChanged(&m_clistAllSites, TRUE);
    MoveSelected(&m_clistAllSites, &m_clistCurrentSites);
    OnChangeRWField(fWasChange);
}

void CComputerMsmqSites::OnSitesRemove() 
{
    BOOL fWasChange = MarkSitesChanged(&m_clistCurrentSites, FALSE);
    MoveSelected(&m_clistCurrentSites, &m_clistAllSites);
    OnChangeRWField(fWasChange);
}

void CComputerMsmqSites::EnableButtons()
{
    m_buttonAdd.EnableWindow(0 != m_clistAllSites.GetSelCount());
    m_buttonRemove.EnableWindow(0 != m_clistCurrentSites.GetSelCount());
}


BOOL CComputerMsmqSites::OnApply() 
{
    if (!m_fModified)
    {
        return TRUE;
    }

    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        //
        // Check for server (Bug #3965, YoelA, 14-Feb-1999)
        // Changing sites of an MSMQ server may break the system integrity in
        // mixed NT4/NT5 environment. Issue a warning.
        //
        if (m_fIsServer)
        {
            //
            // Check to see if any non foreign site was added to or removed from
            // this computer
            //
            BOOL fDisplaySitesWarning = FALSE;
            for (DWORD i=0; i<m_nSites; i++)
            {
                if(m_piSitesChanges[i] != 0)
                {
                    //
                    // Check if the site is foreign. Issue a warning if not.
                    //
                    BOOL fForeign = FALSE;
                    //
                    // Note that we do not check errors here. They are reported to the user,
                    // and in case of error (like no DS) we will treat the site as non
                    // foreign
                    //
                    GetSiteForeignFlag(&m_aguidAllSites[i], &fForeign, m_fLocalMgmt, m_strDomainController);
                    if (FALSE == fForeign)
                    {
                        fDisplaySitesWarning = TRUE;
                        break;
                    }
                }
            }
            if (fDisplaySitesWarning)
            {
                if (IDYES != AfxMessageBox(IDS_SERVER_SITES_WARNING, MB_YESNO))
                {
                    return FALSE;
                }
            }
        }

        CWaitCursor wc;

        //
        // Write the R/W properties to the DS
        //
	    PROPID paPropid[] = {PROPID_QM_SITE_IDS};

	    const DWORD x_iPropCount = sizeof(paPropid) / sizeof(paPropid[0]);
	    PROPVARIANT apVar[x_iPropCount];
    
	    DWORD iProperty = 0;

        //
        // PROPID_QM_SITE_IDS
        //
        ASSERT(paPropid[iProperty] == PROPID_QM_SITE_IDS);
        apVar[iProperty].vt = VT_CLSID|VT_VECTOR;

        INT_PTR iNumSites = m_aguidSites.GetSize();

        P<GUID> aguidSites = new GUID[iNumSites];

        for (INT_PTR i=0; i<iNumSites; i++)
        {
            aguidSites[i] = m_aguidSites[i];
        }

	    apVar[iProperty].cauuid.pElems = aguidSites;
	    apVar[iProperty].cauuid.cElems = (ULONG) INT_PTR_TO_INT(iNumSites);
    	 
        HRESULT hr = ADSetObjectProperties(
                        eMACHINE,
                        m_fLocalMgmt ? MachineDomain() : GetDomainController(m_strDomainController),
						m_fLocalMgmt ? false : true,	// fServerName
                        m_strMsmqName,
                        x_iPropCount, 
                        paPropid, 
                        apVar
                        );

        if (MQ_OK != hr)
        {
            MessageDSError(hr, IDS_OP_SET_PROPERTIES_OF, m_strMsmqName);
            return FALSE;
        }
    }

    //
    // Reset change flag and changes array
    //
    OnChangeRWField(FALSE);
    memset(m_piSitesChanges, 0, m_nSites*sizeof(m_piSitesChanges[0]));

	return CMqPropertyPage::OnApply();
}

void CComputerMsmqSites::OnChangeRWField(BOOL bChanged)
{
    EnableButtons();
    CMqPropertyPage::OnChangeRWField(bChanged);
}

void CComputerMsmqSites::ExchangeSites(CDataExchange * pDX)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (!pDX->m_bSaveAndValidate)
    {
        CArray<GUID, const GUID&> aguidSites;
        aguidSites.Copy(m_aguidSites);

        int iNumSites = INT_PTR_TO_INT(aguidSites.GetSize());
        int iNumListElems = m_clistAllSites.GetCount();
        if(LB_ERR == iNumListElems)
        {
            ASSERT(0);
            return;
        }

        for(int i=0; i<iNumListElems && 0 < iNumSites; i++)
        {
            for (int j=0; j<iNumSites && i<iNumListElems;)
            {
                if (m_aguidAllSites[m_clistAllSites.GetItemData(i)] == 
                        aguidSites[j])
                {
                    aguidSites.RemoveAt(j);
                    iNumSites--;

                    MoveClistItem(m_clistCurrentSites, m_clistAllSites, i);
                    iNumListElems--;

                    //
                    // Current item was deleted from list - retry all sites 
                    // with the next item, that now have index i
                    //
                    j=0;
                }
                else
                {
                    j++;
                }
            }
        }
    }
    else
    {
        m_aguidSites.RemoveAll();
        int iNumListElems = m_clistCurrentSites.GetCount();
        if (iNumListElems == 0)
        {
            AfxMessageBox(IDS_YOU_MUST_SPECIFY_SITE);
            pDX->Fail();
        }

        for (int i=0; i<iNumListElems; i++)
        {
            m_aguidSites.Add(
                m_aguidAllSites[m_clistCurrentSites.GetItemData(i)]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\compgen.h ===
#if !defined(AFX_COMPGEN_H__83F9BCD5_A079_11D1_8085_00A024C48131__INCLUDED_)
#define AFX_COMPGEN_H__83F9BCD5_A079_11D1_8085_00A024C48131__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CompGen.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqGeneral dialog

class CComputerMsmqGeneral : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CComputerMsmqGeneral)

// Construction
public:
	GUID m_guidID;
	DWORD m_dwJournalQuota;
	DWORD m_dwQuota;
	BOOL m_fLocalMgmt;

    CComputerMsmqGeneral();
	~CComputerMsmqGeneral();

// Dialog Data
	//{{AFX_DATA(CComputerMsmqGeneral)
	enum { IDD = IDD_COMPUTER_MSMQ_GENERAL };
	CString	m_strMsmqName;
	CString	m_strDomainController;
	CString	m_strService;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CComputerMsmqGeneral)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
	void SetWorkgroup(BOOL fIsWorkgroup)
	{
		m_fIsWorkgroup = fIsWorkgroup;
	}

	void SetForeign(BOOL fForeign)
	{
		m_fForeign = fForeign;
	}

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CComputerMsmqGeneral)
	virtual BOOL OnInitDialog();
	afx_msg void OnComputerMsmqMquotaCheck();
	afx_msg void OnComputerMsmqJquotaCheck();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void DisableStorageLimitsWindows();

private:
	BOOL m_fIsWorkgroup;
	BOOL m_fForeign;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COMPGEN_H__83F9BCD5_A079_11D1_8085_00A024C48131__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\cpropmap.cpp ===
/*++

Copyright (c) 1995 - 2001 Microsoft Corporation

Module Name:

    cpropmap.cpp

Abstract:

    Implelentation of CPropMap. This object retrievs properties from AD

Author:

    Nela Karpel (nelak) 26-Jul-2001

Environment:

    Platform-independent.

 --*/


#include "stdafx.h"
#include "cpropmap.h"
#include "globals.h"

#include "cpropmap.tmh"


HRESULT 
CPropMap::GetObjectProperties (
    IN  DWORD                         dwObjectType,
	IN  LPCWSTR						  pDomainController,
	IN  bool						  fServerName,
    IN  LPCWSTR                       lpwcsPathNameOrFormatName,
    IN  DWORD                         cp,
    IN  const PROPID                  *aProp,
    IN  BOOL                          fUseMqApi   /* = FALSE */,
    IN  BOOL                          fSecondTime /* = FALSE */)
{
    P<PROPVARIANT> apVar = new PROPVARIANT[cp];
    HRESULT hr = MQ_OK;
    DWORD i;

    //
    // set NULL variants
    //
    for (i=0; i<cp; i++)
    {
        apVar[i].vt = VT_NULL;
    }

    if (fUseMqApi)
    {
        //
        // Only queue is supported right now
        //
        ASSERT(MQDS_QUEUE == dwObjectType);

        MQQUEUEPROPS mqp = {cp, (PULONG)aProp, apVar, 0};
 
        hr = MQGetQueueProperties(lpwcsPathNameOrFormatName, &mqp);
    }
    else
    {
        hr = ADGetObjectProperties(
                GetADObjectType(dwObjectType), 
                pDomainController,
				fServerName,
                lpwcsPathNameOrFormatName,
                cp,
                const_cast<PROPID *>(aProp),
                apVar
                );

    }
    if (SUCCEEDED(hr))
    {
        for (i = 0; i<cp; i++)
        {
            PROPID pid = aProp[i];

            //
            // Force deletion of old object, if any
            //
            RemoveKey(pid);

            SetAt(pid, apVar[i]);
        }
        return hr;
    }

    if ((hr == MQ_ERROR || hr == MQDS_GET_PROPERTIES_ERROR) && !fSecondTime)
    {
        //
        // Try again - this time just with NT4 properties. We may be working
        // against NT4 PSC
        //
        P<PROPID> aPropNt4 = new PROPID[cp];
        P<PROPID> aPropW2K = new PROPID[cp];
        DWORD cpNt4 = 0;
        DWORD cpW2K = 0;
        for (i = 0; i<cp; i++)
        {
            if (IsNt4Property(dwObjectType, aProp[i]))
            {
                aPropNt4[cpNt4] = aProp[i];
                cpNt4++;
            }
            else
            {
                aPropW2K[cpW2K] = aProp[i];
                cpW2K++;
            }
        }

        //
        // recursive call - get only the NT4 props
        //
        hr = GetObjectProperties(
						dwObjectType, 
						pDomainController, 
						fServerName, 
						lpwcsPathNameOrFormatName, 
						cpNt4, 
						aPropNt4, 
						fUseMqApi, 
						TRUE
						);

        if (SUCCEEDED(hr))
        {
            for (i=0; i<cpW2K; i++)
            {
                //
                // Force deletion of old object, if any
                //
                RemoveKey(aPropW2K[i]);
                GuessW2KValue(aPropW2K[i]);
            }
        }
    }

    return hr;
}


BOOL 
CPropMap::IsNt4Property(IN DWORD dwObjectType, IN PROPID pid)
{
    switch (dwObjectType)
    {
        case MQDS_QUEUE:
            return (pid < PROPID_Q_NT4ID || 
                    (pid > PPROPID_Q_BASE && pid < PROPID_Q_OBJ_SECURITY));

        case MQDS_MACHINE:
            return (pid < PROPID_QM_FULL_PATH || 
                    (pid > PPROPID_QM_BASE && pid <= PROPID_QM_ENCRYPT_PK));

        case MQDS_SITE:
            return (pid < PROPID_S_FULL_NAME || 
                    (pid > PPROPID_S_BASE && pid <= PROPID_S_PSC_SIGNPK));

        case MQDS_ENTERPRISE:
            return (pid < PROPID_E_NT4ID || 
                    (pid > PPROPID_E_BASE && pid <= PROPID_E_SECURITY));

        case MQDS_USER:
            return (pid <= PROPID_U_ID);

        case MQDS_SITELINK:
            return (pid < PROPID_L_GATES_DN);

        default:
            ASSERT(0);
            //
            // Other objects (like CNs) should have the same properties under NT4 or 
            // Win 2K
            //
            return TRUE;
    }
}


/*-----------------------------------------------------------------------------
/ Utility to convert to the new msmq object type
/----------------------------------------------------------------------------*/
AD_OBJECT 
CPropMap::GetADObjectType (DWORD dwObjectType)
{
    switch(dwObjectType)
    {
    case MQDS_QUEUE:
        return eQUEUE;
        break;

    case MQDS_MACHINE:
        return eMACHINE;
        break;

    case MQDS_SITE:
        return eSITE;
        break;

    case MQDS_ENTERPRISE:
        return eENTERPRISE;
        break;

    case MQDS_USER:
        return eUSER;
        break;

    case MQDS_SITELINK:
        return eROUTINGLINK;
        break;

    case MQDS_SERVER:
        return eSERVER;
        break;

    case MQDS_SETTING:
        return eSETTING;
        break;

    case MQDS_COMPUTER:
        return eCOMPUTER;
        break;

    case MQDS_MQUSER:
        return eMQUSER;
        break;

    default:
        return eNumberOfObjectTypes;    //invalid value
    }

    return eNumberOfObjectTypes;
}


//
// Guess the value of a W2K specific property, based of the value of known NT4 properties
//
void 
CPropMap::GuessW2KValue(PROPID pidW2K)
{
    PROPVARIANT propVarValue;

    switch(pidW2K)
    {
        case PROPID_QM_SERVICE_DSSERVER:  
        case PROPID_QM_SERVICE_ROUTING:
        case PROPID_QM_SERVICE_DEPCLIENTS:
        {
            PROPVARIANT propVar;
            PROPID pid;
            BOOL fValue = FALSE;

            pid = PROPID_QM_SERVICE;            
            VERIFY(Lookup(pid, propVar));
            ULONG ulService = propVar.ulVal;
            switch(pidW2K)
            {
                case PROPID_QM_SERVICE_DSSERVER:  
                    fValue = (ulService >= SERVICE_BSC);
                    break;

                case PROPID_QM_SERVICE_ROUTING:
                case PROPID_QM_SERVICE_DEPCLIENTS:
                    fValue = (ulService >= SERVICE_SRV);
                    break;
            }
            propVarValue.vt = VT_UI1;
            propVarValue.bVal = (UCHAR)fValue;
            break;
        }

        default:
            //
            // We cannot guess the value. Return.
            //
            return;
    }


    //
    // Put the "Guessed" value in the map
    //

    SetAt(pidW2K, propVarValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\cpropmap.h ===
/*++

Copyright (c) 1995 - 2001 Microsoft Corporation

Module Name:

    cpropmap.h

Abstract:

    Definition of CPropMap. This object retrievs properties from AD

Author:

    Nela Karpel (nelak) 26-Jul-2001

Environment:

    Platform-independent.

 --*/
#pragma once
#ifndef __PROPMAP_H__
#define __PROPMAP_H__

//
// CpropMap - creates a properties map for ADGetObjectProperties
//
class CPropMap : public CMap<PROPID, PROPID&, PROPVARIANT, PROPVARIANT &>
{
public:
	CPropMap() {};

    HRESULT GetObjectProperties (
        IN  DWORD                   dwObjectType,
	    IN  LPCWSTR					pDomainController,
		IN  bool					fServerName,
        IN  LPCWSTR                 lpwcsPathName,
        IN  DWORD                   cp,
        IN  const PROPID            *aProp,
        IN  BOOL                    fUseMqApi   = FALSE,
        IN  BOOL                    fSecondTime = FALSE
        );
private:

	CPropMap(const CPropMap&);
	CPropMap& operator=(const CPropMap&);

    BOOL IsNt4Property(IN DWORD dwObjectType, IN PROPID pid);
    void GuessW2KValue(PROPID pidW2K);
    /*-----------------------------------------------------------------------------
    / Utility to convert to the new msmq object type
    /----------------------------------------------------------------------------*/
    AD_OBJECT GetADObjectType (DWORD dwObjectType);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\compsite.h ===
#if !defined(AFX_COMPSITE_H__26E6BE55_CEBD_11D1_8091_00A024C48131__INCLUDED_)
#define AFX_COMPSITE_H__26E6BE55_CEBD_11D1_8091_00A024C48131__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CompSite.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CComputerMsmqSites dialog

class CComputerMsmqSites : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CComputerMsmqSites)

// Construction
public:
	CComputerMsmqSites(BOOL fIsServer = FALSE);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CComputerMsmqSites)
	enum { IDD = IDD_COMPUTER_MSMQ_SITES };
	CStatic	m_staticCurrentSitesLabel;
	CButton	m_buttonRemove;
	CButton	m_buttonAdd;
	CListBox	m_clistCurrentSites;
	CListBox	m_clistAllSites;
	//}}AFX_DATA
	CString	m_strMsmqName;
	CString	m_strDomainController;
    CArray<GUID, const GUID&> m_aguidSites;

	BOOL m_fForeign;
	BOOL m_fLocalMgmt;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CComputerMsmqSites)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void ExchangeSites(CDataExchange* pDX);
	void EnableButtons();
	void MoveClistItem(CListBox &clistDest, CListBox &clistSrc, int iIndex = -1);
    HRESULT InitiateSitesList();
    CArray<GUID, const GUID&> m_aguidAllSites;
    BOOL m_fIsServer;
    BOOL MarkSitesChanged(CListBox* plb, BOOL fAdded);


	// Generated message map functions
	//{{AFX_MSG(CComputerMsmqSites)
	virtual BOOL OnInitDialog();
	afx_msg void OnSitesAdd();
	afx_msg void OnSitesRemove();
	//}}AFX_MSG
    virtual void OnChangeRWField(BOOL bChanged);
	DECLARE_MESSAGE_MAP()
private:
	DWORD m_nSites;
    AP<int> m_piSitesChanges;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COMPSITE_H__26E6BE55_CEBD_11D1_8091_00A024C48131__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\dataobj.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dataobj.cpp

Abstract:

    CDataObject implementation. Originally based on step4 sample from
    mmc SDK.
    In our model, this represents the data related to a specific Queue / MSMQ objetct / Etc.

Author:

    Yoel Arnon (yoela)

--*/

#include "stdafx.h"
#include "shlobj.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "dataobj.h"
#include "ldaputl.h"


#include "dataobj.tmh"
               
/////////////////////////////////////////////////////////////////////////////
// CDataObject - This class is used to pass data back and forth with MMC. It
//               uses a standard interface, IDataObject to acomplish this. Refer
//               to OLE documentation for a description of clipboard formats and
//               the IdataObject interface.

//============================================================================
//
// Constructor and Destructor
// 
//============================================================================


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CDataObject
//
//  Synopsis:   ctor
//
//---------------------------------------------------------------------------

CDataObject::CDataObject() :
    m_strMsmqPath(TEXT("")),
    m_strDomainController(TEXT("")),
    m_pDsNotifier(0),
    m_fFromFindWindow(FALSE),
    m_spObjectPageInit(0),
    m_spObjectPage(0),
    m_spMemberOfPageInit(0),
    m_spMemberOfPage(0)
{
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::~CDataObject
//
//  Synopsis:   dtor
//
//---------------------------------------------------------------------------

CDataObject::~CDataObject()
{
    if (0 != m_pDsNotifier)
    {
        m_pDsNotifier->Release(FALSE);
    }
}

HRESULT CDataObject::InitAdditionalPages(
                        LPCITEMIDLIST pidlFolder, 
                        LPDATAOBJECT lpdobj, 
                        HKEY hkeyProgID)
{
    HRESULT hr;
    if (m_spObjectPageInit != 0 && m_spMemberOfPageInit != 0)
    {
        //
        // Initializing again
        //
        ASSERT(0);
        return S_OK;
    }

    if (m_spObjectPageInit != 0)
    {
        //
        // Initializing again
        //
        ASSERT(0);
    }
    else
    {
        //
        // Get the "object" property page handler
        // Note: if we fail, we simply ignore that page.
        //
        hr = CoCreateInstance(x_ObjectPropertyPageClass, 0, CLSCTX_ALL, IID_IShellExtInit, (void**)&m_spObjectPageInit);
        if FAILED(hr)
        {
            ASSERT(0);
            m_spObjectPageInit = 0;
            return S_OK;
        }

        ASSERT(m_spObjectPageInit != 0);
        hr = m_spObjectPageInit->Initialize(pidlFolder, lpdobj, hkeyProgID);
        if FAILED(hr)
        {
            ASSERT(0);
            return S_OK;
        }
        hr = m_spObjectPageInit->QueryInterface(IID_IShellPropSheetExt, (void**)&m_spObjectPage);
        if FAILED(hr)
        {
            ASSERT(0);
            m_spObjectPage = 0;
        }
    }

    if (m_spMemberOfPageInit  != 0)
    {
        //
        // Initializing again
        //
        ASSERT(0);
    }
    else
    {
        //
        // Get the "memeber of" property page handler
        // Note: if we fail, we simply ignore that page.
        //
        hr = CoCreateInstance(x_MemberOfPropertyPageClass, 0, CLSCTX_ALL, IID_IShellExtInit, (void**)&m_spMemberOfPageInit);
        if FAILED(hr)
        {
            ASSERT(0);
            m_spMemberOfPageInit = 0;
            return S_OK;
        }

        ASSERT(m_spMemberOfPageInit != 0);
        hr = m_spMemberOfPageInit->Initialize(pidlFolder, lpdobj, hkeyProgID);
        if FAILED(hr)
        {
            ASSERT(0);
            return S_OK;
        }
        hr = m_spMemberOfPageInit->QueryInterface(IID_IShellPropSheetExt, (void**)&m_spMemberOfPage);
        if FAILED(hr)
        {
            ASSERT(0);
            m_spMemberOfPage = 0;
        }
    }

    return S_OK;
}
    
//
// IShellExtInit
//
STDMETHODIMP CDataObject::Initialize (
    LPCITEMIDLIST pidlFolder, 
    LPDATAOBJECT lpdobj, 
    HKEY hkeyProgID)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    if (0 == lpdobj || IsBadReadPtr(lpdobj, sizeof(LPDATAOBJECT)))
    {
        return E_INVALIDARG;
    }

    //
    // Gets the LDAP path
    //
    STGMEDIUM stgmedium =  {  TYMED_HGLOBAL,  0  };
    FORMATETC formatetc =  {  0, 0,  DVASPECT_CONTENT,  -1,  TYMED_HGLOBAL  };

	LPWSTR lpwstrLdapName;
	LPDSOBJECTNAMES pDSObj;
	
	formatetc.cfFormat = DWORD_TO_WORD(RegisterClipboardFormat(CFSTR_DSOBJECTNAMES));
	hr = lpdobj->GetData(&formatetc, &stgmedium);

    if (SUCCEEDED(hr))
    {
        ASSERT(0 != stgmedium.hGlobal);
        CGlobalPointer gpDSObj(stgmedium.hGlobal); // Automatic release
        stgmedium.hGlobal = 0;

        pDSObj = (LPDSOBJECTNAMES)(HGLOBAL)gpDSObj;

        //
        // Identify wheather we were called from the "Find" window
        //
        if (pDSObj->clsidNamespace == CLSID_FindWindow)
        {
            m_fFromFindWindow = TRUE;
        }

		lpwstrLdapName = (LPWSTR)((BYTE*)pDSObj + pDSObj->aObjects[0].offsetName);

		m_strLdapName = lpwstrLdapName;      

		//
		// Get Domain Controller name
		//
		hr = ExtractDCFromLdapPath(m_strDomainController, lpwstrLdapName);
		ASSERT(("Failed to Extract DC name", SUCCEEDED(hr)));

        hr = ExtractMsmqPathFromLdapPath(lpwstrLdapName);

        if (SUCCEEDED(hr))
        {
            hr = HandleMultipleObjects(pDSObj);
        }
    }

    //
    // Initiate Display Specifiers modifier
    //
    ASSERT(0 == m_pDsNotifier);
    m_pDsNotifier = new CDisplaySpecifierNotifier(lpdobj);

    //
    // if we fail we'll ignore these pages
    //
    HRESULT hr1 = InitAdditionalPages(pidlFolder, lpdobj, hkeyProgID);
    
    return hr;
}



HRESULT CDataObject::GetProperties()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = m_propMap.GetObjectProperties(GetObjectType(), 
                                               m_strDomainController,
											   true,	// fServerName
                                               m_strMsmqPath,
                                               GetPropertiesCount(),
                                               GetPropidArray());
    if (FAILED(hr))
    {
        IF_NOTFOUND_REPORT_ERROR(hr)
        else
        {
            MessageDSError(hr, IDS_OP_GET_PROPERTIES_OF, m_strMsmqPath);
        }
    }

    return hr;
}


HRESULT CDataObject::GetPropertiesSilent()
{
    HRESULT hr = m_propMap.GetObjectProperties(GetObjectType(), 
                                               m_strDomainController,
											   true,	// fServerName
                                               m_strMsmqPath,
                                               GetPropertiesCount(),
                                               GetPropidArray());
    return hr;
}



//
// CDisplaySpecifierNotifier
//
long CDisplaySpecifierNotifier::AddRef(BOOL fIsPage /*= TRUE*/)
{
    InterlockedIncrement(&m_lRefCount);
    if (fIsPage)
    {
        InterlockedIncrement(&m_lPageRef);
    }
    return m_lRefCount;
}

long CDisplaySpecifierNotifier::Release(BOOL fIsPage /*= TRUE */)
{
    ASSERT(m_lRefCount > 0);
    InterlockedDecrement(&m_lRefCount);
    if (fIsPage)
    {
        ASSERT(m_lPageRef > 0);
        InterlockedDecrement(&m_lPageRef);
        if (0 == m_lPageRef)
        {
            if (m_sheetCfg.hwndHidden && ::IsWindow(m_sheetCfg.hwndHidden))
            {
               ::PostMessage(m_sheetCfg.hwndHidden, 
                             WM_DSA_SHEET_CLOSE_NOTIFY, 
                             (WPARAM)m_sheetCfg.wParamSheetClose, 
                             (LPARAM)0);
            }
        }
    }
    if (0 == m_lRefCount)
    {
        delete this;
        return 0;
    }
    return m_lRefCount;
};

CDisplaySpecifierNotifier::CDisplaySpecifierNotifier(LPDATAOBJECT lpdobj) :
    m_lRefCount(1),
    m_lPageRef(0)
{
    //
    // Get the prop sheet configuration
    //
    STGMEDIUM stgmedium =  {  TYMED_HGLOBAL,  0  };
    FORMATETC formatetc =  {  0, 0,  DVASPECT_CONTENT,  -1,  TYMED_HGLOBAL  };

    formatetc.cfFormat = DWORD_TO_WORD(RegisterClipboardFormat(CFSTR_DS_PROPSHEETCONFIG));
	HRESULT hr = lpdobj->GetData(&formatetc, &stgmedium);
    if (SUCCEEDED(hr))
    {
        ASSERT(0 != stgmedium.hGlobal);
        CGlobalPointer gpDSObj(stgmedium.hGlobal); // Automatic release
        stgmedium.hGlobal = 0;

        m_sheetCfg = *(PPROPSHEETCFG)(HGLOBAL)gpDSObj;
    }
    else
    {
        //
        // We are probably called from "Find" menu
        //
        memset(&m_sheetCfg, 0, sizeof(m_sheetCfg));
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\deppage.cpp ===
// deppage.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "globals.h"
#include "mqPPage.h"
#include "deppage.h"
#include "admmsg.h"

#include "deppage.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDependentMachine property page

IMPLEMENT_DYNCREATE(CDependentMachine, CMqPropertyPage)

CDependentMachine::CDependentMachine() : CMqPropertyPage(CDependentMachine::IDD)
{
	//{{AFX_DATA_INIT(CDependentMachine)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CDependentMachine::~CDependentMachine()
{
}

void CDependentMachine::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDependentMachine)
	DDX_Control(pDX, IDC_DEPENDENT_CLIENTS, m_clistDependentClients);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDependentMachine, CMqPropertyPage)
	//{{AFX_MSG_MAP(CDependentMachine)
	ON_BN_CLICKED(IDC_DEPENDENT_CLIENTS_REFRESH, OnDependentClientsRefresh)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDependentMachine message handlers

void CDependentMachine::OnDependentClientsRefresh() 
{
    m_clistDependentClients.DeleteAllItems();
    
    //
    // Update the dependent clients list control
    //
    UpdateDependentClientList();
}

HRESULT  CDependentMachine::UpdateDependentClientList()
{
  	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CWaitCursor wc;

    CList<LPWSTR, LPWSTR&> DependentMachineList;
    HRESULT hr;

    hr = RequestDependentClient(m_gMachineId, DependentMachineList);
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD iItem = 0;

    POSITION pos = DependentMachineList.GetHeadPosition();
    while (pos != NULL)
    {
        AP<WCHAR> ClientName= DependentMachineList.GetNext(pos);

        m_clistDependentClients.InsertItem(iItem, ClientName);
        ++iItem;
    }

    return(MQ_OK);
}

BOOL CDependentMachine::OnInitDialog() 
{
    UpdateData( FALSE );

    {
    	AFX_MANAGE_STATE(AfxGetStaticModuleState());

        RECT rectList;
        CString csHeading;
        m_clistDependentClients.GetClientRect(&rectList);

        csHeading.LoadString(IDS_CLIENTS_HEADING);
        m_clistDependentClients.InsertColumn(0, LPCTSTR(csHeading), LVCFMT_LEFT, rectList.right - rectList.left,0 );
    }

    //
    // Update the dependent clients list control
    //
    HRESULT hr = UpdateDependentClientList();
    if FAILED(hr)
    {
    	AFX_MANAGE_STATE(AfxGetStaticModuleState());
        MessageDSError(hr, IDS_OP_RETRIEVE_DEP_CLIENTS);
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void
CDependentMachine::SetMachineId(
    const GUID* pMachineId
    )
{
    m_gMachineId = *pMachineId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\dataobj.h ===
// dataobj.h : IDataObject Interface to communicate data
//
// This is a part of the MMC SDK.
// Copyright (C) 1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// MMC SDK Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// MMC Library product.
//

#ifndef __DATAOBJ_H_
#define __DATAOBJ_H_

#include <mmc.h>
#include <shlobj.h>
#include "globals.h"	// Added by ClassView
#include "cpropmap.h"
#include <dspropp.h>

//
// Defines, Types etc...
//

class CDisplaySpecifierNotifier;


/////////////////////////////////////////////////////////////////////////////
// CDataObject - This class is used to pass data back and forth with MMC. It
//               uses a standard interface, IDataObject to acomplish this. Refer
//               to OLE documentation for a description of clipboard formats and
//               the IdataObject interface.

class CDataObject:
    public IShellExtInit,
    public IShellPropSheetExt,
    public IContextMenu,
   	public CComObjectRoot
{
public:

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)

BEGIN_COM_MAP(CDataObject)
    COM_INTERFACE_ENTRY(IShellExtInit)
    COM_INTERFACE_ENTRY(IShellPropSheetExt)
    COM_INTERFACE_ENTRY(IContextMenu)
END_COM_MAP()

    CDataObject();
   ~CDataObject();
 
    //
    // IShellExtInit
    //
	STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hkeyProgID);

    //
    // IShellPropSheetExt
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam) PURE;
    STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

    //
    // IContextMenu
    //
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax);

protected:
	BOOL m_fFromFindWindow;
	virtual HRESULT GetProperties();
	virtual HRESULT GetPropertiesSilent();

	CPropMap m_propMap;
	virtual HRESULT ExtractMsmqPathFromLdapPath (LPWSTR lpwstrLdapPath) PURE;
    virtual HRESULT HandleMultipleObjects(LPDSOBJECTNAMES /*pDSObj*/)
    {
	    //
	    // Do nothing by default
	    //
	    return S_OK;
    }


   	virtual const DWORD  GetObjectType() PURE;
    virtual const PROPID *GetPropidArray() PURE;
    virtual const DWORD  GetPropertiesCount() PURE;
    
    HRESULT InitAdditionalPages(
        LPCITEMIDLIST pidlFolder, 
        LPDATAOBJECT lpdobj, 
        HKEY hkeyProgID
        );

    CString m_strLdapName;
    CString m_strDomainController;
    CString m_strMsmqPath;
    CDisplaySpecifierNotifier *m_pDsNotifier;

    CComPtr<IShellExtInit> m_spObjectPageInit;
    CComPtr<IShellPropSheetExt> m_spObjectPage;
    CComPtr<IShellExtInit> m_spMemberOfPageInit;
    CComPtr<IShellPropSheetExt> m_spMemberOfPage;

};

//
// IContextMenu
//
inline STDMETHODIMP CDataObject::QueryContextMenu(
    HMENU /*hmenu*/, 
    UINT /*indexMenu*/, 
    UINT /*idCmdFirst*/, 
    UINT /*idCmdLast*/, 
    UINT /*uFlags*/
    )
{
    return S_OK;
}

inline STDMETHODIMP CDataObject::InvokeCommand(
    LPCMINVOKECOMMANDINFO /*lpici*/)
{
    return S_OK;
}

inline STDMETHODIMP CDataObject::GetCommandString(UINT_PTR /*idCmd*/, UINT /*uType*/, UINT * /*pwReserved*/, LPSTR /*pszName*/, UINT /*cchMax*/)
{
    return S_OK;
}

struct FindColumns
{
    INT fmt;
    INT cx;
    INT uID;
    LPCTSTR pDisplayProperty;
};


//
// IShellPropSheetExt
//
//+----------------------------------------------------------------------------
//
//  Member: CDataObject::IShellExtInit::ReplacePage
//
//  Notes:  Not used.
//
//-----------------------------------------------------------------------------
inline STDMETHODIMP
CDataObject::ReplacePage(
	UINT /*uPageID*/,
	LPFNADDPROPSHEETPAGE /*lpfnReplaceWith*/,
	LPARAM /*lParam*/
	)
{
    return E_NOTIMPL;
}

#define WM_DSA_SHEET_CLOSE_NOTIFY     (WM_USER + 5) 
#define CFSTR_DS_PROPSHEETCONFIG L"DsPropSheetCfgClipFormat"

//
// CDisplaySpecifierNotifier
//
class CDisplaySpecifierNotifier
{
public:
    long AddRef(BOOL fIsPage = TRUE);
    long Release(BOOL fIsPage = TRUE);
    CDisplaySpecifierNotifier(LPDATAOBJECT lpdobj);

private:
    long m_lRefCount;
    long m_lPageRef;
    PROPSHEETCFG m_sheetCfg;
    ~CDisplaySpecifierNotifier()
    {
    };
};
#endif // __DATAOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\deppage.h ===
#if !defined(AFX_DEPPAGE_H__57A77017_D858_11D1_9C86_006008764D0E__INCLUDED_)
#define AFX_DEPPAGE_H__57A77017_D858_11D1_9C86_006008764D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// deppage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDependentMachine dialog

class CDependentMachine : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CDependentMachine)

// Construction
public:
	CDependentMachine();
	~CDependentMachine();
    
    void
    SetMachineId(
        const GUID* pMachineId
        );

// Dialog Data
	//{{AFX_DATA(CDependentMachine)
	enum { IDD = IDD_COMPUTER_MSMQ_DEPENDENT_CLIENTS };
	CListCtrl	m_clistDependentClients;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDependentMachine)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDependentMachine)
	afx_msg void OnDependentClientsRefresh();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	HRESULT  UpdateDependentClientList();

	GUID m_gMachineId;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DEPPAGE_H__57A77017_D858_11D1_9C86_006008764D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\edataobj.cpp ===
// edataobj.cpp : Implementation of CEnterpriseDataObject
#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqPPage.h"
#include "dataobj.h"
#include "mqDsPage.h"
#include "edataobj.h"
#include "EnterGen.h"
#include "MsmqLink.h"
#include "ForgSite.h"
#include "ForgComp.h"
#include "ldaputl.h"

#include "edataobj.tmh"

/////////////////////////////////////////////////////////////////////////////
// CEnterpriseDataObject

const PROPID CEnterpriseDataObject::mx_paPropid[] = { PROPID_E_LONG_LIVE };

HRESULT 
CEnterpriseDataObject::ExtractMsmqPathFromLdapPath(
    LPWSTR /*lpwstrLdapPath*/
    )
{
    //
    // NOTE:  the enterprise name is extracted from DS and from LDAP.
    //
    HRESULT rc;

    PROPID      prop;
    PROPVARIANT var;
    prop = PROPID_E_NAME;    
    var.vt = VT_NULL;    

    rc = ADGetObjectProperties(
                eENTERPRISE,
                GetDomainController(m_strDomainController),
				true,	// fServerName
                L"msmq",
                1,
                &prop,
                &var
                );
  
    if (SUCCEEDED(rc))
    {
        m_strMsmqPath = var.pwszVal;
        MQFreeMemory(var.pwszVal);
    }
    
    return rc;
}

//
// IShellPropSheetExt
//


STDMETHODIMP 
CEnterpriseDataObject::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam
    )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (SUCCEEDED(GetProperties()))
    {
        HPROPSHEETPAGE hPage = CreateGeneralPage();
        if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
        {
            ASSERT(0);
            return E_UNEXPECTED;
        }
    }
    else
    {
        return E_UNEXPECTED;
    }

    return S_OK;
}


HPROPSHEETPAGE 
CEnterpriseDataObject::CreateGeneralPage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());


    //
    // By using template class CMqDsPropertyPage, we extend the basic functionality
    // of CQueueGeneral and add DS snap-in notification on release
    //
	CMqDsPropertyPage<CEnterpriseGeneral>  *pcpageGeneral = 
        new CMqDsPropertyPage<CEnterpriseGeneral>(m_pDsNotifier, m_strMsmqPath, m_strDomainController);

    PROPVARIANT propVar;
    PROPID pid;

	//
	// PROPID_E_CREATE_TIME
	//
    pid = PROPID_E_LONG_LIVE;
    VERIFY(m_propMap.Lookup(pid, propVar));
	pcpageGeneral->LongLiveIntialize(propVar.ulVal);

    return pcpageGeneral->CreateThemedPropertySheetPage();  
}


const 
DWORD  
CEnterpriseDataObject::GetPropertiesCount(
    void
    )
{
    return sizeof(mx_paPropid) / sizeof(mx_paPropid[0]);
}


//
// IContextMenu
//
STDMETHODIMP 
CEnterpriseDataObject::QueryContextMenu(
    HMENU hmenu, 
    UINT indexMenu, 
    UINT idCmdFirst, 
    UINT /*idCmdLast*/, 
    UINT /*uFlags*/
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    UINT uiMenu = 0;

    CString strNewMenuEntry;
    strNewMenuEntry.LoadString(IDS_NEW_FOREIGN_SITE);
    
    InsertMenu(
        hmenu,
        indexMenu, 
        MF_BYPOSITION|MF_STRING,
        idCmdFirst + eNewForeignSite,
        strNewMenuEntry
        );
    uiMenu++;   
    
    strNewMenuEntry.LoadString(IDS_NEW_FOREIGN_COMPUTER);
    InsertMenu(
        hmenu,
        indexMenu, 
        MF_BYPOSITION|MF_STRING,
        idCmdFirst + eNewForeignComputer,
        strNewMenuEntry
        );
    uiMenu++;
    
    return uiMenu;
}

STDMETHODIMP 
CEnterpriseDataObject::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    switch((INT_PTR)lpici->lpVerb)
    {
        case eNewForeignSite:
        {
			_bstr_t bstrMsmqPath = m_strMsmqPath;
			CString strPathDisplayFormat;
			GetContainerPathAsDisplayString(bstrMsmqPath, &strPathDisplayFormat);

		    CForeignSite* pForeignSite = new CForeignSite(strPathDisplayFormat);       
			CGeneralPropertySheet propertySheet(pForeignSite);
			pForeignSite->SetParentPropertySheet(&propertySheet);

            propertySheet.DoModal();
            break;
        }

        case eNewForeignComputer:
        {
 		    CForeignComputer* pForeignComputer = new CForeignComputer(m_strDomainController);       
			CGeneralPropertySheet propertySheet(pForeignComputer);
			pForeignComputer->SetParentPropertySheet(&propertySheet);
           
            propertySheet.DoModal();
            break;
        }

        default:
            ASSERT(0);

    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\dsext.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

   DSExt.h

Abstract:

   Extensions to DS functionality (wrapper classes, etc.)

Author:

    Yoel Arnon (yoela)

--*/
//
// DsLookup class
//
class DSLookup
{
public:
    DSLookup ( IN HANDLE   hEnume,
               IN HRESULT  hr
               );

    ~DSLookup ();

    HRESULT Next( IN OUT  DWORD*          pcProps,
                  OUT     PROPVARIANT     aPropVar[]);

    BOOL HasValidHandle();

    HRESULT GetStatusCode();

private:
    HANDLE  m_hEnum;
    HRESULT m_hr;
};

inline DSLookup::DSLookup ( 
    IN HANDLE   hEnume,
    IN HRESULT  hr
    ) :
    m_hEnum(hEnume),
    m_hr(hr)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());  
   
    if (FAILED(m_hr))
    {
        MessageDSError(m_hr, IDS_LOOKUP_BEGIN);

        if (0 != m_hEnum)
        {
            VERIFY(SUCCEEDED(ADEndQuery(m_hEnum)));  
            m_hEnum = 0;
        }
    }
}

inline DSLookup::~DSLookup ()
{
    if (0 != m_hEnum)
    {
        VERIFY(SUCCEEDED(ADEndQuery(m_hEnum)));        
        m_hEnum = 0;
    }
}

inline HRESULT DSLookup::Next( 
    IN OUT  DWORD*          pcProps,
    OUT     PROPVARIANT     aPropVar[])
{
    ASSERT(0 != m_hEnum);    
    m_hr = ADQueryResults(
               m_hEnum, 
               pcProps, 
               aPropVar
               );
    return m_hr;
}

inline BOOL DSLookup::HasValidHandle()
{
    return (0 != m_hEnum);
}

inline HRESULT DSLookup::GetStatusCode()
{
    return m_hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\dssec.h ===
#ifndef _DSSEC_H_
#define _DSSEC_H_

#include <aclui.h>  // LPSECURITYINFO


//+---------------------------------------------------------------------------
//
//  Function:   PFNREADOBJECTSECURITY
//
//  Synopsis:   Reads the security descriptor of a DS object
//
//  Arguments:  [IN  LPCWSTR]               --  ADS path of DS Object
//              [IN  SECURITY_INFORMATION]  --  Which SD parts to read
//              [OUT PSECURITY_DESCRIPTOR*] --  Return SD here. Caller frees with LocalFree
//              [IN  LPARAM]                --  Context param
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
//
//  Function:   PFNWRITEOBJECTSECURITY
//
//  Synopsis:   Writes a security descriptor to a DS object
//
//  Arguments:  [IN  LPCWSTR]               --  ADS path of DS Object
//              [IN  SECURITY_INFORMATION]  --  Which SD parts to write
//              [OUT PSECURITY_DESCRIPTOR]  --  Security descriptor to write
//              [IN  LPARAM]                --  Context param
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
typedef HRESULT (WINAPI *PFNREADOBJECTSECURITY)(LPCWSTR, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR*, LPARAM);
typedef HRESULT (WINAPI *PFNWRITEOBJECTSECURITY)(LPCWSTR, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR, LPARAM);

//+---------------------------------------------------------------------------
//
//  Function:   DSCreateISecurityInfoObject
//
//  Synopsis:   Instantiates an ISecurityInfo interface for a DS object
//
//  Arguments:  [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [OUT ppSI]              --  Interface pointer returned here
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  LPARAM]            --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSCreateISecurityInfoObject(LPCWSTR pwszObjectPath,
                            LPCWSTR pwszObjectClass,
                            DWORD dwFlags,
                            LPSECURITYINFO *ppSI,
                            PFNREADOBJECTSECURITY pfnReadSD,
                            PFNWRITEOBJECTSECURITY pfnWriteSD,
                            LPARAM lpContext);

#define DSSI_READ_ONLY          0x00000001
#define DSSI_NO_ACCESS_CHECK    0x00000002
#define DSSI_NO_EDIT_SACL       0x00000004
#define DSSI_NO_EDIT_OWNER      0x00000008
#define DSSI_IS_ROOT            0x00000010

//+---------------------------------------------------------------------------
//
//  Function:   DSCreateSecurityPage
//
//  Synopsis:   Creates a Security property page for a DS object
//
//  Arguments:  [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [OUT phPage]            --  HPROPSHEETPAGE returned here
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  LPARAM]            --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSCreateSecurityPage(LPCWSTR pwszObjectPath,
                     LPCWSTR pwszObjectClass,
                     DWORD dwFlags,
                     HPROPSHEETPAGE *phPage,
                     PFNREADOBJECTSECURITY pfnReadSD,
                     PFNWRITEOBJECTSECURITY pfnWriteSD,
                     LPARAM lpContext);

//+---------------------------------------------------------------------------
//
//  Function:   DSEditSecurity
//
//  Synopsis:   Displays a modal dialog for editing security on a DS object
//
//  Arguments:  [IN  hwndOwner]         --  Dialog owner window
//              [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [IN  pwszCaption]       --  Optional dialog caption
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  LPARAM]            --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSEditSecurity(HWND hwndOwner,
               LPCWSTR pwszObjectPath,
               LPCWSTR pwszObjectClass,
               DWORD dwFlags,
               LPCWSTR pwszCaption,
               PFNREADOBJECTSECURITY pfnReadSD,
               PFNWRITEOBJECTSECURITY pfnWriteSD,
               LPARAM lpContext);


typedef HRESULT (WINAPI *PFNDSCREATEISECINFO)(LPCWSTR,
                                              LPCWSTR,
                                              DWORD,
                                              LPSECURITYINFO*,
                                              PFNREADOBJECTSECURITY,
                                              PFNWRITEOBJECTSECURITY,
                                              LPARAM);

typedef HRESULT (WINAPI *PFNDSCREATESECPAGE)(LPCWSTR,
                                             LPCWSTR,
                                             DWORD,
                                             HPROPSHEETPAGE*,
                                             PFNREADOBJECTSECURITY,
                                             PFNWRITEOBJECTSECURITY,
                                             LPARAM);

typedef HRESULT (WINAPI *PFNDSEDITSECURITY)(HWND,
                                            LPCWSTR,
                                            LPCWSTR,
                                            DWORD,
                                            LPCWSTR,
                                            PFNREADOBJECTSECURITY,
                                            PFNWRITEOBJECTSECURITY,
                                            LPARAM);

#endif  /* _DSSEC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\entergen.cpp ===
// EnterGen.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "mqPPage.h"
#include "EnterGen.h"
#include "mqdsname.h"

#include "entergen.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEnterpriseGeneral property page

IMPLEMENT_DYNCREATE(CEnterpriseGeneral, CMqPropertyPage)

const int CEnterpriseGeneral::m_conversionTable[] = { 1, 60, 60*60, 60*60*24 };

CEnterpriseGeneral::CEnterpriseGeneral(
    const CString& EnterprisePathName,
	const CString& strDomainController
    ) : 
    CMqPropertyPage(CEnterpriseGeneral::IDD),
    m_strDomainController(strDomainController),
	m_dwLongLiveValue(0)
{
	//{{AFX_DATA_INIT(CEnterpriseGeneral)
	//}}AFX_DATA_INIT
	m_strMsmqServiceContainer.Format(
								L"%s"
								TEXT(",")
								L"%s",
								x_MsmqServiceContainerPrefix,
								EnterprisePathName
								);
}

CEnterpriseGeneral::~CEnterpriseGeneral()
{
}

void CEnterpriseGeneral::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
   	int	iLongLiveUnits = eSeconds;
	DWORD	dwLongLiveFieldValue = m_dwLongLiveValue;

    if (!pDX->m_bSaveAndValidate)
    {
        //
        // If time is exactly divided by days, hours or seconds use it.
        //
        for (DWORD i = eDays;  i > eSeconds; --i)
        {
            if ((dwLongLiveFieldValue % m_conversionTable[i]) == 0)
            {
                iLongLiveUnits = i;
                dwLongLiveFieldValue = dwLongLiveFieldValue / m_conversionTable[i];
                break;
            }
        }
    }

	DDX_CBIndex(pDX, IDC_ENT_GEN_LONGLIVE_UNITS_COMBO, iLongLiveUnits);
	DDX_Text(pDX, IDC_ENT_GEN_LONGLIVE_EDIT, dwLongLiveFieldValue);

	//{{AFX_DATA_MAP(CEnterpriseGeneral)
	//}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
		//
		// Make sure we do not overflow a DWORD boundaries
		//
		if (((DWORD)MAXULONG / (DWORD)m_conversionTable[iLongLiveUnits]) > dwLongLiveFieldValue)
		{
	        m_dwLongLiveValue = dwLongLiveFieldValue * m_conversionTable[iLongLiveUnits];
		}
		else
		{
			CString str;
			MQErrorToMessageString(str,ERROR_INVALID_DATA);
            AfxMessageBox(str);
            pDX->Fail();
		}
    }
}



BEGIN_MESSAGE_MAP(CEnterpriseGeneral, CMqPropertyPage)
	//{{AFX_MSG_MAP(CEnterpriseGeneral)
	ON_CBN_SELCHANGE(IDC_ENT_GEN_LONGLIVE_UNITS_COMBO, OnEnterpriseLongLiveChange)
	ON_EN_CHANGE(IDC_ENT_GEN_LONGLIVE_EDIT, OnEnterpriseLongLiveChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEnterpriseGeneral message handlers

BOOL CEnterpriseGeneral::OnInitDialog() 
{
    CString strLongLiveUnit;
	
    //
    // This closure is used to keep the DLL state. For UpdateData we need
    // the mmc.exe state.
    //
    {
    	AFX_MANAGE_STATE(AfxGetStaticModuleState());

        const int UnitTypes[] = {IDS_SECONDS, IDS_MINUTES, IDS_HOURS, IDS_DAYS};
        //
        // Initialize the units combo box
        //
        CComboBox *ccomboUnits = (CComboBox *)GetDlgItem(IDC_ENT_GEN_LONGLIVE_UNITS_COMBO);

        for (int i = eSeconds; i < eLast; ++i)
        {
            VERIFY(FALSE != strLongLiveUnit.LoadString(UnitTypes[i]));
            VERIFY(CB_ERR != ccomboUnits->AddString(strLongLiveUnit));
        }
    }

    UpdateData( FALSE );

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CEnterpriseGeneral::OnApply() 
{
    if (m_dwLongLiveValue == m_dwInitialLongLiveValue)
    {
        return TRUE;
    }

    PROPID paPropid[] = { PROPID_E_LONG_LIVE };
	const DWORD x_iPropCount = sizeof(paPropid) / sizeof(paPropid[0]);
	PROPVARIANT apVar[x_iPropCount];
    
	DWORD iProperty = 0;

    //
    // PROPID_E_LONG_LIVE
    //
    ASSERT(paPropid[iProperty] == PROPID_E_LONG_LIVE);
    apVar[iProperty].vt = VT_UI4;
	apVar[iProperty++].ulVal = m_dwLongLiveValue;
    
    //
    // set the new value
    //	
    HRESULT hr = ADSetObjectProperties(
                        eENTERPRISE,
                        GetDomainController(m_strDomainController),
						true,	// fServerName
                        L"msmq",
                        x_iPropCount, 
                        paPropid, 
                        apVar
                        );

    if (MQ_OK != hr)
    {
    	AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
        MessageDSError(hr, IDS_OP_SET_PROPERTIES_OF, m_strMsmqServiceContainer);
        return FALSE;
    }
	
	return CMqPropertyPage::OnApply();
}

void CEnterpriseGeneral::OnEnterpriseLongLiveChange() 
{
    SetModified();	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\edataobj.h ===
// edataobj.h : Declaration of the CEnterpriseDataObject

#ifndef __EDATAOBJECT_H_
#define __EDATAOBJECT_H_

#include "resource.h"       // main symbols
#include "dataobj.h"

/////////////////////////////////////////////////////////////////////////////
// CEnterpriseDataObject
class CEnterpriseDataObject : 
	public CDataObject,
	public CComCoClass<CEnterpriseDataObject, &CLSID_EnterpriseDataObject>
{
public:
    DECLARE_NOT_AGGREGATABLE(CEnterpriseDataObject)
    DECLARE_REGISTRY_RESOURCEID(IDR_ENTERPRISEDATAOBJECT)

    //
    // IShellPropSheetExt
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    //
    // IContextMenu
    //
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);

protected:
    HPROPSHEETPAGE CreateGeneralPage();

    virtual HRESULT ExtractMsmqPathFromLdapPath (LPWSTR lpwstrLdapPath);
   	virtual const DWORD GetObjectType();
    virtual const PROPID *GetPropidArray();
    virtual const DWORD  GetPropertiesCount();


private:
    enum _MENU_ENTRY
    {
        eNewForeignSite = 0,
        eNewForeignComputer
    };

    static const PROPID mx_paPropid[];
};

inline 
const 
DWORD 
CEnterpriseDataObject::GetObjectType(
    void
    )
{
    return MQDS_ENTERPRISE;
};

inline 
const 
PROPID*
CEnterpriseDataObject::GetPropidArray(
    void
    )
{
    return mx_paPropid;
}

#endif //__EDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\forgcomp.cpp ===
// ForgComp.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "globals.h"
#include "dsext.h"
#include "mqsnap.h"
#include "mqppage.h"
#include "ForgComp.h"

#include "forgcomp.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CForeignComputer dialog

CForeignComputer::CForeignComputer(const CString& strDomainController)
	: CMqPropertyPage(CForeignComputer::IDD),
	  m_strDomainController(strDomainController)
{
	//{{AFX_DATA_INIT(CForeignComputer)
	m_strName = _T("");
	m_iSelectedSite = -1;
	//}}AFX_DATA_INIT
}


void
CForeignComputer::SetParentPropertySheet(
	CGeneralPropertySheet* pPropertySheet
	)
{
	m_pParentSheet = pPropertySheet;
}


void CForeignComputer::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
    BOOL fFirstTime = (m_ccomboSites.m_hWnd == NULL);

	//{{AFX_DATA_MAP(CForeignComputer)
	DDX_Control(pDX, IDC_FOREIGN_COMPUTER_SITE, m_ccomboSites);
	DDX_Text(pDX, IDC_FOREIGN_COMPUTER_NAME, m_strName);
	//}}AFX_DATA_MAP
	DDV_NotEmpty(pDX, m_strName, IDS_PLEASE_ENTER_A_COMPUTER_NAME);
	DDX_CBIndex(pDX, IDC_FOREIGN_COMPUTER_SITE, m_iSelectedSite);

    if (fFirstTime)
    {
        InitiateSitesList();
    }

    if (pDX->m_bSaveAndValidate) 
    {
        if (CB_ERR == m_iSelectedSite)
        {
            AfxMessageBox(IDS_PLEASE_SELECT_A_SITE);
            pDX->Fail();
        }

        DWORD_PTR dwSiteIndex = m_ccomboSites.GetItemData(m_iSelectedSite);
        ASSERT(CB_ERR != dwSiteIndex);

        m_guidSite = m_aguidAllSites[dwSiteIndex];
    }

	DDV_ValidComputerName(pDX, m_strName);
}


BEGIN_MESSAGE_MAP(CForeignComputer, CMqPropertyPage)
	//{{AFX_MSG_MAP(CForeignComputer)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CForeignComputer message handlers
BOOL CForeignComputer::OnInitDialog() 
{
	CMqPropertyPage::OnInitDialog();
	
	CString strDomainName;

	int index = m_strDomainController.Find(L'.');
	if ( index != -1 )
	{
		strDomainName = m_strDomainController.Right(m_strDomainController.GetLength() - index - 1);
	}

	CString strTitle;
	strTitle.FormatMessage(IDS_COMPUTERS, strDomainName);

	SetDlgItemText(IDC_FOREIGN_COMPUTER_CONTAINER, strTitle);

	return TRUE;
}


BOOL CForeignComputer::OnSetActive() 
{
	ASSERT((L"No parent property sheet", m_pParentSheet != NULL));
	return m_pParentSheet->SetWizardButtons();
}


HRESULT CForeignComputer::InitiateSitesList()
{
    //
    // Prepare list of sites
    //
    ASSERT(m_ccomboSites.m_hWnd != NULL);

    DWORD dwSiteIndex = 0;
    m_ccomboSites.ResetContent();
    
    //
    // Initialize the full sites list
    //
	PROPID aPropId[] = {PROPID_S_SITEID, PROPID_S_PATHNAME};
	const DWORD x_nProps = sizeof(aPropId) / sizeof(aPropId[0]);

	PROPVARIANT apResultProps[x_nProps];

	CColumns columns;
	for (DWORD i=0; i<x_nProps; i++)
	{
		columns.Add(aPropId[i]);
	}
    
    HANDLE hEnume;
    HRESULT hr;
    {
        CWaitCursor wc; //display wait cursor while query DS
        hr = ADQueryForeignSites(
                    GetDomainController(m_strDomainController),
					true,		// fServerName
                    columns.CastToStruct(),
                    &hEnume
                    );     
    }
    DSLookup dslookup(hEnume, hr);

    if (!dslookup.HasValidHandle())
    {
        return E_UNEXPECTED;
    }

	DWORD dwPropCount = x_nProps;
	while ( SUCCEEDED(dslookup.Next(&dwPropCount, apResultProps))
			&& (dwPropCount != 0) )
	{
        DWORD iProperty = 0;

        //
        // PROPID_S_SITEID
        //
        ASSERT(PROPID_S_SITEID == aPropId[iProperty]);
        CAutoMQFree<GUID> pguidSite = apResultProps[iProperty].puuid;
        iProperty++;

        //
        // PROPID_S_PATHNAME
        //
        ASSERT(PROPID_S_PATHNAME == aPropId[iProperty]);
        CAutoMQFree<WCHAR> lpwstrSiteName = apResultProps[iProperty].pwszVal;
        iProperty++;

        int nIndex = m_ccomboSites.AddString(lpwstrSiteName);
        if (FAILED(nIndex))
        {
            return E_UNEXPECTED;
        }

        m_aguidAllSites.SetAtGrow(dwSiteIndex, *(GUID *)pguidSite);
        m_ccomboSites.SetItemData(nIndex, dwSiteIndex);
        dwSiteIndex++;

		dwPropCount = x_nProps;
	}

	//
	// If only one foreign site exists, initialize the combo box with it
	//
	if ( dwSiteIndex == 1 )
	{
		m_ccomboSites.SetCurSel(0);
	}

    return S_OK;
}

BOOL CForeignComputer::OnWizardFinish() 
{
    if (0 == UpdateData())
    {
        //
        // Data was not validated - remain in Window!
        //
        return FALSE;
    }

	//
	// Remove all leading and trailing white spaces. They will be removed on creation
	// anyway, but having them in the object name will cause problems in ad.lib
	//
	m_strName.TrimLeft();
	m_strName.TrimRight();

    //
    //  Create computer object
    //
    // The Netbios name is the first MAX_COM_SAM_ACCOUNT_LENGTH (19) characters
    // of the computer name. This value goes to the samAccountName property of the computer.
    // Two computers cannot have the same 19 characters prefix (6295 - ilanh - 03-Jan-2001)
    //
    CString strAccountName = m_strName.Left(MAX_COM_SAM_ACCOUNT_LENGTH) + L"$";

	PROPID aPropComp[] = {PROPID_COM_SAM_ACCOUNT, PROPID_COM_VERSION};
    PROPVARIANT aVarComp[TABLE_SIZE(aPropComp)];
    aVarComp[0].vt = VT_LPWSTR;
    aVarComp[0].pwszVal = (LPWSTR)(LPCWSTR)strAccountName;   
	DWORD cp = 1;

    OSVERSIONINFO verOsInfo;
    verOsInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	WCHAR OsVersion[200];
    if(GetVersionEx(&verOsInfo))
    {
	   int n=_snwprintf(OsVersion, STRLEN(OsVersion), L"%u.%u (%u)", verOsInfo.dwMajorVersion, verOsInfo.dwMinorVersion, verOsInfo.dwBuildNumber & 0xFFFF);
	   ASSERT(n>=0);
	   OsVersion[STRLEN(OsVersion)]=L'\0';
	   	aVarComp[1].vt = VT_LPWSTR;
	   	aVarComp[1].pwszVal = OsVersion;   
	   	cp++;
    }

	ASSERT(("GetVersionEx failed", cp == 2));
    
	HRESULT hr = ADCreateObject(
                    eCOMPUTER,
                    GetDomainController(m_strDomainController),
					true,	    // fServerName
                    m_strName,
                    NULL, //pSecurityDescriptor,
                    cp,
                    aPropComp,
                    aVarComp,
                    NULL    
                    );

    if (FAILED(hr) && hr != MQDS_E_COMPUTER_OBJECT_EXISTS)
    {
		if ( (hr & DS_ERROR_MASK) == ERROR_DS_INVALID_DN_SYNTAX ||
			 hr == E_ADS_BAD_PATHNAME )
		{
			DisplayErrorAndReason(IDS_OP_CREATE_COMPUTER, IDS_INVALID_DN_SYNTAX, m_strName, hr);
			return FALSE;
		}
		else if (	(hr & DS_ERROR_MASK) == ERROR_DS_CONSTRAINT_VIOLATION ||
					(hr & DS_ERROR_MASK) == ERROR_DS_UNWILLING_TO_PERFORM ||
					(hr & DS_ERROR_MASK) == ERROR_GEN_FAILURE )
		{
			DisplayErrorAndReason(IDS_OP_CREATE_COMPUTER, IDS_MAYBE_INVALID_DN_SYNTAX, m_strName, hr);
			return FALSE;
		}
		
        MessageDSError(hr, IDS_OP_CREATE_COMPUTER, m_strName);

        //
        // On error - do not call the default, and thus do not exit the dialog
        //
        return FALSE;
    }

    PROPID aProp[] = {PROPID_QM_SITE_IDS,                       
                      PROPID_QM_SERVICE_DSSERVER,  
                      PROPID_QM_SERVICE_ROUTING, 
                      PROPID_QM_SERVICE_DEPCLIENTS, 
                      PROPID_QM_FOREIGN, 
                      PROPID_QM_OS};

    PROPVARIANT apVar[TABLE_SIZE(aProp)];

    UINT uiPropIndex = 0;

    //
    // PROPID_QM_SITE_IDS
    //
    ASSERT(aProp[uiPropIndex] == PROPID_QM_SITE_IDS);   
    apVar[uiPropIndex].vt = VT_CLSID | VT_VECTOR;
    apVar[uiPropIndex].cauuid.cElems = 1;
    apVar[uiPropIndex].cauuid.pElems = &m_guidSite;

    uiPropIndex++;
    
    //
    // PROPID_QM_SERVICE_DSSERVER
    //
    ASSERT(aProp[uiPropIndex] == PROPID_QM_SERVICE_DSSERVER);
    apVar[uiPropIndex].vt = VT_UI1;
    apVar[uiPropIndex].bVal = FALSE;

    uiPropIndex++;

    //
    // PROPID_QM_SERVICE_ROUTING
    //
    ASSERT(aProp[uiPropIndex] == PROPID_QM_SERVICE_ROUTING);
    apVar[uiPropIndex].vt = VT_UI1;
    apVar[uiPropIndex].bVal = FALSE;

    uiPropIndex++;

    //
    // PROPID_QM_SERVICE_DEPCLIENTS
    //
    ASSERT(aProp[uiPropIndex] == PROPID_QM_SERVICE_DEPCLIENTS);
    apVar[uiPropIndex].vt = VT_UI1;
    apVar[uiPropIndex].bVal = FALSE;

    uiPropIndex++;


    //
    // PROPID_QM_FOREIGN
    //
    ASSERT(aProp[uiPropIndex] == PROPID_QM_FOREIGN);
    apVar[uiPropIndex].vt = VT_UI1;
    apVar[uiPropIndex].bVal = TRUE;

    uiPropIndex++;

    //
    // PROPID_QM_OS
    //
    ASSERT(aProp[uiPropIndex] == PROPID_QM_OS);
    apVar[uiPropIndex].vt = VT_UI4;
    apVar[uiPropIndex].ulVal = MSMQ_OS_FOREIGN;

    uiPropIndex++;
    
    hr = ADCreateObject(
            eMACHINE,
            GetDomainController(m_strDomainController),
			true,	    // fServerName
            (LPTSTR)((LPCTSTR)m_strName),
            NULL, //pSecurityDescriptor,
            TABLE_SIZE(aProp),
            aProp, 
            apVar,
            NULL    
            );

    if FAILED(hr)
    {
        MessageDSError(hr, IDS_OP_CREATE_MSMQ_OBJECT, m_strName);
        return FALSE;
    }


    CString strConfirmation;
    strConfirmation.FormatMessage(IDS_FOREIGN_COMPUTER_CREATED, m_strName);
    AfxMessageBox(strConfirmation, MB_ICONINFORMATION );

	return CMqPropertyPage::OnWizardFinish();
}


void
CForeignComputer::DDV_ValidComputerName(
	CDataExchange* pDX,
	CString& strName
	)
{
	if (!pDX->m_bSaveAndValidate)
		return;

	int indexDot = strName.Find(L'.');
	if (indexDot >= 0)
	{
		DisplayErrorAndReason(IDS_OP_CREATE_COMPUTER, IDS_INVALID_DN_SYNTAX, strName, 0);
        pDX->Fail();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\entergen.h ===
#if !defined(AFX_ENTERGEN_H__2E4B37A7_CC8B_11D1_9C85_006008764D0E__INCLUDED_)
#define AFX_ENTERGEN_H__2E4B37A7_CC8B_11D1_9C85_006008764D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// EnterGen.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEnterpriseGeneral dialog

class CEnterpriseGeneral : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CEnterpriseGeneral)

// Construction
public:
	CEnterpriseGeneral(const CString& EnterprisePathName, const CString& strDomainController);
    CEnterpriseGeneral() {};
	~CEnterpriseGeneral();

    void LongLiveIntialize(DWORD dwInitialLongLiveValue);

// Dialog Data
	//{{AFX_DATA(CEnterpriseGeneral)
	enum { IDD = IDD_ENTERPRISE_GENERAL };
	//}}AFX_DATA

    DWORD m_dwLongLiveValue;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CEnterpriseGeneral)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CEnterpriseGeneral)
	virtual BOOL OnInitDialog();
	afx_msg void OnEnterpriseLongLiveChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    enum LongLiveUnits
    {
        eSeconds,
        eMinutes,
        eHours,
        eDays,
        eLast
    };

    static const int m_conversionTable[eLast];
	DWORD	m_dwInitialLongLiveValue;
    CString m_strDomainController;
	CString m_strMsmqServiceContainer;
};


inline
void
CEnterpriseGeneral::LongLiveIntialize(
    DWORD dwInitialLongLiveValue
    ) 
{
    m_dwInitialLongLiveValue = dwInitialLongLiveValue;
    m_dwLongLiveValue = dwInitialLongLiveValue;
}

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ENTERGEN_H__2E4B37A7_CC8B_11D1_9C85_006008764D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\forgcomp.h ===
#ifndef FORGCOMP_NEW
#define FORGCOMP_NEW

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ForgComp.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CForeignComputer dialog

class CForeignComputer : public CMqPropertyPage
{
// Construction
public:
	CForeignComputer(const CString& strDomainController);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CForeignComputer)
	enum { IDD = IDD_CREATE_FOREIGN_COMPUTER };
	CComboBox	m_ccomboSites;
	CString	m_strName;
	int		m_iSelectedSite;
	//}}AFX_DATA

	void
	SetParentPropertySheet(
		CGeneralPropertySheet* pPropertySheet
		);


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CForeignComputer)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	GUID m_guidSite;
    HRESULT InitiateSitesList();
    CArray<GUID, const GUID&> m_aguidAllSites;
    CString m_strDomainController;


	// Generated message map functions
	//{{AFX_MSG(CForeignComputer)
	virtual BOOL OnWizardFinish();
	virtual BOOL OnSetActive();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CGeneralPropertySheet* m_pParentSheet;

	void DDV_ValidComputerName(CDataExchange* pDX, CString& strName);

};

#endif // #ifndef FORGCOMP_NEW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\forgpage.cpp ===
// ForgPage.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqPPage.h"
#include "ForgPage.h"

#include "forgpage.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CForeignPage property page

IMPLEMENT_DYNCREATE(CForeignPage, CMqPropertyPage)

CForeignPage::CForeignPage() : CMqPropertyPage(CForeignPage::IDD)
{
	//{{AFX_DATA_INIT(CForeignPage)
	m_Description = _T("");
	//}}AFX_DATA_INIT
}

CForeignPage::~CForeignPage()
{
}

void CForeignPage::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CForeignPage)
	DDX_Text(pDX, IDC_FOREIGN_LABEL, m_Description);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CForeignPage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CForeignPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CForeignPage message handlers

BOOL CForeignPage::OnInitDialog() 
{
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        m_Description.LoadString(IDS_FOREIGN_SITE);
    }

    UpdateData(FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\forgdata.cpp ===
// ForeignSiteData.cpp : Implementation of CForeignSiteData
#include "stdafx.h"
#include "mqsnap.h"
#include "mqPPage.h"
#include "ForgData.h"
#include "ForgPage.h"
#include "ldaputl.h"

#include "forgdata.tmh"

const PROPID CForeignSiteData::mx_paPropid[] = {
    PROPID_S_FOREIGN
    };

HRESULT 
CForeignSiteData::ExtractMsmqPathFromLdapPath(
    LPWSTR lpwstrLdapPath
    )
{
    return ExtractNameFromLdapName(m_strMsmqPath, lpwstrLdapPath, 1);
}

STDMETHODIMP 
CForeignSiteData::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam
    )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (FAILED(GetPropertiesSilent()))
    {
        return E_UNEXPECTED;
    }

    //
    // Check that the site is a foreign site.
    //
    PROPVARIANT propVar;
    PROPID pid = PROPID_S_FOREIGN;
    
    VERIFY(m_propMap.Lookup(pid, propVar));
    if (propVar.bVal == FALSE)
    {
        return S_OK;
    }

    HPROPSHEETPAGE hPage = CreateForeignSitePage();
    if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
    {
        ASSERT(0);
        return E_UNEXPECTED;
    }

    return S_OK;
}

HPROPSHEETPAGE 
CForeignSiteData::CreateForeignSitePage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Note: CForeignPage is auto-delete by default
    //
	CForeignPage *pcpageForeign = new CForeignPage;

	return pcpageForeign->CreateThemedPropertySheetPage();
}

const 
DWORD  
CForeignSiteData::GetPropertiesCount()
{
    return sizeof(mx_paPropid) / sizeof(mx_paPropid[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\forgdata.h ===
// ForgData.h : Declaration of the CForeignSiteData

#ifndef __FOREIGNSITEDATA_H_
#define __FOREIGNSITEDATA_H_

#include "resource.h"       // main symbols
#include "dataobj.h"

/////////////////////////////////////////////////////////////////////////////
// CForeignSiteData
class ATL_NO_VTABLE CForeignSiteData : 
	public CDataObject,
	public CComCoClass<CForeignSiteData, &CLSID_ForeignSiteData>
{
    DECLARE_NOT_AGGREGATABLE(CForeignSiteData)
    DECLARE_REGISTRY_RESOURCEID(IDR_FOREIGNSITEDATA)

    //
    // IShellPropSheetExt
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    //
    // IContextMenu
    //
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);

protected:
    HPROPSHEETPAGE CreateForeignSitePage();

    virtual HRESULT ExtractMsmqPathFromLdapPath (LPWSTR lpwstrLdapPath);
   	virtual const DWORD GetObjectType();
    virtual const PROPID *GetPropidArray();
    virtual const DWORD  GetPropertiesCount();


private:
    static const PROPID mx_paPropid[];

};


inline
const 
DWORD 
CForeignSiteData::GetObjectType()
{
    return MQDS_SITE;
}

inline
const 
PROPID*
CForeignSiteData::GetPropidArray()
{
    return mx_paPropid;
}

//
// IContextMenu
//
inline
STDMETHODIMP 
CForeignSiteData::QueryContextMenu(
    HMENU /*hmenu*/,
    UINT /*indexMenu*/, 
    UINT /*idCmdFirst*/, 
    UINT /*idCmdLast*/, 
    UINT /*uFlags*/
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return 0;
}

inline
STDMETHODIMP 
CForeignSiteData::InvokeCommand(
    LPCMINVOKECOMMANDINFO /*lpici*/
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(0);

    return S_OK;
}


#endif //__FOREIGNSITEDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\forgpage.h ===
#if !defined(AFX_FORGPAGE_H__5AB7891A_D920_11D1_9C86_006008764D0E__INCLUDED_)
#define AFX_FORGPAGE_H__5AB7891A_D920_11D1_9C86_006008764D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ForgPage.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CForeignPage dialog

class CForeignPage : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CForeignPage)

// Construction
public:
	CForeignPage();
	~CForeignPage();

// Dialog Data
	//{{AFX_DATA(CForeignPage)
	enum { IDD = IDD_FOREIGN_SITE };
	CString	m_Description;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CForeignPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CForeignPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FORGPAGE_H__5AB7891A_D920_11D1_9C86_006008764D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\forgsite.cpp ===
// ForgSite.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "globals.h"
#include "mqppage.h"
#include "ForgSite.h"

#include "forgsite.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CForeignSite dialog


CForeignSite::CForeignSite(CString strRootDomain)
	: CMqPropertyPage(CForeignSite::IDD),
	  m_strRootDomain(strRootDomain)
{
	//{{AFX_DATA_INIT(CForeignSite)
	m_Foreign_Site_Name = _T("");
	//}}AFX_DATA_INIT
}


void
CForeignSite::SetParentPropertySheet(
	CGeneralPropertySheet* pPropertySheet
	)
{
	m_pParentSheet = pPropertySheet;
}


void CForeignSite::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CForeignSite)
	DDX_Text(pDX, IDC_FOREIGN_SITE_NAME, m_Foreign_Site_Name);
	//}}AFX_DATA_MAP

    if ((pDX->m_bSaveAndValidate) && (m_Foreign_Site_Name.IsEmpty()))
    {
        AfxMessageBox(IDS_MISSING_FOREIGN_SITE_NAME);
        pDX->Fail();
    }
}


BEGIN_MESSAGE_MAP(CForeignSite, CMqPropertyPage)
	//{{AFX_MSG_MAP(CForeignSite)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CForeignSite message handlers
BOOL CForeignSite::OnInitDialog() 
{
	CMqPropertyPage::OnInitDialog();
	
	CString strTitle;
	strTitle.FormatMessage(IDS_SITES, m_strRootDomain);

	SetDlgItemText(IDC_FOREIGN_SITE_CONTAINER, strTitle);

	return TRUE;
}


BOOL CForeignSite::OnSetActive() 
{
	ASSERT((L"No parent property sheet", m_pParentSheet != NULL));
	return m_pParentSheet->SetWizardButtons();
}


BOOL CForeignSite::OnWizardFinish() 
{
    //
    // Call DoDataExchange
    //
    if (!UpdateData(TRUE))
    {
        return FALSE;
    }

    //
    // Create Site link in the DS
    //
    HRESULT rc = CreateForeignSite();
    if(FAILED(rc))
    {
		if ( (rc & DS_ERROR_MASK) == ERROR_DS_INVALID_DN_SYNTAX ||
			 (rc & DS_ERROR_MASK) == ERROR_DS_NAMING_VIOLATION ||
			 rc == E_ADS_BAD_PATHNAME )
		{
			DisplayErrorAndReason(IDS_CREATE_SITE_FAILED, IDS_INVALID_DN_SYNTAX, m_Foreign_Site_Name, rc);
			return FALSE;
		}

        MessageDSError(rc, IDS_CREATE_SITE_FAILED, m_Foreign_Site_Name);
        return FALSE;
    }

    CString strConfirmation;
    strConfirmation.FormatMessage(IDS_FOREIGN_SITE_CREATED, m_Foreign_Site_Name);
    AfxMessageBox(strConfirmation, MB_ICONINFORMATION);

    return CMqPropertyPage::OnWizardFinish();
}


HRESULT
CForeignSite::CreateForeignSite(
    void
    )
{
    ASSERT(!m_Foreign_Site_Name.IsEmpty());

	//
	// Remove all the leading and trailing white spaces.
	//
	m_Foreign_Site_Name.TrimLeft();
	m_Foreign_Site_Name.TrimRight();

    //
    // Prepare the properties for DS call.
    //
    PROPID paPropid[] = { 
                PROPID_S_FOREIGN
                };

	const DWORD x_iPropCount = sizeof(paPropid) / sizeof(paPropid[0]);
	PROPVARIANT apVar[x_iPropCount];
    DWORD iProperty = 0;

	ASSERT(paPropid[iProperty] == PROPID_S_FOREIGN);    //PropId
    apVar[iProperty].vt = VT_UI1;          //Type
    apVar[iProperty].bVal = TRUE;
    ++iProperty;
  
    HRESULT hr = ADCreateObject(
                    eSITE,
                    GetDomainController(m_strDomainController),
					true,	    // fServerName
                    m_Foreign_Site_Name,
                    NULL, //pSecurityDescriptor,
                    iProperty,
                    paPropid,
                    apVar,                                  
                    NULL    
                    );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\forgsite.h ===
#ifndef FORGSITE_NEW
#define FORGSITE_NEW

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ForeignSite.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CForeignSite dialog

class CForeignSite : public CMqPropertyPage
{
// Construction
public:
	CForeignSite(CString strRootDomain);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CForeignSite)
	enum { IDD = IDD_CREATE_FOREIGN_SITE };
	CString	m_Foreign_Site_Name;
	CString	m_strDomainController;
	//}}AFX_DATA

	void
	SetParentPropertySheet(
		CGeneralPropertySheet* pPropertySheet
		);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CForeignSite)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL


// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CForeignSite)
	virtual BOOL OnWizardFinish();
	virtual BOOL OnSetActive();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    HRESULT
    CreateForeignSite(
        void
        );

	CGeneralPropertySheet* m_pParentSheet;
	CString m_strRootDomain;

};


#endif // FORGSITE_NEW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\frslist.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    frslist.cpp

Abstract:

    FRS list control - source.

Author:

    Yoel Arnon (yoela)

--*/
#include "stdafx.h"
#include "resource.h"
#include "frslist.h"
#include "globals.h"
#include "dsext.h"

#include "frslist.tmh"

CFrsList::CFrsList() :
    m_pGuidArray(0)
{
}

CFrsList::~CFrsList()
{
    if (m_pGuidArray)
    {
        m_pGuidArray->Release();
    }
}


HRESULT CFrsList::InitFrsList(CACLSID const pguidSiteIds, BOOL fLocalMgmt, const CString& strDomainController)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Initiate();
    if (0 != m_pGuidArray)
    {
        m_pGuidArray->Release();
    }
    m_pGuidArray = new CGuidArray;

    HRESULT hr = S_OK;
    PROPID aPropId[] = {PROPID_QM_PATHNAME, PROPID_QM_MACHINE_ID};
    const DWORD x_nProps = sizeof(aPropId) / sizeof(aPropId[0]);

    PROPVARIANT apResultProps[x_nProps];

    CColumns columns;
    for (DWORD i=0; i<x_nProps; i++)
    {
        columns.Add(aPropId[i]);
    }

	for (DWORD i=0; i < pguidSiteIds.cElems; i++)
    {       
		//
	    // This search request will be recognized and specially simulated by DS
	    //    
		HANDLE hEnume;
		GUID *pguidSiteId = &((pguidSiteIds.pElems)[i]);
		{
			CWaitCursor wc; //display wait cursor while query DS
			hr = ADQuerySiteServers(
						fLocalMgmt ? MachineDomain() : GetDomainController(strDomainController),
						fLocalMgmt ? false : true,		// fServerName
			            pguidSiteId,
			            eRouter,
			            columns.CastToStruct(),
			            &hEnume
			            );
		}

		DSLookup dslookup (hEnume, hr);
    
		if (!dslookup.HasValidHandle())
		{
		    return E_UNEXPECTED;
		}

		DWORD dwPropCount = x_nProps;
	
		while ( SUCCEEDED(dslookup.Next(&dwPropCount, apResultProps))
		        && (dwPropCount != 0) )
		{
		    DWORD iProperty = 0;
		    
		    //
		    // PROPID_QM_PATHNAME
		    //
		    ASSERT(PROPID_QM_PATHNAME == aPropId[iProperty]);
		    CAutoMQFree<WCHAR> lpwstrFrsName = apResultProps[iProperty].pwszVal;
	
	        iProperty++;
	
	        //
	        // PROPID_QM_MACHINE_ID
	        //
	        ASSERT(PROPID_QM_MACHINE_ID == aPropId[iProperty]);
	        CAutoMQFree<GUID> pguidFrs = apResultProps[iProperty].puuid;
	
			if (FindStringExact( -1, lpwstrFrsName) == CB_ERR)
			{
				//
				// the lpwstrFrsName was not Added before.
				// (it could have been added if the Frs is in more then 1 site)
				//

				int nIndex = AddItem(lpwstrFrsName, *pguidFrs);
	
		        if (FAILED(nIndex))
		        {
		            return E_UNEXPECTED;
		        }
	
		        //
		        // Add the FRS to the cache.
		        // 
		        m_mapFrsCache[*pguidFrs] = lpwstrFrsName;
			}

			dwPropCount = x_nProps;
			
		}
	}
    return hr;
}

CFrsList& CFrsList::operator = (const CFrsList &frslst)
{
    if (&frslst == this)
    {
        return *this;
    }

    //
    // First, clears the current items in the combo box
    //
    while(CB_ERR != DeleteString(0));
    m_pGuidArray = frslst.m_pGuidArray;
    m_pGuidArray->AddRef();

    for (int i=0; i<frslst.GetCount(); i++)
    {
        CString strCurrentString;
        frslst.GetLBText(i, strCurrentString);
        int iNewIndex = AddString(strCurrentString);
        if (SUCCEEDED(iNewIndex))
        {
            INT_PTR iCurrentIndex = frslst.GetItemData(i);
            SetItemData(iNewIndex, iCurrentIndex);
        }
    }
    return *this;
}

int CFrsList::SelectGuid(GUID &guid, BOOL fLocalMgmt, const CString& strDomainController)
{
    CString strItemToSelect;
    HRESULT hr;

    if (0 == m_mapFrsCache.Lookup(guid, strItemToSelect))
    {
        PROPID pid = PROPID_QM_PATHNAME;
        PROPVARIANT var;

        var.vt = VT_NULL;

        hr = ADGetObjectPropertiesGuid(
                eMACHINE,
                fLocalMgmt ? MachineDomain() : GetDomainController(strDomainController),
				fLocalMgmt ? false : true,	// fServerName
                &guid, 
                1, 
                &pid, 
                &var
                );

        if (SUCCEEDED(hr))
        {
            strItemToSelect = var.pwszVal;
            MQFreeMemory(var.pwszVal);
            m_mapFrsCache[guid] = strItemToSelect;
        }
        else
        {
            return CB_ERR;
        }
    }

    int nIndex = FindStringExact( -1, strItemToSelect);

    if (CB_ERR == nIndex)
    {
        //
        // Add the item to the combo box
        //
        nIndex = AddItem(strItemToSelect, guid);
        if (FAILED(nIndex))
        {
            return CB_ERR;
        }
    }

    VERIFY(CB_ERR != SetCurSel(nIndex));

    return nIndex;
}

int CFrsList::AddItem(LPCWSTR strItem, GUID &guidItem)
{
    int nIndex = AddString(strItem);
    if (FAILED(nIndex))
    {
        return CB_ERR;
    }

    if (0 != m_pGuidArray)
    {
        INT_PTR iGuidIndex = m_pGuidArray->Add(guidItem);

        if (FAILED(SetItemData(nIndex, iGuidIndex)))
        {
            return CB_ERR;
        }
    }
    else
    {
        ASSERT(0);
        return CB_ERR;
    }

    return nIndex;
}

BOOL CFrsList::GetLBGuid(int nIndex, GUID &guid)
{
    INT_PTR iGuidIndex = GetItemData(nIndex);

    if (iGuidIndex < 0)
    {
        return FALSE;
    }

    ASSERT(0 != m_pGuidArray && iGuidIndex <= m_pGuidArray->GetUpperBound());

    guid = (*m_pGuidArray)[iGuidIndex];

    return TRUE;
}

static INT_PTR s_initItemData = -1;

void CFrsList::Initiate()
{
    while(CB_ERR != DeleteString(0))
	{
		NULL;
	}

    CString strNone;
    strNone.LoadString(IDS_COMBO_SELECTION_NONE);

    VERIFY(0 == AddString(strNone));
    SetItemData(0, s_initItemData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\generrpg.cpp ===
// GenErrPg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "mqPPage.h"
#include "dataobj.h"
#include "mqDsPage.h"
#include "GenErrPg.h"

#include "generrpg.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGeneralErrorPage dialog


CGeneralErrorPage::CGeneralErrorPage()
	: CMqPropertyPage(CGeneralErrorPage::IDD)
{
	//{{AFX_DATA_INIT(CGeneralErrorPage)
	m_strError = _T("");
	//}}AFX_DATA_INIT
}

CGeneralErrorPage::CGeneralErrorPage(CString &strError)
	: CMqPropertyPage(CGeneralErrorPage::IDD)
{
    m_strError = strError;
}

void CGeneralErrorPage::DoDataExchange(CDataExchange* pDX)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGeneralErrorPage)
	DDX_Text(pDX, IDC_ERROR_LABEL, m_strError);
	//}}AFX_DATA_MAP
}

HPROPSHEETPAGE CGeneralErrorPage::CreateGeneralErrorPage(
    CDisplaySpecifierNotifier *pDsNotifier, CString &strErr)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    //
    // By using template class CMqDsPropertyPage, we extend the basic functionality
    // of CQueueGeneral and add DS snap-in notification on release
    //
    CMqDsPropertyPage<CGeneralErrorPage> *pcpageErrorGeneral = 
        new CMqDsPropertyPage<CGeneralErrorPage> (pDsNotifier, strErr);

    return pcpageErrorGeneral->CreateThemedPropertySheetPage();
}


BEGIN_MESSAGE_MAP(CGeneralErrorPage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CGeneralErrorPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGeneralErrorPage message handlers

BOOL CGeneralErrorPage::OnInitDialog() 
{

    UpdateData( FALSE );

	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\frslist.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    frslist.h

Abstract:

    FRS list control - definitions.

Author:

    Yoel Arnon (yoela)

--*/
#ifndef _FRSLIST_H_
#define _FRSLIST_H_

class CGuidArray;

class CFrsList : public CComboBox
{
public:
    CFrsList();
    ~CFrsList();
	HRESULT InitFrsList(CACLSID const pguidSiteIds, BOOL fLocalMgmt, const CString& strDomainController);
    CFrsList& operator = (const CFrsList &frslst);
    int SelectGuid(GUID &guid, BOOL fLocalMgmt, const CString& strDomainController);
    int AddItem(LPCWSTR strItem, GUID &guidItem);
    BOOL GetLBGuid(int nIndex, GUID &guid);
    BOOL GetSelectedGuid(GUID &guid);

protected:
    static CMap<GUID, const GUID&, CString, LPCTSTR> m_mapFrsCache;
    CGuidArray *m_pGuidArray;
    void Initiate();
};

inline BOOL CFrsList::GetSelectedGuid(GUID &guid)
{
    int nIndex = GetCurSel();

    if (FAILED(nIndex))
    {
        return FALSE;
    }

    return GetLBGuid(nIndex, guid);
}

//
// Note: CGuidArray can only be allocated on the heap!
//
class CGuidArray : public CArray<GUID, const GUID&>
{
public:
    ULONG AddRef();
    ULONG Release();
    CGuidArray();

private:
    ULONG m_ulRefCount;
    ~CGuidArray();
};

inline CGuidArray::CGuidArray() :
    m_ulRefCount(1)    
{
}

inline CGuidArray::~CGuidArray()
{
    ASSERT(0 == m_ulRefCount);
}

inline ULONG CGuidArray::AddRef()
{
    return (++m_ulRefCount);
}

inline ULONG CGuidArray::Release()
{
    ASSERT(m_ulRefCount > 0);
    m_ulRefCount--;
    if (0 == m_ulRefCount)
    {
        delete this;
        return 0;
    }
    return m_ulRefCount;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\generrpg.h ===
#if !defined(AFX_GENERRPG_H__4D2273BA_12CB_11D3_8841_006094EB6406__INCLUDED_)
#define AFX_GENERRPG_H__4D2273BA_12CB_11D3_8841_006094EB6406__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// GenErrPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CGeneralErrorPage dialog

class CGeneralErrorPage : public CMqPropertyPage
{
// Construction
public:
	CGeneralErrorPage();   // standard constructor
    CGeneralErrorPage(CString &strError);
    static HPROPSHEETPAGE CreateGeneralErrorPage(CDisplaySpecifierNotifier *pDsNotifier, CString &strErr);

// Dialog Data
	//{{AFX_DATA(CGeneralErrorPage)
	enum { IDD = IDD_GENERALERROR };
	CString	m_strError;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGeneralErrorPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGeneralErrorPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GENERRPG_H__4D2273BA_12CB_11D3_8841_006094EB6406__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\infodlg.cpp ===
// InfoDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqPPage.h"
#include "InfoDlg.h"

#include "infodlg.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInfoDlgDialog dialog

CInfoDlgDialog::CInfoDlgDialog(LPCTSTR szInfoText, CWnd* pParent /*=NULL*/)
	: CMqDialog(CInfoDlgDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CInfoDlgDialog)
	m_szInfoText = _T("");
	//}}AFX_DATA_INIT
    m_szInfoText = szInfoText;
	m_pParent = pParent;
	m_nID = CInfoDlgDialog::IDD;
}

BOOL CInfoDlgDialog::Create()
{
    return CDialog::Create(m_nID, m_pParent);
}

CInfoDlgDialog *CInfoDlgDialog::CreateObject(LPCTSTR szInfoText, CWnd* pParent)
{
    CInfoDlgDialog *dlg = new CInfoDlgDialog(szInfoText, pParent);
    if (dlg)
    {
        dlg->Create();
    }

    return dlg;
}

void CInfoDlgDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInfoDlgDialog)
	DDX_Text(pDX, IDC_Moving_Files_LABEL, m_szInfoText);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CInfoDlgDialog, CMqDialog)
	//{{AFX_MSG_MAP(CInfoDlgDialog)   
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CInfoDlgDialog::PostNcDestroy()
{
	CDialog::PostNcDestroy();
	delete this;
}

/////////////////////////////////////////////////////////////////////////////
// CInfoDlg - Wrapper class

CInfoDlg::CInfoDlg(LPCTSTR szInfoText, CWnd* pParent)
{
    m_pinfoDlg = CInfoDlgDialog::CreateObject(szInfoText, pParent);
}

CInfoDlg::~CInfoDlg()
{
    //
    // Note: We do not delete m_pinfoDlg. It deletes itself on PostNcDestroy
    //
    if (m_pinfoDlg)
    {
        m_pinfoDlg->DestroyWindow();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\icons.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	icons.h

Abstract:

	
Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __ICONS_H_
#define __ICONS_H_

enum MQICON {

	IMAGE_DEADLETTER_QUEUE,
	IMAGE_JOURNAL_QUEUE,
	IMAGE_PRIVATE_QUEUE,
	IMAGE_PRIVATE_FOLDER_CLOSE,
	IMAGE_PRIVATE_FOLDER_OPEN,
	IMAGE_SYSTEM_FOLDER_CLOSE,
	IMAGE_SYSTEM_FOLDER_OPEN,
	IMAGE_PUBLIC_FOLDER_NODS_CLOSE,
	IMAGE_PUBLIC_FOLDER_NODS_OPEN,
    IMAGE_QUEUE,
    IMAGE_MESSAGE,
    IMAGE_JOURNAL_MESSAGE,
    IMAGE_REPORT_MESSAGE,
    IMAGE_ACK_MESSAGE,
    IMAGE_NACK_MESSAGE,
    IMAGE_TEST_MESSAGE,
    IMAGE_DEAD_LETTER_MESSAGE,
	IMAGE_PRODUCT_ICON,
	IMAGE_PRODUCT_NOTCONNECTED,
	IMAGE_LOCAL_OUTGOING_QUEUE,
	IMAGE_PUBLIC_QUEUE,
	IMAGE_PRIVATE_QUEUE_HOLD,
	IMAGE_QUEUE_HOLD,
	IMAGE_LOCAL_OUTGOING_QUEUE_HOLD,
	IMAGE_PUBLIC_QUEUE_HOLD,
	IMAGE_ERROR,
	IMAGE_TRIGGERS_GENERAL,
	IMAGE_TRIGGERS_DEFINITION,
	IMAGE_RULES_DEFINITION
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\globals.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

   globals.cpp

Abstract:

   Implementation of various utility routines

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "mqutil.h"
#include "resource.h"
#include "globals.h"
#include "tr.h"
#include "Fn.h"
#include "Ntdsapi.h"
#include "mqcast.h"
#include "localutl.h"
#include "mqppage.h"
#include "infodlg.h"
#include "ldaputl.h"
#include <clusapi.h>
#include <resapi.h>
#include "autorel3.h"

#include "globals.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

int CALLBACK SortByString(LPARAM, LPARAM, LPARAM){ return 1;}
int CALLBACK SortByULONG(LPARAM, LPARAM, LPARAM){return 1;}
int CALLBACK SortByINT(LPARAM, LPARAM, LPARAM){return 1;}
int CALLBACK SortByCreateTime(LPARAM, LPARAM, LPARAM){return 1;}
int CALLBACK SortByModifyTime(LPARAM, LPARAM, LPARAM){return 1;}


//
// Declaration of Propvariant Handlers
//
VTUI1Handler        g_VTUI1;
VTUI2Handler        g_VTUI2;
VTUI4Handler        g_VTUI4;
VTUI8Handler        g_VTUI8;
VTLPWSTRHandler     g_VTLPWSTR;
VTCLSIDHandler      g_VTCLSID;
VTVectUI1Handler    g_VectUI1;
VTVectLPWSTRHandler g_VectLPWSTR;
//
// Global default column width
//
int g_dwGlobalWidth = 150;

//
// Static text
//
CString s_finishTxt;

//
// static functions
//
static BOOL MQErrorToString(CString &str, HRESULT err);

//
// CErrorCapture
//
CString *CErrorCapture::ms_pstrCurrentErrorBuffer = 0;


extern HMODULE	    g_hResourceMod;


LPWSTR newwcs(LPCWSTR p)
{
    if(p == 0)
        return 0;

    LPWSTR dup = new WCHAR[wcslen(p) + 1];
    return wcscpy(dup, p);
}


/*====================================================

EnumToString

Scans a list of EnumItems, and return in <str> the
string corresponding to a value <dwVal>

=====================================================*/
void EnumToString(DWORD dwVal, EnumItem * pEnumList, DWORD dwListSize, CString & str)
{
    DWORD i=0;

    for(i = 0; i < dwListSize; i++)
    {
        if(pEnumList->val == dwVal)
        {
              str.LoadString(pEnumList->StringId);
              return;
        }
        pEnumList++;
    }


    //
    // Value not found
    //
    str.LoadString(IDS_UNKNOWN);
}


/*====================================================

TimeToString

Gets a PROPVARIANT datevalue, and return it as a string

=====================================================*/
void CALLBACK TimeToString(const PROPVARIANT *pPropVar, CString &str)
{
    ASSERT(pPropVar->vt == VT_UI4);

	//
	// If time is not set, do not display it.
	// Converting time that is not set will show dd/mm/1970 date
	//
    if ( pPropVar->ulVal == 0 )
	{
		str = L"";
		return;
	}

	BOOL fShort = 0;
    TCHAR bufDate[128], bufTime[128];
    SYSTEMTIME sysTime;
	DWORD dwDateFormat;
	DWORD dwTimeFormat;
    CTime time(pPropVar->ulVal);

    sysTime.wYear = (WORD)time.GetYear();
    sysTime.wMonth = (WORD)time.GetMonth();
    sysTime.wDayOfWeek = (WORD)time.GetDayOfWeek();
    sysTime.wDay = (WORD)time.GetDay();
    sysTime.wHour = (WORD)time.GetHour();
    sysTime.wMinute = (WORD)time.GetMinute();
    sysTime.wSecond = (WORD)time.GetSecond();
    sysTime.wMilliseconds = 0;

   if(fShort)
   {
      dwDateFormat = DATE_SHORTDATE;
      dwTimeFormat = TIME_NOSECONDS;
   }
   else
   {
      dwDateFormat = DATE_LONGDATE;
      dwTimeFormat = 0;
   }

    GetDateFormat(
        LOCALE_USER_DEFAULT,
        dwDateFormat,   // flags specifying function options
        &sysTime,       // date to be formatted
        0,              // date format string - zero means default for locale
        bufDate,        // buffer for storing formatted string
        TABLE_SIZE(bufDate) // size of buffer
        );

    GetTimeFormat(
        LOCALE_USER_DEFAULT,
        dwTimeFormat,   // flags specifying function options
        &sysTime,       // date to be formatted
        0,              // time format string - zero means default for locale
        bufTime,        // buffer for storing formatted string
        TABLE_SIZE(bufTime) // size of buffer
        );

    str = bufDate;
    str += " ";
    str += bufTime;

}


/*====================================================

BoolToString

Gets a PROPVARIANT boolean, and return a Yes/No string
accordingly

=====================================================*/
void CALLBACK BoolToString(const PROPVARIANT *pPropVar, CString &str)
{
   ASSERT(pPropVar->vt == VT_UI1);


   str.LoadString(pPropVar->bVal ? IDS_YES: IDS_NO);

}

/*====================================================

QuotaToString

Gets a PROPVARIANT qouta, returns a number or "Infinite"

=====================================================*/
void CALLBACK QuotaToString(const PROPVARIANT *pPropVar, CString &str)
{
   ASSERT(pPropVar->vt == VT_UI4);
   if (pPropVar->ulVal == INFINITE)
   {
       str.LoadString(IDS_INFINITE_QUOTA);
   }
   else
   {
       str.Format(TEXT("%d"), pPropVar->ulVal);
   }
}


/*====================================================

ItemDisplay

Gets an ItemDisplay entry, and call the appropriate
display function.
=====================================================*/
void ItemDisplay(const PropertyDisplayItem * pItem,PROPVARIANT * pPropVar, CString & szTmp)
{

    VTHandler * pvth = pItem->pvth;

    if(pItem->pfnDisplay == NULL)
    {
		//
		// Special treatment for VT_NULL
		//
		if(pPropVar->vt == VT_NULL)
		{
			szTmp = L"";
			return;
		}

        //
        // If no function defined, call the Propvariant handler
        //
        pvth->Display(pPropVar, szTmp);
    }
    else
    {
        //
        // Call the function defined
        //
        (pItem->pfnDisplay)(pPropVar, szTmp);
    }

}

/*====================================================

GetPropertyString

Given a property ID, and a array of Property display item,
returns a string of the property value
=====================================================*/
void GetPropertyString(const PropertyDisplayItem * pItem, PROPID pid, PROPVARIANT *pPropVar, CString & strResult)
{
    //
    // Scan the list
    //
    while(pItem->itemPid != 0)
    {
        if(pItem->itemPid == pid)
        {
            //
            // Property ID match, call the display function
            //
            ItemDisplay(pItem, pPropVar, strResult);
            return;
        }

        pItem++;
        pPropVar++;
    }

    ASSERT(0);

    return;


}

/*====================================================

GetProperyVar

Given a property ID, and a array of Property display item,
returns a the variant of the property value
=====================================================*/
void GetPropertyVar(const PropertyDisplayItem * pItem, PROPID pid, PROPVARIANT *pPropVar, PROPVARIANT ** ppResult)
{
    ASSERT(ppResult != NULL);
    ASSERT(pPropVar != NULL);
    //
    // Scan the list
    //
    while(pItem->itemPid != 0)
    {
        if(pItem->itemPid == pid)
        {
            //
            // Property ID match
            //
            *ppResult = pPropVar;
            return;
        }

        pItem++;
        pPropVar++;
    }

    ASSERT(0);
 }


//////////////////////////////////////////////////////////////////////////////
/*++

QueuePathnameToName

	Translates a pathname to a short name (display function for PropertyDisplayItem)

--*/
//////////////////////////////////////////////////////////////////////////////
void CALLBACK QueuePathnameToName(const PROPVARIANT *pPropVar, CString &str)
{
	if(pPropVar->vt != VT_LPWSTR)
	{
		str = L"";
		return;
	}

    ExtractQueueNameFromQueuePathName(str, pPropVar->pwszVal);

	return;
}


/*==============================================================

MessageDSError

  This function displays a DS error:
    Can not <operation> <object>.\n<error description>.
    "Can not %1 %2.\n%3."

Return Value:

================================================================*/
int
MessageDSError(
    HRESULT rc,                     //  Error code
    UINT nIDOperation,              //  Operation string identifier,
                                    //  e.g., get premissions, delete queue, etc.
    LPCTSTR pObjectName /* = 0*/,   //  object that operation performed on
    UINT nType /* = MB_OK | MB_ICONERROR */,
    UINT nIDHelp /* = (UINT) -1*/
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString csErrorText;
    CString csPrompt;

    CString csOperation;
    AfxFormatString1(csOperation, nIDOperation, pObjectName);

    MQErrorToMessageString(csErrorText, rc);
    AfxFormatString2(csPrompt, IDS_DS_ERROR, csOperation, csErrorText);

    return CErrorCapture::DisplayError(csPrompt, nType, nIDHelp);
}


/*=======================================================

MQErrorToString

  Translate an MQError to a string

========================================================*/
BOOL MQErrorToString(CString &str, HRESULT err)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    DWORD rc;
    TCHAR p[512];

    //
    // For MSMQ error code, we will take the message from MQUTIL.DLL based on the full
    // HRESULT. For Win32 error codes, we get the message from the system..
    // For other error codes, we assume they are DS error codes, and get the code
    // from ACTIVEDS dll.
    //

    DWORD dwErrorCode = err;
    HMODULE hLib = 0;
    DWORD dwFlags = FORMAT_MESSAGE_MAX_WIDTH_MASK;

    switch (HRESULT_FACILITY(err))
    {
        case FACILITY_MSMQ:
            dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
            hLib = g_hResourceMod;
            break;

        case FACILITY_NULL:
        case FACILITY_WIN32:
            dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
            dwErrorCode = HRESULT_CODE(err);
            break;

        default:
            dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
            hLib = LoadLibrary(TEXT("ACTIVEDS.DLL"));
            break;
    }

    rc = FormatMessage( dwFlags,
                        hLib,
                        err,
                        0,
                        p,
                        TABLE_SIZE(p),
                        NULL);

    if (0 != hLib && g_hResourceMod != hLib)
    {
        FreeLibrary(hLib);
    }

    if(rc != 0)
    {
        str.FormatMessage(IDS_DISPLAY_ERROR_FORMAT, p);
    }

    return(rc);
}

/*==============================================================

MQErrorToMessageString

    Will set csMessage to an error message, displayable in a message box
================================================================*/
BOOL
MQErrorToMessageString(
    CString &csErrorText,          //  Returned message
    HRESULT rc                     //  Error code
    )
{
    if(!MQErrorToString(csErrorText,rc))
    {
        csErrorText.FormatMessage(IDS_UNKNOWN_ERROR_FORMAT, rc);
        return FALSE;
    }
    return TRUE;
}


/*==============================================================

DisplayErrorAndReason

    Will set strErrorText to an error message, displayable in a message box
================================================================*/
void
DisplayErrorAndReason(
	UINT uiErrorMsgProblem,
    UINT uiErrorMsgReason,
	CString strObject,
	HRESULT errorCode
	)
{
	CString strErrorProblem, strErrorReason;

	if ( strObject == L"" )
	{
		if(uiErrorMsgProblem == IDS_OP_CREATE_COMPUTER || uiErrorMsgProblem == IDS_CREATE_SITE_FAILED)
		{
			strErrorProblem.FormatMessage(uiErrorMsgProblem, L"\" \"");
		}
		else
		{
			strErrorProblem.LoadString(uiErrorMsgProblem);
		}
	}
	else
	{
		strErrorProblem.FormatMessage(uiErrorMsgProblem, strObject);
	}

	strErrorReason.LoadString(uiErrorMsgReason);
	strErrorProblem += (L"\n" + strErrorReason);

	if ( errorCode != 0 )
	{
		CString strErrorCode;
		strErrorCode.FormatMessage(IDS_ERROR_DW_FORMAT, errorCode);
		strErrorProblem += strErrorCode;
	}

	CErrorCapture::DisplayError(strErrorProblem, MB_OK | MB_ICONERROR, static_cast<UINT>(-1));
}


/*==============================================================

DisplayErrorFromCOM

    Will set strErrorText to an error message, displayable in a message box
================================================================*/
void
DisplayErrorFromCOM(
	UINT uiErrorMsg,
	const _com_error& e
	)
{ 

	CString strError;
	_bstr_t Description = e.Description();
	if ((LPCWSTR)Description == NULL)
	{
		strError.FormatMessage(uiErrorMsg, L"");
	} 
	else
	{
		WCHAR strDesc[256];
		wcscpy(strDesc, Description);		
		strError.FormatMessage(uiErrorMsg, strDesc);
	}

	AfxMessageBox(strError, MB_OK | MB_ICONERROR);
}


/*===================================================*
 *
 * DDX functions
 *
 *===================================================*/
//
// DDX function for numbers. When the number is INFINITE, the check box
// is not checked.
// (Good for queue qouta, for example)
//
void AFXAPI DDX_NumberOrInfinite(CDataExchange* pDX, int nIDCEdit, int nIDCCheck, DWORD& dwNumber)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HWND hWndCheck = pDX->PrepareCtrl(nIDCCheck);
    HWND hWndEdit = pDX->PrepareEditCtrl(nIDCEdit);

    if (pDX->m_bSaveAndValidate)
    {
        BOOL_PTR fChecked = SendMessage(hWndCheck, BM_GETCHECK, 0 ,0);
        if (!fChecked)
        {
            dwNumber = INFINITE;
        }
        else
        {
            //
            // Avoid negatives - MFC just translate them to positive
            // 2's complement numbers. We want to avoid this
            //
            int nLen = ::GetWindowTextLength(hWndEdit);
            CString strTemp;

            GetWindowText(hWndEdit, strTemp.GetBufferSetLength(nLen), nLen+1);
            strTemp.ReleaseBuffer();

            if (!(strTemp.SpanExcluding(x_tstrDigitsAndWhiteChars)).IsEmpty())
            {
                AfxMessageBox(AFX_IDP_PARSE_UINT);
                pDX->Fail();
            }

            DDX_Text(pDX, nIDCEdit, dwNumber);
            //
            // If number was out of range, DDX_Text returns Infinite
            //
            if (INFINITE == dwNumber)
            {
	            TCHAR szMax[32];
	            wsprintf(szMax, TEXT("%lu"), INFINITE-1);

	            CString prompt;
	            AfxFormatString2(prompt, AFX_IDP_PARSE_INT_RANGE, TEXT("0"), szMax);
	            AfxMessageBox(prompt, MB_ICONEXCLAMATION, AFX_IDP_PARSE_INT_RANGE);
	            prompt.Empty(); // exception prep
	            pDX->Fail();
            }
        }
    }
    else
    {
        if (INFINITE == dwNumber)
        {
            //
            // Note: The caller must handle BN_CLICKED to re-enable the edit box
            //
            SendMessage(hWndCheck, BM_SETCHECK, FALSE ,0);
            EnableWindow(hWndEdit, FALSE);
        }
        else
        {
            SendMessage(hWndCheck, BM_SETCHECK, TRUE ,0);
            DDX_Text(pDX, nIDCEdit, dwNumber);
        }
    }
}

void OnNumberOrInfiniteCheck(CWnd *pwnd, int idEdit, int idCheck)
{
    CEdit *pEdit = (CEdit*)pwnd->GetDlgItem(idEdit);
    CButton *pCheck = (CButton*)pwnd->GetDlgItem(idCheck);
    BOOL fChecked = pCheck->GetCheck();

    pEdit->EnableWindow(fChecked);
}


//------------- DDX_TEXT (for GUID) ---------------------------
// This function compliment the standard DDX_ function set, and
// used to exchange a a GUID property with an edit box
// in DoDataExchange.

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, GUID& guid)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);

    if (pDX->m_bSaveAndValidate)
    {
        int nLen = ::GetWindowTextLength(hWndCtrl);
        CString strTemp;

        ::GetWindowText(hWndCtrl, strTemp.GetBufferSetLength(nLen), nLen+1);
        strTemp.ReleaseBuffer();

        if (IIDFromString((LPTSTR)((LPCTSTR)strTemp), &guid))   // throws exception
        {
            //
            // Can't convert string to guid
            //
            CString strMessage;
            strMessage.LoadString(IDE_INVALIDGUID);

            AfxMessageBox(strMessage);
            pDX->Fail();    // throws exception
        }
    }
    else
    {
        TCHAR szTemp[x_dwMaxGuidLength];
        StringFromGUID2(guid, szTemp, TABLE_SIZE(szTemp));
        ::SetWindowText(hWndCtrl, szTemp);
    }
}


/*====================================================
MqsnapCreateQueue
Creates a queue given a set of parameters and a list of properties IDs. The list must
contain some or all of PROPID_Q_PATHNAME, PROPID_Q_LABEL, PROPID_Q_TRANSACTION and
PROPID_Q_TYPE. Parameters that do not have a corresponding property ID in the list are
ignored.

Arguments:

Return Value:

=====================================================*/
HRESULT MqsnapCreateQueue(CString& strPathName, BOOL fTransactional,
                       CString& strLabel, GUID* pTypeGuid,
                       PROPID aProp[], UINT cProp,
                       CString *pStrFormatName /* = 0 */)
{
#define MAX_EXPCQ_PROPS 10

    ASSERT(cProp <= MAX_EXPCQ_PROPS);

    PROPVARIANT apVar[MAX_EXPCQ_PROPS];
    HRESULT hr = MQ_OK, hr1 = MQ_OK;
    UINT iProp;

    for (iProp = 0; iProp<cProp; iProp++)
    {
        switch (aProp[iProp])
        {
            case PROPID_Q_PATHNAME:
                apVar[iProp].vt = VT_LPWSTR;

                apVar[iProp].pwszVal = (LPTSTR)(LPCTSTR)(strPathName);
                break;

            case PROPID_Q_LABEL:
                apVar[iProp].vt = VT_LPWSTR;
                apVar[iProp].pwszVal = (LPTSTR)(LPCTSTR)(strLabel);
                break;

            case PROPID_Q_TYPE:
                apVar[iProp].vt = VT_CLSID;
                apVar[iProp].puuid = pTypeGuid;
                break;

            case PROPID_Q_TRANSACTION:
                apVar[iProp].vt = VT_UI1;
                apVar[iProp].bVal = (UCHAR)fTransactional;
                break;

            default:
                ASSERT(0);
                break;
        }

    }

    MQQUEUEPROPS mqp = {cProp, aProp, apVar, 0};

    DWORD dwFormatLen;
    if (0 != pStrFormatName)
    {
        dwFormatLen = MAX_QUEUE_FORMATNAME;
        hr = MQCreateQueue(0, &mqp, pStrFormatName->GetBuffer(MAX_QUEUE_FORMATNAME), &dwFormatLen);
        pStrFormatName->ReleaseBuffer();
    }
    else
    {
        dwFormatLen=0;
        if ((hr1 = MQCreateQueue(0, &mqp, 0, &dwFormatLen)) != MQ_INFORMATION_FORMATNAME_BUFFER_TOO_SMALL)
           hr = hr1;
    }

    return hr;
}

/*====================================================
CreateEmptyQueue


Arguments:

Return Value:

=====================================================*/
HRESULT CreateEmptyQueue(CString &csDSName,
                         BOOL fTransactional, CString &csMachineName, CString &csPathName,
                         CString *pStrFormatName /* = 0 */)
{
    PROPID  aProp[] = {PROPID_Q_PATHNAME,
                       PROPID_Q_LABEL,
                       PROPID_Q_TRANSACTION
                       };

    csPathName.Format(TEXT("%s\\%s"), csMachineName, csDSName);

    HRESULT hr =  MqsnapCreateQueue(csPathName, fTransactional, csDSName, 0,
                                    aProp, sizeof(aProp) / sizeof(aProp[0]), pStrFormatName);
    if (hr != MQ_ERROR_INVALID_OWNER)
    {
        //
        // Either success or real error. Return.
        //
        return hr;
    }

    CString csNetBiosName;
    if (!GetNetbiosName(csMachineName, csNetBiosName))
    {
        //
        // Already a netbios name. No need to proceed
        //
        return hr;
    }

    //
    // This may be an NT4 server, and we may be using a full DNS name. Try again with
    // Netbios name  (fix for 5076, YoelA, 16-Sep-99)
    //
    csPathName.Format(TEXT("%s\\%s"), csNetBiosName, csDSName);

    return MqsnapCreateQueue(csPathName, fTransactional, csDSName, 0,
                             aProp, sizeof(aProp) / sizeof(aProp[0]), pStrFormatName);
}

/*====================================================
CreateTypedQueue
  ( for report and test queues )

Arguments:

Return Value:

=====================================================*/

HRESULT CreateTypedQueue(CString& strPathname, CString& strLabel, GUID& TypeGuid)
{
    PROPID  aProp[] = {PROPID_Q_PATHNAME,
                       PROPID_Q_LABEL,
                       PROPID_Q_TYPE,
                       };

    return MqsnapCreateQueue(strPathname, FALSE, strLabel, &TypeGuid,
                          aProp, sizeof(aProp) / sizeof(aProp[0]));
}


/*==============================================================

CaubToString

  This function converts a CAUI1 buffer to a string displayable in the
  right hand side of an hex editor (every byte is a character, control characters
  are replaced by '.')
Arguments:

Return Value:

================================================================*/
void CaubToString(const CAUB* pcaub, CString& strResult)
{
    LPTSTR pstr = strResult.GetBuffer(pcaub->cElems);
    for (DWORD i=0; i<pcaub->cElems; i++)
    {
        //
        // Replace control characters with "."
        //
        if (pcaub->pElems[i]>=32)
        {
            pstr[i] = pcaub->pElems[i];
        }
        else
        {
            pstr[i] = L'.';
        }
    }
    strResult.ReleaseBuffer();
}

/*==============================================================

MoveSelected

  This function moves all the selected items from one list box to another.
  (Usefull for implementation of Add/Remove buttons)

Arguments:
  plbSource - pointer to source list box from which the selected item
              should be moved to the destination list box

  plbDest - pointer to the destination list box

Return Value:

================================================================*/
void
MoveSelected(
    CListBox* plbSource,
    CListBox* plbDest
    )
{
    try
    {
        int nTotalItems = plbSource->GetCount();
        AP<int> piRgIndex = new int[nTotalItems];
        int nSel =  plbSource->GetSelItems(nTotalItems, piRgIndex );
        int i;

        for (i=0; i<nSel; i++)
        {
            CString strItem;
            plbSource->GetText(piRgIndex[i], strItem);

            DWORD_PTR dwItemData = plbSource->GetItemData(piRgIndex[i]);

            int iDestIndex = plbDest->AddString(strItem);
            plbDest->SetItemData(iDestIndex, dwItemData);
        }

        for (i=0; i<nSel; i++)
        {
            plbSource->DeleteString(piRgIndex[i]-i);
        }
    }
    catch (CException* pException)
    {
        TrERROR(GENERAL, "Exception  2 in MoveSelected");
        pException->ReportError();
        pException->Delete();
    }
}

//
// Helper routine for handling LPWSTR map
//
template<>
BOOL
AFXAPI
CompareElements(
    const LPCWSTR* MapName1,
    const LPCWSTR* MapName2
    )
{
    return (wcscmp(*MapName1, *MapName2) == 0);
}


template<>
UINT
AFXAPI
HashKey(
    LPCWSTR key
    )
{
    UINT nHash = 0;
    while (*key)
    {
        nHash = (nHash<<5) + nHash + *key++;
    }

    return nHash;
}


/*==============================================================
DDV_NotEmpty

    The routine checks that the input is not empty

Arguments:
    pDX - pointer to Data exchange
    str - pointer to the selected string
    uiErrorMessage - Error message if the validation fails

Returned Value:
    None.

================================================================*/
void DDV_NotEmpty(
    CDataExchange* pDX,
    CString& str,
    UINT uiErrorMessage
    )
{
    if (pDX->m_bSaveAndValidate)
    {
        if (str.IsEmpty())
        {
            AfxMessageBox(uiErrorMessage);
            pDX->Fail();
        }
    }
}

//
// String comparison function for sorting queue nqmes
//
int __cdecl QSortCompareQueues( const void *arg1, const void *arg2 )
{
   /* Compare all of both strings: */
   return _wcsicmp( * (WCHAR ** ) arg1, * (WCHAR ** ) arg2 );
}


template<>
void AFXAPI DestructElements(PROPVARIANT *pElements, INT_PTR nCount)
{
    DWORD i,j;
    for (i=0; i<(DWORD)nCount; i++)
    {
        switch(pElements[i].vt)
        {
            case VT_CLSID:
                MQFreeMemory(pElements[i].puuid);
                break;

            case VT_LPWSTR:
                MQFreeMemory(pElements[i].pwszVal);
                break;

            case VT_BLOB:
                MQFreeMemory(pElements[i].blob.pBlobData);
                break;

            case (VT_VECTOR | VT_CLSID):
                MQFreeMemory(pElements[i].cauuid.pElems);
                break;

            case (VT_VECTOR | VT_LPWSTR):
                for(j = 0; j < pElements[i].calpwstr.cElems; j++)
                {
                    MQFreeMemory(pElements[i].calpwstr.pElems[j]);
                }
                MQFreeMemory(pElements[i].calpwstr.pElems);
                break;

            case (VT_VECTOR | VT_VARIANT):
                DestructElements((PROPVARIANT*)pElements[i].capropvar.pElems, pElements[i].capropvar.cElems);
                MQFreeMemory(pElements[i].calpwstr.pElems);
                break;
            default:
                break;
        }

        pElements[i].vt = VT_EMPTY;
    }
}

//
// CompareVariants - compare two variants
//
#define _COMPAREVARFIELD(field) (propvar1->field == propvar2->field ?  0 : \
                                    propvar1->field > propvar2->field ? 1 : -1)

int CompareVariants(PROPVARIANT *propvar1, PROPVARIANT *propvar2)
{
    if (propvar1->vt != propvar2->vt)
    {
        //
        // Can't compare. Consider them equal
        //
        return 0;
    }

    char *pChar1, *pChar2;
    size_t nChar1, nChar2;
    switch (propvar1->vt)
    {
        case VT_UI1:
            return _COMPAREVARFIELD(bVal);

        case VT_UI2:
        case VT_I2:
            return _COMPAREVARFIELD(iVal);

        case VT_UI4:
        case VT_I4:
            return _COMPAREVARFIELD(lVal);

        case VT_UI8:
            return _COMPAREVARFIELD(uhVal.QuadPart);

        case VT_CLSID:
        {
            for (int i = 0; i < sizeof(GUID); i++)
            {
                if (((BYTE*)propvar1->puuid)[i] > ((BYTE*)propvar2->puuid)[i])
                {
                    return 1;
                }
                else if (((BYTE*)propvar1->puuid)[i] < ((BYTE*)propvar2->puuid)[i])
                {
                    return -1;
                }
            }

            return 0;
        }

        case VT_LPWSTR:
        {
            int nCompResult = CompareString(0,0, propvar1->pwszVal, -1, propvar2->pwszVal, -1);
            switch(nCompResult)
            {
                case CSTR_LESS_THAN:
                    return -1;

                case CSTR_EQUAL:
                    return 0;

                case CSTR_GREATER_THAN:
                    return 1;
            }
        }

        case VT_BLOB:
            pChar1 = (char *)propvar1->blob.pBlobData;
            pChar2 = (char *)propvar2->blob.pBlobData;
            nChar1 = propvar1->blob.cbSize;
            nChar2 = propvar2->blob.cbSize;
            //
            // Fall through
            //
        case (VT_VECTOR | VT_UI1):
            if (propvar1->vt == (VT_VECTOR | VT_UI1)) // not fallen through
            {
                pChar1 = (char *)propvar1->caub.pElems;
                pChar2 = (char *)propvar2->caub.pElems;
                nChar1 = propvar1->caub.cElems;
                nChar2 = propvar2->caub.cElems;
            }
            {
                int iResult = memcmp(pChar1, pChar2, min (nChar1, nChar2));
                if (iResult == 0)
                {
                    if (nChar1 > nChar2)
                    {
                        return 1;
                    }
                    else if (nChar2 > nChar1)
                    {
                        return -1;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return iResult;
                }
            }

        case (VT_VECTOR | VT_CLSID):
        case (VT_VECTOR | VT_LPWSTR):
        case (VT_VECTOR | VT_VARIANT):
        default:
            //
            // can't compare these types - consider them equal
            //
            return 0;
    }
}
#undef _COMPAREVARFIELD

/*==============================================================
InsertColumnsFromDisplayList

This routine inserts columns into header using a display list.
It should be called from InsertColumns functions of classes derived from
CSnapinNode.
================================================================*/

HRESULT   InsertColumnsFromDisplayList(IHeaderCtrl* pHeaderCtrl,
                                       const PropertyDisplayItem *aDisplayList)
{
    DWORD i = 0;
    DWORD dwColId = 0;
    while(aDisplayList[i].itemPid != 0)
    {
        if (aDisplayList[i].uiStringID != NO_TITLE)
        {
            CString title;
            title.LoadString(aDisplayList[i].uiStringID);

            pHeaderCtrl->InsertColumn(dwColId, title, LVCFMT_LEFT,aDisplayList[i].iWidth);
            dwColId++;
        }
        i++;
    }

    return(S_OK);
}


//
// GetDsServer - returns the current DS Server
//
HRESULT GetDsServer(CString &strDsServer)
{
    MQMGMTPROPS	  mqProps;
    PROPID  propIdDsServ = PROPID_MGMT_MSMQ_DSSERVER;
    PROPVARIANT propVarDsServ;
    propVarDsServ.vt = VT_NULL;

	mqProps.cProp = 1;
	mqProps.aPropID = &propIdDsServ;
	mqProps.aPropVar = &propVarDsServ;
	mqProps.aStatus = NULL;

    HRESULT hr = MQMgmtGetInfo(0, MO_MACHINE_TOKEN, &mqProps);

    if(FAILED(hr))
    {
       return(hr);
    }

	ASSERT(propVarDsServ.vt == (VT_LPWSTR));

    strDsServer = propVarDsServ.pwszVal;
    MQFreeMemory(propVarDsServ.pwszVal);

    return S_OK;
}

//
// GetComputerNameIntoString - Puts the local computer name in a string
//
HRESULT GetComputerNameIntoString(CString &strComputerName)
{
    const DWORD x_dwComputerNameLen = 256;
    DWORD dwComputerNameLen = x_dwComputerNameLen;

    HRESULT hr = GetComputerNameInternal(strComputerName.GetBuffer(dwComputerNameLen), &dwComputerNameLen);
    strComputerName.ReleaseBuffer();

    return hr;
}

//
// GetSiteForeignFlag - retrieves a site's foreign flag from the DS
//
HRESULT
GetSiteForeignFlag(
    const GUID* pSiteId,
    BOOL *fForeign,
	BOOL fLocalMgmt,
	const CString& strDomainController
    )
{
    //
    // By default (and in case of error) return FALSE
    //
    *fForeign = FALSE;
    //
    // Get the site foreign flag
    //
    PROPID pid = PROPID_S_FOREIGN;
    PROPVARIANT var;
    var.vt = VT_NULL;
   
    HRESULT hr = ADGetObjectPropertiesGuid(
                    eSITE,
                    fLocalMgmt ? MachineDomain() : GetDomainController(strDomainController),
					fLocalMgmt ? false : true,	// fServerName
                    pSiteId,
                    1,
                    &pid,
                    &var
                    );
    if (FAILED(hr))
    {
        if (MQ_ERROR == hr)
        {
            //
            // In this case, we assume we are working against NT4 server.
            // There are no foreign sites in NT4, so we return FALSE in fForeign
            //
            return MQ_OK;
        }
        //
        // Another error - report error and return it.
        //
        CString strSite;
        strSite.LoadString(IDS_SITE);
        MessageDSError(hr, IDS_OP_GET_PROPERTIES_OF, strSite);
        return hr;
    }

    *fForeign = var.bVal;
    return MQ_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++
GetNetbiosName
This function gets a full DNS name and returns the Netbios name
return value - TRUE if Netbios name different than Full Dns Name
--*/
//////////////////////////////////////////////////////////////////////////////
BOOL GetNetbiosName(CString &strFullDnsName, CString &strNetbiosName)
{
    DWORD dwFirstDot = strFullDnsName.Find(L".");
    if (dwFirstDot == -1)
    {
        //
        // It is already a netbios name. Return it
        //
        strNetbiosName = strFullDnsName;
        return FALSE;
    }

    strNetbiosName = strFullDnsName.Left(dwFirstDot);
    return TRUE;
}

//
//  Temporary - until logging mechanism is decided
//  currently doesn't perform logging
//
void LogMsgHR(HRESULT /*hr*/, LPWSTR /*wszFileName*/, USHORT /*usPoint*/)
{
}

//
// Nedded for linking with fn.lib
//
WCHAR g_MachineName[MAX_COMPUTERNAME_LENGTH+1] = L"";
DWORD g_MachineNameLength = MAX_COMPUTERNAME_LENGTH+1;
static bool s_fMachineName = false;

LPCWSTR
McComputerName(
	void
	)
{
	if (s_fMachineName)
	{
		return g_MachineName;
	}

    HRESULT hr = GetComputerNameInternal( 
                     g_MachineName,
                     &g_MachineNameLength
                     );
    if(FAILED(hr))
    {
		TrERROR(GENERAL, "Failed to get computer name. Error: %!hresult!", hr);
		throw bad_hresult(hr);
    }
    
    s_fMachineName = true;
    return g_MachineName; 
}

//
// Nedded for linking with fn.lib
//
DWORD
McComputerNameLen(
	void
	)
{
	if (s_fMachineName)
	{
		return g_MachineNameLength;
	}
	
	McComputerName();
	ASSERT(s_fMachineName);
	
	return g_MachineNameLength;
}


void
DDV_ValidFormatName(
	CDataExchange* pDX,
	CString& str
	)
{
	if (!pDX->m_bSaveAndValidate)
		return;

	QUEUE_FORMAT qf;
	AP<WCHAR> strToFree;
	BOOL fRes = FnFormatNameToQueueFormat(str, &qf, &strToFree);

	if ( !fRes ||
		qf.GetType() == QUEUE_FORMAT_TYPE_DL ||
		qf.GetType() == QUEUE_FORMAT_TYPE_MULTICAST )
	{
        CString strNewAlias;
        strNewAlias.LoadString(IDS_ALIAS);

        MessageDSError(MQ_ERROR_ILLEGAL_FORMATNAME, IDS_OP_SET_FORMATNAME_PROPERTY, strNewAlias);
        pDX->Fail();
	}
}


void
SetScrollSizeForList(
	CListBox* pListBox
	)
{
	int dx=0;

	//
	// Find maximal string among all strings in the ListBox
	//
	CDC* pDC = pListBox->GetDC();
	
	for (int i = 0; i < pListBox->GetCount(); i++)
	{
		CString strItem;
		CSize sizeOfStr;

		pListBox->GetText( i, strItem );
		sizeOfStr = pDC->GetTextExtent(strItem);

		dx = max(dx, sizeOfStr.cx);
	}

	pListBox->ReleaseDC(pDC);

	pListBox->SetHorizontalExtent(dx);
}


BOOL
TryStopMSMQServiceIfStarted(BOOL* pfServiceWasRunning, CWnd* pWnd)
{
    BOOL fServiceIsRunning;
    if (!GetServiceRunningState(&fServiceIsRunning))
    {
        //
        // Failed to get service status - do not do anything
		// GetServiceRunningState() displays error in this case
        //
        return FALSE;        
    }


    //
    // The service is running, ask the user whether it wants to stop it.
    // If the service is not stopped, we do not move the files and do not
    // update the registry.
    //
    if (fServiceIsRunning)
    {
		CString strMessage;
        strMessage.LoadString(IDS_Q_STOP_SRVICE);           
        
		if (AfxMessageBox(strMessage, 
						MB_YESNO | MB_ICONQUESTION) == IDNO)
        {
            //
            // So, the user doesn't want to stop the service, be it.
            //
            return FALSE;            
        }

        //
        // Stop the service.
        //
        CString strStopService;

        strStopService.LoadString(IDS_STOP_SERVICE);
        CInfoDlg StopServiceDlg(strStopService, pWnd);

        if (!StopService())
        {
            //
            // Failed to stop the service.
            //
            return FALSE;            
        }
    }

	*pfServiceWasRunning = fServiceIsRunning;

	return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
/*++

FreeMqProps

  Free all properties allocated by MSMQ

--*/
//////////////////////////////////////////////////////////////////////////////
void FreeMqProps(MQMGMTPROPS * mqProps)
{
	//
	// Free all the properties allocated by MSMQ
	//
	for(DWORD i = 0; i < mqProps->cProp; i++)
	{
		switch(mqProps->aPropVar[i].vt)
		{
		case VT_NULL:
		case VT_UI4:
		case VT_I4:
        case VT_UI1:
        case VT_I2:
			break;

		case VT_LPWSTR:
			MQFreeMemory(mqProps->aPropVar[i].pwszVal);
			break;

		case VT_CLSID:
			MQFreeMemory(mqProps->aPropVar[i].puuid);
			break;

		case VT_BLOB:
			MQFreeMemory(mqProps->aPropVar[i].blob.pBlobData);
			break;

		case (VT_VECTOR | VT_LPWSTR):
			{
				for(DWORD j = 0; j < mqProps->aPropVar[i].calpwstr.cElems; j++)
					MQFreeMemory(mqProps->aPropVar[i].calpwstr.pElems[j]);

				MQFreeMemory(mqProps->aPropVar[i].calpwstr.pElems);

				break;
			}

		default:

			ASSERT(0);
		}
	}

	//
	// Remove other allocations
	//
	delete [] mqProps->aStatus;
	delete [] mqProps->aPropID;
	delete [] mqProps->aPropVar;

	//
	// To be on the safe side...
	// 
	mqProps->cProp = 0;
	mqProps->aPropID = NULL;
	mqProps->aPropVar = NULL;
	mqProps->aStatus = NULL;


}


//////////////////////////////////////////////////////////////////////////////
/*++

GetStringPropertyValue

  Return the string value of a pid

--*/
//////////////////////////////////////////////////////////////////////////////
void GetStringPropertyValue(const PropertyDisplayItem * pItem, PROPID pid, PROPVARIANT *pPropVar, CString &str)
{
	if (pItem->itemPid == 0)
	{
		ASSERT(0);
		str = L"";
		return;
	}
	
	PROPVARIANT * pProp;
	GetPropertyVar(pItem, pid, pPropVar, &pProp);

	if(pProp->vt == VT_NULL)
	{
		str = L"";
		return;
	}

	ASSERT(pProp->vt == VT_LPWSTR);
	str = pProp->pwszVal;
 }


BOOL IsClusterVirtualServer(LPCWSTR wcsMachineName)
{
	if (!IsLocalSystemCluster())
	{
		TrTRACE(GENERAL, "%ls is not a cluster machine.", wcsMachineName);
		return FALSE;
	}

	CAutoCluster hCluster( OpenCluster(NULL) );

	if ( hCluster == NULL )
	{
		TrERROR(GENERAL, "Failed to get handle to Cluster that %ls is part of", wcsMachineName);
		return FALSE;
	}

	CClusterNode hNode( OpenClusterNode(hCluster, wcsMachineName) );

	if ( hNode != NULL )
	{
		TrTRACE(GENERAL, "%ls is a cluster physical node.", wcsMachineName);
		return FALSE;
	}

	TrTRACE(GENERAL, "%ls is a cluster virtual server.", wcsMachineName);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\globals.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

   globals.h

Abstract:

   Definition and partial implementation of various
    utility functions.

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////

#ifndef __GLOBALS_H__
#define __GLOBALS_H__

#include "snapres.h"
#include "atlsnap.h"
#include "_guid.h"
#include "machdomain.h"
#include "mqaddef.h"

#define MAX_GUID_LENGTH 40
#define MAX_QUEUE_FORMATNAME 300

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif


#define DS_ERROR_MASK 0x0000ffff
//
// Clipboard Formats
//
//
// Clipboard Formats
//
const CLIPFORMAT gx_CCF_FORMATNAME = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_QUEUE_FORMAT_NAME"));
const CLIPFORMAT gx_CCF_PATHNAME = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_MESSAGE_QUEUING_PATH_NAME"));  
const CLIPFORMAT gx_CCF_COMPUTERNAME = (CLIPFORMAT) RegisterClipboardFormat(_T("MMC_SNAPIN_MACHINE_NAME"));

//
// A special flag, move to UpdateAllView to delete all the data in result pane
//
const int UPDATE_REMOVE_ALL_RESULT_NODES = -1;

LPWSTR newwcs(LPCWSTR p);

//
// for AD API: get domain controller name
//
inline LPCWSTR GetDomainController(LPCWSTR pDomainController)
{
	if((pDomainController == NULL) || (wcscmp(pDomainController, L"") == 0))
	{
		//
		// For empty string or NULL pointer, return NULL
		//
		return NULL;
	}

    return pDomainController;
}


/*-----------------------------------------------------------------------------
/ String helper macros
/----------------------------------------------------------------------------*/
#define StringByteCopy(pDest, iOffset, sz)          \
        { memcpy(&(((LPBYTE)pDest)[iOffset]), sz, StringByteSize(sz)); }

#define StringByteSize(sz)                          \
        ((lstrlen(sz)+1)*sizeof(TCHAR))

/*-----------------------------------------------------------------------------
/ Other Macros
/----------------------------------------------------------------------------*/
//
// This macro is used after a DS call returns with error. It handle all the
// cases of "object no found" error. The most common cause of this kind of error
// is replication delays (sometimes the DS snap-in domain controller is not the
// same as the MSMQ domain controller) - Yoela, 29-June-98
//
// This macro was updated to display the replication delay popup, only in case AD
// is accessed through MQDSCli. When AD is accessed directly this popup
// is not relevant.
//
#define IF_NOTFOUND_REPORT_ERROR(rc) \
        if ((rc == MQDS_OBJECT_NOT_FOUND \
            || rc == MQ_ERROR_QUEUE_NOT_FOUND \
            || rc == MQ_ERROR_MACHINE_NOT_FOUND) && \
            (  ADProviderType() == eMqdscli)) \
        { \
            AFX_MANAGE_STATE(AfxGetStaticModuleState()); \
            AfxMessageBox(IDS_REPLICATION_PROBLEMS); \
        }


//
// EnumEntry
//
// Used to map a #define value to a resource string
//
//
#define ENUM_ENTRY(x) {x, IDS_ ## x}
struct EnumItem
{
    DWORD val;          //value
    DWORD StringId;     //Resource Id
};

// Scan a list of EnumEntry, and returns the string matching the specific value
void EnumToString(DWORD dwVal, EnumItem * pEnumList, DWORD dwListSize, CString & str);



int CALLBACK SortByString(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
int CALLBACK SortByULONG(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
int CALLBACK SortByINT(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
int CALLBACK SortByCreateTime(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
int CALLBACK SortByModifyTime(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
int __cdecl QSortCompareQueues( const void *arg1, const void *arg2 );

HRESULT 
CreateMachineSecurityPage(
	HPROPSHEETPAGE *phPage, 
	IN LPCWSTR lpwcsMachineName, 
	IN LPCWSTR lpwcsDomainController, 
	IN bool fServerName
	);

//
// Utilities to convert useful propvariant types to string
//
void CALLBACK TimeToString(const PROPVARIANT *pPropVar, CString &str);
void CALLBACK BoolToString(const PROPVARIANT *pPropVar, CString &str);
void CALLBACK QuotaToString(const PROPVARIANT *pPropVar, CString &str);


int
MessageDSError(                         //  Error box: "Can not <op> <obj>.\n<rc>."
    HRESULT rc,                         //  DS Error code
    UINT nIDOperation,                  //  Operation string identifier,
                                        //  e.g., get premissions, delete, etc.
    LPCTSTR pObjectName = 0,            //  object that operation performed on
    UINT nType = MB_OK | MB_ICONERROR,  //  buttons & icon
    UINT nIDHelp = (UINT) -1            //  help context
    );

HRESULT MqsnapCreateQueue(CString& strPathName, BOOL fTransactional,
                       CString& strLabel, GUID* pTypeGuid,
                       PROPID aProp[], UINT cProp,
                       CString *pStrFormatName = 0);

HRESULT CreateEmptyQueue(CString &csDSName,
                         BOOL fTransactional, CString &csMachineName, 
                         CString &csPathName, CString *pStrFormatName = 0);

HRESULT CreateTypedQueue(CString& strPathname, CString& strLabel, GUID& TypeGuid);

BOOL MQErrorToMessageString(CString &csErrorText, HRESULT rc);
void DisplayErrorAndReason(UINT uiErrorMsgProblem, UINT uiErrorMsgReason, CString strObject, HRESULT errorCode);
void DisplayErrorFromCOM(UINT uiErrorMsg, const _com_error& e);


HRESULT GetDsServer(CString &strDsServer);
HRESULT GetComputerNameIntoString(CString &strComputerName);
HRESULT GetSiteForeignFlag(const GUID* pSiteId, BOOL *fForeign, BOOL fLocalMgmt, const CString& strDomainController);
BOOL GetNetbiosName(CString &strFullDnsName, CString &strNetbiosName);

//
// DDX functions
//
void AFXAPI DDX_NumberOrInfinite(CDataExchange* pDX, int nIDCEdit, int nIDCCheck, DWORD& dwNumber);
void OnNumberOrInfiniteCheck(CWnd *pwnd, int idEdit, int idCheck);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, GUID& guid);


typedef void (CALLBACK *PFNDISPLAY)(const PROPVARIANT *pPropVar, CString &str);

#define NO_COLUMN   (DWORD)-1
#define HIDE        (DWORD)-2         // Dont display on the right pane
#define NO_INDEX    (DWORD)-1
#define NO_TITLE    (DWORD)-1
#define NO_PROPERTY (PROPID)-1

class VTHandler;
struct PropertyDisplayItem
{
    UINT        uiStringID;         // Description string
    PROPID         itemPid;         // Id
    VTHandler       *pvth;          // Handler object for the VT type
    PFNDISPLAY      pfnDisplay;     // Special display function. NULL means to call the VT display func.
    DWORD           offset;         // For variable len property, offset in struct
    DWORD           size;           // For variable len property - size, For fix size, default value
    INT            iWidth;          // Original column width
    PFNLVCOMPARE   CompareFunc;     // Compare function
};
//
// Display functions for PropertyDisplayItem
//
void CALLBACK QueuePathnameToName(const PROPVARIANT *pPropVar, CString &str);


void GetPropertyString(const PropertyDisplayItem * pItem, PROPID pid, PROPVARIANT *pPropVar, CString & strResult);
void GetPropertyVar(const PropertyDisplayItem * pItem, PROPID pid, PROPVARIANT *pPropVar, PROPVARIANT ** ppResult);
void ItemDisplay(const PropertyDisplayItem * pItem,PROPVARIANT * pPropVar, CString & szTmp);
HRESULT InsertColumnsFromDisplayList(IHeaderCtrl* pHeaderCtrl, const PropertyDisplayItem *aDisplayList);

//----------------------------------------
//
//  Global default width
//
//----------------------------------------
extern int g_dwGlobalWidth;

//----------------------------------------
//
// PROPVARIANT utility functions
//
//----------------------------------------

#define NO_OFFSET       (DWORD) 0xFFFFFFFF

//
// CLASS: VTHandler
// Base class.
// Pure class definiting the interface on a Propavariant class. Every implementation
// of a propvariant class must inherit this one.
//
//
class VTHandler
{
public:
    // Stringize a propvariant value
    virtual void Display(const PROPVARIANT *pPropVar, CString & str) =0;
    // Set a propvariant to a specfic value, at a specifc address (base + offset) for
    // variable length variant
    virtual void Set(PROPVARIANT *pPropVar, VOID * pBase, DWORD offset, DWORD size) =0;

    //
    // Clear the variant
    //
    virtual void Clear(PROPVARIANT * /*pPropVar*/)
    {
        //
        // Do nothing by default
        //
    }

};

class VTNumericHandler : public VTHandler
{
public:
    virtual void Clear(PROPVARIANT *pPropVar)
    {
        Set(pPropVar, 0, NO_OFFSET, 0);
    }
};

class VTUI1Handler : public VTNumericHandler
{
public:

    void Display(const PROPVARIANT *pPropVar, CString & str)
    {
        WCHAR szTmp[50];

        _itow(pPropVar->bVal,szTmp,10);
        str = szTmp;
    }

    void Set(PROPVARIANT *pPropVar, VOID * /*pBase*/, DWORD offset, DWORD val)
    {
        ASSERT(offset == NO_OFFSET);
        UNREFERENCED_PARAMETER(offset);
        pPropVar->vt = VT_UI1;
        pPropVar->bVal = static_cast<UCHAR>(val);
    }
};

class VTUI2Handler : public VTNumericHandler
{
public:

    void Display(const PROPVARIANT *pPropVar, CString & str)
    {
        WCHAR szTmp[50];

        _itow(pPropVar->uiVal,szTmp,10);
        str = szTmp;

    }

    void Set(PROPVARIANT *pPropVar, VOID * /*pBase*/, DWORD offset, DWORD val)
    {
        ASSERT(offset == NO_OFFSET);
        UNREFERENCED_PARAMETER(offset);
        pPropVar->vt = VT_UI2;
        pPropVar->uiVal = static_cast<USHORT>(val);
    }
};

class VTUI4Handler : public VTNumericHandler
{
public:

    void Display(const PROPVARIANT *pPropVar, CString & str)
    {
        WCHAR szTmp[50];

        _itow(pPropVar->ulVal,szTmp,10);
        str = szTmp;

    }

    void Set(PROPVARIANT *pPropVar, VOID * /*pBase*/, DWORD offset, DWORD val)
    {
        ASSERT(offset == NO_OFFSET);
        UNREFERENCED_PARAMETER(offset);
        pPropVar->vt = VT_UI4;
        pPropVar->ulVal = val;
    }
};


class VTUI8Handler : public VTNumericHandler
{
public:

    void Display(const PROPVARIANT *pPropVar, CString & str)
    {
		if (pPropVar->uhVal.QuadPart == 0)
		{
			str = L"";
			return;
		}

        WCHAR szTmp[100];
        _ui64tow((pPropVar->uhVal).QuadPart, szTmp, 10);
        str = szTmp;
    }

    void Set(PROPVARIANT *pPropVar, VOID* /*pBase*/, DWORD offset, DWORD /* val */)
    {
        ASSERT(offset == NO_OFFSET);
        UNREFERENCED_PARAMETER(offset);
        pPropVar->vt = VT_UI8;
		pPropVar->uhVal.QuadPart = 0;
    }
};

class VTLPWSTRHandler : public VTHandler
{
public:

	void Display(const PROPVARIANT *pPropVar, CString & str)
    {
        str = pPropVar->pwszVal;
    }

    void Set(PROPVARIANT *pPropVar, VOID * pBase, DWORD offset, DWORD /*size*/)
    {
        pPropVar->vt = VT_LPWSTR;
        pPropVar->pwszVal = reinterpret_cast<LPWSTR> ((char *)pBase + offset);
    }
};


class VTCLSIDHandler : public VTHandler
{
public:

    void Display(const PROPVARIANT *pPropVar, CString & str)
    {
        GUID_STRING szGuid;
        MQpGuidToString(pPropVar->puuid, szGuid);

        str = szGuid;

     }


    void Set(PROPVARIANT *pPropVar, VOID * pBase, DWORD offset, DWORD /*size*/)
    {
        pPropVar->vt = VT_CLSID;
        pPropVar->puuid = reinterpret_cast<CLSID *> ((char *)pBase + offset);
    }
};

class VTVectLPWSTRHandler : public VTHandler
{
public:

    void Display(const PROPVARIANT *pPropVar, CString & str)
    {
      ASSERT(pPropVar->vt == (VT_LPWSTR|VT_VECTOR));

      str = L"";
      for (DWORD i = 0; i < pPropVar->calpwstr.cElems; i++)
      {
         str += pPropVar->calpwstr.pElems[i];
         str += L" ";
      }
   }


    void Set(PROPVARIANT * /*pPropVar*/, VOID * /*pBase*/, DWORD /*offset*/, DWORD /*size*/)
    {
      ASSERT(0);
    }
};


class VTVectUI1Handler : public VTHandler
{
public:

    void Display(const PROPVARIANT * /*pPropVar*/, CString & str)
    {
        str =L"VTVectUI1Handler";
    }


    void Set(PROPVARIANT *pPropVar, VOID * pBase, DWORD offset, DWORD size)
    {
        pPropVar->vt = VT_UI1|VT_VECTOR;
        pPropVar->caui.pElems = (unsigned short *)((char *)pBase + offset);
        pPropVar->caui.cElems = size;
    }
};


extern VTUI1Handler        g_VTUI1;
extern VTUI2Handler        g_VTUI2;
extern VTUI4Handler        g_VTUI4;
extern VTUI8Handler        g_VTUI8;
extern VTLPWSTRHandler     g_VTLPWSTR;
extern VTCLSIDHandler      g_VTCLSID;
extern VTVectUI1Handler    g_VectUI1;
extern VTVectLPWSTRHandler g_VectLPWSTR;

void CaubToString(const CAUB* pcaub, CString& strResult);

//
// Automatic Global Pointer (Use GlobalAlloc and GlobalFree)
//
class CGlobalPointer
{
public:
    operator HGLOBAL() const;
    CGlobalPointer(UINT uFlags, DWORD dwBytes);
    CGlobalPointer(HGLOBAL hGlobal);
    ~CGlobalPointer();

private:
    HGLOBAL m_hGlobal;
};

inline CGlobalPointer::CGlobalPointer(UINT uFlags, DWORD dwBytes)
{
    m_hGlobal = GlobalAlloc(uFlags, dwBytes);
}

inline CGlobalPointer::CGlobalPointer(HGLOBAL hGlobal)
{
    m_hGlobal = hGlobal;
}

inline CGlobalPointer::~CGlobalPointer()
{
    if (0 != m_hGlobal)
    {
        VERIFY( 0 == GlobalFree(m_hGlobal));
    }
}

inline CGlobalPointer::operator HGLOBAL() const
{
    return m_hGlobal;
}

//
// Automatic CoTask memory Pointer (Use CoTaskMemAlloc and CoTaskMemFree)
//
class CCoTaskMemPointer
{
public:
    operator LPVOID() const;
    CCoTaskMemPointer &operator =(LPVOID p);
    CCoTaskMemPointer(DWORD dwBytes);
    ~CCoTaskMemPointer();

private:
    LPVOID m_pvCoTaskMem;
};

inline CCoTaskMemPointer::CCoTaskMemPointer(DWORD dwBytes)
{
    m_pvCoTaskMem = CoTaskMemAlloc(dwBytes);
}

inline CCoTaskMemPointer::~CCoTaskMemPointer()
{
    if (0 != m_pvCoTaskMem)
    {
        CoTaskMemFree(m_pvCoTaskMem);
    }
}

inline CCoTaskMemPointer::operator LPVOID() const
{
    return m_pvCoTaskMem;
}

inline CCoTaskMemPointer &CCoTaskMemPointer::operator =(LPVOID p)
{
    m_pvCoTaskMem = p;
    return *this;
}

//
//  Auto delete of ADs allocated string
//
class ADsFree {
private:
    WCHAR * m_p;

public:
    ADsFree() : m_p(0)            {}
    ADsFree(WCHAR* p) : m_p(p)    {}
   ~ADsFree()                     { FreeADsStr(m_p); }

    operator WCHAR*() const   { return m_p; }
    WCHAR** operator&()       { return &m_p;}
    WCHAR* operator->() const { return m_p; }
};


//
// CErrorCapture - used to route error messages to the screen or to 
// a buffer
//         
class CErrorCapture : public CString
{
public:
    CErrorCapture()
    {
        m_pstrOldErrorBuffer = 0;
        SetErrorBuffer(&m_pstrOldErrorBuffer, this);
    }
    ~CErrorCapture()
    {
        SetErrorBuffer(&m_pstrOldErrorBuffer, 0);
    }
    static DisplayError(CString &csPrompt, 
                          UINT nType = MB_OK | MB_ICONERROR, 
                          UINT nIDHelp = 0)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        if (ms_pstrCurrentErrorBuffer == 0)
        {
            return AfxMessageBox(csPrompt, nType, nIDHelp);
        }
        *ms_pstrCurrentErrorBuffer = csPrompt;
        return IDOK;
    }

private:
    static CString *ms_pstrCurrentErrorBuffer /* = 0 */;
    static void SetErrorBuffer(CString **pstrOldErrorBuffer, CString *pstrErrorBuffer)
    {
        if (pstrErrorBuffer != 0)
        {
            //
            // Push error buffer
            //
            *pstrOldErrorBuffer = ms_pstrCurrentErrorBuffer;
            ms_pstrCurrentErrorBuffer = pstrErrorBuffer;
        }
        else
        {
            //
            // Pop Error puffer
            //
            ms_pstrCurrentErrorBuffer = *pstrOldErrorBuffer;
        }
    }
    CString *m_pstrOldErrorBuffer;

};
 

class CMqPropertyPage;

class CGeneralPropertySheet : public CPropertySheetEx
{
public:
	CGeneralPropertySheet(CMqPropertyPage* pPropertyPage);
	~CGeneralPropertySheet(){};

	BOOL SetWizardButtons();

protected:
	void initHtmlHelpString(){};
	static HBITMAP GetHbmHeader(){};
	static HBITMAP GetHbmWatermark(){};

private:
	CGeneralPropertySheet(const CGeneralPropertySheet&);
	CGeneralPropertySheet& operator=(const CGeneralPropertySheet&);

};

inline
CGeneralPropertySheet::CGeneralPropertySheet(
	CMqPropertyPage* pPropertyPage
	) : CPropertySheetEx(L"New")
{
	AddPage(reinterpret_cast<CPropertyPageEx*>(pPropertyPage));

	//
    // Establish a property page as a wizard
    //
    SetWizardMode();
}

extern CString s_finishTxt;

inline 
CGeneralPropertySheet::SetWizardButtons()
{
    CPropertySheetEx::SetWizardButtons(PSWIZB_FINISH);
	
	s_finishTxt.LoadString(IDS_OK);
	SetFinishText(s_finishTxt);

    return TRUE;
}

                                                                       
//
// Constants
//
const TCHAR x_tstrDigitsAndWhiteChars[] = TEXT("0123456789\n\t\b");
const DWORD x_dwMaxGuidLength = 40;

void MoveSelected(CListBox* plbSource, CListBox* plbDest);

//
// NOTE: Don't implement DestructElements. SiteGate use a double map with
//       double pointing. on the class destruction the RemoveAll for the maps
//       is called, but for the second map the keys and the values are not
//       valid anymore.
//
template<>
BOOL AFXAPI CompareElements(const LPCWSTR* MapName1, const LPCWSTR* MapName2);
template<>
UINT AFXAPI HashKey(LPCWSTR key);

void DDV_NotEmpty(CDataExchange* pDX, CString& str, UINT uiErrorMessage);

template<>
extern void AFXAPI DestructElements(PROPVARIANT *pElements, INT_PTR nCount);

int CompareVariants(PROPVARIANT *propvar1, PROPVARIANT *propvar2);

//
// "Object" property page DS UUID
// 6dfe6488-a212-11d0-bcd5-00c04fd8d5b6
//
const GUID x_ObjectPropertyPageClass = 
  { 0x6dfe6488, 0xa212, 0x11d0, { 0xbc, 0xd5, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0xb6 } };

//
// "Member Of" property page DSPropertyPages.MemberShip
// 0x6dfe648a-a212-11d0-bcd5-00c04fd8d5b6
//
const GUID x_MemberOfPropertyPageClass =
    { 0x6dfe648a,0xa212,0x11d0,{ 0xbc,0xd5,0x00,0xc0,0x4f,0xd8,0xd5,0xb6} };


const GUID CQueueExtDatatGUID_NODETYPE = 
   { 0x9a0dc343, 0xc100, 0x11d1, { 0xbb, 0xc5, 0x00, 0x80, 0xc7, 0x66, 0x70, 0xc0 } };

//
// DS Snapin CLSID - {E355E538-1C2E-11d0-8C37-00C04FD8FE93}
//
const CLSID CLSID_DSSnapin = { 0xe355e538, 0x1c2e, 0x11d0, { 0x8c, 0x37, 0x0, 0xc0, 0x4f, 0xd8, 0xfe, 0x93 } };

//
// Find Window CLSID - {FE1290F0-CFBD-11CF-A330-00AA00C16E65}
//
const CLSID CLSID_FindWindow = { 0xfe1290f0, 0xcfbd, 0x11cf, { 0xa3, 0x30, 0x00, 0xaa, 0x00, 0xc1, 0x6e, 0x65 } };

const DWORD x_CnPrefixLen = sizeof(L"CN=")/sizeof(WCHAR) - 1;
const DWORD x_LdapPrefixLen = sizeof(L"LDAP://")/sizeof(WCHAR) - 1;

const WCHAR x_CnPrefix[] = L"CN=";
const WCHAR x_wstrLdapPrefix[] = L"LDAP://";

const WCHAR x_wstrDN[] = L"distinguishedName";
const WCHAR x_wstrAliasFormatName[] = L"mSMQ-Recipient-FormatName";
const WCHAR x_wstrDescription[] = L"description";

const WCHAR x_wstrAliasClass[] = L"mSMQ-Custom-Recipient";

struct CColumnDisplay
{
    DWORD m_columnNameId;
    int m_width;
};

//
// Nedded for linking with fn.lib
//
LPCWSTR
McComputerName(
	void
	);

//
// Nedded for linking with fn.lib
//
DWORD
McComputerNameLen(
	void
	);



void
DDV_ValidFormatName(
	CDataExchange* pDX,
	CString& str
	);

void
SetScrollSizeForList(
	CListBox* pListBox
	);

BOOL
TryStopMSMQServiceIfStarted(
	BOOL* pfServiceWasRunning,
	CWnd* pWnd
	);

void 
GetStringPropertyValue(
	const PropertyDisplayItem * pItem, 
	PROPID pid, 
	PROPVARIANT *pPropVar, 
	CString &str
	);

void 
FreeMqProps(
	MQMGMTPROPS * mqProps
	);

BOOL
IsClusterVirtualServer(
	LPCWSTR wcsMachineName
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\infodlg.h ===
// InfoDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CInfoDlgDialog dialog

class CInfoDlgDialog : public CMqDialog
{
// Construction
public:
    static CInfoDlgDialog *CreateObject(LPCTSTR szInfoText, CWnd* pParent = NULL);

private:
    //
    // Private constructor - this object can only be created
    // using CreateObject
    //
    CInfoDlgDialog(LPCTSTR szInfoText, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CInfoDlgDialog)
	enum { IDD = IDD_INFO_DLG };
    CString m_szInfoText;
	//}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CInfoDlgDialog)
	protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void PostNcDestroy();
	//}}AFX_VIRTUAL

// Implementation
protected:  
    // Generated message map functions
    //{{AFX_MSG(CInfoDlgDialog)       
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL Create();
    CWnd* m_pParent;
	int m_nID;
};

class CInfoDlg
{
public:
    CInfoDlg(LPCTSTR szInfoText, CWnd* pParent = NULL);
    ~CInfoDlg();

private:
    CInfoDlgDialog *m_pinfoDlg;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\ldaputl.h ===
/*++

Copyright (c) 1995 - 2001 Microsoft Corporation

Module Name:

    ldaputl.h

Abstract:

    Definition of functions that retrieve data from LDAP names

Author:

    Nela Karpel (nelak) 26-Jul-2001

Environment:

    Platform-independent.

--*/
#pragma once
#ifndef __LDAPUTL_H__
#define __LDAPUTL_H__


HRESULT ExtractDCFromLdapPath(
	CString& strName, 
	LPCWSTR lpcwstrLdapName
	);

HRESULT ExtractNameFromLdapName(
	CString &strName, 
	LPCWSTR lpcwstrLdapName, 
	DWORD dwIndex
	);

HRESULT ExtractComputerMsmqPathNameFromLdapName(
	CString &strComputerMsmqName, 
	LPCWSTR lpcwstrLdapName
	);

HRESULT ExtractComputerMsmqPathNameFromLdapQueueName(
	CString &strComputerMsmqName, 
	LPCWSTR lpcwstrLdapName
	);

HRESULT ExtractQueuePathNameFromLdapName(
	CString &strQueuePathName, 
	LPCWSTR lpcwstrLdapName
	);

HRESULT ExtractLinkPathNameFromLdapName(
	CString& SiteLinkPathName, 
	LPCWSTR lpwstrLdapPath
	);

HRESULT ExtractAliasPathNameFromLdapName(
	CString& AliasPathName, 
	LPCWSTR lpwstrLdapPath
	);

	HRESULT ExtractQueueNameFromQueuePathName(
	CString &strQueueName, 
	LPCWSTR lpcwstrQueuePathName
	);

HRESULT ExtractQueuePathNamesFromDataObject(
    IDataObject*               pDataObject,
    CArray<CString, CString&>& astrQNames,
	CArray<CString, CString&>& astrLdapNames
    );

HRESULT ExtractQueuePathNamesFromDSNames(
    LPDSOBJECTNAMES pDSObj,
    CArray<CString, CString&>& astrQNames,
	CArray<CString, CString&>& astrLdapNames
    );

HRESULT ExtractPathNamesFromDataObject(
    IDataObject*               pDataObject,
    CArray<CString, CString&>& astrObjectNames,
	CArray<CString, CString&>& astrLdapNames,
    BOOL                       fExtractAlsoComputerMsmqObjects
    );

HRESULT ExtractPathNamesFromDSNames(
    LPDSOBJECTNAMES pDSObj,
    CArray<CString, CString&>& astrQNames,
	CArray<CString, CString&>& astrLdapNames,
    BOOL    fExtractAlsoComputerMsmqObjects
    );

BOOL
GetContainerPathAsDisplayString(
	BSTR bstrContainerCNFormat,
	CString* pContainerDispFormat
	);

#endif // __LDAPUTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\linkdata.cpp ===
// linkdata.cpp : Implementation of CLinkDataObject
#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "mqPPage.h"
#include "dataobj.h"
#include "mqDsPage.h"
#include "linkdata.h"
#include "linkgen.h"
#include "SiteGate.h"
#include "globals.h"
#include "msmqlink.h"
#include "ldaputl.h"
#include <adsiutl.h>

#include "linkdata.tmh"


const PROPID CLinkDataObject::mx_paPropid[] = {
    PROPID_L_NEIGHBOR1,
    PROPID_L_NEIGHBOR2,
    PROPID_L_ACTUAL_COST,
    PROPID_L_GATES_DN,
	PROPID_L_DESCRIPTION
    };


/////////////////////////////////////////////////////////////////////////////
// CLinkDataObject


//
// IShellPropSheetExt
//

HRESULT 
CLinkDataObject::ExtractMsmqPathFromLdapPath(
    LPWSTR lpwstrLdapPath
    )
{
    return ExtractLinkPathNameFromLdapName(m_strMsmqPath, lpwstrLdapPath);
}


STDMETHODIMP 
CLinkDataObject::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam
    )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (SUCCEEDED(GetPropertiesSilent()))
    {
        InitializeLinkProperties();

        HPROPSHEETPAGE hPage = CreateGeneralPage();
        if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
        {
            ASSERT(0);
            return E_UNEXPECTED;
        }
        //
        //  Is it a valid site-link
        //
        if ((m_FirstSiteId != GUID_NULL) &&
            (m_SecondSiteId != GUID_NULL))
        {
            hPage = CreateSiteGatePage();
            if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
            {
                ASSERT(0);
                return E_UNEXPECTED;
            }
        }
    }
    else
    {
        return E_UNEXPECTED;
    }

    return S_OK;
}

void
CLinkDataObject::InitializeLinkProperties(
    void
    )
{
    PROPVARIANT propVar;
    PROPID pid;

    //
    // Get first site ID
    //
    pid = PROPID_L_NEIGHBOR1;
    VERIFY(m_propMap.Lookup(pid, propVar));
    //
    //  check neighbor validity
    //
    if (propVar.vt == VT_EMPTY)
    {
        m_FirstSiteId = GUID_NULL;
    }
    else
    {
        m_FirstSiteId = *(propVar.puuid);
    }

    //
    // Get second site ID
    //
    pid = PROPID_L_NEIGHBOR2;
    VERIFY(m_propMap.Lookup(pid, propVar));
    //
    //  check neighbor validity
    //
    if (propVar.vt == VT_EMPTY)
    {
        m_SecondSiteId = GUID_NULL;
    }
    else
    {
        m_SecondSiteId = *(propVar.puuid);
    }

    pid = PROPID_L_ACTUAL_COST;
    VERIFY(m_propMap.Lookup(pid, propVar));
    m_LinkCost = propVar.ulVal; 

    pid = PROPID_L_DESCRIPTION;
    VERIFY(m_propMap.Lookup(pid, propVar));
	if (propVar.vt == VT_EMPTY)
	{
		m_LinkDescription = L"";
	}
	else
	{
		m_LinkDescription = propVar.pwszVal;
	}

}


HPROPSHEETPAGE 
CLinkDataObject::CreateGeneralPage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // By using template class CMqDsPropertyPage, we extend the basic functionality
    // of CQueueGeneral and add DS snap-in notification on release
    //
	CMqDsPropertyPage<CLinkGen> *pcpageGeneral = 
        new CMqDsPropertyPage<CLinkGen>(m_pDsNotifier, m_strMsmqPath, m_strDomainController);
    pcpageGeneral->Initialize(
                        &m_FirstSiteId, 
                        &m_SecondSiteId,
                        m_LinkCost,
						m_LinkDescription
                        );

    return pcpageGeneral->CreateThemedPropertySheetPage();
}


HPROPSHEETPAGE 
CLinkDataObject::CreateSiteGatePage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    PROPVARIANT propVar;
    PROPID pid = PROPID_L_GATES_DN;
    VERIFY(m_propMap.Lookup(pid, propVar));

    //
    // Note: CLinkDataObject is auto-delete by default
    //
	CSiteGate *pSiteGatePage = new CSiteGate(m_strDomainController, m_strMsmqPath);
    pSiteGatePage->Initialize(
                        &m_FirstSiteId, 
                        &m_SecondSiteId,
                        &propVar.calpwstr
                        );

	return pSiteGatePage->CreateThemedPropertySheetPage();
}


const 
DWORD  
CLinkDataObject::GetPropertiesCount(
    void
    )
{
    return sizeof(mx_paPropid) / sizeof(mx_paPropid[0]);
}


//
// IContextMenu
//
STDMETHODIMP 
CLinkDataObject::QueryContextMenu(
    HMENU /*hmenu*/,
    UINT /*indexMenu*/, 
    UINT /*idCmdFirst*/, 
    UINT /*idCmdLast*/, 
    UINT /*uFlags*/
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return 0;
}

STDMETHODIMP 
CLinkDataObject::InvokeCommand(
    LPCMINVOKECOMMANDINFO /*lpici*/
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(0);

    return S_OK;
}


STDMETHODIMP CLinkDataObject::Initialize(IADsContainer* pADsContainerObj, 
                        IADs* pADsCopySource,
                        LPCWSTR lpszClassName)
{
    if ((pADsContainerObj == NULL) || (lpszClassName == NULL))
    {
        return E_INVALIDARG;
    }
    //
    // We do not support copy at the moment
    //
    if (pADsCopySource != NULL)
    {
        return E_INVALIDARG;
    }

	//
	// Get Domain Controller name
	// This is neccessary because in this case we call CreateModal()
	// and not the normal path that call CDataObject::Initialize
	// so m_strDomainController is not initialized yet
	//
    HRESULT hr;
    R<IADs> pIADs;
    hr = pADsContainerObj->QueryInterface(IID_IADs, (void **)&pIADs);
    ASSERT(SUCCEEDED(hr));
	if(FAILED(hr))
	{
		//
		// If we failed to get IADs we will return
		// m_strDomainController will not be initialized, but this is ok
		//
		return S_OK;
	}

    VARIANT var;
    hr = pIADs->Get(L"distinguishedName", &var);
    ASSERT(SUCCEEDED(hr));

	GetContainerPathAsDisplayString(var.bstrVal, &m_strContainerDispFormat);
    VariantClear(&var);

	BSTR bstr;
 	hr = pIADs->get_ADsPath(&bstr);
    ASSERT(SUCCEEDED(hr));
	hr = ExtractDCFromLdapPath(m_strDomainController, bstr);
	ASSERT(("Failed to Extract DC name", SUCCEEDED(hr)));

    return S_OK;
}

HRESULT 
CLinkDataObject::CreateModal(HWND /*hwndParent*/, IADs** ppADsObj)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    R<CMsmqLink> pMsmqLink = new CMsmqLink(m_strDomainController, m_strContainerDispFormat);
	CGeneralPropertySheet propertySheet(pMsmqLink.get());
	pMsmqLink->SetParentPropertySheet(&propertySheet);

	//
	// We want to use pMsmqLink data also after DoModal() exitst
	//
	pMsmqLink->AddRef();
    if (IDCANCEL == propertySheet.DoModal())
    {
        return S_FALSE;
    }

    LPCWSTR SiteLinkFullPath = pMsmqLink->GetSiteLinkFullPath();
    if (SiteLinkFullPath == NULL)
    {
        return S_FALSE;
    }

    CString strTemp = L"LDAP://";
    strTemp += SiteLinkFullPath;

	AP<WCHAR> pEscapeAdsPathNameToFree;

    HRESULT rc = ADsOpenObject( 
		            UtlEscapeAdsPathName(strTemp, pEscapeAdsPathNameToFree),
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**) ppADsObj
					);

    if(FAILED(rc))
    {   
        AfxMessageBox(IDS_CREATED_WAIT_FOR_REPLICATION);
        return S_FALSE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\linkgen.cpp ===
// LinkGen.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqPPage.h"
#include "LinkGen.h"
#include "globals.h"

#include "linkgen.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLinkGen property page

IMPLEMENT_DYNCREATE(CLinkGen, CMqPropertyPage)

CLinkGen::CLinkGen(
    const CString& LinkPathName,
    const CString& strDomainController
    ) : 
    CMqPropertyPage(CLinkGen::IDD),
    m_LinkPathName(LinkPathName),
    m_strDomainController(strDomainController),
    m_pFirstSiteId(NULL),
    m_pSecondSiteId(NULL)
{
	//{{AFX_DATA_INIT(CLinkGen)
	m_LinkCost = 0;
	m_LinkLabel = _T("");
	//}}AFX_DATA_INIT
}

CLinkGen::~CLinkGen()
{
}

void CLinkGen::DoDataExchange(CDataExchange* pDX)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLinkGen)
	DDX_Text(pDX, IDC_LINK_COST, m_LinkCost);
	DDV_MinMaxDWord(pDX, m_LinkCost, 1, MQ_MAX_LINK_COST);
	DDX_Text(pDX, IDC_LINK_LABEL, m_LinkLabel);
	DDX_Text(pDX, IDC_LINK_DESCR, m_strLinkDescription);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLinkGen, CMqPropertyPage)
	//{{AFX_MSG_MAP(CLinkGen)
	ON_EN_CHANGE(IDC_LINK_COST, OnChangeRWField)
	ON_EN_CHANGE(IDC_LINK_DESCR, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLinkGen message handlers

BOOL CLinkGen::OnInitDialog() 
{
    //
    // This closure is used to keep the DLL state. For UpdateData we need
    // the mmc.exe state.
    //

    UpdateData( FALSE );
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


HRESULT
CLinkGen::GetSiteName(
    const GUID* pguidSiteId,
    CString *   pstrSiteName
    )
{
    //
    //  Is the site-id valid?
    //
    if (*pguidSiteId == GUID_NULL)
    {
        //
        //  Not a valid site
        //
        pstrSiteName->LoadString(IDS_UNKNOWN_OR_DELETED_SITE);
        return MQ_OK;
    }
    //
    // Get the site name
    //
    PROPID pid[1] = { PROPID_S_PATHNAME };
    PROPVARIANT var[1];
    var[0].vt = VT_NULL;
    
    HRESULT hr = ADGetObjectPropertiesGuid(
                    eSITE,
                    GetDomainController(m_strDomainController),
					true,	// fServerName
                    pguidSiteId,
                    1, 
                    pid,
                    var
                    );

    if (FAILED(hr))
    {
        IF_NOTFOUND_REPORT_ERROR(hr)
        else
        {
            CString strSite;
            strSite.LoadString(IDS_SITE);
            MessageDSError(hr, IDS_OP_GET_PROPERTIES_OF, strSite);
        }
        return hr;
    }

    *pstrSiteName = var[0].pwszVal;
    MQFreeMemory(var[0].pwszVal);
    return MQ_OK;
}


HRESULT
CLinkGen::Initialize(
    const GUID* FirstSiteId,
    const GUID* SecondSiteId,
    DWORD LinkCost,
	CString strLinkDescription
    )
{
    CString strFirstSiteName, strSecondSiteName;

    m_pFirstSiteId = FirstSiteId;
    m_pSecondSiteId = SecondSiteId;
    m_LinkCost = LinkCost;
	m_strLinkDescription = strLinkDescription;

    //
    // Get the site name
    //
    HRESULT hr = GetSiteName(
        FirstSiteId,
        &strFirstSiteName
        );
    if (FAILED(hr))
    {
        return hr;
    }
    //
    // Get the second site name
    //
    hr = GetSiteName(
        SecondSiteId,
        &strSecondSiteName
        );
    if (FAILED(hr))
    {
        return hr;
    }

    m_LinkLabel.FormatMessage(IDS_SITE_LINK_LABEL, strFirstSiteName, strSecondSiteName);

    return hr;

}


BOOL CLinkGen::OnApply() 
{
	//
	// No changes
	//
    if (!m_fModified)
    {
        return TRUE;
    }

    PROPID paPropid[] = { PROPID_L_ACTUAL_COST, PROPID_L_DESCRIPTION };
	const DWORD x_iPropCount = sizeof(paPropid) / sizeof(paPropid[0]);
	PROPVARIANT apVar[x_iPropCount];
    
	DWORD iProperty = 0;

    //
    // PROPID_L_ACTUAL_COST
    //
    apVar[iProperty].vt = VT_UI4;
	apVar[iProperty].ulVal = m_LinkCost;
	iProperty++;

    //
    // PROPID_L_DESCRIPTION
    //
    apVar[iProperty].vt = VT_LPWSTR;
    apVar[iProperty].pwszVal = (LPWSTR)(static_cast<LPCWSTR>(m_strLinkDescription));
	iProperty++;
    
    //
    // set the new value
    //
    HRESULT hr = ADSetObjectProperties(
                    eROUTINGLINK,
                    GetDomainController(m_strDomainController),
					true,	// fServerName
                    m_LinkPathName,
                    x_iPropCount, 
                    paPropid, 
                    apVar
                    );


    if (MQ_OK != hr)
    {
    	AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
        MessageDSError(hr, IDS_OP_SET_PROPERTIES_OF, m_LinkPathName);
        return FALSE;
    }
	
	return CMqPropertyPage::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\ldaputl.cpp ===
/*++

Copyright (c) 1995 - 2001 Microsoft Corporation

Module Name:

    ldaputl.cpp

Abstract:

    Implelentation of functions that retrieve data from LDAP names

Author:

    Nela Karpel (nelak) 26-Jul-2001

Environment:

    Platform-independent.

--*/


#include "stdafx.h"
#include "Ntdsapi.h"
#include "mqcast.h"
#include "localutl.h"
#include "ldaputl.h"

#include "ldaputl.tmh"

HRESULT ExtractDCFromLdapPath(CString &strName, LPCWSTR lpcwstrLdapName)
{
	//
	// Format of name: LDAP://servername.domain.com/CN=Name1,CN=Name2,...
	//
	const WCHAR x_wcFirstStr[] = L"://";

	UINT iSrc = numeric_cast<UINT>(wcscspn(lpcwstrLdapName, x_wcFirstStr));

    if (0 == lpcwstrLdapName[iSrc])
    {
		ASSERT(("did not find :// str in lpcwstrLdapName", 0));
        strName.ReleaseBuffer();
        return E_UNEXPECTED;
    }

	iSrc += numeric_cast<UINT>(wcslen(x_wcFirstStr));

	const WCHAR x_wcLastChar = L'/';
	int iDst=0;

    LPWSTR lpwstrNamePointer = strName.GetBuffer(numeric_cast<UINT>(wcslen(lpcwstrLdapName)));

	for (; lpcwstrLdapName[iSrc] != 0 && lpcwstrLdapName[iSrc] != x_wcLastChar; iSrc++)
	{
		lpwstrNamePointer[iDst++] = lpcwstrLdapName[iSrc];
	}

	if(lpcwstrLdapName[iSrc] == 0)
	{
		ASSERT(("did not find last Char	in lpcwstrLdapName", 0));
        strName.ReleaseBuffer();
        return E_UNEXPECTED;
	}

	lpwstrNamePointer[iDst] = 0;

    strName.ReleaseBuffer();

	return S_OK;
}
/*====================================================

LDAPNameToQueueName

Translate an LDAP object name to a MSMQ queue name
This function allocates the memory which has to be freed by the caller
=====================================================*/

HRESULT ExtractComputerMsmqPathNameFromLdapName(CString &strComputerMsmqName, LPCWSTR lpcwstrLdapName)
{
   //
   // Format of name: LDAP://CN=msmq,CN=computername,CN=...
   //
    return ExtractNameFromLdapName(strComputerMsmqName, lpcwstrLdapName, 2);
}

HRESULT ExtractComputerMsmqPathNameFromLdapQueueName(CString &strComputerMsmqName, LPCWSTR lpcwstrLdapName)
{
   //
   // Format of name: LDAP://CN=QueueName,CN=msmq,CN=computername,CN=...
   //
    return ExtractNameFromLdapName(strComputerMsmqName, lpcwstrLdapName, 3);
}

HRESULT ExtractQueuePathNameFromLdapName(CString &strQueuePathName, LPCWSTR lpcwstrLdapName)
{
   //
   // Format of name: LDAP://CN=QueueName,CN=msmq,CN=computername,CN=...
   //
    CString strQueueName, strLdapQueueName, strComputerName;
    HRESULT hr;
    hr = ExtractComputerMsmqPathNameFromLdapQueueName(strComputerName, lpcwstrLdapName);
    if FAILED(hr)
    {
        return hr;
    }

    hr = ExtractNameFromLdapName(strLdapQueueName, lpcwstrLdapName, 1);
    if FAILED(hr)
    {
        return hr;
    }

    //
    // Remove all '\' from the queue name
    //
    strQueueName.Empty();
    for (int i=0; i<strLdapQueueName.GetLength(); i++)
    {
        if (strLdapQueueName[i] != '\\')
        {
            strQueueName+=strLdapQueueName[i];
        }
    }

    strQueuePathName.GetBuffer(strComputerName.GetLength() + strQueueName.GetLength() + 1);

    strQueuePathName = strComputerName + TEXT("\\") + strQueueName;

    strQueuePathName.ReleaseBuffer();

    return S_OK;
}

HRESULT ExtractLinkPathNameFromLdapName(
    CString& SiteLinkName,
    LPCWSTR lpwstrLdapPath
    )
{
    HRESULT hr;

    hr = ExtractNameFromLdapName(SiteLinkName, lpwstrLdapPath, 1);
    return hr;
}

HRESULT ExtractAliasPathNameFromLdapName(
    CString& AliasPathName,
    LPCWSTR lpwstrLdapPath
    )
{
    HRESULT hr;

    hr = ExtractNameFromLdapName(AliasPathName, lpwstrLdapPath, 1);
    return hr;
}

HRESULT ExtractNameFromLdapName(CString &strName, LPCWSTR lpcwstrLdapName, DWORD dwIndex)
{
    ASSERT(dwIndex >= 1);

   //
   // Format of name: LDAP://CN=Name1,CN=Name2,...
   //
   const WCHAR x_wcFirstChar=L'=';

   const WCHAR x_wcLastChar=L',';

   BOOL fCopy = FALSE;
   int iSrc=0, iDst=0;

    LPWSTR lpwstrNamePointer = strName.GetBuffer(numeric_cast<UINT>(wcslen(lpcwstrLdapName)));

    //
    // Go to the dwIndex appearance of the first char
    //
    for (DWORD dwAppearance=0; dwAppearance < dwIndex; dwAppearance++)
    {
        while(lpcwstrLdapName[iSrc] != 0 && lpcwstrLdapName[iSrc] != x_wcFirstChar)
        {
            //
            // skip escape characters (composed of '\' + character)
            //
            if (lpcwstrLdapName[iSrc] == L'\\')
            {
                iSrc++;
                if (lpcwstrLdapName[iSrc] != 0)
                {
                    iSrc++;
                }
            }
            else
            {
                //
                // Skip one character
                //
                iSrc++;
            }
        }

        if (0 == lpcwstrLdapName[iSrc])
        {
            strName.ReleaseBuffer();
            return E_UNEXPECTED;
        }
        iSrc++;
    }

   for (; lpcwstrLdapName[iSrc] != 0 && lpcwstrLdapName[iSrc] != x_wcLastChar; iSrc++)
   {
      lpwstrNamePointer[iDst++] = lpcwstrLdapName[iSrc];
   }

   lpwstrNamePointer[iDst] = 0;

    strName.ReleaseBuffer();

   return S_OK;
}


HRESULT ExtractQueueNameFromQueuePathName(CString &strQueueName, LPCWSTR lpcwstrQueuePathName)
{
    //
    // Get the name only out of the pathname
    //
    strQueueName = lpcwstrQueuePathName;

    int iLastSlash = strQueueName.ReverseFind(L'\\');
    if (iLastSlash != -1)
    {
        strQueueName = strQueueName.Right(strQueueName.GetLength() - iLastSlash - 1);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++
ExtractQueuePathNamesFromDataObject
--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT ExtractQueuePathNamesFromDataObject(
    IDataObject*               pDataObject,
    CArray<CString, CString&>& astrQNames,
	CArray<CString, CString&>& astrLdapNames
    )
{
    return( ExtractPathNamesFromDataObject(
                pDataObject,
                astrQNames,
                astrLdapNames,
                FALSE   //fExtractAlsoComputerMsmqObjects
                ));
}

//////////////////////////////////////////////////////////////////////////////
/*++
ExtractQueuePathNamesFromDSNames
--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT ExtractQueuePathNamesFromDSNames(
    LPDSOBJECTNAMES pDSObj,
    CArray<CString, CString&>& astrQNames,
	CArray<CString, CString&>& astrLdapNames
    )
{
    return( ExtractPathNamesFromDSNames(
                pDSObj,
                astrQNames,
                astrLdapNames,
                FALSE       // fExtractAlsoComputerMsmqObjects
                ));
}


//////////////////////////////////////////////////////////////////////////////
/*++
ExtractPathNamesFromDSNames
--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT ExtractPathNamesFromDSNames(
    LPDSOBJECTNAMES pDSObj,
    CArray<CString, CString&>& astrObjNames,
	CArray<CString, CString&>& astrLdapNames,
    BOOL    fExtractAlsoComputerMsmqObjects
    )
{
    //
    //  This routine extract queues pathnames and msmq-configuration pathnames (optional)
    //
    static const WCHAR x_strMsmqQueueClassName[] = L"mSMQQueue";
    static const WCHAR x_strMsmqClassName[] = L"mSMQConfiguration";
    for (DWORD i = 0; i < pDSObj->cItems; i++)
    {
  	    LPWSTR lpwstrLdapClass = (LPWSTR)((BYTE*)pDSObj + pDSObj->aObjects[i].offsetClass);
        CString strLdapName = (LPWSTR)((BYTE*)pDSObj + pDSObj->aObjects[i].offsetName);
        CString strObjectName;

        if (wcscmp(lpwstrLdapClass, x_strMsmqQueueClassName) == 0)
        {
            //
            // Translate (and keep in the Queue) the LDAP name to a queue name
            //
            HRESULT hr = ExtractQueuePathNameFromLdapName(strObjectName, strLdapName);
            if(FAILED(hr))
            {
                ATLTRACE(_T("ExtractPathNamesFromDataObject - Extracting queue name from LDP name %s failed\n"),
                         (LPTSTR)(LPCTSTR)strLdapName);
                return(hr);
            }
        }
        else if ( fExtractAlsoComputerMsmqObjects &&
                  wcscmp(lpwstrLdapClass, x_strMsmqClassName) == 0)
        {
            //
            // Translate  the LDAP name to a msmq object name
            //
            HRESULT hr = ExtractComputerMsmqPathNameFromLdapName(strObjectName, strLdapName);
            if(FAILED(hr))
            {
                ATLTRACE(_T("ExtractPathNamesFromDataObject - Extracting msmq configuration name from LDP name %s failed\n"),
                         (LPTSTR)(LPCTSTR)strLdapName);
                return(hr);
            }
        }
        else
        {
            //
            // We ignore any object not queues or msmq-configuration
            //
            continue;
        }


        astrObjNames.Add(strObjectName);
        astrLdapNames.Add(strLdapName);
    }

    return S_OK;
}
//////////////////////////////////////////////////////////////////////////////
/*++
ExtractPathNamesFromDataObject
--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT ExtractPathNamesFromDataObject(
    IDataObject*               pDataObject,
    CArray<CString, CString&>& astrObjNames,
	CArray<CString, CString&>& astrLdapNames,
    BOOL                       fExtractAlsoComputerMsmqObjects
    )
{
    //
    // Get the object name from the DS snapin
    //
    LPDSOBJECTNAMES pDSObj;

	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc =  {  0, 0,  DVASPECT_CONTENT,  -1,  TYMED_HGLOBAL  };

    //
    // Get the LDAP name of the queue from the DS Snapin
    //
   	formatetc.cfFormat = DWORD_TO_WORD(RegisterClipboardFormat(CFSTR_DSOBJECTNAMES));
	HRESULT hr = pDataObject->GetData(&formatetc, &stgmedium);

    if(FAILED(hr))
    {
        ATLTRACE(_T("ExtractPathNamesFromDataObject::GetExtNodeObject - Get clipboard format from DS failed\n"));
        return(hr);
    }

    pDSObj = (LPDSOBJECTNAMES)stgmedium.hGlobal;

    hr = ExtractPathNamesFromDSNames(pDSObj,
                                     astrObjNames,
                                     astrLdapNames,
                                     fExtractAlsoComputerMsmqObjects
                                     );

    GlobalFree(stgmedium.hGlobal);

    return hr;
}


BOOL
GetContainerPathAsDisplayString(
	BSTR bstrContainerCNFormat,
	CString* pContainerDispFormat
	)
{
	PDS_NAME_RESULT pDsNameRes = NULL;
	DWORD dwRes = DsCrackNames(NULL,
						DS_NAME_FLAG_SYNTACTICAL_ONLY,
						DS_FQDN_1779_NAME,
						DS_CANONICAL_NAME,
						1,
						&bstrContainerCNFormat,
						&pDsNameRes
						);
	
	if (dwRes != DS_NAME_NO_ERROR)
	{
		return FALSE;
	}

	*pContainerDispFormat = pDsNameRes->rItems[0].pName;
	DsFreeNameResult(pDsNameRes);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\linkdata.h ===
// linkdata.h : Declaration of the CLinkDataObject

#ifndef __LINKDATA_H_
#define __LINKDATA_H_

#include "resource.h"       // main symbols
#include "dataobj.h"

/////////////////////////////////////////////////////////////////////////////
// CLinkDataObject
class CLinkDataObject : 
	public CDataObject,
	public CComCoClass<CLinkDataObject, &CLSID_LinkDataObject>,
    public IDsAdminCreateObj

{
public:
    DECLARE_NOT_AGGREGATABLE(CLinkDataObject)
    DECLARE_REGISTRY_RESOURCEID(IDR_LINKDATAOBJECT)

    BEGIN_COM_MAP(CLinkDataObject)
	    COM_INTERFACE_ENTRY(IDsAdminCreateObj)
	    COM_INTERFACE_ENTRY_CHAIN(CDataObject)
    END_COM_MAP()

public:

    //
    // IDsAdminCreateObj methods
    //
    STDMETHOD(Initialize)(IADsContainer* pADsContainerObj, 
                          IADs* pADsCopySource,
                          LPCWSTR lpszClassName);
    STDMETHOD(CreateModal)(HWND hwndParent,
                           IADs** ppADsObj);

    //
    // IShellPropSheetExt
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    //
    // IContextMenu
    //
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);

protected:
    HPROPSHEETPAGE CreateGeneralPage();
    HPROPSHEETPAGE CreateSiteGatePage();

    virtual HRESULT ExtractMsmqPathFromLdapPath (LPWSTR lpwstrLdapPath);
   	virtual const DWORD GetObjectType();
    virtual const PROPID *GetPropidArray();
    virtual const DWORD  GetPropertiesCount();


private:
    void
    InitializeLinkProperties(
        void
        );


    GUID m_FirstSiteId;
    GUID m_SecondSiteId;
    DWORD m_LinkCost;
	CString m_LinkDescription;

	CString m_strContainerDispFormat;

    static const PROPID mx_paPropid[];
};


inline 
const 
DWORD 
CLinkDataObject::GetObjectType(
    void
    )
{
    return MQDS_SITELINK;
};


inline 
const 
PROPID*
CLinkDataObject::GetPropidArray(
    void
    )
{
    return mx_paPropid;
}

#endif //__LINKDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\linkgen.h ===
#if !defined(AFX_LINKGEN_H__57A77014_D858_11D1_9C86_006008764D0E__INCLUDED_)
#define AFX_LINKGEN_H__57A77014_D858_11D1_9C86_006008764D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// LinkGen.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CLinkGen dialog

class CLinkGen : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CLinkGen)

// Construction
public:
	CLinkGen(const CString& LinkPathName, const CString& m_strDomainController);
    CLinkGen() {};
	~CLinkGen();

    HRESULT
    Initialize(
        const GUID* FirstSiteId,
        const GUID* SecondSiteId,
        DWORD LinkCost,
		CString strLinkDescription
        );

// Dialog Data
	//{{AFX_DATA(CLinkGen)
	enum { IDD = IDD_SITE_LINK_GENERAL };
	DWORD	m_LinkCost;
	CString	m_LinkLabel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLinkGen)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLinkGen)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    HRESULT
    GetSiteName(
        const GUID* pguidSiteId,
        CString *   pstrSiteName
        );
	

    const GUID* m_pFirstSiteId;
    const GUID* m_pSecondSiteId;

    CString m_LinkPathName;
    CString m_strDomainController;
	CString m_strLinkDescription;

};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LINKGEN_H__57A77014_D858_11D1_9C86_006008764D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\localcrt.h ===
// localcrt.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLocalUserCertPage dialog

#include <autoptr.h>
#include <mqprops.h>

class CLocalUserCertPage : public CMqPropertyPage
{
    DECLARE_DYNCREATE(CLocalUserCertPage)

// Construction
public:
    CLocalUserCertPage();  
    ~CLocalUserCertPage();       

// Dialog Data
    //{{AFX_DATA(CLocalUserCertPage)
    enum { IDD = IDD_LOCAL_USERCERT };   
    //}}AFX_DATA
    
// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CLocalUserCertPage)
    public:    
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CLocalUserCertPage)
    afx_msg void OnRegister();
    afx_msg void OnRemove();
    afx_msg void OnView();    
    afx_msg void OnRenewCert();    
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\localcrt.cpp ===
//
// Security.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqppage.h"
#include "localcrt.h"
#include <autoptr.h>
#include <mqcrypt.h>
#include <_registr.h>
#include <mqsec.h>
#include <mqnames.h>
#include <wincrypt.h>
#include <cryptui.h>
#include <rt.h>
#include <mqcertui.h>
#include <rtcert.h>
#include <_secutil.h>
#include "globals.h"

#include "localcrt.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static HRESULT
_RemoveUserCert( CMQSigCertificate *pCertRem )
{
    HRESULT hr = RTRemoveUserCert(pCertRem);

    if (hr == MQDS_OBJECT_NOT_FOUND)
    {
        //
        // NT bug 516098.
        // Try to remove only the certificate, without digest.
        // Query active directory using SID.
        //
        PSID   pSid = NULL ;
        DWORD  dwLen = 0 ;

        HRESULT hr1 = MQSec_GetProcessUserSid( &pSid,
                                               &dwLen ) ;
        if (SUCCEEDED(hr1) && (pSid != NULL))
        {
            hr = RTRemoveUserCertSid( pCertRem,
                                      reinterpret_cast<SID*> (pSid) ) ;
            delete pSid ;
        }
    }

    return hr ;
}

/////////////////////////////////////////////////////////////////////////////
// CLocalUserCertPage property page

IMPLEMENT_DYNCREATE(CLocalUserCertPage, CMqPropertyPage)

CLocalUserCertPage::CLocalUserCertPage() :
    CMqPropertyPage(CLocalUserCertPage::IDD)
{
    //{{AFX_DATA_INIT(CLocalUserCertPage)
    //}}AFX_DATA_INIT

    m_fModified = FALSE;
}

CLocalUserCertPage::~CLocalUserCertPage()
{
}

void CLocalUserCertPage::DoDataExchange(CDataExchange* pDX)
{
    CMqPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLocalUserCertPage)
    //}}AFX_DATA_MAP

}


BEGIN_MESSAGE_MAP(CLocalUserCertPage, CMqPropertyPage)
    //{{AFX_MSG_MAP(CLocalUserCertPage)
    ON_BN_CLICKED(ID_Register, OnRegister)
    ON_BN_CLICKED(ID_Remove, OnRemove)
    ON_BN_CLICKED(ID_View, OnView)
    ON_BN_CLICKED(ID_RenewCert, OnRenewCert)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLocalUserCertPage message handlers

void CLocalUserCertPage::OnRegister()
{
    HRESULT hr = MQ_OK ;
    CString strErrorMsg;
    R<CMQSigCertificate> pCert;
    static s_fCreateCert = TRUE ;
    BOOL   fCertCreated = FALSE ;

    //
    // don't check the return code from this api.
    // in MSMQ1.0, and in nt5 beta2, this api (RTCreateInternalCertificate)
    // was called whenever user run the msmq control panel. If a certificate
    // already exist then the api do nothing. The certificate was used
    // only here in "OnRegister". So we keep same semantic and are compatible
    // with new api MQRegisterCertificate(). If user does not explicitely
    // press "register", or "renewInternal", then an internal certificate is
    // not created on the machine.
    //
    if (s_fCreateCert)
    {
        hr = RTCreateInternalCertificate( NULL ) ;
        s_fCreateCert = FALSE ;
        if (SUCCEEDED(hr))
        {
            fCertCreated = TRUE ;
        }
    }
    else
    {
        //
        // Create an internal certificate only of not already exist.
        //
        R<CMQSigCertStore> pStoreInt = NULL ;
        R<CMQSigCertificate> pCertInt = NULL ;

        hr = RTGetInternalCert(&pCertInt.ref(),
                               &pStoreInt.ref(),
                                FALSE,
                                FALSE,
                                NULL) ;
        if (FAILED(hr))
        {
            hr = RTCreateInternalCertificate( NULL ) ;
            if (SUCCEEDED(hr))
            {
                fCertCreated = TRUE ;
            }
        }
    }

    if (SelectPersonalCertificateForRegister(m_hWnd, NULL, 0, &pCert.ref()))
    {
        CWaitCursor wait; //display hourglass cursor
        hr = RTRegisterUserCert( pCert.get(),
                                 FALSE  ) ; //fMachine

        switch(hr)
        {
        case MQ_OK:
            break;
        case MQ_ERROR_INTERNAL_USER_CERT_EXIST:
            strErrorMsg.LoadString(IDS_CERT_EXIST1);
            AfxMessageBox(strErrorMsg, MB_OK | MB_ICONEXCLAMATION);
            break;
        default:
            if (FAILED(hr))
            {
				MessageDSError(hr, IDS_REGISTER_ERROR1);
            }
            break;
        }
    }
    else if (fCertCreated)
    {
        //
        // If an internal certificate was created then delete it.
        // It was not registered in DS and we don't want to keep it
        // localy in registry.
        //
        R<CMQSigCertStore> pStoreInt = NULL ;
        R<CMQSigCertificate> pCertInt = NULL ;

        hr = RTGetInternalCert(&pCertInt.ref(),
                               &pStoreInt.ref(),
                                TRUE,
                                FALSE,
                                NULL) ;
        if (SUCCEEDED(hr))
        {
            hr = RTDeleteInternalCert(pCertInt.get());
        }
    }
}

//+----------------------------------
//
//  void CLocalUserCertPage::OnRemove()
//
//+----------------------------------

void CLocalUserCertPage::OnRemove()
{
    HRESULT hr;
    R<CMQSigCertificate> p32Certs[32];
    AP< R<CMQSigCertificate> > pManyCerts = NULL;
    CMQSigCertificate **pCerts = &p32Certs[0].ref();
    DWORD nCerts = 32;
    CMQSigCertificate *pCertRem;
    CString strErrorMessage;

    CWaitCursor wait; //display hourglass cursor
    hr = RTGetUserCerts(pCerts, &nCerts, NULL);

    if (FAILED(hr))
    {
        MessageDSError(hr, IDS_GET_USER_CERTS_ERROR1);
        return;
    }

    if (nCerts > 32)
    {
        pManyCerts = new R<CMQSigCertificate>[nCerts];
        pCerts = &pManyCerts[0].ref();
        hr = RTGetUserCerts(pCerts, &nCerts, NULL);
        if (FAILED(hr))
        {
			MessageDSError(hr, IDS_GET_USER_CERTS_ERROR1);
            return;
        }
    }

    if (SelectPersonalCertificateForRemoval(m_hWnd, &pCerts[0], nCerts, &pCertRem))
    {
        hr = _RemoveUserCert( pCertRem ) ;
        if (FAILED(hr))
        {
			MessageDSError(hr, IDS_DELETE_USER_CERT_ERROR1);
            return;
        }

        //
        // If this is the internal certificate, then remove it from
        // local store (local HKCU registry) too.
        // Don't display any error if this fail.
        // That's new behavior of MSMQ2.0 !!!
        //
        R<CMQSigCertStore> pStoreInt = NULL ;
        R<CMQSigCertificate> pCertInt = NULL ;

        hr = RTGetInternalCert(&pCertInt.ref(),
                               &pStoreInt.ref(),
                                TRUE,
                                FALSE,
                                NULL) ;
        if (SUCCEEDED(hr))
        {
            BYTE *pCertIntBlob = NULL ;
            DWORD dwCertIntSize = 0 ;
            hr = pCertInt->GetCertBlob( &pCertIntBlob,
                                        &dwCertIntSize ) ;

            BYTE *pCertRemBlob = NULL ;
            DWORD dwCertRemSize = 0 ;
            HRESULT hr1 = pCertRem->GetCertBlob( &pCertRemBlob,
                                                 &dwCertRemSize ) ;

            if (SUCCEEDED(hr) && SUCCEEDED(hr1))
            {
                if (dwCertRemSize == dwCertIntSize)
                {
                    ASSERT(dwCertRemSize != 0) ;

                    if (memcmp( pCertIntBlob,
                                pCertRemBlob,
                                dwCertIntSize ) == 0)
                    {
                        //
                        // The removed certificate is the internal one.
                        // delete from local store.
                        //
                        hr = RTDeleteInternalCert(pCertInt.get());
                        ASSERT(SUCCEEDED(hr)) ;
                    }
                }
            }
        }
    }
}


void CLocalUserCertPage::OnView()
{
    HRESULT hr;
    R<CMQSigCertificate> p32Certs[32];
    AP< R<CMQSigCertificate> > pManyCerts = NULL;
    CMQSigCertificate **pCerts = &p32Certs[0].ref();
    DWORD nCerts = 32;
    CString strErrorMessage;

    CWaitCursor wait; //display hourglass cursor
    hr = RTGetUserCerts(pCerts, &nCerts, NULL);
    if (FAILED(hr))
    {
		MessageDSError(hr, IDS_GET_USER_CERTS_ERROR1);
        return;
    }

    if (nCerts > 32)
    {
        pManyCerts = new R<CMQSigCertificate>[nCerts];
        pCerts = &pManyCerts[0].ref();
        hr = RTGetUserCerts(pCerts, &nCerts, NULL);
        if (FAILED(hr))
        {
			MessageDSError(hr, IDS_GET_USER_CERTS_ERROR1);
            return;
        }
    }

    ShowPersonalCertificates(m_hWnd, &pCerts[0], nCerts);
}

void CLocalUserCertPage::OnRenewCert()
{
    HRESULT hr;
    CString strCaption;
    CString strMessage;

    strMessage.LoadString(IDS_CERT_WARNING);
    if (AfxMessageBox(strMessage, MB_YESNO | MB_ICONQUESTION) == IDNO)
    {
        return;
    }

    CWaitCursor wait; //display hourglass cursor

    //
    // If we have an internal certificate, remove it.
    //
    R<CMQSigCertStore> pStore = NULL ;
    R<CMQSigCertificate> pCert = NULL ;

    hr = RTGetInternalCert(&pCert.ref(),
                           &pStore.ref(),
                            TRUE,
                            FALSE,
                            NULL) ;
     //
     // Open the certificates store with write access, so we can later
     // delete the internal certificate, before creating a new one.
     //

    if (SUCCEEDED(hr))
    {
		//
		// Hack!! Lets check if the PEC is online
		// and permissions are OK. To do so, we will write
		// the certificate in DS, to remove it right after
		// (RaphiR)
		//
		hr = RTRegisterUserCert( pCert.get(),
                                 FALSE  ) ; //fMachine
        if (SUCCEEDED(hr))
        {
            //
            // This internal certifcate was not yet registered in DS.
            // That's OK, go on !
            //
        }
        else if ((hr == MQ_ERROR_INTERNAL_USER_CERT_EXIST) ||
                 (hr == MQ_ERROR_INVALID_CERTIFICATE))
        {
            //
            // That's ok. we're not interested in errors indicating that
            // the certificate is already registered or is not valid.
            // We're mainly interested in NO_DS and ACCESS_DENIED errors.
            //
            // Note: the INVALID_CERTIFICATE can happen in the following
            // scenario:
            // 1. install win95 + msqm in domain A and run control panel.
            //    This will create an internal certificate in registry.
            // 2. remove msmq and login as user of domain B.
            // 3. reinstall msmq.
            // 4. upgrade to win2k and login as same user of domain B
            // 5. Now try to renew internal certificate. The problem is
            //    that the certificate of user of domain A (from first
            //    step) is still in registry.
            // Anyway, if present internal certificate is not valid, then
            // we certainly want to remove it from DS and create anothe one.
            //
            // Go on !
            //
        }
        else
        {
			MessageDSError(hr, IDS_CREATE_INTERNAL_CERT_ERROR1);
			return;
        }

        //
        // Remove the internal certificate from MQIS.
        //
        hr = _RemoveUserCert( pCert.get() ) ;
        if (FAILED(hr) && (hr != MQDS_OBJECT_NOT_FOUND))
        {
            strMessage.LoadString(IDS_UNREGISTER_ERROR);
            if (AfxMessageBox(strMessage, MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
            {
                return;
            }
        }

        //
        // Remove the internal certificate from the certificate store.
        //
        hr = RTDeleteInternalCert(pCert.get());
        if (FAILED(hr) && (hr != MQ_ERROR_NO_INTERNAL_USER_CERT))
        {
            strMessage.LoadString(IDS_DELETE_ERROR);
            AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);
            return;
        }
    }

    //
    // Create the new internal certificate.
    //
    pCert.free();
    hr = RTCreateInternalCertificate( &pCert.ref() ) ;
    if (FAILED(hr))
    {
		MessageDSError(hr, IDS_CREATE_INTERNAL_CERT_ERROR1);
        return;
    }

    //
    // Register the newly created internal certificate in MQIS.
    //
    hr = RTRegisterUserCert( pCert.get(),
                             FALSE  ) ; //fMachine
    if (FAILED(hr))
    {
		MessageDSError(hr, IDS_REGISTER_ERROR1);
        return;
    }

    //
    // Display a confirmation message box.
    //
    strMessage.LoadString(IDS_INTERNAL_CERT_RENEWED);
    AfxMessageBox(strMessage, MB_OK | MB_ICONINFORMATION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\localadm.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	localadm.cpp

Abstract:
	Implementation for the Local administration

Authors:

    RaphiR, YoelA


--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "rt.h"
#include "mqutil.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "cpropmap.h"
#include "dsext.h"
#include "mqPPage.h"
#include "qname.h"

#define  INIT_ERROR_NODE
#include "snpnerr.h"
#include "localadm.h"
#include "qnmsprov.h"
#include "localfld.h"
#include "dataobj.h"
#include "sysq.h"
#include "privadm.h"
#include "snpqueue.h"
#include "rdmsg.h"
#include "storage.h"
#include "localcrt.h"
#include "mobile.h"
#include "client.h"
#include "srvcsec.h"
#include "compgen.h"
#include "compdiag.h"
#include "strconv.h"
#include "deppage.h"
#include "frslist.h"
#include "cmpmrout.h"
#include "compsite.h"
#include "secopt.h"
#include "mqtg.h"

#import "mqtrig.tlb" no_namespace
#include "trigadm.h"

#include "localadm.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/****************************************************

CSnapinLocalAdmin Class
    
 ****************************************************/
// {B6EDE69C-29CC-11d2-B552-006008764D7A}
static const GUID CSnapinLocalAdminGUID_NODETYPE = 
{ 0xb6ede69c, 0x29cc, 0x11d2, { 0xb5, 0x52, 0x0, 0x60, 0x8, 0x76, 0x4d, 0x7a } };

const GUID*  CSnapinLocalAdmin::m_NODETYPE = &CSnapinLocalAdminGUID_NODETYPE;
const OLECHAR* CSnapinLocalAdmin::m_SZNODETYPE = OLESTR("B6EDE69C-29CC-11d2-B552-006008764D7A");
const OLECHAR* CSnapinLocalAdmin::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CSnapinLocalAdmin::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;

const PROPID CSnapinLocalAdmin::mx_paPropid[] = {	PROPID_QM_MACHINE_ID,
													PROPID_QM_SERVICE_ROUTING,
													PROPID_QM_SERVICE_DEPCLIENTS,
													PROPID_QM_FOREIGN,
													PROPID_QM_QUOTA,
													PROPID_QM_JOURNAL_QUOTA,
													PROPID_QM_SITE_ID,
													PROPID_QM_OUTFRS,
													PROPID_QM_INFRS,
													PROPID_QM_SERVICE,
													PROPID_QM_SITE_IDS
													};


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::InsertColumns

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString title;

    title.LoadString(IDS_COLUMN_NAME);
    pHeaderCtrl->InsertColumn(0, title, LVCFMT_LEFT, g_dwGlobalWidth);

    return(S_OK);
}

bool IsMQTrigLoadedForWrite()
{
	CRegHandle hKey;
	LONG rc = RegOpenKeyEx(
						HKEY_LOCAL_MACHINE,
						REGKEY_TRIGGER_PARAMETERS,
						0,
						KEY_ALL_ACCESS,
						&hKey
						);
	if (rc != ERROR_SUCCESS)
	{
		return false;
	}
	return true;
}
	
//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::PopulateScopeChildrenList()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    CString strTitle;

    if (m_fIsDepClient)
    {
        //
        // don't add children if we are on Dep. Client
        //
        return hr;
    }

    //
    // Add a local outgoing queues folder
    //
    CLocalOutgoingFolder * logF;

    strTitle.LoadString(IDS_LOCALOUTGOING_FOLDER);
    logF = new CLocalOutgoingFolder(this, m_pComponentData, m_szMachineName, strTitle);

	AddChild(logF, &logF->m_scopeDataItem);

	if ( !m_fIsWorkgroup )
	{
		// Add a public queues folder
		//
		CLocalPublicFolder * lpubF;

		strTitle.LoadString(IDS_LOCALPUBLIC_FOLDER);
		lpubF = new CLocalPublicFolder(this, m_pComponentData, m_szMachineName, strTitle,
									   m_fUseIpAddress);

		AddChild(lpubF, &lpubF->m_scopeDataItem);
	}

    //
    // Add a private queues folder
    //
    CLocalPrivateFolder * pF;

    strTitle.LoadString(IDS_PRIVATE_FOLDER);
    pF = new CLocalPrivateFolder(this, m_pComponentData, m_szMachineName, strTitle);

	AddChild(pF, &pF->m_scopeDataItem);

    //
    // Add a system queue folder
    //
    {
        CSystemQueues *pSQ; 

        pSQ = new CSystemQueues(this, m_pComponentData, m_szMachineName);
        strTitle.LoadString(IDS_SYSTEM_QUEUES);
        pSQ->m_bstrDisplayName = strTitle;

  	    AddChild(pSQ, &pSQ->m_scopeDataItem);
    }

	//
	// We want to expand the triggers node only if we're on the local machine and if
	// the user has write permissions to the registry.
	//
    if ((m_szMachineName[0] == 0) && IsMQTrigLoadedForWrite())
    {
		try
		{
			//
			// For local machine add MSMQ Trigger folder
			//
			CTriggerLocalAdmin* pTrig = new CTriggerLocalAdmin(this, m_pComponentData, m_szMachineName);
			
			strTitle.LoadString(IDS_MSMQ_TRIGGERS);
			pTrig->m_bstrDisplayName = strTitle;

			AddChild(pTrig, &pTrig->m_scopeDataItem);
		}
		catch (const _com_error&)
		{
		}
    }


    return(hr);

}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::SetVerbs

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hr;
    //
    // Display verbs that we support
    //
    hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );
    hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );

    // We want the default verb to be Properties
	hr = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    return(hr);
}

void CSnapinLocalAdmin::SetState(LPCWSTR pszState, bool fRefreshIcon)
{
	if(wcscmp(pszState, MSMQ_CONNECTED) == 0)
	{
		SetIcons(IMAGE_PRODUCT_ICON, IMAGE_PRODUCT_ICON);
		m_bConnected = true;
	}
	else if(wcscmp(pszState, MSMQ_DISCONNECTED) == 0)
	{
		SetIcons(IMAGE_PRODUCT_NOTCONNECTED, IMAGE_PRODUCT_NOTCONNECTED);
		m_bConnected = false;
	}
    else
    {
        ASSERT(0);
    }
    //
    // Refresh icon if needed & asked to
    //
    if (fRefreshIcon)
    {
        CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_pComponentData->m_spConsole); 
        spConsoleNameSpace->SetItem(&m_scopeDataItem);
    }
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::UpdateState

  Updates the "Message Queuing" Object's Icon and state (Online / offline)
--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::UpdateState(bool fRefreshIcon)
{
    if (IsThisMachineDepClient())
    {
        SetState(MSMQ_CONNECTED, fRefreshIcon);
        return S_OK;
    }

	MQMGMTPROPS	  mqProps;
    PROPVARIANT   PropVar;

    //
    // Retreive the Connected state of the QM
    //
    PROPID        PropId = PROPID_MGMT_MSMQ_CONNECTED;
    PropVar.vt = VT_NULL;

    mqProps.cProp = 1;
    mqProps.aPropID = &PropId;
    mqProps.aPropVar = &PropVar;
    mqProps.aStatus = NULL;

    HRESULT hr = MQMgmtGetInfo((m_szMachineName == TEXT("")) ? (LPCWSTR)NULL : m_szMachineName, 
			        		   MO_MACHINE_TOKEN, &mqProps);

    if(FAILED(hr))
    {
        TRACE(_T("CSnapinLocalAdmin::UpdateState: MQMgmtGetInfo failed on %s. Error = %X"), m_szMachineName, hr);                
        return hr;
    }

    ASSERT(PropVar.vt == VT_LPWSTR);

    SetState(PropVar.pwszVal, fRefreshIcon);

    MQFreeMemory(PropVar.pwszVal);

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::UpdateMenuState

      Called when context menu is created. Used to enable/disable menu items.


--*/
//////////////////////////////////////////////////////////////////////////////
void CSnapinLocalAdmin::UpdateMenuState(UINT id, LPTSTR /*pBuf*/, UINT *pflags)
{
    //
    // We want to open the menu according to the right state, but
    // we do not want to change the icon until the user choose "Refresh". 
    // Otherwise users may think that the state (Online / Offline) was changed
    // because they right clicked "Message Queuing" while in fact it was changed
    // by some other application / user.
    // YoelA - 28-Nov-2001
    //

	//
	//	We don't care if we failed to update the icon state
	//
	UpdateState(false);
	

	//
	// Gray out menu when in Connected state
	//
	if(m_bConnected)
	{

		if (id == ID_MENUITEM_LOCALADM_CONNECT)
			*pflags |= MFS_DISABLED;

		return;
	}

	//
	// Gray out menu when in Disconnected state
	//
	if(!m_bConnected)
	{
		if (id == ID_MENUITEM_LOCALADM_DISCONNECT)
			*pflags |= MFS_DISABLED;

		return;
	}

	return;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::OnConnect


      Called when menu item is selected


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::OnConnect(bool & /*bHandled*/, CSnapInObjectRootBase * /*pSnapInObjectRoot*/)
{

	HRESULT hr;
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT(!m_bConnected);

    CString strConfirmation;

    if (!ConfirmConnection(IDS_CONNECT_QUESTION))
    {
        return S_OK;
    }
	
	//
	// Connect
	//
	hr = MQMgmtAction((m_szMachineName == TEXT("")) ? (LPCWSTR)NULL : m_szMachineName, 
                       MO_MACHINE_TOKEN,MACHINE_ACTION_CONNECT);

    if(FAILED(hr))
    {
        //
        // If failed, just display a message
        //
        MessageDSError(hr,IDS_OPERATION_FAILED);
        return(hr);
    }

	//
	// We are OK 
	// Change the ICON to connect state
	//
    SetState(MSMQ_CONNECTED, true);

    return(S_OK);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::OnDisconnect


      Called when menu item is selected


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::OnDisconnect(bool & /*bHandled*/, CSnapInObjectRootBase * /*pSnapInObjectRoot*/)
{

	HRESULT hr;
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT(m_bConnected);

    if (!ConfirmConnection(IDS_DISCONNECT_QUESTION))
    {
        return S_OK;
    }

	//
	// Connect
	//
	hr = MQMgmtAction((m_szMachineName == TEXT("")) ? (LPCWSTR)NULL : m_szMachineName, 
                       MO_MACHINE_TOKEN,MACHINE_ACTION_DISCONNECT);

    if(FAILED(hr))
    {
        //
        // If failed, just display a message
        //
        MessageDSError(hr,IDS_OPERATION_FAILED);
        return(hr);
    }

	//
	// We are OK 
	// Change the ICON to disconnect state
	//
    SetState(MSMQ_DISCONNECTED, true);

    return(S_OK);

}

//
// ConfirmConnection - Ask for confirmation for connect / disconnect
//
BOOL CSnapinLocalAdmin::ConfirmConnection(UINT nFormatID)
{
    CString strConfirmation;

    //
    // strThisComputer is either the computer name or "this computer" for local
    //
    CString strThisComputer;
    if (m_szMachineName != TEXT(""))
    {
        strThisComputer = m_szMachineName;
    }
    else
    {
        strThisComputer.LoadString(IDS_THIS_COMPUTER);
    }

    //
    // Are you sure you want to take Message Queuing on *this computer* offline / online?
    //
    strConfirmation.FormatMessage(nFormatID, strThisComputer);
    if (IDYES == AfxMessageBox(strConfirmation, MB_YESNO))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CheckEnvironment

  Check the site environment. This function will initialize the
  flag that is checked on mobile tab display.
  The mobile tab should be displayed only when:
  1. The client is not in workgroup mode AND
  2. The registry key 'MSMQ\Parameters\ServersCache' exists AND
  3. The work is done in MQIS mode

  In all other cases the mabile tab is irrelevant

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSnapinLocalAdmin::CheckEnvironment(
	BOOL fIsWorkgroup,									
	BOOL* pfIsNT4Env
	)
{
	*pfIsNT4Env = FALSE;

	if ( fIsWorkgroup )
	{
		return S_OK;
	}

	WCHAR wszRegPath[512];
	wcscpy(wszRegPath, FALCON_REG_KEY);
	wcscat(wszRegPath, L"\\");
	wcscat(wszRegPath, MSMQ_SERVERS_CACHE_REGNAME);

	HKEY hKey;
	DWORD dwRes = RegOpenKeyEx(
						FALCON_REG_POS,
						wszRegPath,
						0,
						KEY_READ,
						&hKey
						);

	CRegHandle hAutoKey(hKey);

	if ( dwRes != ERROR_SUCCESS && dwRes != ERROR_FILE_NOT_FOUND )
	{
		return HRESULT_FROM_WIN32(dwRes);
	}

	if ( dwRes != ERROR_SUCCESS )
	{
		return S_OK;
	}

	if ( ADGetEnterprise() == eMqis )
	{
		*pfIsNT4Env = TRUE;
	}

	return S_OK;
}	


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::InitServiceFlagsInternal

  Get registry key and initilize MSMQ flags

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::InitServiceFlagsInternal()
{
	//
    // Check if MSMQ Dep. Client
    //    
    DWORD dwType = REG_SZ ;
    TCHAR szRemoteMSMQServer[ MAX_PATH ];
    DWORD dwSize = sizeof(szRemoteMSMQServer) ;
    HRESULT rc = GetFalconKeyValue( RPC_REMOTE_QM_REGNAME,
                                    &dwType,
                                    (PVOID) szRemoteMSMQServer,
                                    &dwSize ) ;
    if(rc == ERROR_SUCCESS)
    {
        //
        // Dep. Client
        //
        m_fIsDepClient = TRUE;      
        return S_OK;
    } 
    
    m_fIsDepClient = FALSE;    

    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    DWORD dwValue;
    rc = GetFalconKeyValue(MSMQ_MQS_ROUTING_REGNAME,
                           &dwType,
                           &dwValue,
                           &dwSize);
    if (rc != ERROR_SUCCESS) 
    {
        return HRESULT_FROM_WIN32(rc);
    }
    m_fIsRouter = (dwValue!=0);

    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    rc = GetFalconKeyValue( MSMQ_MQS_DSSERVER_REGNAME,
                            &dwType,
                            &dwValue,
                            &dwSize);
    if (rc != ERROR_SUCCESS) 
    {
        return HRESULT_FROM_WIN32(rc);
    }
    m_fIsDs = (dwValue!=0);

	//
	// Check if local account
	//
    BOOL fLocalUser =  FALSE ;
    rc = MQSec_GetUserType( NULL,
                           &fLocalUser,
                           NULL ) ;
	if ( FAILED(rc) )
	{
		return rc;
	}

	if ( fLocalUser )
	{
		m_fIsLocalUser = TRUE;
	}

    return CheckEnvironment(m_fIsWorkgroup, &m_fIsNT4Env);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::InitServiceFlags

  Called when creating a control panel property pages

--*/
//////////////////////////////////////////////////////////////////////////////
void CSnapinLocalAdmin::InitServiceFlags()
{
	HRESULT hr = InitAllMachinesFlags();
	if (FAILED(hr))
	{
        MessageDSError(hr, IDS_OP_DISPLAY_PAGES);
		return;
    }

	//
	// All further checks are relevant only for local machine
	//
	if (m_szMachineName[0] != 0)
	{
		return;
	}


    hr = InitServiceFlagsInternal();
    if (FAILED(hr))
    {
        MessageDSError(hr, IDS_OP_DISPLAY_PAGES);                
    }
    else
    {       
        //
        // BUGBUG: we do not show control panel pages
        // on cluster machine
        // Bug 5794 falcon database
        //
        m_fAreFlagsInitialized = TRUE;     
    }
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::InitAllMachinesFlags

  Called when creating the object

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::InitAllMachinesFlags()
{
	//
	// Find the real name of this computer.
	// m_szMachineName id NULL for local computer.
	//
	if (m_szMachineName[0] == 0)
	{
		GetComputerNameIntoString(m_strRealComputerName);
	}
	else
	{
		m_strRealComputerName = m_szMachineName;
	}

	m_strRealComputerName.MakeUpper();

	//
	// Read keys from registry
	//
	CRegHandle hKey;
	DWORD dwRes = RegOpenKeyEx(
						FALCON_REG_POS,
						FALCON_REG_KEY,
						0,
						KEY_READ,
						&hKey
						);

	if ( dwRes != ERROR_SUCCESS )
	{
		return HRESULT_FROM_WIN32(dwRes);
	}

	DWORD dwVal = 0;
	DWORD dwSizeVal = sizeof(DWORD);
	DWORD dwType = REG_DWORD;

	dwRes = RegQueryValueEx(
					hKey,
					MSMQ_WORKGROUP_REGNAME,
					0,
					&dwType,
					reinterpret_cast<LPBYTE>(&dwVal),
					&dwSizeVal
					);
	
	if ( dwRes != ERROR_SUCCESS && dwRes != ERROR_FILE_NOT_FOUND )
	{
		return HRESULT_FROM_WIN32(dwRes);
	}

	if ( dwRes == ERROR_SUCCESS && dwVal == 1 )
	{
		m_fIsWorkgroup = TRUE;
	}

	return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::GetMachineProperties

  Called when creating the object

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CSnapinLocalAdmin::GetMachineProperties()
{
	HRESULT hr = m_propMap.GetObjectProperties(
										MQDS_MACHINE, 
										MachineDomain(m_szMachineName),
										false,		// fServerName
										m_strRealComputerName,
										TABLE_SIZE(mx_paPropid),
										mx_paPropid
										);
										
	return (SUCCEEDED(hr));
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::IsForeign

  Is this a foreign computer

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CSnapinLocalAdmin::IsForeign()
{
	PROPVARIANT propVar;
	PROPID pid = PROPID_QM_FOREIGN;

	if (m_propMap.Lookup(pid, propVar))
	{
		return propVar.bVal;
	}

	return FALSE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::IsServer

  Is this a server computer

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CSnapinLocalAdmin::IsServer()
{
	PROPVARIANT propVar;
	PROPID pid = PROPID_QM_SERVICE_DEPCLIENTS;

	if (m_propMap.Lookup(pid, propVar))
	{
		return propVar.bVal;
	}

	return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::IsRouter

  Is this a Router computer

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CSnapinLocalAdmin::IsRouter()
{
	PROPVARIANT propVar;
	PROPID pid = PROPID_QM_SERVICE_ROUTING;

	if (m_propMap.Lookup(pid, propVar))
	{
		return propVar.bVal;
	}

	return FALSE;
}
//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CreatePropertyPages

  Called when creating a property page of the object

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR /*handle*/, 
	IUnknown* /*pUnk*/,
	DATA_OBJECT_TYPES type)
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (type == CCT_SCOPE || type == CCT_RESULT)
	{   
        HRESULT hr = S_OK;
		BOOL fRetrievedMachineData = GetMachineProperties();
		BOOL fForeign = IsForeign();
		BOOL fIsClusterVirtualServer = IsClusterVirtualServer(m_strRealComputerName);

		if (fRetrievedMachineData || 
			((m_szMachineName[0] == 0) && m_fIsWorkgroup))
		{
			HPROPSHEETPAGE hGeneralPage = 0;
			hr = CreateGeneralPage (&hGeneralPage, fRetrievedMachineData, m_fIsWorkgroup, fForeign);
			if (SUCCEEDED(hr))
			{
				lpProvider->AddPage(hGeneralPage); 
			}
			else
			{
				MessageDSError(hr, IDS_OP_DISPLAY_GENERAL_PAGE);
			}
		}

        if (m_szMachineName[0] == 0 && m_fAreFlagsInitialized)
        {
            //
            // it is local computer and all flags from registry were
            // initialized successfully. It is not cluster machine also.
            // So, we have to add pages which were on control panel
            //     
            //
            // BUGBUG: currently we do not show control panel pages 
            // on cluster machine since all get/set registry operation
            // must be performed differently.
            // When we'll add this support we have to change the code
            // in storage.cpp too where we set/get registry and work with
            // directory. Maybe there is problem on other pages too.
            // Bug 5794 falcon database
            //

           
            //
            // add storage page on all computers except Dep. Client 
			// and cluster virtual server
            //        
			if (!m_fIsDepClient && !fIsClusterVirtualServer)
            {
                HPROPSHEETPAGE hStoragePage = 0;
                hr = CreateStoragePage (&hStoragePage);
                if (SUCCEEDED(hr))
                {
                    lpProvider->AddPage(hStoragePage); 
                }
                else
                {
                    MessageDSError(hr, IDS_OP_DISPLAY_STORAGE_PAGE);
                }
            }

            //
            // add Client page on Ind. Client
            //
            if (m_fIsDepClient)
            {
                HPROPSHEETPAGE hClientPage = 0;
                hr = CreateClientPage (&hClientPage);
                if (SUCCEEDED(hr))
                {
                    lpProvider->AddPage(hClientPage); 
                }
                else
                {
                    MessageDSError(hr, IDS_OP_DISPLAY_CLIENT_PAGE);
                }
            }

            //
            // add Local User Certificate page if the computer is not in
			// WORKGROUP mode, or the user is not local
            //
			if (!m_fIsWorkgroup && !m_fIsLocalUser)
			{
				HPROPSHEETPAGE hLocalUserCertPage = 0;
				hr = CreateLocalUserCertPage (&hLocalUserCertPage);
				if (SUCCEEDED(hr))
				{
					lpProvider->AddPage(hLocalUserCertPage); 
				}
				else
				{
					MessageDSError(hr, IDS_OP_DISPLAY_MSMQSECURITY_PAGE);
				}
			}
        
            //
            // add Mobile page if we run on Ind. Client
            //        
            if (!m_fIsRouter && !m_fIsDs && !m_fIsDepClient && m_fIsNT4Env)
            {
                HPROPSHEETPAGE hMobilePage = 0;
                hr = CreateMobilePage (&hMobilePage);
                if (SUCCEEDED(hr))
                {
                    lpProvider->AddPage(hMobilePage);
                }
                else
                {
                    MessageDSError(hr, IDS_OP_DISPLAY_MOBILE_PAGE);
                }            
            }

            //
            // add Service Security page on all computers running MSMQ
			// except WORKGROUP computers
            //
			if ( !m_fIsWorkgroup && !m_fIsDepClient)
			{
				HPROPSHEETPAGE hServiceSecurityPage = 0;
				hr = CreateServiceSecurityPage (&hServiceSecurityPage);
				if (SUCCEEDED(hr))
				{
					lpProvider->AddPage(hServiceSecurityPage);
				}
				else
				{
					MessageDSError(hr, IDS_OP_DISPLAY_SRVAUTH_PAGE);
				}
			}


			if (!m_fIsDepClient && !fIsClusterVirtualServer)
			{
				HPROPSHEETPAGE hSecurityOptionsPage = 0;
				hr = CreateSecurityOptionsPage(&hSecurityOptionsPage);
				if (SUCCEEDED(hr))
				{
					lpProvider->AddPage(hSecurityOptionsPage); 
				}
				else
				{
					MessageDSError(hr, IDS_OP_DISPLAY_SECURITY_OPTIONS_PAGE);
				}
			}
        }

		if (fRetrievedMachineData)
		{
			if (!fForeign)
			{
				//if not Routing machine, create routing page
				
				if(!IsRouter())
				{
					//
					// Create Routing page
					//
					HPROPSHEETPAGE hRoutingPage = 0;
					hr = CreateRoutingPage (&hRoutingPage);
					if (SUCCEEDED(hr))
					{
						lpProvider->AddPage(hRoutingPage);
					}
					else
					{
						MessageDSError(hr, IDS_OP_DISPLAY_ROUTING_PAGE);
					}
				}

				if (IsServer())
				{
					//
					// Create Dependent Clients page
					//
					HPROPSHEETPAGE hDepPage = 0;
					hr = CreateDepClientsPage (&hDepPage);
					if (SUCCEEDED(hr))
					{
						lpProvider->AddPage(hDepPage);
					}
					else
					{
						MessageDSError(hr, IDS_OP_DISPLAY_DEPCLI_PAGE);
					}
				}
				
			}

			PROPVARIANT propVar;
			PROPID pid = PROPID_QM_SITE_IDS;
			if (m_propMap.Lookup(pid, propVar))
			{
				HPROPSHEETPAGE hSitesPage = 0;
				hr = CreateSitesPage (&hSitesPage);
				if (SUCCEEDED(hr))
				{
					lpProvider->AddPage(hSitesPage);
				}
				else
				{
					MessageDSError(hr, IDS_OP_DISPLAY_SITES_PAGE);
				}
			}

			if (!fForeign)
			{
				// 
				// Create Diagnostics page
				//
				HPROPSHEETPAGE hDiagPage = 0;
				hr = CreateDiagPage (&hDiagPage);
				if (SUCCEEDED(hr))
				{
					lpProvider->AddPage(hDiagPage);
				}
				else
				{
					MessageDSError(hr, IDS_OP_DISPLAY_DIAG_PAGE);
				}
			}
		}

		//
        // must be last page: create machine security page
        // don't add this page on/for Dep. Client
        //
        if (!m_fIsDepClient)  
        {
            HPROPSHEETPAGE hSecurityPage = 0;
            hr = CreateMachineSecurityPage(
					&hSecurityPage, 
					m_szMachineName, 
					MachineDomain(m_szMachineName), 
					false	// fServerName
					);

            if (SUCCEEDED(hr))
            {
                lpProvider->AddPage(hSecurityPage); 
            }
            else
            {
                MessageDSError(hr, IDS_OP_DISPLAY_SECURITY_PAGE);
            }
        }
        
        return(S_OK);
	}
	return E_UNEXPECTED;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::UpdatePageDataFromPropMap

  Called when creating a general property page of the object (data comes from AD)

--*/
//////////////////////////////////////////////////////////////////////////////
void CSnapinLocalAdmin::UpdatePageDataFromPropMap(CComputerMsmqGeneral *pcpageGeneral)
{
	TrTRACE(GENERAL, "Data for machine %ls is from AD", m_strRealComputerName);

	PROPVARIANT propVar;
	PROPID pid;

	//
	// PROPID_QM_MACHINE_ID
	//
	pid = PROPID_QM_MACHINE_ID;
	VERIFY(m_propMap.Lookup(pid, propVar));
	pcpageGeneral->m_guidID = *propVar.puuid;    

	//
	// PROPID_QM_QUOTA
	//
	pid = PROPID_QM_QUOTA;
	VERIFY(m_propMap.Lookup(pid, propVar));
	pcpageGeneral->m_dwQuota = propVar.ulVal;

	//
	// PROPID_QM_JOURNAL_QUOTA
	//
	pid = PROPID_QM_JOURNAL_QUOTA;
	VERIFY(m_propMap.Lookup(pid, propVar));
	pcpageGeneral->m_dwJournalQuota = propVar.ulVal;

	//
	// Service type
	//
	pid = PROPID_QM_SERVICE_ROUTING;
	VERIFY(m_propMap.Lookup(pid, propVar));
	BOOL fRout= propVar.bVal;

	pid = PROPID_QM_SERVICE_DEPCLIENTS;
	VERIFY(m_propMap.Lookup(pid, propVar));
	BOOL fDepCl= propVar.bVal;

	pid = PROPID_QM_FOREIGN;
	VERIFY(m_propMap.Lookup(pid, propVar));
	BOOL fForeign = propVar.bVal;

	pcpageGeneral->m_strService = MsmqServiceToString(fRout, fDepCl, fForeign);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::UpdatePageDataFromRegistry

  Called when creating a general property page of the object (data comes from registry)

--*/
//////////////////////////////////////////////////////////////////////////////
LONG CSnapinLocalAdmin::UpdatePageDataFromRegistry(CComputerMsmqGeneral *pcpageGeneral)
{
	TrTRACE(GENERAL, "Data for machine %ls is from registry", m_strRealComputerName);

	//
	// Read QM GUID from registry
	//
	GUID QmGUID;
	DWORD dwValueType = REG_BINARY ;
	DWORD dwValueSize = sizeof(GUID);
	LONG rc = GetFalconKeyValue(
						MSMQ_QMID_REGNAME,
						&dwValueType,
						&QmGUID,
						&dwValueSize);
	if (FAILED(rc))
	{
		return rc;
	}

	pcpageGeneral->m_guidID = QmGUID;
	

	//
	// Read machine quota from registry
	//
	DWORD dwQuota;
	dwValueType = REG_DWORD;
	dwValueSize = sizeof(DWORD);
	DWORD defaultValue = DEFAULT_QM_QUOTA;

	rc = GetFalconKeyValue(
					MSMQ_MACHINE_QUOTA_REGNAME,
					&dwValueType,
					&dwQuota,
					&dwValueSize,
					(LPCTSTR)&defaultValue
					);
	if (FAILED(rc))
	{
		return rc;
	}

	pcpageGeneral->m_dwQuota = dwQuota;


	//
	// Read machine journal quota from registry
	//
	DWORD dwJournalQuota;
	dwValueType = REG_DWORD;
	dwValueSize = sizeof(DWORD);
	defaultValue = DEFAULT_QM_QUOTA;

	rc = GetFalconKeyValue(
					MSMQ_MACHINE_JOURNAL_QUOTA_REGNAME,
					&dwValueType,
					&dwJournalQuota,
					&dwValueSize,
					(LPCTSTR)&defaultValue
					);
	if (FAILED(rc))
	{
		return rc;
	}

	pcpageGeneral->m_dwJournalQuota = dwJournalQuota;

	//
	// Create machine type string from local data, that was previously retrieved
	// If we look at local registry this is not a foreign computer
	//
	pcpageGeneral->m_strService = MsmqServiceToString(m_fIsRouter, m_fIsDs, FALSE);

	return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CreateGeneralPage

  Called when creating a general property page of the object (from control panel)

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CSnapinLocalAdmin::CreateGeneralPage(
							OUT HPROPSHEETPAGE *phGeneralPage, 
							BOOL fRetrievedMachineData,
							BOOL fIsWorkgroup,
							BOOL fForeign)
{   
    CComputerMsmqGeneral *pcpageGeneral = new CComputerMsmqGeneral();

	pcpageGeneral->SetWorkgroup(fIsWorkgroup);
	pcpageGeneral->SetForeign(fForeign);
    pcpageGeneral->m_strMsmqName = m_strRealComputerName;
    pcpageGeneral->m_fLocalMgmt = TRUE;

	if (fRetrievedMachineData)
	{
		UpdatePageDataFromPropMap(pcpageGeneral);
	}
	else
	{
		LONG rc = UpdatePageDataFromRegistry(pcpageGeneral);
		if (FAILED(rc))
		{
			return rc;
		}
	}

    HPROPSHEETPAGE hPage = pcpageGeneral->CreateThemedPropertySheetPage();
    if (hPage)
    {
        *phGeneralPage = hPage;
    }
    else 
    {
        ASSERT(0);
        return E_UNEXPECTED;    
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CreateStoragePage

  Called when creating a storage property page of the object (from control panel)

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::CreateStoragePage (OUT HPROPSHEETPAGE *phStoragePage)
{   
    CStoragePage *pcpageStorage = new CStoragePage;

    HPROPSHEETPAGE hPage = pcpageStorage->CreateThemedPropertySheetPage();
    if (hPage)
    {
        *phStoragePage = hPage;
    }
    else 
    {
        ASSERT(0);
        return E_UNEXPECTED;    
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CreateSecurityOptionsPage

  Called when creating a security property page of the object (from control panel)

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::CreateSecurityOptionsPage (OUT HPROPSHEETPAGE *phSecurityOptionsPage)
{   
    CSecurityOptionsPage *pcpageSecurityOptions = new CSecurityOptionsPage();
    pcpageSecurityOptions->SetMSMQName(m_strRealComputerName);
    
    HPROPSHEETPAGE hPage = pcpageSecurityOptions->CreateThemedPropertySheetPage();
    if (hPage)
    {
        *phSecurityOptionsPage = hPage;
    }
    else 
    {
        ASSERT(0);
        return E_UNEXPECTED;    
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CreateLocalUserCertPage

  Called when creating a MSMQ Security property page of the object (from control panel)

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::CreateLocalUserCertPage (
                   OUT HPROPSHEETPAGE *phLocalUserCertPage)
{       
    CLocalUserCertPage *pcpageLocalUserCert = new CLocalUserCertPage();

    HPROPSHEETPAGE hPage = pcpageLocalUserCert->CreateThemedPropertySheetPage();
    if (hPage)
    {
        *phLocalUserCertPage = hPage;
    }
    else 
    {
        ASSERT(0);
        return E_UNEXPECTED;    
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CreateMobilePage

  Called when creating a mobile property page of the object (from control panel)

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::CreateMobilePage (OUT HPROPSHEETPAGE *phMobilePage)
{       
    CMobilePage *pcpageMobile = new CMobilePage;

    HPROPSHEETPAGE hPage = pcpageMobile->CreateThemedPropertySheetPage();
    if (hPage)
    {
        *phMobilePage = hPage;
    }
    else 
    {
        ASSERT(0);
        return E_UNEXPECTED;    
    }    
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CreateClientPage

  Called when creating a client property page of the object (from control panel)

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::CreateClientPage (OUT HPROPSHEETPAGE *phClientPage)
{
    CClientPage *pcpageClient = new CClientPage;

    HPROPSHEETPAGE hPage = pcpageClient->CreateThemedPropertySheetPage(); 
    if (hPage)
    {
        *phClientPage = hPage;
    }
    else 
    {
        ASSERT(0);
        return E_UNEXPECTED;    
    }    
    
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CreateRoutingPage

  Called when creating a diagnostic property page of the object (from control panel)

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::CreateRoutingPage (OUT HPROPSHEETPAGE *phRoutingPage)
{
    PROPVARIANT propVar;
    PROPID pid;

    CComputerMsmqRouting *pcpageRouting = new CComputerMsmqRouting();
    pcpageRouting->m_strMsmqName = m_strRealComputerName;
    pcpageRouting->m_fLocalMgmt = TRUE;

	//
	// PROPID_QM_SITE_IDS
	//
	pid = PROPID_QM_SITE_IDS;
	VERIFY(m_propMap.Lookup(pid, propVar));
	pcpageRouting->InitiateSiteIDsValues(&propVar.cauuid);

	//
	// PROPID_QM_OUTFRS
	//
	pid = PROPID_QM_OUTFRS;
	VERIFY(m_propMap.Lookup(pid, propVar));
	pcpageRouting->InitiateOutFrsValues(&propVar.cauuid);

	//
	// PROPID_QM_INFRS
	//
	pid = PROPID_QM_INFRS;
	VERIFY(m_propMap.Lookup(pid, propVar));
	pcpageRouting->InitiateInFrsValues(&propVar.cauuid);
    
	HPROPSHEETPAGE hPage = pcpageRouting->CreateThemedPropertySheetPage(); 
    if (hPage)
    {
        *phRoutingPage = hPage;
    }
    else 
    {
        ASSERT(0);
        return E_UNEXPECTED;    
    }    
    
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CreateDepClientsPage

  Called when creating a diagnostic property page of the object (from control panel)

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::CreateDepClientsPage (OUT HPROPSHEETPAGE *phDependentPage)
{
    CDependentMachine* pDependentPage = new CDependentMachine;

    //
    // PROPID_QM_MACHINE_ID
    //
	PROPVARIANT propVar;
	PROPID pid = PROPID_QM_MACHINE_ID;
	VERIFY(m_propMap.Lookup(pid, propVar));
	pDependentPage->SetMachineId(propVar.puuid);

    HPROPSHEETPAGE hPage = pDependentPage->CreateThemedPropertySheetPage(); 
    if (hPage)
    {
        *phDependentPage = hPage;
    }
    else 
    {
        ASSERT(0);
        return E_UNEXPECTED;    
    }    
    
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CreateSitesPage

  Called when creating a sites property page of the object (from control panel)

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::CreateSitesPage (OUT HPROPSHEETPAGE *phSitesPage)
{
    PROPVARIANT propVar;
    PROPID pid;

    //
    // Retrieve the service in order to pass TRUE for server and FALSE 
    // for client to CComputerMsmqSites.
    //
    pid = PROPID_QM_SERVICE;
    VERIFY(m_propMap.Lookup(pid, propVar));

    CComputerMsmqSites *pcpageSites = new CComputerMsmqSites(propVar.ulVal != SERVICE_NONE);
    pcpageSites->m_strMsmqName = m_strRealComputerName;
    pcpageSites->m_fLocalMgmt = TRUE;

    //
    // PROPID_QM_SITE_IDS
    //
    pid = PROPID_QM_SITE_IDS;
    VERIFY(m_propMap.Lookup(pid, propVar));

    //
    // Sets m_aguidSites from CACLSID
    //
    CACLSID const *pcaclsid = &propVar.cauuid;
    for (DWORD i=0; i<pcaclsid->cElems; i++)
    {
        pcpageSites->m_aguidSites.SetAtGrow(i,((GUID *)pcaclsid->pElems)[i]);
    }

    //
    // PROPID_QM_FOREIGN
    //
    pid = PROPID_QM_FOREIGN;
    VERIFY(m_propMap.Lookup(pid, propVar));
    pcpageSites->m_fForeign = propVar.bVal;
    
	HPROPSHEETPAGE hPage = pcpageSites->CreateThemedPropertySheetPage();
    if (hPage)
    {
        *phSitesPage = hPage;
    }
    else 
    {
        ASSERT(0);
        return E_UNEXPECTED;    
    }    
    
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CreateDiagPage

  Called when creating a diagnostic property page of the object (from control panel)

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::CreateDiagPage (OUT HPROPSHEETPAGE *phPageDiag)
{
    CComputerMsmqDiag *pcpageDiag = new CComputerMsmqDiag();

    pcpageDiag->m_strMsmqName = m_strRealComputerName;
    pcpageDiag->m_fLocalMgmt = TRUE;

    //
    // PROPID_QM_MACHINE_ID
    //
	PROPVARIANT propVar;
	PROPID pid;

	pid = PROPID_QM_MACHINE_ID;
	VERIFY(m_propMap.Lookup(pid, propVar));
	pcpageDiag->m_guidQM = *propVar.puuid;

    HPROPSHEETPAGE hPage = pcpageDiag->CreateThemedPropertySheetPage();
    if (hPage)
    {
        *phPageDiag = hPage;
    }
    else 
    {
        ASSERT(0);
        return E_UNEXPECTED;    
    }    
    
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinLocalAdmin::CreateServiceSecurityPage

  Called when creating a service security property page of the object (from control panel)

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinLocalAdmin::CreateServiceSecurityPage (OUT HPROPSHEETPAGE *phServiceSecurityPage)
{
    CServiceSecurityPage *pcpageServiceSecurity = 
            new CServiceSecurityPage(m_fIsDepClient, m_fIsDs);

    HPROPSHEETPAGE hPage = pcpageServiceSecurity->CreateThemedPropertySheetPage();
    if (hPage)
    {
        *phServiceSecurityPage = hPage;
    }
    else 
    {
        ASSERT(0);
        return E_UNEXPECTED;    
    }    
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\localadm.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	localadm.h

Abstract:

	Definition for the Local administration
Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __LOCALADM_H_
#define __LOCALADM_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"
#include "snpnerr.h"


class CComputerMsmqGeneral;

/****************************************************

        CSnapinLocalAdmin Class
    
 ****************************************************/

class CSnapinLocalAdmin : public CNodeWithScopeChildrenList<CSnapinLocalAdmin, FALSE>
{
public:
    CString m_szMachineName;

    HRESULT UpdateState(bool fRefreshIcon);

   	BEGIN_SNAPINCOMMAND_MAP(CSnapinLocalAdmin, FALSE)
		SNAPINCOMMAND_ENTRY(ID_MENUITEM_LOCALADM_CONNECT, OnConnect)
		SNAPINCOMMAND_ENTRY(ID_MENUITEM_LOCALADM_DISCONNECT, OnDisconnect)
	END_SNAPINCOMMAND_MAP()

   	SNAPINMENUID(IDR_LOCALADM_MENU)

	CSnapinLocalAdmin(CSnapInItem * pParentNode, CSnapin * pComponentData, CString strComputer) : 
		CNodeWithScopeChildrenList<CSnapinLocalAdmin, FALSE>(pParentNode, pComponentData ),
		m_szMachineName(strComputer),
		//
		// all these flags below are valid only for local admin of LOCAL machine
		//
		m_fIsDepClient(FALSE),
		m_fIsRouter(FALSE),
		m_fIsDs(FALSE),
		m_fAreFlagsInitialized(FALSE),
		m_fIsNT4Env(FALSE),
		m_fIsWorkgroup(FALSE),
		m_fIsLocalUser(FALSE)
	{
		CheckIfIpAddress();

		InitServiceFlags();
	}

	~CSnapinLocalAdmin()
    {
    }

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

	virtual HRESULT PopulateScopeChildrenList();

	virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

	void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags);
	
    HRESULT CreateGeneralPage (
					OUT HPROPSHEETPAGE *phStoragePage, 
					BOOL fRetrievedMachineData, 
					BOOL fIsWorkgroup, 
					BOOL fForeign
					);

    HRESULT CreateStoragePage (OUT HPROPSHEETPAGE *phStoragePage);
    
    HRESULT CreateLocalUserCertPage (OUT HPROPSHEETPAGE *phLocalUserCertPage);

    HRESULT CreateMobilePage (OUT HPROPSHEETPAGE *phMobilePage);

    HRESULT CreateClientPage (OUT HPROPSHEETPAGE *phClientPage);
	
	HRESULT CreateRoutingPage (OUT HPROPSHEETPAGE *phClientPage);
    
	HRESULT CreateDepClientsPage (OUT HPROPSHEETPAGE *phClientPage);

	HRESULT CreateSitesPage (OUT HPROPSHEETPAGE *phClientPage);

    HRESULT CreateDiagPage (OUT HPROPSHEETPAGE *phClientPage);

    HRESULT CreateServiceSecurityPage (OUT HPROPSHEETPAGE *phServiceSecurityPage);

	HRESULT CreateSecurityOptionsPage (OUT HPROPSHEETPAGE *phSecurityOptionsPage);

    const BOOL IsThisMachineDepClient()
    {
        return m_fIsDepClient;
    }

	virtual HRESULT OnRefresh( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				)
    {
        //
		//	We don't care if we failed to update the icon state
		//
		UpdateState(true);
        return CNodeWithScopeChildrenList<CSnapinLocalAdmin, FALSE>::OnRefresh(
             arg, param, pComponentData, pComponent, type);
    }

private:
    
	void SetState(LPCWSTR pszState, bool fRefreshIcon);

	//
	// Menu functions
	//
	HRESULT OnConnect(bool &bHandled, CSnapInObjectRootBase* pObj);
	HRESULT OnDisconnect(bool &bHandled, CSnapInObjectRootBase* pObj);

	BOOL GetMachineProperties();
	void UpdatePageDataFromPropMap(CComputerMsmqGeneral *pcpageGeneral);
	LONG UpdatePageDataFromRegistry(CComputerMsmqGeneral *pcpageGeneral);
	BOOL IsForeign();
	BOOL IsServer();
	BOOL IsRouter();

    //
    // Identify if computer name is an IP address.
    // IP address contains exactly three dots, and the rest are digits
    //
    void CheckIfIpAddress()
    {
        int i = 0;
        int len = m_szMachineName.GetLength();

        DWORD dwNumDots = 0;
        m_fUseIpAddress = TRUE;

        while(i < len)
        {
            if (m_szMachineName[i] == _T('.'))
            {
                dwNumDots++;
            }
            else if (m_szMachineName[i] < _T('0') || m_szMachineName[i] > _T('9'))
            {
                //
                // Not a digit. Can't be an IP address
                //
                m_fUseIpAddress = FALSE;
                break;
            }
            i++;
        }

        if (dwNumDots != 3)
        {
            //
            // Contains more or less than three dots. Can't be an IP address
            //
            m_fUseIpAddress = FALSE;
        }
    }

    BOOL ConfirmConnection(UINT nFormatID);

	bool	m_bConnected;	//MSMQ Currently connected or disconnected
	BOOL    m_fUseIpAddress;    

    //
    // all these flags are valid only for local admin of LOCAL machine
    //
    void InitServiceFlags();
    HRESULT InitAllMachinesFlags();
    HRESULT InitServiceFlagsInternal();
	HRESULT CheckEnvironment(BOOL fIsWorkgroup, BOOL* pfIsNT4Env);
    BOOL   m_fIsDepClient;
    BOOL   m_fIsRouter;
    BOOL   m_fIsDs;
    BOOL   m_fAreFlagsInitialized;
	BOOL   m_fIsNT4Env;
	BOOL   m_fIsWorkgroup;
	BOOL   m_fIsLocalUser;

	CString m_strRealComputerName;
	CPropMap m_propMap;

    static const PROPID mx_paPropid[];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\localq.cpp ===
/*++

Copyright (c) 1995 - 2001 Microsoft Corporation

Module Name:

    localq.cpp

Abstract:

    Implelentation of objects that represent local 
	queues.

Author:

    Nela Karpel (nelak) 26-Jul-2001

Environment:

    Platform-independent.

--*/

#include "stdafx.h"
#include "shlobj.h"
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

#include "uniansi.h"

#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "mqPPage.h"
#include "dataobj.h"
#include "mqDsPage.h"
#include "strconv.h"
#include "QGeneral.h"
#include "QMltcast.h"
#include "Qname.h"
#include "rdmsg.h"
#include "icons.h"
#include "generrpg.h"
#include "dsext.h"
#include "qnmsprov.h"
#include "localfld.h"
#include "localq.h"
#include "SnpQueue.h"
#include "admmsg.h"

#import "mqtrig.tlb" no_namespace
#include "rule.h"
#include "trigger.h"
#include "trigdef.h"
#include "mqcast.h"
#include "qformat.h"
#include "Fn.h"

#include "localq.tmh"

EXTERN_C BOOL APIENTRY RTIsDependentClient(); //implemented in mqrt.dll

const PROPID CQueue::mx_paPropid[] = 
            {
             //
             // Public Queue only properties
             // Note: If you change this, you must change mx_dwNumPublicOnlyProps below!
             //
             PROPID_Q_INSTANCE, 
             PROPID_Q_FULL_PATH,

             //
             // Public & Private queue properties
             //
             PROPID_Q_LABEL,  PROPID_Q_TYPE,
        	 PROPID_Q_QUOTA, PROPID_Q_AUTHENTICATE, PROPID_Q_TRANSACTION,
             PROPID_Q_JOURNAL, PROPID_Q_JOURNAL_QUOTA, PROPID_Q_PRIV_LEVEL,
             PROPID_Q_BASEPRIORITY, PROPID_Q_MULTICAST_ADDRESS};

const DWORD CQueue::mx_dwPropertiesCount = sizeof(mx_paPropid) / sizeof(mx_paPropid[0]);
const DWORD CQueue::mx_dwNumPublicOnlyProps = 2;



/****************************************************

CLocalQueue Class
    
 ****************************************************/
// {B6EDE68C-29CC-11d2-B552-006008764D7A}
static const GUID CLocalQueueGUID_NODETYPE = 
{ 0xb6ede68c, 0x29cc, 0x11d2, { 0xb5, 0x52, 0x0, 0x60, 0x8, 0x76, 0x4d, 0x7a } };

const GUID*  CLocalQueue::m_NODETYPE = &CLocalQueueGUID_NODETYPE;
const OLECHAR* CLocalQueue::m_SZNODETYPE = OLESTR("B6EDE68C-29CC-11d2-B552-006008764D7A");
const OLECHAR* CLocalQueue::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CLocalQueue::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalQueue::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalQueue::PopulateScopeChildrenList()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    CString strTitle;

    //
    // Create a node to Read Messages
    //
    CReadMsg * p = new CReadMsg(this, m_pComponentData, m_szFormatName, m_szMachineName);

    // Pass relevant information
    strTitle.LoadString(IDS_READMESSAGE);
    p->m_bstrDisplayName = strTitle;
    p->SetIcons(IMAGE_QUEUE,IMAGE_QUEUE);

  	AddChild(p, &p->m_scopeDataItem);
  

    //
    // Create the journal queue
    //
    p = new CReadMsg(this, m_pComponentData, m_szFormatName + L";JOURNAL", m_szMachineName);
     
    strTitle.LoadString(IDS_READJOURNALMESSAGE);
    p->m_bstrDisplayName = strTitle;
    p->SetIcons(IMAGE_JOURNAL_QUEUE,IMAGE_JOURNAL_QUEUE);

  	AddChild(p, &p->m_scopeDataItem);

    //
    // Create Trigger definition
    //
    if (m_szMachineName[0] == 0)
    {
		try
		{
			R<CRuleSet> pRuleSet = GetRuleSet(m_szMachineName);
			R<CTriggerSet> pTrigSet = GetTriggerSet(m_szMachineName);

			CTriggerDefinition* pTrigger = new CTriggerDefinition(this, m_pComponentData, pTrigSet.get(), pRuleSet.get(), m_szPathName);
			if (pTrigger == NULL)
				return S_OK;

			strTitle.LoadString(IDS_TRIGGER_DEFINITION);
			pTrigger->m_bstrDisplayName = strTitle;

			AddChild(pTrigger, &pTrigger->m_scopeDataItem);
		}
		catch (const _com_error&)
		{
		}
    }

    return(hr);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalQueue::InsertColumns

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalQueue::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString title;

    title.LoadString(IDS_COLUMN_NAME);
    pHeaderCtrl->InsertColumn(0, title, LVCFMT_LEFT, g_dwGlobalWidth);

    return(S_OK);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalQueue::OnUnSelect

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalQueue::OnUnSelect( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    HRESULT hr;

    hr = pHeaderCtrl->GetColumnWidth(0, &g_dwGlobalWidth);
    return(hr);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalQueue::CreatePropertyPages

  Called when creating a property page of the object

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalQueue::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR /*handle*/, 
	IUnknown* /*pUnk*/,
	DATA_OBJECT_TYPES type)
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	
	if (type == CCT_SCOPE || type == CCT_RESULT)
	{
        if (SUCCEEDED(GetProperties()))
        {
            //--------------------------------------
            //
            // Queue General Page
            //
            //--------------------------------------
            CQueueGeneral *pqpageGeneral = new CQueueGeneral(
													m_fPrivate, 
													true  // Local Managment
													);

            if (0 == pqpageGeneral)
            {
                return E_OUTOFMEMORY;
            }

            HRESULT hr = pqpageGeneral->InitializeProperties(
											m_szPathName, 
											m_propMap, 
											NULL,	// pstrDomainController
											&m_szFormatName
											);

            if FAILED(hr)
            {
                delete pqpageGeneral;
                return hr;
            }

            HPROPSHEETPAGE hPage = pqpageGeneral->CreateThemedPropertySheetPage();

            if (hPage == NULL)
	        {
                delete pqpageGeneral;
		        return E_UNEXPECTED;  
	        }
    
            lpProvider->AddPage(hPage); 

			
			//
			// Queue Multicast Address Page
			// Do not create the page for a dependent client machine
			// or for a transactional queue
			//
			PROPVARIANT propVarTransactional;
			PROPID pid = PROPID_Q_TRANSACTION;
			VERIFY(m_propMap.Lookup(pid, propVarTransactional));

			if ( !RTIsDependentClient() && !propVarTransactional.bVal)
			{
				CQueueMulticast *pqpageMulticast = new CQueueMulticast(
															m_fPrivate, 
															true  // Local Managment
															);
				if (0 == pqpageMulticast)
				{
					return E_OUTOFMEMORY;
				}
            
				hr = pqpageMulticast->InitializeProperties(
										m_szPathName,
										m_propMap,                                     
										NULL,	// pstrDomainController
										&m_szFormatName
										);

				if (FAILED(hr))
				{
					//
					// We can fail to initialize Multicast property.
					// This is the case in MQIS environment, the multicast property
					// for public queue will not be in m_propMap.
					// in that case we will not display the multicast page.
					//
					delete pqpageMulticast;
				}
				else
				{
					hPage = pqpageMulticast->CreateThemedPropertySheetPage();

					if (hPage == NULL)
					{
						delete pqpageMulticast;
						return E_UNEXPECTED;  
					}

					lpProvider->AddPage(hPage);             
				}
			}

            if (m_szPathName != TEXT(""))
            {
                hr = CreateQueueSecurityPage(&hPage, m_szFormatName, m_szPathName);
            }
            else
            {
                hr = CreateQueueSecurityPage(&hPage, m_szFormatName, m_szFormatName);
            }

            if SUCCEEDED(hr)
            {
                lpProvider->AddPage(hPage); 
            }
            else
            {
                MessageDSError(hr, IDS_OP_DISPLAY_SECURITY_PAGE);
            }
        }

        return(S_OK);


	}
	return E_UNEXPECTED;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalQueue::SetVerbs

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalQueue::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hr;
    //
    // Display verbs that we support
    //
    hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );
    hr = pConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );

    // We want the default verb to be Properties
	hr = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    return(hr);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalQueue::OnDelete

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CLocalQueue::OnDelete( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * pComponentData,
	IComponent * pComponent,
	DATA_OBJECT_TYPES /*type*/,
	BOOL /*fSilent*/
	)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString strDeleteQuestion;
    strDeleteQuestion.FormatMessage(IDS_DELETE_QUESTION, m_szPathName);
    if (IDYES != AfxMessageBox(strDeleteQuestion, MB_YESNO))
    {
        return S_FALSE;
    }

	HRESULT hr;
	if(m_fPrivate)
	{
		hr = MQDeleteQueue(m_szFormatName);
	}
	else
	{
		AP<WCHAR> pStrToFree;
		QUEUE_FORMAT QueueFormat;
		if (!FnFormatNameToQueueFormat(m_szFormatName, &QueueFormat, &pStrToFree))
		{
			TrERROR(GENERAL, "FnFormatNameToQueueFormat failed, PathName = %ls", m_szPathName);
			MessageDSError(MQ_ERROR_ILLEGAL_FORMATNAME, IDS_OP_DELETE, m_szPathName);
			return MQ_ERROR_ILLEGAL_FORMATNAME;
		}

		ASSERT(QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PUBLIC);

        hr = ADDeleteObjectGuid(
				eQUEUE,
				MachineDomain(),
				false,		// fServerName
				&QueueFormat.PublicID()
				);
	}


    if (FAILED(hr))
    {
        if (MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION == hr)
        {
            AfxMessageBox(IDS_REMOTE_PRIVATE_QUEUE_OPERATION);
        }
        else
        {
            MessageDSError(hr, IDS_OP_DELETE, m_szPathName);
        }
		TrERROR(GENERAL, "Failed to Delete queue %ls, hr = 0x%x", m_szPathName, hr);
        return hr;
    }
	TrTRACE(GENERAL, "Delete queue %ls", m_szPathName);

	// Need IConsoleNameSpace.

	// But to get that, first we need IConsole
	CComPtr<IConsole> spConsole;
	if( pComponentData != NULL )
	{
		 spConsole = ((CSnapin*)pComponentData)->m_spConsole;
	}
	else
	{
		// We should have a non-null pComponent
		 spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
	}
	ASSERT( spConsole != NULL );

    //
    // Need IConsoleNameSpace
    //
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole); 
	
    //
    // Need to see if this works because of multi node scope
    //

    hr = spConsoleNameSpace->DeleteItem(m_scopeDataItem.ID, TRUE ); 


	if (FAILED(hr))
	{
		return hr;
	}
    
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalQueue::FillData

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CLocalQueue::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
	HRESULT hr = DV_E_CLIPFORMAT;
	ULONG uWritten;

    hr = CDisplayQueue<CLocalQueue>::FillData(cf, pStream);

    if (hr != DV_E_CLIPFORMAT)
    {
        return hr;
    }

	if (cf == gx_CCF_PATHNAME)
	{
		hr = pStream->Write(
            (LPCTSTR)m_szPathName, 
            (m_szPathName.GetLength() + 1) * sizeof(WCHAR), 
            &uWritten);
		return hr;
	}

	return hr;
}


/****************************************************

CPrivateQueue Class
    
****************************************************/
//////////////////////////////////////////////////////////////////////////////
/*++

CPrivateQueue::SetVerbs

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPrivateQueue::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    //
    // Default menu should be displayed for local / unknow location queues only
    //
    if (m_QLocation != PRIVQ_REMOTE)
    {
        return CLocalQueue::SetVerbs(pConsoleVerb);
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPrivateQueue::GetProperties

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPrivateQueue::GetProperties()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = m_propMap.GetObjectProperties(MQDS_QUEUE, 
                                               NULL,	// pDomainController
											   false,	// fServerName
                                               m_szFormatName,
                                               mx_dwPropertiesCount-mx_dwNumPublicOnlyProps,
                                               (mx_paPropid + mx_dwNumPublicOnlyProps),
                                               TRUE);
    if (FAILED(hr))
    {
		if ( hr == MQ_ERROR_QUEUE_NOT_FOUND )
		{
			AfxMessageBox(IDS_PRIVATE_Q_NOT_FOUND);
		}
        else if (MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION == hr)
        {
            AfxMessageBox(IDS_REMOTE_PRIVATE_QUEUE_OPERATION);
        }
        else
        {
            MessageDSError(hr, IDS_OP_GET_PROPERTIES_OF, m_szFormatName);
        }
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPrivateQueue::ApplyCustomDisplay

--*/
//////////////////////////////////////////////////////////////////////////////
void CPrivateQueue::ApplyCustomDisplay(DWORD dwPropIndex)
{
    CLocalQueue::ApplyCustomDisplay(dwPropIndex);

    //
    // For management
    //
    if (m_mqProps.aPropID[dwPropIndex] == PROPID_MGMT_QUEUE_PATHNAME && m_bstrLastDisplay[0] == 0)
    {
        m_bstrLastDisplay = m_bstrDisplayName;
    }
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPrivateQueue::CreateQueueSecurityPage

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPrivateQueue::CreateQueueSecurityPage(HPROPSHEETPAGE *phPage,
                                               IN LPCWSTR lpwcsFormatName, 
                                               IN LPCWSTR lpwcsDescriptiveName)
{
    return CreatePrivateQueueSecurityPage(phPage, lpwcsFormatName, lpwcsDescriptiveName);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPrivateQueue::IsAdminRespQueue
Returns true if this is an admin response queue - providing m_bstrDisplayName was initialized
--*/
//////////////////////////////////////////////////////////////////////////////
bool CPrivateQueue::IsAdminRespQueue()
{
    return (_wcsicmp(m_bstrDisplayName, x_strAdminResponseQName) == 0);
}


/****************************************************

CLocalPublicQueue Class
    
****************************************************/
//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPublicQueue::GetProperties

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPublicQueue::GetProperties()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = m_propMap.GetObjectProperties(MQDS_QUEUE, 
                                               MachineDomain(),
											   false,	// fServerName
                                               m_szPathName,
                                               mx_dwPropertiesCount,
                                               (mx_paPropid));
    if (FAILED(hr))
    {
        IF_NOTFOUND_REPORT_ERROR(hr)
        else
        {
            MessageDSError(hr, IDS_OP_GET_PROPERTIES_OF, m_szFormatName);
        }
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPublicQueue::SetVerbs

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPublicQueue::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    //
    // Default menu should be displayed for local / unknow location queues only
    //
    HRESULT hr;
    if (m_fFromDS)
    {
        hr = CLocalQueue::SetVerbs(pConsoleVerb);
    }
    else
    {
        //
        // Properties and delete are not functioning when there is no DS connection.
        // However, we want them to remain visable, but disabled.
        //
        hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, HIDDEN, FALSE );
        hr = pConsoleVerb->SetVerbState( MMC_VERB_DELETE, HIDDEN, FALSE );
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPublicQueue::CreateQueueSecurityPage

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPublicQueue::CreateQueueSecurityPage(HPROPSHEETPAGE *phPage,
                                IN LPCWSTR lpwcsFormatName,
                                IN LPCWSTR lpwcsDescriptiveName)
{
    if (eAD != ADGetEnterprise())
    {
        // We are working with an NT4 PSC.
        // For NT4, public queue security is done in the same fasion as 
        // private queue security
        //
        return CreatePrivateQueueSecurityPage(phPage, lpwcsFormatName, lpwcsDescriptiveName);
    }

    //
    // We are working with AD
    //
    PROPVARIANT propVarGuid;

    PROPID pidInstance;

    pidInstance = PROPID_Q_INSTANCE;
    VERIFY(m_propMap.Lookup(pidInstance, propVarGuid));
    return CreatePublicQueueSecurityPage(
				phPage, 
				lpwcsDescriptiveName, 
				MachineDomain(), 
				false,	// fServerName 
				propVarGuid.puuid
				);
}



/****************************************************

CLocalOutgoingQueue Class
    
 ****************************************************/
// {B6EDE68F-29CC-11d2-B552-006008764D7A}
static const GUID CLocalOutgoingQueueGUID_NODETYPE = 
{ 0xb6ede68f, 0x29cc, 0x11d2, { 0xb5, 0x52, 0x0, 0x60, 0x8, 0x76, 0x4d, 0x7a } };

const GUID*  CLocalOutgoingQueue::m_NODETYPE = &CLocalOutgoingQueueGUID_NODETYPE;
const OLECHAR* CLocalOutgoingQueue::m_SZNODETYPE = OLESTR("B6EDE68F-29CC-11d2-B552-006008764D7A");
const OLECHAR* CLocalOutgoingQueue::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CLocalOutgoingQueue::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalOutgoingQueue::CLocalOutgoingQueue

--*/
//////////////////////////////////////////////////////////////////////////////
CLocalOutgoingQueue::CLocalOutgoingQueue(
	CLocalOutgoingFolder * pParentNode, 
	CSnapin * pComponentData, 
	BOOL fOnLocalMachine
	) : 
    CDisplayQueue<CLocalOutgoingQueue>(pParentNode, pComponentData)
{
		m_mqProps.cProp = 0;
		m_mqProps.aPropID = NULL;
		m_mqProps.aPropVar = NULL;
		m_mqProps.aStatus = NULL;
        m_aDisplayList = pParentNode->GetDisplayList();
        m_dwNumDisplayProps = pParentNode->GetNumDisplayProps();
        m_fOnLocalMachine = fOnLocalMachine;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalOutgoingQueue::InsertColumns

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalOutgoingQueue::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString title;

    title.LoadString(IDS_COLUMN_NAME);
    pHeaderCtrl->InsertColumn(0, title, LVCFMT_LEFT, g_dwGlobalWidth);

    return(S_OK);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalOutgoingQueue::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalOutgoingQueue::PopulateScopeChildrenList()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());   
    HRESULT hr = S_OK;
    CString strTitle;
    
    //
    // Create a node to Read Messages if on local machine
    //
    if (m_fOnLocalMachine)
    {
        CReadMsg * p = new CReadMsg(this, m_pComponentData, m_szFormatName, L"");

        // Pass relevant information
        strTitle.LoadString(IDS_READMESSAGE);
        p->m_bstrDisplayName = strTitle;
	    p->m_fAdminMode      = MQ_ADMIN_ACCESS;

        p->SetIcons(IMAGE_QUEUE,IMAGE_QUEUE);

   	    AddChild(p, &p->m_scopeDataItem);
    }

    return(hr);

}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalOutgoingQueue::InitState

--*/
//////////////////////////////////////////////////////////////////////////////
void CLocalOutgoingQueue::InitState()
{
    //
    // Set display name
    //
    CString strName;
	GetStringPropertyValue(m_aDisplayList, PROPID_MGMT_QUEUE_PATHNAME, m_mqProps.aPropVar, strName);
	if(strName == L"")
    {
		m_bstrDisplayName = m_szFormatName;
    }
    else
    {
        m_bstrDisplayName = strName;
    }

	//
	// Set queue state
	//
	CString strState;
	m_fOnHold = FALSE;

	GetStringPropertyValue(m_aDisplayList, PROPID_MGMT_QUEUE_STATE, m_mqProps.aPropVar, strState);

	if(strState == MGMT_QUEUE_STATE_ONHOLD)
		m_fOnHold = TRUE;
	
	//
	// Set the right icon
	//
	DWORD icon;
	icon = IMAGE_LOCAL_OUTGOING_QUEUE;
	if(m_fOnHold)
		icon = IMAGE_LOCAL_OUTGOING_QUEUE_HOLD;

	SetIcons(icon, icon);
	return;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalOutgoingQueue::UpdateMenuState

      Called when context menu is created. Used to enable/disable menu items.


--*/
//////////////////////////////////////////////////////////////////////////////
void CLocalOutgoingQueue::UpdateMenuState(UINT id, LPTSTR /*pBuf*/, UINT *pflags)
{

	//
	// Gray out menu when in OnHold state
	//
	if(m_fOnHold == TRUE)
	{

		if (id == ID_MENUITEM_LOCALOUTGOINGQUEUE_PAUSE)
			*pflags |= MFS_DISABLED;

		return;
	}

	//
	// Gray out menu when in connected state
	//
	if(m_fOnHold == FALSE)
	{
		if (id == ID_MENUITEM_LOCALOUTGOINGQUEUE_RESUME)
			*pflags |= MFS_DISABLED;

		return;
	}

	return;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalOutgoingQueue::OnPause


      Called when menu item is selected


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalOutgoingQueue::OnPause(bool & /*bHandled*/, CSnapInObjectRootBase * pSnapInObjectRoot)
{

	HRESULT hr;
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT(m_fOnHold == FALSE);

    CString strConfirmation;

    strConfirmation.FormatMessage(IDS_PAUSE_QUESTION);
    if (IDYES != AfxMessageBox(strConfirmation, MB_YESNO))
    {
        return(S_OK);
    }

    //
	// Pause
	//
	CString szObjectName = L"QUEUE=" + m_szFormatName;
	hr = MQMgmtAction((m_szMachineName == TEXT("")) ? (LPCWSTR)NULL : m_szMachineName, 
                       szObjectName, 
                       QUEUE_ACTION_PAUSE);

    if(FAILED(hr))
    {
        //
        // If failed, just display a message
        //
        MessageDSError(hr,IDS_OPERATION_FAILED);
        return(hr);
    }

	//
	// Refresh disaply
	//
    CComPtr<IConsole> spConsole;

    ASSERT(pSnapInObjectRoot->m_nType == 1 || pSnapInObjectRoot->m_nType == 2);
    if(pSnapInObjectRoot->m_nType == 1)
    {
        //
        // m_nType == 1 means the IComponentData implementation
        //
        CSnapin *pCComponentData = static_cast<CSnapin *>(pSnapInObjectRoot);
        spConsole = pCComponentData->m_spConsole;
    }
    else
    {
        //
        // m_nType == 2 means the IComponent implementation
        //
        CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pSnapInObjectRoot);
        spConsole = pCComponent->m_spConsole;
    }

    //
    // Need IConsoleNameSpace
    //
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_pComponentData->m_spConsole); 

	//
	// We are OK 
	// Change the ICON to disconnect state
	//
	m_scopeDataItem.nImage = IMAGE_LOCAL_OUTGOING_QUEUE_HOLD;  
	m_scopeDataItem.nOpenImage = IMAGE_LOCAL_OUTGOING_QUEUE_HOLD;
	spConsoleNameSpace->SetItem(&m_scopeDataItem);

	//
	// And keep this state
	//
	m_fOnHold = TRUE;

    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return(S_OK);

}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalOutgoingQueue::OnResume


      Called when menu item is selected


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalOutgoingQueue::OnResume(bool & /*bHandled*/, CSnapInObjectRootBase * pSnapInObjectRoot)
{

	HRESULT hr;
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT(m_fOnHold == TRUE);

    CString strConfirmation;

    strConfirmation.FormatMessage(IDS_RESUME_QUESTION);
    if (IDYES != AfxMessageBox(strConfirmation, MB_YESNO))
    {
        return(S_OK);
    }
	
	//
	// Resume
	//
	CString szObjectName = L"QUEUE=" + m_szFormatName;
	hr = MQMgmtAction((m_szMachineName == TEXT("")) ? (LPCWSTR)NULL : m_szMachineName, 
                       szObjectName, 
                       QUEUE_ACTION_RESUME);

    if(FAILED(hr))
    {
        //
        // If failed, just display a message
        //
        MessageDSError(hr,IDS_OPERATION_FAILED);
        return(hr);
    }


	//
	// Refresh disaply
	//
    CComPtr<IConsole> spConsole;

    ASSERT(pSnapInObjectRoot->m_nType == 1 || pSnapInObjectRoot->m_nType == 2);
    if(pSnapInObjectRoot->m_nType == 1)
    {
        //
        // m_nType == 1 means the IComponentData implementation
        //
        CSnapin *pCComponentData = static_cast<CSnapin *>(pSnapInObjectRoot);
        spConsole = pCComponentData->m_spConsole;
    }
    else
    {
        //
        // m_nType == 2 means the IComponent implementation
        //
        CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pSnapInObjectRoot);
        spConsole = pCComponent->m_spConsole;
    }

    //
    // Need IConsoleNameSpace
    //
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_pComponentData->m_spConsole); 

	//
	// We are OK 
	// Change the ICON to disconnect state
	//
	m_scopeDataItem.nImage = IMAGE_LOCAL_OUTGOING_QUEUE;  
	m_scopeDataItem.nOpenImage = IMAGE_LOCAL_OUTGOING_QUEUE;
	spConsoleNameSpace->SetItem(&m_scopeDataItem);

	//
	// And keep this state
	//
	m_fOnHold = FALSE;

    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return(S_OK);

}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalOutgoingQueue::ApplyCustomDisplay

--*/
//////////////////////////////////////////////////////////////////////////////
void CLocalOutgoingQueue::ApplyCustomDisplay(DWORD dwPropIndex)
{
    CDisplayQueue<CLocalOutgoingQueue>::ApplyCustomDisplay(dwPropIndex);

    //
    // If pathname is blank, take the display name (in this case, the format name)
    //
    if (m_mqProps.aPropID[dwPropIndex] == PROPID_MGMT_QUEUE_PATHNAME && 
        (m_bstrLastDisplay == 0 || m_bstrLastDisplay[0] == 0))
    {
        m_bstrLastDisplay = m_bstrDisplayName;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\localfld.cpp ===
/*++

Copyright (c) 1995 - 2001 Microsoft Corporation

Module Name:

    localfld.cpp

Abstract:

    Implelentation of objects that represent local 
	queue folders.

Author:

    Nela Karpel (nelak) 26-Jul-2001

Environment:

    Platform-independent.

--*/

#include "stdafx.h"
#include "rt.h"
#include "mqutil.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "dsext.h"
#include "mqPPage.h"
#include "qname.h"
#include "qnmsprov.h"
#include "dataobj.h"
#include "localfld.h"
#include "localq.h"
#include "privadm.h"
#include "ldaputl.h"

#include "localfld.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



//////////////////////////////////////////////////////////////////////////////
/*++

LocalQueuePropertyToString

	Translates a property value into a string from String Resource file

--*/
//////////////////////////////////////////////////////////////////////////////
static void CALLBACK LocalQueuePropertyToString(const PROPVARIANT *pPropVar, CString &str)
{
	struct 
	{
		const WCHAR *pString;
		DWORD StringId;
	} ItemList[] = 
	{
		{MGMT_QUEUE_TYPE_PUBLIC,         IDS_MGMT_QUEUE_TYPE_PUBLIC},
		{MGMT_QUEUE_TYPE_PRIVATE,        IDS_MGMT_QUEUE_TYPE_PRIVATE},
		{MGMT_QUEUE_TYPE_MACHINE,        IDS_MGMT_QUEUE_TYPE_MACHINE},
		{MGMT_QUEUE_TYPE_CONNECTOR,      IDS_MGMT_QUEUE_TYPE_CONNECTOR},
		{MGMT_QUEUE_STATE_LOCAL,         IDS_MGMT_QUEUE_STATE_LOCAL},
		{MGMT_QUEUE_STATE_NONACTIVE,     IDS_MGMT_QUEUE_STATE_NONACTIVE},
		{MGMT_QUEUE_STATE_WAITING,       IDS_MGMT_QUEUE_STATE_WAITING},
		{MGMT_QUEUE_STATE_NEED_VALIDATE, IDS_MGMT_QUEUE_STATE_NEED_VALIDATE},
		{MGMT_QUEUE_STATE_ONHOLD,        IDS_MGMT_QUEUE_STATE_ONHOLD},
		{MGMT_QUEUE_STATE_CONNECTED,     IDS_MGMT_QUEUE_STATE_CONNECTED},
		{MGMT_QUEUE_STATE_DISCONNECTING, IDS_MGMT_QUEUE_STATE_DISCONNECTING},
		{MGMT_QUEUE_STATE_DISCONNECTED,  IDS_MGMT_QUEUE_STATE_DISCONNECTED},
		{MGMT_QUEUE_LOCAL_LOCATION,      IDS_MGMT_QUEUE_LOCAL_LOCATION},
		{MGMT_QUEUE_REMOTE_LOCATION,     IDS_MGMT_QUEUE_REMOTE_LOCATION},
		{MGMT_QUEUE_UNKNOWN_TYPE,        IDS_MGMT_QUEUE_UNKNOWN_TYPE},
		{MGMT_QUEUE_CORRECT_TYPE,        IDS_MGMT_QUEUE_CORRECT_TYPE},
		{MGMT_QUEUE_INCORRECT_TYPE,      IDS_MGMT_QUEUE_INCORRECT_TYPE},
		{MGMT_QUEUE_STATE_LOCKED,		 IDS_MGMT_QUEUE_STATE_LOCKED},
		{L"",                             0}
	};


	if(pPropVar->vt == VT_NULL)
	{
		str = L"";
		return;
	}

    if (pPropVar->vt == VT_UI1) // Assume boolean value
    {
        if (pPropVar->bVal)
        {
			str.LoadString(IDS_MGMT_QUEUE_CORRECT_TYPE);
        }
        else
        {
			str.LoadString(IDS_MGMT_QUEUE_INCORRECT_TYPE);
        }
        return;
    }

	ASSERT(pPropVar->vt == VT_LPWSTR);
	for(DWORD i = 0; ItemList[i].StringId != 0; i++)
	{
		if(wcscmp(pPropVar->pwszVal, ItemList[i].pString) == 0)
		{
			str.LoadString(ItemList[i].StringId);
			return;
		}
	}

	ASSERT(0);
	str=L"";

	return;
}

//------------------------------------------------
//
// Tables of Outgoing / public queues properties
//
//------------------------------------------------

const PropertyDisplayItem OutgoingQueueDisplayList[] = {

    // String         |  Property    ID              | VT Handler   | Display                    |Field   |Len|Width        |Sort
    // Resource       |                              |              | function                   |Offset  |   |             |    
    //----------------+------------------------------+--------------+----------------------------+--------+---+-------------+-----
	{ IDS_LQ_PATHNAME,  PROPID_MGMT_QUEUE_PATHNAME,     &g_VTLPWSTR,  NULL,                       NO_OFFSET, 0, 200,         NULL},
	{ IDS_LQ_FORMATNM,  PROPID_MGMT_QUEUE_FORMATNAME,   &g_VTLPWSTR,  NULL,                       NO_OFFSET, 0, HIDE_COLUMN, NULL},
	{ IDS_LQ_LOCATION,  PROPID_MGMT_QUEUE_LOCATION,     NULL,         LocalQueuePropertyToString, NO_OFFSET, 0, HIDE_COLUMN, NULL},   
	{ IDS_LQ_XACT,      PROPID_MGMT_QUEUE_XACT,         NULL,         LocalQueuePropertyToString, NO_OFFSET, 0, HIDE_COLUMN, NULL},  
	{ IDS_LQ_FOREIGN,   PROPID_MGMT_QUEUE_FOREIGN,      NULL,         LocalQueuePropertyToString, NO_OFFSET, 0, HIDE_COLUMN, NULL},   
	{ IDS_LQ_MSGCOUNT,  PROPID_MGMT_QUEUE_MESSAGE_COUNT,&g_VTUI4,     NULL,                       NO_OFFSET, 0,  50,         NULL},   
	{ IDS_LQ_ACKCOUNT,  PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT,        &g_VTUI4,    NULL,             NO_OFFSET, 0,  50,         NULL},   
	{ IDS_LQ_READCOUNT, PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT,       &g_VTUI4,    NULL,             NO_OFFSET, 0,  50,         NULL},
	{ IDS_LQ_USEDQUOTA, PROPID_MGMT_QUEUE_USED_QUOTA,   &g_VTUI4,     NULL,                       NO_OFFSET, 0, HIDE_COLUMN, NULL},   
	{ IDS_LQ_STATE,     PROPID_MGMT_QUEUE_STATE,        NULL,         LocalQueuePropertyToString, NO_OFFSET, 0, 100,         NULL},   
	{ IDS_LQ_NEXTHOP,   PROPID_MGMT_QUEUE_NEXTHOPS,     &g_VectLPWSTR,NULL,                       NO_OFFSET, 0, 180,         NULL},   
	{ IDS_LQ_JMSGCOUNT, PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT,   &g_VTUI4,    NULL,             NO_OFFSET, 0, HIDE_COLUMN, NULL},
	{ IDS_LQ_JUSEDQUOTA,PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA,      &g_VTUI4,    NULL,             NO_OFFSET, 0, HIDE_COLUMN, NULL},   
	{ NO_TITLE,         PROPID_MGMT_QUEUE_TYPE,         NULL,                   NULL,             NO_OFFSET, 0,   0,         NULL},   


/*
	//
	// Properties that are not shown on the right pane (only in property pages)
	//
    // Str. |       Property    ID                 | VT Handler   |Dis.| Field    |Len|Width | Sort
    // Res  |                                      |              |func| Offset   |   |      |     
    //------+--------------------------------------+--------------+----+----------+---+------+-----
	{ 0,     PROPID_MGMT_QUEUE_EOD_LAST_ACK,        NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EOD_LAST_ACK_TIME,   NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EDO_LAST_ACK_COUNT,  NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EOD_FIRST_NON_ACK,   NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EOD_LAST_NON_ACK,    NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EOD_NEXT_SEQ,        NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT,   NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT,    NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EOD_RESEND_TIME,     NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EOD_RESEND_INTERVAL, NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EDO_RESEND_COUNT,    NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
	{ 0,     PROPID_MGMT_QUEUE_EOD_SOURCE_INFO,     NULL,          NULL, NO_OFFSET, 0, 100,   NULL},   
*/


    {0,                 0,                              NULL }

};



const PropertyDisplayItem PublicQueueDisplayList[] = {

    // String         |  Property    ID              | VT Handler   | Display                    |Field   |Len|Width        |Sort
    // Resource       |                              |              | function                   |Offset  |   |             |    
    //----------------+------------------------------+--------------+----------------------------+--------+---+-------------+----
	{ IDS_LQ_PATHNAME,  PROPID_MGMT_QUEUE_PATHNAME,     &g_VTLPWSTR,  QueuePathnameToName,        NO_OFFSET, 0, 200,         NULL},
	{ IDS_LQ_FORMATNM,  PROPID_MGMT_QUEUE_FORMATNAME,   &g_VTLPWSTR,  NULL,                       NO_OFFSET, 0, HIDE_COLUMN, NULL},
	{ IDS_LQ_XACT,      PROPID_MGMT_QUEUE_XACT,         NULL,         LocalQueuePropertyToString, NO_OFFSET, 0, HIDE_COLUMN, NULL},  
	{ IDS_LQ_MSGCOUNT,  PROPID_MGMT_QUEUE_MESSAGE_COUNT,&g_VTUI4,     NULL,                       NO_OFFSET, 0,  50,         NULL},   
	{ IDS_LQ_USEDQUOTA, PROPID_MGMT_QUEUE_USED_QUOTA,   &g_VTUI4,     NULL,                       NO_OFFSET, 0, HIDE_COLUMN, NULL},   
	{ IDS_LQ_JMSGCOUNT, PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT,   &g_VTUI4,    NULL,             NO_OFFSET, 0, HIDE_COLUMN, NULL},
	{ IDS_LQ_JUSEDQUOTA,PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA,      &g_VTUI4,    NULL,             NO_OFFSET, 0, HIDE_COLUMN, NULL},   
	{ NO_TITLE,         PROPID_MGMT_QUEUE_TYPE,         NULL,                   NULL,             NO_OFFSET, 0, HIDE_COLUMN, NULL},   
	{ NO_TITLE,         PROPID_MGMT_QUEUE_LOCATION,     NULL,                   NULL,             NO_OFFSET, 0, HIDE_COLUMN, NULL},   
    {0,                 0,                              NULL }

};


/****************************************************

CLocalOutgoingFolder Class
    
 ****************************************************/
// {B6EDE697-29CC-11d2-B552-006008764D7A}
static const GUID CLocalOutgoingFolderGUID_NODETYPE = 
{ 0xb6ede697, 0x29cc, 0x11d2, { 0xb5, 0x52, 0x0, 0x60, 0x8, 0x76, 0x4d, 0x7a } };

const GUID*  CLocalOutgoingFolder::m_NODETYPE = &CLocalOutgoingFolderGUID_NODETYPE;
const OLECHAR* CLocalOutgoingFolder::m_SZNODETYPE = OLESTR("B6EDE697-29CC-11d2-B552-006008764D7A");
const OLECHAR* CLocalOutgoingFolder::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CLocalOutgoingFolder::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;


const PropertyDisplayItem *CLocalOutgoingFolder::GetDisplayList()
{
    return OutgoingQueueDisplayList;
}


const DWORD CLocalOutgoingFolder::GetNumDisplayProps()
{
    return ((sizeof(OutgoingQueueDisplayList)/sizeof(OutgoingQueueDisplayList[0])) - 1);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalOutgoingFolder::GetQueueNamesProducer

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalOutgoingFolder::GetQueueNamesProducer(CQueueNames **ppqueueNamesProducer)
{
    HRESULT hr = S_OK;
    if (0 == m_pQueueNames)
    {
        hr = CCachedQueueNames::CreateInstance(&m_pQueueNames, m_szMachineName);
    }

    *ppqueueNamesProducer = m_pQueueNames;
    return hr;
}


void CLocalOutgoingFolder::AddChildQueue(CString &szFormatName, 
                                         CString &,
                                         MQMGMTPROPS &mqQProps, 
										 CString &szLocation,   
                                         CString &)
{
	if(szLocation == MGMT_QUEUE_REMOTE_LOCATION)
	{
    	CLocalOutgoingQueue *pLocalOutgoing;
		//
		// Create a new Outgoing queue
		//
		pLocalOutgoing = new CLocalOutgoingQueue(this, m_pComponentData, m_fOnLocalMachine);

		pLocalOutgoing->m_szFormatName  = szFormatName;
		pLocalOutgoing->m_mqProps       = mqQProps;
		pLocalOutgoing->m_szMachineName = m_szMachineName;     
		pLocalOutgoing->InitState();

		AddChild(pLocalOutgoing, &pLocalOutgoing->m_scopeDataItem);
	}
}



/****************************************************

CLocalPublicFolder Class
    
 ****************************************************/
// {5c845756-8da1-11d2-829e-006094eb6406}
static const GUID CLocalPublicFolderGUID_NODETYPE = 
{ 0x5c845756, 0x8da1, 0x11d2,{0x82, 0x9e, 0x00, 0x60, 0x94, 0xeb, 0x64, 0x06} };
const GUID*  CLocalPublicFolder::m_NODETYPE = &CLocalPublicFolderGUID_NODETYPE;
const OLECHAR* CLocalPublicFolder::m_SZNODETYPE = OLESTR("5c845756-8da1-11d2-829e-006094eb6406");
const OLECHAR* CLocalPublicFolder::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CLocalPublicFolder::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;


const PropertyDisplayItem *CLocalPublicFolder::GetDisplayList()
{
    return PublicQueueDisplayList;
}


const DWORD CLocalPublicFolder::GetNumDisplayProps()
{
    return ((sizeof(PublicQueueDisplayList)/sizeof(PublicQueueDisplayList[0])) - 1);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPublicFolder::GetQueueNamesProducer

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPublicFolder::GetQueueNamesProducer(CQueueNames **ppqueueNamesProducer)
{
    HRESULT hr = S_OK;
    if (0 == m_pQueueNames)
    {
        CString strMachineNameForDs;
        if (!m_fOnLocalMachine)
        {
            strMachineNameForDs = m_szMachineName;
        }
        else
        {
            hr = GetComputerNameIntoString(strMachineNameForDs);

            if FAILED(hr)
            {
                return hr ;
            }
        }
        hr = CDsPublicQueueNames::CreateInstance(&m_pQueueNames, strMachineNameForDs);
        if FAILED(hr)
        {
			MessageDSError(hr, IDS_WARNING_DS_PUBLIC_QUEUES_NOT_AVAILABLE);
            //
            // Change the icons of the folder to indicate no DS state
            //
            //
            // Need IConsoleNameSpace
            //
            CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_pComponentData->m_spConsole); 

	        //
	        // We are OK 
	        // Change the ICON to disconnect state
	        //
	        m_scopeDataItem.nImage = IMAGE_PUBLIC_FOLDER_NODS_CLOSE;  
	        m_scopeDataItem.nOpenImage = IMAGE_PUBLIC_FOLDER_NODS_OPEN;
	        spConsoleNameSpace->SetItem(&m_scopeDataItem);
            hr = CCachedQueueNames::CreateInstance(&m_pQueueNames, m_szMachineName);
        }
   }

    *ppqueueNamesProducer = m_pQueueNames;
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPublicFolder::AddChildQueue

--*/
//////////////////////////////////////////////////////////////////////////////
void CLocalPublicFolder::AddChildQueue(CString &szFormatName, 
                                       CString &szPathName,
                                       MQMGMTPROPS &mqQProps, 
									   CString &szLocation,   
                                       CString &szType)
{
	if(szLocation == MGMT_QUEUE_LOCAL_LOCATION || szLocation == TEXT(""))
	{
		//
		// if public, Create a new LocalQueue object
		//
		if(szType == MGMT_QUEUE_TYPE_PUBLIC || szType == TEXT(""))
		{
            CString strQueuePathName;
            BOOL fFromDS;
            if (szPathName == TEXT(""))
            {
                //
                // We got the queue from local cache
                //
        	    GetStringPropertyValue(GetDisplayList(), PROPID_MGMT_QUEUE_PATHNAME, mqQProps.aPropVar, strQueuePathName);
                fFromDS = FALSE;
            }
            else
            {
                strQueuePathName = szPathName;
                fFromDS = TRUE;
            }

            CLocalPublicQueue *pLocalQueue = new CLocalPublicQueue(this, GetDisplayList(), GetNumDisplayProps(), m_pComponentData, strQueuePathName, szFormatName, fFromDS);

            pLocalQueue->m_mqProps.cProp    = mqQProps.cProp;
            pLocalQueue->m_mqProps.aPropID  = mqQProps.aPropID;
            pLocalQueue->m_mqProps.aPropVar = mqQProps.aPropVar;
            pLocalQueue->m_mqProps.aStatus  = NULL;

			pLocalQueue->m_szMachineName = m_szMachineName;

            //
            // Extract the queue name only from the full public path name
            //
            CString strName;
            ExtractQueueNameFromQueuePathName(strName, strQueuePathName);
            pLocalQueue->m_bstrDisplayName = strName;

			AddChild(pLocalQueue, &pLocalQueue->m_scopeDataItem);
		}
	}

}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPublicFolder::OnNewPublicQueue

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPublicFolder::OnNewPublicQueue(bool & bHandled, CSnapInObjectRootBase * /*pSnapInObjectRoot*/)
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    R<CQueueName> pQueueNameDlg = new CQueueName(m_szMachineName);       
	CGeneralPropertySheet propertySheet(pQueueNameDlg.get());
	pQueueNameDlg->SetParentPropertySheet(&propertySheet);

	//
	// We want to use pQueueNameDlg data also after DoModal() exitst
	//
	pQueueNameDlg->AddRef();
    INT_PTR iStatus = propertySheet.DoModal();
    bHandled = TRUE;

    if(iStatus == IDCANCEL || FAILED(pQueueNameDlg->GetStatus()))
    {
        return S_FALSE;
    }
    
    HRESULT hr = AddPublicQueueToScope(pQueueNameDlg->GetNewQueueFormatName(), pQueueNameDlg->GetNewQueuePathName());
    if (FAILED(hr))
    {
        //
        // We successfully added the queue, but AddPublicQueueToScope failed.
        // The most reasonable cause of this is replication delays. (YoelA, 25-Jul-99)
        //
        AfxMessageBox(IDS_CREATED_WAIT_FOR_REPLICATION);
        return S_FALSE;
    }

    return S_OK;
}


HRESULT CLocalPublicFolder::AddPublicQueueToScope(CString &strNewQueueFormatName, CString &strNewQueuePathName)
{
    PROPVARIANT pvar[x_dwMgmtToDsSize];
    PROPID  pid[x_dwMgmtToDsSize];

    for (DWORD i=0; i<x_dwMgmtToDsSize; i++)
    {
        pid[i] = x_aMgmtToDsProps[i].pidDsPid;
        pvar[i].vt = VT_NULL;
    }

    HRESULT hr = ADGetObjectProperties(
						eQUEUE,
						MachineDomain(m_szMachineName),
						false,	// fServerName
						strNewQueuePathName,
						x_dwMgmtToDsSize, 
						pid,
						pvar
						);

    if FAILED(hr)
    {
		TrERROR(GENERAL, "Failed to get properties for queue %ls, hr = 0x%x", strNewQueuePathName, hr);
        return hr;
    }

    //
    // Prepare the management properties structure
    //
	MQMGMTPROPS	  mqQProps;
	AP<PROPID> aPropId = new PROPID[GetNumDisplayProps()];
	AP<PROPVARIANT> aPropVar = new PROPVARIANT[GetNumDisplayProps()];

	mqQProps.cProp    = GetNumDisplayProps();
	mqQProps.aPropID  = aPropId;
	mqQProps.aPropVar = aPropVar;
	mqQProps.aStatus  = NULL;


	//
	// Initialize variant array
	//
    const PropertyDisplayItem *aDisplayList = GetDisplayList();
	for(DWORD j = 0; j < GetNumDisplayProps(); j++)
	{
		mqQProps.aPropID[j] = aDisplayList[j].itemPid;
		mqQProps.aPropVar[j].vt = VT_NULL;
	}
    CString szLocation = MGMT_QUEUE_LOCAL_LOCATION;
    CString szType = MGMT_QUEUE_TYPE_PUBLIC;

    CopyManagementFromDsPropsAndClear(&mqQProps, pvar);

    AddChildQueue(strNewQueueFormatName, strNewQueuePathName, mqQProps, szLocation, szType);

	//
	// These will be cleared by the queue object itself
	//
	aPropId.detach();
	aPropVar.detach();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\localq.h ===
/*++

Copyright (c) 1995 - 2001 Microsoft Corporation

Module Name:

    localq.h

Abstract:

    Definition of objects that represent local 
	queues.

Author:

    Nela Karpel (nelak) 26-Jul-2001

Environment:

    Platform-independent.

--*/
#pragma once
#ifndef __LOCALQUEUE_H_
#define __LOCALQUEUE_H_

#include "snpnscp.h"
#include "lqDsply.h"
#include "privadm.h"
//
// CQueue - general queue class
//
class CQueue
{
protected:
    static const PROPID mx_paPropid[];
    static const DWORD  mx_dwPropertiesCount;
    static const DWORD  mx_dwNumPublicOnlyProps;
};


/****************************************************

        CLocalQueue Class
    
 ****************************************************/
class CLocalQueue : public CDisplayQueue<CLocalQueue>,
                    public CQueue
{
public:

    CString m_szFormatName;           // Format name of the private queue
    CString m_szPathName;             // Path name of the private queue

   	BEGIN_SNAPINCOMMAND_MAP(CPrivateQueue, FALSE)
	END_SNAPINCOMMAND_MAP()

    //
    // Local constructor - called from local admin (Comp. Management snapin)
    //
    CLocalQueue(CSnapInItem * pParentNode, const PropertyDisplayItem *aDisplayList, DWORD dwDisplayProps, CSnapin * pComponentData) :
        CDisplayQueue<CLocalQueue> (pParentNode, pComponentData)
	{
        m_aDisplayList = aDisplayList;
        m_dwNumDisplayProps = dwDisplayProps;
	}

    //
    // DS constructor - called from DS snapin
    //
    CLocalQueue(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CDisplayQueue<CLocalQueue> (pParentNode, pComponentData)
	{
	}

	~CLocalQueue()
	{
	}

    virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );

  	virtual HRESULT OnUnSelect( IHeaderCtrl* pHeaderCtrl );

	virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);
	virtual HRESULT OnDelete( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				, BOOL fSilent = FALSE
				);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

    STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream);

protected:
    //
    // CQueueDataObject
    //
	virtual HRESULT GetProperties() PURE;
    virtual HRESULT CreateQueueSecurityPage(HPROPSHEETPAGE *phPage,
                                            IN LPCWSTR lpwcsFormatName,
                                            IN LPCWSTR lpwcsDescriptiveName) PURE;

	CPropMap m_propMap;
    BOOL m_fPrivate;
};


/****************************************************

        CPrivateQueue Class
    
 ****************************************************/
class CPrivateQueue : public CLocalQueue
{
public:
    //
    // Local constructor - called from local admin (Comp. Management snapin)
    //
    CPrivateQueue(CSnapInItem * pParentNode, const PropertyDisplayItem *aDisplayList, DWORD dwDisplayProps, CSnapin * pComponentData, BOOL fOnLocalMachine) :
        CLocalQueue (pParentNode, aDisplayList, dwDisplayProps, pComponentData)
	{
        Init();
        if (fOnLocalMachine)
        {
            m_QLocation = PRIVQ_LOCAL;
        }
        else
        {
            m_QLocation = PRIVQ_REMOTE;
        }
	}

    //
    // DS constructor - called from DS snapin
    //
    CPrivateQueue(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CLocalQueue (pParentNode, pComponentData)
	{
        Init();
        m_QLocation = PRIVQ_UNKNOWN;
	}

    HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);
    bool IsAdminRespQueue();

protected:
    enum
    {
        PRIVQ_LOCAL,
        PRIVQ_REMOTE,
        PRIVQ_UNKNOWN
    } m_QLocation;

	virtual HRESULT GetProperties();
    virtual void Init()
    {
        SetIcons(IMAGE_PRIVATE_QUEUE, IMAGE_PRIVATE_QUEUE);
        m_fPrivate = TRUE;
    }
    virtual void ApplyCustomDisplay(DWORD dwPropIndex);
    virtual HRESULT CreateQueueSecurityPage(HPROPSHEETPAGE *phPage,
                                            IN LPCWSTR lpwcsFormatName,
                                            IN LPCWSTR lpwcsDescriptiveName);

};


/****************************************************

        CLocalPublicQueue Class
    
 ****************************************************/
class CLocalPublicQueue : public CLocalQueue
{
public:
    //
    // Local constructor - called from local admin (Comp. Management snapin)
    //
    CLocalPublicQueue(CSnapInItem * pParentNode, 
                      const PropertyDisplayItem *aDisplayList, 
                      DWORD dwDisplayProps, 
                      CSnapin * pComponentData,
                      CString &strPathName,
                      CString &strFormatName,
                      BOOL fFromDS) :
        CLocalQueue (pParentNode, aDisplayList, dwDisplayProps, pComponentData),
        m_fFromDS(fFromDS)
	{
        m_szFormatName = strFormatName;
        m_szPathName = strPathName;
        Init();
	}

    ~CLocalPublicQueue()
    {
    }

    HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

protected:
	virtual HRESULT GetProperties();
    virtual void Init()
    {
        SetIcons(IMAGE_PUBLIC_QUEUE, IMAGE_PUBLIC_QUEUE);
        m_fPrivate = FALSE;
    }
    virtual HRESULT CreateQueueSecurityPage(HPROPSHEETPAGE *phPage,
                                            IN LPCWSTR lpwcsFormatName,
                                            IN LPCWSTR lpwcsDescriptiveName);
    BOOL m_fFromDS;
};


/****************************************************

        CLocalOutgoingQueue Class
    
 ****************************************************/
class CLocalOutgoingQueue : public CDisplayQueue<CLocalOutgoingQueue>
{
public:
	void InitState();

   	BEGIN_SNAPINCOMMAND_MAP(CLocalOutgoingQueue, FALSE)
		SNAPINCOMMAND_ENTRY(ID_MENUITEM_LOCALOUTGOINGQUEUE_PAUSE,  OnPause)
		SNAPINCOMMAND_ENTRY(ID_MENUITEM_LOCALOUTGOINGQUEUE_RESUME, OnResume)
	END_SNAPINCOMMAND_MAP()

   	SNAPINMENUID(IDR_LOCALOUTGOINGQUEUE_MENU)

    CLocalOutgoingQueue(
		CLocalOutgoingFolder * pParentNode, 
		CSnapin * pComponentData, 
		BOOL fOnLocalMachine = TRUE
		);

	virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );
    
	virtual HRESULT PopulateScopeChildrenList();

	void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags);

protected:
    virtual void ApplyCustomDisplay(DWORD dwPropIndex);

private:
	//
	// Menu functions
	//
	HRESULT OnPause(bool &bHandled, CSnapInObjectRootBase* pObj);
	HRESULT OnResume(bool &bHandled, CSnapInObjectRootBase* pObj);

	BOOL m_fOnHold;			//Currently on Hold or not
    BOOL m_fOnLocalMachine;
};


HRESULT 
CreatePrivateQueueSecurityPage(
       HPROPSHEETPAGE *phPage,
    IN LPCWSTR lpwcsFormatName,
    IN LPCWSTR lpwcsDescriptiveName);

HRESULT
CreatePublicQueueSecurityPage(
    HPROPSHEETPAGE *phPage,
    IN LPCWSTR lpwcsDescriptiveName,
    IN LPCWSTR lpwcsDomainController,
	IN bool	   fServerName,
    IN GUID*   pguid
	);


#endif // __LOCALQUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\localfld.h ===
/*++

Copyright (c) 1995 - 2001 Microsoft Corporation

Module Name:

    localfld.h

Abstract:

    Definition of objects that represent local 
	queue folders.

Author:

    Nela Karpel (nelak) 26-Jul-2001

Environment:

    Platform-independent.

--*/
#pragma once
#ifndef __LOCALFLD_H_
#define __LOCALFLD_H_

#include "resource.h"

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

#include "atlsnap.h"
#include "snpnscp.h"
#include "icons.h"
#include "snpnerr.h"
#include "lqdsply.h"

////////////////////////////////////////////////////////////////////////////////
// CLocalQueuesFolder class
//
template <class T> 
class CLocalQueuesFolder : 
    public CNodeWithScopeChildrenList<T, FALSE>
{
public:
	MQMGMTPROPS	m_mqProps;

   	virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );

    CLocalQueuesFolder(CSnapInItem * pParentNode, CSnapin * pComponentData, 
                       LPCTSTR strMachineName, LPCTSTR strDisplayName) :
        CNodeWithScopeChildrenList<T, FALSE>(pParentNode, pComponentData),
        m_szMachineName(strMachineName)
        {
            m_bstrDisplayName = strDisplayName;
            //
            // If we are administrating the local machine, the machine name is empty
            //
            if (strMachineName[0] == 0)
            {
                m_fOnLocalMachine = TRUE;
            }
            else
            {
                m_fOnLocalMachine = FALSE;
            }
        };

protected:

	//
	// Menu functions
	//
    BOOL    m_fOnLocalMachine;
    virtual const PropertyDisplayItem *GetDisplayList() = 0;
    virtual const DWORD         GetNumDisplayProps() = 0;

    CString m_szMachineName;

private:

	virtual CString GetHelpLink();

};


template <class T>
HRESULT CLocalQueuesFolder<T>::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return InsertColumnsFromDisplayList(pHeaderCtrl, GetDisplayList());
}


template <class T>
CString CLocalQueuesFolder<T>::GetHelpLink(
	VOID
	)
{
	CString strHelpLink;
    strHelpLink.LoadString(IDS_HELPTOPIC_QUEUES);

	return strHelpLink;
}


////////////////////////////////////////////////////////////////////////////////
// CLocalActiveFolder class
//
template <class T> 
class CLocalActiveFolder : public CLocalQueuesFolder<T>
{
public:
   	BEGIN_SNAPINCOMMAND_MAP(CLocalActiveFolder, FALSE)
	END_SNAPINCOMMAND_MAP()

   	SNAPINMENUID(IDR_LOCALACTIVE_MENU)

    CLocalActiveFolder(CSnapInItem * pParentNode, CSnapin * pComponentData,
                       LPCTSTR strMachineName, LPCTSTR strDisplayName) : 
        CLocalQueuesFolder<T>(pParentNode, pComponentData, strMachineName, strDisplayName),
        m_pQueueNames(0)
    {
        SetIcons(IMAGE_PRIVATE_FOLDER_CLOSE, IMAGE_PRIVATE_FOLDER_OPEN);
    }

	~CLocalActiveFolder()
    {
        if (m_pQueueNames !=0)
        {
            m_pQueueNames->Release();
        }
    }

    
	virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    virtual const PropertyDisplayItem *GetDisplayList() PURE;
    virtual const DWORD         GetNumDisplayProps() PURE;
	virtual void  AddChildQueue(CString &szFormatName, CString &szPathName, MQMGMTPROPS &mqQProps, 
							   CString &szLocation, CString &szType) PURE;
    virtual  HRESULT GetQueueNamesProducer(CQueueNames **ppqueueNamesProducer, BOOL fNew);

protected:
    CQueueNames *m_pQueueNames;
    virtual  HRESULT GetQueueNamesProducer(CQueueNames **ppqueueNamesProducer) PURE;

};

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalActiveFolder::GetQueueNamesProducer

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T> 
HRESULT CLocalActiveFolder<T>::GetQueueNamesProducer(CQueueNames **ppqueueNamesProducer, BOOL fNew)
{
    if (fNew)
    {
        if (0 != m_pQueueNames)
        {
            m_pQueueNames->Release();
            m_pQueueNames = 0;
        }
    }

    return GetQueueNamesProducer(ppqueueNamesProducer);
};


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalActiveFolder::SetVerbs

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T> 
HRESULT CLocalActiveFolder<T>::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hr;
    //
    // Display verbs that we support
    //
    hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );

    return(hr);
}
       

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalActiveFolder::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T> 
HRESULT CLocalActiveFolder<T>::PopulateScopeChildrenList()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CQueueNames *pQueueNames;
        
    HRESULT hr = GetQueueNamesProducer(&pQueueNames, TRUE);
    if FAILED(hr)
    {
        return hr;
    }

	//
	// Loop over all open queue and create queue objects
	//
	while(TRUE)
    {
		HRESULT hr;
		MQMGMTPROPS	  mqQProps;
		AP<PROPID> aPropId = new PROPID[GetNumDisplayProps()]; 
		AP<PROPVARIANT> aPropVar = new PROPVARIANT[GetNumDisplayProps()];

		//
		// Initialize variant array
		//
        const PropertyDisplayItem *aDisplayList = GetDisplayList();
		for(DWORD j = 0; j < GetNumDisplayProps(); j++)
		{
			aPropId[j] = aDisplayList[j].itemPid;
			aPropVar[j].vt = VT_NULL;
		}

		mqQProps.cProp    = GetNumDisplayProps();
		mqQProps.aPropID  = aPropId;
		mqQProps.aPropVar = aPropVar;
		mqQProps.aStatus  = NULL;

		//
		// Get the format name of the local queue
		//
		CString szFormatName = TEXT("");
		CString szPathName = TEXT("");
   		CString szLocation = TEXT("");
        CString szType = TEXT("");

        hr = pQueueNames->GetNextQueue(szFormatName, szPathName, &mqQProps);
        //
        // Clear the properties with no value using the "Clear" function
        //
        for (DWORD i = 0; i < mqQProps.cProp; i++)
        {
            if (mqQProps.aPropVar[i].vt == VT_NULL)
            {
                VTHandler       *pvth = aDisplayList[i].pvth;
                if (pvth)
                {
                    pvth->Clear(&mqQProps.aPropVar[i]);
                }
            }
        }

        if FAILED(hr)
        {
            if (szFormatName != TEXT(""))
            {
   			    //
			    // if format name is valid, there is a queue but we could not get
                // its properties for some reason. Add an error node
			    //
			    CErrorNode *pErr = new CErrorNode(this, m_pComponentData);
			    CString szErr;

			    MQErrorToMessageString(szErr, hr);
			    pErr->m_bstrDisplayName = szFormatName + L" - " + szErr;
	  		    AddChild(pErr, &pErr->m_scopeDataItem);

			    continue;
            }

            //
            // If format name is not valid, there is no point in continuing fetching queues
            //
            return hr;
        }

        if (szFormatName == TEXT("")) // End of queues
        {
            break;
        }

        GetStringPropertyValue(aDisplayList, PROPID_MGMT_QUEUE_LOCATION, mqQProps.aPropVar, szLocation);
	    GetStringPropertyValue(aDisplayList, PROPID_MGMT_QUEUE_TYPE, mqQProps.aPropVar, szType);

		AddChildQueue(szFormatName, szPathName, mqQProps, szLocation, szType);
        aPropId.detach();
        aPropVar.detach();
    }

    return(hr);

}

class CLocalOutgoingFolder : public CLocalActiveFolder<CLocalOutgoingFolder>
{
public:
	virtual void AddChildQueue(CString &szFormatName, CString &, MQMGMTPROPS &mqQProps, 
							   CString &szLocation, CString &);
    CLocalOutgoingFolder(CSnapInItem * pParentNode, CSnapin * pComponentData,
                         LPCTSTR strMachineName, LPCTSTR strDisplayName) : 
        CLocalActiveFolder<CLocalOutgoingFolder>(pParentNode, pComponentData, strMachineName, strDisplayName)
        {}
    virtual const PropertyDisplayItem *GetDisplayList();
    virtual const DWORD         GetNumDisplayProps();

protected:
    virtual  HRESULT GetQueueNamesProducer(CQueueNames **ppqueueNamesProducer);
};

class CLocalPublicFolder : public CLocalActiveFolder<CLocalPublicFolder>
{
public:
   	BEGIN_SNAPINCOMMAND_MAP(CLocalPublicFolder, FALSE)
		SNAPINCOMMAND_ENTRY(ID_MENUITEM_NEW_PUBLIC_QUEUE, OnNewPublicQueue)
        CHAIN_SNAPINCOMMAND_MAP(CLocalActiveFolder<CLocalPublicFolder>)
	END_SNAPINCOMMAND_MAP()

   	UINT GetMenuID()
    {
        if (m_fUseIpAddress)
        {
            //
            // Admin using IP address. Do not allow creation of a new queue
            //
            return IDR_IPPUBLIC_MENU;
        }
        else
        {
            return IDR_LOCALPUBLIC_MENU;
        }
    }

	virtual void AddChildQueue(CString &szFormatName, 
                               CString &szPathName, 
                               MQMGMTPROPS &mqQProps, 
							   CString &szLocation, 
                               CString &szType);

    CLocalPublicFolder(CSnapInItem * pParentNode, CSnapin * pComponentData,
                       LPCTSTR strMachineName, LPCTSTR strDisplayName, BOOL fUseIpAddress) : 
        CLocalActiveFolder<CLocalPublicFolder>(pParentNode, pComponentData, strMachineName, strDisplayName),
        m_fUseIpAddress(fUseIpAddress)
        {}
    virtual const PropertyDisplayItem *GetDisplayList();
    virtual const DWORD         GetNumDisplayProps();

protected:
    virtual  HRESULT GetQueueNamesProducer(CQueueNames **ppqueueNamesProducer);
    HRESULT  AddPublicQueueToScope(CString &strNewQueueFormatName, CString &strNewQueuePathName);
	HRESULT OnNewPublicQueue(bool &bHandled, CSnapInObjectRootBase* pObj);
	BOOL m_fUseIpAddress;
};



#endif // __LOCALFLD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\localutl.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	cplutil.h

Abstract:

	Definition for the control panel utility function
Author:

    TatianaS


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __CPLUTIL_H_
#define __CPLUTIL_H_
#include "resource.h"

//cplutil.cpp
BOOL IsFile(LPCTSTR name);
BOOL IsDirectory (LPCTSTR name);
void DisplayFailDialog();
void GetLastErrorText(CString &strErrorText);
BOOL SetDirectorySecurity(LPCTSTR szDirectory);
BOOL MoveFiles(
    LPCTSTR pszSrcDir,
    LPCTSTR pszDestDir,
    LPCTSTR pszFileProto,
    BOOL fRecovery =FALSE);
BOOL OnRestartWindows();

CString GetToken(LPCTSTR& p, TCHAR delimeter) throw();

//service.cpp
BOOL GetServiceRunningState(BOOL *pfServiceIsRunning);
BOOL StopService();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\machdomain.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    machdomain.h

Abstract:

	machine domain declarations

Author:		 

    Ilan  Herbst  (ilanh)  12-Mar-2001

--*/

#ifndef __MACHDOMAIN_H_
#define __MACHDOMAIN_H_

LPCWSTR MachineDomain(LPCWSTR pMachineName);

LPCWSTR MachineDomain();

LPCWSTR LocalMachineDomain();

#endif // __MACHDOMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\lqdsply.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	lqDsply.h

Abstract:

	Local queues folder general functions
Author:

    YoelA, Raphir


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __LQDSPLY_H_
#define __LQDSPLY_H_

#include "mqcast.h"

//
// CDisplayQueue - Queue that has display properties for right pane
//
template<class T>
class CDisplayQueue : public CNodeWithScopeChildrenList<T, FALSE>
{
public:
  	LPOLESTR GetResultPaneColInfo(int nCol);
    STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream);
	MQMGMTPROPS	m_mqProps;
	CString m_szFormatName;
    CString m_szMachineName;

protected:
	CComBSTR m_bstrLastDisplay;
    const PropertyDisplayItem *m_aDisplayList;
    DWORD m_dwNumDisplayProps;
    void Init()
    {
        m_aDisplayList = 0;
        m_mqProps.cProp = 0;
	    m_mqProps.aPropID = NULL;
	    m_mqProps.aPropVar = NULL;
	    m_mqProps.aStatus = NULL;
    }


    CDisplayQueue() :
    {
        Init();
    }

    CDisplayQueue(CSnapInItem * pParentNode, CSnapin * pComponentData) : 
        CNodeWithScopeChildrenList<T, FALSE>(pParentNode, pComponentData)
    {
        Init();
    }

    ~CDisplayQueue();

    //
    // Override this function to enable special treatment for display of specific 
    // property
    //
    virtual void ApplyCustomDisplay(DWORD /*dwPropIndex*/)
    {
    }

private:

	virtual CString GetHelpLink();
};


/***************************************************************************

  CDisplayQueue implementation

 ***************************************************************************/

//////////////////////////////////////////////////////////////////////////////
/*++

CDisplayQueue::GetResultPaneColInfo

  Param - nCol: Column number
  Returns - String to be displayed in the specific column


Called for each column in the result pane.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T>
LPOLESTR CDisplayQueue<T>::GetResultPaneColInfo(int nCol)
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (0 == m_aDisplayList)
    {
     	if (nCol == 0)
	    {
		    return m_bstrDisplayName;
	    }

        //
	    // Return the blank for other columns
        //
	    return OLESTR(" ");
    }

#ifdef _DEBUG
    {
        //
        // Make sure that nCol is not larger than the last index in
        // m_aDisplayList
        //
        int i = 0;
        for (i=0; m_aDisplayList[i].itemPid != 0; i++)
		{
			NULL;
		}

        if (nCol >= i)
        {
            ASSERT(0);
        }
    }
#endif // _DEBUG

    //
    // Get a display string of that property
    //
    CString strTemp = m_bstrLastDisplay;
    ItemDisplay(&m_aDisplayList[nCol], &(m_mqProps.aPropVar[nCol]), strTemp);
    m_bstrLastDisplay=strTemp;
	
	ASSERT(m_mqProps.aPropID[nCol] == m_aDisplayList[nCol].itemPid);
    
    //
    // Apply custom display for that property
    //
    ApplyCustomDisplay(nCol);

    //
    // Return a pointer to the string buffer.
    //
    return(m_bstrLastDisplay);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CDisplayQueue::~CDisplayQueue
	Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T>
CDisplayQueue<T>::~CDisplayQueue()
{

	FreeMqProps(&m_mqProps);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CDisplayQueue::FillData

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T>
STDMETHODIMP CDisplayQueue<T>::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
	HRESULT hr = DV_E_CLIPFORMAT;
	ULONG uWritten;

    hr = CNodeWithScopeChildrenList<T, FALSE>::FillData(cf, pStream);

    if (hr != DV_E_CLIPFORMAT)
    {
        return hr;
    }

	if (cf == gx_CCF_FORMATNAME)
	{
		hr = pStream->Write(
            m_szFormatName, 
            (numeric_cast<ULONG>(wcslen(m_szFormatName) + 1))*sizeof(m_szFormatName[0]), 
            &uWritten);

		return hr;
	}

   	if (cf == gx_CCF_COMPUTERNAME)
	{
		hr = pStream->Write(
            (LPCTSTR)m_szMachineName, 
            m_szMachineName.GetLength() * sizeof(WCHAR), 
            &uWritten);
		return hr;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CDisplayQueue::GetHelpLink

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T>
CString CDisplayQueue<T>::GetHelpLink(
	VOID
	)
{
	CString strHelpLink;
	strHelpLink.LoadString(IDS_HELPTOPIC_QUEUES);
	return strHelpLink;
}


#endif // __LQDSPLY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\machtrac.cpp ===
// MachineTracking.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "dsext.h"
#include "admmsg.h"
#include "mqppage.h"
#include "testmsg.h"
#include "Machtrac.h"

#include "machtrac.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMachineTracking property page

IMPLEMENT_DYNCREATE(CMachineTracking, CMqDialog)

CMachineTracking::CMachineTracking(
	const GUID& gMachineID, 
	const CString& strDomainController,
	BOOL fLocalMgmt
	) : 
	CMqDialog(CMachineTracking::IDD), m_gMachineID(gMachineID),
	m_strDomainController(strDomainController),
	m_fLocalMgmt(fLocalMgmt)
{
    
    //{{AFX_DATA_INIT(CMachineTracking)
	m_ReportQueueName = _T("");
    m_iTestButton = 0;
	//}}AFX_DATA_INIT
    m_LastReportQName = _T("");
}

CMachineTracking::~CMachineTracking()
{
}

void CMachineTracking::DoDataExchange(CDataExchange* pDX)
{
	CMqDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMachineTracking)
	DDX_Control(pDX, IDC_REPORTQUEUE_NAME, m_ReportQueueCtrl);
	DDX_CBString(pDX, IDC_REPORTQUEUE_NAME, m_ReportQueueName);
    DDX_Radio(pDX, IDC_TRACK_ALL, m_iTestButton);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMachineTracking, CMqDialog)
	//{{AFX_MSG_MAP(CMachineTracking)
	ON_BN_CLICKED(IDC_REPORTQUEUE_NEW, OnReportqueueNew)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMachineTracking message handlers

BOOL CMachineTracking::OnInitDialog() 
{
	CMqDialog::OnInitDialog();
	CWaitCursor wc;

    //
    // Initialize report queue name combo box
    //
    GUID TestGuidType = MQ_QTYPE_REPORT;
    CComboBox *pcomboName = (CComboBox *)GetDlgItem(IDC_REPORTQUEUE_NAME);

	//
    // Query the DS for all the report-queues and insert them into 
    // the combo-box
    //
    CRestriction restriction;
    restriction.AddRestriction(&TestGuidType, PROPID_Q_TYPE, PREQ);

    //
    // Insert blank to the top of the list
    //
    CString strNone;
    strNone.LoadString(IDS_LB_NONE);
    pcomboName->AddString(strNone);

    //
    // Insert the name of all the report queues to the list
    //
    CColumns columns;
    columns.Add(PROPID_Q_PATHNAME);
    columns.Add(PROPID_Q_INSTANCE);

    const DWORD x_dwResultBufferSize = 64;
    PROPVARIANT apResultProps[x_dwResultBufferSize];
    DWORD dwPropCount = x_dwResultBufferSize;
  
    HRESULT hr;
    HANDLE hEnume;
    {
        CWaitCursor wc; //display wait cursor while query DS
        hr = ADQueryQueues(
					m_fLocalMgmt ? MachineDomain() : GetDomainController(m_strDomainController),
					m_fLocalMgmt ? false : true,		// fServerName
                    restriction.CastToStruct(),
                    columns.CastToStruct(),
                    0,
                    &hEnume
                    );
    }
    DSLookup dslookup(hEnume, hr);

    if (!dslookup.HasValidHandle())
    {
        EndDialog(IDCANCEL);
        return TRUE;
    }

    while ( SUCCEEDED(dslookup.Next(&dwPropCount, apResultProps))
            && (dwPropCount != 0) )
    {
        for (DWORD i=0; i<dwPropCount; i++)
        {
            int iItem = m_ReportQueueCtrl.AddString(apResultProps[i].pwszVal);
            MQFreeMemory(apResultProps[i].pwszVal);

            i++;
            INT_PTR iArrayIndex = m_aguidAllQueues.Add(*apResultProps[i].puuid);
            m_ReportQueueCtrl.SetItemData(iItem, iArrayIndex);
            MQFreeMemory(apResultProps[i].puuid);
        }
        dwPropCount = x_dwResultBufferSize;
    }

    HRESULT rc = GetQMReportQueue(m_gMachineID, m_ReportQueueName, m_fLocalMgmt, m_strDomainController);

    if (FAILED(rc))
    {
        MessageDSError(rc, IDS_CANNOT_GET_REPORT_QUEUE);
        m_ReportQueueName = strNone;
    }
    else
    {
        if (m_ReportQueueName.IsEmpty())
        {
            m_ReportQueueName = strNone;
        }
        m_LastReportQName = m_ReportQueueName;
    }

    //
    // Retrieve state of test all (propagate) flag from machine
    //
    hr = GetQMReportState(m_gMachineID, m_fTestAll);

    m_iTestButton = m_fTestAll ? 0 : 1;

    if(FAILED(hr))
    {
        MessageDSError(rc, IDS_CANNOT_GET_TRACKING_FLAG);
        EndDialog(IDCANCEL);
        return(TRUE);
    }

    //
    //  data has changed, update it
    //
    UpdateData(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CMachineTracking::OnOK() 
{
    UpdateData(TRUE);

    HRESULT hr;
    if (m_LastReportQName != m_ReportQueueName)
    {
        CString strNone;
        strNone.LoadString(IDS_LB_NONE);

        if (m_ReportQueueName != strNone)
        {
            int iReportQueueIndex = m_ReportQueueCtrl.GetCurSel();
            UINT_PTR uiGuidIndex = m_ReportQueueCtrl.GetItemData(iReportQueueIndex);
            hr = SetQMReportQueue(m_gMachineID, m_aguidAllQueues[uiGuidIndex]);
        }
        else
        {
            hr = SetQMReportQueue(m_gMachineID, GUID_NULL);
        }
            
        if(FAILED(hr))
        {
            MessageDSError(hr, IDS_OP_SET_REPORTQUEUE); 
            return;
        }
    }
       
    m_LastReportQName = m_ReportQueueName;

    //
    // Set the value of test all (propagate) flag
    //
    BOOL fTestAll = (m_iTestButton == 0);
    if (m_fTestAll != fTestAll)
    {
        m_fTestAll = fTestAll;

        hr = SetQMReportState(m_gMachineID, m_fTestAll);
        if(FAILED(hr))
        {
            MessageDSError(hr, IDS_OP_SET_PROPAGATION_FLAG);
        }
    }

	CMqDialog::OnOK();
}

void CMachineTracking::OnReportqueueNew() 
{
	static const GUID x_ReportGuidType = MQ_QTYPE_REPORT;

    CNewQueueDlg NewQDlg(this, IDS_REPORTQ_LABEL, x_ReportGuidType);
    if(NewQDlg.DoModal() == IDOK)
    {
        //
        // add queue to the combo-box.
        //
	    int iItem = m_ReportQueueCtrl.AddString(NewQDlg.m_strPathname);
        if (CB_ERR == iItem)
        {
            ASSERT(0);
            return;
        }

        INT_PTR iArrayIndex = m_aguidAllQueues.Add(NewQDlg.m_guid);
        m_ReportQueueCtrl.SetItemData(iItem, iArrayIndex);

        m_ReportQueueCtrl.SelectString(-1, NewQDlg.m_strPathname);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\localutl.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	cplutil.cpp

Abstract:

	Implementation file for the control panel utility function

Author:

    TatianaS


--*/
//////////////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "localutl.h"
#include "mqcast.h"
#include "bkupres.h"

#include "localutl.tmh"

#define STORAGE_DIR_INHERIT_FLAG \
                       (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE)

//////////////////////////////////////////////////////////////////////////////
/*++

 Function -
      SetDirectorySecurity.

 Parameter -
      szDirectory - The directory for which to set the security.

 Return Value -
      TRUE if successfull, else FALSE.

 Description -
      The function sets the security of the given directory such that
      any file that is created in the directory will have full control for
      the local administrators group and no access at all to anybody else.

--*/
//////////////////////////////////////////////////////////////////////////////

BOOL
SetDirectorySecurity(
    LPCTSTR szDirectory)
{
    //
    // Get the SID of the local administrators group.
    //
	PSID pAdminSid = MQSec_GetAdminSid();

    //
    // Create a DACL so that the local administrators group will have full
    // control for the directory and full control for files that will be
    // created in the directory. Anybody else will not have any access to the
    // directory and files that will be created in the directory.
    //
    P<ACL> pDacl;
    DWORD dwDaclSize;

    WORD dwAceSize = DWORD_TO_WORD(sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminSid) - sizeof(DWORD));
    dwDaclSize = sizeof(ACL) + 2 * (dwAceSize);
    pDacl = (PACL)(char*) new BYTE[dwDaclSize];
    P<ACCESS_ALLOWED_ACE> pAce = (PACCESS_ALLOWED_ACE) new BYTE[dwAceSize];

    pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    pAce->Header.AceFlags = STORAGE_DIR_INHERIT_FLAG ;
    pAce->Header.AceSize = dwAceSize;
    pAce->Mask = FILE_ALL_ACCESS;
    memcpy(&pAce->SidStart, pAdminSid, GetLengthSid(pAdminSid));

    BOOL fRet = TRUE;

    //
    // Create the security descriptor and set the it as the security
    // descriptor of the directory.
    //
    SECURITY_DESCRIPTOR SD;

    if (!InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION) ||
        !InitializeAcl(pDacl, dwDaclSize, ACL_REVISION) ||
        !AddAccessAllowedAce(pDacl, ACL_REVISION, FILE_ALL_ACCESS, pAdminSid) ||
        !AddAce(pDacl, ACL_REVISION, MAXDWORD, (LPVOID) pAce, dwAceSize) ||
        !SetSecurityDescriptorDacl(&SD, TRUE, pDacl, FALSE) ||
        !SetFileSecurity(szDirectory, DACL_SECURITY_INFORMATION, &SD))
    {
        fRet = FALSE;
    }

    return fRet;
}

//////////////////////////////////////////////////////////////////////////////
/*++

 Get the text string that explains the error code returned by
 GetLastError()
--*/
//////////////////////////////////////////////////////////////////////////////

void GetLastErrorText(CString &strErrorText)
{
    LPTSTR szError;

    if (FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            GetLastError(),
            0,
            (LPTSTR)&szError,
            128,
            NULL) == 0)
    {
        //
        // Faield in FormatMessage, so just display the error number.
        //
        strErrorText.FormatMessage(IDS_ERROR_CODE, GetLastError());
    }
    else
    {
        strErrorText = szError;
        LocalFree(szError);
    }
}

//////////////////////////////////////////////////////////////////////////////
/*++


 Function -
      IsProperDirectorySecurity.

 Parameter -
      szDirectory - The directory for which to check the security.

 Return Value -
      TRUE if successfull and the security is OK, else FALSE.

 Description -
      The function verifies that the security of a given directory is set
      properly so that the files in the storage directory will be secured.

--*/
//////////////////////////////////////////////////////////////////////////////

static
BOOL
IsProperDirectorySecurity(
    LPCTSTR szDirectory)
{
    DWORD dwSdLen;

    //
    // Get the size of the directory security descriptor.
    //
    if (GetFileSecurity(szDirectory, DACL_SECURITY_INFORMATION, NULL, 0, &dwSdLen) ||
        (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
    {
        return FALSE;
    }

    //
    // Get the directory security descriptor and retrieve the DACL out of it.
    //
    AP<BYTE> pbSd_buff = new BYTE[dwSdLen];
    PSECURITY_DESCRIPTOR pSd = (PSECURITY_DESCRIPTOR)pbSd_buff;
    BOOL bPresent;
    PACL pDacl;
    BOOL bDefault;

    if (!GetFileSecurity(szDirectory, DACL_SECURITY_INFORMATION, pSd, dwSdLen, &dwSdLen) ||
        !GetSecurityDescriptorDacl(pSd, &bPresent, &pDacl, &bDefault) ||
        !bPresent ||
        !pDacl)
    {
        return FALSE;
    }

    //
    // Get the SID of the local administrators group.
    //
	PSID pAdminSid = MQSec_GetAdminSid();

    //
    // Get the ACE count of the security descriptor. There should be two ACEs there.
    // Retrieve the first ACE.
    //
    ACL_SIZE_INFORMATION AclInfo;
    LPVOID pAce0;

    if (!GetAclInformation(pDacl, &AclInfo, sizeof(AclInfo), AclSizeInformation) ||
        (AclInfo.AceCount != 2) ||
        !GetAce(pDacl, 0, &pAce0))
    {
        return FALSE;
    }

    //
    // See that the first ACE grant full control for the admin on the diretory it self.
    // And retrieve the second ACE.
    //
    PACCESS_ALLOWED_ACE pAce = (PACCESS_ALLOWED_ACE) pAce0;

    if ((pAce->Header.AceType != ACCESS_ALLOWED_ACE_TYPE) ||
        (pAce->Header.AceFlags != 0) ||
        (pAce->Mask != FILE_ALL_ACCESS) ||
        !EqualSid(&pAce->SidStart, pAdminSid) ||
        !GetAce(pDacl, 1, &pAce0))
    {
        return FALSE;
    }

    //
    // See that the second ACE is an inherit ACE that sets the security of files in
    // the directory to full control for the admin.
    //
    pAce = (PACCESS_ALLOWED_ACE) pAce0;

    if ((pAce->Header.AceType != ACCESS_ALLOWED_ACE_TYPE)   ||
        (pAce->Header.AceFlags != STORAGE_DIR_INHERIT_FLAG) ||
        (pAce->Mask != FILE_ALL_ACCESS)                     ||
        !EqualSid(&pAce->SidStart, pAdminSid))
    {
        return FALSE;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

 Check if the passed string is an existing file.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL IsFile(LPCTSTR name)
{
	DWORD status = GetFileAttributes(name);
	TrTRACE(GENERAL, "File status for file %ls is 0x%x", name, status);

    if (status == 0xFFFFFFFF)
    {
		TrERROR(GENERAL, "File status for file %ls was not retrieved. Error: %!winerr!", name, GetLastError());
		return FALSE;
	}
	
	if (status & FILE_ATTRIBUTE_DIRECTORY)
	{
		TrERROR(GENERAL, "File %ls is a directory. Status: 0x%x", name, status);
		return FALSE;
	}

	return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

 If the passed string is of an existing directory on
 a fixed local drive.

--*/
//////////////////////////////////////////////////////////////////////////////

BOOL IsDirectory (LPCTSTR name)
{
    DWORD status;
    TCHAR szDrive[4];
    CString strError;
    CString strMessage;

    //
    // Does the path start with d: ?
    //
    if (!isalpha(name[0]) || (name[1] != ':'))
    {
        strError.FormatMessage(IDS_NOT_A_FULLPATH, name);
        AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);
        return FALSE;
    }

    szDrive[0] = name[0];
    szDrive[1] = ':';
    szDrive[2] = '\\';
    szDrive[3] = '\0';

    //
    // See if the drive is a fixed drive. We only allow fixed drives.
    //
    if (GetDriveType(szDrive) != DRIVE_FIXED)
    {
        strError.FormatMessage(IDS_LOCAL_DRIVE, szDrive);
        AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);

        return FALSE;
    }

    //
    // See whether this is a name of a directory.
    //
    status = GetFileAttributes(name);

    if (status == 0xFFFFFFFF)
    {
        //
        // The directory does not exist. Ask the user whether she wants to
        // create the directory.
        //
        strMessage.FormatMessage(IDS_ASK_CREATE_DIR, name);       
       
        if (AfxMessageBox(strMessage, MB_YESNO | MB_ICONQUESTION) == IDNO)
        {
            //
            // No thank you!
            //
            return FALSE;
        }

        //
        // OK, create the directory.
        //
        if (CreateDirectory(name, NULL))
        {
            //
            // The directory was created, set it's security.
            //
            if (!SetDirectorySecurity(name))
            {
                //
                // Faield to set the security on the directory. Delete the directory
                // and notify the user.
                //
                RemoveDirectory(name);

                GetLastErrorText(strError);
                strMessage.FormatMessage(IDS_SET_DIR_SECURITY_ERROR, name, (LPCTSTR)strError);
                AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);

                return FALSE;
            }
            else
            {
                if (!IsProperDirectorySecurity(name))
                {
                    //
                    // This appears to be a FAT drive. Ask the user if she wants to use
                    // it anyway, without security.
                    //
                    strMessage.FormatMessage(IDS_FAT_WARNING, name);
                   
                    if (AfxMessageBox(strMessage, MB_YESNO | MB_ICONQUESTION) == IDNO)
                    {
                        //
                        // No thank you!
                        //
                        RemoveDirectory(name);
                        return FALSE;
                    }
                }
            }

            return TRUE;
        }
        else
        {
            //
            // Faield to create the directory, notify the user.
            //
            GetLastErrorText(strError);
            strMessage.FormatMessage(IDS_CREATE_DIR_ERROR, name, (LPCTSTR)strError);
            AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);

            return FALSE;
        }
    }
    else if (!(status & FILE_ATTRIBUTE_DIRECTORY))
    {
        //
        // This is not a directory (a file or what?)
        //
        strError.FormatMessage(IDS_NOT_A_DIR, name);
        AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);

        return FALSE;
    }

    //
    // We got here because the directory is a valid existing directory, so
    // only see if the security is OK, if not, notify the user.
    //
    if (!IsProperDirectorySecurity(name))
    {
        strMessage.FormatMessage(IDS_DIR_SECURITY_WARNING, name);
        AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);
    }

    return TRUE;
}

//
// display "Falcon not installed properlly" message
//
void DisplayFailDialog()
{       
    AfxMessageBox(IDS_REGISTRY_ERROR, MB_OK | MB_ICONEXCLAMATION);
}


//////////////////////////////////////////////////////////////////////////////
/*++

 Move files from source directory to a destination directory.
 If one of the files failed to move, the fiels that were already
 moved are placed back in the original source directory.

--*/
//////////////////////////////////////////////////////////////////////////////

BOOL MoveFiles(
    LPCTSTR pszSrcDir,
    LPCTSTR pszDestDir,
    LPCTSTR pszFileProto,
    BOOL fRecovery)
{
    TCHAR szSrcDir[MAX_PATH] = {0};
    TCHAR szSrcFile[MAX_PATH];
    TCHAR szDestDir[MAX_PATH] = {0};
    TCHAR szDestFile[MAX_PATH];

    //
    // Get the source directory and source file prototype
    //
	_tcsncpy(szSrcDir,pszSrcDir, (MAX_PATH-2-_tcslen(pszFileProto)));
    _tcscat(szSrcDir, TEXT("\\"));
    _tcscat(_tcscpy(szSrcFile, szSrcDir), pszFileProto);

    //
    // Get the destination directory
    //
	_tcsncpy(szDestDir,pszDestDir, MAX_PATH - 2);
    _tcscat(szDestDir, TEXT("\\"));

    //
    // Find the first file to be moved.
    //
    WIN32_FIND_DATA FindData;
    HANDLE hFindFile = FindFirstFile(szSrcFile, &FindData);

    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        //
        // No files to move.
        //
        return TRUE;
    }

    do
    {
        //
        // Skip directories.
        //
        if ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
            (FindData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
        {
            continue;
        }

        //
        // Get the full path of the source file and destination file.
        //
        _tcsncat(_tcscpy(szDestFile, szDestDir), FindData.cFileName, (MAX_PATH-1-_tcslen(szDestDir)));
        _tcsncat(_tcscpy(szSrcFile, szSrcDir), FindData.cFileName, (MAX_PATH-1-_tcslen(szSrcDir)));

        //
        // Move the file
        //
        if (!MoveFile(szSrcFile, szDestFile))
        {
            //
            // Faield to move the file, display an error message and try to
            // roll back.
            //
            CString strMessage;
            CString strError;

            GetLastErrorText(strError);
            strMessage.FormatMessage(IDS_MOVE_FILE_ERROR,
                (LPCTSTR)szSrcFile, (LPCTSTR)szDestFile, (LPCTSTR)strError);            
            AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);

            //
            // Try to roll back - do not roll back if failed while rolling back.
            //
            if (!fRecovery)
            {
                if (!MoveFiles(pszDestDir, pszSrcDir, pszFileProto, TRUE))
                {
                    //
                    // Failed to roll back, display and error message.
                    //
                    strMessage.LoadString(IDS_MOVE_FILES_RECOVERY_ERROR);
                    AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);
                }
            }
            return FALSE;
        }
        //
        // Get the name of the next file to move.
        //
    } while (FindNextFile(hFindFile, &FindData));

    //
    // If we got this far, were all done successfully.
    //
    return TRUE;
}

//
// Reboot Windows
//
BOOL RestartWindows()
{
    HANDLE hToken;              // handle to process token
    TOKEN_PRIVILEGES tkp;       // ptr. to token structure


     //
     // Get the current process token handle
     // so we can get shutdown privilege.
     //

    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hToken))
    {
        return FALSE;
    }

    // Get the LUID for shutdown privilege.

    if (!LookupPrivilegeValue(NULL, TEXT("SeShutdownPrivilege"),
                              &tkp.Privileges[0].Luid))
    {
        return FALSE;
    }

    tkp.PrivilegeCount = 1;  // one privilege to set
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    // Get shutdown privilege for this process.

    if (!AdjustTokenPrivileges(hToken, FALSE, &tkp, 0,
                               (PTOKEN_PRIVILEGES) NULL, 0))
    {
        return FALSE;
    }

    // Cannot test the return value of AdjustTokenPrivileges.

    if (!ExitWindowsEx(EWX_FORCE|EWX_REBOOT,0))
    {
        return FALSE;
    }

    // Disable shutdown privilege.

    tkp.Privileges[0].Attributes = 0;
    AdjustTokenPrivileges(hToken, FALSE, &tkp, 0,
                          (PTOKEN_PRIVILEGES) NULL, 0);

    return(TRUE);
}

BOOL OnRestartWindows()
{
    BOOL fRet = RestartWindows();

    if (!fRet)
    {
        CString strMessage;
        CString strErrorText;

        GetLastErrorText(strErrorText);
        strMessage.FormatMessage(IDS_RESTART_WINDOWS_ERROR, (LPCTSTR)strErrorText);
        AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);       
    }

    return fRet;
}


CString GetToken(LPCTSTR& p, TCHAR delimeter) throw()
{
    //
    // Trim leading whitespace characters from the string
    //
    for(;*p != NULL && iswspace(*p); ++p)
    {
        NULL;
    }

    if (p == NULL)
        return CString();

    LPCTSTR pDelimeter = _tcschr(p, delimeter);
    LPCTSTR pBegin = p;

    if (pDelimeter == NULL)
    {
        p += _tcslen(p);
        return CString(pBegin);
    }

    p = pDelimeter;

    for(--pDelimeter; (pDelimeter >= pBegin) && iswspace(*pDelimeter); --pDelimeter)
    {
        NULL;
    }

    return CString(pBegin, numeric_cast<int>(pDelimeter - pBegin + 1));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\machdomain.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    machdomain.cpp

Abstract:

	Handle machine domain

Author:		 

    Ilan  Herbst  (ilanh)  12-Mar-2001

--*/

#include "stdafx.h"
#include "globals.h"
#include "machdomain.h"
#include "autoreln.h"
#include "Dsgetdc.h"
#include <lm.h>
#include <lmapibuf.h>
#include "uniansi.h"
#include "tr.h"
#include "_registr.h"
#include <mqexception.h>

#include "machdomain.tmh"

static LPCWSTR LocalComputerName()
/*++
Routine Description:
	return local computer name

Arguments:
	None

Returned Value:
	computer name.

--*/
{
	static WCHAR s_pLocalComputerName[MAX_COMPUTERNAME_LENGTH + 1] = {0};

	if(s_pLocalComputerName[0] == L'\0')
	{
		//
		// First time Initialization - initialize local computer name
		//
		DWORD dwLen = TABLE_SIZE(s_pLocalComputerName);
		GetComputerName(s_pLocalComputerName, &dwLen);
		TrTRACE(GENERAL, "Local Computer Name = %ls", s_pLocalComputerName);
	}

	//
	// In case of failure we will return empty string "", next time we will try again.
	//
	return s_pLocalComputerName;

}


static LPWSTR LocalMachineDomainFromRegistry()
/*++
Routine Description:
	Find local machine msmq configuration object domain from registry.
	The function allocated the LocalComputer domain string, the caller is responsible to free this string.

Arguments:
	None

Returned Value:
	machine domain string.

--*/
{
	static WCHAR s_DomainName[256] = {0};

	if(s_DomainName[0] == L'\0')
	{
		//
		// First time Initialization - read Machine Domain from registry
		//
        DWORD  dwSize = sizeof(s_DomainName);
		DWORD dwType = REG_SZ;
		LONG rc = GetFalconKeyValue( 
						MSMQ_MACHINE_DOMAIN_REGNAME,
						&dwType,
						(PVOID) s_DomainName,
						&dwSize 
						);

		if (rc != ERROR_SUCCESS)
		{
			TrERROR(GENERAL, "GetFalconKeyValue Failed to query registry %ls, rc = 0x%x", MSMQ_MACHINE_DOMAIN_REGNAME, rc);
			throw bad_win32_error(rc);
		}

		TrTRACE(GENERAL, "Registry value: %ls = %ls", MSMQ_MACHINE_DOMAIN_REGNAME, s_DomainName);
	}

	ASSERT(s_DomainName[0] != L'\0');
	AP<WCHAR> pDomainName = new WCHAR[wcslen(s_DomainName) + 1];
    wcscpy(pDomainName, s_DomainName);
	return pDomainName.detach();
}

	
static LPWSTR FindMachineDomain(LPCWSTR pMachineName)
/*++
Routine Description:
	Find machine domain

Arguments:
	pMachineName - machine name

Returned Value:
	machine domain, NULL if not found

--*/
{
	TrTRACE(GENERAL, "FindMachineDomain(), MachineName = %ls", pMachineName);

	try
	{
		if((pMachineName == NULL) || 
		   (pMachineName[0] == L'\0') ||
		   (CompareStringsNoCase(pMachineName, LocalComputerName()) == 0))
		{
			//
			// Local machine - get Machine domain from registry
			//
			return LocalMachineDomainFromRegistry();
		}
	}
	catch(const bad_win32_error&)
	{
		//
		// In case of excption continue with the same code that gets the machine domain 
		// using DsGetDcName
		//
	}

	//
	// Get AD server
	//
	PNETBUF<DOMAIN_CONTROLLER_INFO> pDcInfo;
	DWORD dw = DsGetDcName(
					pMachineName, 
					NULL, 
					NULL, 
					NULL, 
					DS_DIRECTORY_SERVICE_REQUIRED, 
					&pDcInfo
					);

	if(dw != NO_ERROR) 
	{
		TrERROR(GENERAL, "FindMachineDomain(), DsGetDcName failed, error = %d", dw);
		return NULL;
	}

	ASSERT(pDcInfo->DomainName != NULL);
	TrTRACE(GENERAL, "DoamainName = %ls", pDcInfo->DomainName);
	AP<WCHAR> pMachineDomain = new WCHAR[wcslen(pDcInfo->DomainName) + 1];
    wcscpy(pMachineDomain, pDcInfo->DomainName);
	return pMachineDomain.detach();
}


static AP<WCHAR> s_pMachineName;
static AP<WCHAR> s_pMachineDomain; 

static bool s_fInitialize = false;

LPCWSTR MachineDomain(LPCWSTR pMachineName)
/*++
Routine Description:
	find machine domain.

Arguments:
	pMachineName - machine name

Returned Value:
	return machine domain

--*/
{
	if(s_fInitialize)
	{
	    if(CompareStringsNoCase(s_pMachineName, pMachineName) == 0)
		{
			//
			// Same machine name
			//
			return s_pMachineDomain;
		}

		//
		// Free previously machine domain
		//
		s_fInitialize = false;
		s_pMachineDomain.free();
	}

	//
	// Get computer domain
	//
	AP<WCHAR> pMachineDomain = FindMachineDomain(pMachineName);

	if(NULL != InterlockedCompareExchangePointer(
					&s_pMachineDomain.ref_unsafe(), 
					pMachineDomain.get(), 
					NULL
					))
	{
		//
		// The exchange was not performed
		//
		ASSERT(s_fInitialize);
		ASSERT(s_pMachineDomain != NULL);
		ASSERT(CompareStringsNoCase(s_pMachineName, pMachineName) == 0);
		return s_pMachineDomain;
	}

	//
	// The exchange was done
	//
	ASSERT(s_pMachineDomain == pMachineDomain);
	pMachineDomain.detach();

	//
	// Update the machine name
	//
	s_pMachineName.free();
	s_pMachineName = newwcs(pMachineName);

	s_fInitialize = true;
	TrTRACE(GENERAL, "Initialize machine domain: machine = %ls", s_pMachineName.get());
	TrTRACE(GENERAL, "machine domain = %ls", s_pMachineDomain.get());
	return s_pMachineDomain;
}


LPCWSTR MachineDomain()
/*++
Routine Description:
	get current machine domain.

Arguments:

Returned Value:
	return current machine domain

--*/
{
	ASSERT(s_fInitialize);
	return s_pMachineDomain;
}


static bool s_fLocalInitialize = false;
static AP<WCHAR> s_pLocalMachineDomain; 

LPCWSTR LocalMachineDomain()
/*++
Routine Description:
	get local machine domain.

Arguments:

Returned Value:
	return local machine domain

--*/
{
	if(s_fLocalInitialize)
	{
		return s_pLocalMachineDomain;
	}

	//
	// Get local computer domain
	//
	AP<WCHAR> pLocalMachineDomain = FindMachineDomain(NULL);

	if(NULL != InterlockedCompareExchangePointer(
					&s_pLocalMachineDomain.ref_unsafe(), 
					pLocalMachineDomain.get(), 
					NULL
					))
	{
		//
		// The exchange was not performed
		//
		ASSERT(s_fLocalInitialize);
		ASSERT(s_pLocalMachineDomain != NULL);
		return s_pLocalMachineDomain;
	}

	//
	// The exchange was done
	//
	ASSERT(s_pLocalMachineDomain == pLocalMachineDomain);
	pLocalMachineDomain.detach();

	s_fLocalInitialize = true;
	TrTRACE(GENERAL, "local machine domain = %ls", s_pLocalMachineDomain.get());
	return s_pLocalMachineDomain;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\message.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	message.cpp

Abstract:

	Implementation file for the CMessage snapin node class.

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wincrypt.h"
#include "mqsnap.h"
#include "snapin.h"
#include "message.h"
#include "globals.h"
#include "mqPPage.h"
#include "msggen.h"
#include "msgsndr.h"
#include "msgq.h"
#include "msgbody.h"
#include "msgsoap.h"
#include "mqcast.h"

#include <Sddl.h>
#include <strsafe.h>

#include "message.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////
/*++

MsgIdToString

--*/
//////////////////////////////////////////////////////////////////////////////
void CALLBACK MsgIdToString(const PROPVARIANT *pPropVar, CString &str)
{
   ASSERT(pPropVar->vt == (VT_VECTOR | VT_UI1));

   OBJECTID *pID = (OBJECTID*) pPropVar->caub.pElems ;

   TCHAR msgId[MAX_GUID_LENGTH + 35]; // msgid= GUID + '\' + DWORD

   HRESULT hr = StringCchPrintf(msgId, TABLE_SIZE(msgId), GUID_FORMAT L"\\%u", GUID_ELEMENTS(&(pID->Lineage)), pID->Uniquifier);
   ASSERT(("Message ID buffer is too small", hr == S_OK)); 
   UNREFERENCED_PARAMETER(hr);

   str = msgId;
 
}

//////////////////////////////////////////////////////////////////////////////
/*++

MsgDeliveryToString

--*/
//////////////////////////////////////////////////////////////////////////////
void CALLBACK MsgDeliveryToString(const PROPVARIANT *pPropVar, CString &str)
{
    ASSERT(pPropVar->vt == VT_UI1);
    static EnumItem ItemList[] =
    { 
        ENUM_ENTRY(MQMSG_DELIVERY_EXPRESS),
        ENUM_ENTRY(MQMSG_DELIVERY_RECOVERABLE),
    };

    EnumToString(pPropVar->bVal,ItemList, sizeof(ItemList) / sizeof(EnumItem), str);
}

//////////////////////////////////////////////////////////////////////////////
/*++

MsgClassToString

--*/
//////////////////////////////////////////////////////////////////////////////
void CALLBACK MsgClassToString(const PROPVARIANT *pPropVar, CString &str)
{

    ASSERT(pPropVar->vt == VT_UI2);
	ASSERT(("Invalid message class", MQCLASS_IS_VALID(pPropVar->uiVal)));

	if (MQCLASS_NACK_HTTP(pPropVar->uiVal))
	{
		str.FormatMessage(IDS_MQMSG_CLASS_NACK_HTTP, (pPropVar->uiVal ^ 0xA000));
		return;
	}

    static EnumItem ItemList[] =
    { 
        ENUM_ENTRY(MQMSG_CLASS_NORMAL),
        ENUM_ENTRY(MQMSG_CLASS_REPORT),
        ENUM_ENTRY(MQMSG_CLASS_ACK_REACH_QUEUE),
        ENUM_ENTRY(MQMSG_CLASS_ACK_RECEIVE),
        ENUM_ENTRY(MQMSG_CLASS_NACK_BAD_DST_Q),
        ENUM_ENTRY(MQMSG_CLASS_NACK_PURGED),
        ENUM_ENTRY(MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT),
        ENUM_ENTRY(MQMSG_CLASS_NACK_Q_EXCEED_QUOTA),
        ENUM_ENTRY(MQMSG_CLASS_NACK_ACCESS_DENIED),
        ENUM_ENTRY(MQMSG_CLASS_NACK_HOP_COUNT_EXCEEDED),
        ENUM_ENTRY(MQMSG_CLASS_NACK_BAD_SIGNATURE),
        ENUM_ENTRY(MQMSG_CLASS_NACK_BAD_ENCRYPTION),
        ENUM_ENTRY(MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT),
        ENUM_ENTRY(MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q),
        ENUM_ENTRY(MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_MSG),
        ENUM_ENTRY(MQMSG_CLASS_NACK_Q_DELETED),
        ENUM_ENTRY(MQMSG_CLASS_NACK_Q_PURGED),
        ENUM_ENTRY(MQMSG_CLASS_NACK_RECEIVE_TIMEOUT),
        ENUM_ENTRY(MQMSG_CLASS_NACK_RECEIVE_TIMEOUT_AT_SENDER),
        ENUM_ENTRY(MQMSG_CLASS_NACK_UNSUPPORTED_CRYPTO_PROVIDER),
        ENUM_ENTRY(MQMSG_CLASS_NACK_SOURCE_COMPUTER_GUID_CHANGED)
        
    };

    EnumToString(pPropVar->uiVal,ItemList, sizeof(ItemList) / sizeof(EnumItem), str);
}

      
//////////////////////////////////////////////////////////////////////////////
/*++

MsgHashToString

--*/
//////////////////////////////////////////////////////////////////////////////
void CALLBACK MsgHashToString(const PROPVARIANT *pPropVar, CString &str)
{
    ASSERT(pPropVar->vt == VT_UI4);
    static EnumItem ItemList[] =
    { 

        ENUM_ENTRY(CALG_MD2),     
        ENUM_ENTRY(CALG_MD4),     
        ENUM_ENTRY(CALG_MD5),     
        ENUM_ENTRY(CALG_SHA),     
        ENUM_ENTRY(CALG_MAC),     
        ENUM_ENTRY(CALG_RSA_SIGN),
        ENUM_ENTRY(CALG_DSS_SIGN),
        ENUM_ENTRY(CALG_RSA_KEYX),
        ENUM_ENTRY(CALG_DES),     
        ENUM_ENTRY(CALG_RC2),
        ENUM_ENTRY(CALG_RC4),     
        ENUM_ENTRY(CALG_SEAL),    
        ENUM_ENTRY(CALG_DH_SF)
    };   

    EnumToString(pPropVar->ulVal,ItemList, sizeof(ItemList) / sizeof(EnumItem), str);
}

//////////////////////////////////////////////////////////////////////////////
/*++

MsgEncryptToString

--*/
//////////////////////////////////////////////////////////////////////////////
void CALLBACK MsgEncryptToString(const PROPVARIANT *pPropVar, CString &str)
{       
    //
    // Same set of values
    //
    MsgHashToString(pPropVar, str);
}

//////////////////////////////////////////////////////////////////////////////
/*++

MsgSenderIdToString

--*/
//////////////////////////////////////////////////////////////////////////////
void CALLBACK MsgSenderIdToString(const PROPVARIANT *pPropVar, CString &str)
{       
   ASSERT(pPropVar->vt == (VT_VECTOR | VT_UI1));


    PSID pSid = pPropVar->caub.pElems;          // binary SID
    //
    // test if SID passed in is valid
    //
    if(!IsValidSid(pSid)) 
        return;

    LPTSTR pszTextBuffer;  // buffer for textual representaion of SID
	BOOL f = ConvertSidToStringSid(pSid, &pszTextBuffer);
	if (!f)
	{
	    str.LoadString(IDS_UNKNOWN);
		return;
	}

	str = pszTextBuffer;
	LocalFree(pszTextBuffer);
}

//////////////////////////////////////////////////////////////////////////////
/*++

MsgSendTypeToString

--*/
//////////////////////////////////////////////////////////////////////////////
void CALLBACK MsgSendTypeToString(const PROPVARIANT *pPropVar, CString &str)
{       
    str.LoadString(MQMSG_SENDERID_TYPE_NONE == pPropVar->ulVal ?
                   IDS_NO : IDS_YES);

}

//////////////////////////////////////////////////////////////////////////////
/*++

MsgPrivToString

--*/
//////////////////////////////////////////////////////////////////////////////
void CALLBACK MsgPrivToString(const PROPVARIANT *pPropVar, CString &str)
{
    ASSERT(pPropVar->vt == VT_UI4);
    static EnumItem ItemList[] =
    { 

        ENUM_ENTRY(MQ_PRIV_LEVEL_NONE), //BugBug - Assuming == MQMSG_PRIV_LEVEL_NONE   
        ENUM_ENTRY(MQMSG_PRIV_LEVEL_BODY_BASE),     
        ENUM_ENTRY(MQMSG_PRIV_LEVEL_BODY_ENHANCED)     
    };   

    EnumToString(pPropVar->ulVal,ItemList, sizeof(ItemList) / sizeof(EnumItem), str);
}

//------------------------------------------------
//
// Table of message properties
//
//------------------------------------------------

extern const PropertyDisplayItem MessageDisplayList[] = {

    // String resource                | Property ID            | VT Handler   | Display func     | Field Offset                          | Size                | Width     | Sort        | 
    //--------------------------------+------------------------+--------------+------------------+---------------------------------------+---------------------+-----------+-------------+-
    {IDS_REPORT_MESSAGETITLE,           PROPID_M_LABEL,          &g_VTLPWSTR,  NULL,               FIELD_OFFSET(MsgProps,wszLabel),        0,                    100,        SortByString},
    {IDS_REPORT_MESSAGEPRIORITY,        PROPID_M_PRIORITY,       &g_VTUI1,     NULL,               NO_OFFSET,                              0,                     50,        SortByString},
    {IDS_REPORT_MESSAGE_CLASS,          PROPID_M_CLASS,          &g_VTUI2,     MsgClassToString,   NO_OFFSET,                              0,                     50,        SortByString},
    {IDS_REPORT_MESSAGE_BODYSIZE,       PROPID_M_BODY_SIZE,      &g_VTUI4,     NULL,               NO_OFFSET,                              BODYLEN,               50,        SortByULONG},
    {IDS_REPORT_MESSAGEID,              PROPID_M_MSGID,          &g_VectUI1,   MsgIdToString,      FIELD_OFFSET(MsgProps,acMsgId),         PROPID_M_MSGID_SIZE,  275,        SortByString},
    {IDS_REPORT_MESSAGE_APPSPECIFIC,    PROPID_M_APPSPECIFIC,    &g_VTUI4,     NULL,               NO_OFFSET,                              0,                   HIDE_COLUMN, SortByULONG},
    {IDS_REPORT_MESSAGETITLE_LEN,       PROPID_M_LABEL_LEN,      &g_VTUI4,     NULL,               NO_OFFSET,                              LABELLEN,            HIDE_COLUMN, SortByULONG},
    {IDS_REPORT_MESSAGEDELIVERY,        PROPID_M_DELIVERY,       &g_VTUI1,     MsgDeliveryToString,NO_OFFSET,                              0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_AUTHENTICATED,  PROPID_M_AUTHENTICATED,  &g_VTUI1,     BoolToString,       NO_OFFSET,                              0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_HASH_ALG,       PROPID_M_HASH_ALG,       &g_VTUI4,     MsgHashToString,    NO_OFFSET,                              0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_ENCRYPT_ALG,    PROPID_M_ENCRYPTION_ALG, &g_VTUI4,     MsgEncryptToString, NO_OFFSET,                              0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_SRC_MACHINE_ID, PROPID_M_SRC_MACHINE_ID, &g_VTCLSID,   NULL,               FIELD_OFFSET(MsgProps,guidSrcMachineId),0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_SENTTIME,       PROPID_M_SENTTIME,       &g_VTUI4,     TimeToString,       NO_OFFSET,                              0,                   HIDE_COLUMN, SortByCreateTime},
    {IDS_REPORT_MESSAGE_ARRIVEDTIME,    PROPID_M_ARRIVEDTIME,    &g_VTUI4,     TimeToString,       NO_OFFSET,                              0,                   HIDE_COLUMN, SortByModifyTime},
    {IDS_REPORT_MESSAGE_RCPT_QUEUE,     PROPID_M_DEST_QUEUE,     &g_VTLPWSTR,  NULL,               FIELD_OFFSET(MsgProps,wszDestQueue),    0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_RCPT_QUEUE_LEN, PROPID_M_DEST_QUEUE_LEN, &g_VTUI4,     NULL,               NO_OFFSET,                              QUEUELEN,            HIDE_COLUMN, SortByULONG},
    {IDS_REPORT_MESSAGE_RESP_QUEUE,     PROPID_M_RESP_QUEUE,     &g_VTLPWSTR,  NULL,               FIELD_OFFSET(MsgProps,wszRespQueue),    0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_RESP_QUEUE_LEN, PROPID_M_RESP_QUEUE_LEN, &g_VTUI4,     NULL,               NO_OFFSET,                              QUEUELEN,            HIDE_COLUMN, SortByULONG},
    {IDS_REPORT_MESSAGE_ADMIN_QUEUE,    PROPID_M_ADMIN_QUEUE,    &g_VTLPWSTR,  NULL,               FIELD_OFFSET(MsgProps,wszAdminQueue),   0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_ADMIN_QUEUE_LEN,PROPID_M_ADMIN_QUEUE_LEN,&g_VTUI4,     NULL,               NO_OFFSET,                              QUEUELEN,            HIDE_COLUMN, SortByULONG},
    {IDS_REPORT_MESSAGE_TRACE,          PROPID_M_TRACE,          &g_VTUI1,     BoolToString,       NO_OFFSET,                              0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_SENDERID,       PROPID_M_SENDERID,       &g_VectUI1,   MsgSenderIdToString,FIELD_OFFSET(MsgProps,acSenderId),      SENDERLEN,           HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_SENDERID_LEN,   PROPID_M_SENDERID_LEN,   &g_VTUI4,     NULL,               NO_OFFSET,                              SENDERLEN,           HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_SENDERID_TYPE,  PROPID_M_SENDERID_TYPE,  &g_VTUI4,     MsgSendTypeToString,NO_OFFSET,                              0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_PRIV_LEVEL,     PROPID_M_PRIV_LEVEL,     &g_VTUI4,     MsgPrivToString,    NO_OFFSET,                              0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_CORRELATIONID,  PROPID_M_CORRELATIONID,  &g_VectUI1,   MsgIdToString,      FIELD_OFFSET(MsgProps,acCorrelationId), PROPID_M_MSGID_SIZE, HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_DEST_FN,        PROPID_M_DEST_FORMAT_NAME,      &g_VTLPWSTR,NULL,          FIELD_OFFSET(MsgProps,wszMultiDestFN),  0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_DEST_FN_LEN,    PROPID_M_DEST_FORMAT_NAME_LEN,  &g_VTUI4,   NULL,          NO_OFFSET,                              MULTIFNLEN,          HIDE_COLUMN, SortByULONG},
    {IDS_REPORT_MESSAGE_RESP_FN,        PROPID_M_RESP_FORMAT_NAME,      &g_VTLPWSTR,NULL,          FIELD_OFFSET(MsgProps,wszMultiRespFN),  0,                   HIDE_COLUMN, SortByString},
    {IDS_REPORT_MESSAGE_RESP_FN_LEN,    PROPID_M_RESP_FORMAT_NAME_LEN,  &g_VTUI4,   NULL,          NO_OFFSET,                              MULTIFNLEN,          HIDE_COLUMN, SortByULONG},   
    {IDS_REPORT_MESSAGE_LOOKUPID,		PROPID_M_LOOKUPID,		 &g_VTUI8,     NULL,			   NO_OFFSET,							   0,					HIDE_COLUMN, SortByString},
    {NO_TITLE,                          PROPID_M_BODY,           &g_VectUI1,   NULL,               FIELD_OFFSET(MsgProps,acBody),          LABELLEN,            HIDE_COLUMN, SortByString},
    {NO_TITLE,                          PROPID_M_SOAP_ENVELOPE_LEN,     &g_VTUI4,   NULL,          NO_OFFSET,							   0,		            HIDE_COLUMN, SortByString},
    
    {0,                                 0,                       NULL }

};

//////////////////////////////////////////////////////////////////////////////
/*++

GetUserIdAndDomain

  Returned a domain\user string based on a sid

--*/
//////////////////////////////////////////////////////////////////////////////
void GetUserIdAndDomain(CString &strUser, PVOID psid)
{
#define USER_AND_DOMAIN_INIT_SIZE 256
    CString strUid;
    CString strDomain;
    SID_NAME_USE eUse;

    strUser = L"";
    
    if (psid == 0)
            return ;
    
    DWORD cbName = USER_AND_DOMAIN_INIT_SIZE;
    DWORD cpPrevName = 0;
    DWORD cbReferencedDomainName = USER_AND_DOMAIN_INIT_SIZE;
    DWORD cbPrevReferencedDomainName = 0;
    BOOL fReturnValue;

    while(cbPrevReferencedDomainName < cbReferencedDomainName ||
          cpPrevName < cbName)
    {
        cpPrevName = cbName;
        cbPrevReferencedDomainName = cbReferencedDomainName;

        fReturnValue = LookupAccountSid(
            0,          // address of string for system name
            psid, // address of security identifier
            strUid.GetBuffer(cbName / sizeof(TCHAR) + 1),   // address of string for account name
            &cbName,    // address of size account string
            strDomain.GetBuffer(cbReferencedDomainName / sizeof(TCHAR) + 1),    // address of string for referenced domain
            &cbReferencedDomainName,    // address of size domain string
            &eUse   // address of structure for SID type
        );
        strUid.ReleaseBuffer();
        strDomain.ReleaseBuffer();
    }

    strUser.Format(TEXT("%s\\%s"), strDomain, strUid);

}


/////////////////////////////////////////////////////////////////////////////
// CMessage
// {B1320C00-BCB2-11d1-9B9B-00E02C064C39}
static const GUID CMessageGUID_NODETYPE = 
{ 0xb1320c00, 0xbcb2, 0x11d1, { 0x9b, 0x9b, 0x0, 0xe0, 0x2c, 0x6, 0x4c, 0x39 } };

const GUID*  CMessage::m_NODETYPE = &CMessageGUID_NODETYPE;
const OLECHAR* CMessage::m_SZNODETYPE = OLESTR("B1320C00-BCB2-11d1-9B9B-00E02C064C39");
const OLECHAR* CMessage::m_SZDISPLAY_NAME = OLESTR("MSMQ Message Admin");
const CLSID* CMessage::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;

//////////////////////////////////////////////////////////////////////////////
/*++

CMessage::GetQueuePathName

  Get queue path name by format name

--*/
//////////////////////////////////////////////////////////////////////////////
void CMessage::GetQueuePathName(
                     CString  strFormatName,
                     CString &strPathName
                     )
{    
	if(strFormatName[0] == 0)
	{
		TrWARNING(GENERAL, "No format name was supplied");
	    strPathName.Empty();
		return;
	}

    PROPVARIANT   aPropVar[1];
    PROPID        aPropId[1];
    MQQUEUEPROPS  mqprops;
    CString       szError;


    aPropVar[0].vt = VT_NULL;
    aPropVar[0].pwszVal = NULL;
    aPropId[0] = PROPID_Q_PATHNAME;
             
    mqprops.cProp    = 1;
    mqprops.aPropID  = aPropId;
    mqprops.aPropVar = aPropVar;
    mqprops.aStatus  = NULL;        

	//
	// calling MQGetQueueProperties() will try the user domain and then the GC
	// which is ok.
	// We are not using ADGetObjectPropertiesGuid() with a specific domain\DomainController
	// because those are queues on the message and we don't want to limit the search for a specific domain,
	// we want to search the GC.
	//
    HRESULT hr = MQGetQueueProperties(strFormatName, &mqprops);

    if(SUCCEEDED(hr))
    {
        strPathName = aPropVar[0].pwszVal;
		TrTRACE(GENERAL, "PathName = %ls", aPropVar[0].pwszVal);
        MQFreeMemory(aPropVar[0].pwszVal);
		return;
    }

	TrERROR(GENERAL, "MQGetQueueProperties failed, QueueFormatName = %ls, hr = 0x%x", strFormatName, hr);

    MQErrorToMessageString(szError, hr);
    TRACE(_T("CMessage::CreatePropertyPages: Could not get %s pathname. %X - %s\n"), strFormatName,
          hr, szError);
    strPathName.Empty();
}

//////////////////////////////////////////////////////////////////////////////
/*++

CMessage::CreatePropertyPages

  Called when creating a property page of the object

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CMessage::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR /*handle*/, 
	IUnknown* /*pUnk*/,
	DATA_OBJECT_TYPES type)
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (type == CCT_SCOPE || type == CCT_RESULT)
	{
	
        //--------------------------------------
        //
        // Message General Page
        //
        //--------------------------------------      
	    CMessageGeneralPage *pGenPage = new CMessageGeneralPage();

        GetPropertyString(MessageDisplayList, PROPID_M_LABEL,       m_pMsgProps->aPropVar, pGenPage->m_szLabel);
        GetPropertyString(MessageDisplayList, PROPID_M_SENTTIME,    m_pMsgProps->aPropVar, pGenPage->m_szSent);
        GetPropertyString(MessageDisplayList, PROPID_M_ARRIVEDTIME, m_pMsgProps->aPropVar, pGenPage->m_szArrived);
        GetPropertyString(MessageDisplayList, PROPID_M_CLASS,       m_pMsgProps->aPropVar, pGenPage->m_szClass);
        GetPropertyString(MessageDisplayList, PROPID_M_MSGID,       m_pMsgProps->aPropVar, pGenPage->m_szId);
        GetPropertyString(MessageDisplayList, PROPID_M_PRIORITY,    m_pMsgProps->aPropVar, pGenPage->m_szPriority);
        GetPropertyString(MessageDisplayList, PROPID_M_TRACE,       m_pMsgProps->aPropVar, pGenPage->m_szTrack);
		GetPropertyString(MessageDisplayList, PROPID_M_LOOKUPID,    m_pMsgProps->aPropVar, pGenPage->m_szLookupID);
        pGenPage->m_iIcon = m_iIcon;

	    HPROPSHEETPAGE hPage = pGenPage->CreateThemedPropertySheetPage();  

        HRESULT hr = MMCPropPageCallback(&pGenPage->m_psp);
        ASSERT(SUCCEEDED(hr));

        if (hPage == NULL)
	    {
		    return E_UNEXPECTED;  
	    }
    
        lpProvider->AddPage(hPage); 

        //--------------------------------------
        //
        // Message Queues Page
        //
        //--------------------------------------        
        
        CMessageQueuesPage *pQueuePage = new CMessageQueuesPage();                      
        //
        // Get format name for queues. We ask new property _FORMAT_NAME
        // Even if there is only old property we get for this new property
        // old value. 
        //

        GetPropertyString(
                MessageDisplayList,
                PROPID_M_ADMIN_QUEUE, 
                m_pMsgProps->aPropVar, 
                pQueuePage->m_szAdminFN);             
      
        //
        // get format name for response queue
        //        
        GetPropertyString(
                MessageDisplayList,
                PROPID_M_RESP_FORMAT_NAME,
                m_pMsgProps->aPropVar, 
                pQueuePage->m_szRespFN);        
        
        //
        // get format name for destination queue: we need both old and new values
        //
        GetPropertyString(
                MessageDisplayList,
                PROPID_M_DEST_QUEUE, 
                m_pMsgProps->aPropVar, 
                pQueuePage->m_szDestFN);             
      
        GetPropertyString(
                MessageDisplayList,
                PROPID_M_DEST_FORMAT_NAME,
                m_pMsgProps->aPropVar, 
                pQueuePage->m_szMultiDestFN);        

        //
        // Get the destination queue PathName (from Beta1 Whistler: Recipient frame)
        // only for single cast format name
        //                
        GetQueuePathName (pQueuePage->m_szDestFN, pQueuePage->m_szDestPN);           
        
        //
        // Get the response queue PathName only if it is single cast format name
        //
        pQueuePage->m_szRespPN = L"";

        //
        // old property: PROPID_M_RESP_QUEUE
        //
        CString strRespFN(m_pMsgProps->wszRespQueue);  

        if(strRespFN == pQueuePage->m_szRespFN)
        {
            //
            // it is single response queue
            //            
            GetQueuePathName (strRespFN, pQueuePage->m_szRespPN);        
        }

        CString strAdminFN(m_pMsgProps->wszAdminQueue);  
        
        GetQueuePathName (strAdminFN, pQueuePage->m_szAdminPN);            

	    hPage = pQueuePage->CreateThemedPropertySheetPage();


        if (hPage == NULL)
	    {
		    return E_UNEXPECTED;  
	    }
    
        hr = MMCPropPageCallback(&pQueuePage->m_psp);
        ASSERT(SUCCEEDED(hr));

        lpProvider->AddPage(hPage); 


        //--------------------------------------
        //
        // Message Senders Page
        //
        //--------------------------------------
        MQQMPROPS qmprops;        

        CMessageSenderPage *pSenderPage = new CMessageSenderPage();
        GetPropertyString(MessageDisplayList, PROPID_M_AUTHENTICATED, m_pMsgProps->aPropVar, pSenderPage->m_szAuthenticated);
        GetPropertyString(MessageDisplayList, PROPID_M_PRIV_LEVEL,    m_pMsgProps->aPropVar, pSenderPage->m_szEncrypt);
        GetPropertyString(MessageDisplayList, PROPID_M_ENCRYPTION_ALG,m_pMsgProps->aPropVar, pSenderPage->m_szEncryptAlg);
        GetPropertyString(MessageDisplayList, PROPID_M_SRC_MACHINE_ID,m_pMsgProps->aPropVar, pSenderPage->m_szGuid);
        GetPropertyString(MessageDisplayList, PROPID_M_HASH_ALG,      m_pMsgProps->aPropVar, pSenderPage->m_szHashAlg);
        GetPropertyString(MessageDisplayList, PROPID_M_SENDERID,      m_pMsgProps->aPropVar, pSenderPage->m_szSid);
        
        //
        // Get machine pathname
        //
        PROPVARIANT   aPropVar[1];
        PROPID        aPropId[1];        
        CString       szError;

        aPropVar[0].vt = VT_NULL;
        aPropVar[0].pwszVal = NULL;
        aPropId[0] = PROPID_QM_PATHNAME;

        qmprops.cProp    = 1;
        qmprops.aPropID  = aPropId;
        qmprops.aPropVar = aPropVar;
        qmprops.aStatus  = NULL;

		//
		// calling MQGetMachineProperties() will try the user domain and then the GC
		// which is ok. 
		// we are looking for the sending QM so we really wants to look in the GC.
		// We are not using ADGetObjectPropertiesGuid() with a specific domain\DomainController
		// because it will limit the search only
		// for a specific domain and will not search the GC.
		//
        hr = MQGetMachineProperties(NULL, &m_pMsgProps->guidSrcMachineId, &qmprops);
        if(SUCCEEDED(hr))
        {
            pSenderPage->m_szPathName = aPropVar[0].pwszVal;
            MQFreeMemory(aPropVar[0].pwszVal);
        }
        else
        {
            TCHAR szMachineGuid[x_dwMaxGuidLength];
            StringFromGUID2(m_pMsgProps->guidSrcMachineId, szMachineGuid, TABLE_SIZE(szMachineGuid));
            
            MQErrorToMessageString(szError, hr);

            TRACE(_T("CMessage::CreatePropertyPages: Could not get %s pathname. %X - %s\n"), szMachineGuid,
                  hr, szError);

            pSenderPage->m_szPathName = szMachineGuid;
        }

        //
        // Get user account and domain, based on Sid
        //
        GetUserIdAndDomain(pSenderPage->m_szUser, &m_pMsgProps->acSenderId);

	    hPage = pSenderPage->CreateThemedPropertySheetPage();

        if (hPage == NULL)
	    {
		    return E_UNEXPECTED;  
	    }
    
        hr = MMCPropPageCallback(&pSenderPage->m_psp);
        ASSERT(SUCCEEDED(hr));

        lpProvider->AddPage(hPage); 

        
        //--------------------------------------
        //
        // Message Body Page
        //
        //--------------------------------------        
        CMessageBodyPage *pBodyPage = new CMessageBodyPage();
        PROPVARIANT * pvarSize;
        DWORD dwSize;
      
        GetPropertyVar(MessageDisplayList, PROPID_M_BODY_SIZE, m_pMsgProps->aPropVar, &pvarSize);

        ASSERT(pvarSize->vt == VT_UI4);
        dwSize = pvarSize->ulVal;

        pBodyPage->m_Buffer = m_pMsgProps->acBody;

        if (dwSize > BODYLEN)
        {
            pBodyPage->m_strBodySizeMessage.FormatMessage(
                IDS_BODY_SIZE_PARTIAL_MESSAGE,
                BODYLEN,
                dwSize);
            pBodyPage->m_dwBufLen = BODYLEN;
        }
        else
        {
            pBodyPage->m_strBodySizeMessage.FormatMessage(
                IDS_BODY_SIZE_NORMAL_MESSAGE,
                dwSize);
             pBodyPage->m_dwBufLen = dwSize;
		}

	    hPage = pBodyPage->CreateThemedPropertySheetPage();
        if (hPage == NULL)
	    {
		    return E_UNEXPECTED;  
	    }
    
        hr = MMCPropPageCallback(&pBodyPage->m_psp);
        ASSERT(SUCCEEDED(hr));

        lpProvider->AddPage(hPage); 


        //--------------------------------------
		//
		// Message SOAP Envelope Page
		//
        //--------------------------------------
        PROPVARIANT * pvarSoapEnvSize;
        GetPropertyVar(MessageDisplayList, PROPID_M_SOAP_ENVELOPE_LEN, m_pMsgProps->aPropVar, &pvarSoapEnvSize);
        ASSERT(pvarSoapEnvSize->vt == VT_UI4);

		if (pvarSoapEnvSize->ulVal > 0)
		{
			PROPVARIANT * pvarLookupID;
			GetPropertyVar(MessageDisplayList, PROPID_M_LOOKUPID, m_pMsgProps->aPropVar, &pvarLookupID);
			ASSERT(pvarLookupID->vt == VT_UI8);

			CMessageSoapEnvPage *pSoapEnvPage = new CMessageSoapEnvPage(
																pvarSoapEnvSize->ulVal,
																m_strQueueFormatName,
																pvarLookupID->uhVal.QuadPart
																);
      
			hPage = pSoapEnvPage->CreateThemedPropertySheetPage();

			if (hPage == NULL)
			{
				return E_UNEXPECTED;  
			}
    
			hr = MMCPropPageCallback(&pSoapEnvPage->m_psp);
			ASSERT(SUCCEEDED(hr));

			lpProvider->AddPage(hPage);
		}

        return(S_OK);


	}
	return E_UNEXPECTED;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CMessage::SetVerbs

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CMessage::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hr;
    //
    // Display verbs that we support
    //
    hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );

    // We want the default verb to be Properties
	hr = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    return(hr);
}
        
//////////////////////////////////////////////////////////////////////////////
/*++

CMessage::GetResultPaneColInfo

  Param - nCol: Column number
  Returns - String to be displayed in the specific column


Called for each column in the result pane.


--*/
//////////////////////////////////////////////////////////////////////////////
LPOLESTR CMessage::GetResultPaneColInfo(int nCol)
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Make sure that nCol is not larger than the last index in
    // MessageDisplayList that is actually a column
    //
    ASSERT(nCol < (ARRAYSIZE(MessageDisplayList)-3));

    //
    // Get a display string of that property
    //
    CString strTemp = m_bstrLastDisplay;
    ItemDisplay(&MessageDisplayList[nCol], &(m_pMsgProps->aPropVar[nCol]),strTemp);
    m_bstrLastDisplay = strTemp;
    
    //
    // Return a pointer to the string buffer.
    //
    return(m_bstrLastDisplay);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CMessage::GetValueInColumn

  Param - nCol: Column number
  Returns - Propvariant representing the value in the column


Called for each column in the result pane.


--*/
//////////////////////////////////////////////////////////////////////////////
PROPVARIANT *CMessage::GetValueInColumn(int nCol)
{
    ASSERT(nCol < ARRAYSIZE(MessageDisplayList));

    return &m_pMsgProps->aPropVar[nCol];
}

//////////////////////////////////////////////////////////////////////////////
void CMessage::UpdateIcon()
{
    PROPVARIANT * pvar;
    GetPropertyVar(MessageDisplayList, PROPID_M_CLASS, m_pMsgProps->aPropVar, &pvar);
    ASSERT(pvar->vt == VT_UI2);
    USHORT usClass = pvar->uiVal;

    GetPropertyVar(MessageDisplayList, PROPID_M_TRACE, m_pMsgProps->aPropVar, &pvar);
    ASSERT(pvar->vt == VT_UI1);
    BOOL fTrace = pvar->bVal;

    DWORD iImage;

    if (fTrace)
    {
        iImage = IMAGE_TEST_MESSAGE;
        m_iIcon = IDI_TEST_MSG;
    }
    else if(MQCLASS_NACK(usClass))
    {
        iImage = IMAGE_NACK_MESSAGE;
        m_iIcon = IDI_NACK_MSG;
    }
    else
    {
        switch(usClass)
        {
            case MQMSG_CLASS_ACK_REACH_QUEUE:
            case MQMSG_CLASS_ACK_RECEIVE:
            case MQMSG_CLASS_ORDER_ACK:
                iImage = IMAGE_ACK_MESSAGE;
                m_iIcon = IDI_ACK_MSG;
                break;

            case MQMSG_CLASS_REPORT:
                iImage = IMAGE_REPORT_MESSAGE;
                m_iIcon = IDI_REPORT_MSG;
                break;

            case MQMSG_CLASS_NORMAL:
            default:
                iImage = IMAGE_MESSAGE;
                m_iIcon = IDI_MSGICON;
                break;
        }
    }

    SetIcons(iImage, iImage);

}


//
// Compare two items in a given column. *pnResult contain column on entry,
// and -1 (<). 0 (==), or 1 (>) on exit.
//
HRESULT CMessage::Compare(LPARAM /*lUserParam*/, CMessage *pItemToCompare, int* pnResult)
{
    int nCol = *pnResult;
    PROPVARIANT *ppropvA = GetValueInColumn(nCol); 
    PROPVARIANT *ppropvB = pItemToCompare->GetValueInColumn(nCol);
    
    if (ppropvA == 0 || ppropvB == 0)
    {
        return E_UNEXPECTED;
    }

    *pnResult = CompareVariants(ppropvA, ppropvB);
    return S_OK;
}


CString 
CMessage::GetHelpLink()
{
	CString strHelpLink;
	strHelpLink.LoadString(IDS_HELPTOPIC_MESSAGES);
	return strHelpLink;
}

//////////////////////////////////////////////////////////////////////////////
/*++

MessageDataSize

   Returns the max possible size for message information

--*/
//////////////////////////////////////////////////////////////////////////////
DWORD MessageDataSize(void)
{
    DWORD dwTableSize;
    DWORD dwItemSize;

    dwTableSize = sizeof(MessageDisplayList)/sizeof(PropertyDisplayItem);
    dwItemSize = sizeof(DWORD) + sizeof(INT);

    return(dwItemSize * dwTableSize);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\machtrac.h ===
// MachineTracking.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMachineTracking dialog

class CMachineTracking : public CMqDialog
{
	DECLARE_DYNCREATE(CMachineTracking)

// Construction
public:
	CMachineTracking(
		const GUID& gMachineID = GUID_NULL, 
		const CString& strDomainController = CString(""),
		BOOL fLocaLMgmt = FALSE
		);

	~CMachineTracking();

	void Disable();

// Dialog Data
	//{{AFX_DATA(CMachineTracking)
	enum { IDD = IDD_MACHINE_TRACKING };
	CComboBox	m_ReportQueueCtrl;
	CString	m_ReportQueueName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMachineTracking)
	public:
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	int m_iTestButton;
	BOOL m_fTestAll;
    CArray<GUID, const GUID&> m_aguidAllQueues;

	// Generated message map functions
	//{{AFX_MSG(CMachineTracking)
//	afx_msg void OnMtrackingSendtestmsg();
//	afx_msg void OnMtrackingSetpropflag();
//	afx_msg void OnMtrackingSetreportqueue();
	virtual BOOL OnInitDialog();
	afx_msg void OnReportqueueNew();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void DisableAllWindowChilds();
	CString m_LastReportQName;
	CString m_strDomainController;
    GUID m_gMachineID;
	BOOL m_fLocalMgmt;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\mobile.cpp ===
// Mobile.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqppage.h"
#include "localutl.h"
#include "Mobile.h"
#include "..\..\ds\h\servlist.h"
#include <winreg.h>

#define DLL_EXPORT  __declspec(dllexport)
#define DLL_IMPORT  __declspec(dllimport)

#include <rt.h>
#include "_registr.h"
#include "mqcast.h"

#include "mobile.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMobilePage property page

IMPLEMENT_DYNCREATE(CMobilePage, CMqPropertyPage)

void CMobilePage::SetSiteName()
{
	TCHAR wcsSiteName[1000] = L"";
	DWORD dwSize = sizeof(wcsSiteName);
	DWORD dwType = REG_SZ;

	//
	// Read site name from registry
	//
	LONG rc = GetFalconKeyValue(MSMQ_SITENAME_REGNAME, &dwType, wcsSiteName, &dwSize, L"");

	if (_tcscmp(wcsSiteName, TEXT("")))
	{
		m_fSiteRead = TRUE ;
	}

	m_strCurrentSite = wcsSiteName;
}

CMobilePage::CMobilePage() : CMqPropertyPage(CMobilePage::IDD)
{
    m_fModified = FALSE;

    m_fSiteRead = FALSE ;
    SetSiteName() ;
}

CMobilePage::~CMobilePage()
{
}

void CMobilePage::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMobilePage)
	DDX_Control(pDX, ID_SiteList, m_box);
	DDX_Text(pDX, ID_CurrentSite, m_strCurrentSite);
	//}}AFX_DATA_MAP
    if (pDX->m_bSaveAndValidate)
    {
        DWORD iNewSite = m_box.GetCurSel();
        if (iNewSite != CB_ERR)
        {
            m_box.GetLBText(iNewSite, m_szNewSite);
            m_fModified = TRUE;
        }
    }
    else
    {
       DWORD iSite = m_box.FindStringExact(0, m_szNewSite);
       m_box.SetCurSel(iSite) ;
    }
}


BEGIN_MESSAGE_MAP(CMobilePage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CMobilePage)
    ON_CBN_SELCHANGE(ID_SiteList, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMobilePage message handlers

BOOL CMobilePage::OnInitDialog()
{
    return CMqPropertyPage::OnInitDialog();
}


BOOL CMobilePage::OnSetActive()
{

    if (!m_fSiteRead)
    {
       //
       // site name not yet read from registry. Try to read it now.
       //
       UpdateData(TRUE) ;
       SetSiteName() ;
       UpdateData(FALSE) ;
    }

    TCHAR tPrivKeyName[256] = {0} ;

    HKEY hServersCacheKey;
    HRESULT rc;
    DWORD dwSizeVal ;
    DWORD dwSizeData ;
    TCHAR  szName[1000];

    TCHAR  data[ MAX_REG_DSSERVER_LEN ] ;

    _tcscpy(tPrivKeyName, FALCON_REG_KEY) ;
    _tcscat(tPrivKeyName, TEXT("\\"));
    _tcscat(tPrivKeyName, MSMQ_SERVERS_CACHE_REGNAME);

    // obtain a handle to key ServersCache
    rc = RegOpenKeyEx( FALCON_REG_POS,
                       tPrivKeyName,
                       0L,
                       KEY_ALL_ACCESS,
                       &hServersCacheKey );
    if (rc != ERROR_SUCCESS)
    {
	    return TRUE;
    }

    m_box.ResetContent() ;
    DWORD dwIndex = 0;               // enumeration Index
    //
    //  enumerate the values of ServersCache
    //  and add them to list-box
    //
    do
    {
	    //dwSizeVal  = sizeof(szName) ;
	    //dwSizeData = sizeof(data) ;
	    dwSizeVal  = sizeof(szName)/sizeof(TCHAR) ;//size in characters
	    dwSizeData = sizeof(data);				// size in bytes

	    rc = RegEnumValue( hServersCacheKey,// handle of key to query
                         dwIndex,         // index of value to query
                         szName,	      // address of buffer for value string
                         &dwSizeVal,      // address for size of value buffer
                         0L,	          // reserved
                         NULL,            // type
                         (BYTE*) data,    // address of buffer for value data
                         &dwSizeData      // address for size of value data
                       );

	    if (rc != ERROR_SUCCESS)
      {
	    break ;
	    }



	    //don't add values starting with '\'
	    if ((char)data[0] != (char) NEW_SITE_IN_REG_FLAG_CHR)
      {
          //add to list-box
          m_box.AddString(szName);
      }

	    dwIndex++;
    } while (TRUE);

    CMqPropertyPage::OnSetActive();

    RegCloseKey( hServersCacheKey );
    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CMobilePage::OnApply()
{
    if (!m_fModified || !UpdateData(TRUE))
    {
        return TRUE;
    }

    TCHAR tPrivKeyName[256] = {0} ;
    HKEY ServersCacheKey;
	TCHAR szData[1000];
	TCHAR szServersList[1000];

    HRESULT rc;
    DWORD dwSize;
    DWORD dwType;
	TCHAR  szTmp1[1000];
    TCHAR  szTmp[100];


	/*how to reconstruct the precious status */

    //ConvertFromWideCharString(MSMQ_SERVERS_CACHE_REGNAME, szTmp);
	_tcscpy(szTmp,MSMQ_SERVERS_CACHE_REGNAME);
    _tcscpy(tPrivKeyName, FALCON_REG_KEY);
    _tcscat(tPrivKeyName, TEXT("\\"));
    _tcscat(tPrivKeyName, szTmp);

    //open registry key ServersCache
    rc = RegOpenKeyEx(FALCON_REG_POS,
                      tPrivKeyName,
                      0L,
                      KEY_ALL_ACCESS,
                      &ServersCacheKey
                      );
    if (rc != ERROR_SUCCESS) {
        DisplayFailDialog();
        return TRUE;
    }


    //get the servers list (value of key ServersCache)
    dwSize=sizeof(szData);
    rc = RegQueryValueEx(ServersCacheKey,        // handle of key to query
                         m_szNewSite,           // address of name of value to query
                         NULL,                   // reserved
                         NULL,                   // address of buffer for value type
                         (BYTE *)szData,                   // address of data buffer
                         &dwSize                 // address of data buffer size
                         );
    if (rc != ERROR_SUCCESS) {
        DisplayFailDialog();
        return TRUE;
    }


    //make the servers list Unicode
    //ConvertToWideCharString((char*)data,szServersList);
	_tcscpy(szServersList,szData);

    //write servers list as new value for key MQISServer
    dwType = REG_SZ;
	dwSize = (numeric_cast<DWORD>(_tcslen(szServersList) +1 )) * sizeof(TCHAR);
    rc = SetFalconKeyValue(MSMQ_DS_SERVER_REGNAME,
                           &dwType,
                           szServersList,
                           &dwSize
                           );
    //
    // BUGBUG:SetFalconKeyValue accepts WCHAR
    //
    ASSERT(rc == ERROR_SUCCESS);

    //save in registry new value for key SiteName
	//ConvertToWideCharString(pageMobile.m_szNewSite,wcsTmp);
	_tcscpy(szTmp1, m_szNewSite);

    dwSize = (numeric_cast<DWORD>(_tcslen(szTmp1) + 1)) * sizeof(TCHAR);
    dwType = REG_SZ;
    rc = SetFalconKeyValue(MSMQ_SITENAME_REGNAME,
                           &dwType,
                           szTmp1,
                           &dwSize
                           );
     //
     // BUGBUG:SetFalconKeyValue accepts WCHAR
     //
    ASSERT(rc == ERROR_SUCCESS);


    //save in registry new value for key SiteId
    dwType = REG_BINARY;
    dwSize = sizeof(GUID_NULL);
    rc = SetFalconKeyValue(MSMQ_SITEID_REGNAME,
                           &dwType,
                           (void*)&GUID_NULL,
                           &dwSize
                           );
    //
    // BUGBUG:SetFalconKeyValue accepts WCHAR
    //
    ASSERT(rc == ERROR_SUCCESS);

    m_fNeedReboot = TRUE;

    return CMqPropertyPage::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\mgmtext.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	mgmtext.cpp

Abstract:
	Implementation for the Local Computer management extensions

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "cpropmap.h"
#include "rt.h"
#include "mgmtext.h"
#include "lqDsply.h"
#include "localadm.h"

#include "mgmtext.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/****************************************************

CSnapinComputerMgmt Class
    
 ****************************************************/

/////////////////////////////////////////////////////////////////////////////
// {2B39B2B2-2166-11d2-9BA5-00E02C064C39}
static const GUID CSnapinComputerMgmtGUID_NODETYPE = 
{ 0x2b39b2b2, 0x2166, 0x11d2, { 0x9b, 0xa5, 0x0, 0xe0, 0x2c, 0x6, 0x4c, 0x39 } };


const GUID*  CSnapinComputerMgmt::m_NODETYPE = &CSnapinComputerMgmtGUID_NODETYPE;
const OLECHAR* CSnapinComputerMgmt::m_SZNODETYPE = OLESTR("2B39B2B2-2166-11d2-9BA5-00E02C064C39");
const OLECHAR* CSnapinComputerMgmt::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CSnapinComputerMgmt::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComputerMgmt::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinComputerMgmt::PopulateScopeChildrenList()
{
    HRESULT hr = S_OK;
    CString strTitle;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CSnapinLocalAdmin *pAdmin;

    pAdmin = new CSnapinLocalAdmin(this, m_pComponentData, m_szMachineName);
    strTitle.LoadString(IDS_LOCAL_MACHINE_ADM);
    pAdmin->m_bstrDisplayName = strTitle;
    
    //
    // Update the state, but do not refresh the icon because the icon was not added yet
    //
    hr = pAdmin->UpdateState(false);

    if(FAILED(hr))
    {
        //
        // If failed, Do not display the icon. No error message is displayed.
        // We do not display an error message because the user of Computer Management
        // snap-in may not be interested in MSMQ at all.
        //
        TRACE(_T("UpdateIcon failed on %s. Error = %X"), m_szMachineName, hr);                
        //
        // BUGBUG. memory leak: to free pAdmin here
        //
        return (hr);
    }

    AddChild(pAdmin, &pAdmin->m_scopeDataItem);

    return(hr);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComputerMgmt::OnRemoveChildren

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSnapinComputerMgmt::OnRemoveChildren( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{

    ((CComputerMgmtExtData *)m_pParentNode)->RemoveChild(m_szMachineName);

	return (S_OK);
}
    
/****************************************************

        CComputerMgmtExtData Class
    
 ****************************************************/
//
// Extending the Local Computer Management MMC.
// We are extending the "SystemTools" folder of the local computer
//
// Nodes defined by the local Computer Management MMC are:
//
//#define struuidNodetypeComputer      "{476e6446-aaff-11d0-b944-00c04fd8d5b0}"
//#define struuidNodetypeDrive         "{476e6447-aaff-11d0-b944-00c04fd8d5b0}"
//#define struuidNodetypeSystemTools   "{476e6448-aaff-11d0-b944-00c04fd8d5b0}"
//#define struuidNodetypeServerApps    "{476e6449-aaff-11d0-b944-00c04fd8d5b0}"
//#define struuidNodetypeStorage       "{476e644a-aaff-11d0-b944-00c04fd8d5b0}"
//
//#define lstruuidNodetypeComputer    L"{476e6446-aaff-11d0-b944-00c04fd8d5b0}"
//#define lstruuidNodetypeDrive       L"{476e6447-aaff-11d0-b944-00c04fd8d5b0}"
//#define lstruuidNodetypeSystemTools L"{476e6448-aaff-11d0-b944-00c04fd8d5b0}"
//#define lstruuidNodetypeServerApps  L"{476e6449-aaff-11d0-b944-00c04fd8d5b0}"
//#define lstruuidNodetypeStorage     L"{476e644a-aaff-11d0-b944-00c04fd8d5b0}"
//
//#define structuuidNodetypeComputer    \
//    { 0x476e6446, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }
//#define structuuidNodetypeDrive       \
//    { 0x476e6447, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }
//#define structuuidNodetypeSystemTools \
//    { 0x476e6448, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }
//#define structuuidNodetypeServerApps  \
//    { 0x476e6449, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }
//#define structuuidNodetypeStorage     \
//    { 0x476e644a, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }
//
//


// Extension of the ServerApps nodes
static const GUID CComputerMgmtExtDataGUID_NODETYPE = 
  { 0x476e6449, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };

const GUID*  CComputerMgmtExtData::m_NODETYPE = &CComputerMgmtExtDataGUID_NODETYPE;
const OLECHAR* CComputerMgmtExtData::m_SZNODETYPE = OLESTR("476e6449-aaff-11d0-b944-00c04fd8d5b0");
const OLECHAR* CComputerMgmtExtData::m_SZDISPLAY_NAME = OLESTR("MSMQAdmin");
const CLSID* CComputerMgmtExtData::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;



//////////////////////////////////////////////////////////////////////////////
/*++

CComputerMgmtExtData::CreatePropertyPages

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CComputerMgmtExtData::CreatePropertyPages(
	LPPROPERTYSHEETCALLBACK /*lpProvider*/,
    LONG_PTR /*handle*/, 
	IUnknown* /*pUnk*/,
	DATA_OBJECT_TYPES type)
{
	if (type == CCT_SCOPE || type == CCT_RESULT)
	{
//		CSnapPage* pPage = new CSnapPage(_T("Snap"));
//		lpProvider->AddPage(pPage->Create());

		// TODO : Add code here to add additional pages
		return S_OK;
	}
	return E_UNEXPECTED;
}

void ExtractComputerName(IDataObject* pDataObject, CString& strComputer)
{
    strComputer=L"";

	//
	// Find the computer name from the ComputerManagement snapin
	//
	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { gx_CCF_COMPUTERNAME, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    //
    // Allocate memory for the stream
    //
    int len = 500;

    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, len);

	if(stgmedium.hGlobal == NULL)
		return;


	HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium);

    ASSERT(SUCCEEDED(hr));

	//
	// Get the computer name
	//
    strComputer = (WCHAR *)stgmedium.hGlobal;

	GlobalFree(stgmedium.hGlobal);


}

//////////////////////////////////////////////////////////////////////////////
/*++

CComputerMgmtExtData::GetExtNodeObject

  Called with a node that we need to expand. 
  Check if we have already a snapin object corresponding to this node,
  else create a new one.

--*/
//////////////////////////////////////////////////////////////////////////////
CSnapInItem* CComputerMgmtExtData::GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* /*pDefault*/)
{
    CString strComputer; 
    CSnapinComputerMgmt *pCompMgmt;


    ExtractComputerName(pDataObject, strComputer);

    //
    // Already extending...
    //
    HRESULT rc = m_mapComputers.Lookup(strComputer, pCompMgmt);
    if(rc == TRUE)
        return(pCompMgmt);

	//
	// Create our extension
	//
	pCompMgmt = new CSnapinComputerMgmt(this, m_pComponentData, strComputer);

    //
    // Add it to the map
    //
    m_mapComputers.SetAt(strComputer, pCompMgmt);

    return(pCompMgmt);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComputerMgmtExtData::~CComputerMgmtExtData

  Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CComputerMgmtExtData::~CComputerMgmtExtData()
{

    //
    // bug!!! We must remove all children...
    //
    //RemoveChild(m_pCompMgmt);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComputerMgmtExtData::RemoveChild


--*/
//////////////////////////////////////////////////////////////////////////////
void CComputerMgmtExtData::RemoveChild(CString &strCompName)
{    
    
    BOOL rc;
    CSnapinComputerMgmt *pCompMgmt;

    rc = m_mapComputers.Lookup(strCompName, pCompMgmt);

    if(rc == FALSE)
    {
        ASSERT(0);
        return;
    }

    rc = m_mapComputers.RemoveKey(strCompName);
    ASSERT(rc == TRUE);

    //
    // BUGBUG: Must delete it but we get AV when exiting MMC
    //
    //delete pCompMgmt;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\mobile.h ===
// Mobile.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMobilePage dialog

class CMobilePage : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CMobilePage)

// Construction
public:
	CMobilePage();
	~CMobilePage();

// Dialog Data
	//{{AFX_DATA(CMobilePage)
	enum { IDD = IDD_MOBILE };
	CComboBox	m_box;
	CString	m_strCurrentSite;
	//}}AFX_DATA
	CString m_szNewSite;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMobilePage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMobilePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
   void SetSiteName() ;   
   BOOL  m_fSiteRead ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\message.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	message.h

Abstract:

	Definition file for the CMessage snapin node class.

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////

#ifndef __MSMQMSG_H_
#define __MSMQMSG_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnode.h"

#include "icons.h"

#define MAX_VAR     50
#define BODYLEN     260
#define LABELLEN    260
#define QUEUELEN    200
#define SENDERLEN   100
#define MULTIFNLEN  260

#define SET_LAST_CHAR_AS_ZERO(wsz)     (wsz)[ sizeof(wsz)/sizeof((wsz)[0]) - 1 ] = _T('\0')

struct MsgProps
{
    // 
    // Message properties that need buffer
    //
    WCHAR             wszLabel[LABELLEN];
    char              acMsgId[PROPID_M_MSGID_SIZE];
    UCHAR             acBody[BODYLEN];
    GUID              guidSrcMachineId;    
    WCHAR             wszDestQueue[QUEUELEN];        
    WCHAR             wszRespQueue[QUEUELEN];        
    WCHAR             wszAdminQueue[QUEUELEN];    
    char              acSenderId[SENDERLEN];
    char              acCorrelationId[PROPID_M_MSGID_SIZE];
    WCHAR             wszMultiDestFN[MULTIFNLEN];    
    WCHAR             wszMultiRespFN[MULTIFNLEN];


    PROPVARIANT aPropVar[MAX_VAR];
    PROPID      aPropId[MAX_VAR];

};

class CMessage : public CSnapinNode<CMessage, FALSE>
{
public:
 
	CComPtr<IControlbar> m_spControlBar; 

  	BEGIN_SNAPINCOMMAND_MAP(CMessage, FALSE)
	END_SNAPINCOMMAND_MAP()

   	SNAPINMENUID(IDR_SNAPIN_MENU)

    CMessage(
		CSnapInItem * pParentNode, 
		CSnapin * pComponentData,
		LPCWSTR pwcsQueueFormatName
		) : 
        CSnapinNode<CMessage, FALSE>(pParentNode, pComponentData),
		m_strQueueFormatName(pwcsQueueFormatName)
	{
        
        SetIcons(IMAGE_MESSAGE, IMAGE_MESSAGE);

        m_pMsgProps = NULL;
        m_iIcon = IDI_MSGICON;
	}

	~CMessage()
	{
        delete m_pMsgProps;
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

    HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

	LPOLESTR GetResultPaneColInfo(int nCol);

    void SetMsgProps(MsgProps * pMsgProps);

    PROPVARIANT *CMessage::GetValueInColumn(int nCol);

    virtual HRESULT Compare(LPARAM lUserParam, CMessage *pItemToCompare, int* pnResult);

private:
    void UpdateIcon();   

    void GetQueuePathName(CString strFormatName, CString &strPathName);  

	virtual CString GetHelpLink();

    MsgProps *  m_pMsgProps;                // Property value of the message
	CComBSTR    m_bstrLastDisplay;          // Last column displayed
    DWORD m_iIcon;

	CString m_strQueueFormatName;
};

inline void CMessage::SetMsgProps(MsgProps * pMsgProps)
{   
    m_pMsgProps = pMsgProps;
    UpdateIcon();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\mqppage.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

   mqppage.h

Abstract:

   General property page class - used as base class for all
   mqsnap property pages.

Author:

    YoelA


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __MQPPAGE_H__
#define __MQPPAGE_H__

#include <tr.h>
#include <ref.h>

/////////////////////////////////////////////////////////////////////////////
// CMqPropertyPage
class CMqPropertyPage : public CPropertyPageEx, public CReference
{
DECLARE_DYNCREATE(CMqPropertyPage)

public:
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMqPropertyPage)
	//}}AFX_VIRTUAL
	HPROPSHEETPAGE CreateThemedPropertySheetPage();

protected:
  	//{{AFX_MSG(CMqPropertyPage)
    	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
    afx_msg virtual void OnChangeRWField();
    virtual void OnChangeRWField(BOOL bChanged);
    BOOL m_fModified;
    BOOL m_fNeedReboot;
  	CMqPropertyPage(UINT nIDTemplate, UINT nIDCaption = 0);
    CMqPropertyPage() {};    

    void RestartWindowsIfNeeded(); 

    
    static UINT CALLBACK MqPropSheetPageProc(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
    virtual void OnReleasePage() ;

    afx_msg LRESULT OnDisplayChange(WPARAM wParam, LPARAM lParam);
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);

private:
    LPFNPSPCALLBACK m_pfnOldCallback;
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CMqDialog
class CMqDialog : public CDialog
{
DECLARE_DYNCREATE(CMqDialog)

public:
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMqDialog)
	//}}AFX_VIRTUAL

protected:
  	//{{AFX_MSG(CMqDialog)
    	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	CMqDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
	CMqDialog(UINT nIDTemplate, CWnd* pParentWnd = NULL);
	CMqDialog();

	DECLARE_MESSAGE_MAP()
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\mqppage.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

   mqppage.cpp

Abstract:

   General property page class - used as base class for all
   mqsnap property pages.

Author:

    YoelA


--*/

#include "stdafx.h"
#include "resource.h"
#include "mqPPage.h"
#include "mqsnhlps.h"
#include "globals.h"
#include "Restart.h"
#include "localutl.h"

#include "mqppage.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMqPropertyPage

IMPLEMENT_DYNCREATE(CMqPropertyPage, CPropertyPageEx)

BEGIN_MESSAGE_MAP(CMqPropertyPage, CPropertyPageEx)
	//{{AFX_MSG_MAP(CMqPropertyPage)
	    ON_WM_HELPINFO()
	    ON_WM_CONTEXTMENU()
    	ON_WM_SETTINGCHANGE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_DISPLAYCHANGE, OnDisplayChange)
END_MESSAGE_MAP()

CMqPropertyPage::CMqPropertyPage(UINT nIDTemplate, UINT nIDCaption /* = 0 */)
 : CPropertyPageEx(nIDTemplate, nIDCaption),
 m_fModified(FALSE),
 m_fNeedReboot(FALSE)
{
    m_psp.lParam = (LPARAM)this;
    m_pfnOldCallback = m_psp.pfnCallback;
    m_psp.pfnCallback = MqPropSheetPageProc;
}

/////////////////////////////////////////////////////////////////////////////
// MqPropSheetPageProc - replaces the MMC / MFC callback and add release of the
// allocated window.

UINT CALLBACK CMqPropertyPage::MqPropSheetPageProc(
    HWND hWnd, //Reserved, will always be 0
    UINT uMsg,		
    LPPROPSHEETPAGE ppsp)
{
    CMqPropertyPage *pThis = (CMqPropertyPage *)ppsp->lParam;

    ASSERT(0 != pThis->m_pfnOldCallback);

    UINT uiRetVal = pThis->m_pfnOldCallback(hWnd, uMsg, ppsp);

    switch(uMsg)
    {
        case PSPCB_RELEASE:                       
            pThis->OnReleasePage() ;            
            pThis->Release();
    }

    return uiRetVal;
}

BOOL CMqPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (pHelpInfo->iContextType == HELPINFO_WINDOW)   // must be for a control
    {
	    ::WinHelp ((HWND)pHelpInfo->hItemHandle,
		    AfxGetApp()->m_pszHelpFilePath,
		    HELP_WM_HELP,
		    (DWORD_PTR)(LPVOID)g_aHelpIDs);
    }
    return TRUE;
}

void CMqPropertyPage::OnContextMenu(CWnd* pWnd, CPoint /*point*/)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if (this == pWnd)
		return;

	::WinHelp (pWnd->m_hWnd,
		AfxGetApp()->m_pszHelpFilePath,
		HELP_CONTEXTMENU,
		(DWORD_PTR)(LPVOID)g_aHelpIDs);
}

void CMqPropertyPage::OnChangeRWField(BOOL bChanged)
{
    m_fModified = bChanged;
    SetModified(bChanged);	
}

//
// Note: do not change this to use default parameter - this will not work since we use
// this function in message maps
//
void CMqPropertyPage::OnChangeRWField()
{
    OnChangeRWField(TRUE);
}

void CMqPropertyPage::RestartWindowsIfNeeded()
{    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());    
    
    CRestart dlgRestart;     

    if (m_fNeedReboot && dlgRestart.DoModal() == IDOK)
    {
       BOOL fRet = OnRestartWindows();                	       
    }
    
}


void CMqPropertyPage::OnReleasePage()
{       
    RestartWindowsIfNeeded();
}

LRESULT CMqPropertyPage::OnDisplayChange(WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());        
    return CPropertyPageEx::OnDisplayChange(wParam, lParam);
}

void CMqPropertyPage::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CPropertyPageEx::OnSettingChange(uFlags, lpszSection);
}

//+--------------------------------------------------------------------------
//  Function:   CreateThemedPropertyPage
//
//  Synopsis:   Helper function to make sure that property pages put up
//              by the snap-in are themed.
//              Note that m_psp of a property page in MFC is of type AFX_OLDPROPSHEETPAGE,
//              which do not support themes. In order to override that limitation, we copy the structure
//              to a new (V3) PROPSHEETPAGE.
//              Note that we do not use the latest version of PROPSHEETPAGE (the type PROPSHEETPAGE),
//              because we do not know if we can always assume that copymemory from 
//              AFX_OLDPROPSHEETPAGE to PROPSHEETPAGE.
//
//  History:    4/20/2001  RahulTh  created in sdnt\ds\testsrc\zaw\ctappman\codecov\results\nt510\rc1
//              Nov/7/2001  YoelA    Modified for MSMQ (bug 8817)
//---------------------------------------------------------------------------

HPROPSHEETPAGE CMqPropertyPage::CreateThemedPropertySheetPage()
{
    PROPSHEETPAGE_V3 psp_v3 = {0};
    CopyMemory (&psp_v3, &m_psp, min(m_psp.dwSize, min(sizeof(m_psp), sizeof(psp_v3))));
    psp_v3.dwSize = sizeof(psp_v3);
    return (::CreatePropertySheetPage (&psp_v3));
}

/////////////////////////////////////////////////////////////////
// CMqDialog

IMPLEMENT_DYNCREATE(CMqDialog, CDialog)

BEGIN_MESSAGE_MAP(CMqDialog, CDialog)
	//{{AFX_MSG_MAP(CMqDialog)
	    ON_WM_HELPINFO()
	    ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CMqDialog::CMqDialog()
{
}

CMqDialog::CMqDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd /* = NULL */) :
    CDialog(lpszTemplateName, pParentWnd)
{
}

CMqDialog::CMqDialog(UINT nIDTemplate, CWnd* pParentWnd /* = NULL */) :
    CDialog(nIDTemplate, pParentWnd)
{
}


void CMqDialog::OnContextMenu(CWnd* pWnd, CPoint /*point*/)
{
	if (this == pWnd)
		return;

	::WinHelp (pWnd->m_hWnd,
		AfxGetApp()->m_pszHelpFilePath,
		HELP_CONTEXTMENU,
		(DWORD_PTR)(LPVOID)g_aHelpIDs);
}

BOOL CMqDialog::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW)   // must be for a control
    {
	    ::WinHelp ((HWND)pHelpInfo->hItemHandle,
		    AfxGetApp()->m_pszHelpFilePath,
		    HELP_WM_HELP,
		    (DWORD_PTR)(LPVOID)g_aHelpIDs);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\mgmtext.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	mgmtext.h

Abstract:

	Definition for the Local Computer management extensions
Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __MGMTEXT_H_
#define __MGMTEXT_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"


/****************************************************

        CSnapinComputerMgmt Class
    
 ****************************************************/

class CSnapinComputerMgmt : public CNodeWithScopeChildrenList<CSnapinComputerMgmt, TRUE>
{
public:
    CString m_szMachineName;


   	BEGIN_SNAPINCOMMAND_MAP(CSnapinComputerMgmt, FALSE)
	END_SNAPINCOMMAND_MAP()

    CSnapinComputerMgmt(CSnapInItem * pParentNode, CSnapin * pComponentData, 
                        CString strComputer) : 
        CNodeWithScopeChildrenList<CSnapinComputerMgmt, TRUE>(pParentNode, pComponentData ),
        m_szMachineName(strComputer)
    {
   		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
    }

	~CSnapinComputerMgmt()
    {
    }

	virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT OnRemoveChildren( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			);


private:
};



/****************************************************

        CComputerMgmtExtData Class
    
 ****************************************************/

class CComputerMgmtExtData : public CSnapInItemImpl<CComputerMgmtExtData, TRUE>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

    CSnapin *   m_pComponentData;


	BEGIN_SNAPINCOMMAND_MAP(CComputerMgmtExtData, FALSE)
	END_SNAPINCOMMAND_MAP()

	BEGIN_SNAPINTOOLBARID_MAP(CComputerMgmtExtData)
		// Create toolbar resources with button dimensions 16x16 
		// and add an entry to the MAP. You can add multiple toolbars
		// SNAPINTOOLBARID_ENTRY(Toolbar ID)
	END_SNAPINTOOLBARID_MAP()

	CComputerMgmtExtData()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CComputerMgmtExtData();

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES /*type*/)
	{
		//if (type == CCT_SCOPE || type == CCT_RESULT)
		//	return S_OK;
		return S_FALSE;
	}

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* /*pDefault*/)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault);

   void RemoveChild(CString &strCompName);



private:

    CMap< CString, LPCWSTR, CSnapinComputerMgmt*, CSnapinComputerMgmt* > m_mapComputers;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\mqdspage.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

   mqdspage.h

Abstract:

   General property page class for all the property pages of DS objects,
   that are called using display specifiers. Inherits from general property 
   page - see mqppage.h

Author:

    YoelA


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __MQDSPAGE_H__
#define __MQDSPAGE_H__

/////////////////////////////////////////////////////////////////////////////
// CMqDsPropertyPage
template<class T>
class CMqDsPropertyPage : public T
{
public:
    CMqDsPropertyPage(CDisplaySpecifierNotifier *pDsNotifier) :
        m_pDsNotifier(pDsNotifier)
    {
        init();
    }

    CMqDsPropertyPage(CDisplaySpecifierNotifier *pDsNotifier, CString& strPathName) :
        T(strPathName),
        m_pDsNotifier(pDsNotifier)
    {
        init();
    }

	CMqDsPropertyPage(CDisplaySpecifierNotifier *pDsNotifier, CString& strPathName, const CString& strDomainController) :
        T(strPathName, strDomainController),
        m_pDsNotifier(pDsNotifier)
    {
        init();
    }

    ~CMqDsPropertyPage()
    {
        if (0 != m_pDsNotifier)
        {
            m_pDsNotifier->Release();
        }
    }

protected:
  	//{{AFX_MSG(CMqDsPropertyPage)
	//}}AFX_MSG
    CDisplaySpecifierNotifier *m_pDsNotifier;

    void init()
    {
        if (0 != m_pDsNotifier)
        {
            m_pDsNotifier->AddRef();
        }
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\msgq.cpp ===
// msgq.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqPPage.h"
#include "msgq.h"

#include "msgq.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMessageQueuesPage property page

IMPLEMENT_DYNCREATE(CMessageQueuesPage, CMqPropertyPage)

CMessageQueuesPage::CMessageQueuesPage() : CMqPropertyPage(CMessageQueuesPage::IDD)
{
    //{{AFX_DATA_INIT(CMessageQueuesPage)
    m_szAdminFN = _T("");
    m_szAdminPN = _T("");
    m_szDestFN = _T("");
    m_szDestPN = _T("");
    m_szRespFN = _T("");
    m_szRespPN = _T("");
    m_szMultiDestFN = _T("");    
    //}}AFX_DATA_INIT
}

CMessageQueuesPage::~CMessageQueuesPage()
{
}

void CMessageQueuesPage::DoDataExchange(CDataExchange* pDX)
{
    CMqPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMessageQueuesPage)
    DDX_Text(pDX, IDC_MSG_ADMIN_FN, m_szAdminFN);
    DDX_Text(pDX, IDC_MSG_ADMIN_PN, m_szAdminPN);
    DDX_Text(pDX, IDC_MSG_DST_FN, m_szDestFN);
    DDX_Text(pDX, IDC_MSG_DST_PN, m_szDestPN);
    DDX_Text(pDX, IDC_MSG_RSP_FN, m_szRespFN);
    DDX_Text(pDX, IDC_MSG_RSP_PN, m_szRespPN);
    DDX_Text(pDX, IDC_MSG_MULTIDST_FN, m_szMultiDestFN); 
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMessageQueuesPage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CMessageQueuesPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMessageQueuesPage message handlers

BOOL CMessageQueuesPage::OnInitDialog() 
{
    //
    // PATCH!!!!
    // Defining this method to override the default OnInitDialog of
    // CMqPropertyPage, because it asserts.
    //
    // This function must be in the context of MMC.EXE so dont 
    // put an "AFX_MANAGE_STATE(AfxGetStaticModuleState());" unless
    // it is bracketted inside a {....} statement.
    //
    //

  	UpdateData( FALSE );

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\mqsnhlps.h ===
#define IDH_196_1110 	1110 // IDC_TESTMESSAGE_DESTQ
#define IDH_196_1121 	1121 // IDC_TESTMESSAGE_SEND
#define IDH_196_1122 	1122 // IDC_TESTMESSAGE_CLOSE
#define IDH_196_1111 	1111 // IDC_TESTMESSAGE_NEW
#define IDH_352_1115 	1115 // IDC_NEWQTYPE_QUEUENAME
#define IDH_159_1026 	1026 // IDC_QUEUENAME
#define IDH_159_1128 	1128 // IDC_TRANSACTIONAL
#define IDH_189_1086 	1309 // IDC_LINK_LABEL
#define IDH_189_1036 	1001 // IDC_LINK_COST
#define IDH_146_1004 	1020 // IDC_INROUT_LABEL
#define IDH_146_1091 	1017 // IDC_INROUTCOMBO_0
#define IDH_146_1093 	1018 // IDC_INROUTCOMBO_1
#define IDH_146_1095 	1019 // IDC_INROUTCOMBO_2
#define IDH_146_1006 	1021 // IDC_OUTROUT_LABEL
#define IDH_146_1097 	1023 // IDC_OUTROUTCOMBO_0
#define IDH_146_1100 	1024 // IDC_OUTROUTCOMBO_1
#define IDH_146_1102 	1025 // IDC_OUTROUTCOMBO_2
#define IDH_151_1013 	1304 // IDC_SITE_GATES_LIST
#define IDH_151_1081 	1302 // IDB_SITE_GATE_ADD
#define IDH_151_1084 	1301 // IDC_SITE_FRS_LIST
#define IDH_151_1087 	1303 // IDB_SITE_GATE_REMOVE
#define IDH_153_1005 	1005 // IDC_QGENERAL_QLABEL
#define IDH_153_1007 	1007 // IDC_QGENERAL_TYPEID
#define IDH_155_1015 	1015 // IDC_QMESSAGES_QUOTA
#define IDH_155_1129 	1006 // IDC_QGENERAL_TRANSACTIONAL
#define IDH_155_1014 	1014 // IDC_QMESSAGES_JOURNAL
#define IDH_155_1016 	1016 // IDC_QMESSAGES_JOURNAL_QUOTA
#define IDH_155_1018 	1357 // IDC_QMESSAGES_PRIVLEVEL
#define IDH_351_1108 	1108 // IDC_REPORTQUEUE_NEW
#define IDH_351_1119 	1119 // IDC_TRACK_ALL
#define IDH_351_1120 	1120 // IDC_TRACK_TEST
#define IDH_166_1032 	209  // IDC_MSGLABEL
#define IDH_166_1034 	211  // IDC_MSGID
#define IDH_166_1038 	215  // IDC_MSGPRIORITY
#define IDH_144_1001 	1002 // IDC_COMPUTER_MSMQ_NAME
#define IDH_144_1002 	1318 // IDC_CURRENTSITES_LIST
#define IDH_144_1003 	1356 // IDC_COMPUTER_MSMQ_ID
#define IDH_149_1008 	1317 // IDC_ALLSITES_LIST
#define IDH_153_1010 	1004 // IDC_QGENERAL_NAME
#define IDH_144_1144 	1144 // IDC_MGENERAL_CREATED
#define IDH_144_1145 	1145 // IDC_MGENERAL_MODIFIED
#define IDH_166_1040 	216  // IDC_MSGCLASS
#define IDH_166_1044 	214  // IDC_MSGTRACK
#define IDH_169_1153 	1348 // IDC_FCOMPNAME_LABEL 
#define IDH_169_1154 	1349 // IDC_FOREIGN_COMPUTER_SITE
#define IDH_366_1131 	227  // IDC_MSG_DST_FN
#define IDH_366_1132 	230  // IDC_MSG_DST_PN
#define IDH_366_1133 	228  // IDC_MSG_RSP_FN
#define IDH_366_1134 	231  // IDC_MSG_RSP_PN
#define IDH_366_1135 	229  // IDC_MSG_ADMIN_FN
#define IDH_366_1136 	232  // IDC_MSG_ADMIN_PN
#define IDH_367_1141 	219  // IDC_MSGGUID
#define IDH_367_1142 	220  // IDC_MSGPATHNAME
#define IDH_367_1043 	223  // IDC_MSGAUTHENTICATED
#define IDH_367_1148 	224  // IDC_MSGHASHALG
#define IDH_367_1045 	225  // IDC_MSGENCRYPT
#define IDH_367_1041 	226  // IDC_MSGENCRYPTALG
#define IDH_144_1146 	1146 // IDC_COMPUTER_MSMQ_QUOTA
#define IDH_144_1147 	1147 // IDC_COMPUTER_MSMQ_JOURNAL_QUOTA
#define IDH_155_1164 	1164 // IDC_QUEUE_MQUOTA_CHECK
#define IDH_155_1165 	1165 // IDC_QUEUE_JQUOTA_CHECK
#define IDH_144_1169 	1169 // IDC_COMPUTER_MSMQ_MQUOTA_CHECK
#define IDH_144_1170 	1170 // IDC_COMPUTER_MSMQ_JQUOTA_CHECK
#define IDH_144_1240 	1240 // IDC_COMPUTER_MSMQ_SERVICE
#define IDH_155_1245 	1245 // IDC_QMESSAGES_AUTHENTICATED
#define IDH_155_1241 	1358 // IDC_QUEUE_BASEPRIORITY
#define IDH_166_1242 	217  // IDC_MSGSENT
#define IDH_166_1243 	218  // IDC_MSGARRIVED
#define IDH_169_1251 	1332 // IDC_FOREIGN_SITE_NAME
#define IDH_183_1252 	1252 // IDC_ENT_GEN_LONGLIVE_EDIT
#define IDH_183_1256 	1256 // IDC_ENT_GEN_LONGLIVE_UNITS_COMBO
#define IDH_196_1239 	1123 // IDC_TESTMESSAGE_NO_SENT
#define IDH_364_1246 	1300 // IDC_MESSAGE_BODY_EDIT
#define IDH_367_1250 	221  // IDC_MSGUSER
#define IDH_367_1249 	222  // IDC_MSGSID
#define IDH_151_1077 	1320 // IDC_SITES_REMOVE
#define IDH_151_1244 	1319 // IDC_SITES_ADD
#define IDH_351_1188 	1188 // IDC_MESSAGE_TRACKING_EXPLANATION
#define IDH_351_1109 	1109 // IDC_REPORTQUEUE_NAME
#define IDH_153_1012 	1003 // IDC_QGENERAL_ID
#define IDH_DC_button 	1266 // IDC_DEPENDENT_CLIENTS_REFRESH
#define IDH_DC_window 	1269 // IDC_DEPENDENT_CLIENTS
#define idh_new_link_from 	244 // IDC_FIRST_SITE_COMBO 
#define idh_new_link_to		245 // IDC_SECOND_SITE_COMBO 
#define idh_new_link_cost 	1355 // IDC_LINK_COST_EDIT
#define idh_mqping_button 	1331 // IDC_CERT_VIEW
#define idh_send_test_button 	1327 // IDC_DIAG_SEND_TEST
#define idh_tracking_button 	1329 // IDC_DIAG_TRACKING
#define idh_computer_os 	1241 // IDC_COMPUTER_MSMQ_OS
#define idh_message_size 250 // IDC_MBODY_SIZE_MESSAGE
#define idh_cert_list 1310 // IDC_CERT_LIST
#define idh_cert_view 1311 // IDC_CERT_VIEW
#define idh_cert_remove 1312 // IDC_CERT_REMOVE
#define IDH_ALIAS_LABEL			1411 // IDC_ALIAS_LABEL
#define IDH_ALIAS_FORMATNAME    1413 // IDC_ALIAS_FORMATNAME
#define IDH_ALIAS_DESCRIPTION	1415 // IDC_ALIAS_DESCRIPTION
#define IDH_NEWALIAS_PATHNAME	1419 // IDC_NEWALIAS_PATHNAME
#define IDH_NEWALIAS_FORMATNAME	1421 // IDC_NEWALIAS_FORMATNAME
#define IDH_MSG_MULTIDST_FN     1173 // IDC_MSG_MULTIDST_FN
#define IDH_QMULTICAST_QADDRESS 1009 // IDC_QMULTICAST_QADDRESS
#define IDH_FIND_EDITLABEL              1353 // IDC_FIND_EDITLABEL
#define IDH_FIND_EDITTYPE               1000 // IDC_FIND_EDITTYPE
#define IDH_QNAME_PRIVATE_TITLE         1369 // IDC_QNAME_PRIVATE_TITLE
#define IDH_CREATE_IN                   1514 // IDC_CREATE_IN
#define IDH_ALIAS_CONTAINER             1515 // IDC_ALIAS_CONTAINER
#define IDH_ROUTING_LINK_CONTAINER      1519 // IDC_ROUTING_LINK_CONTAINER
#define IDH_FOREIGN_SITE_CONTAINER      1523 // IDC_FOREIGN_SITE_CONTAINER
#define IDH_QUEUE_CONTAINER             1525 // IDC_QUEUE_CONTAINER
#define IDH_FOREIGN_COMPUTER_CONTAINER  1528 // IDC_FOREIGN_COMPUTER_CONTAINER
#define IDH_OPTION_HARDENED_MSMQ		1529 // IDC_OPTION_HARDENED_MSMQ
#define IDH_OPTION_OLD_REMOTE_READ		1530 // IDC_OPTION_OLD_REMOTE_READ
#define IDH_OPTION_DEP_CLIENTS			1531 // IDC_OPTION_DEP_CLIENTS
#define IDH_RESTORE_SECURITY_OPTIONS	1532 // IDC_RESTORE_SECURITY_OPTIONS

#define IDH_LINK_DESCR                  10930 //IDC_LINK_DESCR

//
// Trigger UI
//
#define IDH_TRIGGER_GENERAL_HEADER      1424 // IDC_TRIGGER_GENERAL_HEADER
#define IDH_InitThreadsCount            1428 // IDC_InitThreadsCount
#define IDH_MaxThreadCount              1429 // IDC_MaxThreadCount
#define IDH_DefaultMsgBodySize          1430 // IDC_DefaultMsgBodySize
#define IDH_ConditionValue              1431 // IDC_ConditionValue
#define IDH_RULE_DESCRIPTION            1432 // IDC_RULE_DESCRIPTION
#define IDH_RULE_COND_TYPES             1434 // IDC_RULE_COND_TYPES
#define IDH_RULECOND_LIST              10835 // IDC_RULECOND_LIST
#define IDH_AddRuleCondition_BTM        1437 // IDC_AddRuleCondition_BTM
#define IDH_RULE_LIST                   1438 // IDC_RULE_LIST
#define IDH_RemoveCondition             1439 // IDC_RemoveCondition
#define IDH_RULE_NAME                   1440 // IDC_RULE_NAME
#define IDH_INVOKE_COM                  1446 // IDC_INVOKE_COM
#define IDH_INVOKE_EXE                  1447 // IDC_INVOKE_EXE
#define IDH_COMPONENT_PROGID            1452 // IDC_COMPONENT_PROGID
#define IDH_COMMETHOD_NAME              1453 // IDC_COMMETHOD_NAME
#define IDH_EXE_PATH                    1454 // IDC_EXE_PATH
#define IDH_RULE_GENERAL_TITLE          1464 // IDC_RULE_GENERAL_TITLE
#define IDH_FIND_EXE_BTM                1469 // IDC_FIND_EXE_BTM
#define IDH_PARAM_BTM                   1470 // IDC_PARAM_BTM
#define IDH_PARAM_ORDER_UP              1478 // IDB_PARAM_ORDER_UP
#define IDH_PARM_REMOVE                 1479 // IDB_PARM_REMOVE
#define IDH_PARAM_ADD                   1480 // IDB_PARAM_ADD
#define IDH_PARM_ORDER_DOWN             1481 // IDB_PARM_ORDER_DOWN
#define IDH_PARAM_COMBO                 1482 // IDC_PARAM_COMBO
#define IDH_LITERAL_PARAM               1483 // IDC_LITERAL_PARAM
#define IDH_INVOKE_PARMETER_LIST        1485 // IDC_INVOKE_PARMETER_LIST
#define IDH_TriggerName_EDIT            1488 // IDC_TriggerName_EDIT
#define IDH_QueuePathName               1489 // IDC_QueuePathName
#define IDH_FRAME_GROUP                 1490 // IDC_SysyetmQueue_GROUP (use this IDH for all frames)
#define IDH_QueueMessages_RDB           1491 // IDC_QueueMessages_RDB
#define IDH_JournalMessages_RDB         1492 // IDC_JournalMessages_RDB
#define IDH_DeadlLetter_RDB             1493 // IDC_DeadlLetter_RDB
#define IDH_TransactionalDeadLetter_RDB 1494 // IDC_TransactionalDeadLetter_RDB
#define IDH_Enabled_CHK                 1496 // IDC_Enabled_CHK
#define IDH_Serialized_CHK              1497 // IDC_Serialized_CHK
#define IDH_AttachedRule                1501 // IDC_AttachedRule
#define IDH_RemoveRule_BTM              1503 // IDC_RemoveRule_BTM
#define IDH_UpRule_BTM                  1504 // IDC_UpRule_BTM
#define IDH_Down_BTM                    1505 // IDC_Down_BTM
#define IDH_ATTACH_RULES_BTM            1506 // IDC_ATTACH_RULES_BTM
#define IDH_ADD_RULE                    1507 // IDC_ADD_RULE
#define IDH_PeekMessage_RDB             1508 // IDC_PeekMessage_RDB
#define IDH_ReceiveMessage_RDB          1509 // IDC_ReceiveMessage_RDB
#define IDH_ReceiveMessageXact_RDB      1510 // IDC_ReceiveMessageXact_RDB
#define IDH_ViewRuleProperties			1511 // IDC_PROPERTIES_LABEL, IDC_EXISTING_RULE_PROPS, IDC_ATTACHED_RULE_PROPS

//
// From control panel: cpl\cplhlps.h
//
#define IDH_107_1038	68026475	// Storage: "To maximize MSMQ messaging speed, specify multiple disk drives for storing message information." (Static)
#define IDH_110_1017	66650222	// Mobile: "" (ComboBox)
#define IDH_110_1018	66715758	// Mobile: "" (Edit)
#define IDH_107_1046	68550763	// Storage: "" (Edit)
#define IDH_150_1047	68616342	// MSMQ Client: "" (Edit)
#define IDH_107_1048	68681835	// Storage: "" (Edit)
#define IDH_108_1027	67305580	// Security: "Encryption Key" (Button)
#define IDH_110_1030	67502190	// Mobile: "If you are moving your computer to a new site and expect your messages to be waiting there when you arrive, specify the new site before disconnecting from the network" (Static)
#define IDH_108_1031	67567724	// Security: "User Certificates" (Button)
#define IDH_108_1032	67633260	// Security: "Register certificates in MSMQ Information Store (MQIS)" (Static)
#define IDH_108_1033	67698796	// Security: "View a list of all registered certificates in MQIS" (Static)
#define IDH_108_1034	67764332	// Security: "Remove certificates from MQIS" (Static)
#define IDH_108_1035	67829868	// Security: "Internal Certificate" (Button)
#define IDH_107_1012	66322539	// Storage: "" (Edit)
#define IDH_158_1063    69664926    // Server Certificates 
#define IDH_FRAME_HELP  60000001    // Unified help for all frames

#define IDH_NO_MSMQ_HELP		-1

const DWORD g_aHelpIDs[]=
{
    IDC_TESTMESSAGE_DESTQ,  IDH_196_1110,   // Send Test Message: "" (ComboBox)
    IDC_TESTMESSAGE_DESTQ_LABEL,    IDH_196_1110,   // Send Test Message: "Destination Queue:" (Static)
    IDC_TESTMESSAGE_SEND,   IDH_196_1121,   // Send Test Message: "&Send" (Button)
    IDC_TESTMESSAGE_CLOSE,  IDH_196_1122,   // Send Test Message: "&Close" (Button)
    IDC_TESTMESSAGE_NEW,    IDH_196_1111,   // Send Test Message: "&New Queue..." (Button)
    IDC_NEWQTYPE_QUEUENAME_LABEL,   IDH_352_1115,   // New Queue Pathname?: "Pathname (computer\queue):" (Static)
    IDC_NEWQTYPE_QUEUENAME, IDH_352_1115,
    IDC_QUEUENAME,  IDH_159_1026,   // Queue Name: "" (Edit)
    IDC_QUEUENAME_LABEL,  IDH_159_1026,   // Queue Name: "" (Edit)
    IDC_TRANSACTIONAL,  IDH_159_1128,   // Queue Name: "&Transactional" (Button)
    IDC_LINK_LABEL, IDH_189_1086,   // Site links: "" (Edit)
    IDC_LINK_COST_LABEL, IDH_189_1036,   // Site links: "" (Edit)
    IDC_LINK_COST, IDH_189_1036,   // Site links: "" (Edit)
    IDC_INROUT_LABEL,    IDH_146_1004,   // Client: "&In Routing Servers" (Button)
    IDC_INROUTCOMBO_0, IDH_146_1091,
    IDC_INROUTCOMBO_1, IDH_146_1093,
    IDC_INROUTCOMBO_2, IDH_146_1095,
    IDC_OUTROUT_LABEL, IDH_146_1006,
    IDC_OUTROUTCOMBO_0, IDH_146_1097,
    IDC_OUTROUTCOMBO_1, IDH_146_1100,
    IDC_OUTROUTCOMBO_2, IDH_146_1102,
    IDC_SITE_GATES_LIST,IDH_151_1013,   // Connections: "List1" (SysListView32)
    IDC_SITE_GATE_LABEL,IDH_151_1013,   // Connections: "Site &Gates" (Static)
    IDB_SITE_GATE_ADD,  IDH_151_1081,   // Connections: "Add ..." (Button)
    IDC_SITE_FRS_LIST,  IDH_151_1084,   // Connections: "Edit ..." (Button)
    IDC_SITE_FRS_LABEL,  IDH_151_1084,   // Connections: "Edit ..." (Button)
    IDB_SITE_GATE_REMOVE,IDH_151_1087,   // Connections: "Remove" (Button)
    IDC_QGENERAL_NAME, IDH_153_1010,
    IDC_QGENERAL_QLABEL,IDH_153_1005,   // General: "" (Edit)
    IDC_QGENERAL_QLABEL_LABEL,    IDH_153_1005,   // General: "&Label:" (Static)
    IDC_QGENERAL_TYPEID,    IDH_153_1007,   // General: "" (Edit)
    IDC_QGENERAL_TYPEID_LABEL,  IDH_153_1007,   // General: "&Type ID:" (Static)
    IDC_QMESSAGES_QUOTA,    IDH_155_1015,   // Advanced: "" (Edit)
    IDC_QGENERAL_TRANSACTIONAL_LABEL,    IDH_155_1129,   // Advanced: "&Transactional" (Button)
    IDC_QGENERAL_TRANSACTIONAL,    IDH_155_1129,   // Advanced: "&Transactional" (Button)
    IDC_QMESSAGES_JOURNAL,  IDH_155_1014,   // Advanced: "&Enabled" (Button)
    IDC_QUEUE_JQUOTA_CHECK, IDH_155_1016,   // Advanced: "" (Edit)
    IDC_QMESSAGES_JOURNAL_QUOTA, IDH_155_1016,   // Advanced: "" (Edit)
    IDC_QMESSAGES_PRIVLEVEL,    IDH_155_1018,   // Advanced: "" (ComboBox)
    IDC_QUEUE_ENCRIPTION_LABEL, IDH_155_1018,   // Advanced: "Privacy &Level:" (Static)
    IDC_REPORTQUEUE_NEW,    IDH_351_1108,   // Tracking: "&New..." (Button)
    IDC_TRACK_ALL,  IDH_351_1119,   // Tracking: "Track &all messages" (Button)
    IDC_TRACK_TEST, IDH_351_1120,   // Tracking: "Track only &test message" (Button)
    IDC_MSGGNRL_TITLE_LABEL,    IDH_166_1032,   // General: "Label:" (Static)
    IDC_MSGLABEL,  IDH_166_1032,   // General: "" (Edit)
    IDC_MSGGNRL_ID_LABEL,   IDH_166_1034,   // General: "ID:" (Static)
    IDC_MSGID, IDH_166_1034,   // General: "" (Edit)
    IDC_MSGGNRL_PRIORITY_LABEL, IDH_166_1038,   // General: "Priority:" (Static)
    IDC_MSGPRIORITY,   IDH_166_1038,   // General: "" (Edit)
    IDC_COMPUTER_MSMQ_NAME,    IDH_144_1001, 
    IDC_CURRENTSITES_LIST,    IDH_144_1002,  
    IDC_CURRENTSITES_LABEL,    IDH_144_1002,  
    IDC_COMPUTER_MSMQ_ID,  IDH_144_1003,
    IDC_COMPUTER_MSMQ_ID_LABEL,  IDH_144_1003,
    IDC_ALLSITES_LIST,    IDH_149_1008,
    IDC_ALLSITES_LABEL,    IDH_149_1008,
    IDC_MSGGNRL_CLASS_LABEL,    IDH_166_1040,   // General: "Class:" (Static)
    IDC_MSGCLASS,  IDH_166_1040, 
    IDC_MSGTRACK,    IDH_166_1044, 
    IDC_MSGGNRL_TRACKED_LABEL,  IDH_166_1044,   // General: "Tracked:" (Static)
    IDC_FOREIGN_COMPUTER_NAME,   IDH_169_1153,   // New Foreign Computer: "&Foreign Connected Networks:" (Static)
    IDC_FCOMPNAME_LABEL,   IDH_169_1153,   // New Foreign Computer: "&Foreign Connected Networks:" (Static)
    IDC_FOREIGN_COMPUTER_SITE,  IDH_169_1154,   // New Foreign Computer: "" (ListBox)
    IDC_FCOMPSITE_LABEL,    IDH_169_1154,   // New Foreign Computer: "&Member of:" (Static)
    IDC_MSG_DST_FN, IDH_366_1131, 
    IDC_MQUEUE_DEST_FORMAT_LABEL,   IDH_366_1131,   // Queues: "Format Name:" (Static)
    IDC_MSG_DST_PN,   IDH_366_1132, 
    IDC_MQUEUE_DEST_PATH_LABEL, IDH_366_1132,   // Queues: "Name:" (Static)
    IDC_MSG_RSP_FN, IDH_366_1133,   // Queues: "" (Edit)
    IDC_MQUEUE_RESPONSE_FORMAT_LABEL,   IDH_366_1133,   // Queues: "Format Name:" (Static)
    IDC_MSG_RSP_PN,   IDH_366_1134,   // Queues: "" (Edit)
    IDC_MQUEUE_RESPONSE_PATH_LABEL, IDH_366_1134,   // Queues: "Name:" (Static)
    IDC_MSG_ADMIN_FN,    IDH_366_1135, 
    IDC_MQUEUE_ADMIN_FORMAT_LABEL,  IDH_366_1135,   // Queues: "Format Name:" (Static)
    IDC_MQUEUE_ADMIN_PATH_LABEL,    IDH_366_1136,   // Queues: "Name:" (Static)
    IDC_MSG_ADMIN_PN,  IDH_366_1136,   // Queues: "" (Edit)
    IDC_MSENDER_SOURCE_GUID_LABEL,  IDH_367_1141,   // Sender: "GUID:" (Static)
    IDC_MSGGUID,    IDH_367_1141,   // Sender: "" (Edit)
    IDC_MSENDER_SOURCE_PATH_LABEL,  IDH_367_1142,   // Sender: "Pathname:" (Static)
    IDC_MSGPATHNAME,    IDH_367_1142,
    IDC_MSGAUTHENTICATED,  IDH_367_1043,   // Sender: "" (Edit)
    IDC_MSENDER_AUTHENTICATED_LABEL,    IDH_367_1043,   // Sender: "Authenticated:" (Static)
    IDC_MSENDER_HASH_ALG_LABEL, IDH_367_1148,   // Sender: "Hash Algorithm:" (Static)
    IDC_MSGHASHALG,   IDH_367_1148,
    IDC_MSGENCRYPT,  IDH_367_1045,   // Sender: "" (Edit)
    IDC_MSENDER_ENCRYPTED_LABEL,    IDH_367_1045,   // Sender: "Encrypted:" (Static)
    IDC_MSGENCRYPTALG,    IDH_367_1041,   // Sender: "" (Edit)
    IDC_MSENDER_ENCRYPT_ALG_LABEL,  IDH_367_1041,   // Sender: "Encryption Algorithm:" (Static)
    IDC_COMPUTER_MSMQ_QUOTA, IDH_144_1146,   // General: "" (Edit)
    IDC_COMPUTER_MSMQ_JOURNAL_QUOTA, IDH_144_1147,   // General: "" (Edit)
    IDC_QUEUE_MQUOTA_CHECK, IDH_155_1164,   // Advanced: "Limit &message storage (in K) to:" (Button)
    IDC_QUEUE_JQUOTA_CHECK, IDH_155_1165,   // Advanced: "Limit journal &storage (in K) to:" (Button)
    IDC_COMPUTER_MSMQ_MQUOTA_CHECK,   IDH_144_1169,   // General: "Limit &message storage (in K) to:" (Button)
    IDC_COMPUTER_MSMQ_JQUOTA_CHECK,   IDH_144_1170,   // General: "Limit journal &storage (in K) to:" (Button)
    IDC_COMPUTER_MSMQ_SERVICE_LABEL, IDH_144_1240,   // General: "Service:" (Static)
    IDC_COMPUTER_MSMQ_SERVICE,   IDH_144_1240,   // General: "" (Edit)
    IDC_QMESSAGES_AUTHENTICATED,    IDH_155_1245,   // Advanced: "&Authenticated" (Button)
    IDC_BASEPRIORITY_SPIN,  IDH_155_1241,   // Advanced: "Spin1" (msctls_updown32)
    IDC_QUEUE_BASEPRIORITY_LABEL,   IDH_155_1241,   // Advanced: "Base &Priority:" (Static)
    IDC_QUEUE_BASEPRIORITY, IDH_155_1241,   // Advanced: "0" (Edit)
    IDC_MSGGNRL_SENT_TIME_LABEL,    IDH_166_1242,   // General: "Sent:" (Static)
    IDC_MSGSENT,  IDH_166_1242,   // General: "" (Edit)
    IDC_MSGARRIVED,   IDH_166_1243,   // General: "" (Edit)
    IDC_MSGGNRL_ARRIVED_TIME_LABEL, IDH_166_1243,   // General: "Arrived:" (Static)
    IDC_FOREIGN_SITE_NAME,  IDH_169_1251,   // New Object - Foreign Site: "" (Edit)
    IDC_FOREIGN_SITE_LABEL,  IDH_169_1251,   // New Object - Foreign Site: "Foreign site name:" (Static)
    IDC_ENT_GEN_LONGLIVE_EDIT,  IDH_183_1252,   // General: "" (Edit)
    IDC_ENT_GEN_LONGLIVE_EDIT_LABEL,  IDH_183_1252,   // General: "" (Edit)
    IDC_EGENERAL_DEFINITIONS_FRAME,  IDH_183_1252,   // General: "" (Edit)
    IDC_ENT_GEN_LONGLIVE_UNITS_COMBO,   IDH_183_1256,   // General: "" (ComboBox)
    IDC_TESTMESSAGE_NO_SENT,    IDH_196_1239,   // Send Test Message: "0" (Static)
    IDC_TESTMESSAGE_NO_SENT_LABEL,  IDH_196_1239,   // Send Test Message: "Messages sent" (Static)
    IDC_MESSAGE_BODY_EDIT,  IDH_364_1246,   // Body: "" (Edit)
    IDC_MSGUSER,    IDH_367_1250,   // Sender: "" (Edit)
    IDC_MSENDER_UID_LABEL,  IDH_367_1250,   // Sender: "User:" (Static)
    IDC_MSGSID,    IDH_367_1249,   // Sender: "" (Edit)
    IDC_MSENDER_SID_LABEL,  IDH_367_1249,   // Sender: "SID:" (Static)
    IDC_SITES_REMOVE,  IDH_151_1077,   // Connections: "Edit ..." (Button)
    IDC_SITES_ADD,   IDH_151_1244,   // Connections: "Add ..." (Button)
    IDC_MESSAGE_TRACKING_EXPLANATION,   IDH_351_1188,   // Tracking: "Route tracking messages will be sent to the report queue." (Static)
    IDC_REPORTQUEUE_NAME,   IDH_351_1109,   // Tracking: "" (ComboBox)
    IDC_REPORTQUEUE_NAME_LABEL, IDH_351_1109,   // Tracking: "Pathname of &report queue:" (Static)
    IDC_QGENERAL_ID,       IDH_153_1012,   // General: "" (Edit)
    IDC_QGENERAL_ID_LABEL, IDH_153_1012,   // General: "" (Edit)
    IDC_DEPENDENT_CLIENTS_REFRESH, IDH_DC_button,
    IDC_DEPENDENT_CLIENTS, IDH_DC_window,
    IDC_DEPCLIENTS_LABEL, IDH_NO_MSMQ_HELP,
    IDC_FIRST_SITE_LABEL, idh_new_link_from,
    IDC_FIRST_SITE_COMBO, idh_new_link_from,
    IDC_SECOND_SITE_LABEL, idh_new_link_to,
    IDC_SECOND_SITE_COMBO, idh_new_link_to,
    IDC_LINK_COST_LABEL, idh_new_link_cost,
    IDC_LINK_COST_EDIT, idh_new_link_cost,
    IDC_DIAG_PING, idh_mqping_button,
    IDC_DIAG_PING_ICON, IDH_NO_MSMQ_HELP,
    IDC_DIAG_PING_LABEL, idh_mqping_button,
    IDC_DIAG_SEND_TEST, idh_send_test_button,
    IDC_DIAG_SENDTEST_ICON, IDH_NO_MSMQ_HELP,
    IDC_DIAG_SENDTEST_LABEL, idh_send_test_button,
    IDC_DIAG_TRACKING, idh_tracking_button,
    IDC_DIAG_TRACKING_ICON, IDH_NO_MSMQ_HELP,
    IDC_DIAG_TRACKING_LABEL, idh_tracking_button,  
    IDC_MBODY_SIZE_MESSAGE, idh_message_size,
    IDC_CERT_LIST, idh_cert_list,
    IDC_CERT_VIEW, idh_cert_view,
    IDC_CERT_REMOVE, idh_cert_remove,
    IDC_ALIAS_LABEL, IDH_ALIAS_LABEL,                   // 1411
    IDC_ALIAS_FORMATNAME_LABEL, IDH_ALIAS_FORMATNAME,   // 1412
    IDC_ALIAS_FORMATNAME, IDH_ALIAS_FORMATNAME,         // 1413
    IDC_ALIAS_DESCRIPTION_LABEL, IDH_ALIAS_DESCRIPTION, // 1414
    IDC_ALIAS_DESCRIPTION, IDH_ALIAS_DESCRIPTION,       // 1415
    IDC_NEWALIAS_PATHNAME_LABEL, IDH_NEWALIAS_PATHNAME, // 1418
    IDC_NEWALIAS_PATHNAME, IDH_NEWALIAS_PATHNAME,       // 1419
    IDC_NEWALIAS_FORMATNAME_LABEL, IDH_NEWALIAS_FORMATNAME, // 1420
    IDC_NEWALIAS_FORMATNAME, IDH_NEWALIAS_FORMATNAME,   // 1421
    IDC_MQUEUE_MULTIDEST_FORMAT_LABEL, IDH_MSG_MULTIDST_FN, //1172
    IDC_MSG_MULTIDST_FN, IDH_MSG_MULTIDST_FN,               //1173
    IDC_MQUEUE_DEST_FRAME, IDH_FRAME_GROUP, //  = 1200 = 1490
    IDC_MQUEUE_MULTIDEST_FRAME, IDH_FRAME_GROUP, // 1171 = 1490
    IDC_MQUEUE_ADMIN_FRAME, IDH_FRAME_GROUP, //  1206 = 1490
    IDC_MQUEUE_RESP_FRAME, IDH_FRAME_GROUP, //  1203 = 1490
    IDC_QMULTICAST_QADDRESS, IDH_QMULTICAST_QADDRESS, //1009
    IDC_QMULTICAST_QADDRESS_LABEL, IDH_NO_MSMQ_HELP, 
    IDC_QMULTICAST_QADDRESS_DESCRIPTION, IDH_NO_MSMQ_HELP, 
    IDC_MSENDER_SOURCE_FRAME, IDH_FRAME_GROUP, //  1209 = 1490
    IDC_MSENDER_SENDER_FRAME, IDH_FRAME_GROUP, //  1212 = 1490
    IDC_MSENDER_SECURITY_FRAME, IDH_FRAME_GROUP, //  1213 = 1490
    IDC_FIND_EDITLABEL, IDH_FIND_EDITLABEL, // 1353
    IDC_FIND_LABEL_LABEL, IDH_FIND_EDITLABEL, // 1354 = 1353
    IDC_FIND_EDITTYPE, IDH_FIND_EDITTYPE,  // 1000
    IDC_FIND_TYPE_LABEL, IDH_FIND_EDITTYPE,  // 1516 = 1000
    IDC_QNAME_PRIVATE_TITLE, IDH_QNAME_PRIVATE_TITLE, //1369
    IDC_CREATE_IN, IDH_CREATE_IN, // 1514
    IDC_ALIAS_CONTAINER, IDH_ALIAS_CONTAINER, // 1515
    IDC_ROUTING_LINK_CONTAINER, IDH_ROUTING_LINK_CONTAINER, // 1519
    IDC_FOREIGN_SITE_CONTAINER, IDH_FOREIGN_SITE_CONTAINER, // 1523
    IDC_QUEUE_CONTAINER, IDH_QUEUE_CONTAINER, // 1525
    IDC_FOREIGN_COMPUTER_CONTAINER, IDH_FOREIGN_COMPUTER_CONTAINER, // 1528
	IDC_LINK_DESCR, IDH_LINK_DESCR, // 10930
	IDC_LINK_DESCR_LABEL, IDH_LINK_DESCR, // 10929 = 10930
	IDC_OPTION_HARDENED_MSMQ, IDH_OPTION_HARDENED_MSMQ, // 1529
	IDC_OPTION_OLD_REMOTE_READ, IDH_OPTION_OLD_REMOTE_READ, // 1530
	IDC_OPTION_DEP_CLIENTS, IDH_OPTION_DEP_CLIENTS, // 1531
	IDC_RESTORE_SECURITY_OPTIONS, IDH_RESTORE_SECURITY_OPTIONS,	//1532  
	IDC_COMPUTER_MSMQ_GROUPBOX, IDH_FRAME_HELP,
	ID_Renew_LABEL, IDH_108_1031,
	IDC_COMPUTER_MSMQ_ICON, IDH_NO_MSMQ_HELP,
	IDC_MESSAGE_ICON, IDH_NO_MSMQ_HELP,
	IDC_QGENERAL_ICON, IDH_NO_MSMQ_HELP,
	IDC_SECURITY_OPTIONS_LABEL1, IDH_NO_MSMQ_HELP,
	IDC_COMPUTER_SITES_TITLE, IDH_NO_MSMQ_HELP,
	IDC_ENTERPRISE_GENERAL, IDH_NO_MSMQ_HELP,
	IDC_ENT_GEN_TITLE, IDH_NO_MSMQ_HELP,
	IDC_MESSAGE_GENERAL_LABEL, IDH_NO_MSMQ_HELP,
	
	
    //
    // Trigger UI
    //
    IDC_TRIGGER_CONF_GENERAL_HEADER, IDH_TRIGGER_GENERAL_HEADER, //1424
    IDC_InitThreadsCount_LABEL, IDH_InitThreadsCount, //1425 = 1428 (these have the same help)
    IDC_MaxThreadCount_LABEL, IDH_MaxThreadCount, // 1426 = 1429
    IDC_DefaultMsgBodySize_LABEL, IDH_DefaultMsgBodySize, //1427 = 1430
    IDC_InitThreadsCount, IDH_InitThreadsCount, //1428
    IDC_MaxThreadCount, IDH_MaxThreadCount, //1429
    IDC_DefaultMsgBodySize, IDH_DefaultMsgBodySize, // 1430
    IDC_ConditionValue, IDH_ConditionValue, // 1431
    IDC_RULE_DESCRIPTION, IDH_RULE_DESCRIPTION, // 1432
    IDC_RULE_COND_TYPES, IDH_RULE_COND_TYPES, // 1434
	IDC_RULECOND_LIST, IDH_RULECOND_LIST, // 10835
    IDC_AddRuleCondition_BTM, IDH_AddRuleCondition_BTM, // 1437
    IDC_RULE_LIST, IDH_RULE_LIST, //1438
    IDC_RemoveCondition, IDH_RemoveCondition, // 1439
    IDC_RULE_NAME, IDH_RULE_NAME, // 1440
    IDC_RuleName_LABEL, IDH_RULE_NAME, // 1441 = 1440
    IDC_RuleDescription_LABEL, IDH_RULE_DESCRIPTION, // 1442 = 1432
    IDC_INVOKE_COM, IDH_INVOKE_COM, // 1446
    IDC_INVOKE_EXE, IDH_INVOKE_EXE, // 1447
    IDC_PROID_LABEL, IDH_COMPONENT_PROGID, // 1449 = 1452
    IDC_EXEPATH_LABEL, IDH_EXE_PATH, // 1450 = 1454
    IDC_METHOD_LABEL, IDH_COMMETHOD_NAME, // 1451 = 1453
    IDC_COMPONENT_PROGID, IDH_COMPONENT_PROGID, // 1452
    IDC_COMMETHOD_NAME, IDH_COMMETHOD_NAME, // 1453
    IDC_EXE_PATH, IDH_EXE_PATH, // 1454
    IDC_RULE_GENERAL_TITLE, IDH_RULE_GENERAL_TITLE, // 1464
    IDC_EXE_INVOKE, IDH_FRAME_GROUP, // 1465 = 1490
    IDC_COM_INVOKE, IDH_FRAME_GROUP, // 1466 = 1490
    IDC_FIND_EXE_BTM, IDH_FIND_EXE_BTM, // 1469
    IDC_PARAM_BTM, IDH_PARAM_BTM, // 1470
    IDC_RULE_PARM_LABEL, IDH_PARAM_COMBO, // 1471 = 1482
    IDC_INVOKE_PARAM_LABEL, IDH_INVOKE_PARMETER_LIST, // 1473 = 1485
    IDB_PARAM_ORDER_UP, IDH_PARAM_ORDER_UP, // 1478
    IDB_PARM_REMOVE, IDH_PARM_REMOVE, //1479
    IDB_PARAM_ADD, IDH_PARAM_ADD, // 1480
    IDB_PARM_ORDER_DOWN, IDH_PARM_ORDER_DOWN, // 1481
    IDC_PARAM_COMBO, IDH_PARAM_COMBO, // 1482
    IDC_LITERAL_PARAM, IDH_LITERAL_PARAM, // 1483
    IDC_LITERAL_VALUE, IDH_LITERAL_PARAM, // 1484 = 1483
    IDC_INVOKE_PARMETER_LIST, IDH_INVOKE_PARMETER_LIST, // 1485
    IDC_TriggerName_LABEL, IDH_TriggerName_EDIT, // 1486 = 1488
    IDC_QueuePathname_LABEL, IDH_QueuePathName, // 1487 = 1489
    IDC_TriggerName_EDIT, IDH_TriggerName_EDIT, // 1488
    IDC_QueuePathName, IDH_QueuePathName, // 1489
    IDC_SysyetmQueue_GROUP, IDH_FRAME_GROUP, // 1490
    IDC_QueueMessages_RDB, IDH_QueueMessages_RDB, // 1491
    IDC_JournalMessages_RDB, IDH_JournalMessages_RDB, // 1492
    IDC_DeadlLetter_RDB, IDH_DeadlLetter_RDB, // 1493
    IDC_TransactionalDeadLetter_RDB, IDH_TransactionalDeadLetter_RDB, // 1494
    IDC_Enabled_CHK, IDH_Enabled_CHK, // 1496
    IDC_Serialized_CHK, IDH_Serialized_CHK, // 1497
    IDC_ATTACHED_RULE_LIST, IDH_AttachedRule, // 1499 = 1501
    IDC_RuleList_LABEL, IDH_RULE_LIST, // 1500 = 1438
    IDC_AttachedRule, IDH_AttachedRule, // 1501
    IDC_RemoveRule_BTM, IDH_RemoveRule_BTM, // 1503
    IDC_UpRule_BTM, IDH_UpRule_BTM, // 1504
    IDC_Down_BTM, IDH_Down_BTM, // 1505
    IDC_ATTACH_RULES_BTM, IDH_ATTACH_RULES_BTM, // 1506
    IDC_ADD_RULE, IDH_ADD_RULE, // 1507
    IDC_PeekMessage_RDB, IDH_PeekMessage_RDB, // 1508 
    IDC_ReceiveMessage_RDB, IDH_ReceiveMessage_RDB, // 1509
    IDC_ReceiveMessageXact_RDB, IDH_ReceiveMessageXact_RDB, // 1510
    IDC_MsgProcessingType_Group, IDH_FRAME_GROUP, // 1511 = 1490
	IDC_PROPERTIES_LABEL, IDH_ViewRuleProperties,
	IDC_EXISTING_RULE_PROPS, IDH_ViewRuleProperties,
	IDC_ATTACHED_RULE_PROPS, IDH_ViewRuleProperties,
	IDC_RULE_ICON, IDH_NO_MSMQ_HELP,
    IDC_TRIGGER_ICON, IDH_NO_MSMQ_HELP, 
    IDC_Monitored_Label, IDH_NO_MSMQ_HELP,
    IDC_Monitored_Queue, IDH_NO_MSMQ_HELP,
    IDC_TRIGGER_GENERAL_HEADER, IDH_NO_MSMQ_HELP,
    


    //
    // from control panel: cpl\cplhlps.h
    //
    IDC_Storage_Explanation_LABEL1, IDH_107_1038,
    IDC_Storage_Explanation_LABEL2, IDH_107_1038,
    ID_SiteList_LABEL, IDH_110_1017,
    ID_SiteList, IDH_110_1017,
    ID_CurrentSite, IDH_110_1018,
    ID_CurrentSite_LABEL, IDH_110_1018,
    ID_MessageLogger_LABEL, IDH_107_1046,
    ID_MessageLogger, IDH_107_1046,
    IDC_ServerName, IDH_150_1047,
    IDC_ServerName_LABEL, IDH_NO_MSMQ_HELP,
    ID_TransactionLogger_LABEL , IDH_107_1048,
    ID_TransactionLogger , IDH_107_1048,
    ID_RenewCryp, IDH_108_1027,
    IDC_CRYPTO_KEYS_LABEL, IDH_108_1027,
    IDC_Mobile_Explanation_LABEL, IDH_110_1030,
    ID_RenewCert, IDH_108_1031,
    ID_Register, IDH_108_1032,
    ID_Register_LABEL, IDH_108_1032,
    ID_View_LABEL, IDH_108_1033,
    ID_View, IDH_108_1033,
    ID_Remove_LABEL, IDH_108_1034,
    ID_Remove, IDH_108_1034,
    ID_RenewCert, IDH_108_1035,
    ID_MessageFiles_LABEL, IDH_107_1012,
    ID_MessageFiles, IDH_107_1012,
    IDC_SERVER_AUTHENTICATION_LABEL, IDH_158_1063,
    IDC_SERVER_AUTHENTICATION, IDH_158_1063,
    IDC_MOBILE_FRAME, IDH_FRAME_HELP,
    IDC_Security_Cert_FRAME, IDH_FRAME_HELP,
    IDC_Security_InternalCert_LABEL, IDH_FRAME_HELP,
    IDC_CRYPTO_KEYS_FRAME, IDH_FRAME_HELP,
    IDC_SERVER_AUTHENTICATION_FRAME, IDH_FRAME_HELP,  
    
    0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\msggen.h ===
#if !defined(AFX_MSGGEN_H__4910BC84_BEE4_11D1_9B9B_00E02C064C39__INCLUDED_)
#define AFX_MSGGEN_H__4910BC84_BEE4_11D1_9B9B_00E02C064C39__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// msggen.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMessageGeneralPage dialog

class CMessageGeneralPage : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CMessageGeneralPage)

// Construction
public:
	DWORD m_iIcon;
	CMessageGeneralPage();
	~CMessageGeneralPage();

// Dialog Data
	//{{AFX_DATA(CMessageGeneralPage)
	enum { IDD = IDD_MESSAGE_GENERAL };
	CStatic	m_cstaticMessageIcon;
	CString	m_szLabel;
	CString	m_szId;
	CString m_szLookupID;
	CString	m_szArrived;
	CString	m_szClass;
	CString	m_szPriority;
	CString	m_szSent;
	CString	m_szTrack;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMessageGeneralPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
   	BOOL m_bAutoDelete;

	// Generated message map functions
	//{{AFX_MSG(CMessageGeneralPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSGGEN_H__4910BC84_BEE4_11D1_9B9B_00E02C064C39__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\msggen.cpp ===
// msggen.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqPPage.h"
#include "msggen.h"

#include "msggen.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMessageGeneralPage property page

IMPLEMENT_DYNCREATE(CMessageGeneralPage, CMqPropertyPage)

CMessageGeneralPage::CMessageGeneralPage() : CMqPropertyPage(CMessageGeneralPage::IDD)
{
	//{{AFX_DATA_INIT(CMessageGeneralPage)
	m_szLabel = _T("");
	m_szId = _T("");
	m_szLookupID = _T("");
	m_szArrived = _T("");
	m_szClass = _T("");
	m_szPriority = _T("");
	m_szSent = _T("");
	m_szTrack = _T("");
	//}}AFX_DATA_INIT
    m_iIcon = IDI_MSGICON;
}

CMessageGeneralPage::~CMessageGeneralPage()
{
}

void CMessageGeneralPage::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	//{{AFX_DATA_MAP(CMessageGeneralPage)
	DDX_Control(pDX, IDC_MESSAGE_ICON, m_cstaticMessageIcon);
	DDX_Text(pDX, IDC_MSGLABEL, m_szLabel);
	DDX_Text(pDX, IDC_MSGID, m_szId);
	DDX_Text(pDX, IDC_MSGLOOKUPID, m_szLookupID);
	DDX_Text(pDX, IDC_MSGARRIVED, m_szArrived);
	DDX_Text(pDX, IDC_MSGCLASS, m_szClass);
	DDX_Text(pDX, IDC_MSGPRIORITY, m_szPriority);
	DDX_Text(pDX, IDC_MSGSENT, m_szSent);
	DDX_Text(pDX, IDC_MSGTRACK, m_szTrack);
	//}}AFX_DATA_MAP

    if (!pDX->m_bSaveAndValidate)
    {
        HICON hIcon = AfxGetApp()->LoadIcon(m_iIcon);
        ASSERT(0 != hIcon);
        m_cstaticMessageIcon.SetIcon(hIcon);
    }
}


BEGIN_MESSAGE_MAP(CMessageGeneralPage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CMessageGeneralPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMessageGeneralPage message handlers

BOOL CMessageGeneralPage::OnInitDialog() 
{
    //
    // PATCH!!!!
    // Defining this method to override the default OnInitDialog of
    // CMqPropertyPage, because it asserts.
    //
    // This function must be in the context of MMC.EXE so dont 
    // put an "AFX_MANAGE_STATE(AfxGetStaticModuleState());" unless
    // it is bracketted inside a {....} statement.
    //
    //

  	UpdateData( FALSE );

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\msgbody.h ===
#if !defined(AFX_MSGBODY_H__3B0D1CB4_D2C3_11D1_9B9D_00E02C064C39__INCLUDED_)
#define AFX_MSGBODY_H__3B0D1CB4_D2C3_11D1_9B9D_00E02C064C39__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// msgbody.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMessageBodyPage dialog

class CMessageBodyPage : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CMessageBodyPage)

// Construction
public:
	DWORD   m_dwBufLen;
	UCHAR * m_Buffer;


	CMessageBodyPage();
	~CMessageBodyPage();

// Dialog Data
	//{{AFX_DATA(CMessageBodyPage)
	enum { IDD = IDD_MESSAGE_BODY };
	CEdit	m_ctlBodyEdit;
	CString	m_strBodySizeMessage;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMessageBodyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMessageBodyPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSGBODY_H__3B0D1CB4_D2C3_11D1_9B9D_00E02C064C39__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\msgbody.cpp ===
// msgbody.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqPPage.h"
#include "msgbody.h"
#include "globals.h"

#include "msgbody.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMessageBodyPage property page

IMPLEMENT_DYNCREATE(CMessageBodyPage, CMqPropertyPage)

CMessageBodyPage::CMessageBodyPage() : CMqPropertyPage(CMessageBodyPage::IDD)
{
	//{{AFX_DATA_INIT(CMessageBodyPage)
	m_strBodySizeMessage = _T("");
	//}}AFX_DATA_INIT
}

CMessageBodyPage::~CMessageBodyPage()
{
}

void CMessageBodyPage::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMessageBodyPage)
	DDX_Control(pDX, IDC_MESSAGE_BODY_EDIT, m_ctlBodyEdit);
	DDX_Text(pDX, IDC_MBODY_SIZE_MESSAGE, m_strBodySizeMessage);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMessageBodyPage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CMessageBodyPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMessageBodyPage message handlers

BOOL CMessageBodyPage::OnInitDialog() 
{
  	UpdateData( FALSE );
	
    static CFont font;
    static UINT nBytesPerLine = 0;

    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        //
        // Create font and calculate char width - needed only once in the
        // application's activation
        //
        if (0 == nBytesPerLine)
        {
            LOGFONT lf = {0,0,0,0,0,0,0,0,0,0,0,0, FIXED_PITCH, TEXT("")};
            font.CreateFontIndirect(&lf);
            m_ctlBodyEdit.SetFont(&font);

            CDC *pdc = m_ctlBodyEdit.GetDC();
    
            INT iCharWidth;
            //
            // This is a fixed pitch font - so it is enough to pick one 
            // char by random ("A" in this case) and calculate its width
            //
            pdc->GetCharWidth(65,65,&iCharWidth);
            m_ctlBodyEdit.ReleaseDC(pdc);
  
            RECT rectText;
            m_ctlBodyEdit.GetRect(&rectText);

            //
            // We always have a vertical scroll bar
            //
            UINT nNumChars = (rectText.right - rectText.left - GetSystemMetrics(SM_CXVSCROLL)) / iCharWidth;

            //
            // Every byte occupys one char for ASCII representation, and three (two digits and 
            // a space) for hex representation - total of four.
            //
            nBytesPerLine = nNumChars/4;
        }
        else
        {
            m_ctlBodyEdit.SetFont(&font);
        }

        CString strFullText(TEXT(""));

        for (DWORD iStartLine = 0; iStartLine < m_dwBufLen;
             iStartLine += nBytesPerLine)
        {
            CString strHexLine(TEXT(""));
            DWORD iEndOfLine = min(m_dwBufLen, iStartLine + nBytesPerLine);
	        for (DWORD i=iStartLine; i<iStartLine + nBytesPerLine; i++)
            {
                if (i<m_dwBufLen)
                {
                    CString strHex;
                    ULONG ulTempValue = m_Buffer[i];
                    strHex.Format(TEXT("%02X "), ulTempValue);
                    strHexLine += strHex;
                }
                else
                {
                    //
                    // Pad the hex line with spaces
                    //
                    strHexLine += TEXT("   ");
                }
            }
            CString strLineText;
            CAUB caubLine;
            caubLine.cElems = iEndOfLine - iStartLine;
            caubLine.pElems = &m_Buffer[iStartLine];
            CaubToString(&caubLine, strLineText);

            strFullText += strHexLine + strLineText + TEXT("\r\n");
        }
    
        m_ctlBodyEdit.SetWindowText(strFullText);
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\mqsnap.cpp ===
// mqsnap.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f mqsnapps.mk in the project directory.

#include "stdafx.h"
#include "initguid.h"
#include "cmnquery.h" // re-include for GUID initialization
#include "dsadmin.h" // re-include for GUID initialization
#include "mqsnap.h"
#include "mqsnap_i.c"
#include "Snapin.h"
#include "dataobj.h"
#include "dsext.h"
#include "qnmsprov.h"
#include "localfld.h"
#include "SnpQueue.h"
#include "edataobj.h"
#include "linkdata.h"
#include "UserCert.h"
#include "ForgData.h"
#include "aliasq.h"
#include "_mqres.h"


#include "mqsnap.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CComModule _Module;

//
// define the resource only dll handle
//
HMODULE     g_hResourceMod=NULL;


BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_MSMQSnapin, CSnapin)
    OBJECT_ENTRY(CLSID_MSMQSnapinAbout, CSnapinAbout)
    OBJECT_ENTRY(CLSID_MsmqQueueExt, CQueueDataObject)
    OBJECT_ENTRY(CLSID_MsmqCompExt, CComputerMsmqDataObject)
    OBJECT_ENTRY(CLSID_EnterpriseDataObject, CEnterpriseDataObject)
    OBJECT_ENTRY(CLSID_LinkDataObject, CLinkDataObject)
    OBJECT_ENTRY(CLSID_UserCertificate, CRegularUserCertificate)
    OBJECT_ENTRY(CLSID_MigratedUserCertificate, CMigratedUserCertificate)
    OBJECT_ENTRY(CLSID_ForeignSiteData, CForeignSiteData)
    OBJECT_ENTRY(CLSID_AliasQObject, CAliasQObject)
END_OBJECT_MAP()

class CMqsnapApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
};

CMqsnapApp theApp;



BOOL CMqsnapApp::InitInstance()
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

    _Module.Init(ObjectMap, m_hInstance);
    CSnapInItem::Init();
    
    g_hResourceMod=MQGetResourceHandle();
    
    if(g_hResourceMod == NULL)return FALSE;
    
    AfxSetResourceHandle(g_hResourceMod);


    //
    //  Previously m_pszAppName string is coming from AFX_IDS_APP_TITLE
    //  resource ID. However, due to the localization effort which centralized all the resource
    //  in mqutil.dll, AFX_IDS_APP_TITLE was removed from mqsnap.dll.  Now we just need to  
    //  get it from mqutil.dll     
    //

    CString csTitle;
    
    if( csTitle.LoadString(AFX_IDS_APP_TITLE) )
    {
        //
        // Free m_pszAppName first
        //
        if(m_pszAppName)
        {
            free((void*)m_pszAppName);
        }

        //
        //  The CWinApp destructor will free the memory.
        //
        m_pszAppName = _tcsdup((LPCTSTR)csTitle);
    }
    
    
    return  CWinApp::InitInstance();
}

int CMqsnapApp::ExitInstance()
{
    WPP_CLEANUP();

    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\msgq.h ===
#if !defined(AFX_MSGQ_H__3F7BAB03_BFBE_11D1_9B9B_00E02C064C39__INCLUDED_)
#define AFX_MSGQ_H__3F7BAB03_BFBE_11D1_9B9B_00E02C064C39__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// msgq.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMessageQueuesPage dialog

class CMessageQueuesPage : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CMessageQueuesPage)

// Construction
public:
	CMessageQueuesPage();
	~CMessageQueuesPage();

// Dialog Data
    //{{AFX_DATA(CMessageQueuesPage)
    enum { IDD = IDD_MESSAGE_QUEUE };
    CString	m_szAdminFN;
    CString	m_szAdminPN;
    CString	m_szDestFN;
    CString	m_szDestPN;
    CString	m_szRespFN;
    CString	m_szRespPN;
    CString m_szMultiDestFN;
    //}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMessageQueuesPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMessageQueuesPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSGQ_H__3F7BAB03_BFBE_11D1_9B9B_00E02C064C39__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\msgsndr.cpp ===
// msgsndr.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqPPage.h"
#include "msgsndr.h"

#include "msgsndr.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMessageSenderPage  property page

IMPLEMENT_DYNCREATE(CMessageSenderPage, CMqPropertyPage)


CMessageSenderPage::CMessageSenderPage() : CMqPropertyPage(CMessageSenderPage::IDD)
{
	//{{AFX_DATA_INIT(CMessageSenderPage)
	m_szAuthenticated = _T("");
	m_szEncrypt = _T("");
	m_szEncryptAlg = _T("");
	m_szHashAlg = _T("");
	m_szGuid = _T("");
	m_szPathName = _T("");
	m_szSid = _T("");
	m_szUser = _T("");
	//}}AFX_DATA_INIT
}

CMessageSenderPage::~CMessageSenderPage()
{
}

void CMessageSenderPage::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMessageSenderPage)
	DDX_Text(pDX, IDC_MSGAUTHENTICATED, m_szAuthenticated);
	DDX_Text(pDX, IDC_MSGENCRYPT, m_szEncrypt);
	DDX_Text(pDX, IDC_MSGENCRYPTALG, m_szEncryptAlg);
	DDX_Text(pDX, IDC_MSGHASHALG, m_szHashAlg);
	DDX_Text(pDX, IDC_MSGGUID, m_szGuid);
	DDX_Text(pDX, IDC_MSGPATHNAME, m_szPathName);
	DDX_Text(pDX, IDC_MSGSID, m_szSid);
	DDX_Text(pDX, IDC_MSGUSER, m_szUser);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMessageSenderPage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CMessageSenderPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMessageSenderPage message handlers

BOOL CMessageSenderPage::OnInitDialog() 
{
    //
    // PATCH!!!!
    // Defining this method to override the default OnInitDialog of
    // CMqPropertyPage, because it asserts.
    //
    // This function must be in the context of MMC.EXE so dont 
    // put an "AFX_MANAGE_STATE(AfxGetStaticModuleState());" unless
    // it is bracketted inside a {....} statement.
    //
    //

  	UpdateData( FALSE );

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\msgsoap.h ===
/*++

Copyright (c) 1995 - 2001 Microsoft Corporation

Module Name:

    msgsoap.h

Abstract:

    Definition of SOAP Envelope property page 

Author:

    Nela Karpel (nelak) 9-Sep-2001

Environment:

    Platform-independent.

--*/
#pragma once
#ifndef _MSG_SOAP_ENV_H_
#define _MSG_SOAP_ENV_H_


/////////////////////////////////////////////////////////////////////////////
// CMessageBodyPage dialog

class CMessageSoapEnvPage : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CMessageSoapEnvPage)

public:

	CMessageSoapEnvPage() {};
	
	CMessageSoapEnvPage(
				DWORD dwSoapEnvSize,
				const CString& strQueueFormatName,
				ULONGLONG lookupID
				);

	~CMessageSoapEnvPage();

public:
	enum { IDD = IDD_MESSAGE_SOAP_ENV };
	CEdit	m_ctlSoapEnvEdit;

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	virtual BOOL OnInitDialog();
	DECLARE_MESSAGE_MAP()

private:
	DWORD m_dwSoapEnvSize;
	CString m_strQueueFormatName;
	ULONGLONG m_ululLookupID;
};


#endif //_MSG_SOAP_ENV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\msmqdobj.h ===
/*++

Copyright (c) 1995 - 2001 Microsoft Corporation

Module Name:

    msmqdobj.h

Abstract:

    Definition of objects that represent MSMQ computer
	object in DS snapin

Author:

    Nela Karpel (nelak) 26-Jul-2001

Environment:

    Platform-independent.

--*/
#pragma once
#ifndef __MSMQDATAOBJ_H_
#define __MSMQDATAOBJ_H_

#include "dataobj.h"

class CMsmqDataObject : 
    public CDataObject,
    public IQueryForm
{
public:
    BEGIN_COM_MAP(CMsmqDataObject)
	    COM_INTERFACE_ENTRY(IQueryForm)
	    COM_INTERFACE_ENTRY_CHAIN(CDataObject)
    END_COM_MAP()

    CMsmqDataObject();
    ~CMsmqDataObject();

    //
    // IShellExtInit
    //
	STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hkeyProgID);

    // IQueryForm
    STDMETHOD(Initialize)(THIS_ HKEY hkForm);
    STDMETHOD(AddForms)(THIS_ LPCQADDFORMSPROC pAddFormsProc, LPARAM lParam);
    STDMETHOD(AddPages)(THIS_ LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam) PURE;

protected:
    static  FindColumns Columns[];
    static  HRESULT CALLBACK QueryPageProc(LPCQPAGE pQueryPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static  INT_PTR CALLBACK FindDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void ClearQueryWindowFields(HWND hwnd) PURE;
	virtual HRESULT GetQueryParams(HWND hWnd, LPDSQUERYPARAMS* ppDsQueryParams) PURE;
	virtual HRESULT EnableQueryWindowFields(HWND hwnd, BOOL fEnable) PURE;
};


class CComputerMsmqDataObject : 
    public CMsmqDataObject,
   	public CComCoClass<CComputerMsmqDataObject,&CLSID_MsmqCompExt>
{
public:

    DECLARE_NOT_AGGREGATABLE(CComputerMsmqDataObject)
    DECLARE_REGISTRY_RESOURCEID(IDR_MsmqCompExt)

    //
    // IShellPropSheetExt
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    //
    // IContextMenu
    //
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);

    // IQueryForm
    STDMETHOD(AddPages)(THIS_ LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam);

    //
    // Constructor
    //
    CComputerMsmqDataObject()
    {
        m_guid = GUID_NULL;
    };

protected:
	virtual HRESULT ExtractMsmqPathFromLdapPath (LPWSTR lpwstrLdapPath);
    HPROPSHEETPAGE CreateGeneralPage();
    HPROPSHEETPAGE CreateRoutingPage();
    HPROPSHEETPAGE CreateDependentClientPage();
    HPROPSHEETPAGE CreateSitesPage();
    HPROPSHEETPAGE CreateDiagPage();
	virtual HRESULT EnableQueryWindowFields(HWND hwnd, BOOL fEnable);
	virtual void ClearQueryWindowFields(HWND hwnd);
	virtual HRESULT GetQueryParams(HWND hWnd, LPDSQUERYPARAMS* ppDsQueryParams);

   	virtual const DWORD GetObjectType();
    virtual const PROPID *GetPropidArray();
    virtual const DWORD  GetPropertiesCount();
    GUID *GetGuid();

    enum _MENU_ENTRY
    {
        mneMqPing = 0
    };

private:
    static const PROPID mx_paPropid[];
    GUID m_guid;
};


inline const DWORD CComputerMsmqDataObject::GetObjectType()
{
    return MQDS_MACHINE;
};

inline const PROPID *CComputerMsmqDataObject::GetPropidArray()
{
    return mx_paPropid;
}




#endif // __MSMQDATAOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\msgsndr.h ===
#if !defined(AFX_MSGSNDR_H__4910BC85_BEE4_11D1_9B9B_00E02C064C39__INCLUDED_)
#define AFX_MSGSNDR_H__4910BC85_BEE4_11D1_9B9B_00E02C064C39__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// msgsndr.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMessageSenderPage dialog

class CMessageSenderPage : public CMqPropertyPage
{
  	DECLARE_DYNCREATE(CMessageSenderPage)

// Construction
public:
	CMessageSenderPage();   // standard constructor
    ~CMessageSenderPage();

// Dialog Data
	//{{AFX_DATA(CMessageSenderPage)
	enum { IDD = IDD_MESSAGE_SENDER };
	CString	m_szAuthenticated;
	CString	m_szEncrypt;
	CString	m_szEncryptAlg;
	CString	m_szHashAlg;
	CString	m_szGuid;
	CString	m_szPathName;
	CString	m_szSid;
	CString	m_szUser;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMessageSenderPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMessageSenderPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSGSNDR_H__4910BC85_BEE4_11D1_9B9B_00E02C064C39__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\msgsoap.cpp ===
/*++

Copyright (c) 1995 - 2001 Microsoft Corporation

Module Name:

    msgsoap.cpp

Abstract:

    Implelentation of SOAP Envelope property page 

Author:

    Nela Karpel (nelak) 9-Sep-2001

Environment:

    Platform-independent.

--*/

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqPPage.h"
#include "globals.h"
#include "msgsoap.h"

#include "msgsoap.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static
void 
IdentEnvelope(
	const CString strEnvelope,
	CString& strIdentedEnv
	)
{
	strIdentedEnv = L"";

	int iIndent = 0;
	int closeBrIndx = 0;

	int openBrIndx = strEnvelope.Find(L"<", 0);
	
	while (openBrIndx < strEnvelope.GetLength())
	{
		ASSERT(("Opening tag was not found", openBrIndx != ((int)(-1))));

		if (strEnvelope.GetAt(openBrIndx + 1) == L'/')
		{
			//
			// This is a closing tag
			//
			iIndent--;
			closeBrIndx = strEnvelope.Find(L">", openBrIndx+1);
			
			strIdentedEnv += CString(L' ', iIndent * 4);
			strIdentedEnv += strEnvelope.Mid(openBrIndx, closeBrIndx - openBrIndx + 1);
			strIdentedEnv += L"\r\n";
			
		}
		else
		{
			//
			// This is an opening tag
			//
			closeBrIndx = strEnvelope.Find(L">", openBrIndx+1);

			strIdentedEnv += CString(L' ', iIndent * 4);
			strIdentedEnv += strEnvelope.Mid(openBrIndx, closeBrIndx - openBrIndx + 1);
			strIdentedEnv += L"\r\n";
			
			//
			// Do not increase indentation if this is tag of 
			// type <MyTag/>.
			//
			if (strEnvelope.GetAt(closeBrIndx - 1) != L'/')
			{
				iIndent++;
			}

		}

		//
		// find next "<", if next opening tag doesn't exist exit.
		//
		int openBrIndx1 = strEnvelope.Find(L"<", closeBrIndx+1);
		if(openBrIndx1 == ((int)(-1)))
			return;

		if (openBrIndx1 != (closeBrIndx + 1))
		{
			//
			// There is content
			//
			strIdentedEnv += CString(L' ', iIndent * 4);
			strIdentedEnv += strEnvelope.Mid(closeBrIndx + 1, openBrIndx1 - closeBrIndx - 1);
			strIdentedEnv += L"\r\n";
		}

		openBrIndx = openBrIndx1;
	}
}


static
HRESULT
ReceiveSoapEnvelopeByLookupID(
				QUEUEHANDLE hQueue,
				ULONGLONG ululLookupID,
				DWORD dwLength,
				LPWSTR pwcsSoapEnvelope
				)
{
	MQMSGPROPS msgProps;
	MSGPROPID propId[2];
	MQPROPVARIANT propVar[2];

	int i = 0;
	propId[i] = PROPID_M_SOAP_ENVELOPE_LEN;
	propVar[i].vt = VT_UI4;
	propVar[i].ulVal = dwLength;
	i++;

	propId[i] = PROPID_M_SOAP_ENVELOPE;
	propVar[i].vt = VT_LPWSTR;
	propVar[i].pwszVal = pwcsSoapEnvelope;
	i++;

	msgProps.cProp = i;
	msgProps.aPropID = propId;
	msgProps.aPropVar = propVar;
	msgProps.aStatus = NULL;

	HRESULT hr = MQReceiveMessageByLookupId(
										hQueue, 
										ululLookupID,
										MQ_LOOKUP_PEEK_CURRENT,
										&msgProps,
										NULL,
										NULL,
										NULL
										);

	return hr;
}

							
/////////////////////////////////////////////////////////////////////////////
// CMessageSoapEnvPage property page

IMPLEMENT_DYNCREATE(CMessageSoapEnvPage, CMqPropertyPage)


CMessageSoapEnvPage::CMessageSoapEnvPage(
	DWORD dwSoapEnvSize,
	const CString& strQueueFormatName,
	ULONGLONG lookupID
	) : 
	CMqPropertyPage(CMessageSoapEnvPage::IDD),
	m_dwSoapEnvSize(dwSoapEnvSize),
	m_strQueueFormatName(strQueueFormatName),
	m_ululLookupID(lookupID)
{
}


CMessageSoapEnvPage::~CMessageSoapEnvPage()
{
}


void CMessageSoapEnvPage::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);

	DDX_Control(pDX, IDC_MESSAGE_SOAP_EDIT, m_ctlSoapEnvEdit);
}


BEGIN_MESSAGE_MAP(CMessageSoapEnvPage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CMessageSoapEnvPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMessageSoapEnvPage message handlers

BOOL CMessageSoapEnvPage::OnInitDialog() 
{
  	UpdateData( FALSE );
		
	QUEUEHANDLE hQueue;
	HRESULT hr = MQOpenQueue(
					m_strQueueFormatName,
					MQ_PEEK_ACCESS,
					MQ_DENY_NONE,
					&hQueue
					);

	if (FAILED(hr))
	{
		MessageDSError(hr, IDS_SOAP_ERROR_DISPLAY);
		return TRUE;
	}


	AP<WCHAR> pwcsSoap = new WCHAR[m_dwSoapEnvSize + 1];

	hr = ReceiveSoapEnvelopeByLookupID(
									hQueue,
									m_ululLookupID,
									m_dwSoapEnvSize,
									pwcsSoap
									);
	MQCloseQueue(hQueue);

	if (FAILED(hr))
	{
		MessageDSError(hr, IDS_SOAP_ERROR_DISPLAY);
		return TRUE;
	}

	CString strIdentedEnvelope;
	IdentEnvelope(pwcsSoap.get(), strIdentedEnvelope);

	m_ctlSoapEnvEdit.SetWindowText(strIdentedEnvelope);
   
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\msmqlink.h ===
#if !defined(AFX_MSMQLINK_H__2E4B37AC_CC8B_11D1_9C85_006008764D0E__INCLUDED_)
#define AFX_MSMQLINK_H__2E4B37AC_CC8B_11D1_9C85_006008764D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// MsmqLink.h : header file
//

#include "resource.h"

class CSiteInfo
{
public:
    CSiteInfo(
        GUID* pSiteId,
        LPWSTR pSiteName
        );

    ~CSiteInfo();

    LPCWSTR 
    GetSiteName(
        void
        );

    const
    GUID*
    GetSiteId(
        void
        ) const;

private:
    GUID m_SiteId;
    CString m_SiteName;
};


/////////////////////////////////////////////////////////////////////////////
// CMsmqLink dialog

class CMsmqLink : public CMqPropertyPage
{
// Construction
public:
	CMsmqLink(const CString& strDomainController, const CString& strContainerPathDispFormat);   // standard constructor
    ~CMsmqLink();

    HRESULT
    CreateSiteLink (
        void
	    );

    LPCWSTR 
    GetSiteLinkFullPath(
       void
       );

	void
	SetParentPropertySheet(
		CGeneralPropertySheet* pPropertySheet
		);


    // Dialog Data
	//{{AFX_DATA(CMsmqLink)
	enum { IDD = IDD_NEW_MSMQ_LINK };
	DWORD	m_dwLinkCost;
	CString	m_strFirstSite;
	CString	m_strSecondSite;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMsmqLink)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMsmqLink)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeFirstSiteCombo();
	afx_msg void OnSelchangeSecondSiteCombo();
	virtual BOOL OnWizardFinish();
	virtual BOOL OnSetActive();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	BOOL m_fThereAreForeignSites;
    HRESULT 
    InitializeSiteInfo(
        void
        );

    void
    CheckLinkValidityAndForeignExistance (    
        CDataExchange* pDX
	    );

    DWORD m_SiteNumber;
    CArray<CSiteInfo*, CSiteInfo*&> m_SiteInfoArray;

    BOOL m_FirstSiteSelected;
    BOOL m_SecondSiteSelected;

	CComboBox*	m_pSecondSiteCombo;
	CComboBox*	m_pFirstSiteCombo;

    const GUID* m_FirstSiteId;
    const GUID* m_SecondSiteId;

    CString m_SiteLinkFullPath;
    CString m_strDomainController;

	CString m_strContainerPathDispFormat;
	CGeneralPropertySheet* m_pParentSheet;
};


inline
LPCWSTR 
CMsmqLink::GetSiteLinkFullPath(
   void
   )
{
    return m_SiteLinkFullPath;
}

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSMQLINK_H__2E4B37AC_CC8B_11D1_9C85_006008764D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\msmqdobj.cpp ===
/*++

Copyright (c) 1995 - 2001 Microsoft Corporation

Module Name:

    msmqdobj.cpp

Abstract:

    Implelentation of objects that represent MSMQ computer
	object in DS snapin

Author:

    Nela Karpel (nelak) 26-Jul-2001

Environment:

    Platform-independent.

--*/

#include "stdafx.h"
#include "shlobj.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "mqPPage.h"
#include "msmqdobj.h"
#include "mqDsPage.h"
#include "strconv.h"
#include "CompGen.h"
#include "frslist.h"
#include "CmpMRout.h"
#include "compsite.h"
#include "CompDiag.h"
#include "deppage.h"
#include "Qname.h"
#include "admmsg.h"
#include "generrpg.h"
#include "ldaputl.h"

#include "msmqdobj.tmh"

/////////////////////////////////////////////////////////////////////
// CMsmqDataObject
//
CMsmqDataObject::CMsmqDataObject()
{
}


CMsmqDataObject::~CMsmqDataObject()
{
}


STDMETHODIMP CMsmqDataObject::Initialize (
    LPCITEMIDLIST pidlFolder, 
    LPDATAOBJECT lpdobj, 
    HKEY hkeyProgID)
{
    HRESULT hr = CDataObject::Initialize(
                    pidlFolder,
                    lpdobj,
                    hkeyProgID);
    if FAILED(hr)
    {
        return hr;
    }    

    return hr;
}


/*-----------------------------------------------------------------------------
/ IQueryForm methods
/----------------------------------------------------------------------------*/

STDMETHODIMP CMsmqDataObject::Initialize(THIS_ HKEY /*hkForm*/)
{
    // This method is called to initialize the query form object, it is called before
    // any pages are added.  hkForm should be ignored, in the future however it
    // will be a way to persist form state.

    return S_OK;
}


/*---------------------------------------------------------------------------*/
STDMETHODIMP CMsmqDataObject::AddForms(THIS_ LPCQADDFORMSPROC /*pAddFormsProc*/, LPARAM /*lParam*/)
{
    // This method is called to allow the form handler to register its query form(s),
    // each form is identifiered by a CLSID and registered via the pAddFormProc.  Here
    // we are going to register a test form.
    
    // When registering a form which is only applicable to a specific task, eg. Find a Domain
    // object, it is advised that the form be marked as hidden (CQFF_ISNEVERLISTED) which 
    // will cause it not to appear in the form picker control.  Then when the
    // client wants to use this form, they specify the form identifier and ask for the
    // picker control to be hidden. 

    //
    // By default - do nothing
    //
    return S_OK;

}


/*---------------------------------------------------------------------------*/

// The PageProc is used to perform general house keeping and communicate between
// the frame and the page. 
//
// All un-handled, or unknown reasons should result in an E_NOIMPL response
// from the proc.  
//
// In:
//  pPage -> CQPAGE structure (copied from the original passed to pAddPagesProc)
//  hwnd = handle of the dialog for the page
//  uMsg, wParam, lParam = message parameters for this event
//
// Out:
//  HRESULT
//
// uMsg reasons:
// ------------
//  CQPM_INIIIALIZE
//  CQPM_RELEASE
//      These are issued as a result of the page being declared or freed, they 
//      allow the caller to AddRef, Release or perform basic initialization
//      of the form object.
//
// CQPM_ENABLE
//      Enable is when the query form needs to enable or disable the controls
//      on its page.  wParam contains TRUE/FALSE indicating the state that
//      is required.
//
// CQPM_GETPARAMETERS
//      To collect the parameters for the query each page on the active form 
//      receives this event.  lParam is an LPVOID* which is set to point to the
//      parameter block to pass to the handler, if the pointer is non-NULL 
//      on entry the form needs to appened its query information to it.  The
//      parameter block is handler specific. 
//
//      Returning S_FALSE from this event causes the query to be canceled.
//
// CQPM_CLEARFORM
//      When the page window is created for the first time, or the user clicks
//      the clear search the page receives a CQPM_CLEARFORM notification, at 
//      which point it needs to clear out the edit controls it has and
//      return to a default state.
//
// CQPM_PERSIST:
//      When loading of saving a query, each page is called with an IPersistQuery
//      interface which allows them to read or write the configuration information
//      to save or restore their state.  lParam is a pointer to the IPersistQuery object,
//      and wParam is TRUE/FALSE indicating read or write accordingly.

HRESULT CALLBACK CMsmqDataObject::QueryPageProc(LPCQPAGE pQueryPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    CMsmqDataObject* pMsmqDataObject = (CMsmqDataObject*)pQueryPage->lParam;

    switch ( uMsg )
    {
        // Initialize so AddRef the object we are associated with so that
        // we don't get unloaded.

        case CQPM_INITIALIZE:
            pMsmqDataObject->CComObjectRoot::InternalAddRef();
            break;

        // Release, therefore Release the object we are associated with to
        // ensure correct destruction etc.

        case CQPM_RELEASE:
            pMsmqDataObject->CComObjectRoot::InternalRelease();
            break;

        // Enable so fix the state of our two controls within the window.

        case CQPM_ENABLE:
            pMsmqDataObject->EnableQueryWindowFields(hwnd, DWORD_PTR_TO_DWORD(wParam));
            break;

        // Fill out the parameter structure to return to the caller, this is 
        // handler specific.  In our case we constructure a query of the CN
        // and objectClass properties, and we show a columns displaying both
        // of these.  For further information about the DSQUERYPARAMs structure
        // see dsquery.h

        case CQPM_GETPARAMETERS:
            hr = pMsmqDataObject->GetQueryParams(hwnd, (LPDSQUERYPARAMS*)lParam);
            break;

        // Clear form, therefore set the window text for these two controls
        // to zero.

        case CQPM_CLEARFORM:
            pMsmqDataObject->ClearQueryWindowFields(hwnd);
            break;
            
        // persistance is not currently supported by this form.            
                  
        case CQPM_PERSIST:
        {
            BOOL fRead = (BOOL)wParam;
            IPersistQuery* pPersistQuery = (IPersistQuery*)lParam;

            ASSERT(0 != pPersistQuery);

            hr = E_NOTIMPL;             // NYI
            break;
        }

        default:
        {
            hr = E_NOTIMPL;
            break;
        }
    }

    return hr;
}


//
// The DlgProc is a standard Win32 dialog proc associated with the form
// window.  
//
INT_PTR CALLBACK CMsmqDataObject::FindDlgProc(HWND hwnd, UINT uMsg, WPARAM /*wParam*/, LPARAM lParam)
{
    BOOL fResult = FALSE;
    LPCQPAGE pQueryPage;

    if ( uMsg == WM_INITDIALOG )
    {
        //
        // pQueryPage will be of use later, so hang onto it by storing it
        // in the DWL_USER field of the dialog box instance.
        //

        pQueryPage = (LPCQPAGE)lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pQueryPage);
    }
    else
    {
        //
        // pQueryPage can be retreived from the DWL_USER field of the
        // dialog structure, note however that in some cases this will
        // be NULL as it is set on WM_INITDIALOG.
        //

        pQueryPage = (LPCQPAGE)GetWindowLongPtr(hwnd, DWLP_USER);
    }

    return fResult;
}




////////////////////////////////////////////////////////////////////////////////////
// ComputerMSMQDataObject
//
const PROPID CComputerMsmqDataObject::mx_paPropid[] = 
    {PROPID_QM_MACHINE_ID, 
     PROPID_QM_QUOTA, PROPID_QM_JOURNAL_QUOTA, PROPID_QM_SERVICE, 
     PROPID_QM_SERVICE_DSSERVER,  PROPID_QM_SERVICE_ROUTING, 
     PROPID_QM_SERVICE_DEPCLIENTS, PROPID_QM_FOREIGN, PROPID_QM_OUTFRS, 
     PROPID_QM_INFRS, PROPID_QM_SITE_ID, PROPID_QM_SITE_IDS};


const DWORD  CComputerMsmqDataObject::GetPropertiesCount()
{
    return sizeof(mx_paPropid) / sizeof(mx_paPropid[0]);
}


HRESULT CComputerMsmqDataObject::ExtractMsmqPathFromLdapPath(LPWSTR lpwstrLdapPath)
{
    return ExtractComputerMsmqPathNameFromLdapName(m_strMsmqPath, lpwstrLdapPath);
}

    
//
// IShellPropSheetExt
//
STDMETHODIMP CComputerMsmqDataObject::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    HPROPSHEETPAGE hPage;
    //
    // Call GetProperties and capture the errors
    //
    {
        CErrorCapture errstr;
        hr = GetProperties();
        if (FAILED(hr))
        {
            hPage = CGeneralErrorPage::CreateGeneralErrorPage(m_pDsNotifier, errstr);
            if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
            {
                ASSERT(0);
                return E_UNEXPECTED;
            }
        return S_OK;
        }
    }

    //
    // Check if the machine is an MSMQ server - [adsrv] separately per functionality
    //
    PROPVARIANT propVar;
    PROPID pid;
    
    pid = PROPID_QM_SERVICE_DSSERVER;
    VERIFY(m_propMap.Lookup(pid, propVar));
    BOOL fDs = propVar.bVal;

    pid = PROPID_QM_SERVICE_ROUTING;
    VERIFY(m_propMap.Lookup(pid, propVar));
    BOOL fRout= propVar.bVal;

    pid = PROPID_QM_SERVICE_DEPCLIENTS;
    VERIFY(m_propMap.Lookup(pid, propVar));
    BOOL fDepCl= propVar.bVal;

    //
    // Get foreign flag
    //
    pid = PROPID_QM_FOREIGN;
    VERIFY(m_propMap.Lookup(pid, propVar));
    BOOL fForeign = (propVar.bVal);


	hPage = CreateGeneralPage();
	if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
	{
		ASSERT(0);
		return E_UNEXPECTED;
	}

    //
    // Routing page should appear only on clients
    //
    if ((!fRout) && (!fForeign))   // [adsrv] fIsServer
    {
        hPage = CreateRoutingPage();
        if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
        {
            ASSERT(0);
            return E_UNEXPECTED;
        }
    }

    //
    // Dependent client page appear only on servers
    //
    if (fDepCl)       // [adsrv] fIsServer
    {
        hPage = CreateDependentClientPage();
        if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
        {
            ASSERT(0);
            return E_UNEXPECTED;
        }
    }

    //
    // Sites page is created iff PROPID_QM_SITE_IDS exists in the map.
    // Otherwise, we are in NT4 - multiple sites are not supported, 
    // and we will not display the sites.
    //

    pid = PROPID_QM_SITE_IDS;
    if (m_propMap.Lookup(pid, propVar))
    {

        hPage = CreateSitesPage();
        if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
        {
            ASSERT(0);
            return E_UNEXPECTED;
        }
    }

    if (!fForeign)
    {
        hPage = CreateDiagPage();
        if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
        {
            ASSERT(0);
            return E_UNEXPECTED;
        }
    }

    //
    // Add the "Object" page using the cached interface
    //
    if (m_spObjectPage != 0)
    {
        VERIFY(SUCCEEDED(m_spObjectPage->AddPages(lpfnAddPage, lParam)));
    }

    //
    // Security page
    //
    hr = CreateMachineSecurityPage(
			&hPage, 
			m_strMsmqPath, 
			GetDomainController(m_strDomainController), 
			true	// fServerName
			);
    if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
    {
        ASSERT(0);
        return E_UNEXPECTED;
    }

    return S_OK;
}


HPROPSHEETPAGE CComputerMsmqDataObject::CreateGeneralPage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // By using template class CMqDsPropertyPage, we extend the basic functionality
    // of CQueueGeneral and add DS snap-in notification on release
    //
    CMqDsPropertyPage<CComputerMsmqGeneral> *pcpageGeneral = 
        new CMqDsPropertyPage<CComputerMsmqGeneral> (m_pDsNotifier);

    pcpageGeneral->m_strMsmqName = m_strMsmqPath;
    pcpageGeneral->m_strDomainController = m_strDomainController;

    PROPVARIANT propVar;
    PROPID pid;

    //
    // PROPID_QM_MACHINE_ID
    //
    pid = PROPID_QM_MACHINE_ID;
    VERIFY(m_propMap.Lookup(pid, propVar));
    pcpageGeneral->m_guidID = *propVar.puuid;    

    //
    // PROPID_QM_QUOTA
    //
    pid = PROPID_QM_QUOTA;
    VERIFY(m_propMap.Lookup(pid, propVar));
    pcpageGeneral->m_dwQuota = propVar.ulVal;

    //
    // PROPID_QM_JOURNAL_QUOTA
    //
    pid = PROPID_QM_JOURNAL_QUOTA;
    VERIFY(m_propMap.Lookup(pid, propVar));
    pcpageGeneral->m_dwJournalQuota = propVar.ulVal;

    //
    // PROPID_QM_SERVICE, PROPID_QM_FOREIGN
    //
    pid = PROPID_QM_SERVICE;            
    VERIFY(m_propMap.Lookup(pid, propVar));
    ULONG ulService = propVar.ulVal;

    pid = PROPID_QM_SERVICE_DSSERVER;
    VERIFY(m_propMap.Lookup(pid, propVar));
    BOOL fDs = propVar.bVal;

    pid = PROPID_QM_SERVICE_ROUTING;
    VERIFY(m_propMap.Lookup(pid, propVar));
    BOOL fRout= propVar.bVal;

    pid = PROPID_QM_SERVICE_DEPCLIENTS;
    VERIFY(m_propMap.Lookup(pid, propVar));
    BOOL fDepCl= propVar.bVal;

    pid = PROPID_QM_FOREIGN;
    VERIFY(m_propMap.Lookup(pid, propVar));
    BOOL fForeign = propVar.bVal;

	pcpageGeneral->SetForeign(fForeign);
    pcpageGeneral->m_strService = MsmqServiceToString(fRout, fDepCl, fForeign);

    return pcpageGeneral->CreateThemedPropertySheetPage();
}


HPROPSHEETPAGE CComputerMsmqDataObject::CreateRoutingPage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    PROPVARIANT propVar;
    PROPID pid;

    //
    // Note: CComputerMsmqGeneral is auto-delete by default
    //
    CComputerMsmqRouting *pcpageRouting = new CComputerMsmqRouting();
    pcpageRouting->m_strMsmqName = m_strMsmqPath;
    pcpageRouting->m_strDomainController = m_strDomainController;

    //
    // PROPID_QM_SITE_IDS
    //
    pid = PROPID_QM_SITE_IDS;
    VERIFY(m_propMap.Lookup(pid, propVar));
    pcpageRouting->InitiateSiteIDsValues(&propVar.cauuid);

    //
    // PROPID_QM_OUTFRS
    //
    pid = PROPID_QM_OUTFRS;
    VERIFY(m_propMap.Lookup(pid, propVar));
    pcpageRouting->InitiateOutFrsValues(&propVar.cauuid);

    //
    // PROPID_QM_INFRS
    //
    pid = PROPID_QM_INFRS;
    VERIFY(m_propMap.Lookup(pid, propVar));
    pcpageRouting->InitiateInFrsValues(&propVar.cauuid);

    return pcpageRouting->CreateThemedPropertySheetPage();
}


HPROPSHEETPAGE 
CComputerMsmqDataObject::CreateDependentClientPage(
    void
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CDependentMachine* pDependentPage = new CDependentMachine;

    //
    // PROPID_QM_MACHINE_ID
    //
    PROPVARIANT propVar;
    PROPID pid = PROPID_QM_MACHINE_ID;

    VERIFY(m_propMap.Lookup(pid, propVar));
    pDependentPage->SetMachineId(propVar.puuid);

    return pDependentPage->CreateThemedPropertySheetPage();
}


HPROPSHEETPAGE CComputerMsmqDataObject::CreateDiagPage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Note: CComputerMsmqDiag is auto-delete by default
    //
    CComputerMsmqDiag *pcpageDiag = new CComputerMsmqDiag();

    pcpageDiag->m_strMsmqName = m_strMsmqPath;
    pcpageDiag->m_strDomainController = m_strDomainController;


    PROPVARIANT propVar;
    PROPID pid;

    //
    // PROPID_QM_MACHINE_ID
    //
    pid = PROPID_QM_MACHINE_ID;
    VERIFY(m_propMap.Lookup(pid, propVar));
    pcpageDiag->m_guidQM = *propVar.puuid;

    return pcpageDiag->CreateThemedPropertySheetPage(); 
}


HPROPSHEETPAGE CComputerMsmqDataObject::CreateSitesPage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    PROPVARIANT propVar;
    PROPID pid;

    //
    // Retrieve the service in order to pass TRUE for server and FALSE 
    // for client to CComputerMsmqSites.
    //
    pid = PROPID_QM_SERVICE;
    VERIFY(m_propMap.Lookup(pid, propVar));

    //
    // Note: CComputerMsmqSites is auto-delete by default
    //
    CComputerMsmqSites *pcpageSites = new CComputerMsmqSites(propVar.ulVal != SERVICE_NONE);
    pcpageSites->m_strMsmqName = m_strMsmqPath;
    pcpageSites->m_strDomainController = m_strDomainController;

    //
    // PROPID_QM_SITE_IDS
    //
    pid = PROPID_QM_SITE_IDS;
    VERIFY(m_propMap.Lookup(pid, propVar));

    //
    // Sets m_aguidSites from CACLSID
    //
    CACLSID const *pcaclsid = &propVar.cauuid;
    for (DWORD i=0; i<pcaclsid->cElems; i++)
    {
        pcpageSites->m_aguidSites.SetAtGrow(i,((GUID *)pcaclsid->pElems)[i]);
    }

    //
    // PROPID_QM_FOREIGN
    //
    pid = PROPID_QM_FOREIGN;
    VERIFY(m_propMap.Lookup(pid, propVar));
    pcpageSites->m_fForeign = propVar.bVal;

    return pcpageSites->CreateThemedPropertySheetPage();
}

    
//
// IContextMenu
//
STDMETHODIMP CComputerMsmqDataObject::QueryContextMenu(
    HMENU hmenu, 
    UINT indexMenu, 
    UINT idCmdFirst, 
    UINT /*idCmdLast*/, 
    UINT /*uFlags*/)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString strMqPingMenuEntry;
    strMqPingMenuEntry.LoadString(IDS_MQPING);

    InsertMenu(hmenu,
         indexMenu, 
         MF_BYPOSITION|MF_STRING,
         idCmdFirst + mneMqPing,
         strMqPingMenuEntry);

    return 1;
}


STDMETHODIMP CComputerMsmqDataObject::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    switch((INT_PTR)lpici->lpVerb)
    {
        case mneMqPing:
        {
            GUID *pguid = GetGuid();
            if (pguid)
            {
                MQPing(*pguid);
            }
        }
    }

    return S_OK;
}


HRESULT CComputerMsmqDataObject::EnableQueryWindowFields(HWND /*hwnd*/, BOOL /*fEnable*/)
{
    return E_NOTIMPL;
}


void CComputerMsmqDataObject::ClearQueryWindowFields(HWND /*hwnd*/)
{
}


HRESULT CComputerMsmqDataObject::GetQueryParams(HWND /*hWnd*/, LPDSQUERYPARAMS* /*ppDsQueryParams*/)
{
    return E_NOTIMPL ;
}


STDMETHODIMP CComputerMsmqDataObject::AddPages(THIS_ LPCQADDPAGESPROC /*pAddPagesProc*/, LPARAM /*lParam*/)
{
    return E_NOTIMPL;
}


//
// CComputerMsmqDataObject::GetGuid
//
GUID *CComputerMsmqDataObject::GetGuid()
{
  	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (m_guid == GUID_NULL)
    {
        //
        // Get the GUID from the DS
        //
        PROPID pid = PROPID_QM_MACHINE_ID;
        PROPVARIANT pvar;
        pvar.vt = VT_NULL;        
        HRESULT hr = ADGetObjectProperties(
                            eMACHINE,
                            GetDomainController(m_strDomainController),
							true,	// fServerName
                            m_strMsmqPath, 
                            1, 
                            &pid, 
                            &pvar
                            );

        if FAILED(hr)
        {
            MessageDSError(hr, IDS_OP_GET_PROPERTIES_OF, m_strMsmqPath);
            return 0;
        }
        m_guid = *pvar.puuid;
        MQFreeMemory(pvar.puuid);
    }
    return &m_guid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\msmqlink.cpp ===
// MsmqLink.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "mqppage.h"
#include "MsmqLink.h"
#include "dsext.h"

#include "msmqlink.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// CSiteInfo Implementation
//
inline
CSiteInfo::CSiteInfo(
    GUID* pSiteId,
    LPWSTR pSiteName
    ) :
    m_SiteId(*pSiteId),
    m_SiteName(pSiteName)
{
}

CSiteInfo::~CSiteInfo()
{
}

inline
LPCWSTR 
CSiteInfo::GetSiteName(
    void
    )
{
    return m_SiteName;
}

inline
const
GUID*
CSiteInfo::GetSiteId(
    void
    ) const
{
    return &m_SiteId;
}

/////////////////////////////////////////////////////////////////////////////
// CMsmqLink dialog

void
CMsmqLink::CheckLinkValidityAndForeignExistance (    
    CDataExchange* pDX
	)
/*++
Routine Description:
    The routine checks the validity of the site link, after the individual parameters
    were validated already (no NULL siteID or zero cost). It makes sure that the
    site link does not connect two foreign site, and that a site gate exists whenever
    a foreign site is part of the link.

Arguments:
    None.

Returned Value:
    TRUE - valid, FALSE - invalid

--*/
{
    ASSERT(m_FirstSiteId != NULL);
    ASSERT(m_SecondSiteId != NULL);

    BOOL fFirstForeign, fSecondForeign;

    HRESULT hr = GetSiteForeignFlag(m_FirstSiteId, &fFirstForeign, false, m_strDomainController);
    if FAILED(hr)
    //
    // Apparently, no DS connection. A message was already displayed
    //
    {
        pDX->Fail();
    }

    hr = GetSiteForeignFlag(m_SecondSiteId, &fSecondForeign, false, m_strDomainController);
    if FAILED(hr)
    {
        pDX->Fail();
    }


    //
    // It is illegal to create site link between two foreign sites
    //
    if (fFirstForeign && fSecondForeign)
    {
        AfxMessageBox(IDS_BOTH_SITES_ARE_FOREIGN);
        pDX->Fail();
    }

    //
    // If at least one site is a foreign site, the final message should 
    // tell the user to add site gates.
    //
    if (fFirstForeign || fSecondForeign)
    {
        m_fThereAreForeignSites = TRUE;
    }
    else
    {
        m_fThereAreForeignSites = FALSE;
    }
}

HRESULT
CMsmqLink::CreateSiteLink (
    void
	)
/*++
Routine Description:
    The routine create a Site Link object in the DS. The routine is called OnOk
    after the sites ids and the cost were retrieved and the site gates array 
    was initialized.

Arguments:
    None.

Returned Value:
    the operation result

--*/
{
    ASSERT(m_FirstSiteId != NULL);
    ASSERT(m_SecondSiteId != NULL);
    ASSERT(m_dwLinkCost > 0);

    //
    // Build the description
    //
    CString strLinkDescription;

    strLinkDescription.FormatMessage(IDS_LINK_DESCRIPTION, m_strFirstSite, m_strSecondSite);

    //
    // Prepare the properties for DS call.
    //
    PROPID paPropid[] = { 
                PROPID_L_NEIGHBOR1, 
                PROPID_L_NEIGHBOR2,
                PROPID_L_ACTUAL_COST,
                PROPID_L_DESCRIPTION
                };

	const DWORD x_iPropCount = sizeof(paPropid) / sizeof(paPropid[0]);
	PROPVARIANT apVar[x_iPropCount];
    DWORD iProperty = 0;


    ASSERT(paPropid[iProperty] == PROPID_L_NEIGHBOR1);    //PropId
    apVar[iProperty].vt = VT_CLSID;          //Type
    apVar[iProperty].puuid = const_cast<GUID*>(m_FirstSiteId);
    ++iProperty;

	ASSERT(paPropid[iProperty] == PROPID_L_NEIGHBOR2);    //PropId
    apVar[iProperty].vt = VT_CLSID;          //Type
    apVar[iProperty].puuid = const_cast<GUID*>(m_SecondSiteId);
    ++iProperty;

	ASSERT(paPropid[iProperty] == PROPID_L_ACTUAL_COST);    //PropId
    apVar[iProperty].vt = VT_UI4;       //Type
    apVar[iProperty].ulVal =  m_dwLinkCost;
    ++iProperty;

	ASSERT(paPropid[iProperty] == PROPID_L_DESCRIPTION);    //PropId
    apVar[iProperty].vt = VT_LPWSTR;       //Type
    apVar[iProperty].pwszVal =  (LPWSTR)((LPCWSTR)strLinkDescription);
    ++iProperty;

    GUID SiteLinkId;  
    HRESULT hr = ADCreateObject(
                    eROUTINGLINK,
                    GetDomainController(m_strDomainController),
					true,	    // fServerName
                    NULL, //pwcsObjectName
                    NULL, //pSecurityDescriptor,
                    iProperty,
                    paPropid,
                    apVar,
                    &SiteLinkId
                    );

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Get the New object Full path name
    //
    PROPID x_paPropid[] = {PROPID_L_FULL_PATH};
    PROPVARIANT var[1];
    var[0].vt = VT_NULL;
    
    hr = ADGetObjectPropertiesGuid(
                eROUTINGLINK,
                GetDomainController(m_strDomainController),
				true,	// fServerName
                &SiteLinkId,
                1, 
                x_paPropid,
                var
                );

    if (SUCCEEDED(hr))
    {
        m_SiteLinkFullPath = var[0].pwszVal;
        MQFreeMemory(var[0].pwszVal);
    }
    else
    {
        //
        // Site link was created, but does not exist in the DS.
        // Reason not clear (QM failed? Switched DC?)
        //
        ASSERT(0);
        AfxMessageBox(IDS_CREATED_CLICK_REFRESH);
    }

    return MQ_OK;

}


HRESULT
CMsmqLink::InitializeSiteInfo(
    void
    )
/*++
Routine description:
    The routine retreives information about the site from the DS
    and initializes internal data structure

Arguments:
    None.

Returned value:
    operation result

--*/
{
    HRESULT rc = MQ_OK;

    //
    // Get the site name and ID from DS
    //
    PROPID aPropId[] = {
        PROPID_S_SITEID, 
        PROPID_S_PATHNAME
        };

	const DWORD x_nProps = sizeof(aPropId) / sizeof(aPropId[0]);
    CColumns AttributeColumns;

	for (DWORD i=0; i<x_nProps; i++)
	{
		AttributeColumns.Add(aPropId[i]);
	}   
    
    HANDLE hEnume;
    HRESULT hr;
    {
        CWaitCursor wc; //display wait cursor while query DS        
        hr = ADQueryAllSites(
                    GetDomainController(m_strDomainController),
					true,		// fServerName
                    AttributeColumns.CastToStruct(),
                    &hEnume
                    );        
    }

    DSLookup dslookup(hEnume, hr);

    if (!dslookup.HasValidHandle())
    {
        return MQ_ERROR;
    }

    //
    // Get the site properties
    //
    PROPVARIANT result[x_nProps*3];
    DWORD dwPropCount = sizeof(result) /sizeof(result[0]);

    rc = dslookup.Next(&dwPropCount, result);

    while (SUCCEEDED(rc) && (dwPropCount != 0))
    {
        for (DWORD i =0; i < dwPropCount; i += AttributeColumns.Count())
        {
            CSiteInfo* p = new CSiteInfo(result[i].puuid, result[i+1].pwszVal);
            MQFreeMemory(result[i].puuid);
            MQFreeMemory(result[i+1].pwszVal);

            m_SiteInfoArray.SetAtGrow(m_SiteNumber, p);
            ++m_SiteNumber;
        }
        rc = dslookup.Next(&dwPropCount, result);
    }

    return rc;

}

CMsmqLink::CMsmqLink(
	const CString& strDomainController,
	const CString& strContainerPathDispFormat
	) : 
	CMqPropertyPage(CMsmqLink::IDD),
	m_strDomainController(strDomainController),
	m_strContainerPathDispFormat(strContainerPathDispFormat)
{
	//{{AFX_DATA_INIT(CMsmqLink)
	m_dwLinkCost = 0;
	m_strFirstSite = _T("");
	m_strSecondSite = _T("");
	//}}AFX_DATA_INIT

    //
    // Set the array size to 10
    //
    m_SiteInfoArray.SetSize(10);
    m_SiteNumber = 0;

    m_FirstSiteSelected = FALSE;
    m_SecondSiteSelected = FALSE;

    //
    // set pointer to combox to NULL
    //
    m_pFirstSiteCombo = NULL;
    m_pSecondSiteCombo = NULL;

    m_FirstSiteId = NULL;
    m_SecondSiteId = NULL;
}


CMsmqLink::~CMsmqLink()
{
    //
    // delete the site info
    //
    for(DWORD i = 0; i < m_SiteNumber; ++i)
    {
        delete  m_SiteInfoArray[i];
    }
    m_SiteInfoArray.RemoveAll();
}


void
CMsmqLink::SetParentPropertySheet(
	CGeneralPropertySheet* pPropertySheet
	)
{
	m_pParentSheet = pPropertySheet;
}


void CMsmqLink::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);


	//{{AFX_DATA_MAP(CMsmqLink)
	DDX_Text(pDX, IDC_LINK_COST_EDIT, m_dwLinkCost);
	DDV_MinMaxDWord(pDX, m_dwLinkCost, 1, MQ_MAX_LINK_COST);
	DDX_CBString(pDX, IDC_FIRST_SITE_COMBO, m_strFirstSite);
	DDV_NotEmpty(pDX, m_strFirstSite, IDS_MISSING_SITE_NAME);
	DDX_CBString(pDX, IDC_SECOND_SITE_COMBO, m_strSecondSite);
	DDV_NotEmpty(pDX, m_strSecondSite, IDS_MISSING_SITE_NAME);
	//}}AFX_DATA_MAP

    DWORD_PTR Index;
    int iSelected;

    //
    // Get First Site ID
    //
    VERIFY(CB_ERR != (iSelected = m_pFirstSiteCombo->GetCurSel()));
    VERIFY(CB_ERR != (Index = m_pFirstSiteCombo->GetItemData(iSelected)));
    m_FirstSiteId = m_SiteInfoArray[Index]->GetSiteId();

    //
    // Get Second Site ID
    //
    VERIFY(CB_ERR != (iSelected = m_pSecondSiteCombo->GetCurSel()));
    VERIFY(CB_ERR != (Index = m_pSecondSiteCombo->GetItemData(iSelected)));
    m_SecondSiteId = m_SiteInfoArray[Index]->GetSiteId();

    if (pDX->m_bSaveAndValidate)
    {
        if (m_strFirstSite == m_strSecondSite)
        {
            AfxMessageBox(IDS_BOTH_SITES_ARE_SAME);
            pDX->Fail();
        }
        CheckLinkValidityAndForeignExistance(pDX);
    }
}


BEGIN_MESSAGE_MAP(CMsmqLink, CMqPropertyPage)
	//{{AFX_MSG_MAP(CMsmqLink)
	ON_CBN_SELCHANGE(IDC_FIRST_SITE_COMBO, OnSelchangeFirstSiteCombo)
	ON_CBN_SELCHANGE(IDC_SECOND_SITE_COMBO, OnSelchangeSecondSiteCombo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMsmqLink message handlers
BOOL CMsmqLink::OnInitDialog() 
{
	SetDlgItemText(IDC_ROUTING_LINK_CONTAINER, m_strContainerPathDispFormat);
    //
    // This closure is used to keep the DLL state. For UpdateData we need
    // the mmc.exe state.
    //
    {
        HRESULT rc;

        AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
        //
        // Initialize pointer to combox
        //
        m_pFirstSiteCombo = (CComboBox *)GetDlgItem(IDC_FIRST_SITE_COMBO);
        m_pSecondSiteCombo = (CComboBox *)GetDlgItem(IDC_SECOND_SITE_COMBO);

        rc = InitializeSiteInfo();
        if (SUCCEEDED(rc))
        {
            //
            // Initialize the Site name combo boxes
            //
            for (DWORD i = 0; i < m_SiteNumber; ++i)
            {
                CString SiteName(m_SiteInfoArray[i]->GetSiteName());
                int iNewItem;

                VERIFY(CB_ERR != (iNewItem = m_pFirstSiteCombo->AddString(SiteName)));
                VERIFY(CB_ERR != m_pFirstSiteCombo->SetItemData(iNewItem, i));

                VERIFY(CB_ERR != (iNewItem = m_pSecondSiteCombo->AddString(SiteName)));
                VERIFY(CB_ERR != m_pSecondSiteCombo->SetItemData(iNewItem, i));
            }
        }
    }	

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}



void CMsmqLink::OnSelchangeFirstSiteCombo() 
{
    int FirstSiteIndex = m_pFirstSiteCombo->GetCurSel();
    ASSERT(FirstSiteIndex != CB_ERR);

    if (m_SecondSiteSelected &&
        m_pSecondSiteCombo->GetCurSel() == FirstSiteIndex)
    {
        AfxMessageBox(IDS_BOTH_SITES_ARE_SAME);
        m_FirstSiteSelected = FALSE;
        return;
    }

    m_FirstSiteSelected = TRUE;
    
}

void CMsmqLink::OnSelchangeSecondSiteCombo() 
{
    int SecondSiteIndex = m_pSecondSiteCombo->GetCurSel();
    ASSERT(SecondSiteIndex != CB_ERR);

    if (m_FirstSiteSelected &&
        m_pFirstSiteCombo->GetCurSel() == SecondSiteIndex)
    {
        AfxMessageBox(IDS_BOTH_SITES_ARE_SAME);
        m_SecondSiteSelected = FALSE;
        return;
    }

    m_SecondSiteSelected = TRUE;
}


BOOL CMsmqLink::OnWizardFinish() 
{
    //
    // Call DoDataExchange
    //
    if (!UpdateData(TRUE))
    {
        return FALSE;
    }

    //
    // Create Site link in the DS
    //
    HRESULT rc = CreateSiteLink();
    if(FAILED(rc))
    {
        CString strSiteLink;
        strSiteLink.LoadString(IDS_SITE_LINK);

        MessageDSError(rc, IDS_OP_CREATE, strSiteLink);
        return FALSE;
    }

    //
    // Display a warning in case of foreign site existance
    //
    if (m_fThereAreForeignSites)
    {
        AfxMessageBox(IDS_WARN_ABOUT_FOREIGN_SITES, MB_ICONINFORMATION);
    }


    return CMqPropertyPage::OnWizardFinish();
}


BOOL CMsmqLink::OnSetActive() 
{
	ASSERT((L"No parent property sheet", m_pParentSheet != NULL));
	return m_pParentSheet->SetWizardButtons();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\newrule.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	trigger.cpp

Abstract:
	Implementation for the trigger Local administration

Author:
    Uri Habusha (urih), 25-Jun-2000

--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"

#import "mqtrig.tlb" no_namespace

#include "mqppage.h"
#include "ruledef.h"
#include "rulecond.h"
#include "ruleact.h"
#include "newrule.h"

#include "newrule.tmh"


CNewRule::CNewRule(CRuleSet* pRuleSet) :
    CPropertySheetEx(IDS_NEW_RULE_CAPTION, 0, 0, NULL, 0, NULL),
    m_pRuleSet(SafeAddRef(pRuleSet)),
    m_newRule(NULL)
{	
    m_pGeneral = new CNewRuleGeneral(this);
    AddPage(m_pGeneral);

    m_pCondition = new CRuleCondition(this);
    AddPage(m_pCondition);

    m_pAction = new CRuleAction(this);
    AddPage(m_pAction);

    //
    // Establish a property page as a wizard
    //
    SetWizardMode();
}

    
CNewRule::~CNewRule()
{
}


BOOL CNewRule::SetWizardButtons()
{
    if (GetActiveIndex() == 0)
	{
        //
		//first page
        //
        CPropertySheetEx::SetWizardButtons(PSWIZB_NEXT);
        return TRUE;
	}

    if (GetActiveIndex() == GetPageCount() - 1)
	{
        //
		//last page
        //
		CPropertySheetEx::SetWizardButtons(PSWIZB_BACK |PSWIZB_FINISH );
        return TRUE;
	}

    CPropertySheetEx::SetWizardButtons(PSWIZB_BACK |PSWIZB_NEXT );
    return TRUE;
}


void CNewRule::OnFinishCreateRule(void) throw (_com_error)
{
    _bstr_t name = static_cast<LPCTSTR>(m_pGeneral->m_ruleName);
    _bstr_t description = static_cast<LPCTSTR>(m_pGeneral->m_ruleDescription);
    _bstr_t condition = static_cast<LPCTSTR>(m_pCondition->GetCondition());
    _bstr_t action = static_cast<LPCTSTR>(m_pAction->GetAction());
    long fShowWindow = m_pAction->m_fShowWindow;

    m_newRule = m_pRuleSet->AddRule(
                              name, 
                              description, 
                              condition,
                              action, 
                              fShowWindow
                              );
}


HBITMAP CNewRule::GetHbmWatermark()
{
    return NULL;
}


HBITMAP CNewRule::GetHbmHeader()
{
    return NULL;
}

void CNewRule::initHtmlHelpString()
{	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\newalias.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    newalias.cpp

Abstract:

    New alias queue implementation file

Author:

    Tatiana Shubin

--*/

#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "mqppage.h"
#include "newalias.h"
#include "adsutil.h"

#include "newalias.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewAlias dialog

HRESULT
CNewAlias::CreateNewAlias (
    void
	)
/*++
Routine Description:
    The routine create an Alias Queue object in the DS.

Arguments:
    None.

Returned Value:
    the operation result

--*/
{    
    ASSERT(!m_strPathName.IsEmpty());
    ASSERT(!m_strContainerPath.IsEmpty());
    ASSERT(!m_strFormatName.IsEmpty());
    
    CAdsUtil AdsUtil (m_strContainerPath, m_strPathName, m_strFormatName);
    HRESULT hr = AdsUtil.CreateAliasObject(&m_strAliasFullPath);
    
    if (FAILED(hr))
    {        
        return hr;
    }
  
    return MQ_OK;

}

CNewAlias::CNewAlias()
	: CMqPropertyPage(CNewAlias::IDD)
{
	//{{AFX_DATA_INIT(CNewAlias)
	m_strPathName = _T("");
    m_strFormatName = _T("");
	//}}AFX_DATA_INIT    
}

CNewAlias::CNewAlias(
	CString strContainerPath, 
	CString strContainerPathDispFormat
	) : CMqPropertyPage(CNewAlias::IDD)
{
	//{{AFX_DATA_INIT(CNewAlias)
	m_strPathName = _T("");
    m_strFormatName = _T("");
	//}}AFX_DATA_INIT    
	m_strContainerPath = strContainerPath;
	m_strContainerPathDispFormat = strContainerPathDispFormat;
}


CNewAlias::~CNewAlias()
{
	m_pParentSheet = NULL;
}

void
CNewAlias::SetParentPropertySheet(
	CGeneralPropertySheet* pPropertySheet
	)
{
	m_pParentSheet = pPropertySheet;
}

void CNewAlias::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);


	//{{AFX_DATA_MAP(CNewAlias)
    DDX_Text(pDX, IDC_NEWALIAS_PATHNAME, m_strPathName);
    DDX_Text(pDX, IDC_NEWALIAS_FORMATNAME, m_strFormatName);		
    DDV_NotEmpty(pDX, m_strPathName, IDS_MISSING_ALIAS_NAME);
    DDV_NotEmpty(pDX, m_strFormatName, IDS_MISSING_ALIAS_FORMATNAME);
	DDV_ValidFormatName(pDX, m_strFormatName);
	//}}AFX_DATA_MAP
       
}


BEGIN_MESSAGE_MAP(CNewAlias, CMqPropertyPage)
	//{{AFX_MSG_MAP(CNewAlias)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CNewAlias::OnInitDialog() 
{
	CMqPropertyPage::OnInitDialog();
	
	SetDlgItemText(IDC_ALIAS_CONTAINER, m_strContainerPathDispFormat);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CNewAlias message handlers

BOOL CNewAlias::OnWizardFinish() 
{
    //
    // Call DoDataExchange
    //
    if (!UpdateData(TRUE))
    {
        return FALSE;
    }

    //
    // Create alias queue in the DS
    //
    m_hr = CreateNewAlias();
    if(FAILED(m_hr))
    {
        CString strNewAlias;
        strNewAlias.LoadString(IDS_ALIAS);

        MessageDSError(m_hr, IDS_OP_CREATE, strNewAlias);
        return FALSE;        
    }    

    return CMqPropertyPage::OnWizardFinish();
}


BOOL CNewAlias::OnSetActive() 
{
	ASSERT((L"No parent property sheet", m_pParentSheet != NULL));
	return m_pParentSheet->SetWizardButtons();
}


HRESULT CNewAlias::GetStatus()
{
    return m_hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\newrule.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    newrule.h

Abstract:
	Definition for the new rule property sheet

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __NEWRULE_H__
#define __NEWRULE_H__

class CRuleGeneral;
class CRuleCondition;
class CRuleAction;

class CNewRule : public CPropertySheetEx
{
public:
	CNewRule(CRuleSet* pRuleSet);
    ~CNewRule();

    BOOL SetWizardButtons();

    void OnFinishCreateRule(void) throw (_com_error);

    R<CRule> GetRule()
    {
        return m_newRule;
    }

	// Generated message map functions
protected:
	void initHtmlHelpString();
	static HBITMAP GetHbmHeader();
	static HBITMAP GetHbmWatermark();

private:
    R<CRuleSet> m_pRuleSet;
    HICON m_hIcon;

    CRuleGeneral* m_pGeneral;
    CRuleCondition* m_pCondition;
    CRuleAction* m_pAction;

    R<CRule> m_newRule;
};

#endif //__NEWRULE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\newalias.h ===
#if !defined(AFX_NEWALIAS_H__2E4B37AC_CC8B_11D1_9C85_006008764D0E__INCLUDED_)
#define AFX_NEWALIAS_H__2E4B37AC_CC8B_11D1_9C85_006008764D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// newalias.h : header file
//

#include "resource.h"

class CGeneralPropertySheet;

/////////////////////////////////////////////////////////////////////////////
// CNewAlias dialog

class CNewAlias : public CMqPropertyPage
{
// Construction
public:
	CNewAlias();   // standard constructor
    CNewAlias(CString strContainerPath, CString strContainerPathDispFormat);   
    ~CNewAlias();

    HRESULT
    CreateNewAlias (
        void
	    );

    LPCWSTR 
    GetAliasFullPath(
       void
       );

    HRESULT 
    GetStatus(
        void
        );

	void
	SetParentPropertySheet(
		CGeneralPropertySheet* pPropertySheet
		);

    // Dialog Data
	//{{AFX_DATA(CNewAlias)
	enum { IDD = IDD_NEW_ALIAS };	
	CString	m_strPathName;
	CString	m_strFormatName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewAlias)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewAlias)
	virtual BOOL OnWizardFinish();
    virtual BOOL OnInitDialog();
	virtual BOOL OnSetActive();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:

    CString m_strAliasFullPath;
    CString m_strContainerPath;
	CString m_strContainerPathDispFormat;
    HRESULT m_hr;
	CGeneralPropertySheet* m_pParentSheet;
};


inline
LPCWSTR 
CNewAlias::GetAliasFullPath(
   void
   )
{
    return m_strAliasFullPath;
}

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWALIAS_H__2E4B37AC_CC8B_11D1_9C85_006008764D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\newtrig.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    newtrig.h

Abstract:
	Definition for the new trigger property sheet

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __NEWTRIGGER_H__
#define __NEWTRIGGER_H__

class CAttachedRule;
class CTriggerProp;

class CNewTrigger : public CPropertySheetEx
{
public:
	CNewTrigger(
        CTriggerSet* pTrigSet,
        CRuleSet* pRuleSet,
        LPCTSTR queueName
        );

     ~CNewTrigger();

    BOOL SetWizardButtons();

    void OnFinishCreateTrigger(void) throw (_com_error);

    RuleList GetRuleList()
    {
        return m_pRuleSet->GetRuleList();
    }

	// Generated message map functions
protected:
	void initHtmlHelpString();
	static HBITMAP GetHbmHeader();
	static HBITMAP GetHbmWatermark();

private:
    R<CTriggerSet> m_pTriggerSet;
    R<CRuleSet> m_pRuleSet;

    CTriggerProp* m_pGeneral;
    CAttachedRule* m_pAttachRule;
};

#endif //__NEWTRIGGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\newtrig.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	trigger.cpp

Abstract:
	Implementation for the trigger Local administration

Author:
    Uri Habusha (urih), 25-Jun-2000

--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "mqppage.h"

#import "mqtrig.tlb" no_namespace

#include "rule.h"
#include "trigger.h"
#include "newtrig.h"
#include "trigprop.h"

#include "newtrig.tmh"


CNewTrigger::CNewTrigger(
    CTriggerSet* pTrigSet,
    CRuleSet* pRuleSet,
    LPCTSTR queueName
    ) :
    CPropertySheetEx(IDS_NEW_TRIGGER_CAPTION, 0, 0, NULL, 0, NULL),
    m_pTriggerSet(SafeAddRef(pTrigSet)),
    m_pRuleSet(SafeAddRef(pRuleSet))
{	
    m_pGeneral = new CNewTriggerProp(this, queueName);
    AddPage(m_pGeneral);


    m_pAttachRule = new CAttachedRule(this);
    AddPage(m_pAttachRule);

    //
    // Use help
    m_psh.dwFlags |= PSP_HASHELP;

    //
    // Establish a property page as a wizard
    //
    SetWizardMode();
}

    
CNewTrigger::~CNewTrigger()
{
}


BOOL CNewTrigger::SetWizardButtons()
{
    if (GetActiveIndex() == 0)
	{
        //
		//first page
        //
        CPropertySheetEx::SetWizardButtons(PSWIZB_NEXT);
        return TRUE;
	}

    if (GetActiveIndex() == GetPageCount() - 1)
	{
        //
		//last page
        //
		CPropertySheetEx::SetWizardButtons(PSWIZB_BACK |PSWIZB_FINISH );
        return TRUE;
	}

    CPropertySheetEx::SetWizardButtons(PSWIZB_BACK |PSWIZB_NEXT );
    return TRUE;
}


void CNewTrigger::OnFinishCreateTrigger(void) throw (_com_error)
{
    _bstr_t name = static_cast<LPCTSTR>(m_pGeneral->m_triggerName);
    _bstr_t queuePathName = static_cast<LPCTSTR>(m_pGeneral->m_queuePathName);
    SystemQueueIdentifier queueType = m_pGeneral->m_queueType;
    long fEnabled = m_pGeneral->m_fEnabled;
    long fSerialized = m_pGeneral->m_fSerialized;
	MsgProcessingType msgProcType = m_pGeneral->m_msgProcType;

    R<CTrigger> pTrig = m_pTriggerSet->AddTrigger(
                                          name, 
                                          queuePathName, 
                                          queueType,
                                          fEnabled, 
                                          fSerialized,
										  msgProcType
                                          );


    pTrig->UpdateAttachedRules(m_pAttachRule->GetAttachedRules());
}


HBITMAP CNewTrigger::GetHbmWatermark()
{
    return NULL;
}


HBITMAP CNewTrigger::GetHbmHeader()
{
    return NULL;
}

void CNewTrigger ::initHtmlHelpString()
{	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\privadm.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	localadm.h

Abstract:

	Definition for the Private queues administration
Author:

    YoelA


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __PRIVADM_H_
#define __PRIVADM_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"
#include "msmqdobj.h"
#include "sysq.h"

#include "icons.h"

/****************************************************

        CLocalPrivateFolder Class
    
 ****************************************************/

class CLocalPrivateFolder : public CLocalQueuesFolder<CLocalPrivateFolder>
{
public:
   	BEGIN_SNAPINCOMMAND_MAP(CLocalPrivateFolder, FALSE)
		SNAPINCOMMAND_ENTRY(ID_MENUITEM_NEW_PRIVATE_QUEUE, OnNewPrivateQueue)
	END_SNAPINCOMMAND_MAP()

	UINT GetMenuID()
    {
        if (m_fOnLocalMachine)
        {
            //
            // Admin on local machine
            //
            return IDR_LOCALPRIVATE_MENU;
        }
        else
        {
            return IDR_REMOTEPRIVATE_MENU;
        }
    }


    CLocalPrivateFolder(CSnapInItem * pParentNode, CSnapin * pComponentData,
                        CString &strMachineName, LPCTSTR strDisplayName) : 
             CLocalQueuesFolder<CLocalPrivateFolder>(pParentNode, pComponentData, strMachineName, strDisplayName)
    {
        SetIcons(IMAGE_PRIVATE_FOLDER_CLOSE, IMAGE_PRIVATE_FOLDER_OPEN);
    }

	~CLocalPrivateFolder()
	{
	}

    virtual const PropertyDisplayItem *GetDisplayList();
    virtual const DWORD         GetNumDisplayProps();

protected:
	virtual HRESULT PopulateScopeChildrenList();
    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);
    HRESULT OnNewPrivateQueue(bool & bHandled, CSnapInObjectRootBase * pSnapInObjectRoot);
    HRESULT AddPrivateQueueToScope(CString &szPathName);
    HRESULT GetPrivateQueueQMProperties(CString &szPathName, PROPID *aPropId, PROPVARIANT *aPropVar, CString &strFormatName);
    HRESULT GetPrivateQueueMGMTProperties(DWORD dwNumProperties, PROPID *aPropId, PROPVARIANT *aPropVar, CString &strFormatName, const PropertyDisplayItem *aDisplayList);
};

//
// Persistency functions
//
HRESULT PrivateQueueDataSave(IStream* pStream);
HRESULT PrivateQueueDataLoad(IStream* pStream);
DWORD PrivateQueueDataSize(void);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\privadm.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	privadm.cpp

Abstract:
	Implementation for the private queues administration

Author:

    YoelA


--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "rt.h"
#include "dsext.h"
#include "qnmsprov.h"
#include "localfld.h"
#include "localq.h"
#include "privadm.h"
#include "rdmsg.h"
#include "SnpQueue.h"
#include "snpnerr.h"
#include "strconv.h"
#include "mqPPage.h"
#include "qname.h"
#include "ldaputl.h"

#include "privadm.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/****************************************************

        CLocalPrivateFolder Class
    
 ****************************************************/
/////////////////////////////////////////////////////////////////////////////
// CLocalPrivateFolder
// {7198f3d8-4baf-11d2-8292-006094eb6406}
static const GUID CLocalPrivateFolderGUID_NODETYPE = 
{ 0x7198f3d8, 0x4baf, 0x11d2, { 0x82, 0x92, 0x0, 0x60, 0x94, 0xeb, 0x64, 0x6 } };

const GUID*  CLocalPrivateFolder::m_NODETYPE = &CLocalPrivateFolderGUID_NODETYPE;
const OLECHAR* CLocalPrivateFolder::m_SZNODETYPE = OLESTR("7198f3d8-4baf-11d2-8292-006094eb6406");
const OLECHAR* CLocalPrivateFolder::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CLocalPrivateFolder::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;

//------------------------------------------------
//
// Table of private queue properties
//
//------------------------------------------------
static void CALLBACK DisplayPrivacyToString(const PROPVARIANT *pPropVar, CString &str)
{
   ASSERT(pPropVar->vt == VT_UI4);
   str = PrivacyToString(pPropVar->ulVal);
}

const PropertyDisplayItem PrivateQueueMQDisplayList[] = {
    // String         |  Property    ID              | VT Handler   | Display                    |Field   |Len|Width        |Sort
    // Resource       |                              |              | function                   |Offset  |   |             |    
    //----------------+------------------------------+--------------+----------------------------+--------+---+-------------+----
	{ IDS_Q_PATHNAME,   PROPID_Q_PATHNAME,              &g_VTLPWSTR,  QueuePathnameToName,        NO_OFFSET, 0, 200,         NULL},
	{ IDS_Q_LABEL,      PROPID_Q_LABEL,                 &g_VTLPWSTR,  NULL,                       NO_OFFSET, 0, 200,         NULL},
	{ IDS_Q_QUOTA,      PROPID_Q_QUOTA,                 &g_VTUI4,     QuotaToString,              NO_OFFSET, 0, HIDE_COLUMN, NULL},
    { IDS_Q_TRANSACTION,PROPID_Q_TRANSACTION,           &g_VTUI1,     BoolToString,               NO_OFFSET, 0, HIDE_COLUMN, SortByString},
    { IDS_Q_TYPE,       PROPID_Q_TYPE,                  &g_VTCLSID,   NULL,                       NO_OFFSET, 0, HIDE_COLUMN, SortByString},
    { IDS_Q_AUTHENTICATE,PROPID_Q_AUTHENTICATE,         &g_VTUI1,     BoolToString,               NO_OFFSET, 0, HIDE_COLUMN, SortByString},
    { IDS_Q_JOURNAL,    PROPID_Q_JOURNAL,               &g_VTUI1,     BoolToString,               NO_OFFSET, 0, HIDE_COLUMN, SortByString},
	{ IDS_Q_JOURNAL_QUOTA,PROPID_Q_JOURNAL_QUOTA,       &g_VTUI4,     QuotaToString,              NO_OFFSET, 0, HIDE_COLUMN, NULL},
	{ IDS_Q_PRIV_LEVEL, PROPID_Q_PRIV_LEVEL,            &g_VTUI4,     DisplayPrivacyToString,     NO_OFFSET, 0, HIDE_COLUMN, NULL},
    {0,                 0,                              NULL }
};

static const DWORD x_dwNumPrivateQueueMQDisplayProps = 
    ((sizeof(PrivateQueueMQDisplayList)/sizeof(PrivateQueueMQDisplayList[0])) - 1);

const PropertyDisplayItem PrivateQueueMGMTDisplayList[] = {
    // String         |  Property    ID              | VT Handler   | Display                    |Field   |Len|Width         |Sort
    // Resource       |                              |              | function                   |Offset  |   |              |    
    //----------------+------------------------------+--------------+----------------------------+--------+---+--------------+----
    { IDS_LQ_MSGCOUNT,  PROPID_MGMT_QUEUE_MESSAGE_COUNT,&g_VTUI4,     NULL,                       NO_OFFSET, 0,  50,          NULL},   
	{ IDS_LQ_USEDQUOTA, PROPID_MGMT_QUEUE_USED_QUOTA,   &g_VTUI4,     NULL,                       NO_OFFSET, 0,  HIDE_COLUMN, NULL},   
	{ IDS_LQ_JMSGCOUNT, PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT,   &g_VTUI4,    NULL,             NO_OFFSET, 0,  HIDE_COLUMN, NULL},
	{ IDS_LQ_JUSEDQUOTA,PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA,      &g_VTUI4,    NULL,             NO_OFFSET, 0,  HIDE_COLUMN, NULL},   
    {0,                 0,                              NULL }
};

static const DWORD x_dwNumPrivateQueueMGMTDisplayProps = 
    ((sizeof(PrivateQueueMGMTDisplayList)/sizeof(PrivateQueueMGMTDisplayList[0])) - 1);

const PropertyDisplayItem RemotePrivateQueueDisplayList[] = {
    // String         |  Property    ID              | VT Handler   | Display                    |Field   |Len|Width        |Sort
    // Resource       |                              |              | function                   |Offset  |   |             |    
    //----------------+------------------------------+--------------+----------------------------+--------+---+-------------+----
	{ IDS_LQ_PATHNAME,  PROPID_MGMT_QUEUE_PATHNAME,     &g_VTLPWSTR,  QueuePathnameToName,        NO_OFFSET, 0, 200,         NULL},
    { IDS_LQ_MSGCOUNT,  PROPID_MGMT_QUEUE_MESSAGE_COUNT,&g_VTUI4,     NULL,                       NO_OFFSET, 0,  50,         NULL},   
	{ IDS_LQ_USEDQUOTA, PROPID_MGMT_QUEUE_USED_QUOTA,   &g_VTUI4,     NULL,                       NO_OFFSET, 0, HIDE_COLUMN, NULL},   
	{ IDS_LQ_JMSGCOUNT, PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT,   &g_VTUI4,    NULL,             NO_OFFSET, 0, HIDE_COLUMN, NULL},
	{ IDS_LQ_JUSEDQUOTA,PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA,      &g_VTUI4,    NULL,             NO_OFFSET, 0, HIDE_COLUMN, NULL},   
    {0,                 0,                              NULL }
};

static const DWORD x_dwNumRemotePrivateQueueDisplayProps = 
    ((sizeof(RemotePrivateQueueDisplayList)/sizeof(RemotePrivateQueueDisplayList[0])) - 1);

const PropertyDisplayItem *InitPrivateQueueDisplayList()
{
    static PropertyDisplayItem tempPrivateQueueDisplayList[x_dwNumPrivateQueueMQDisplayProps + x_dwNumPrivateQueueMGMTDisplayProps + 1] = {0};
    //
    // First time - initialize
    //
    memcpy(
		tempPrivateQueueDisplayList, 
		PrivateQueueMQDisplayList, 
		x_dwNumPrivateQueueMQDisplayProps * sizeof(PrivateQueueMQDisplayList[0])
		);

    memcpy(
		tempPrivateQueueDisplayList + x_dwNumPrivateQueueMQDisplayProps, 
		PrivateQueueMGMTDisplayList,
		sizeof(PrivateQueueMGMTDisplayList)
		);

    return tempPrivateQueueDisplayList;
}

const PropertyDisplayItem *PrivateQueueDisplayList = InitPrivateQueueDisplayList();



const PropertyDisplayItem *CLocalPrivateFolder::GetDisplayList()
{
    if (m_fOnLocalMachine) 
    {
        return PrivateQueueDisplayList;
    }
    else
    {
        return RemotePrivateQueueDisplayList;
    }
}

const DWORD CLocalPrivateFolder::GetNumDisplayProps()
{
    if (m_fOnLocalMachine) 
    {
        return x_dwNumPrivateQueueMQDisplayProps + x_dwNumPrivateQueueMGMTDisplayProps;
    }
    else
    {
        return x_dwNumRemotePrivateQueueDisplayProps;
    }
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPrivateFolder::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPrivateFolder::PopulateScopeChildrenList()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());


    HRESULT hr = S_OK;
    CString strTitle;

	MQMGMTPROPS	  mqProps;
    PROPVARIANT   propVar;

	//
	// Retreive the private queues of the QM
	//
    PROPID  propId = PROPID_MGMT_MSMQ_PRIVATEQ;
    propVar.vt = VT_NULL;

	mqProps.cProp = 1;
	mqProps.aPropID = &propId;
	mqProps.aPropVar = &propVar;
	mqProps.aStatus = NULL;

    hr = MQMgmtGetInfo((m_szMachineName == TEXT("")) ? (LPCWSTR)NULL : m_szMachineName, MO_MACHINE_TOKEN, &mqProps);

    if(FAILED(hr))
    {
        //
        // If failed, just display a message
        //
        MessageDSError(hr,IDS_NOCONNECTION_TO_SRVICE);
        return(hr);
    }

	ASSERT(propVar.vt == (VT_VECTOR | VT_LPWSTR));
	
	//
	// Sort the queues by their name
	//
	qsort(propVar.calpwstr.pElems, propVar.calpwstr.cElems, sizeof(WCHAR *), QSortCompareQueues);

	//
	// Loop over all private queue and create queue objects
	//
	for (DWORD i = 0; i < propVar.calpwstr.cElems; i++)
    {
        //
		// Get the format name of the private queue
		//
		CString szPathName = propVar.calpwstr.pElems[i];
        MQFreeMemory(propVar.calpwstr.pElems[i]);

        //
        // We add the private queue to the scope WITHOUT checking for errors.
        // Reason: AddPrivateQueueToScope reports its errors to the user, and even if
        // one queue is corrupted for some reason, we still want to display the rest.
        //
        AddPrivateQueueToScope(szPathName);
	
    }

	MQFreeMemory(propVar.calpwstr.pElems);

    return(hr);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPrivateFolder::AddPrivateQueueToScope

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPrivateFolder::AddPrivateQueueToScope(CString &szPathName)
{
    const PropertyDisplayItem *aDisplayList = GetDisplayList();
    CString strFormatName;
    HRESULT hr = S_OK;

    AP<PROPID> aPropId = new PROPID[GetNumDisplayProps()]; 
    AP<PROPVARIANT> aPropVar = new PROPVARIANT[GetNumDisplayProps()];

    //
    // Initialize variant array
    //
    for(DWORD j = 0; j < GetNumDisplayProps(); j++)
    {
	    aPropId[j] = aDisplayList[j].itemPid;
	    aPropVar[j].vt = VT_NULL;
    }

    DWORD dwMgmtPropOffset = 0;
    if (m_fOnLocalMachine) 
    {
        hr = GetPrivateQueueQMProperties(szPathName, aPropId, aPropVar, strFormatName);

        if(FAILED(hr))
        {
            //
            // If failed, put an error node
            //
		    CErrorNode *pErr = new CErrorNode(this, m_pComponentData);
		    CString szErr;

		    MQErrorToMessageString(szErr, hr);
		    pErr->m_bstrDisplayName = szPathName + L" - " + szErr;
	  	    AddChild(pErr, &pErr->m_scopeDataItem);
            return(hr);
        }
        dwMgmtPropOffset = x_dwNumPrivateQueueMQDisplayProps;
    }
    else // Remote queue
    {
        strFormatName.Format(TEXT("%s%s%s%s"), 
                             FN_DIRECT_TOKEN, FN_EQUAL_SIGN, FN_DIRECT_OS_TOKEN,
                             szPathName);
    }

    //
    // Note: We do not check error code from GetPrivateQueueMGMTProperties
    // This is because this function will clear the management properties if
    // the management API call fails
    //
    GetPrivateQueueMGMTProperties(
		GetNumDisplayProps() - dwMgmtPropOffset,
		&aPropId[dwMgmtPropOffset], 
		&aPropVar[dwMgmtPropOffset], 
		strFormatName,
		aDisplayList + dwMgmtPropOffset
		);
    //
    // Create Private queue object
    //
    CPrivateQueue *pQ = new CPrivateQueue(this, GetDisplayList(), GetNumDisplayProps(), m_pComponentData, m_fOnLocalMachine);

    pQ->m_mqProps.cProp    = GetNumDisplayProps();
    pQ->m_mqProps.aPropID  = aPropId;
    pQ->m_mqProps.aPropVar = aPropVar;
    pQ->m_mqProps.aStatus  = NULL;

    pQ->m_szFormatName = strFormatName;
    pQ->m_szPathName   = szPathName;
	pQ->m_szMachineName = m_szMachineName;

    //
    // Extract the queue name only from the full private path name
    //
    CString csName = szPathName;
    CString szUpperName = csName;
    szUpperName.MakeUpper();

    int n = szUpperName.Find(PRIVATE_QUEUE_PATH_INDICATIOR);
    ASSERT(n != -1);

    pQ->m_bstrDisplayName = csName.Mid(n + PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH);

    //
    // Add it to the left pane
    //
    AddChild(pQ, &pQ->m_scopeDataItem);

    //
    // If all is well, do not free propid / propvar - they will be freed when the node
    // is deleted
    //
    aPropId.detach();
    aPropVar.detach();

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPrivateFolder::GetPrivateQueueQMProperties

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPrivateFolder::GetPrivateQueueQMProperties(
            CString &szPathName, 
            PROPID *aPropId, 
            PROPVARIANT *aPropVar, 
            CString &strFormatName)
{
    const x_dwFormatNameMaxSize = 255;
    DWORD dwSize = x_dwFormatNameMaxSize;
    HRESULT hr = MQPathNameToFormatName(szPathName, strFormatName.GetBuffer(x_dwFormatNameMaxSize), &dwSize); 
    strFormatName.ReleaseBuffer();
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Retrieve the queue properties
    //
    MQQUEUEPROPS  mqProps;
	mqProps.cProp    = x_dwNumPrivateQueueMQDisplayProps;   
	mqProps.aPropID  = aPropId; 
	mqProps.aPropVar = aPropVar;
	mqProps.aStatus  = NULL; 

	hr = MQGetQueueProperties(strFormatName, &mqProps);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPrivateFolder::GetPrivateQueueMGMTProperties

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPrivateFolder::GetPrivateQueueMGMTProperties(
            DWORD dwNumProperties,
            PROPID *aPropId, 
            PROPVARIANT *aPropVar, 
            CString &strFormatName,
            const PropertyDisplayItem *aDisplayList)
{
    MQMGMTPROPS  mqQProps;
	mqQProps.cProp    = dwNumProperties;   
	mqQProps.aPropID  = aPropId;
	mqQProps.aPropVar = aPropVar;
	mqQProps.aStatus  = NULL;

    CString szObjectName = L"QUEUE=" + strFormatName;
	HRESULT hr = MQMgmtGetInfo((m_szMachineName == TEXT("")) ? (LPCWSTR)NULL : m_szMachineName, szObjectName, &mqQProps);
    //
    // BugBug - Should check error here, and decide wheather the queue is simply not open 
    // (then display only MQ properties) or something is wrong. This is not done today because
    // the error code when the queue is not opened is MQ_ERROR - not detailed enough
    //
    if FAILED(hr)
    {
        //
        // Clear the properties using the "Clear" function
        //
        for (DWORD i = 0; i < mqQProps.cProp; i++)
        {
            VTHandler       *pvth = aDisplayList[i].pvth;
            pvth->Clear(&mqQProps.aPropVar[i]);
        }
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPrivateFolder::SetVerbs

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPrivateFolder::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hr = S_OK;
    //
    // Display verbs that we support
    //
    hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );

    return(hr);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalPrivateFolder::OnNewPrivateQueue

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalPrivateFolder::OnNewPrivateQueue(bool & bHandled, CSnapInObjectRootBase * /*pSnapInObjectRoot*/)
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
	R<CQueueName> pQueueNameDlg = new CQueueName(m_szMachineName, L"", TRUE);       
	CGeneralPropertySheet propertySheet(pQueueNameDlg.get());
	pQueueNameDlg->SetParentPropertySheet(&propertySheet);

    bHandled = TRUE;

	//
	// We want to use pQueueNameDlg data also after DoModal() exitst
	//
	pQueueNameDlg->AddRef();
    INT_PTR iStatus = propertySheet.DoModal();
    if(iStatus == IDCANCEL || FAILED(pQueueNameDlg->GetStatus()))
    {
        return S_FALSE;
    }

    return AddPrivateQueueToScope(pQueueNameDlg->GetNewQueuePathName());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\privsec.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    privsec.cpp

Abstract:

    Private queue security property page

Author:

    Yoel Arnon (yoela)

--*/
#include "stdafx.h"
#include "ntdsapi.h"
#include "aclui.h"
#include "resource.h"
#include "globals.h"

#include "privsec.tmh"

extern HMODULE g_hResourceMod;

// The following array defines the inheritance types for my containers.
SI_INHERIT_TYPE g_siObjInheritTypes[] =
{
    &GUID_NULL, 0, MAKEINTRESOURCE(IDS_MQ_PRIV_LEVEL_NONE),
};

//
// SetSecurityProp - Utility function - sets the security 
// property in the AD.
//
HRESULT 
SetSecurityProp(
	SECURITY_INFORMATION si,
	PSECURITY_DESCRIPTOR pSD,
	AD_OBJECT            eObject,
	LPCWSTR              pwcsDomainController,
	bool				 fServerName,
	LPCWSTR              pwcsObjectName,
	GUID                *pObjGuid,
	PROPID               pidSecurityProp
	)
{
    ASSERT((NULL != pSD) && IsValidSecurityDescriptor(pSD));

#ifdef _DEBUG
    SECURITY_DESCRIPTOR_CONTROL sdc;

    //
    // Verify that the destination security descriptor answers to all
    // requirements.
    //
    DWORD dwRevision;
    BOOL bRet = GetSecurityDescriptorControl(pSD, &sdc, &dwRevision);
    ASSERT(bRet);

    //
    // Note: It may be OK to get self relative here, although we always got
    //       absolute. Need to see if MakeSelfRelativeSD still returns the right
    //       result. (YoelA, 4/25/2001)
    //
    //
    ASSERT(!(sdc & SE_SELF_RELATIVE));
    ASSERT(dwRevision == SECURITY_DESCRIPTOR_REVISION);
#endif

	AP<BYTE> pSelfRelativeSecDesc;
    DWORD dwSelfRelativeLen = 0;

    //
    // We must convert security descriptor to a self relative one,
    // since it is going to cross process boundaries .
    //

    //
    // Get the length of self relative SD
    //
    BOOL fSuccess = MakeSelfRelativeSD(pSD, 0, &dwSelfRelativeLen);
    ASSERT(FALSE == fSuccess);

    //
    // Alocate buffer and get the actual descriptor
    //
    pSelfRelativeSecDesc = new BYTE[dwSelfRelativeLen];

    if (0==(PVOID)pSelfRelativeSecDesc)
    {
        return E_OUTOFMEMORY;
    }

    fSuccess = MakeSelfRelativeSD(pSD, pSelfRelativeSecDesc, &dwSelfRelativeLen);
    if (FALSE == fSuccess)
    {
        ASSERT(0);
        return E_UNEXPECTED;
    }   

    MQPROPVARIANT var;
    var.vt = VT_BLOB;
    var.blob.cbSize = GetSecurityDescriptorLength( pSelfRelativeSecDesc);
    var.blob.pBlobData = pSelfRelativeSecDesc; 

    HRESULT hr;

    if (NULL == pwcsObjectName)
    {
        ASSERT(NULL != pObjGuid);
        hr = ADSetObjectSecurityGuid(
					eObject,
					pwcsDomainController,
					fServerName,
					pObjGuid,
					si,
					pidSecurityProp,
					&var
					);
    }
    else
    {
        hr = ADSetObjectSecurity(
					eObject,
					pwcsDomainController,
					fServerName,
					pwcsObjectName,
					si,
					pidSecurityProp,
					&var
					);
    }

    if (FAILED(hr))
    {
        MessageDSError(hr, IDS_OP_SET_SECURITY_DESCRIPTOR);
        return hr;
    };

    return hr;
}

//
// GetSecurityProp - Utility function. Gets the security descriptor from AD
//
HRESULT 
GetSecurityProp(
	SECURITY_INFORMATION si,
	PSECURITY_DESCRIPTOR *ppSD,
	BOOL                 fDefault,
	AD_OBJECT            eObject,
	LPCWSTR              pwcsDomainController,
	bool				 fServerName,
	LPCWSTR              pwcsObjectName,
	GUID                *pObjGuid,
	PROPID               pidSecurityProp
	)
{
    DWORD dwSecLength = 0;
    *ppSD = NULL;

    if (fDefault)
    {
        return E_NOTIMPL;
    }
 
    HRESULT hr;
    
    PROPVARIANT var;
    var.vt = VT_NULL;
    if (NULL == pwcsObjectName)
    {
        ASSERT(NULL != pObjGuid);

        hr = ADGetObjectSecurityGuid(
                eObject,
                pwcsDomainController,
				fServerName,
                pObjGuid,
                si,
                pidSecurityProp,
                &var
                );
    }
    else
    {
        hr = ADGetObjectSecurity(
                eObject,
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                si,
                pidSecurityProp,
                &var
                );
    }
    
    if (FAILED(hr))
    {
        MessageDSError(hr, IDS_OP_GET_SECURITY_DESCRIPTOR);
        return hr;
    }

    PBYTE pSecurityDescriptor = 0;
    dwSecLength = var.blob.cbSize;

    if (0 != dwSecLength) pSecurityDescriptor = (PBYTE)LocalAlloc(LPTR, dwSecLength);        

    if (pSecurityDescriptor)
    {
        memcpy (pSecurityDescriptor, var.blob.pBlobData, dwSecLength);
    }
    else
    {
        ASSERT(0);
        return E_FAIL;
    }

    *ppSD = (PSECURITY_DESCRIPTOR)pSecurityDescriptor;    
    MQFreeMemory(var.blob.pBlobData);
   
    return hr;
}

//
// CObjSecurity - Base class for security info. editor. Also used for private queue
//
class CObjSecurity : public ISecurityInformation
{
protected:
    ULONG                   m_cRef;
    DWORD                   m_dwSIFlags;

    CString                 m_lpwcsFormatName;
    CString                 m_lpwcsDescriptiveName;
    CString                 m_lpwcsDomainController;
    CString                 m_lpwcsMachineName;
	bool					m_fServerName;

public:
    CObjSecurity(
			LPCWSTR                    lpwcsFormatName,
			LPCWSTR                    lpwcsDescriptiveName,
			LPCWSTR                    lpwcsDomainController,
			LPCWSTR                    lpwcsMachineName,
			bool					   fServerName,
			DWORD                      dwFlags
			) : 
    m_cRef(1),
    m_lpwcsFormatName(lpwcsFormatName),
    m_lpwcsDescriptiveName(lpwcsDescriptiveName),
    m_lpwcsDomainController(lpwcsDomainController),
    m_lpwcsMachineName(lpwcsMachineName),
    m_fServerName(fServerName),
    m_dwSIFlags(dwFlags)
    {
    	if (lpwcsMachineName == NULL || m_lpwcsMachineName == TEXT(""))
        {
            GetComputerNameIntoString(m_lpwcsMachineName);
        }
	}

    virtual ~CObjSecurity();

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    
    // ISecurityInformation methods
    STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo);
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
    STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes);
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage);
};

///////////////////////////////////////////////////////////////////////////////
//
//  This is the entry point function called from our code that establishes
//  what the ACLUI interface is going to need to know.
//
//
///////////////////////////////////////////////////////////////////////////////

//
// CreatePrivateQueueSecurityPage - Creates security page for either a private queue,
//                                  or a public queue in NT4 environment
//
HRESULT
CreatePrivateQueueSecurityPage(
    HPROPSHEETPAGE *phPage,
    IN LPCWSTR lpwcsFormatName,
    IN LPCWSTR lpwcsDescriptiveName
    )
{
    const DWORD  x_dwSIFlags = SI_EDIT_ALL | SI_ADVANCED | SI_NO_ACL_PROTECT; // Used by security editor
    CObjSecurity *psi;

    psi = new CObjSecurity(
					lpwcsFormatName, 
					lpwcsDescriptiveName, 
					TEXT(""),	// lpwcsDomainController
					NULL,
					false,		// fServerName
					x_dwSIFlags
					);
    if (!psi)
    {
        return E_OUTOFMEMORY;
    }

    *phPage = CreateSecurityPage(psi);
    psi->Release();

    if (0 == *phPage)
    {
        return MQ_ERROR;
    }

    return MQ_OK;
}


CObjSecurity::~CObjSecurity()
{
}


///////////////////////////////////////////////////////////
//
// IUnknown methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CObjSecurity::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CObjSecurity::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CObjSecurity::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////
//
// ISecurityInformation methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP
CObjSecurity::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{
  	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    pObjectInfo->dwFlags = m_dwSIFlags;
    pObjectInfo->hInstance = g_hResourceMod;
    pObjectInfo->pszServerName = m_lpwcsMachineName == TEXT("") ? 
                                        NULL : (LPTSTR)(LPCTSTR)m_lpwcsMachineName; 
    pObjectInfo->pszObjectName = (LPTSTR)(LPCTSTR)m_lpwcsDescriptiveName;

    return S_OK;
}

STDMETHODIMP
CObjSecurity::GetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault)
{
    DWORD dwSecLength = 0;
    *ppSD = NULL;

    if (fDefault)
    {
        return E_NOTIMPL;
    }
 
    HRESULT hr;
    DWORD dwDummy;
    hr = MQGetQueueSecurity(
                    m_lpwcsFormatName,
                    si,
                    &dwDummy, //    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
                    0,    //    IN DWORD nLength,
                    &dwSecLength
					);

    ASSERT(hr != MQ_OK);
    if (hr != MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL)
    {
        MessageDSError(hr, IDS_OP_GET_SECURITY_DESCRIPTOR);
        return hr;
    }

    PBYTE pSecurityDescriptor = 0;
    if (0 != dwSecLength) pSecurityDescriptor = (PBYTE)LocalAlloc(LPTR, dwSecLength);;

    hr = MQGetQueueSecurity(
                m_lpwcsFormatName,
                si,
                pSecurityDescriptor,
                dwSecLength,
                &dwSecLength);

    if (FAILED(hr))
    {
        MessageDSError(hr, IDS_OP_GET_SECURITY_DESCRIPTOR);
        LocalFree(pSecurityDescriptor);
        return hr;
    }

    *ppSD = (PSECURITY_DESCRIPTOR)pSecurityDescriptor;

    return hr;
}

STDMETHODIMP
CObjSecurity::SetSecurity(SECURITY_INFORMATION si,
                          PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = 
        MQSetQueueSecurity(
            m_lpwcsFormatName,
            si,
            pSD
            );

    if (FAILED(hr))
    {
        MessageDSError(hr, IDS_OP_SET_SECURITY_DESCRIPTOR);
        return hr;
    };

    return hr;
}

STDMETHODIMP
CObjSecurity::GetAccessRights(const GUID* /*pguidObjectType*/,
                               DWORD /*dwFlags*/,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    //
    // DESCRIPTION OF ACCESS FLAG AFFECTS
    //
    // SI_ACCESS_GENERAL shows up on general properties page
    // SI_ACCESS_SPECIFIC shows up on advanced page
    // SI_ACCESS_CONTAINER shows on general page IF object is a container
    //
    // The following array defines the permission names for my objects.
    //
    static SI_ACCESS x_siObjAccesses[] = 
    {
        { &GUID_NULL, MQSEC_QUEUE_GENERIC_ALL,       MAKEINTRESOURCE(IDS_SEC_ACCESS_ALL),             SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_DELETE_QUEUE,            MAKEINTRESOURCE(IDS_SEC_DELETE),                 SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_RECEIVE_MESSAGE,         MAKEINTRESOURCE(IDS_SEC_RECEIVE_MESSAGE),        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_PEEK_MESSAGE,            MAKEINTRESOURCE(IDS_SEC_PEEK_MESSAGE),           SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_RECEIVE_JOURNAL_MESSAGE, MAKEINTRESOURCE(IDS_SEC_RECEIVE_JOURNAL_MESSAGE),SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_GET_QUEUE_PROPERTIES,    MAKEINTRESOURCE(IDS_SEC_GET_PROPERTIES),         SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_SET_QUEUE_PROPERTIES,    MAKEINTRESOURCE(IDS_SEC_SET_PROPERTIES),         SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_GET_QUEUE_PERMISSIONS,   MAKEINTRESOURCE(IDS_SEC_GET_PERMISSIONS),        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_CHANGE_QUEUE_PERMISSIONS,MAKEINTRESOURCE(IDS_SEC_SET_PERMISSIONS),        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_TAKE_QUEUE_OWNERSHIP,    MAKEINTRESOURCE(IDS_SEC_TAKE_OWNERSHIP),         SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_WRITE_MESSAGE,           MAKEINTRESOURCE(IDS_SEC_WRITE_MESSAGE),          SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_DELETE_MESSAGE,          MAKEINTRESOURCE(IDS_SEC_DELETE_MESSAGE),         SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_DELETE_JOURNAL_MESSAGE,  MAKEINTRESOURCE(IDS_SEC_DELETE_JOURNAL_MESSAGE), SI_ACCESS_SPECIFIC },
    };

    *ppAccesses = x_siObjAccesses;
    *pcAccesses = sizeof(x_siObjAccesses)/sizeof(x_siObjAccesses[0]);
    *piDefaultAccess = 10; // ordinal 10 in the table above - MQSEC_WRITE_MESSAGE

    return S_OK;
}

STDMETHODIMP
CObjSecurity::MapGeneric(const GUID* /*pguidObjectType*/,
                          UCHAR * /*pAceFlags*/,
                          ACCESS_MASK *pmask)
{
    //
    // define our generic mapping structure for queue
    //
    static GENERIC_MAPPING ObjMap =
    {
        MQSEC_QUEUE_GENERIC_READ,
        MQSEC_QUEUE_GENERIC_WRITE,
        MQSEC_QUEUE_GENERIC_EXECUTE,
        MQSEC_QUEUE_GENERIC_ALL
    };
    MapGenericMask(pmask, &ObjMap);

    return S_OK;
}

STDMETHODIMP
CObjSecurity::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes)
{
    *ppInheritTypes = g_siObjInheritTypes;
    *pcInheritTypes = sizeof(g_siObjInheritTypes)/sizeof(g_siObjInheritTypes[0]);

    return S_OK;
}

STDMETHODIMP
CObjSecurity::PropertySheetPageCallback(HWND /*hwnd*/,
                                         UINT /*uMsg*/,
                                         SI_PAGE_TYPE /*uPage*/)
{
    return S_OK;
}

//
// CMachineSecurity - Security page for machine in the AD
//
class CMachineSecurity : public CObjSecurity
{
public:
    CMachineSecurity(
		LPCWSTR                    lpwcsMachineName,
		LPCWSTR                    lpwcsDomainController,
		bool					   fServerName,
		DWORD                      dwFlags
		) : 
    CObjSecurity(TEXT(""), lpwcsMachineName, lpwcsDomainController, lpwcsMachineName, fServerName, dwFlags)
    {}

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);


    // ISecurityInformation methods
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
};

STDMETHODIMP
CMachineSecurity::GetSecurity(
	SECURITY_INFORMATION si,
	PSECURITY_DESCRIPTOR *ppSD,
	BOOL fDefault
	)
{
    return GetSecurityProp(
				si, 
				ppSD, 
				fDefault,
				eMACHINE, 
				m_lpwcsDomainController, 
				m_fServerName,
				m_lpwcsMachineName, 
				NULL, 
				PROPID_QM_OBJ_SECURITY
				);
}

STDMETHODIMP
CMachineSecurity::SetSecurity(
	SECURITY_INFORMATION si,
	PSECURITY_DESCRIPTOR pSD
	)
{
    return SetSecurityProp(
				si, 
				pSD, 
				eMACHINE, 
				m_lpwcsDomainController, 
				m_fServerName,
				m_lpwcsMachineName, 
				NULL, 
				PROPID_QM_OBJ_SECURITY
				);
}

STDMETHODIMP
CMachineSecurity::GetAccessRights(const GUID* /*pguidObjectType*/,
                               DWORD /*dwFlags*/,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    static GUID guidQueueObject =
        { 0x9a0dc343, 0xc100, 0x11d1,
            { 0xbb, 0xc5, 0x00, 0x80, 0xc7, 0x66, 0x70, 0xc0 }} ;

    static GUID guidRightsReceiveDeadletter = 
        { 0x4b6e08c0, 0xdf3c, 0x11d1,
            { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e }};

    static GUID guidRightsPeekDeadletter =
    { 0x4b6e08c1, 0xdf3c, 0x11d1,
        { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e }};

    static GUID guidRightsReceiveJournal =
    { 0x4b6e08c2, 0xdf3c, 0x11d1,
        { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e }};

    static GUID guidRightsPeekJournal =
    { 0x4b6e08c3, 0xdf3c, 0x11d1,
        { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e }};

    //
    // DESCRIPTION OF ACCESS FLAG AFFECTS
    //
    // SI_ACCESS_GENERAL shows up on general properties page
    // SI_ACCESS_SPECIFIC shows up on advanced page
    // SI_ACCESS_CONTAINER shows on general page IF object is a container
    //
    // The following array defines the permission names for my objects.
    //
    static SI_ACCESS x_siMachineAccesses[] = 
    {
        { &GUID_NULL,                  DS_GENERIC_ALL,         MAKEINTRESOURCE(IDS_SEC_ACCESS_ALL),                  SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &guidQueueObject,            ACTRL_DS_CREATE_CHILD,  MAKEINTRESOURCE(IDS_SEC_CREATE_QUEUE),                SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &guidRightsReceiveDeadletter,ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_RECEIVE_DEAD_LETTER_MESSAGE), SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &guidRightsReceiveJournal,   ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_RECEIVE_MACHINE_JOURNAL),     SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  ACTRL_DS_READ_PROP,     MAKEINTRESOURCE(IDS_SEC_GET_PROPERTIES),              SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  ACTRL_DS_WRITE_PROP,    MAKEINTRESOURCE(IDS_SEC_SET_PROPERTIES),              SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  READ_CONTROL,           MAKEINTRESOURCE(IDS_SEC_GET_PERMISSIONS),             SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  WRITE_DAC,              MAKEINTRESOURCE(IDS_SEC_SET_PERMISSIONS),             SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  WRITE_OWNER,            MAKEINTRESOURCE(IDS_SEC_TAKE_OWNERSHIP),              SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  DELETE,                 MAKEINTRESOURCE(IDS_SEC_DELETE),                      SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &guidRightsPeekDeadletter,   ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_PEEK_DEAD_LETTER_MESSAGE),                        SI_ACCESS_SPECIFIC },
        { &guidRightsPeekJournal,      ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_PEEK_COMPUTER_JOURNAL),                           SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_ALL_EXTENDED_RIGHTS),                             SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  ACTRL_DS_CREATE_CHILD,  MAKEINTRESOURCE(IDS_SEC_CREATE_ALL_CHILD_OBJECTS),                        SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  ACTRL_DS_DELETE_CHILD,  MAKEINTRESOURCE(IDS_SEC_DELETE_ALL_CHILD_OBJECTS),                        SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                  ACTRL_DS_LIST,          MAKEINTRESOURCE(IDS_SEC_LIST_OBJECTS),                			 SI_ACCESS_SPECIFIC }
    };

    *ppAccesses = x_siMachineAccesses;
    *pcAccesses = sizeof(x_siMachineAccesses)/sizeof(x_siMachineAccesses[0]);
    *piDefaultAccess = 4; // Ordinal 4 in the table above - MQSEC_GET_MACHINE_PROPERTIES

    return S_OK;
}

STDMETHODIMP
CMachineSecurity::MapGeneric(const GUID* /*pguidObjectType*/,
                          UCHAR * /*pAceFlags*/,
                          ACCESS_MASK *pmask)
{
    //
    // define our generic mapping structure for queue
    //
    static GENERIC_MAPPING ObjMap =
    {
        DS_GENERIC_READ,
        DS_GENERIC_WRITE,
        DS_GENERIC_EXECUTE,
        DS_GENERIC_ALL
    };
    MapGenericMask(pmask, &ObjMap);

    return S_OK;
}

STDMETHODIMP
CMachineSecurity::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


//
// CNT4MachineSecurity - Security page for machine in an NT4 environment
//
class CNT4MachineSecurity : public CObjSecurity
{
public:
    CNT4MachineSecurity(LPCWSTR                    lpwcsMachineName,
                        DWORD                      dwFlags) : 
    CObjSecurity(
		TEXT(""), 
		lpwcsMachineName, 
		TEXT(""),	// lpwcsDomainController
		lpwcsMachineName,
		false,		// fServerName
		dwFlags
		)
    {}

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);


    // ISecurityInformation methods
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
};

STDMETHODIMP
CNT4MachineSecurity::GetSecurity(
	SECURITY_INFORMATION si,
	PSECURITY_DESCRIPTOR *ppSD,
	BOOL fDefault
	)
{
    //
    // Note: We do not need domain for NT4 MQIS
    //
    return GetSecurityProp(
				si, 
				ppSD, 
				fDefault,
				eMACHINE, 
				NULL,       // pwcsDomainController
				false,	    // fServerName
				m_lpwcsMachineName, 
				NULL, 
				PROPID_QM_SECURITY
				);
}

STDMETHODIMP
CNT4MachineSecurity::SetSecurity(
	SECURITY_INFORMATION si,
	PSECURITY_DESCRIPTOR pSD
	)
{
    //
    // Note: We do not need domain for NT4 MQIS
    //
    return SetSecurityProp(
				si, 
				pSD, 
				eMACHINE, 
				NULL,       // pwcsDomainController
				false,	    // fServerName
				m_lpwcsMachineName, 
				NULL, 
				PROPID_QM_SECURITY
				);
}

STDMETHODIMP
CNT4MachineSecurity::GetAccessRights(const GUID* /*pguidObjectType*/,
                               DWORD /*dwFlags*/,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    //
    // DESCRIPTION OF ACCESS FLAG AFFECTS
    //
    // SI_ACCESS_GENERAL shows up on general properties page
    // SI_ACCESS_SPECIFIC shows up on advanced page
    // SI_ACCESS_CONTAINER shows on general page IF object is a container
    //
    // The following array defines the permission names for my objects.
    //
    static SI_ACCESS x_siMachineAccesses[] = 
    {
        { &GUID_NULL, MQSEC_MACHINE_GENERIC_ALL,          MAKEINTRESOURCE(IDS_SEC_ACCESS_ALL),                  SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_CREATE_QUEUE,                 MAKEINTRESOURCE(IDS_SEC_CREATE_QUEUE),                SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_RECEIVE_DEADLETTER_MESSAGE,   MAKEINTRESOURCE(IDS_SEC_RECEIVE_DEAD_LETTER_MESSAGE), SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_RECEIVE_JOURNAL_QUEUE_MESSAGE,MAKEINTRESOURCE(IDS_SEC_RECEIVE_MACHINE_JOURNAL),     SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_GET_MACHINE_PROPERTIES,       MAKEINTRESOURCE(IDS_SEC_GET_PROPERTIES),              SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_SET_MACHINE_PROPERTIES,       MAKEINTRESOURCE(IDS_SEC_SET_PROPERTIES),              SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_GET_MACHINE_PERMISSIONS,      MAKEINTRESOURCE(IDS_SEC_GET_PERMISSIONS),             SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_CHANGE_MACHINE_PERMISSIONS,   MAKEINTRESOURCE(IDS_SEC_SET_PERMISSIONS),             SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_TAKE_MACHINE_OWNERSHIP,       MAKEINTRESOURCE(IDS_SEC_TAKE_OWNERSHIP),              SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_DELETE_MACHINE,               MAKEINTRESOURCE(IDS_SEC_DELETE),                      SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL, MQSEC_PEEK_DEADLETTER_MESSAGE,      MAKEINTRESOURCE(IDS_SEC_PEEK_DEAD_LETTER_MESSAGE),    SI_ACCESS_SPECIFIC},
        { &GUID_NULL, MQSEC_PEEK_JOURNAL_QUEUE_MESSAGE,   MAKEINTRESOURCE(IDS_SEC_PEEK_COMPUTER_JOURNAL),       SI_ACCESS_SPECIFIC},
    };

    *ppAccesses = x_siMachineAccesses;
    *pcAccesses = sizeof(x_siMachineAccesses)/sizeof(x_siMachineAccesses[0]);
    *piDefaultAccess = 4; // Ordinal 4 in the table above - MQSEC_GET_MACHINE_PROPERTIES

    return S_OK;
}

STDMETHODIMP
CNT4MachineSecurity::MapGeneric(const GUID* /*pguidObjectType*/,
                          UCHAR * /*pAceFlags*/,
                          ACCESS_MASK *pmask)
{
    //
    // define our generic mapping structure for queue
    //
    static GENERIC_MAPPING ObjMap =
    {
        MQSEC_MACHINE_GENERIC_READ,
        MQSEC_MACHINE_GENERIC_WRITE,
        MQSEC_MACHINE_GENERIC_EXECUTE,
        MQSEC_MACHINE_GENERIC_ALL
    };
    MapGenericMask(pmask, &ObjMap);

    return S_OK;
}

STDMETHODIMP
CNT4MachineSecurity::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

//
// CreateMachineSecurityPage - used for MSMQ config security.
// Detects the environment and displays AD or NT4 page
//
HRESULT
CreateMachineSecurityPage(
    HPROPSHEETPAGE *phPage,
    IN LPCWSTR lpwcsMachineNameIn,
    IN LPCWSTR lpwcsDomainController,
	IN bool fServerName
	)
{
    const DWORD  x_dwSIFlags = SI_EDIT_ALL | SI_ADVANCED; // Used by security editor
    CObjSecurity *psi;

    CString strMachineName;

    ASSERT(0 != lpwcsMachineNameIn);

    if (eAD == ADGetEnterprise())
    {
        psi = new CMachineSecurity(lpwcsMachineNameIn, lpwcsDomainController, fServerName, x_dwSIFlags);
    }
    else
    {
        psi = new CNT4MachineSecurity(lpwcsMachineNameIn, x_dwSIFlags | SI_NO_ACL_PROTECT);
    }

    if (!psi)
    {
        return E_OUTOFMEMORY;
    }

    *phPage = CreateSecurityPage(psi);
    psi->Release();

    if (0 == *phPage)
    {
        return MQ_ERROR;
    }

    return MQ_OK;
}

//
// CPublicQueueSecurity - Security page for public queue in the AD
//
class CPublicQueueSecurity : public CObjSecurity
{
protected:
    GUID                 m_guid;

public:
    CPublicQueueSecurity(
		LPCWSTR  lpwcsDescriptiveName,
		LPCWSTR  lpwcsDomainController,
		bool	 fServerName,
		DWORD    dwFlags,
		GUID*    pguid
		) : 
    m_guid(*pguid),
    CObjSecurity(TEXT(""), lpwcsDescriptiveName, lpwcsDomainController, NULL, fServerName, dwFlags)
    {}

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);

    // ISecurityInformation methods
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
};

STDMETHODIMP
CPublicQueueSecurity::GetSecurity(SECURITY_INFORMATION si,
                                  PSECURITY_DESCRIPTOR *ppSD,
                                  BOOL fDefault)
{
    return GetSecurityProp(
				si, 
				ppSD, 
				fDefault, 
				eQUEUE, 
				m_lpwcsDomainController, 
				m_fServerName, 
				NULL, 
				&m_guid, 
				PROPID_Q_OBJ_SECURITY
				);
}

STDMETHODIMP
CPublicQueueSecurity::SetSecurity(
	SECURITY_INFORMATION si,
	PSECURITY_DESCRIPTOR pSD
	)
{
    return SetSecurityProp(
				si, 
				pSD, 
				eQUEUE, 
				m_lpwcsDomainController, 
				m_fServerName,
				NULL, 
				&m_guid, 
				PROPID_Q_OBJ_SECURITY
				);
}

STDMETHODIMP
CPublicQueueSecurity::GetAccessRights(const GUID* /*pguidObjectType*/,
                               DWORD /*dwFlags*/,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    static GUID guidRightsReceiveMessage = 
      { 0x06bd3200, 0xdf3e, 0x11d1,
        { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e }};

    static GUID guidRightsPeekMessage = 
      { 0x06bd3201, 0xdf3e, 0x11d1,
        { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e }};

    static GUID guidRightsSendMessage = 
     { 0x06bd3202, 0xdf3e, 0x11d1,
        { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e }};

    static GUID guidRightsReceiveJournal = 
     { 0x06bd3203, 0xdf3e, 0x11d1,
        { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e }};

    //
    // DESCRIPTION OF ACCESS FLAG AFFECTS
    //
    // SI_ACCESS_GENERAL shows up on general properties page
    // SI_ACCESS_SPECIFIC shows up on advanced page
    // SI_ACCESS_CONTAINER shows on general page IF object is a container
    //
    // The following array defines the permission names for my objects.
    //
    static SI_ACCESS x_siObjAccesses[] = 
    {
        { &GUID_NULL,                DS_GENERIC_ALL,         MAKEINTRESOURCE(IDS_SEC_ACCESS_ALL),             SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                DELETE,                 MAKEINTRESOURCE(IDS_SEC_DELETE),                 SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &guidRightsReceiveMessage, ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_RECEIVE_MESSAGE),        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &guidRightsPeekMessage,    ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_PEEK_MESSAGE),           SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &guidRightsReceiveJournal, ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_RECEIVE_JOURNAL_MESSAGE),SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                ACTRL_DS_READ_PROP,     MAKEINTRESOURCE(IDS_SEC_GET_PROPERTIES),         SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                ACTRL_DS_WRITE_PROP,    MAKEINTRESOURCE(IDS_SEC_SET_PROPERTIES),         SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                READ_CONTROL,           MAKEINTRESOURCE(IDS_SEC_GET_PERMISSIONS),        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                WRITE_DAC,              MAKEINTRESOURCE(IDS_SEC_SET_PERMISSIONS),        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                WRITE_OWNER,            MAKEINTRESOURCE(IDS_SEC_TAKE_OWNERSHIP),         SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &guidRightsSendMessage,    ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_WRITE_MESSAGE),          SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
        { &GUID_NULL,                ACTRL_DS_CONTROL_ACCESS,MAKEINTRESOURCE(IDS_SEC_ALL_EXTENDED_RIGHTS),                        SI_ACCESS_SPECIFIC }
    };

    *ppAccesses = x_siObjAccesses;
    *pcAccesses = sizeof(x_siObjAccesses)/sizeof(x_siObjAccesses[0]);
    *piDefaultAccess = 10; // ordinal 10 in the table above - Send message

    return S_OK;
}

STDMETHODIMP
CPublicQueueSecurity::MapGeneric(const GUID* /*pguidObjectType*/,
                          UCHAR * /*pAceFlags*/,
                          ACCESS_MASK *pmask)
{
    //
    // define our generic mapping structure for queue
    //
    static GENERIC_MAPPING ObjMap =
    {
        DS_GENERIC_READ,
        DS_GENERIC_WRITE,
        DS_GENERIC_EXECUTE,
        DS_GENERIC_ALL
    };
    MapGenericMask(pmask, &ObjMap);

    return S_OK;
}

STDMETHODIMP
CPublicQueueSecurity::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

//
// CreatePublicQueueSecurityPage - Returns the security page of a public queue in AD
//
HRESULT
CreatePublicQueueSecurityPage(
    HPROPSHEETPAGE *phPage,
    IN LPCWSTR lpwcsDescriptiveName,
    IN LPCWSTR lpwcsDomainController,
	IN bool	   fServerName,
    IN GUID*   pguid
	)
{
    const DWORD  x_dwSIFlags = SI_EDIT_ALL | SI_ADVANCED; // Used by security editor
    CObjSecurity *psi;

    psi = new CPublicQueueSecurity(lpwcsDescriptiveName, lpwcsDomainController, fServerName, x_dwSIFlags, pguid);
    if (!psi)
    {
        return E_OUTOFMEMORY;
    }

    *phPage = CreateSecurityPage(psi);
    psi->Release();

    if (0 == *phPage)
    {
        return MQ_ERROR;
    }

    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\qext.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	qext.cpp

Abstract:


Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "qext.h"
#include "snapin.h"
#include "globals.h"
#include "rdmsg.h"
#include "mqcast.h"
#include "ldaputl.h"

#include "qext.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/****************************************************

        CSnapinQueue Class
    
 ****************************************************/

/////////////////////////////////////////////////////////////////////////////
// {0C0F8CE2-D475-11d1-9B9D-00E02C064C39}
static const GUID CSnapinQueueGUID_NODETYPE = 
{ 0xc0f8ce2, 0xd475, 0x11d1, { 0x9b, 0x9d, 0x0, 0xe0, 0x2c, 0x6, 0x4c, 0x39 } };


const GUID*  CSnapinQueue::m_NODETYPE = &CSnapinQueueGUID_NODETYPE;
const OLECHAR* CSnapinQueue::m_SZNODETYPE = OLESTR("0C0F8CE2-D475-11d1-9B9D-00E02C064C39");
const OLECHAR* CSnapinQueue::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CSnapinQueue::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinQueue::CSnapinQueue 
Constractor. Set initial values and determines wheather or not the queue should be
expanded.

--*/
//////////////////////////////////////////////////////////////////////////////
CSnapinQueue::CSnapinQueue(CSnapInItem * pParentNode, CSnapin * pComponentData, LPCWSTR lpcwstrLdapName) : 
    CNodeWithScopeChildrenList<CSnapinQueue, TRUE>(pParentNode, pComponentData ),
    m_hrError(MQ_OK)
{
   	memset(&m_scopeDataItem, 0, sizeof(m_scopeDataItem));
	memset(&m_resultDataItem, 0, sizeof(m_resultDataItem));
    m_szFormatName[0] = L'\0';
    Init(lpcwstrLdapName);
}

void CSnapinQueue::Init(LPCWSTR lpcwstrLdapName)
{
    //
    // Check if the computer is a foreign computer. If it is, we don't
    // want to expand the current queue. We also don't want to expand 
    // the current queue if there is an error getting its details from MSMQ DS.
    // (Such error can occur, for example, when the DS snap-in and MSMQ are accessing 
    // two different domain controllers, and the queue data did not arrive to the
    // MSMQ domain controller yet).
    //
    m_fDontExpand = FALSE;

    HRESULT hr;
    CString strComputerMsmqName;
    hr = ExtractComputerMsmqPathNameFromLdapQueueName(strComputerMsmqName, lpcwstrLdapName);
    if (FAILED(hr))
    {
        ASSERT(0);
        return;
    }

    m_strMsmqPathName = strComputerMsmqName;

	//
	// Get Domain Controller name
	//
	CString strDomainController;
	hr = ExtractDCFromLdapPath(strDomainController, lpcwstrLdapName);
	ASSERT(("Failed to Extract DC name", SUCCEEDED(hr)));
	
	PROPVARIANT   PropVar;
    PROPID        PropId = PROPID_QM_FOREIGN;

    PropVar.vt = VT_NULL;

    hr = ADGetObjectProperties(
                    eMACHINE,
	                GetDomainController(strDomainController),
					true,	// fServerName
                    strComputerMsmqName,
                    1, 
                    &PropId,
                    &PropVar
                    );

    if(SUCCEEDED(hr))
    {
        //
        // Do not expand (do not show messages) for
        // queues on foreign computers
        //
        if (PropVar.bVal)
        {
            m_fDontExpand = TRUE;
        }
        else
        {
            m_fDontExpand = FALSE;
        }
    }
    else
    {
        //
        // Most probably, MSMQ is not running. We do not want to report an
        // error - we simply don't display the messages.
        //
        m_fDontExpand = TRUE;
    }
    //
    // We keep the error condition to see if the "don't expand" situation
    // is permanent
    //
    m_hrError = hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinQueue::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapinQueue::PopulateScopeChildrenList()
{

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Return right away if you should not expand parent
    //
    if (m_fDontExpand)
    {
        //
        // We don't need the scode data item if we do not expand the node
        //
       	memset(&m_scopeDataItem, 0, sizeof(m_scopeDataItem));
        return m_hrError;
    }

    HRESULT hr = S_OK;
    CString strTitle;
    
    //
    // Create a node to Read Messages
    //
    CReadMsg * p = new CReadMsg(this, m_pComponentData, m_szFormatName, m_strMsmqPathName);

    // Pass relevant information
    strTitle.LoadString(IDS_READMESSAGE);
    p->m_bstrDisplayName = strTitle;
    p->SetIcons(IMAGE_QUEUE,IMAGE_QUEUE);

   	AddChild(p, &p->m_scopeDataItem);

    

    //
    // Create a node to Read journal messages
    //
    // Compose the format name of the journal queue
    CString strJournal = m_szFormatName;
    strJournal = strJournal + L";JOURNAL";

    p = new CReadMsg(this, m_pComponentData, strJournal, m_strMsmqPathName);
    
   
    strTitle.LoadString(IDS_READJOURNALMESSAGE);
    p->m_bstrDisplayName = strTitle;
    p->SetIcons(IMAGE_JOURNAL_QUEUE,IMAGE_JOURNAL_QUEUE);


   	AddChild(p, &p->m_scopeDataItem);


    return(hr);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinQueue::OnRemoveChildren

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSnapinQueue::OnRemoveChildren( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{

    ((CQueueExtData *)m_pParentNode)->RemoveChild(m_pwszQueueName);

	return (S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinQueue::FillData

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapinQueue::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
	HRESULT hr = DV_E_CLIPFORMAT;
	ULONG uWritten;

    hr = CNodeWithScopeChildrenList<CSnapinQueue, TRUE>::FillData(cf, pStream);

    if (hr != DV_E_CLIPFORMAT)
    {
        return hr;
    }

	if (cf == gx_CCF_FORMATNAME)
	{
		hr = pStream->Write(
            m_szFormatName, 
            (numeric_cast<ULONG>(wcslen(m_szFormatName) + 1))*sizeof(m_szFormatName[0]), 
            &uWritten);

		return hr;
	}

	if (cf == gx_CCF_PATHNAME)
	{
		hr = pStream->Write(
            (LPCTSTR)m_pwszQueueName, 
            m_pwszQueueName.GetLength() * sizeof(WCHAR), 
            &uWritten);
		return hr;
	}

	if (cf == gx_CCF_COMPUTERNAME)
	{
		hr = pStream->Write(
            (LPCTSTR)m_strMsmqPathName, 
            m_strMsmqPathName.GetLength() * sizeof(WCHAR), 
            &uWritten);
		return hr;
	}

	return hr;
}


/****************************************************

        CQueueExtData Class
    
 ****************************************************/
//
// Extending the DS Queue node type
//  taken from object:   GC://CN=MSMQ-Queue,CN=Schema,CN=Configuration,DC=raphirdom,DC=Com
//             property: schemaIDGUID
//             value:    x43 xc3 x0d x9a x00 xc1 xd1 x11 xbb xc5 x00 x80 xc7 x66 x70 xc0
//
// static const GUID CQueueExtDatatGUID_NODETYPE = 
//   { 0x9a0dc343, 0xc100, 0x11d1, { 0xbb, 0xc5, 0x00, 0x80, 0xc7, 0x66, 0x70, 0xc0 } }; - was moved to globals.h
const GUID*  CQueueExtData::m_NODETYPE = &CQueueExtDatatGUID_NODETYPE;
const OLECHAR* CQueueExtData::m_SZNODETYPE = OLESTR("9a0dc343-c100-11d1-bbc5-0080c76670c0");
const OLECHAR* CQueueExtData::m_SZDISPLAY_NAME = OLESTR("MSMQAdmin");
const CLSID* CQueueExtData::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;

//////////////////////////////////////////////////////////////////////////////
/*++

CQueueExtData::CreatePropertyPages

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CQueueExtData::CreatePropertyPages(
	LPPROPERTYSHEETCALLBACK /*lpProvider*/,
    LONG_PTR /*handle*/, 
	IUnknown* /*pUnk*/,
	DATA_OBJECT_TYPES type)
{
	if (type == CCT_SCOPE || type == CCT_RESULT)
	{
//		CSnapPage* pPage = new CSnapPage(_T("Snap"));
//		lpProvider->AddPage(pPage->Create());

		// TODO : Add code here to add additional pages
		return S_OK;
	}
	return E_UNEXPECTED;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CQueueExtData::GetExtNodeObject

  Called with a node that we need to expand. 
  Check if we have already a snapin object corresponding to this node,
  else create a new one.

--*/
//////////////////////////////////////////////////////////////////////////////
CSnapInItem* CQueueExtData::GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
{
    CSnapinQueue *pQ;

    CArray<CString, CString&> astrQNames;
	CArray<CString, CString&> astrLdapNames;

    HRESULT hr = ExtractQueuePathNamesFromDataObject(pDataObject, astrQNames, astrLdapNames);
    if(FAILED(hr))
    {
        ATLTRACE(_T("CQueueExtData::GetExtNodeObject - Extracting queue name failed\n"));
        return(pDefault);
    }

    //
    // We should get one and only one queue in this interface
    //
    if (astrQNames.GetSize() != 1)
    {
        ASSERT(0);
        return(pDefault);
    }

    //
    // Do we already have this object
    //
    BOOL fQueueExist = m_mapQueues.Lookup(astrQNames[0], pQ);
    if(fQueueExist == TRUE)
    {
        if (SUCCEEDED(pQ->m_hrError))
        {
            //
            // If there was no error last time, simply return the cashed 
            // result. Otherwise continue.
            //
            return(pQ);
        }
        //
        // In case last time ended with error, attempt to re-initiate the object
        //
        pQ->Init(astrLdapNames[0]);
    }
    else
    {

        //
        // Not in the list, so create a queue object
        //
        pQ = new CSnapinQueue(this, m_pComponentData, astrLdapNames[0]);
    }

    //
    // Set the queue name and format name in the object
    //
    pQ->m_pwszQueueName = astrQNames[0];
    DWORD dwSize =  sizeof(pQ->m_szFormatName);
    pQ->m_hrError = MQPathNameToFormatName(pQ->m_pwszQueueName,pQ->m_szFormatName, &dwSize); 

    if (FALSE == fQueueExist)
    {
        //
        // Add it to the map, if not there already
        //
        m_mapQueues.SetAt(astrQNames[0], pQ);
    }

    return(pQ);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CQueueExtData::~CQueueExtData

  Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CQueueExtData::~CQueueExtData()
{

    RemoveAllChildrens();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CQueueExtData::RemoveAllChildrens


--*/
//////////////////////////////////////////////////////////////////////////////
void CQueueExtData::RemoveAllChildrens(void)
{

    POSITION pos;
    CString str;
    CSnapinQueue * pQ;

    //
    // Delete all the nodes from the map
    //
    pos = m_mapQueues.GetStartPosition();
    while(pos != NULL)
    {

        m_mapQueues.GetNextAssoc(pos, str, pQ);
        delete pQ;
    }

    //
    // Empty the map
    //
    m_mapQueues.RemoveAll();

}

//////////////////////////////////////////////////////////////////////////////
/*++

CQueueExtData::RemoveChild


--*/
//////////////////////////////////////////////////////////////////////////////
void CQueueExtData::RemoveChild(CString& strQName)
{
    BOOL rc;
    CSnapinQueue *pQ;

    rc = m_mapQueues.Lookup(strQName, pQ);

    if(rc == FALSE)
    {
        ASSERT(0);
        return;
    }

    rc = m_mapQueues.RemoveKey(strQName);
    ASSERT(rc == TRUE);

    delete pQ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\qmltcast.h ===
#if !defined(AFX_QMULTICAST_H__AE51B255_A3C8_11D1_808A_00A024C48131__INCLUDED_)
#define AFX_QMULTICAST_H__AE51B255_A3C8_11D1_808A_00A024C48131__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// qmltcast.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CQueueMulticast dialog

class CQueueMulticast : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CQueueMulticast)

// Construction
public:
	CQueueMulticast(
		BOOL fPrivate = FALSE, 
		BOOL fLocalMgmt = FALSE
		);

	~CQueueMulticast();

    HRESULT 
	InitializeProperties(
			CString &strMsmqPath,
			CPropMap &propMap,                                  
			CString* pstrDomainController, 
			CString* pstrFormatName = 0
			);

// Dialog Data
	//{{AFX_DATA(CQueueMulticast)
	enum { IDD = IDD_QUEUE_MULTICAST };
	CString m_strMulticastAddress;
    CString m_strInitialMulticastAddress;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CQueueMulticast)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CQueueMulticast)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
  
    BOOL IsMulticastAddressAvailable ();

    BOOL m_fPrivate;
    BOOL m_fLocalMgmt;

    CString m_strFormatName;
    CString	m_strName;
    CString m_strDomainController;

    void DDV_ValidMulticastAddress(CDataExchange* pDX);    

	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_QMULTICAST_H__AE51B255_A3C8_11D1_808A_00A024C48131__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\qgeneral.h ===
#if !defined(AFX_QGENERAL_H__AE51B255_A3C8_11D1_808A_00A024C48131__INCLUDED_)
#define AFX_QGENERAL_H__AE51B255_A3C8_11D1_808A_00A024C48131__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// QGeneral.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CQueueGeneral dialog

class CQueueGeneral : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CQueueGeneral)

// Construction
public:
	CQueueGeneral(
		BOOL fPrivate = FALSE, 
		BOOL fLocalMgmt = FALSE
		);

	~CQueueGeneral();

    HRESULT 
	InitializeProperties(
		CString &strMsmqPath, 
		CPropMap &propMap, 
		CString* pstrDomainController, 
		CString* pstrFormatName = 0
		);

    DWORD m_dwQuota;
	DWORD m_dwJournalQuota;
	BOOL	m_fTransactional;

// Dialog Data
	//{{AFX_DATA(CQueueGeneral)
	enum { IDD = IDD_QUEUE_GENERAL };
	CStatic	m_staticIcon;
	CSpinButtonCtrl	m_spinPriority;
	CString	m_strName;
	CString	m_strLabel;
	GUID m_guidID;
	GUID m_guidTypeID;
	BOOL	m_fAuthenticated;
	BOOL	m_fJournal;
	LONG	m_lBasePriority;
	int		m_iPrivLevel;
	COleDateTime	m_dateCreateTime;
	COleDateTime	m_dateModifyTime;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CQueueGeneral)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CQueueGeneral)
	virtual BOOL OnInitDialog();
	afx_msg void OnQueueMquotaCheck();
	afx_msg void OnQueueJquotaCheck();
	//}}AFX_MSG

    BOOL m_fPrivate;
    BOOL m_fLocalMgmt;

    CString m_strFormatName;
    CString m_strDomainController;

	DECLARE_MESSAGE_MAP()
};

#define MAX_BASE_PRIORITY  32767
#define MIN_BASE_PRIORITY -32768

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_QGENERAL_H__AE51B255_A3C8_11D1_808A_00A024C48131__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\qmltcast.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    qmltcast.cpp

Abstract:

    Queue/Multicast Address property page implementation

Author:

    Tatiana Shubin (tatianas)

--*/
#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "cpropmap.h"
#include "mqPPage.h"
#include "qmltcast.h"
#include "qformat.h"
#include "Tr.h"
#include "Fn.h"

#include "qmltcast.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CQueueMulticast property page

IMPLEMENT_DYNCREATE(CQueueMulticast, CMqPropertyPage)

CQueueMulticast::CQueueMulticast(
		 BOOL fPrivate /* = FALSE */, 
		 BOOL fLocalMgmt /* = FALSE */
		 ) : 
    CMqPropertyPage(CQueueMulticast::IDD)
{    
    m_fPrivate = fPrivate;
    m_fLocalMgmt = fLocalMgmt;
    //{{AFX_DATA_INIT(CQueueMulticast)
    m_strMulticastAddress = _T("");
    m_strInitialMulticastAddress = _T("");
	//}}AFX_DATA_INIT

}

CQueueMulticast::~CQueueMulticast()
{
}

void CQueueMulticast::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
	//{{AFX_DATA_MAP(CQueueMulticast)
	DDX_Text(pDX, IDC_QMULTICAST_QADDRESS, m_strMulticastAddress);
	//}}AFX_DATA_MAP	
    DDV_ValidMulticastAddress(pDX);
}

BEGIN_MESSAGE_MAP(CQueueMulticast, CMqPropertyPage)
    //{{AFX_MSG_MAP(CQueueMulticast)  
    ON_EN_CHANGE(IDC_QMULTICAST_QADDRESS, OnChangeRWField)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQueueMulticast message handlers

BOOL CQueueMulticast::OnInitDialog() 
{
    //
    // This closure is used to keep the DLL state. For UpdateData we need
    // the mmc.exe state.
    //
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
        if (!IsMulticastAddressAvailable ())
        {
            GetDlgItem(IDC_QMULTICAST_QADDRESS)->EnableWindow(FALSE);
            GetDlgItem(IDC_QMULTICAST_QADDRESS_LABEL)->EnableWindow(FALSE);
            //
            // BUGBUG: Add text box with explanation that this feature is not
            // supported. Maybe instead of EnableWindow(FALSE) use
            // ShowWindow(FALSE)
            //
        }        
    }

	UpdateData( FALSE );
  
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}   

BOOL CQueueMulticast::OnApply() 
{
    if (!m_fModified)
    {
        return TRUE;
    }

    if (m_strInitialMulticastAddress == m_strMulticastAddress)
    {  
        //
        // there is no change
        //
        return TRUE;
    } 

    PROPID paMulticastPropid[] = {PROPID_Q_MULTICAST_ADDRESS};

	DWORD iProperty = 0;           
    PROPVARIANT apMulticastVar[1];
    
    if (m_strMulticastAddress == _T("")) 
    {
        apMulticastVar[iProperty++].vt = VT_EMPTY;	   
    }
    else
    {
        apMulticastVar[iProperty].vt = VT_LPWSTR;
	    apMulticastVar[iProperty++].pwszVal = (LPWSTR)(LPCWSTR)m_strMulticastAddress;
    }                         

    MQQUEUEPROPS mqp = {iProperty, paMulticastPropid, apMulticastVar, 0};
        
    HRESULT hr = MQ_OK;
	if(m_fPrivate)
	{
		hr = MQSetQueueProperties(m_strFormatName, &mqp);
	}
	else
	{
		AP<WCHAR> pStrToFree;
        QUEUE_FORMAT QueueFormat;
		if (!FnFormatNameToQueueFormat(m_strFormatName, &QueueFormat, &pStrToFree))
		{
			MessageDSError(MQ_ERROR_ILLEGAL_FORMATNAME, IDS_OP_SET_PROPERTIES_OF, m_strFormatName);
			return FALSE;
		}

        ASSERT(QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PUBLIC);

		hr = ADSetObjectPropertiesGuid(
				   eQUEUE,
				   m_fLocalMgmt ? MachineDomain() : GetDomainController(m_strDomainController),
				   m_fLocalMgmt ? false : true,		// fServerName
				   &QueueFormat.PublicID(),
				   mqp.cProp,
				   mqp.aPropID,
				   mqp.aPropVar 
				   );

	}

    if (FAILED(hr))
    {     
        MessageDSError(hr, IDS_OP_SET_MULTICAST_PROPERTY, m_strName);
        return FALSE;
    }
	
    m_strInitialMulticastAddress = m_strMulticastAddress;
  
	return CMqPropertyPage::OnApply();
}

HRESULT 
CQueueMulticast::InitializeProperties( 
         CString  &strMsmqPath,                                              
         CPropMap &propMap,                 
		 CString* pstrDomainController, 
         CString* pstrFormatName /* = 0 */
         )
{
	TrTRACE(GENERAL, "InitializeProperties(), QueuePathName = %ls", strMsmqPath);

	if(!m_fLocalMgmt)
	{
		//
		// In MMC we will get the domain controller that is used by the MMC
		//
		ASSERT(pstrDomainController != NULL);
		m_strDomainController = *pstrDomainController;
		TrTRACE(GENERAL, "InitializeProperties(), domain controller = %ls", m_strDomainController);
	}

	m_strName = strMsmqPath;
    
    if (0 != pstrFormatName)
    {
	    m_strFormatName = *pstrFormatName;
    }
    else
    {
        const x_dwFormatNameMaxSize = 255;
        DWORD dwSize = x_dwFormatNameMaxSize;
        HRESULT hr = MQPathNameToFormatName(strMsmqPath, m_strFormatName.GetBuffer(x_dwFormatNameMaxSize), &dwSize); 
        m_strFormatName.ReleaseBuffer();
        if(FAILED(hr))
        {
            //
            // If failed, just display a message
            //
            MessageDSError(hr,IDS_OP_PATHNAMETOFORMAT, strMsmqPath);
            return(hr);
        }
    }                

    PROPVARIANT propVar;
    PROPID pid;

    //
    // PROPID_Q_MULTICAST_ADDRESS
    //
    pid = PROPID_Q_MULTICAST_ADDRESS;
    BOOL fFound = propMap.Lookup(pid, propVar);
	if(!fFound)
	{
		return MQ_ERROR_PROPERTY;
	}

    if (propVar.vt == VT_LPWSTR)
    {
        m_strMulticastAddress = propVar.pwszVal;
    }
    else
    {
        ASSERT(propVar.vt == VT_EMPTY);
        m_strMulticastAddress = _T("");
    }
    m_strInitialMulticastAddress = m_strMulticastAddress;
  
    return MQ_OK;
}

BOOL CQueueMulticast::IsMulticastAddressAvailable ()
{
    //
    // veriy if this property is available in AD. If not return FALSE 
    // in order DO NOT SHOW or SHOW this page GRAYED. If we decide
    // to show this page grayed it is necessary to add text box with
    // text like "This property is not available"
    //
    return TRUE;
}

void CQueueMulticast::DDV_ValidMulticastAddress(CDataExchange* pDX)
{
    if (!pDX->m_bSaveAndValidate)
        return;

    //
    // do nothing if string is empty
    //
    if (m_strMulticastAddress == _T(""))
        return;

    //
    // verify here if the new value is valid. If it is wrong
    // call MessageDSError and then return FALSE;
    //    

    MULTICAST_ID id;
    try
    {        
        LPCWSTR p = FnParseMulticastString(m_strMulticastAddress, &id);
		if(*p != L'\0')
			throw bad_format_name(p);
    }
    catch(const bad_format_name&)
    {        
        MessageDSError(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, IDS_OP_SET_MULTICAST_PROPERTY, m_strName);
        pDX->Fail();
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\qgeneral.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    qgeneral.cpp

Abstract:

    Queue/General property page implementation

Author:

    Yoel Arnon (yoela)

--*/
#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "cpropmap.h"
#include "mqPPage.h"
#include "QGeneral.h"
#include "tr.h"

#include "qgeneral.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CQueueGeneral property page

IMPLEMENT_DYNCREATE(CQueueGeneral, CMqPropertyPage)

CQueueGeneral::CQueueGeneral(
		BOOL fPrivate /* = FALSE */,
		BOOL fLocalMgmt /* = FALSE */
		) : 
    CMqPropertyPage(CQueueGeneral::IDD)
{
	m_fTransactional = FALSE;
    m_fPrivate = fPrivate;
    m_fLocalMgmt = fLocalMgmt;
	//{{AFX_DATA_INIT(CQueueGeneral)
	m_strName = _T("");
	m_strLabel = _T("");
	m_guidID = GUID_NULL;
	m_guidTypeID = GUID_NULL;
	m_fAuthenticated = FALSE;
	m_fJournal = FALSE;
	m_lBasePriority = 0;
	m_iPrivLevel = -1;
	//}}AFX_DATA_INIT

}

CQueueGeneral::~CQueueGeneral()
{
}

void CQueueGeneral::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (!pDX->m_bSaveAndValidate)
    {
        CString strYesNo;
        strYesNo.LoadString(m_fTransactional ? IDS_TRANSACTIONAL_Q : IDS_NONTRANSACTIONAL_Q);
    	DDX_Text(pDX, IDC_QGENERAL_TRANSACTIONAL, strYesNo);
    }
    //
    // Save last values for comparison
    //
	//{{AFX_DATA_MAP(CQueueGeneral)
	DDX_Control(pDX, IDC_QGENERAL_ICON, m_staticIcon);
	DDX_Control(pDX, IDC_BASEPRIORITY_SPIN, m_spinPriority);
	DDX_Text(pDX, IDC_QGENERAL_NAME, m_strName);
	DDX_Text(pDX, IDC_QGENERAL_QLABEL, m_strLabel);
	DDX_Text(pDX, IDC_QGENERAL_ID, m_guidID);
	DDX_Text(pDX, IDC_QGENERAL_TYPEID, m_guidTypeID);
	DDX_Check(pDX, IDC_QMESSAGES_AUTHENTICATED, m_fAuthenticated);
	DDX_Check(pDX, IDC_QMESSAGES_JOURNAL, m_fJournal);
	DDX_Text(pDX, IDC_QUEUE_BASEPRIORITY, m_lBasePriority);
	DDV_MinMaxLong(pDX, m_lBasePriority, MIN_BASE_PRIORITY, MAX_BASE_PRIORITY);
	DDX_CBIndex(pDX, IDC_QMESSAGES_PRIVLEVEL, m_iPrivLevel);
	//}}AFX_DATA_MAP
	DDX_NumberOrInfinite(pDX, IDC_QMESSAGES_QUOTA, IDC_QUEUE_MQUOTA_CHECK, m_dwQuota);
	DDX_NumberOrInfinite(pDX, IDC_QMESSAGES_JOURNAL_QUOTA, IDC_QUEUE_JQUOTA_CHECK, m_dwJournalQuota);
}


BEGIN_MESSAGE_MAP(CQueueGeneral, CMqPropertyPage)
	//{{AFX_MSG_MAP(CQueueGeneral)
	ON_EN_CHANGE(IDC_QGENERAL_QLABEL, OnChangeRWField)
	ON_BN_CLICKED(IDC_QUEUE_MQUOTA_CHECK, OnQueueMquotaCheck)
	ON_EN_CHANGE(IDC_QGENERAL_TYPEID, OnChangeRWField)
	ON_EN_CHANGE(IDC_QMESSAGES_QUOTA, OnChangeRWField)
	ON_BN_CLICKED(IDC_QMESSAGES_AUTHENTICATED, OnChangeRWField)
	ON_CBN_SELCHANGE(IDC_QMESSAGES_PRIVLEVEL, OnChangeRWField)
	ON_EN_CHANGE(IDC_QUEUE_BASEPRIORITY, OnChangeRWField)
	ON_BN_CLICKED(IDC_QMESSAGES_JOURNAL, OnChangeRWField)
	ON_EN_CHANGE(IDC_QMESSAGES_JOURNAL_QUOTA, OnChangeRWField)
	ON_BN_CLICKED(IDC_QUEUE_JQUOTA_CHECK, OnQueueJquotaCheck)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQueueGeneral message handlers

BOOL CQueueGeneral::OnInitDialog() 
{
    //
    // This closure is used to keep the DLL state. For UpdateData we need
    // the mmc.exe state.
    //
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        //
        // Initialize the privacy level combo box
        //
        CComboBox *ccomboPrivLevel = (CComboBox *)GetDlgItem(IDC_QMESSAGES_PRIVLEVEL);

        //
        // Note: Order must be the same as the order of the constants
        //       MQ_PRIV_LEVEL_NONE, OPTIONAL and BODY. We assume that 
        //       MQ_PRIV_LEVEL_NONE is zero, and the rest are consecutive.
        //
        UINT uiPrivacyValues[] = {IDS_QUEUE_ENCRYPT_NONE, 
                                  IDS_QUEUE_ENCRYPT_OPTIONAL, 
                                  IDS_QUEUE_ENCRYPT_BODY};

        CString strValueToInsert;

        for (UINT i=0; i<(sizeof(uiPrivacyValues) / sizeof(uiPrivacyValues[0])); i++)
        {
            VERIFY(strValueToInsert.LoadString(uiPrivacyValues[i]));
            VERIFY(CB_ERR != ccomboPrivLevel->AddString(strValueToInsert));
        }
    
        VERIFY(CB_ERR != ccomboPrivLevel->SetCurSel(m_iPrivLevel));  
        
        //
        // Hide ID for private queue
        //
        if (m_fPrivate)
        {
            GetDlgItem(IDC_QGENERAL_ID)->ShowWindow(FALSE);
            GetDlgItem(IDC_QGENERAL_ID_LABEL)->ShowWindow(FALSE);
            GetDlgItem(IDC_QUEUE_BASEPRIORITY)->ShowWindow(FALSE);
            GetDlgItem(IDC_QUEUE_BASEPRIORITY_LABEL)->ShowWindow(FALSE);
            GetDlgItem(IDC_BASEPRIORITY_SPIN)->ShowWindow(FALSE);
        }
    }


	UpdateData( FALSE );

    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        if (m_fPrivate)
        {
            m_staticIcon.SetIcon(LoadIcon(g_hResourceMod, (LPCTSTR)IDI_PRIVATE_QUEUE));
        }

        m_spinPriority.SetRange(MIN_BASE_PRIORITY, MAX_BASE_PRIORITY);
        m_fModified = FALSE;
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CQueueGeneral::OnApply() 
{
    if (!m_fModified)
    {
        return TRUE;
    }
    //
    // BugBug Can we check what really changed and set only that? Does it matter?
    //
	PROPID paPropid[] = 
        {PROPID_Q_LABEL, PROPID_Q_TYPE,  PROPID_Q_QUOTA, PROPID_Q_AUTHENTICATE, 
         PROPID_Q_JOURNAL, PROPID_Q_JOURNAL_QUOTA, 
         PROPID_Q_PRIV_LEVEL, 
         
         //
         // Begin public only properties - remember to change x_iNumPublicOnlyProps
         // If you add properties hee
         //
         PROPID_Q_BASEPRIORITY};

	const DWORD x_iNumPublicOnlyProps = 1;

	const DWORD x_iPropCount = sizeof(paPropid) / sizeof(paPropid[0]);
	PROPVARIANT apVar[x_iPropCount];
    
	DWORD iProperty = 0;
	//
	// PROPID_Q_LABEL
	//
    ASSERT(PROPID_Q_LABEL == paPropid[iProperty]);
    apVar[iProperty].vt = VT_LPWSTR;
	apVar[iProperty++].pwszVal = (LPWSTR)(LPCWSTR)m_strLabel;

	//
	// PROPID_Q_TYPE
	//
    ASSERT(PROPID_Q_TYPE == paPropid[iProperty]);
    apVar[iProperty].vt = VT_CLSID;
	apVar[iProperty++].puuid = &m_guidTypeID;

    //
    // PROPID_Q_QUOTA
    //
    ASSERT(PROPID_Q_QUOTA == paPropid[iProperty]);
    apVar[iProperty].vt = VT_UI4;
	apVar[iProperty++].ulVal = m_dwQuota ;
    
    //
    // PROPID_Q_AUTHENTICATE
    //
    ASSERT(PROPID_Q_AUTHENTICATE == paPropid[iProperty]);
    apVar[iProperty].vt = VT_UI1;
	apVar[iProperty++].bVal = (UCHAR)m_fAuthenticated;
     
    //
    // PROPID_Q_JOURNAL
    // 
    ASSERT(PROPID_Q_JOURNAL == paPropid[iProperty]);
    apVar[iProperty].vt = VT_UI1;
	apVar[iProperty++].bVal = (UCHAR)m_fJournal;
    
    //
    // PROPID_Q_JOURNAL_QUOTA
    //
    ASSERT(PROPID_Q_JOURNAL_QUOTA == paPropid[iProperty]);
    apVar[iProperty].vt = VT_UI4;
	apVar[iProperty++].ulVal = m_dwJournalQuota;
    
    //
    // PROPID_Q_PRIV_LEVEL
    //
    ASSERT(PROPID_Q_PRIV_LEVEL == paPropid[iProperty]);
    apVar[iProperty].vt = VT_UI4;
	apVar[iProperty++].ulVal = m_iPrivLevel;

    //
    // Public only properties
    //
    if (!m_fPrivate)
    {
        //
        // PROPID_Q_BASEPRIORITY
        //
        ASSERT(PROPID_Q_BASEPRIORITY == paPropid[iProperty]);
        apVar[iProperty].vt = VT_I2;
	    apVar[iProperty++].iVal = (short)m_lBasePriority;
    }

    HRESULT hr = MQ_OK;

    MQQUEUEPROPS mqp = {x_iPropCount, paPropid, apVar, 0};

    if (m_fPrivate)
    {
        //
        // For private queue, we do not want to set the public only properties
        //
        mqp.cProp -= x_iNumPublicOnlyProps;
    }

	if(m_fPrivate)
	{
		hr = MQSetQueueProperties(m_strFormatName, &mqp);
	}
	else
	{
		ASSERT(m_guidID != GUID_NULL);

		hr = ADSetObjectPropertiesGuid(
				   eQUEUE,
				   m_fLocalMgmt ? MachineDomain() : GetDomainController(m_strDomainController),
				   m_fLocalMgmt ? false : true,		// fServerName
				   &m_guidID,
				   mqp.cProp,
				   mqp.aPropID,
				   mqp.aPropVar 
				   );

	}

    if (FAILED(hr))
    {
        MessageDSError(hr, IDS_OP_SET_PROPERTIES_OF, m_strName);
        return FALSE;
    }
	
	return CMqPropertyPage::OnApply();
}

void CQueueGeneral::OnQueueMquotaCheck() 
{
	OnNumberOrInfiniteCheck(this, IDC_QMESSAGES_QUOTA, IDC_QUEUE_MQUOTA_CHECK);	
    OnChangeRWField();
}

void CQueueGeneral::OnQueueJquotaCheck() 
{
	OnNumberOrInfiniteCheck(this, IDC_QMESSAGES_JOURNAL_QUOTA, IDC_QUEUE_JQUOTA_CHECK);	
    OnChangeRWField();
}


HRESULT 
CQueueGeneral::InitializeProperties(
		CString &strMsmqPath, 
		CPropMap &propMap, 
		CString* pstrDomainController, 
        CString* pstrFormatName /* = 0 */
		)
{
	TrTRACE(GENERAL, "InitializeProperties(), QueuePathName = %ls", strMsmqPath);

	if(!m_fLocalMgmt)
	{
		//
		// In MMC we will get the domain controller that is used by the MMC
		//
		ASSERT(pstrDomainController != NULL);
		m_strDomainController = *pstrDomainController;
		TrTRACE(GENERAL, "InitializeProperties(), domain controller = %ls", m_strDomainController);
	}

	m_strName = strMsmqPath;
    if (0 != pstrFormatName)
    {
	    m_strFormatName = *pstrFormatName;
    }
    else
    {
        const x_dwFormatNameMaxSize = 255;
        DWORD dwSize = x_dwFormatNameMaxSize;
        HRESULT hr = MQPathNameToFormatName(strMsmqPath, m_strFormatName.GetBuffer(x_dwFormatNameMaxSize), &dwSize); 
        m_strFormatName.ReleaseBuffer();
        if(FAILED(hr))
        {
            //
            // If failed, just display a message
            //
            MessageDSError(hr,IDS_OP_PATHNAMETOFORMAT, strMsmqPath);
            return(hr);
        }
    }

    PROPVARIANT propVar;
    PROPID pid;

	//
	// PROPID_Q_INSTANCE
	//
    if (m_fPrivate)
    {
    	m_guidID = GUID_NULL;
    }
    else
    {
        pid = PROPID_Q_INSTANCE;
        VERIFY(propMap.Lookup(pid, propVar));
    	m_guidID = *propVar.puuid;
    }

	//
	// PROPID_Q_LABEL
	//
    pid = PROPID_Q_LABEL;
    VERIFY(propMap.Lookup(pid, propVar));
    m_strLabel = propVar.pwszVal;

	//
	// PROPID_Q_TYPE
	//
    pid = PROPID_Q_TYPE;
    VERIFY(propMap.Lookup(pid, propVar));
	m_guidTypeID = *propVar.puuid;

    //
    // PROPID_Q_QUOTA
    //
    pid = PROPID_Q_QUOTA;
    VERIFY(propMap.Lookup(pid, propVar));
	m_dwQuota = propVar.ulVal;
    
    //
    // PROPID_Q_AUTHENTICATE
    //
    pid = PROPID_Q_AUTHENTICATE;
    VERIFY(propMap.Lookup(pid, propVar));
	m_fAuthenticated = propVar.bVal;
    
    //
    // PROPID_Q_TRANSACTION
    //
    pid = PROPID_Q_TRANSACTION;
    VERIFY(propMap.Lookup(pid, propVar));
	m_fTransactional = propVar.bVal;
     
    //
    // PROPID_Q_JOURNAL
    // 
    pid = PROPID_Q_JOURNAL;
    VERIFY(propMap.Lookup(pid, propVar));
	m_fJournal = propVar.bVal;
    
    //
    // PROPID_Q_JOURNAL_QUOTA
    //
    pid = PROPID_Q_JOURNAL_QUOTA;
    VERIFY(propMap.Lookup(pid, propVar));
	m_dwJournalQuota = propVar.ulVal;
    
    //
    // PROPID_Q_PRIV_LEVEL
    //
    pid = PROPID_Q_PRIV_LEVEL;
    VERIFY(propMap.Lookup(pid, propVar));
	m_iPrivLevel = propVar.ulVal;

    //
    // PROPID_Q_BASEPRIORITY
    //
    pid = PROPID_Q_BASEPRIORITY;
    VERIFY(propMap.Lookup(pid, propVar));
	m_lBasePriority = propVar.iVal;

    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\qext.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	qext.h

Abstract:

	Definition for the queue extension snapnin node class.

Author:

    RaphiR

--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __QEXT_H_
#define __QEXT_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"


#include "icons.h"

/****************************************************

        CSnapinQueue Class
    
 ****************************************************/

class CSnapinQueue : public CNodeWithScopeChildrenList<CSnapinQueue, TRUE>
{
public:

    CString     m_pwszQueueName;            // Queue name
    WCHAR       m_szFormatName[256];        // Format name
    HRESULT     m_hrError;

   	BEGIN_SNAPINCOMMAND_MAP(CSnapinQueue, FALSE)
	END_SNAPINCOMMAND_MAP()

    CSnapinQueue(CSnapInItem * pParentNode, CSnapin * pComponentData, LPCWSTR lpcwstrLdapName);
    void Init(LPCWSTR lpcwstrLdapName);

	~CSnapinQueue()
    {
    }

	virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT OnRemoveChildren( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			);

    STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream);

private:
	BOOL    m_fDontExpand;
protected:
	CString m_strMsmqPathName;
};



/****************************************************

        CQueueExtData Class
    
 ****************************************************/

class CQueueExtData : public CSnapInItemImpl<CQueueExtData, TRUE>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;


    CSnapin *   m_pComponentData;

	BEGIN_SNAPINCOMMAND_MAP(CQueueExtData, FALSE)
	END_SNAPINCOMMAND_MAP()

	BEGIN_SNAPINTOOLBARID_MAP(CQueueExtData)
		// Create toolbar resources with button dimensions 16x16 
		// and add an entry to the MAP. You can add multiple toolbars
		// SNAPINTOOLBARID_ENTRY(Toolbar ID)
	END_SNAPINTOOLBARID_MAP()

	CQueueExtData()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CQueueExtData();

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES /*type*/)
	{
		//if (type == CCT_SCOPE || type == CCT_RESULT)
		//	return S_OK;
		return S_FALSE;
	}

    IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* /*pDefault*/)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault);
    
    void RemoveAllChildrens(void);

    void RemoveChild(CString& strQName);


private:

    CMap< CString, LPCWSTR, CSnapinQueue*, CSnapinQueue* > m_mapQueues;


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\qnmsprov.cpp ===
/*++

Copyright (c) 1995 - 2001 Microsoft Corporation

Module Name:

    qnmsprov.cpp

Abstract:

    Implelentation of objects that represent a list 
	of queues (caches or from DS).

Author:

    Nela Karpel (nelak) 26-Jul-2001

Environment:

    Platform-independent.

--*/

#include "stdafx.h"
#include "rt.h"
#include "mqutil.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "cpropmap.h"
#include "dsext.h"
#include "mqPPage.h"
#include "qname.h"
#include "lqDsply.h"
#include "localadm.h"
#include "dataobj.h"
#include "qnmsprov.h"

#include "qnmsprov.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


void CopyManagementFromDsPropsAndClear(MQMGMTPROPS *pmqQProps, PROPVARIANT *apvar)
{
    for (DWORD i=0; i<pmqQProps->cProp; i++)
    {
        for (DWORD j=0; j<x_dwMgmtToDsSize; j++)
        {
            if (pmqQProps->aPropID[i] == x_aMgmtToDsProps[j].pidMgmtPid)
            {
                pmqQProps->aPropVar[i] = apvar[j];
                apvar[j].vt = VT_NULL; //Do not destruct this element
            }
        }
    }
}


//////////////////////////////////////////////////////////////////////////////
// CQueueNames class
//
LONG CQueueNames::AddRef()
{
    return InterlockedIncrement(&m_lRef);
};


LONG CQueueNames::Release()
{
    InterlockedDecrement(&m_lRef);
    if (0 == m_lRef)
    {
        delete this;
        return 0; // We cannot return m_lRef - it is not valid after delete this
    }
    return m_lRef;
};


HRESULT CQueueNames::InitiateNewInstance(CString &strMachineName)
{
    m_szMachineName = strMachineName;
    HRESULT hr = Init(strMachineName);
    return hr;
};


HRESULT CQueueNames::GetOpenQueueProperties(CString &szMachineName, CString &szFormatName, MQMGMTPROPS *pmqQProps)
{
	CString szObjectName = L"QUEUE=" + szFormatName;
	HRESULT hr = MQMgmtGetInfo((szMachineName == TEXT("")) ? (LPCWSTR)NULL : szMachineName, szObjectName, pmqQProps);

	if(FAILED(hr))
	{
        return hr;
	}

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// CCachedQueueNames class
//
CCachedQueueNames::CCachedQueueNames() :
    m_nQueue(0)
{
    memset(&m_calpwstrQFormatNames, 0, sizeof(m_calpwstrQFormatNames));
}


CCachedQueueNames::~CCachedQueueNames()
{
    for (DWORD i=0; i<m_calpwstrQFormatNames.cElems; i++)
    {
        MQFreeMemory(m_calpwstrQFormatNames.pElems[i]);
    }

    MQFreeMemory(m_calpwstrQFormatNames.pElems);
}


HRESULT CCachedQueueNames::GetNextQueue(CString &strQueueFormatName, CString &strQueuePathName, MQMGMTPROPS *pmqQProps)
{
    if (0 == m_calpwstrQFormatNames.pElems)
    {
        ASSERT(0);
        return E_UNEXPECTED;
    }

    if (m_nQueue >= m_calpwstrQFormatNames.cElems)
    {
        strQueueFormatName = TEXT("");
        return S_OK;
    }

    strQueueFormatName = m_calpwstrQFormatNames.pElems[m_nQueue];
    m_nQueue++;

    //
    // We do not return the pathname when reading from cache
    //
    strQueuePathName = TEXT("");

    return GetOpenQueueProperties(m_szMachineName, strQueueFormatName, pmqQProps);
}

HRESULT CCachedQueueNames::Init(CString &strMachineName)
{       
    HRESULT hr = S_OK;
    CString strTitle;

	MQMGMTPROPS	  mqProps;
    PROPVARIANT   propVar;

	//
	// Retreive the open queues of the QM
	//
    PROPID  propId = PROPID_MGMT_MSMQ_ACTIVEQUEUES;
    propVar.vt = VT_NULL;

	mqProps.cProp = 1;
	mqProps.aPropID = &propId;
	mqProps.aPropVar = &propVar;
	mqProps.aStatus = NULL;

    hr = MQMgmtGetInfo((strMachineName == TEXT("")) ? (LPCWSTR)NULL : strMachineName, MO_MACHINE_TOKEN, &mqProps);

    if(FAILED(hr))
    {
        //
        // If failed, just display a message
        //
        MessageDSError(hr,IDS_NOCONNECTION_TO_SRVICE);
        return(hr);
    }

	ASSERT(propVar.vt == (VT_VECTOR | VT_LPWSTR));
	
	//
	// Sort the queues by their name
	//
	qsort(propVar.calpwstr.pElems, propVar.calpwstr.cElems, sizeof(WCHAR *), QSortCompareQueues);

    m_calpwstrQFormatNames = propVar.calpwstr;

    return hr;
}




//////////////////////////////////////////////////////////////////////////////
// CDsPublicQueueNames class
//

//
// Copy a management properties structure from a DS props structure.
// Assume that the DS props are organized according to x_aMgmtToDsProps
// Clears the DS prop's vt so it will not be auto destructed.
//
CDsPublicQueueNames::~CDsPublicQueueNames()
{
    DestructElements(m_apvarCache, m_dwNumPropsInQueuesCache);
};


HRESULT CDsPublicQueueNames::GetNextQueue(CString &strQueueFormatName, CString &strQueuePathName, MQMGMTPROPS *pmqQProps)
{
    ASSERT (0 != (DSLookup *)m_pdslookup);

    HRESULT hr = MQ_OK;

    if (m_dwCurrentPropIndex >= m_dwNumPropsInQueuesCache)
    {
        //
        // Clear the previous cache and read from DS
        //
        DestructElements(m_apvarCache, m_dwNumPropsInQueuesCache);
        m_dwNumPropsInQueuesCache = 0;
        DWORD dwNumProps = sizeof(m_apvarCache) / sizeof(m_apvarCache[0]);
        for (DWORD i=0; i<dwNumProps; i++)
        {
            m_apvarCache[i].vt = VT_NULL;
        }

        hr = m_pdslookup->Next(&dwNumProps, m_apvarCache);
        m_dwNumPropsInQueuesCache = dwNumProps;
        m_dwCurrentPropIndex = 0;
        if FAILED(hr)
        {
            return hr;
        }
        if (0 == dwNumProps)
        {
            strQueueFormatName = TEXT("");
            return S_OK;
        }
    }

    //
    // Point to the current section in cache
    //
    PROPVARIANT *apvar = m_apvarCache + m_dwCurrentPropIndex;
    m_dwCurrentPropIndex += x_dwMgmtToDsSize;

    //
    // The queue instance guid appears at x_dwMgmtToDsQInstanceIndex
    //
    ASSERT(apvar[x_dwMgmtToDsQInstanceIndex].vt == VT_CLSID);
    CString szFormatName;
    szFormatName.Format(
    FN_PUBLIC_TOKEN     // "PUBLIC"
        FN_EQUAL_SIGN   // "="
        GUID_FORMAT,     // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
    GUID_ELEMENTS(apvar[x_dwMgmtToDsQInstanceIndex].puuid)
    );

    //
    // Put the format name into the output var
    //
    strQueueFormatName = szFormatName;

    //
    // Put the pathname into the output var
    //
    ASSERT(apvar[x_dwMgmtToDsQPathNameIndex].vt == VT_LPWSTR);
    strQueuePathName = apvar[x_dwMgmtToDsQPathNameIndex].pwszVal;

    //
    // If the queue is open - retrieve the dynamic properties
    //
    hr = GetOpenQueueProperties(m_szMachineName, strQueueFormatName, pmqQProps);
    if FAILED(hr)
    {
        //
        // We cannot get dynamic properties of the queue - it is probably not open.
        // We will try to fill it what we can using static properties
        //
        CopyManagementFromDsPropsAndClear(pmqQProps, apvar);

        return S_OK;
    }

    return hr;
}


HRESULT CDsPublicQueueNames::Init(CString &strMachineName)
{ 
    //
    // Find the computer's GUID so we can look for queues
    //
    PROPID pid = PROPID_QM_MACHINE_ID;
    PROPVARIANT pvar;
    pvar.vt = VT_NULL;
    
    HRESULT hr = ADGetObjectProperties(
                    eMACHINE,
                    MachineDomain(strMachineName),
					false,	// fServerName
                    strMachineName, 
                    1, 
                    &pid, 
                    &pvar
                    );
    if FAILED(hr)
    {
        if (hr != MQDS_OBJECT_NOT_FOUND)
        {
            //
            // Real error. Return.
            //
            return hr;
        }
        //
        // This may be an NT4 server, and we may be using a full DNS name. Try again with
        // Netbios name  (fix for 5076, YoelA, 16-Sep-99)
        //
        CString strNetBiosName;
        if (!GetNetbiosName(strMachineName, strNetBiosName))
        {
            //
            // Already a netbios name. No need to proceed
            //
            return hr;
        }
        
        hr = ADGetObjectProperties(
                    eMACHINE,
                    MachineDomain(strMachineName),
					false,	// fServerName
                    strNetBiosName, 
                    1, 
                    &pid, 
                    &pvar
                    );
        if FAILED(hr)
        {
            //
            // No luck with Netbios name as well... return
            //
            return hr;
        }
    }

    ASSERT(pvar.vt == VT_CLSID);
    GUID guidQM = *pvar.puuid;
    MQFreeMemory(pvar.puuid);

	//
    // Query the DS for all the queues under the current computer
    //
    CRestriction restriction;
    restriction.AddRestriction(&guidQM, PROPID_Q_QMID, PREQ);

    CColumns columns;
    for (int i=0; i<x_dwMgmtToDsSize; i++)
    {
        columns.Add(x_aMgmtToDsProps[i].pidDsPid);
    }        
    
    HANDLE hEnume;
    {
        CWaitCursor wc; //display wait cursor while query DS
        hr = ADQueryMachineQueues(
                MachineDomain(strMachineName),
				false,		// fServerName
                &guidQM,
                columns.CastToStruct(),
                &hEnume
                );
    }
    
    m_pdslookup = new DSLookup(hEnume, hr);

    if (!m_pdslookup->HasValidHandle())
    {
        hr = m_pdslookup->GetStatusCode();
        delete m_pdslookup.detach();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\qname.cpp ===
// QName.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqutil.h"
#include "mqsnap.h"
#include "globals.h"
#include "mqppage.h"
#include "QName.h"

#include "qname.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CQueueName dialog


CQueueName::CQueueName(
	CString &strComputerName, 
	CString strContainerDispFormat /* = "" */, 
	BOOL fPrivate /* = FALSE */
	): 
CMqPropertyPage(CQueueName::IDD, fPrivate ? IDS_NEW_PRIVATE_QUEUE : 0),
    m_fPrivate(fPrivate),
    m_strNewPathName(_T("")),
    m_strFormatName(_T("")),
	m_strContainerDispFormat(strContainerDispFormat),
    m_hr(S_FALSE)
{
	//{{AFX_DATA_INIT(CQueueName)
	m_strQueueName = _T("");
	m_fTransactional = FALSE;
	m_strPrivatePrefix = x_strPrivatePrefix;
	//}}AFX_DATA_INIT
    if (strComputerName == TEXT(""))
    {
        //
        // Local computer
        //
		DWORD dwNameBufferSize = MAX_PATH;
		m_hr = GetComputerNameInternal(
				m_strComputerName.GetBuffer(dwNameBufferSize),
				&dwNameBufferSize);
		m_strComputerName.ReleaseBuffer();
    }
    else
    {
        m_strComputerName = strComputerName;
    }

}


void
CQueueName::SetParentPropertySheet(
	CGeneralPropertySheet* pPropertySheet
	)
{
	m_pParentSheet = pPropertySheet;
}


void
CQueueName::StretchPrivateLabel(
	CStatic *pPrivateTitle,
	CEdit *pQueueNameWindow
	)
{
	CString privStr;
	pPrivateTitle->GetWindowText(privStr);

	CDC* pDC = pPrivateTitle->GetDC();
	CSize textSize = pDC->GetTextExtent(privStr);
	pPrivateTitle->ReleaseDC(pDC);

	//
	// Stretch "private$\" control to fit text
	// Distract the original control size, add the text size
	//
	RECT rectPrivTitleClient;
	RECT rectPrivTitleWindow;
	pPrivateTitle->GetClientRect(&rectPrivTitleClient);
	pPrivateTitle->GetWindowRect(&rectPrivTitleWindow);
	ScreenToClient(&rectPrivTitleWindow);

	rectPrivTitleWindow.right = rectPrivTitleWindow.right - rectPrivTitleClient.right + textSize.cx;
	pPrivateTitle->MoveWindow(&rectPrivTitleWindow);

	//
	// Move queue pathname edit box
	//
	RECT rectEdit;
	pQueueNameWindow->GetWindowRect(&rectEdit);
	ScreenToClient(&rectEdit);
	
	rectEdit.left += textSize.cx;
	rectEdit.right += textSize.cx;
	pQueueNameWindow->MoveWindow(&rectEdit);
}


void CQueueName::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CQueueName)
	DDX_Control(pDX, IDC_PUBLIC_QUEUE_ICON, m_staticIcon);
	DDX_Text(pDX, IDC_QUEUENAME, m_strQueueName);
	DDX_Check(pDX, IDC_TRANSACTIONAL, m_fTransactional);
	DDX_Text(pDX, IDC_QNAME_PRIVATE_TITLE, m_strPrivatePrefix);
	//}}AFX_DATA_MAP
}

CString &CQueueName::GetFullQueueName()
{
    static CString strFullQueueName;
    if (m_fPrivate)
    {
        strFullQueueName = x_strPrivatePrefix + m_strQueueName;
    }
    else
    {
        strFullQueueName = m_strQueueName;
    }

    return strFullQueueName;
}

BEGIN_MESSAGE_MAP(CQueueName, CMqPropertyPage)
	//{{AFX_MSG_MAP(CQueueName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQueueName message handlers

BOOL CQueueName::OnInitDialog() 
{

	CMqPropertyPage::OnInitDialog();

	CStatic *pPrivateTitle = (CStatic *)GetDlgItem(IDC_QNAME_PRIVATE_TITLE);
    if (m_fPrivate)
    {
		AFX_MANAGE_STATE(AfxGetStaticModuleState());

		SetDlgItemText(IDC_QUEUE_CONTAINER, m_strComputerName);
        m_staticIcon.SetIcon(LoadIcon(g_hResourceMod, (LPCTSTR)IDI_PRIVATE_QUEUE));

		CEdit *pQueueNameWindow = (CEdit*)GetDlgItem(IDC_QUEUENAME);
		StretchPrivateLabel(pPrivateTitle, pQueueNameWindow);
		
    }
    else
    {

		CString strTitle;
		if ( m_strContainerDispFormat != L"" )
		{
			SetDlgItemText(IDC_QUEUE_CONTAINER, m_strContainerDispFormat);
		}
		else
		{
			SetDlgItemText(IDC_QUEUE_CONTAINER, m_strComputerName);
		}

		pPrivateTitle->ShowWindow(FALSE);
    }
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CQueueName::OnSetActive() 
{
	ASSERT((L"No parent property sheet", m_pParentSheet != NULL));
	return m_pParentSheet->SetWizardButtons();
}


BOOL CQueueName::OnWizardFinish() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (0 == UpdateData(TRUE))
    {
        //
        // Update data failed
        //
        return FALSE;
    }

    m_hr = CreateEmptyQueue(
            GetFullQueueName(),
            m_fTransactional,
            m_strComputerName, 
            m_strNewPathName,
            &m_strFormatName
            );

    if(FAILED(m_hr))
    {
		if ( m_hr == MQ_ERROR_PROPERTY )
		{
			// 
			// Queue path name is the only property on this dialog - convert 
			// it just to be user friendly
			//
			m_hr = MQ_ERROR_ILLEGAL_QUEUE_PATHNAME;
		}

        MessageDSError(m_hr, IDS_OP_CREATE, m_strQueueName);
        return FALSE;
    }

    return CMqPropertyPage::OnWizardFinish();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\qname.h ===
#ifndef _NEW_QUEUE_NAME
#define _NEW_QUEUE_NAME

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// QName.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CQueueName dialog

class CQueueName : public CMqPropertyPage
{
// Construction
public:
	CQueueName(CString &strComputerName, CString m_strContainerDispFormat = L"", BOOL fPrivate=FALSE);

// Dialog Data
	//{{AFX_DATA(CQueueName)
	enum { IDD = IDD_QUEUENAME };
	CStatic	m_staticIcon;
	CString	m_strQueueName;
	BOOL	m_fTransactional;
	CString	m_strPrivatePrefix;
	//}}AFX_DATA

    CString &GetNewQueuePathName()
    {
        return m_strNewPathName;
    };

    CString &GetNewQueueFormatName()
    {
        return m_strFormatName;
    };

    HRESULT GetStatus()
    {
        return m_hr;
    };

	void
	SetParentPropertySheet(
		CGeneralPropertySheet* pPropertySheet
		);

	// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CQueueName)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    CString &GetFullQueueName();
    BOOL m_fPrivate;
    CString m_strNewPathName;
    CString m_strFormatName;
    HRESULT m_hr;
    CString m_strComputerName;
	CString m_strContainerDispFormat;

	// Generated message map functions
	//{{AFX_MSG(CQueueName)
	virtual BOOL OnInitDialog();
	virtual BOOL OnWizardFinish();
	virtual BOOL OnSetActive();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	
	void
	CQueueName::StretchPrivateLabel(
		CStatic *pPrivateTitle,
		CEdit *pQueueNameWindow
		);

private:

	CGeneralPropertySheet* m_pParentSheet;

};

const LPTSTR x_strPrivatePrefix=TEXT("private$\\");


#endif // _NEW_QUEUE_NAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\rdmsg.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

   rdmsg.cpp

Abstract:

   Implementation file for the CReadMsg snapin node class

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "mqprops.h"
#include "mqutil.h"
#include "_mqdef.h"
#include "rt.h"
#include "mqsnap.h"
#include "snapin.h"
#include "mqppage.h"
#include "rdmsg.h"
#include "globals.h"
#include "message.h"
#include "mqcast.h"

#include "rdmsg.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern const PropertyDisplayItem MessageDisplayList[];


/////////////////////////////////////////////////////////////////////////////
// CReadMsg
// {B3351249-BEFC-11d1-9B9B-00E02C064C39}
static const GUID CReadMsgGUID_NODETYPE =
{ 0xb3351249, 0xbefc, 0x11d1, { 0x9b, 0x9b, 0x0, 0xe0, 0x2c, 0x6, 0x4c, 0x39 } };

const GUID*  CReadMsg::m_NODETYPE = &CReadMsgGUID_NODETYPE;
const OLECHAR* CReadMsg::m_SZNODETYPE = OLESTR("B3351249-BEFC-11d1-9B9B-00E02C064C39");
const OLECHAR* CReadMsg::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CReadMsg::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;


//////////////////////////////////////////////////////////////////////////////
/*++

CReadMsg::InsertColumns

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CReadMsg::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return InsertColumnsFromDisplayList(pHeaderCtrl, MessageDisplayList);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CReadMsg::OpenQueue

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CReadMsg::OpenQueue(DWORD dwAccess, HANDLE *phQueue)
{
    HRESULT rc;    
    rc = MQOpenQueue(
            m_szFormatName,
            dwAccess,
            0,
            phQueue
            );
    return rc;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CReadMsg::PopulateResultChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CReadMsg::PopulateResultChildrenList()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CWaitCursor wc;

	HRESULT  hr;	

	// Check for preconditions:
	// None.

    //
    // Read the messages
    //
    DWORD cProps;
    MQMSGPROPS      msgprops;
    VTHandler       *pvth;
    QUEUEHANDLE     qh;

    //
    // Open the queue
    //    
    hr = OpenQueue(MQ_PEEK_ACCESS | m_fAdminMode, &qh);
    if(FAILED(hr))
    {     
		if ( hr == MQ_ERROR_NO_DS )
		{
			DisplayErrorAndReason(IDS_OP_READMESSAGE, IDS_NO_DS_ERROR, L"", 0);
			return hr;
		}
        //
        // If failed, just display a message
        //
        MessageDSError(hr,IDS_OP_READMESSAGE);
        return(hr);
    }
              
    //
    // Create a cursor
    //
    HANDLE hCursor = 0;
    hr = MQCreateCursor(qh, &hCursor);
    if(FAILED(hr))
    {
        //
        // If failed, display the error
        MessageDSError(hr, IDS_OP_READMESSAGE);
        return(hr);
    }

    //
    // Create the 1st message object
    //
    CMessage * pMessage = new CMessage(this, m_pComponentData, m_szFormatName);

    //
    // Read all messages in queue
    //
    DWORD dwAction = MQ_ACTION_PEEK_CURRENT;
    DWORD dwMsg = 0;
    do
    {
        //
        // Prepare message properties
        //
        MsgProps * pMsgProps = new MsgProps;
        memset(pMsgProps, 0, sizeof(MsgProps));

        DWORD i = 0;
        while(MessageDisplayList[i].itemPid != 0)
        {
            pMsgProps->aPropId[i] = MessageDisplayList[i].itemPid;
            pvth = MessageDisplayList[i].pvth;
            pvth->Set(&(pMsgProps->aPropVar[i]),
                      (void *)pMsgProps,
                      MessageDisplayList[i].offset,
                      MessageDisplayList[i].size);
            i++;
        }


        cProps = i;
        msgprops.cProp    = cProps;
        msgprops.aPropID  = pMsgProps->aPropId;
        msgprops.aPropVar = pMsgProps->aPropVar;
        msgprops.aStatus  = NULL;

        //
        // Peek next message
        //
        hr = MQReceiveMessage(qh, 0, dwAction, &msgprops, NULL, NULL, hCursor, NULL);
        dwAction = MQ_ACTION_PEEK_NEXT;

        if(FAILED(hr))
        {
            switch(hr)
            {
                case MQ_ERROR_BUFFER_OVERFLOW:
                case MQ_ERROR_SENDERID_BUFFER_TOO_SMALL:
                case MQ_ERROR_SENDER_CERT_BUFFER_TOO_SMALL:
                case MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL:
                    //
                    //  In all these cases some buffers are too small, nevertheless
                    //  the buffer is filled to its extent.
                    //
                    //  It is useful to put '\0' at the end of string since in this
                    //  case we can get buffer without null-terminated string and 
                    //  it can cause GP later
                    //
                    SET_LAST_CHAR_AS_ZERO(pMsgProps->wszLabel);
                    SET_LAST_CHAR_AS_ZERO(pMsgProps->wszDestQueue);
                    SET_LAST_CHAR_AS_ZERO(pMsgProps->wszRespQueue);
                    SET_LAST_CHAR_AS_ZERO(pMsgProps->wszAdminQueue);            
                    SET_LAST_CHAR_AS_ZERO(pMsgProps->wszMultiDestFN);    
                    SET_LAST_CHAR_AS_ZERO(pMsgProps->wszMultiRespFN);

                    break;

                default:

                    //
                    // No more messages
                    //
                    delete pMessage;
                    delete pMsgProps;

                   	MQCloseCursor(hCursor);
                    MQCloseQueue(qh);
                    return(S_OK);
            }
        }

        //
        // Save the property values in the message object
        //
        pMessage->SetMsgProps(pMsgProps);

        //
        // Add the message to the result list
        //
    	AddChildToList(pMessage);

        //
        // Get ready with new message
        //
        pMessage = new CMessage(this, m_pComponentData, m_szFormatName);

        dwMsg++;

     // Bugbug. Read up to 1000 messages (we need to replace this with Virtual list
    }while(dwMsg < 1000);

    delete pMessage;

	MQCloseCursor(hCursor);
    MQCloseQueue(qh);

    return(S_OK);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CReadMsg::SetVerbs

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CReadMsg::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hr;
    //
    // Display verbs that we support
    //
    hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );


    return(hr);
}
        


//////////////////////////////////////////////////////////////////////////////
/*++

CReadMsg::OnPurge

    Called when menu item to purge the queue is selected

Note that if you want to retrieve the IConsole from the
CSnapInObjectRootBase, you should write the following code:


    CComPtr<IConsole> spConsole;

    ASSERT(pSnapInObjectRoot->m_nType == 1 || pSnapInObjectRoot->m_nType == 2);
    if(pSnapInObjectRoot->m_nType == 1)
    {
        //
        // m_nType == 1 means the IComponentData implementation
        //
        CSnapin *pCComponentData = static_cast<CSnapin *>(pSnapInObjectRoot);
        spConsole = pCComponentData->m_spConsole;
    }
    else
    {
        //
        // m_nType == 2 means the IComponent implementation
        //
        CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pSnapInObjectRoot);
        spConsole = pCComponent->m_spConsole;
    }

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CReadMsg::OnPurge(bool & /*bHandled*/, CSnapInObjectRootBase * pSnapInObjectRoot)
{

      AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Get the console pointer
    //
    CComPtr<IConsole> spConsole;

    ASSERT(pSnapInObjectRoot->m_nType == 1 || pSnapInObjectRoot->m_nType == 2);
    if(pSnapInObjectRoot->m_nType == 1)
    {
        //
        // m_nType == 1 means the IComponentData implementation
        //
        CSnapin *pCComponentData = static_cast<CSnapin *>(pSnapInObjectRoot);
        spConsole = pCComponentData->m_spConsole;
    }
    else
    {
        //
        // m_nType == 2 means the IComponent implementation
        //
        CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pSnapInObjectRoot);
        spConsole = pCComponent->m_spConsole;
    }

    int res;
    CString title;
    CString text;
    text.LoadString(IDS_CONFIRM_PURGE);
    title.LoadString(IDS_MSMQADMIN);
    spConsole->MessageBox(text, title,MB_YESNO | MB_ICONWARNING, &res);

    if(IDNO == res)
        return(S_OK);

    CWaitCursor wc;

    //
    // Open the queue for receive (MQ_RECEIVE_ACCESS)
    //
    HRESULT rc;
    HANDLE hQueue;    
    rc = OpenQueue(            
            MQ_RECEIVE_ACCESS | m_fAdminMode,            
            &hQueue
            );

    if(FAILED(rc))
    {
        MessageDSError(rc, IDS_OP_PURGE);
        return (S_OK);
    }

    rc = MQPurgeQueue(hQueue);
    if(SUCCEEDED(rc))
    {
        Notify(MMCN_REFRESH, 0, 0, m_pComponentData, NULL, CCT_RESULT);
    }
    else
    {
        MessageDSError(rc, IDS_OP_PURGE);
    }

    MQCloseQueue(hQueue);


    return(S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CReadMsg::FillData

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CReadMsg::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
	HRESULT hr = DV_E_CLIPFORMAT;
	ULONG uWritten;

	if (cf == gx_CCF_FORMATNAME)
	{
		hr = pStream->Write(
            m_szFormatName, 
            (numeric_cast<ULONG>(wcslen(m_szFormatName) + 1))*sizeof(m_szFormatName[0]), 
            &uWritten);

		return hr;
	}

   	if (cf == gx_CCF_COMPUTERNAME)
	{
		hr = pStream->Write(
            (LPCTSTR)m_szComputerName, 
            m_szComputerName.GetLength() * sizeof(WCHAR), 
            &uWritten);
		return hr;
	}


    hr = CNodeWithResultChildrenList< CReadMsg, CMessage, CSimpleArray<CMessage*>, FALSE >::FillData(cf, pStream);
	return hr;
}


CString 
CReadMsg::GetHelpLink( 
	VOID
	)
{
	CString strHelpLink;
    strHelpLink.LoadString(IDS_HELPTOPIC_MESSAGES);

	return strHelpLink;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CReadSystemMsg::GetComputerGuid

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CReadSystemMsg::GetComputerGuid()
{
    if (m_ComputerGuid != GUID_NULL)
    {
        return S_OK;
    }

    //
    // Find the computer's GUID so we can look for queues
    //
    PROPID pid = PROPID_QM_MACHINE_ID;
    PROPVARIANT pvar;
    pvar.vt = VT_NULL;
    
    HRESULT hr = ADGetObjectProperties(
                        eMACHINE,
                        GetDomainController(NULL),
						false,	// fServerName
                        m_szComputerName, 
                        1, 
                        &pid, 
                        &pvar
                        );
    if FAILED(hr)
    {
        if (hr != MQDS_OBJECT_NOT_FOUND)
        {
            //
            // Real error. Return.
            //
            return hr;
        }
        //
        // This may be an NT4 server, and we may be using a full DNS name. Try again with
        // Netbios name  (fix for 5076, YoelA, 16-Sep-99)
        //
        CString strNetBiosName;
        if (!GetNetbiosName(m_szComputerName, strNetBiosName))
        {
            //
            // Already a netbios name. No need to proceed
            //
            return hr;
        }
       
        hr = ADGetObjectProperties(
                eMACHINE,
                GetDomainController(NULL),
				false,	// fServerName
                strNetBiosName, 
                1, 
                &pid, 
                &pvar
                );

        if FAILED(hr)
        {
            //
            // No luck with Netbios name as well... return
            //
            return hr;
        }
    }

    ASSERT(pvar.vt == VT_CLSID);
    m_ComputerGuid = *pvar.puuid;
    MQFreeMemory(pvar.puuid);

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CReadSystemMsg::OpenQueue

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CReadSystemMsg::OpenQueue(DWORD dwAccess, HANDLE *phQueue)
{
    HRESULT rc;    
    rc = MQOpenQueue(
            m_szFormatName,
            dwAccess,
            0,
            phQueue
            );

    if (rc != MQ_ERROR_QUEUE_NOT_FOUND &&
        rc != MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION)
    {           
        return(rc);
    }
        
    //
    // bug 5411: we try to open system queue of NT4 machine.
    // So, we have to try with NT4 format
    //

    //
    // verify if it is local computer: if so, we run on NT5
    // and the format was NOT problem.     
    // if m_szComputerName equals to "" it means "local computer"   
    //    
    // verify if suffix is defined
    //
    if (m_szComputerName == TEXT("") ||      
        m_szSuffix == TEXT(""))
    {        
        return(rc);
    }

    //
    // get computer guid 
    //
    rc = GetComputerGuid();
    if (FAILED(rc))
    {
        return (rc);
    }
    
    //
    // try to build formatname in NT4 format:
    // MACHINE=<machine guid>;<suffix>    
    //
        
    GUID_STRING strUuid;
    MQpGuidToString(&m_ComputerGuid, strUuid);
              
    CString strNT4FormatName;
    strNT4FormatName.Format(L"%s%s%s", 
                        FN_MACHINE_TOKEN FN_EQUAL_SIGN, //MACHINE=
                        strUuid,                         //<machine guid>
                        m_szSuffix);                     //<suffix> like :JOURNAL
    
    //
    // try to open queue again
    //
    rc = MQOpenQueue(
            strNT4FormatName,
            dwAccess,
            0,
            phQueue
            );
    if (FAILED(rc))
    {        
        return(rc);
    }

    m_szFormatName = strNT4FormatName;
    return rc;
}


CString 
CReadSystemMsg::GetHelpLink( 
	VOID
	)
{
	CString strHelpLink;
    strHelpLink.LoadString(IDS_HELPTOPIC_QUEUES);

	return strHelpLink;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\qnmsprov.h ===
/*++

Copyright (c) 1995 - 2001 Microsoft Corporation

Module Name:

    qnmsprov.h

Abstract:

    Definition of objects that represent a list 
	of queues (caches or from DS).

Author:

    Nela Karpel (nelak) 26-Jul-2001

Environment:

    Platform-independent.

--*/
#pragma once
#ifndef __QNMSPROV_H_
#define __QNMSPROV_H_

#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"
#include "snpnerr.h"

void CopyManagementFromDsPropsAndClear(MQMGMTPROPS *pmqQProps, PROPVARIANT *apvar);


////////////////////////////////////////////////////////////////////////////////////////
// CQueueNames class
//
class CQueueNames
{
public:
    virtual LONG AddRef();

    virtual LONG Release();

    virtual HRESULT GetNextQueue(CString &strQueueName, CString &strQueuePathName, MQMGMTPROPS *pmqQProps) = 0;
    
	HRESULT InitiateNewInstance(CString &strMachineName);

protected:
    CQueueNames() :
         m_lRef(1)
    {};

    virtual HRESULT Init(CString &strMachineName) = 0;

    static HRESULT GetOpenQueueProperties(CString &szMachineName, CString &szFormatName, MQMGMTPROPS *pmqQProps);

    CString m_szMachineName;

private:
    long m_lRef;
};


//////////////////////////////////////////////////////////////////////////////
// CCachedQueueNames class
//
class CCachedQueueNames : public CQueueNames
{
public:
    static HRESULT CreateInstance(CQueueNames **ppqueueNamesProducer,CString &strMachineName)
    {
		*ppqueueNamesProducer = NULL;
		CQueueNames * pQueues = new CCachedQueueNames();
        HRESULT hr = pQueues->InitiateNewInstance(strMachineName);
		if FAILED(hr)
		{
	        pQueues->Release();
			return (hr);
		}
		*ppqueueNamesProducer = pQueues;
		return (MQ_OK);	
    };

    virtual HRESULT GetNextQueue(CString &strQueueFormatName, CString &strQueuePathName, MQMGMTPROPS *pmqQProps);

protected:
    virtual HRESULT Init(CString &strMachineName);

    CCachedQueueNames();
    ~CCachedQueueNames();

private:
    CALPWSTR m_calpwstrQFormatNames;
    DWORD m_nQueue;
};

//////////////////////////////////////////////////////////////////////////////
// CDsPublicQueueNames class
//
const struct 
{
    PROPID          pidMgmtPid;
    PROPID          pidDsPid;
} x_aMgmtToDsProps[] =
{
    {PROPID_MGMT_QUEUE_PATHNAME, PROPID_Q_PATHNAME}, // must be index 0 (x_dwMgmtToDsQPathNameIndex)
    {NO_PROPERTY, PROPID_Q_INSTANCE},                // must be index 1 (x_dwMgmtToDsQInstanceIndex)
    {PROPID_MGMT_QUEUE_XACT, PROPID_Q_TRANSACTION}
};

const DWORD x_dwMgmtToDsSize = sizeof(x_aMgmtToDsProps) / sizeof(x_aMgmtToDsProps[0]);
const DWORD x_dwMgmtToDsQPathNameIndex = 0;
const DWORD x_dwMgmtToDsQInstanceIndex = 1;
const DWORD x_dwQueuesCacheSize=20;


class CDsPublicQueueNames : public CQueueNames
{
public:
    static HRESULT CreateInstance(CQueueNames **ppqueueNamesProducer,CString &strMachineName)
    {
		*ppqueueNamesProducer = NULL;
		CQueueNames* pQueues = new CDsPublicQueueNames();
        HRESULT hr = pQueues->InitiateNewInstance(strMachineName);
		if FAILED(hr)
		{
			pQueues->Release();
			return (hr);
		}
		*ppqueueNamesProducer = pQueues;
		return (MQ_OK);
    };

    virtual HRESULT GetNextQueue(CString &strQueueFormatName, CString &strQueuePathName, MQMGMTPROPS *pmqQProps);


protected:
    virtual HRESULT Init(CString &strMachineName);

    CDsPublicQueueNames() :
        m_pdslookup(0) ,
        m_dwCurrentPropIndex(0),
        m_dwNumPropsInQueuesCache(0)
        {};

    ~CDsPublicQueueNames();

private:
    P<DSLookup> m_pdslookup;
    DWORD m_dwCurrentPropIndex;
    DWORD m_dwNumPropsInQueuesCache;
    PROPVARIANT m_apvarCache[x_dwMgmtToDsSize*x_dwQueuesCacheSize];
};

#endif // __QNMSPROV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\resource.h ===
#include "snapres.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\restart.cpp ===
// Restart.cpp : implementation file
//

#include "stdafx.h"
#include "mqPPage.h"
#include "resource.h"
#include "Restart.h"

#include "restart.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRestart dialog


CRestart::CRestart(CWnd* pParent /*=NULL*/)
	: CMqDialog(CRestart::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRestart)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CRestart::DoDataExchange(CDataExchange* pDX)
{
	CMqDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRestart)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRestart, CMqDialog)
	//{{AFX_MSG_MAP(CRestart)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRestart message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\rdmsg.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	rdmsg.h

Abstract:

	Definition CReadMsg snapin node class.

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////

#ifndef __MSMQRMSG_H_
#define __MSMQRMSG_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnres.h"

#include "icons.h"
#include "message.h"

class CReadMsg : public CNodeWithResultChildrenList< CReadMsg, CMessage, CSimpleArray<CMessage*>, FALSE >
{
public:

	DWORD   m_fAdminMode;		// Specifying or not MQ_ADMIN_ACCESS when opening a queue


    CReadMsg(CSnapInItem * pParentNode, CSnapin * pComponentData, LPCWSTR szFormatName, LPCWSTR szComputerName): 
            CNodeWithResultChildrenList< CReadMsg, CMessage, CSimpleArray<CMessage*>, FALSE >(pParentNode, pComponentData),
            m_szFormatName(szFormatName),
            m_szComputerName(szComputerName)
    {
		//
		// Specify that trigger scop item doesn't have any child item
		//
		m_scopeDataItem.mask |= SDI_CHILDREN;
		m_scopeDataItem.cChildren = 0;

		m_fAdminMode = 0;
	}

   	BEGIN_SNAPINCOMMAND_MAP(CReadMsg, FALSE)
		SNAPINCOMMAND_ENTRY(ID_MENUITEM_RDMSG_PURGE, OnPurge)
	END_SNAPINCOMMAND_MAP()

   	SNAPINMENUID(IDR_RDMSG_MENU)

	virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );
    
	virtual HRESULT PopulateResultChildrenList();

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream);

protected:
    CString m_szFormatName;     // Format name of the queue
	CString m_szComputerName;   // The computer that the queue belongs to, or "" for local computer
    virtual HRESULT OpenQueue(DWORD dwAccess, HANDLE *phQueue);

private:
	HRESULT OnPurge(bool &bHandled, CSnapInObjectRootBase * pObj);    
	void UpdateColumnWidth(const LPHEADERCTRL pHeader);    
	virtual CString GetHelpLink();
	
};


class CReadSystemMsg : public CReadMsg
{
public:
    CReadSystemMsg (CSnapInItem * pParentNode, CSnapin * pComponentData, LPCWSTR szFormatName, LPCWSTR szComputerName, LPCWSTR szSuffix): 
            CReadMsg(pParentNode, pComponentData, szFormatName, szComputerName),                    
            m_szSuffix(szSuffix)            
    {         
        m_ComputerGuid = GUID_NULL;
    }   
    
protected:
    virtual HRESULT OpenQueue(DWORD dwAccess, HANDLE *phQueue);  

private:
    HRESULT GetComputerGuid ();    
	virtual CString GetHelpLink();

    GUID m_ComputerGuid;
    CString m_szSuffix;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\rule.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    rule.h                                     *

Abstract:
	Definition for rule the class

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __RULE_H__
#define __RULE_H__

#include <Tr.h>
#include <Ref.h>
#include <autoptr.h>
#include <comdef.h>

#pragma warning(push, 3)
#include <list>
#pragma warning(pop)

class CRule;

typedef std::list< R<CRule> > RuleList;

class CRuleSet :public CReference
{
public:
    CRuleSet(const CString& strComputer);

    void Refresh(void);

    R<CRule> 
    AddRule(
        _bstr_t  name, 
	    _bstr_t  description,
        _bstr_t  condition,
        _bstr_t  action,
        long fShowWindow
        );

    void DeleteRule(const _bstr_t& ruleId);

    void 
    Update(
        _bstr_t  ruleid, 
        _bstr_t  name, 
	    _bstr_t  description,
        _bstr_t  condition,
        _bstr_t  action,
        bool fShowWindow
        ) throw(_com_error);

    RuleList GetRuleList(void)
    {
        return m_ruleList;
    }

private:
    IMSMQRuleSetPtr m_ruleSet;
    RuleList m_ruleList;

    bool m_fChanged;
};


class CRule : public CReference
{
public:
    CRule(
        CRuleSet* pRuleSet,
        _bstr_t  id,
        _bstr_t  name, 
	    _bstr_t  description,
        _bstr_t  condition,
        _bstr_t  action,
        bool fShowWindow
        );


    void Update(
        _bstr_t  name, 
	    _bstr_t  description,
        _bstr_t  condition,
        _bstr_t  action,
        bool fShowWindow
        ) throw(_com_error);

    
    void Update(
        _bstr_t  name
        ) throw(_com_error);


    void 
    DeleteRule(
        void
        ) throw(_com_error)
    {
        m_pRuleSet->DeleteRule(m_id);
    }


    const _bstr_t& GetRuleName(void) const
    {
        return m_name;
    }


    const _bstr_t& GetRuleDescription(void) const
    {
        return m_description;
    }


    const _bstr_t& GetRuleId(void) const
    {
        return m_id;
    }
 

    const _bstr_t& GetRuleAction(void) const
    {
        return m_action;
    }
 

    const _bstr_t& GetRuleCondition(void) const
    {
        return m_condition;
    }
 

    bool GetShowWindow(void) const
    {
        return m_fShowWindow;
    }
 

private:
    R<CRuleSet> m_pRuleSet;

    _bstr_t  m_name; 
	_bstr_t  m_description; 
    _bstr_t  m_id;
    _bstr_t  m_action;
    _bstr_t  m_condition;
    bool m_fShowWindow;
};


R<CRuleSet> GetRuleSet(const CString& strComputer);

#endif // __RULE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\ruleact.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    ruleact.h                                     

Abstract:
	Definition for the rule action class

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __RULEACT_H__
#define __RULEACT_H__

#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"
#include "snpnerr.h"


class CRuleResult;
class CNewRule;

const DWORD xMaxParameters = 256;

//
//
// CRuleParam dialog
//
//
class CRuleParam : public CMqDialog
{
// Construction
public:
    CRuleParam();

// Dialog Data
	//{{AFX_DATA(CRuleParam)
	enum { IDD = IDD_RULE_ACTION_PARAM };
	CString	m_literalValue;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRuleParam)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    virtual void OnOK();

	// Generated message map functions
	//{{AFX_MSG(CRuleParam)
	afx_msg void OnParamAdd();
	afx_msg void OnParamOrderHigh();
	afx_msg void OnParmOrderDown();
	afx_msg void OnParmRemove();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeParamCombo();
	afx_msg int OnVKeyToItem(UINT nKey, CListBox* pListBox, UINT nIndex);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
    void ParseInvokeParameters(LPCTSTR paramList);
    CString GetParametersList(void) const;
    
    bool IsChanged(void) const
    {
        return m_fChanged;
    }


private:
    static DWORD GetParameterTypeId(LPCTSTR param);

private:
    void Display(int selectedCell) const;

private:
    //
    // CParam is a private class that used to hold information for
    // each parameter in rule invokation list. The class hold an ID
    // of parameter type and the value. For string and number the value 
    // literal value, for the others parameters it holds parameter string
    // as it should appear in rule action string
    //
    class CParam
    {
        public:
            CParam() : m_id(0) 
            {
            }

            CParam(DWORD id, CString& value) :
              m_id(id),
              m_value(value)
            {
            }

        public:
            DWORD m_id;
            CString m_value;
    };


private:
    //
    // List of invocation parameters. Each parameter can appear multiple times
    // and they are ordered
    //
    CParam m_invokeParamArray[xMaxParameters];
    DWORD m_NoOfParams;

    CParam m_tempInvokeParam[xMaxParameters];
    DWORD m_NoOftempParams;

    //
    // Indicates if the action property was changed
    //
    bool m_fChanged;

    //
    // Pointer to dialog elements
    //
    CListBox* m_pInvokeParams;
    CComboBox* m_pParams;
};



//
//
// CRuleAction dialog
//
//

class CRuleAction : public CMqPropertyPage
{

// Construction
public:
    //
    // This constuctor is use when display rule property page and it used 
    // for display and rule update
    //
	CRuleAction(
        CRuleParent* pParentNode, 
        _bstr_t action,
        BOOL fShowWindow
        ) :
        CMqPropertyPage(CRuleAction::IDD_VIEW),
        m_pParentNode(SafeAddRef(pParentNode)),
        m_pNewParentNode(NULL),
        m_orgAction(static_cast<LPCTSTR>(action)),
        m_fShowWindow(fShowWindow),
        m_executableType(eCom),
        m_fInit(false)
    {
    }


    //
    // This constructure is called when a new rule is created
    //
	CRuleAction(
        CNewRule* pParentNode
        ) :
        CMqPropertyPage(CRuleAction::IDD_NEW, IDS_NEW_RULE_CAPTION),
        m_pParentNode(NULL),
        m_pNewParentNode(pParentNode),
        m_orgAction(_T("")),
        m_fShowWindow(true),
        m_executableType(eCom),
        m_fInit(false)
    {
    }


    ~CRuleAction();

    CString GetAction(void) const;


// Dialog Data
	//{{AFX_DATA(CRuleAction)
	enum { IDD_NEW = IDD_NEW_TRIGGER_RULE_ACTION, IDD_VIEW = IDD_TRIGGER_RULE_ACTION };
	BOOL	m_fShowWindow;
	CString	m_exePath;
	CString	m_comProgId;
	CString	m_method;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRuleAction)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRuleAction)
	virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive();
    virtual BOOL OnWizardFinish();
	afx_msg void OnInvocationSet();
	afx_msg void OnFindExeBtm();
	afx_msg void OnParamBtm();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    //
    // Invocation type COM or standalone EXE
    //
    enum EXECUTABLE_TYPE {
        eExe,
        eCom
    };

private:
	static void ParseExecutableType(LPCTSTR exeType, EXECUTABLE_TYPE* pType);

private:
	void 
    ParseActionStr(
        LPCTSTR action
        ) throw(exception);

    void SetComFields(BOOL fSet);

private:
    R<CRuleParent> m_pParentNode;
    CNewRule* m_pNewParentNode;

    CString m_orgAction;
    EXECUTABLE_TYPE m_executableType;

    CRuleParam m_ruleParam;
    bool m_fInit;
};

const LPCWSTR xIvokeParameters[] = {
    _T("$MSG_ID"),
    _T("$MSG_LABEL"),
    _T("$MSG_BODY"),
    _T("$MSG_BODY_AS_STRING"),
    _T("$MSG_PRIORITY"),
    _T("$MSG_ARRIVEDTIME"),
    _T("$MSG_SENTTIME"),
    _T("$MSG_CORRELATION_ID"),
    _T("$MSG_APPSPECIFIC"),
    _T("$MSG_QUEUE_PATHNAME"),
    _T("$MSG_QUEUE_FORMATNAME"),
    _T("$MSG_RESPONSE_QUEUE_FORMATNAME"),
    _T("$MSG_DEST_QUEUE_FORMATNAME"),
    _T("$MSG_ADMIN_QUEUE_FORMATNAME"),
    _T("$MSG_SRCMACHINEID"),
    _T("$MSG_LOOKUP_ID"),
    _T("$TRIGGER_NAME"),
    _T("$TRIGGER_ID"),
};




#endif //__RULEACT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\rule.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    rule.cpp                                     *

Abstract:
	Implementation for rule the class

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/
#include "stdafx.h"
#include "autoptr.h" 

#import "mqtrig.tlb" no_namespace
#include "rule.h"

#include "rule.tmh"

using namespace std;

static CRuleSet* s_pRuleSet = NULL;

R<CRuleSet> GetRuleSet(const CString& strComputer)
{
    if (s_pRuleSet == NULL)
    {
        s_pRuleSet = new CRuleSet(strComputer);
    }

    return SafeAddRef(s_pRuleSet);
}


CRule::CRule(
    CRuleSet* pRuleSet,
    _bstr_t  id,
    _bstr_t  name, 
	_bstr_t  description,
    _bstr_t  condition,
    _bstr_t  action,
    bool fShowWindow
    ) :
    m_pRuleSet(SafeAddRef(pRuleSet)),
    m_name(name),
    m_description(description),
    m_id(id),
    m_action(action),
    m_condition(condition),
    m_fShowWindow(fShowWindow)
{
}


void CRule::Update(
    _bstr_t  name, 
	_bstr_t  description,
    _bstr_t  condition,
    _bstr_t  action,
    bool fShowWindow
    ) throw(_com_error)
{
    if ((name == m_name) &&
        (description == m_description) &&
        (condition == m_condition) &&
        (action == m_action) &&
        (fShowWindow == m_fShowWindow))
        return;

    m_pRuleSet->Update(
            m_id, 
            name, 
            description, 
            condition, 
            action, 
            fShowWindow
            );

    m_name = name;
    m_description =description;
    m_action = action;
    m_condition =condition;
    m_fShowWindow =fShowWindow;
}


void CRule::Update(
    _bstr_t  name
    ) throw(_com_error)
{
    m_pRuleSet->Update(
                    m_id, 
                    name, 
                    m_description, 
                    m_condition, 
                    m_action, 
                    m_fShowWindow
                    );

    m_name = name;
}


CRuleSet::CRuleSet(
     const CString& strComputer
    ) :
    m_ruleSet(L"MSMQTriggerObjects.MSMQRuleSet.1"),
    m_fChanged(false)
{
    m_ruleSet->Init(static_cast<LPCWSTR>(strComputer));
    Refresh();
}


void CRuleSet::Refresh(void)
{
    m_ruleSet->Refresh();

    long noOfRules;
    m_ruleSet->get_Count(&noOfRules);

    m_ruleList.erase(m_ruleList.begin(), m_ruleList.end());

    for(long ruleIndex = 0; ruleIndex < noOfRules; ++ruleIndex)
    {        
        BSTR ruleId = NULL;
        BSTR ruleName = NULL;
        BSTR ruleDescription = NULL;
        BSTR ruleCondition = NULL;
        BSTR ruleAction = NULL;
        BSTR ruleProg = NULL;
        long ruleShowWindow = NULL;

        m_ruleSet->GetRuleDetailsByIndex(
                        ruleIndex,
                        &ruleId,
                        &ruleName,
                        &ruleDescription,
                        &ruleCondition,
                        &ruleAction,
                        NULL,
                        &ruleShowWindow
                        );

        R<CRule> pRule = new CRule(
                                this,
                                ruleId, 
                                ruleName, 
                                ruleDescription, 
                                ruleCondition, 
                                ruleAction,
                                (ruleShowWindow != 0)
                                );
    
        m_ruleList.push_back(pRule);
    }
}


R<CRule>
CRuleSet::AddRule(
    _bstr_t  name, 
	_bstr_t  description,
    _bstr_t  condition,
    _bstr_t  action,
    long fShowWindow
)
{
    BSTR impl = NULL;
    BSTR ruleId = NULL;

    m_ruleSet->Add(
            name, 
            description, 
            condition,
            action, 
            impl,
            fShowWindow,
            &ruleId
            );

    R<CRule> pRule = new CRule(
                            this,
                            ruleId, 
                            name, 
                            description, 
                            condition, 
                            action,
                            (fShowWindow != 0)
                            );

    m_ruleList.push_back(pRule);
    return pRule;
}

    
void CRuleSet::DeleteRule(const _bstr_t& ruleId)
{
    m_ruleSet->Delete(ruleId);

    for(RuleList::iterator it = m_ruleList.begin(); it != m_ruleList.end(); ++it)
    {
        if (ruleId == (*it)->GetRuleId())
        {
            m_ruleList.erase(it);
            return;
        }
    }

    ASSERT(0);
}


void CRuleSet::Update(
    _bstr_t  ruleId, 
    _bstr_t  name, 
	_bstr_t  description,
    _bstr_t  condition,
    _bstr_t  action,
    bool fShowWindow
    ) throw(_com_error)
{
    BSTR Implementation = NULL;

    m_ruleSet->Update(
                    ruleId, 
                    name, 
                    description, 
                    condition, 
                    action, 
                    Implementation, 
                    fShowWindow
                    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\ruledef.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	ruledef.cpp

Abstract:
	Implementation for the rules definition

Author:
    Uri Habusha (urih), 25-Jun-2000

--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"

#import "mqtrig.tlb" no_namespace

#include "mqtg.h"
#include "mqppage.h"
#include "triggen.h"
#include "ruledef.h"
#include "rulecond.h"
#include "ruleact.h"
#include "newrule.h"

#include "ruledef.tmh"

static CString s_strYes;
static CString s_strNo;


/****************************************************

CRulesDefinition Class
    
 ****************************************************/

// {FB19702B-EB46-4ec4-9B0B-F41EA2A61410}
static const GUID CRulesDefinitionGUID_NODETYPE = 
{ 0xfb19702b, 0xeb46, 0x4ec4, {0x9b, 0xb, 0xf4, 0x1e, 0xa2, 0xa6, 0x14, 0x10} };

const GUID*  CRulesDefinition::m_NODETYPE = &CRulesDefinitionGUID_NODETYPE;
const OLECHAR* CRulesDefinition::m_SZNODETYPE = OLESTR("FB19702B-EB46-4ec4-9B0B-F41EA2A61410");
const OLECHAR* CRulesDefinition::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CRulesDefinition::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;
  

HRESULT CRulesDefinition::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    //
    // Display verbs that we support
    //
    HRESULT hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );
    ASSERT(SUCCEEDED(hr));

    return S_OK;
}
   
                                
HRESULT CRulesDefinition::PopulateResultChildrenList()
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());


    try
    {
        m_pRuleSet->Refresh();
        RuleList ruleList = m_pRuleSet->GetRuleList();

        for(RuleList::iterator it = ruleList.begin(); it != ruleList.end(); ++it)
        {        
            P<CRuleResult> pRule = new CRuleResult(this, m_pComponentData, (*it).get());

            AddChildToList(pRule);

            pRule.detach();
        }
    }
    catch (const _com_error&)
    {
    }
    return S_OK;
    
}


HRESULT 
CRulesDefinition::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK /*lpProvider*/,
    LONG_PTR /*handle*/, 
	IUnknown* /*pUnk*/,
	DATA_OBJECT_TYPES /*type*/
    )
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return(S_OK);
}


HRESULT 
CRulesDefinition::OnNewRule(
    bool & /*bHandled*/,
    CSnapInObjectRootBase* /*pSnapInObjectRoot*/
    )
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CNewRule newRule(m_pRuleSet.get());
    if (newRule.DoModal() == ID_WIZFINISH)
    {        
        Notify(MMCN_REFRESH, 0, 0, m_pComponentData, NULL, CCT_RESULT);
    }

    return(S_OK);
}


CColumnDisplay RuleDefintionColumn[] = {
    { IDS_RULE_NAME,  150 },
    { IDS_RULE_DESCRIPTION, 200 },
    { IDS_RULE_ID, HIDE_COLUMN },
};

HRESULT 
CRulesDefinition::InsertColumns(
    IHeaderCtrl* pHeaderCtrl
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
	//
	// Initialize column values
	//
	s_strYes.LoadString(IDS_YES);
	s_strNo.LoadString(IDS_NO);

    for (DWORD i = 0; i < ARRAYSIZE(RuleDefintionColumn); ++i)
    {
        CString title;
        title.LoadString(RuleDefintionColumn[i].m_columnNameId);

        HRESULT hr = pHeaderCtrl->InsertColumn(
                                        i, 
                                        title, 
                                        LVCFMT_LEFT, 
                                        RuleDefintionColumn[i].m_width
                                        );
        if (FAILED(hr))
            return hr;
    }

    return(S_OK);
}


CString 
CRulesDefinition::GetHelpLink( 
	VOID
	)
{
	CString strHelpLink;
    strHelpLink.LoadString(IDS_HELPTOPIC_TRIGGERS);

	return strHelpLink;
}

/////////////////////////////////////////////////////////////////////////////
// CRuleParent base class

void CRuleParent::OnRuleApply() throw (_com_error)
{
	try
	{
		_bstr_t name = static_cast<LPCTSTR>(m_pGeneral->m_ruleName);
		_bstr_t description = static_cast<LPCTSTR>(m_pGeneral->m_ruleDescription);
		_bstr_t cond = static_cast<LPCTSTR>(m_pCond->GetCondition());
		_bstr_t action = static_cast<LPCTSTR>(m_pAction->GetAction());
		long fShowWindow = m_pAction->m_fShowWindow;

		m_rule->Update(name, description, cond, action, (fShowWindow != 0));
	}
	catch(const _com_error& e)
	{
		if (e.Error() == MQTRIG_RULE_NOT_FOUND)
		{
			CString strError;
			strError.FormatMessage(IDS_RULE_ALREADY_DELETED, static_cast<LPCWSTR>(GetRuleName()));
			AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);

			throw;
		}

		DisplayErrorFromCOM(IDS_RULE_UPDATE_FAILED, e);
		throw;
	}
}


void
CRuleParent::OnDestroyPropertyPages()
{
	m_pGeneral = NULL;
	m_pCond = NULL;
	m_pAction = NULL;
}

/****************************************************

CRuleResult Class
    
 ****************************************************/

// {3A8D70C9-C74F-4333-B493-43A14442D24B}
static const GUID CRuleResultGUID_NODETYPE = 
{ 0x3a8d70c9, 0xc74f, 0x4333, { 0xb4, 0x93, 0x43, 0xa1, 0x44, 0x42, 0xd2, 0x4b} };

const GUID*  CRuleResult::m_NODETYPE = &CRuleResultGUID_NODETYPE;
const OLECHAR* CRuleResult::m_SZNODETYPE = OLESTR("3A8D70C9-C74F-4333-B493-43A14442D24B");
const OLECHAR* CRuleResult::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CRuleResult::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;
  

HRESULT CRuleResult::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    //
    // Display verbs that we support
    //
    HRESULT hr;

    hr = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
    ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
    ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES);
    ASSERT(SUCCEEDED(hr));

    return S_OK;
}

HRESULT 
CRuleResult::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR /*handle*/,
	IUnknown* /*pUnk*/,
	DATA_OBJECT_TYPES /*type*/
    )
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	//
	// If the propery page already open bring it to top
	//
	if ((m_pGeneral != NULL) && (m_pGeneral->GetParent() != NULL))
	{		
		(m_pGeneral->GetParent())->BringWindowToTop();
		return S_FALSE;
	}

    //
    // Add general rule property page
    //
    HPROPSHEETPAGE hGeneralRule = 0;
    HRESULT hr = CreateGenralPage(&hGeneralRule);
    
    if (FAILED(hr))
    {
        AfxMessageBox(IDS_RULE_GENERAL_FAILED, MB_OK | MB_ICONERROR);
        return(S_OK);
    }

    lpProvider->AddPage(hGeneralRule); 

    //
    // Add rule condition property page
    //
    HPROPSHEETPAGE hCondition = 0;
    hr = CreateConditionPage(&hCondition);
    
    if (FAILED(hr))
    {
        AfxMessageBox(IDS_RULE_COND_FAILE, MB_OK | MB_ICONERROR);
        return(S_OK);
    }

    lpProvider->AddPage(hCondition);
    
    //
    // Add action property page
    //
    HPROPSHEETPAGE hAction = 0;
    hr = CreateActionPage(&hAction);
    
    if (FAILED(hr))
    {
        AfxMessageBox(IDS_RULE_ACTION_FAILED, MB_OK | MB_ICONERROR);
        return(S_OK);
    }

    lpProvider->AddPage(hAction);

    return S_OK;
}


HRESULT 
CRuleResult::CreateGenralPage(
    HPROPSHEETPAGE *phGeneralRule
    )
{   
    try
    {
        m_pGeneral = new CViewRuleGeneral(this, GetRuleName(), GetRuleDescription());
    
        HPROPSHEETPAGE hPage = m_pGeneral->CreateThemedPropertySheetPage();
        if (hPage)
        {
            *phGeneralRule = hPage;
            return S_OK;
        }
    }
    catch (const exception&)
    {
    }

    return E_UNEXPECTED;    
}


HRESULT 
CRuleResult::CreateConditionPage(
    HPROPSHEETPAGE *phCondition
    )
{   
    try
    {
        m_pCond  = new CRuleCondition(this, GetRuleCondition());

        HPROPSHEETPAGE hPage = m_pCond->CreateThemedPropertySheetPage(); 
        if (hPage)
        {
            *phCondition = hPage;
            return S_OK;
        }
    }
    catch(const exception&)
    {
    }

    return E_UNEXPECTED;    
}


HRESULT 
CRuleResult::CreateActionPage(
    HPROPSHEETPAGE *phAction
    )
{      
    try
    {
        m_pAction = new CRuleAction(this, GetRuleAction(), GetShowWindow());

        HPROPSHEETPAGE hPage = m_pAction->CreateThemedPropertySheetPage();
        if (hPage)
        {
            *phAction = hPage;
            return S_OK;
        }
    }
    catch(const exception&)
    {
    }

    return E_UNEXPECTED;    
}


LPOLESTR CRuleResult::GetResultPaneColInfo(int nCol)
{
    ASSERT(ARRAYSIZE(RuleDefintionColumn) >= nCol);
    
    switch (RuleDefintionColumn[nCol].m_columnNameId)
    {
        case IDS_RULE_NAME:
            return m_rule->GetRuleName();

        case IDS_RULE_ID:
            return m_rule->GetRuleId();

        case IDS_RULE_DESCRIPTION:
            return m_rule->GetRuleDescription();

        default:
            ASSERT(0);
            return _T("");
    }
}


HRESULT CRuleResult::OnDelete( 
			LPARAM,
			LPARAM,
			IComponentData* /*pComponentData*/,
			IComponent * /*pComponent*/,
			DATA_OBJECT_TYPES,
            BOOL
			)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString strDeleteQuestion;
    strDeleteQuestion.FormatMessage(IDS_DELETE_QUESTION, static_cast<LPCTSTR>(GetRuleName()));

    if (IDYES != AfxMessageBox(strDeleteQuestion, MB_YESNO))
    {
        return S_FALSE;
    }

    try
    {
        ASSERT(m_pParentNode != NULL);

        m_rule->DeleteRule();
        
		//
		// Remove the trigger from result list so next time the reult pane view it will
		// not present the deleted trigger
		//
		R<CRuleResult> ar = this;
		HRESULT hr = static_cast<CRulesDefinition*>(m_pParentNode)->RemoveChild(this);
		ASSERT(SUCCEEDED(hr));

        return S_OK;
    }
    catch(const _com_error&)
    {
        CString strError;
        strError.FormatMessage(IDS_OP_DELETE, static_cast<LPCWSTR>(GetRuleName()));

        AfxMessageBox(strError, MB_OK | MB_ICONERROR);

        return S_FALSE;
    }
}


void 
CRuleResult::Compare(
	CRuleResult* pItem1, 
	CRuleResult* pItem2,
	int* pnResult
	)
{
	LPCWSTR pVal1 = pItem1->GetResultPaneColInfo(*pnResult);
	LPCWSTR pVal2 = pItem2->GetResultPaneColInfo(*pnResult);

	*pnResult = wcscmp(pVal2, pVal1);
}


CString 
 CRuleResult::GetHelpLink()
{
	CString strHelpLink;
	strHelpLink.LoadString(IDS_HELPTOPIC_TRIGGERS);
	return strHelpLink;
}


/////////////////////////////////////////////////////////////////////////////
// CRuleGeneral property page

CRuleGeneral::CRuleGeneral(
	UINT nIDPage,
	UINT nIDCaption
    ) : 
    CMqPropertyPage(nIDPage, nIDCaption)
{
}

  
void CRuleGeneral::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRuleGeneral)
	DDX_Text(pDX, IDC_RULE_DESCRIPTION, m_ruleDescription);
	DDV_MaxChars(pDX, m_ruleDescription, xMaxRuleDescriptionLen);
	//}}AFX_DATA_MAP
}


BOOL CRuleGeneral::OnInitDialog() 
{
	SetDlgTitle();
	
	return CMqPropertyPage::OnInitDialog();
}


/////////////////////////////////////////////////////////////////////////////
// CNewRuleGeneral property page

CNewRuleGeneral::CNewRuleGeneral(
    CNewRule* pParentNode
    ) : 
    CRuleGeneral(CNewRuleGeneral::IDD, IDS_NEW_RULE_CAPTION),
    m_pNewParentNode(pParentNode)
{
    m_ruleName = _T("");
	m_ruleDescription = _T("");
}


void CNewRuleGeneral::DoDataExchange(CDataExchange* pDX)
{
	CRuleGeneral::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRuleGeneral)
	DDX_Text(pDX, IDC_RULE_NAME, m_ruleName);
    DDV_NotEmpty(pDX, m_ruleName, IDS_RULE_NAME_REQUIRED);
	DDV_MaxChars(pDX, m_ruleName, xMaxRuleNameLen);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CNewRuleGeneral, CRuleGeneral)
	//{{AFX_MSG_MAP(CNewRuleGeneral)
	ON_EN_CHANGE(IDC_RULE_DESCRIPTION, OnChangeRWField)
	ON_EN_CHANGE(IDC_RULE_NAME, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CNewRuleGeneral::OnSetActive() 
{
	ASSERT(m_pNewParentNode != NULL);
    return m_pNewParentNode->SetWizardButtons();
}


/////////////////////////////////////////////////////////////////////////////
// CViewRuleGeneral property page

CViewRuleGeneral::CViewRuleGeneral(
    CRuleParent* pParentNode,
    _bstr_t ruleName, 
    _bstr_t ruleDescription
    ) : 
    CRuleGeneral(CViewRuleGeneral::IDD),
    m_pParentNode(SafeAddRef(pParentNode))
{
	//{{AFX_DATA_INIT(CRuleGeneral)
	m_ruleName = static_cast<LPTSTR>(ruleName);
	m_ruleDescription = static_cast<LPTSTR>(ruleDescription);
	//}}AFX_DATA_INIT
}


CViewRuleGeneral::~CViewRuleGeneral()
{
	ASSERT(m_pParentNode.get() != NULL);
	m_pParentNode->OnDestroyPropertyPages();
}


BEGIN_MESSAGE_MAP(CViewRuleGeneral, CRuleGeneral)
	//{{AFX_MSG_MAP(CViewRuleGeneral)
	ON_EN_CHANGE(IDC_RULE_DESCRIPTION, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CViewRuleGeneral::OnApply() 
{
    try
    {
	    m_pParentNode->OnRuleApply();

        CMqPropertyPage::OnChangeRWField(FALSE);
        return TRUE;
    }
    catch(const _com_error&)
    {
       return FALSE;
    }
}


void CViewRuleGeneral::SetDlgTitle()
{
	SetDlgItemText(IDC_RULE_GENERAL_TITLE, m_ruleName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\ruleact.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	ruleact.cpp

Abstract:
	Implementation for the rule action definition

Author:
    Uri Habusha (urih), 25-Jun-2000

--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "localutl.h"

#import "mqtrig.tlb" no_namespace

#include "mqtg.h"
#include "mqppage.h"
#include "ruledef.h"
#include "rulecond.h"
#include "ruleact.h"
#include "newrule.h"
#include "mqcast.h"
#include <cderr.h>

#include "ruleact.tmh"

static
bool
IsValidNumericValue(
    const CString& value
    )

{
	CString TempValue(value);
	TempValue.TrimRight();
	TempValue.TrimLeft();
	
    TCHAR* pEnd = L"";
    LONG Number = _tcstol(TempValue, &pEnd, 10);
    if ((Number == LONG_MAX) || (Number == LONG_MIN) || (*pEnd != NULL))
    {
		return false;
    }

    return true;
}


//
// CInvokeParam - used to hold parameter information. For each valid parameter we
// hold its string ID in string table and its enumeration value
// 
class CInvokeParam
{
public:
    CInvokeParam(
        DWORD id, 
        eInvokeParameters paramIndex 
        ) :
        m_paramTableStringId(id),
        m_paramIndex(paramIndex)
    {
    }

public:
    DWORD m_paramTableStringId;
    eInvokeParameters m_paramIndex;
};


const CInvokeParam xParameterTypeIds[] = {
    CInvokeParam(IDS_MSG_ID_PARAM,             eMsgId),
    CInvokeParam(IDS_MSG_LABEL_PARAM,          eMsgLabel),
    CInvokeParam(IDS_MSG_BODY_PARAM,           eMsgBody),
    CInvokeParam(IDS_MSG_BODY_STR_PARAM,       eMsgBodyAsString),
    CInvokeParam(IDS_MSG_PREIORITY_PARAM,      eMsgPriority),
    CInvokeParam(IDS_MSG_ARRIVED_TIME_PARAM,   eMsgArrivedTime),
    CInvokeParam(IDS_MSG_SENT_TIME_PARAM,      eMsgSentTime),
    CInvokeParam(IDS_MSG_CORRELATION_PARAM,    eMsgCorrelationId),
    CInvokeParam(IDS_MSG_APP_PARAM,            eMsgAppspecific),
    CInvokeParam(IDS_MSG_QUEUE_PN_PARAM,       eMsgQueuePathName),
    CInvokeParam(IDS_MSG_QUEUE_FN_PARAM,       eMsgQueueFormatName),
    CInvokeParam(IDS_MSG_RESP_QUEUE_PARAM,     eMsgRespQueueFormatName),
    CInvokeParam(IDS_MSG_ADMIN_QUEUE_PARAM,    eMsgAdminQueueFormatName),
    CInvokeParam(IDS_MSG_SRC_MACHINE_PARAM,    eMsgSrcMachineId),
    CInvokeParam(IDS_MSG_LOOKUP_ID,            eMsgLookupId),
    CInvokeParam(IDS_TRIGGER_NAME_PARAM,       eTriggerName),
    CInvokeParam(IDS_TRIGGER_ID_PARAM,         eTriggerId),
    CInvokeParam(IDS_STRING_PARAM,             eLiteralString),
    CInvokeParam(IDS_NUM_PARAM,                eLiteralNumber),
};


/////////////////////////////////////////////////////////////////////////////
// CRuleParam dialog


CRuleParam::CRuleParam() :
    CMqDialog(CRuleParam::IDD),
    m_NoOftempParams(0),
    m_NoOfParams(0),
    m_fChanged(false),
    m_pInvokeParams(NULL),
    m_pParams(NULL)
{
	//{{AFX_DATA_INIT(CRuleParam)
	m_literalValue = _T("");
	//}}AFX_DATA_INIT
}


void CRuleParam::DoDataExchange(CDataExchange* pDX)
{
	CMqDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRuleParam)
	DDX_Text(pDX, IDC_LITERAL_PARAM, m_literalValue);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRuleParam, CMqDialog)
	//{{AFX_MSG_MAP(CRuleParam)
	ON_BN_CLICKED(IDB_PARAM_ADD, OnParamAdd)
	ON_BN_CLICKED(IDB_PARAM_ORDER_UP, OnParamOrderHigh)
	ON_BN_CLICKED(IDB_PARM_ORDER_DOWN, OnParmOrderDown)
	ON_BN_CLICKED(IDB_PARM_REMOVE, OnParmRemove)
	ON_CBN_SELCHANGE(IDC_PARAM_COMBO, OnSelchangeParamCombo)
   	ON_WM_VKEYTOITEM()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRuleParam message handlers

void CRuleParam::OnParamAdd() 
{
    //
    // Get selected cell 
    //
    int nIndex = m_pParams->GetCurSel();
    if (nIndex == LB_ERR)
    {
        AfxMessageBox(IDS_PARAM_NOT_SELECTED, MB_OK | MB_ICONERROR);
        return;
    }

    if (ARRAYSIZE(m_invokeParamArray) == m_NoOftempParams)
    {
        CString strError;
        strError.FormatMessage(IDS_PARAM_NO_EXEEDED, ARRAYSIZE(m_invokeParamArray));

        AfxMessageBox(strError, MB_OK | MB_ICONERROR);
        return;
    }
    //
    // Add the new parameter at the end of invokation parameter list
    //
    DWORD paramIndex = static_cast<DWORD>(m_pParams->GetItemData(nIndex));
    DWORD paramId = xParameterTypeIds[paramIndex].m_paramTableStringId;

    if ((paramId == IDS_STRING_PARAM) ||
        (paramId == IDS_NUM_PARAM))
    {
        UpdateData();

        if (m_literalValue.IsEmpty())
        {
            AfxMessageBox(IDS_LITERAL_VALUE_REQUIRES, MB_OK | MB_ICONERROR);
            return;
        }

        if (paramId == IDS_NUM_PARAM)
        {
            //
            // Check parameter validity
            //
            if (!IsValidNumericValue(m_literalValue))
            {
                CString strError;
                strError.FormatMessage(IDS_ILLEGAL_NUMERIC_VALUE, m_literalValue);

                AfxMessageBox(strError, MB_OK | MB_ICONERROR);
                return;
            }
        }

        if ((paramId == IDS_STRING_PARAM) &&
            (m_literalValue[0] != _T('"')))
        {
            m_literalValue = _T('"') + m_literalValue + _T('"');
        }

        m_tempInvokeParam[m_NoOftempParams] = CParam(paramId, m_literalValue);
    }
    else
    {
        eInvokeParameters paramType = xParameterTypeIds[paramIndex].m_paramIndex;
        CString strParam = xIvokeParameters[paramType];

        m_tempInvokeParam[m_NoOftempParams] = CParam(paramId, strParam);
    }

    ++m_NoOftempParams;        
    Display(m_NoOftempParams - 1);

    m_fChanged = true;
}


void CRuleParam::OnParmRemove() 
{
    //
    // Get selected cell 
    //
    int nIndex = m_pInvokeParams->GetCurSel();
	int selectedCell = nIndex;

    if (nIndex == LB_ERR)
    {
        AfxMessageBox(IDS_PARAM_NOT_SELECTED, MB_OK | MB_ICONERROR);
        return;
    }

    //
    // remove the parameter from invoke parameter list. 
    //
    for (DWORD i = nIndex; i < m_NoOftempParams - 1; ++i)
    {
        m_tempInvokeParam[i] = m_tempInvokeParam[i + 1];
    }

    --m_NoOftempParams;

    Display(selectedCell);

    m_fChanged = true;
}

//
// Handle the case when users press "Delete" in the rules invokation params list
// Bug 5974 - YoelA, 14-Nov-01
//
int CRuleParam::OnVKeyToItem(UINT nKey, CListBox* pListBox, UINT /*nIndex*/)
{
    if (nKey == VK_DELETE &&
        pListBox->m_hWnd == m_pInvokeParams->m_hWnd
        )
    {
        OnParmRemove();
    }
    return -1;
}


void CRuleParam::OnParamOrderHigh() 
{
    //
    // Get selected cell 
    //
    int nIndex = m_pInvokeParams->GetCurSel();
    if (nIndex == LB_ERR)
    {
        AfxMessageBox(IDS_PARAM_NOT_SELECTED, MB_OK | MB_ICONERROR);
        return;
    }

    if (nIndex == 0)
        return;

    //
    // Change order in invoke parameter list
    //
    CParam temp = m_tempInvokeParam[nIndex -1];
    m_tempInvokeParam[nIndex - 1] = m_tempInvokeParam[nIndex];
    m_tempInvokeParam[nIndex] = temp;

    Display(nIndex - 1);

    m_fChanged = true;
}



void CRuleParam::OnParmOrderDown() 
{
    //
    // Get selected cell 
    //
    int nIndex = m_pInvokeParams->GetCurSel();
    if (nIndex == LB_ERR)
    {
        AfxMessageBox(IDS_PARAM_NOT_SELECTED, MB_OK | MB_ICONERROR);
        return;
    }

    if (numeric_cast<DWORD>(nIndex) == (m_NoOftempParams - 1))
        return;

    //
    // Change order in invoke parameter list
    //
    CParam temp = m_tempInvokeParam[nIndex];
    m_tempInvokeParam[nIndex] = m_tempInvokeParam[nIndex + 1];
    m_tempInvokeParam[nIndex + 1] = temp;

    Display(nIndex + 1);

    m_fChanged = true;
}


void CRuleParam::Display(int selectedCell) const
{
    //
    // Clear the list box before adding a list of condition
    //
    m_pInvokeParams->ResetContent();

    for(DWORD i = 0; i < m_NoOftempParams; ++i)
    {
        CString strParam;
        if ((m_tempInvokeParam[i].m_id == IDS_STRING_PARAM) ||
            (m_tempInvokeParam[i].m_id == IDS_NUM_PARAM))
        {
            strParam = m_tempInvokeParam[i].m_value;
        }
        else
        {
            strParam.FormatMessage(m_tempInvokeParam[i].m_id);
        }

        m_pInvokeParams->InsertString(i, strParam);
        m_pInvokeParams->SetItemData(i, i);
    }


	//
	// Check that the sellected cell isn't out of the list boundray
	//
	if (selectedCell >= m_pInvokeParams->GetCount())
	{	  
		selectedCell = m_pInvokeParams->GetCount() - 1;
	}	  
    m_pInvokeParams->SetCurSel(selectedCell);

	SetScrollSizeForList(m_pInvokeParams);
}


BOOL CRuleParam::OnInitDialog() 
{
    m_pInvokeParams = static_cast<CListBox*>(GetDlgItem(IDC_INVOKE_PARMETER_LIST));
    m_pParams = static_cast<CComboBox*>(GetDlgItem(IDC_PARAM_COMBO));

    //
    // Set the temporary array according the latest values
    //
    for (DWORD i = 0; i < m_NoOfParams; ++i)
    {
        m_tempInvokeParam[i] = m_invokeParamArray[i];
    }

    m_NoOftempParams = m_NoOfParams;

    //
    // Disable literal edit box
    //
    GetDlgItem(IDC_LITERAL_PARAM)->EnableWindow(FALSE);

    //
    // Add parameters types to combox
    //
    for(DWORD i = 0; i < ARRAYSIZE(xParameterTypeIds); ++i)
    {
        CString strParam;
        strParam.FormatMessage(xParameterTypeIds[i].m_paramTableStringId);

        m_pParams->InsertString(i, strParam);
        m_pParams->SetItemData(i, i);
    }

    //
    // Display list of parameters and selected parameters
    //
    Display(0);

	CMqDialog::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


DWORD CRuleParam::GetParameterTypeId(LPCTSTR param)
{
    for(DWORD i = 0; i < ARRAYSIZE(xParameterTypeIds); ++i)
    {
		eInvokeParameters paramIndex = xParameterTypeIds[i].m_paramIndex;

		if ((paramIndex == eLiteralString) || (paramIndex == eLiteralNumber))
			continue;

        if (wcscmp(xIvokeParameters[paramIndex], param) == 0)
            return xParameterTypeIds[i].m_paramTableStringId;
    }

    if ((param[0] == _T('"')) && (param[_tcslen(param) - 1] == _T('"')))
        return IDS_STRING_PARAM;

    if (IsValidNumericValue(param))
        return IDS_NUM_PARAM;

    throw exception();
}


void CRuleParam::ParseInvokeParameters(LPCTSTR p)
{
    //
    // Parse the program parameters
    //
    for(;;)
    {
        CString token = GetToken(p, xActionDelimiter);
        if (token.IsEmpty())
            break;
        
        DWORD paramId = GetParameterTypeId(token);
        
        m_invokeParamArray[m_NoOfParams] = CParam(paramId, token);
        ++m_NoOfParams;
    }
}


CString CRuleParam::GetParametersList(void) const
{
    CString paramList;

    for (DWORD i = 0; i < m_NoOfParams; ++i)
    {
        paramList += m_invokeParamArray[i].m_value;
        paramList += xActionDelimiter;
    }

    return paramList;
}


void CRuleParam::OnSelchangeParamCombo() 
{
    //
    // Get selected cell 
    //
    int nIndex = m_pParams->GetCurSel();
    if (nIndex == LB_ERR)
        return;

    DWORD paramIndex = static_cast<DWORD>(m_pParams->GetItemData(nIndex));
    
    if ((xParameterTypeIds[paramIndex].m_paramTableStringId == IDS_STRING_PARAM) ||
        (xParameterTypeIds[paramIndex].m_paramTableStringId == IDS_NUM_PARAM))
    {
        GetDlgItem(IDC_LITERAL_PARAM)->EnableWindow(TRUE);
		return;
    }
    
	//
	// Disable literal window when non literal parameter is selected
	//
	GetDlgItem(IDC_LITERAL_PARAM)->EnableWindow(FALSE);
}


void CRuleParam::OnOK()
{
    for (DWORD i = 0; i < m_NoOftempParams; ++i)
    {
        m_invokeParamArray[i] = m_tempInvokeParam[i];
    }

    m_NoOfParams = m_NoOftempParams;

    CMqDialog::OnOK();

}


//
//
//
void CRuleAction::ParseActionStr(LPCTSTR p) throw (exception)
{
    CString token = GetToken(p, xActionDelimiter);

    //
    // First token is mandatory and it specifies the executable type, COM or EXE
    //
    if (token.IsEmpty())
        throw exception();

    ParseExecutableType(token, &m_executableType);

    //
    // Second token is manadatory and for COM object it identifies the PROGID
    // while for EXE it specifies the exe path;
    //
    token = GetToken(p, xActionDelimiter);
    if (token.IsEmpty())
        throw exception();

    if (m_executableType == eExe)
    {
        m_exePath = token;
    }
    else
    {
        m_comProgId = token;

        //
        // Third token specifies the method name to invoke
        // 
        token = GetToken(p, xActionDelimiter);
        if (token.IsEmpty())
            throw exception();

        m_method = token;
    }

    m_ruleParam.ParseInvokeParameters(p);
}

 
void 
CRuleAction::ParseExecutableType(
    LPCTSTR exeType, 
    EXECUTABLE_TYPE *pType
    ) throw(exception)
{
    ASSERT(_T('C') == xCOMAction[0]);
    ASSERT(_T('E') == xEXEAction[0]);

    //
    //  accelarate token recognition by checking 3rd character
    //
    switch(_totupper(exeType[0]))
    {
        //  pUblic
        case _T('C'):
            if(_tcsncicmp(exeType, xCOMAction, STRLEN(xCOMAction)) == 0)
            {
                *pType = eCom;
                return;
            }

            break;

        case L'E':
            if(_tcsncicmp(exeType, xEXEAction, STRLEN(xEXEAction)) == 0)
            {
                *pType = eExe;
                return;
            }

            break;
            
        default:
            break;
    }

    throw exception();
}

/////////////////////////////////////////////////////////////////////////////
// CRuleAction property page

CRuleAction::~CRuleAction()
{
}

void CRuleAction::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRuleAction)
	DDX_Text(pDX, IDC_EXE_PATH, m_exePath);
	DDX_Text(pDX, IDC_COMPONENT_PROGID, m_comProgId);
	DDX_Text(pDX, IDC_COMMETHOD_NAME, m_method);
	//}}AFX_DATA_MAP

	if (!pDX->m_bSaveAndValidate)
	{
		return;
	}

	//
	// remove leading space
	//
	m_exePath.TrimLeft();
	m_comProgId.TrimLeft();
	m_method.TrimLeft();

	if (m_executableType == eExe )
	{
		DDV_NotEmpty(pDX, m_exePath, IDS_ILLEGAL_INVOCE);

		if (!IsFile(m_exePath))
		{	
			AfxMessageBox(IDS_ENTER_VALID_FILENAME);
			pDX->Fail();
		}
	}
	else
	{
		DDV_NotEmpty(pDX, m_comProgId, IDS_ILLEGAL_INVOCE);
		DDV_NotEmpty(pDX, m_method, IDS_ILLEGAL_INVOCE);
	}
}


BEGIN_MESSAGE_MAP(CRuleAction, CMqPropertyPage)
	//{{AFX_MSG_MAP(CRuleAction)
	ON_BN_CLICKED(IDC_INVOKE_EXE, OnInvocationSet)
	ON_BN_CLICKED(IDC_INVOKE_COM, OnInvocationSet)
	ON_BN_CLICKED(IDC_FIND_EXE_BTM, OnFindExeBtm)
	ON_BN_CLICKED(IDC_PARAM_BTM, OnParamBtm)
	ON_EN_CHANGE(IDC_COMPONENT_PROGID, OnChangeRWField)
	ON_EN_CHANGE(IDC_COMMETHOD_NAME, OnChangeRWField)
	ON_EN_CHANGE(IDC_EXE_PATH, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRuleAction message handlers


void CRuleAction::SetComFields(BOOL fSet)
{
    //
    // Disable EXE input
    //
    GetDlgItem(IDC_EXE_PATH)->EnableWindow(!fSet);
    GetDlgItem(IDC_FIND_EXE_BTM)->EnableWindow(!fSet);

    //
    // Enable COM input
    //
    GetDlgItem(IDC_COMPONENT_PROGID)->EnableWindow(fSet);
    GetDlgItem(IDC_COMMETHOD_NAME)->EnableWindow(fSet);
}

void CRuleAction::OnInvocationSet() 
{
    CMqPropertyPage::OnChangeRWField();

    if (((CButton*)GetDlgItem(IDC_INVOKE_EXE))->GetCheck() == TRUE)
    {
        SetComFields(FALSE);
        m_executableType = eExe;
    }

    if (((CButton*)GetDlgItem(IDC_INVOKE_COM))->GetCheck() == TRUE)
    {
        SetComFields(TRUE);
        m_executableType = eCom;
    }
}


BOOL CRuleAction::OnInitDialog() 
{
    if (!m_orgAction.IsEmpty())
    {
        try
        {
            ParseActionStr(m_orgAction);
        }
        catch (const exception&)
        {
            AfxMessageBox(IDS_BAD_RULE_ACTION);

            m_executableType = eCom;
            m_method = _TCHAR("");
            m_comProgId = _TCHAR("");
            m_exePath = _TCHAR("");
        }
    }
                
    CFont font;
    font.CreatePointFont(180, _T("Arial"));
    GetDlgItem(IDC_FIND_EXE_BTM)->SetFont(&font);

    if (m_executableType == eCom)
    {
        ((CButton*)GetDlgItem(IDC_INVOKE_COM))->SetCheck(TRUE);
        SetComFields(TRUE);
    }
    else
    {
        ((CButton*)GetDlgItem(IDC_INVOKE_EXE))->SetCheck(TRUE);
        SetComFields(FALSE);
    }

    m_fInit = true;
    CMqPropertyPage::OnInitDialog();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CRuleAction::OnFindExeBtm() 
{
	CString strCurrentPath;
	GetDlgItemText(IDC_EXE_PATH, strCurrentPath);

    CFileDialog	 fd(
                    TRUE, 
                    NULL, 
                    strCurrentPath, 
                    OFN_OVERWRITEPROMPT | OFN_FILEMUSTEXIST, 
                    _T("Executable Files (*.exe)|*.exe|All Files (*.*)|*.*||")
                    );

    if (fd.DoModal() == IDOK)
    {
        SetDlgItemText(IDC_EXE_PATH, fd.GetPathName());
        CMqPropertyPage::OnChangeRWField();
		return;
    }

	DWORD dwErr = CommDlgExtendedError();
	if (dwErr == FNERR_INVALIDFILENAME)
	{
		//
		// If file name was invlaid, try again with empty initial path.
		// Invalid path name is usually a string with illegal characters <> ":|/\
		// This one should not fail.
		//
		CFileDialog	 fd(
						TRUE, 
						NULL, 
						L"", 
						OFN_OVERWRITEPROMPT | OFN_FILEMUSTEXIST, 
						_T("Executable Files (*.exe)|*.exe|All Files (*.*)|*.*||")
						);

		if (fd.DoModal() == IDOK)
		{
			SetDlgItemText(IDC_EXE_PATH, fd.GetPathName());
			CMqPropertyPage::OnChangeRWField();
		}
	}

}


void CRuleAction::OnParamBtm() 
{
    if ((m_ruleParam.DoModal() == IDOK) &&
        (m_ruleParam.IsChanged()))
    {
        CMqPropertyPage::OnChangeRWField();
    }
}


CString CRuleAction::GetAction(void) const
{
    if (!m_fInit)
        return static_cast<LPCTSTR>(m_orgAction);

    CString paramList;    
    if (m_executableType == eCom)
    {
        paramList += xCOMAction;
        paramList += xActionDelimiter;

        paramList += m_comProgId;
        paramList += xActionDelimiter;

        paramList += m_method;
        paramList += xActionDelimiter;
    }
    else
    {
        paramList += xEXEAction;
        paramList += xActionDelimiter;

        paramList += m_exePath;
        paramList += xActionDelimiter;
    }

    paramList += m_ruleParam.GetParametersList();
    
    return paramList;
}


BOOL CRuleAction::OnApply() 
{
	if (!m_fModified)
	{
		return TRUE;
	}

    UpdateData();

    try
    {
	    m_pParentNode->OnRuleApply();

        CMqPropertyPage::OnChangeRWField(FALSE);
        return TRUE;
    }
    catch(const _com_error&)
    {
        return FALSE;
    }
}


BOOL CRuleAction::OnSetActive() 
{
    if (m_pNewParentNode == NULL)
        return TRUE;

    return m_pNewParentNode->SetWizardButtons();
}


BOOL CRuleAction::OnWizardFinish()
{
    //
    // We reach here only when creating a new rule
    //
    ASSERT(m_pNewParentNode != NULL);
    
    if (!UpdateData())
	{
		return FALSE;
	}

    try
    {
        m_pNewParentNode->OnFinishCreateRule();
        return TRUE;
    }
    catch(const _com_error& e)
    {
		DisplayErrorFromCOM(IDS_NEW_RULE_FAILED, e);
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\rulecond.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	ruledef.cpp

Abstract:
	Implementation for the rules definition

Author:
    Uri Habusha (urih), 25-Jun-2000

--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "localutl.h"

#import "mqtrig.tlb" no_namespace

#include "mqtg.h"
#include "mqppage.h"
#include "ruledef.h"
#include "rulecond.h"
#include "ruleact.h"
#include "triggen.h"
#include "newrule.h"

#include "rulecond.tmh"

using namespace std;

class CCondTypes
{
public:
    typedef bool (WINAPI* IS_VALID_VALUE_ROUTINE)(const CString& condValue);

public:
    CCondTypes(
        DWORD id,
		DWORD condShortDescrId,
        LPCWSTR condType, 
        IS_VALID_VALUE_ROUTINE pfnIsValidValue
        ) :
        m_condTypeId(id),
		m_condShortDescrId(condShortDescrId),
        m_condType(condType),
        m_pfnIsValidValue(pfnIsValidValue)
    {
    }

public:
    DWORD m_condTypeId;
	DWORD m_condShortDescrId;

	//
	// The assumtion here is that the conditions types are global constants. Otherwise we cannot 
	// use this class because we only save the pointer to the string.
	//
    LPCWSTR m_condType;
    IS_VALID_VALUE_ROUTINE m_pfnIsValidValue;
};


static
bool
WINAPI
IsValidCondStringValue(
    const CString& condValue
    )
{
	DWORD NoOfQuote = 0;
	for(int quoteIndex = condValue.Find(L'\"');	 quoteIndex != -1; quoteIndex = condValue.Find(L'\"', quoteIndex + 1))
	{	
		++NoOfQuote;
	}

	if ((NoOfQuote % 2) == 0)
		return true;

    CString strError;
    strError.FormatMessage(IDS_ILLEGAL_STRING_VALUE, condValue);

    AfxMessageBox(strError, MB_OK | MB_ICONERROR);
    return false;

}


bool
WINAPI
IsValidNumericValue(
    const CString& condValue
    )
{
    TCHAR* pEnd;
    _tcstoul(condValue, &pEnd, 10);

    if (*pEnd == NULL)
        return true;

    CString strError;
    strError.FormatMessage(IDS_ILLEAGL_NUMERIC_VALUE, condValue);

    AfxMessageBox(strError, MB_OK | MB_ICONERROR);
    return false;

}


static
bool
WINAPI
IsValidPriorityValue(
    const CString& condValue
    )
{
    if (!IsValidNumericValue(condValue))
        return false;

    int priority = _ttoi(condValue);
    if ((priority >= MQ_MIN_PRIORITY) && (MQ_MAX_PRIORITY >= priority))
        return true;

    CString strError;
    strError.FormatMessage(IDS_ILLEAGL_PRIORITY_VALUE, MQ_MIN_PRIORITY, MQ_MAX_PRIORITY);
    AfxMessageBox(strError, MB_OK | MB_ICONERROR);
    return false;
}


static
bool
WINAPI
IsValidGuidValue(
    const CString& condValue
    )
{
    UUID temp;
    LPCTSTR pUiid = condValue;

    HRESULT hr = IIDFromString(const_cast<LPTSTR>(pUiid), &temp);
    if (hr == S_OK)
        return true;

    AfxMessageBox(IDS_ILLEAGL_SRC_MACHINE_VALUE, MB_OK | MB_ICONERROR);
    return false;
}


const CCondTypes xContionTypeIds[] = {
    CCondTypes(IDS_COND_LABEL_CONTAIN,      IDS_SHORT_COND_LABEL_CONTAIN,		xConditionTypes[eMsgLabelContains],         IsValidCondStringValue), 
    CCondTypes(IDS_COND_LABEL_NOT_CONTAIN,	IDS_SHORT_COND_LABEL_NOT_CONTAIN,	xConditionTypes[eMsgLabelDoesNotContain],   IsValidCondStringValue), 
    CCondTypes(IDS_COND_BODY_CONTAIN,		IDS_SHORT_COND_BODY_CONTAIN,		xConditionTypes[eMsgBodyContains],          IsValidCondStringValue), 
    CCondTypes(IDS_COND_BODY_NOT_CONTAIN,	IDS_SHORT_COND_BODY_NOT_CONTAIN,	xConditionTypes[eMsgBodyDoesNotContain],    IsValidCondStringValue), 
    CCondTypes(IDS_COND_PRIORITY_EQUAL,		IDS_SHORT_COND_PRIORITY_EQUAL,		xConditionTypes[ePriorityEquals],           IsValidPriorityValue), 
    CCondTypes(IDS_COND_PRIORITY_NOT_EQUAL,	IDS_SHORT_COND_PRIORITY_NOT_EQUAL,	xConditionTypes[ePriorityNotEqual],         IsValidPriorityValue), 
    CCondTypes(IDS_COND_PRIORITY_GRATER,	IDS_SHORT_COND_PRIORITY_GRATER,		xConditionTypes[ePriorityGreaterThan],      IsValidPriorityValue), 
    CCondTypes(IDS_COND_PRIORITY_LESS,		IDS_SHORT_COND_PRIORITY_LESS,		xConditionTypes[ePriorityLessThan],         IsValidPriorityValue), 
    CCondTypes(IDS_COND_APP_EQUAL,			IDS_SHORT_COND_APP_EQUAL,			xConditionTypes[eAppspecificEquals],        IsValidNumericValue), 
    CCondTypes(IDS_COND_APP_NOT_EQUAL,		IDS_SHORT_COND_APP_NOT_EQUAL,		xConditionTypes[eAppspecificNotEqual],      IsValidNumericValue), 
    CCondTypes(IDS_COND_APP_GREATER,		IDS_SHORT_COND_APP_GREATER,			xConditionTypes[eAppSpecificGreaterThan],   IsValidNumericValue), 
    CCondTypes(IDS_COND_APP_LESS,			IDS_SHORT_COND_APP_LESS,			xConditionTypes[eAppSpecificLessThan],      IsValidNumericValue), 
    CCondTypes(IDS_COND_SRCID_EQUAL,		IDS_SHORT_COND_SRCID_EQUAL,			xConditionTypes[eSrcMachineEquals],         IsValidGuidValue), 
    CCondTypes(IDS_COND_SRCID_NOT_EQUAL,	IDS_SHORT_COND_SRCID_NOT_EQUAL,		xConditionTypes[eSrcMachineNotEqual],       IsValidGuidValue), 
};


static
BOOL
IsStringTypeCondition(
	DWORD condIndex
	)
{
	ASSERT(ARRAYSIZE(xContionTypeIds) >= condIndex);

	DWORD condTypeId = xContionTypeIds[condIndex].m_condTypeId;

	if (condTypeId == IDS_COND_LABEL_CONTAIN ||
		condTypeId == IDS_COND_LABEL_NOT_CONTAIN ||
		condTypeId == IDS_COND_BODY_CONTAIN ||
		condTypeId == IDS_COND_BODY_NOT_CONTAIN )
	{
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CRuleCondition property page


CRuleCondition::CRuleCondition(
    CRuleParent* pParentNode, 
    _bstr_t condition
    ) : 
    CMqPropertyPage(CRuleCondition::IDD_VIEW),
    m_pParentNode(SafeAddRef(pParentNode)),
    m_pNewParentNode(NULL),
    m_originalCondVal(condition),
    m_fChanged(false)
{
	//{{AFX_DATA_INIT(CRuleCondition)
	m_newCondValue = _T("");
	//}}AFX_DATA_INIT
}


CRuleCondition::CRuleCondition(
    CNewRule* pParentNode
    ) : 
    CMqPropertyPage(CRuleCondition::IDD_NEW, IDS_NEW_RULE_CAPTION),
    m_pParentNode(NULL),
    m_pNewParentNode(pParentNode),
    m_originalCondVal(_T("")),
    m_fChanged(false)
{
	//{{AFX_DATA_INIT(CRuleCondition)
	m_newCondValue = _T("");
	//}}AFX_DATA_INIT
}


void CRuleCondition::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRuleCondition)
	DDX_Text(pDX, IDC_ConditionValue, m_newCondValue);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRuleCondition, CMqPropertyPage)
	//{{AFX_MSG_MAP(CRuleCondition)
	ON_BN_CLICKED(IDC_AddRuleCondition_BTM, OnAddRuleConditionBTM)
	ON_BN_CLICKED(IDC_RemoveCondition, OnRemoveCondition)
   	ON_WM_VKEYTOITEM()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CRuleCondition message handlers

void CRuleCondition::OnAddRuleConditionBTM() 
{
    UpdateData();

    if (m_newCondValue.IsEmpty())
    {
        AfxMessageBox(IDS_RULE_CONDITION_REQUIRED);
        GetDlgItem(IDC_ConditionValue)->SetFocus();
        return;
    }

	if (m_newCondValue.GetLength() > xMaxRuleConditionLen)
    {
        CString strError;
        strError.FormatMessage(IDS_COND_LEGTH_EXCEEDED,xMaxRuleConditionLen);
        AfxMessageBox(strError, MB_OK | MB_ICONERROR);

        GetDlgItem(IDC_ConditionValue)->SetFocus();
        return;
    }

    ASSERT(!m_newCondValue.IsEmpty());

    DWORD condTypeIndex = m_pConditionTypesCombo->GetCurSel();
    
    if(condTypeIndex == LB_ERR)
    {
        AfxMessageBox(IDS_COND_TYPE_NOT_SELECTED, MB_OK | MB_ICONERROR);
        m_pCondValueEditBox->SetFocus();

        return;
    }

    ASSERT(ARRAYSIZE(xContionTypeIds) >= condTypeIndex);

    if (! xContionTypeIds[condTypeIndex].m_pfnIsValidValue(m_newCondValue))
    {
        m_pCondValueEditBox->SetFocus();
        return;
    }

    CCondition cond(condTypeIndex, m_newCondValue);

    m_condValues.push_back(cond);

    m_fChanged = true;
    
    //
    // re display the condition list
    //
    DisplayConditionList(static_cast<int>(m_condValues.size()) - 1);

    CMqPropertyPage::OnChangeRWField();

    //
    // clear the condition value field
    //
    m_pCondValueEditBox->SetWindowText(_T(""));
}


void CRuleCondition::InitConditionTypeCombo(CComboBox*	pCombo)
{
    for (DWORD i = 0; i < ARRAYSIZE(xContionTypeIds); ++i)
    {
        CString condType;
        condType.Format(xContionTypeIds[i].m_condTypeId);

        pCombo->InsertString(i, condType);
    }
}


void CRuleCondition::InitConditionList(void)
{    
    ParseConditionStr(m_originalCondVal);
    DisplayConditionList(0);
}


void CRuleCondition::DisplayConditionList(int selectedCell) const
{
    //
    // Clear the list box before adding a list of condition
    //
    m_pRuleConditionList->ResetContent();

    DWORD index = 0;
    for(list<CCondition>::iterator it = m_condValues.begin(); it != m_condValues.end(); ++it, ++index)
    {
		int condListIndex = (*it).m_index;
		CString strValue = (*it).m_value;

		if ( IsStringTypeCondition(condListIndex) )
		{
			strValue = L"\"" + strValue + L"\"";
		}

        
		CString strCondType;
        strCondType.FormatMessage(xContionTypeIds[condListIndex].m_condShortDescrId, strValue);
        
		CString strCondIteam;
        if (index != (m_condValues.size() - 1))
        {
            strCondIteam.FormatMessage(IDS_COND_ITEAM, strCondType);
        }
        else
        {
            strCondIteam = strCondType;
        }

        m_pRuleConditionList->InsertString(index, strCondIteam);
    }

	//
	// Check that the sellected cell isn't out of the list boundray
	//
	if (selectedCell >= m_pRuleConditionList->GetCount())
	{	  
		selectedCell = m_pRuleConditionList->GetCount() - 1;
	}	  
	m_pRuleConditionList->SetCurSel(selectedCell);

	SetScrollSizeForList(m_pRuleConditionList);
}


BOOL CRuleCondition::OnInitDialog() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Initialize pointer to ListBox
    //
    m_pRuleConditionList = (CListBox *)GetDlgItem(IDC_RULECOND_LIST);
    m_pConditionTypesCombo = (CComboBox *)GetDlgItem(IDC_RULE_COND_TYPES);
	m_pCondValueEditBox = (CEdit*)GetDlgItem(IDC_ConditionValue);

    //               `
    // Clear the conditon value
    //
    m_pCondValueEditBox->SetWindowText(_T(""));
    InitConditionTypeCombo(m_pConditionTypesCombo);
    InitConditionList();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE

}


int CRuleCondition::GetCondTypeIndex(LPCTSTR condType)
{
    for (DWORD i = 0; i < ARRAYSIZE(xContionTypeIds); ++i)
    {
        if (wcscmp(xContionTypeIds[i].m_condType, condType) == 0)
            return i;
    }

    return -1;
}


void CRuleCondition::ParseConditionStr(LPCTSTR strCond)
{
	while (strCond != NULL)
	{
		//
		// Get condition type
		//
		CString condType = GetToken(strCond, xConditionValueDelimiter);
		if (condType.IsEmpty())
			break;

		//
		// skip delimeter
		//
		if (*strCond != NULL)
		{
			++strCond;
		}

		//
		// Get condition value
		//
		CString condValue = GetToken(strCond, xConditionDelimiter);

		DWORD condIndex = GetCondTypeIndex(condType);
		if ((condValue.IsEmpty()) || (condIndex == -1))
		{
			AfxMessageBox(IDS_ILLEAGL_CONDITION);
			return;
		}

		CCondition cond(condIndex, RemoveEscapeCharacterFromConditionValue(condValue));
		m_condValues.push_back(cond);

		//
		// Skip condition delimeter
		//
		if (*strCond != NULL)
		{
			++strCond;
		}
	}
}


CString CRuleCondition::AddEscapeCharacterToConditionValue(const CString& val)
{
	LPCWSTR pStart = val;

	CString token;
	LPCWSTR p = pStart;
	LPCWSTR pEnd;

	for(;;)
	{
		pEnd = wcschr(p, xConditionValueDelimiter);

		if (pEnd == NULL)
		{
			token += pStart;
			return token;
		}

		//
		// Check that this is a valid delimeter
		// 
		if((pStart != pEnd) && (*(pEnd - 1) == L'\\'))
		{
			p = pEnd + 1;
			continue;
		}
	
		//
		// Test, we are not in exiting a quoted item
		//
		DWORD NoOfQuote = 0;
		LPCWSTR pQuote;
		for(pQuote = wcschr(pStart, L'\"');	 ((pQuote != NULL) && (pQuote < pEnd)); pQuote = wcschr(pQuote, L'\"') )
		{	
			++NoOfQuote;
			++pQuote;
		}

		if ((NoOfQuote % 2) == 1)
		{
			p = wcschr(pEnd + 1, L'\"');
			if (p == NULL)
				throw exception();
			continue;
		}

		//
		// copy the token and insert it to token list 
		// 
		DWORD len = static_cast<DWORD>(pEnd - pStart);
		token += CString(pStart, len);
		token += L'\\';
		token += xConditionValueDelimiter;

		pStart = p = pEnd + 1;
	}
}


CString CRuleCondition::RemoveEscapeCharacterFromConditionValue(const CString& val)
{
	LPCWSTR pStart = val;

	CString token;
	LPCWSTR p = pStart;
	LPCWSTR pEnd;

	for(;;)
	{
		pEnd = wcschr(p, xConditionValueDelimiter);

		if (pEnd == NULL)
		{
			token += pStart;
			return token;
		}

		//
		// Test, we are not in exiting a quoted item
		//
		DWORD NoOfQuote = 0;
		LPCWSTR pQuote;
		for(pQuote = wcschr(pStart, L'\"');	 ((pQuote != NULL) && (pQuote < pEnd)); pQuote = wcschr(pQuote, L'\"') )
		{	
			++NoOfQuote;
			++pQuote;
		}

		if ((NoOfQuote % 2) == 1)
		{
			p = wcschr(pEnd + 1, L'\"');
			if (p == NULL)
				throw exception();
			continue;
		}

		//
		// Check that this is a valid delimeter
		// 
		if((pStart != pEnd) && (*(pEnd - 1) == L'\\'))
		{
			DWORD len = static_cast<DWORD>(pEnd - pStart - 1);
			token += CString(pStart, len);
			token += xConditionValueDelimiter;
		}
	
		pStart = p = pEnd + 1;
	}
}


CString CRuleCondition::GetCondition(void) const
{
    if (!m_fChanged)
        return static_cast<LPCTSTR>(m_originalCondVal);

    //
    // Build rule condition string
    //
    CString strCond;

    for(list<CCondition>::iterator it = m_condValues.begin(); it != m_condValues.end(); ++it)
    {
        //
        // for each value in rhe map, build 'condition=value\t"
        //
        LPCTSTR condType = xContionTypeIds[it->m_index].m_condType;
        strCond += condType;
        strCond += xConditionValueDelimiter;
        strCond += AddEscapeCharacterToConditionValue(it->m_value);
        strCond += xConditionDelimiter;
    }
    
    return strCond;
}


BOOL CRuleCondition::OnApply() 
{
    try
    {
	    m_pParentNode->OnRuleApply();

        m_originalCondVal = static_cast<LPCTSTR>(GetCondition());
        m_fChanged = false;

        CMqPropertyPage::OnChangeRWField(FALSE);
        return TRUE;
    }
    catch(const _com_error&)
    {
        return FALSE;
    }
}

void CRuleCondition::OnRemoveCondition() 
{
    int nIndex = m_pRuleConditionList->GetCurSel();
	int selectedCell = nIndex;
    if (nIndex == LB_ERR)
    {
        AfxMessageBox(IDS_CONDITION_NOT_SELECTED, MB_OK | MB_ICONERROR);
        return;
    }
    

    for(list<CCondition>::iterator it = m_condValues.begin(); nIndex > 0; ++it, --nIndex)
    {
        NULL;
    }
    m_condValues.erase(it);

    m_fChanged = true;

    //
    // re display the condition list
    //
    DisplayConditionList(selectedCell);

    CMqPropertyPage::OnChangeRWField();
}

//
// Handle the case when users press "Delete" in the rules condition list
// Bug 5974 - YoelA, 14-Nov-01
//
int CRuleCondition::OnVKeyToItem(UINT nKey, CListBox* pListBox, UINT /*nIndex*/)
{
    if (nKey == VK_DELETE &&
        pListBox->m_hWnd == m_pRuleConditionList->m_hWnd
        )
    {
        OnRemoveCondition();
    }
    return -1;
}

BOOL CRuleCondition::OnSetActive() 
{
    if (m_pNewParentNode == NULL)
        return TRUE;

    return m_pNewParentNode->SetWizardButtons();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\restart.h ===
// Restart.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRestart dialog

class CRestart : public CMqDialog
{
// Construction
public:
	CRestart(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CRestart)
	enum { IDD = IDD_RESTART };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRestart)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CRestart)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\rulecond.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    rulecond.h                                     *

Abstract:
	Definition for the rule condition class

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __RULECOND_H__
#define __RULECOND_H__

#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"
#include "snpnerr.h"

#include <list>

/////////////////////////////////////////////////////////////////////////////
// CRuleCondition dialog

class CRuleParent;

class CRuleCondition : public CMqPropertyPage
{
friend class CNewRule;

// Construction
public:
	CRuleCondition(
        CRuleParent* pParentNode, 
        _bstr_t condition
        );

	CRuleCondition(
        CNewRule* pParentNode
        );


	virtual ~CRuleCondition()
    {
    }

    CString GetCondition(void) const;

// Dialog Data
	//{{AFX_DATA(CRuleCondition)
	enum { IDD_NEW = IDD_NEW_TRIGGER_RULE_COND, IDD_VIEW = IDD_TRIGGER_RULE_COND };
	CString	m_newCondValue;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRuleCondition)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRuleCondition)
	virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive();
	afx_msg void OnAddRuleConditionBTM();
	afx_msg void OnRemoveCondition();
	afx_msg int  OnVKeyToItem(UINT nKey, CListBox* pListBox, UINT nIndex);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()


private:
    class CCondition
    {
    public:
        CCondition(DWORD index, CString value) :
            m_index(index),
            m_value(value)
        {
        }
    
    public:
        DWORD m_index;
        CString m_value;
    };

private:
    static void InitConditionTypeCombo(CComboBox* pCombo);
	static CString AddEscapeCharacterToConditionValue(const CString& val);
	static CString RemoveEscapeCharacterFromConditionValue(const CString& val);

private:
    void InitConditionList(void);
    void ParseConditionStr(LPCTSTR cond);
    int GetCondTypeIndex(LPCTSTR condType);
    void DisplayConditionList(int selectedCell) const;


private:
	CListBox*	m_pRuleConditionList;
	CComboBox*	m_pConditionTypesCombo;
	CEdit*      m_pCondValueEditBox;

    R<CRuleParent> m_pParentNode;
    CNewRule* m_pNewParentNode;

    _bstr_t m_originalCondVal;
    
    std::list<CCondition> m_condValues;

    bool m_fChanged;
};

const LPCWSTR xConditionTypes[] = {
    _T("$MSG_LABEL_CONTAINS"),
    _T("$MSG_LABEL_DOES_NOT_CONTAIN"),
    _T("$MSG_BODY_CONTAINS"),
    _T("$MSG_BODY_DOES_NOT_CONTAIN"),
    _T("$MSG_PRIORITY_EQUALS"),
    _T("$MSG_PRIORITY_NOT_EQUAL"),
    _T("$MSG_PRIORITY_GREATER_THAN"),
    _T("$MSG_PRIORITY_LESS_THAN"),
    _T("$MSG_APPSPECIFIC_EQUALS"),
    _T("$MSG_APPSPECIFIC_NOT_EQUAL"),
    _T("$MSG_APPSPECIFIC_GREATER_THAN"),
    _T("$MSG_APPSPECIFIC_LESS_THAN"),
    _T("$MSG_SRCMACHINEID_EQUALS"),
    _T("$MSG_SRCMACHINEID_NOT_EQUAL"),
};

#endif //__RULECOND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\ruledef.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    ruledef.h                                     *

Abstract:
	Definition for the class

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __RULDEF_H__
#define __RULDEF_H__

#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"
#include "snpnerr.h"
#include "snpnres.h"

#include "rule.h"

class CRuleResult;
class CNewRule;
class CRuleCondition;
class CRuleParent;

// -----------------------------------------------------
//
// CRulesDefinition
//
// -----------------------------------------------------
class CRulesDefinition :  public CNodeWithResultChildrenList<CRulesDefinition, CRuleResult, CSimpleArray<CRuleResult*>, FALSE>
{
public:
   	BEGIN_SNAPINCOMMAND_MAP(CRulesDefinition, FALSE)
		SNAPINCOMMAND_ENTRY(ID_NEW_NEWRULE, OnNewRule)
	END_SNAPINCOMMAND_MAP()

   	SNAPINMENUID(IDR_RULE_DEF_MENU)

    CRulesDefinition(
        CSnapInItem * pParentNode, 
        CSnapin * pComponentData, 
        CRuleSet* pRuleSet
        ) : 
        CNodeWithResultChildrenList<CRulesDefinition, CRuleResult, CSimpleArray<CRuleResult*>, FALSE>(pParentNode, pComponentData),
        m_pRuleSet(SafeAddRef(pRuleSet))
    {
		//
		// Specify that trigger scop item doesn't have any child item
		//
		m_scopeDataItem.mask |= SDI_CHILDREN;
		m_scopeDataItem.cChildren = 0;

		SetIcons(IMAGE_RULES_DEFINITION,IMAGE_RULES_DEFINITION);
    }

	~CRulesDefinition()
    {
    }

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES /*type*/)
	{
		return S_FALSE;
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

	virtual HRESULT PopulateResultChildrenList();
	virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);

    HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

private:
	//
	// Menu functions
	//
	HRESULT OnNewRule(bool &bHandled, CSnapInObjectRootBase* pObj);
	virtual CString GetHelpLink();

private:
    R<CRuleSet> m_pRuleSet;
};



/////////////////////////////////////////////////////////////////////////////
// CRuleGeneral dialog

class CRuleGeneral : public CMqPropertyPage
{
friend class CNewRule;

// Construction
public:
    CRuleGeneral(UINT nIDPage, UINT nIDCaption = 0);

// Dialog Data
	//{{AFX_DATA(CRuleGeneral)
	CString	m_ruleName;
	CString	m_ruleDescription;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRuleGeneral)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRuleGeneral)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG

private:
	virtual void SetDlgTitle() {};

};


/////////////////////////////////////////////////////////////////////////////
// CNewRuleGeneral page

class CNewRuleGeneral : public CRuleGeneral
{

public:
    CNewRuleGeneral(CNewRule* pParentNode);

	enum { IDD = IDD_NEW_TRIGGER_RULE_GENEARL };

	// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRuleGeneral)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	// Generated message map functions
	//{{AFX_MSG(CRuleGeneral)
    virtual BOOL OnSetActive();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    CNewRule* m_pNewParentNode;

};


/////////////////////////////////////////////////////////////////////////////
// CViewRuleGeneral page

class CViewRuleGeneral : public CRuleGeneral
{

public:
	CViewRuleGeneral(
        CRuleParent* pParentNode, 
        _bstr_t name, 
        _bstr_t description
        );

	~CViewRuleGeneral();

	enum { IDD = IDD_TRIGGER_RULE_GENEARL };

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRuleGeneral)
	public:
	virtual BOOL OnApply();
	//}}AFX_VIRTUAL

protected:
	DECLARE_MESSAGE_MAP()

private:
	void SetDlgTitle();

    R<CRuleParent> m_pParentNode;

};


class CRuleParent
{
friend class CViewRuleGeneral;
friend class CRuleCondition;
friend class CRuleAction;

public:
	CRuleParent(
		) :
		m_pGeneral(NULL),
		m_pCond(NULL),
		m_pAction(NULL),
		m_rule(NULL)
	{
	}

	CRuleParent(
		CRule* pRule
		) :
		m_pGeneral(NULL),
		m_pCond(NULL),
		m_pAction(NULL),
		m_rule(SafeAddRef(pRule))
	{
	}

	virtual void AddRef() = 0;
	virtual void Release() = 0;

    const _bstr_t& GetRuleId(void) const
    {
		ASSERT(m_rule.get() != NULL);
        return m_rule->GetRuleId();
    }

    const _bstr_t& GetRuleName(void) const
    {
		ASSERT(m_rule.get() != NULL);
        return m_rule->GetRuleName();
    }

    const _bstr_t& GetRuleDescription(void) const
    {
		ASSERT(m_rule.get() != NULL);
        return m_rule->GetRuleDescription();
    }

    const _bstr_t& GetRuleAction(void) const
    {
		ASSERT(m_rule.get() != NULL);
        return m_rule->GetRuleAction();
    }

    const _bstr_t& GetRuleCondition(void) const
    {
		ASSERT(m_rule.get() != NULL);
        return m_rule->GetRuleCondition();
    }

    bool GetShowWindow(void) const
    {
		ASSERT(m_rule.get() != NULL);
        return m_rule->GetShowWindow();
    }

	void OnDestroyPropertyPages(void);

protected:
    void OnRuleApply() throw (_com_error);

protected:
    R<CRule> m_rule;

    CRuleGeneral* m_pGeneral;
    CRuleCondition* m_pCond;
    CRuleAction* m_pAction;

};


class CRuleResult : public CSnapinNode<CRuleResult, FALSE>, public CRuleParent
{

public:
    CRuleResult(
        CSnapInItem * pParentNode, 
        CSnapin * pComponentData,
        CRule* pRule
        ): 
        CSnapinNode<CRuleResult, FALSE>(pParentNode, pComponentData),
		CRuleParent(pRule)
    {   
        //
        // Set display name
        //
        m_bstrDisplayName = (BSTR) m_rule->GetRuleName();

		SetIcons(IMAGE_RULES_DEFINITION, IMAGE_RULES_DEFINITION);
	}

    
    virtual ~CRuleResult() 
    {
    }

	virtual void AddRef()
	{
		return CSnapinNode<CRuleResult, FALSE>::AddRef();
	}
	virtual void Release()
	{
		return CSnapinNode<CRuleResult, FALSE>::Release();
	}
    
    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

    STDMETHOD(CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type
        );

    LPOLESTR GetResultPaneColInfo(int nCol);

    virtual HRESULT OnDelete( 
			LPARAM arg,
			LPARAM param,
			IComponentData * pComponentData,
			IComponent * pComponent,
			DATA_OBJECT_TYPES type,
            BOOL fSilent
			);

public:
	static void Compare(CRuleResult *pItem1, CRuleResult *pItem2, int* pnResult);


private:
    HRESULT CreateGenralPage(HPROPSHEETPAGE *phGeneralRule);
    HRESULT CreateConditionPage(HPROPSHEETPAGE *phGeneralRule);
    HRESULT CreateActionPage(HPROPSHEETPAGE *phGeneralRule);
	virtual CString GetHelpLink();
};




#endif // __RULDEF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\secopt.cpp ===
// Storage.cpp : implementation file
//
#include "stdafx.h"
#include <winreg.h>
#include "mqsnap.h"
#include "resource.h"
#include "globals.h"
#include "mqppage.h"
#include "_registr.h"
#include "localutl.h"
#include "secopt.h"
#include "mqsnhlps.h"

#include "secopt.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSecurityOptionsPage property page

IMPLEMENT_DYNCREATE(CSecurityOptionsPage, CMqPropertyPage)

CSecurityOptionsPage::CSecurityOptionsPage() :
	CMqPropertyPage(CSecurityOptionsPage::IDD),
	m_MsmqName(L"")
{
	
    DWORD Type = REG_DWORD;
	DWORD Size = sizeof(DWORD);
	DWORD RegValue;
	
	//
	// Get Message Dep clients key
	//
	DWORD Default = MSMQ_DEAFULT_MQS_DEPCLIENTS;
    LONG rc = GetFalconKeyValue(
					MSMQ_MQS_DEPCLINTS_REGNAME,
					&Type,
					&RegValue,
					&Size, 
					(LPWSTR)&Default
					);

	if (rc != ERROR_SUCCESS)
	{
		TrERROR(GENERAL, "Failed to get key %ls. Error: %!winerr!", MSMQ_MQS_DEPCLINTS_REGNAME, rc);
	    DisplayFailDialog();
	    return;
	}

	//
	// Default value is the more secured option so if we have the default, 
	// the checkbox will be checked
	//
	m_fOldOptionDepClients = (RegValue == MSMQ_DEAFULT_MQS_DEPCLIENTS);

	//
	// Get MSMQ hardened option
	//
	Default = MSMQ_LOCKDOWN_DEFAULT;
	rc = GetFalconKeyValue(
					MSMQ_LOCKDOWN_REGNAME,
					&Type,
					&RegValue,
					&Size, 
					(LPWSTR)&Default
					);

    if (rc != ERROR_SUCCESS)
    {
		TrERROR(GENERAL, "Failed to get key %ls. Error: %!winerr!", MSMQ_LOCKDOWN_REGNAME, rc);
        DisplayFailDialog();
        return;
    }
	m_fOldOptionHardenedMSMQ = (RegValue != MSMQ_LOCKDOWN_DEFAULT);
	
	//
	// Get remote read option
	//
	Default = MSMQ_DENY_OLD_REMOTE_READ_DEFAULT;
	rc = GetFalconKeyValue(
					MSMQ_DENY_OLD_REMOTE_READ_REGNAME,
					&Type,
					&RegValue,
					&Size, 
					(LPWSTR)&Default
					);

    if (rc != ERROR_SUCCESS)
    {
		TrERROR(GENERAL, "Failed to get key %ls. Error: %!winerr!", MSMQ_DENY_OLD_REMOTE_READ_REGNAME, rc);
        DisplayFailDialog();
        return;
    }
	
	m_fOldOptionOldRemoteRead = (RegValue != MSMQ_DENY_OLD_REMOTE_READ_DEFAULT);

	//{{AFX_DATA_INIT(CSecurityOptionsPage)
    m_fNewOptionDepClients = m_fOldOptionDepClients;
	m_fNewOptionHardenedMSMQ = m_fOldOptionHardenedMSMQ;
	m_fNewOptionOldRemoteRead = m_fOldOptionOldRemoteRead;
    //}}AFX_DATA_INIT
}

CSecurityOptionsPage::~CSecurityOptionsPage()
{
}

void CSecurityOptionsPage::SetMSMQName(CString MSMQName)
{
	m_MsmqName = MSMQName;
}


void CSecurityOptionsPage::DoDataExchange(CDataExchange* pDX)
{    
    CMqPropertyPage::DoDataExchange(pDX);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //{{AFX_DATA_MAP(CSecurityOptionsPage)
    DDX_Check(pDX, IDC_OPTION_DEP_CLIENTS, m_fNewOptionDepClients);
	DDX_Check(pDX, IDC_OPTION_HARDENED_MSMQ, m_fNewOptionHardenedMSMQ);
	DDX_Check(pDX, IDC_OPTION_OLD_REMOTE_READ, m_fNewOptionOldRemoteRead);
	DDX_Control(pDX, IDC_RESTORE_SECURITY_OPTIONS, m_ResoreDefaults);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        //
        // Identify changes in values.
        //
        if ((m_fNewOptionDepClients != m_fOldOptionDepClients) ||
			(m_fNewOptionHardenedMSMQ != m_fOldOptionHardenedMSMQ) ||
			(m_fNewOptionOldRemoteRead != m_fOldOptionOldRemoteRead))
        {
            m_fModified = TRUE;
        }
    }
}

BOOL CSecurityOptionsPage::OnInitDialog()
{
    CMqPropertyPage::OnInitDialog();

	//
	// If we already have the default values when loading the form - disable 
	// Restore Defaults button.
	//
	if ((m_fNewOptionDepClients != MSMQ_DEAFULT_MQS_DEPCLIENTS) &&
		(m_fNewOptionHardenedMSMQ == MSMQ_LOCKDOWN_DEFAULT) &&
		(m_fNewOptionOldRemoteRead == MSMQ_DENY_OLD_REMOTE_READ_DEFAULT))
	{
		m_ResoreDefaults.EnableWindow(FALSE);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CSecurityOptionsPage::OnApply() 
{
    if (!m_fModified)
    {
        return TRUE;     
    }

	//
	// This function will check MSMQ service state, ask the user
	// whether to stop it, and stop the service. Error messages inside.
	//
	BOOL fServiceWasRunning;
	if (!TryStopMSMQServiceIfStarted(&fServiceWasRunning, this))
	{
		return FALSE;
	}

	DWORD Type = REG_DWORD;
	DWORD Size = sizeof(DWORD);

	if (m_fNewOptionDepClients != m_fOldOptionDepClients)
	{
		DWORD Value = !m_fNewOptionDepClients;

		//
		// Set dep clients key in ds
		//
		PROPID pPropid[1];
	    DWORD PropCount = 1;
	    PROPVARIANT pVar[1];
    
	    DWORD iProperty = 0;

        pPropid[iProperty] = PROPID_QM_SERVICE_DEPCLIENTS;
        pVar[iProperty].vt = VT_UI1;
	    pVar[iProperty++].uiVal = Value;

        HRESULT hr = ADSetObjectProperties(
		                eMACHINE,
		                MachineDomain(),
						false,
		                m_MsmqName,
		                PropCount, 
		                pPropid, 
		                pVar
		                );

        if (FAILED(hr))
        {
            MessageDSError(hr, IDS_OP_SET_PROPERTIES_OF, m_MsmqName);
            return FALSE;
        }    

        //
		// Set dep clients key in registry
		//
		LONG rc = SetFalconKeyValue( 
						MSMQ_MQS_DEPCLINTS_REGNAME,
						&Type,
						&Value,
						&Size);
		
		if(rc != ERROR_SUCCESS)
		{
			TrERROR(GENERAL, "Failed to write key %ls. Error: %!winerr!", MSMQ_MQS_DEPCLINTS_REGNAME, rc);
			return FALSE;
		}
	}

	if (m_fNewOptionHardenedMSMQ != m_fOldOptionHardenedMSMQ)
	{
		//
		// Set hardened MSMQ key
		//
		DWORD Value = m_fNewOptionHardenedMSMQ;
		LONG rc = SetFalconKeyValue(
					MSMQ_LOCKDOWN_REGNAME,
					&Type,
					&Value,
					&Size);
	
		if(rc != ERROR_SUCCESS)
		{
			TrERROR(GENERAL, "Failed to write key %ls. Error: %!winerr!", MSMQ_LOCKDOWN_REGNAME, rc);
			return FALSE;
		}
	}

	if (m_fNewOptionOldRemoteRead != m_fOldOptionOldRemoteRead)
	{
		//
		// Set remote read key
		//
		DWORD Value = m_fNewOptionOldRemoteRead;
		LONG rc = SetFalconKeyValue(
					MSMQ_DENY_OLD_REMOTE_READ_REGNAME,
					&Type,
					&Value,
					&Size);
	
		if(rc != ERROR_SUCCESS)
		{
			TrERROR(GENERAL, "Failed to write key %ls. Error: %!winerr!", MSMQ_DENY_OLD_REMOTE_READ_REGNAME, rc);
			return FALSE;
		}
	}

	if (fServiceWasRunning)
	{
		m_fNeedReboot = TRUE;
	}

	//
	// Update old values
	//
	m_fOldOptionDepClients = m_fNewOptionDepClients;
	m_fOldOptionHardenedMSMQ = m_fNewOptionHardenedMSMQ;
	m_fOldOptionOldRemoteRead = m_fNewOptionOldRemoteRead;
	
	m_fModified = FALSE;

    return CMqPropertyPage::OnApply();
}

VOID CSecurityOptionsPage::OnRestoreSecurityOptions()
{
	((CButton*)GetDlgItem(IDC_OPTION_DEP_CLIENTS))->SetCheck(BST_CHECKED);
	((CButton*)GetDlgItem(IDC_OPTION_HARDENED_MSMQ))->SetCheck(BST_UNCHECKED);
	((CButton*)GetDlgItem(IDC_OPTION_OLD_REMOTE_READ))->SetCheck(BST_UNCHECKED);
	m_ResoreDefaults.EnableWindow(FALSE);

	OnChangeRWField();
}

VOID CSecurityOptionsPage::OnCheckSecurityOption()
{
	m_ResoreDefaults.EnableWindow(TRUE);

	OnChangeRWField();
}

BEGIN_MESSAGE_MAP(CSecurityOptionsPage, CMqPropertyPage)
    //{{AFX_MSG_MAP(CSecurityOptionsPage)  
    ON_BN_CLICKED(IDC_OPTION_DEP_CLIENTS, OnCheckSecurityOption)
    ON_BN_CLICKED(IDC_OPTION_HARDENED_MSMQ, OnCheckSecurityOption)
    ON_BN_CLICKED(IDC_OPTION_OLD_REMOTE_READ, OnCheckSecurityOption)
	ON_BN_CLICKED(IDC_RESTORE_SECURITY_OPTIONS, OnRestoreSecurityOptions)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSecurityOptionsPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\service.cpp ===
#include <stdafx.h>

//#include "cpldef.h"
#include <winsvc.h>
//#include "ctlpnl.h"
#include <mqtypes.h>
#include <_mqdef.h>
/*
#ifndef DLL_IMPORT
#define DLL_IMPORT __declspec(dllimport)
#endif
*/
#include <_registr.h>
#include <tlhelp32.h>
#include "localutl.h"
#include "globals.h"
#include "autorel.h"
#include "autorel2.h"
#include "mqtg.h"
#include "acioctl.h"
#include "acdef.h"
#include "acapi.h"

#include "service.tmh"

#define MQQM_SERVICE_FILE_NAME  TEXT("mqsvc.exe")
#define MQDS_SERVICE_NAME       TEXT("MQDS")

#define WAIT_INTERVAL	50
#define MAX_WAIT_FOR_SERVICE_TO_STOP	5*60*1000  // 5 minutes


static
BOOL
GetServiceAndScmHandles(
    SC_HANDLE *phServiceCtrlMgr,
    SC_HANDLE *phService,
    DWORD dwAccessType)
{
    *phServiceCtrlMgr = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (*phServiceCtrlMgr == NULL)
    {
        MessageDSError(GetLastError(), IDS_SERVICE_MANAGER_PRIVILEGE_ERROR);

        return FALSE;
    }

    *phService = OpenService(*phServiceCtrlMgr, MQQM_SERVICE_NAME, dwAccessType);
    if (*phService == NULL)
    {
        MessageDSError(GetLastError(), IDS_SERVICE_PRIVILEGE_ERROR);

        CloseServiceHandle(*phServiceCtrlMgr);
        return FALSE;
    }
    return TRUE;
}


static
BOOL
GetMSMQProcessHandle(
    SC_HANDLE hService,
    HANDLE *phProcess
	)
{
	*phProcess = 0;

	//
	// Get service process ID
	//
    SERVICE_STATUS_PROCESS ServiceStatusProcess;
	DWORD dwBytesNeeded;
    BOOL fSucc = QueryServiceStatusEx(
								hService,
								SC_STATUS_PROCESS_INFO,
								reinterpret_cast<LPBYTE>(&ServiceStatusProcess),
								sizeof(ServiceStatusProcess),
								&dwBytesNeeded
								);
    
    if(!fSucc)
    {
        MessageDSError(GetLastError(), IDS_QUERY_SERVICE_ERROR);
		return FALSE;
	}

	//
	// Get hanlde to the service process
	//
	HANDLE hProcess = OpenProcess(SYNCHRONIZE, FALSE, ServiceStatusProcess.dwProcessId);
	
	if (hProcess == NULL)
	{
		//
		// The service is stopped. Either we got a 0
		// process ID in ServiceStatusProcess, or the ID
		// that we got was of a process that already stopped
		//
		if (GetLastError() == ERROR_INVALID_PARAMETER)
		{
			return TRUE;
		}

        MessageDSError(GetLastError(), IDS_OPEN_PROCESS_ERROR);
		return FALSE;
	}

	*phProcess = hProcess;
	return TRUE;
}


static
BOOL
AskUserIfStopServices(
	LPENUM_SERVICE_STATUS lpServiceStruct,
	DWORD nServices
	)
{
	CString strServicesList;
	UINT numOfDepServices = 0;
	//
	// Build a list of all active dependent services
	// Write each one at new line
	//
	for ( DWORD i = 0; i < nServices; i ++ )
	{
		if ( (_wcsicmp(lpServiceStruct[i].lpServiceName, xDefaultTriggersServiceName) == 0) ||
			 (_wcsicmp(lpServiceStruct[i].lpServiceName, MQDS_SERVICE_NAME) == 0) )
		{
			continue;
		}

		strServicesList += "\n";
		strServicesList += "\"";
		strServicesList += lpServiceStruct[i].lpDisplayName;
		strServicesList += "\"";
		
		numOfDepServices++;
	}

	if ( numOfDepServices == 0 )
	{
		return TRUE;
	}

	CString strMessage;
	strMessage.FormatMessage(IDS_DEP_SERVICES_LIST, strServicesList);
	return ( AfxMessageBox(strMessage, MB_OKCANCEL) == IDOK );
}


static
BOOL
WaitForServiceToStop(
	SC_HANDLE hService
	)
{
	DWORD dwWait = 0;

	for (;;)
	{
		SERVICE_STATUS ServiceStatus;
		if (!QueryServiceStatus(hService, &ServiceStatus))
		{
			//
			//  indication here is not helpful for the user.
			//
			return FALSE;
		}

		if (ServiceStatus.dwCurrentState == SERVICE_STOPPED)
		{
			return TRUE;
		}
		
		if ( dwWait > MAX_WAIT_FOR_SERVICE_TO_STOP )
		{
			//
			// If this routine fails, and error message will be displayed.
			// The routine that displays the message does GetLastError()
			// In this case we need to specify what happened.
			//
			SetLastError(ERROR_SERVICE_REQUEST_TIMEOUT);
			return FALSE;
		}

		Sleep(WAIT_INTERVAL);
		dwWait += WAIT_INTERVAL;
	}
}


BOOL
WaitForMSMQServiceToTerminate(
	HANDLE hProcess
	)
{
	if (hProcess == 0)
	{
		return TRUE;
	}

	//
	// Wait on MSMQ service process handle
	//
	DWORD dwRes = WaitForSingleObject(hProcess, MAX_WAIT_FOR_SERVICE_TO_STOP);

	if (dwRes == WAIT_OBJECT_0)
	{
		return TRUE;
	}

	if (dwRes == WAIT_FAILED )
	{
		return FALSE;
	}

	//
	// We had timeout.
	// If this routine fails, and error message will be displayed.
	// The routine that displays the message does GetLastError()
	// In this case we need to specify what happened.
	//
	ASSERT(dwRes == WAIT_TIMEOUT);
	SetLastError(ERROR_SERVICE_REQUEST_TIMEOUT);
	return FALSE;
}


static
BOOL
StopSingleDependentService(
	SC_HANDLE hServiceMgr,
	LPCWSTR pszServiceName
	)	
{
	CServiceHandle hService( OpenService(
								hServiceMgr, 
								pszServiceName, 
								SERVICE_STOP | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS
								) );	
	if (hService == 0)
	{
		return FALSE;
	}

	SERVICE_STATUS ServiceStatus;
	BOOL fRet = ControlService(hService, SERVICE_CONTROL_STOP, &ServiceStatus);

	if ( !fRet && GetLastError() != ERROR_SERVICE_NOT_ACTIVE)
	{
		return FALSE;
	}

	//
	// Wait untill state = SERVICE_STOPPED
	//
	fRet = WaitForServiceToStop(hService);

	return fRet;
}


//
// StopDependentServices
//
// This function stops all services dependent on MSMQ. 
// Enumeration of dependent services gives a list in descending
// degree of depedency. Stopping the services in order that the 
// enumeration gives will not cause dependency clashes.
//
static
BOOL
StopDependentServices(
	SC_HANDLE hServiceMgr,
	SC_HANDLE hService,
	CWaitCursor& wc
	)
{
	DWORD dwBytesNeeded, nServices;

	//
	// Try to find out how much memory is needed for data
	//
	BOOL fRet = EnumDependentServices(
					hService,
					SERVICE_ACTIVE,
					NULL,
					0,
					&dwBytesNeeded,
					&nServices
					);

	//
	// Zero dependent services
	//
	if ( fRet )
	{
		return TRUE;
	}

	if ( !fRet && GetLastError() != ERROR_MORE_DATA )
	{
		MessageDSError(GetLastError(), IDS_ENUM_MSMQ_DEPEND);
		return FALSE;
	}

	AP<ENUM_SERVICE_STATUS> lpServiceStruct = reinterpret_cast<LPENUM_SERVICE_STATUS>(new BYTE[dwBytesNeeded]);
	DWORD dwBuffSize = dwBytesNeeded;

	//
	// Get all the data
	//
	if ( !EnumDependentServices(
					hService,
					SERVICE_ACTIVE,
					lpServiceStruct,
					dwBuffSize,
					&dwBytesNeeded,
					&nServices
					) )
	{
		MessageDSError(GetLastError(), IDS_ENUM_MSMQ_DEPEND);
		return FALSE;
	}

	//
	// Ask user if it is OK to stop all dependent services
	//
	if ( !AskUserIfStopServices(lpServiceStruct, nServices))
	{
		return FALSE;
	}

	wc.Restore();

	for ( DWORD i = 0; i < nServices; i ++ )
	{
		for(;;)
		{
			fRet = StopSingleDependentService(
							hServiceMgr, 
							lpServiceStruct[i].lpServiceName
							);
			if ( !fRet )
			{
				BOOL fRetry = MessageDSError(
									GetLastError(),
									IDS_STOP_SERVICE_ERR, 
									lpServiceStruct[i].lpDisplayName,
									MB_RETRYCANCEL | MB_ICONEXCLAMATION
									);
				
				//
				// User asked for retry
				//
				if (fRetry == IDRETRY)
				{
					wc.Restore();
					continue;
				}

				return FALSE;
			}

			break;
		}
	}

	return TRUE;	
}


//
// See whether the service is running.
//
BOOL
GetServiceRunningState(
    BOOL *pfServiceIsRunning)
{
    SC_HANDLE hServiceCtrlMgr;
    SC_HANDLE hService;

    //
    // Get a handle to the service.
    //
    if (!GetServiceAndScmHandles(&hServiceCtrlMgr,
                             &hService,
                             SERVICE_QUERY_STATUS))
    {
        return FALSE;
    }

	//
	// Automatic wrappers
	//
	CServiceHandle hSCm(hServiceCtrlMgr);
	CServiceHandle hSvc(hService);

    //
    // Query the service status.
    //
    SERVICE_STATUS SrviceStatus;
    if (!QueryServiceStatus(hService, &SrviceStatus))
    {
        MessageDSError(GetLastError(), IDS_QUERY_SERVICE_ERROR);
		return FALSE;
    }
    else
    {
        *pfServiceIsRunning = SrviceStatus.dwCurrentState == SERVICE_RUNNING;
    }

    return TRUE;
}


//
// Stop the MQQM service.
//
BOOL
StopService()
{
	CWaitCursor wc;

    //
    // Get a handle to the service.
    //
    SC_HANDLE hServiceCtrlMgr;
    SC_HANDLE hService;

    if (!GetServiceAndScmHandles(&hServiceCtrlMgr,
                             &hService,
                             SERVICE_STOP | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS))
    {
        return FALSE;
    }

 	//
	// Automatic wrappers
	//
	CServiceHandle hSCm(hServiceCtrlMgr);
	CServiceHandle hSvc(hService);

	CHandle hProcess;
	if (!GetMSMQProcessHandle(hService, &hProcess))
	{
		return FALSE;
	}

	//
    // Stop the service.
    //
	SERVICE_STATUS SrviceStatus;
	DWORD dwErr;
	BOOL fRet;

	for(;;)
	{
		fRet = ControlService(hService,
							  SERVICE_CONTROL_STOP,
							  &SrviceStatus);

		dwErr = GetLastError();

		//
		// If service is already stopped, or there are dependent services active
		// it is normal situtation. Other cases are errors.
		//
		if (!fRet && 
			dwErr != ERROR_SERVICE_NOT_ACTIVE && 
			dwErr != ERROR_DEPENDENT_SERVICES_RUNNING)
		{
			if ( MessageDSError(
							dwErr,
							IDS_STOP_SERVICE_ERROR, 
							NULL,
							MB_RETRYCANCEL | MB_ICONEXCLAMATION) == IDRETRY)
			{
				wc.Restore();
				continue;
			}

			return FALSE;
		}

		break;
	}

	//
	// If there are dependent serivices running, attempt to stop them
	//
	if ( !fRet && dwErr == ERROR_DEPENDENT_SERVICES_RUNNING)
	{
		fRet = StopDependentServices(hServiceCtrlMgr, hService, wc);
		if ( !fRet )
		{
			return FALSE;
		}

		for(;;)
		{
			//
			// Send Stop control to QM again - it should not fail this time
			//
			fRet = ControlService(hService,
					  SERVICE_CONTROL_STOP,
					  &SrviceStatus);

			
			if ( !fRet && 
			   (GetLastError() != ERROR_SERVICE_NOT_ACTIVE) )
			{
				if ( MessageDSError(
							GetLastError(),
							IDS_STOP_SERVICE_ERROR, 
							NULL,
							MB_RETRYCANCEL | MB_ICONEXCLAMATION) == IDRETRY)
				{
					wc.Restore();
					continue;
				}

				return FALSE;
			}

			break;
		}

	}

	for(;;)
	{
		if (!WaitForMSMQServiceToTerminate(hProcess) )
		{
			if ( MessageDSError(
						GetLastError(), 
						IDS_STOP_SERVICE_ERROR, 
						NULL, 
						MB_RETRYCANCEL | MB_ICONEXCLAMATION) == IDRETRY)
			{
				wc.Restore();
				continue;
			}

			return FALSE;
		}

		break;
	}

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\secopt.h ===
// Secopt.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSecurityOptionsPage dialog

class CSecurityOptionsPage : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CSecurityOptionsPage)

// Construction
public:
	CSecurityOptionsPage();
	~CSecurityOptionsPage(); 
	void SetMSMQName(CString MSMQName);
	
// Dialog Data
	//{{AFX_DATA(CSecurityOptionsPage)
	enum { IDD = IDD_SECURITY_OPTIONS };
	BOOL	m_fNewOptionDepClients;
	BOOL	m_fNewOptionHardenedMSMQ;
	BOOL	m_fNewOptionOldRemoteRead;
	CButton m_ResoreDefaults;
	//}}AFX_DATA
// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSecurityOptionsPage)
public:
    virtual BOOL OnApply();
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	
private:
	BOOL m_fOldOptionDepClients;
	BOOL m_fOldOptionHardenedMSMQ;
	BOOL m_fOldOptionOldRemoteRead;

	CString m_MsmqName;
	 
protected:
	// Generated message map functions
	//{{AFX_MSG(CSecurityOptionsPage)    
	afx_msg void OnRestoreSecurityOptions();
	afx_msg void OnCheckSecurityOption();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\snapin.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	snapin.cpp

Abstract:

	Implementation file for the CSnapinExt snapin node class.
    This class expands the DS Snapin objects

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "mqsnap.h"
#include "Snapin.h"
#include "rdmsg.h"
#include "globals.h"
#include "cpropmap.h"
#include "message.h"
#include "localadm.h"
#include "dsext.h"
#include "qnmsprov.h"
#include "localfld.h"
#include "privadm.h"

#import "mqtrig.tlb" no_namespace

#include "mqppage.h"
#include "rule.h"
#include "trigger.h"
#include "trigdef.h"
#include "ruledef.h"

#include "snapin.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSnapinComponentData
static const GUID CSnapinGUID_NODETYPE = 
{ 0x74e5637c, 0xb98c, 0x11d1, { 0x9b, 0x9b, 0x0, 0xe0, 0x2c, 0x6, 0x4c, 0x39 } };
const GUID*  CSnapinData::m_NODETYPE = &CSnapinGUID_NODETYPE;
const OLECHAR* CSnapinData::m_SZNODETYPE = OLESTR("74E5637C-B98C-11D1-9B9B-00E02C064C39");
const OLECHAR* CSnapinData::m_SZDISPLAY_NAME = OLESTR("MSMQAdmin");
const CLSID* CSnapinData::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;

HRESULT CSnapinData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
	IUnknown* /*pUnk*/,
	DATA_OBJECT_TYPES type)
{
	if (type == CCT_SCOPE || type == CCT_RESULT)
	{
		P<CSnapinPage> pPage = new CSnapinPage(handle, true, _T("Snapin"));
		lpProvider->AddPage(pPage->Create());
		// The second parameter  to the property page class constructor
		// should be true for only one page.

		// TODO : Add code here to add additional pages
		pPage.detach();
		return S_OK;
	}
	return E_UNEXPECTED;
}

HRESULT CSnapinData::GetScopePaneInfo(SCOPEDATAITEM *pScopeDataItem)
{
	if (pScopeDataItem->mask & SDI_STR)
		pScopeDataItem->displayname = m_bstrDisplayName;
	if (pScopeDataItem->mask & SDI_IMAGE)
		pScopeDataItem->nImage = m_scopeDataItem.nImage;
	if (pScopeDataItem->mask & SDI_OPENIMAGE)
		pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
	if (pScopeDataItem->mask & SDI_PARAM)
		pScopeDataItem->lParam = m_scopeDataItem.lParam;
	if (pScopeDataItem->mask & SDI_STATE )
		pScopeDataItem->nState = m_scopeDataItem.nState;

	// TODO : Add code for SDI_CHILDREN 
	return S_OK;
}

HRESULT CSnapinData::GetResultPaneInfo(RESULTDATAITEM *pResultDataItem)
{
	if (pResultDataItem->bScopeItem)
	{
		if (pResultDataItem->mask & RDI_STR)
		{
			pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
		}
		if (pResultDataItem->mask & RDI_IMAGE)
		{
			pResultDataItem->nImage = m_scopeDataItem.nImage;
		}
		if (pResultDataItem->mask & RDI_PARAM)
		{
			pResultDataItem->lParam = m_scopeDataItem.lParam;
		}

		return S_OK;
	}

	if (pResultDataItem->mask & RDI_STR)
	{
		pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
	}
	if (pResultDataItem->mask & RDI_IMAGE)
	{
		pResultDataItem->nImage = m_resultDataItem.nImage;
	}
	if (pResultDataItem->mask & RDI_PARAM)
	{
		pResultDataItem->lParam = m_resultDataItem.lParam;
	}
	if (pResultDataItem->mask & RDI_INDEX)
	{
		pResultDataItem->nIndex = m_resultDataItem.nIndex;
	}

	return S_OK;
}

HRESULT CSnapinData::Notify( MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM /*param*/,
	IComponentData* pComponentData,
	IComponent* pComponent,
	DATA_OBJECT_TYPES /*type*/)
{
	// Add code to handle the different notifications.
	// Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
	// In response to MMCN_SHOW you have to enumerate both the scope
	// and result pane items.
	// For MMCN_EXPAND you only need to enumerate the scope items
	// Use IConsoleNameSpace::InsertItem to insert scope pane items
	// Use IResultData::InsertItem to insert result pane item.
	HRESULT hr = E_NOTIMPL;

	
	_ASSERTE(pComponentData != NULL || pComponent != NULL);

	CComPtr<IConsole> spConsole;
	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;
	if (pComponentData != NULL)
		spConsole = ((CSnapin*)pComponentData)->m_spConsole;
	else
	{
		spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
		spHeader = spConsole;
	}

	switch (event)
	{
	case MMCN_SHOW:
		{
			CComQIPtr<IResultData, &IID_IResultData> spResultData(spConsole);
			// TODO : Enumerate the result pane items
			hr = S_OK;
			break;
		}
	case MMCN_EXPAND:
		{
			CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
			// TODO : Enumerate scope pane items
			hr = S_OK;
			break;
		}
	case MMCN_ADD_IMAGES:
		{
			// Add Images
			IImageList* pImageList = (IImageList*) arg;
			hr = E_FAIL;
			// Load bitmaps associated with the scope pane
			// and add them to the image list
			// Loads the default bitmaps generated by the wizard
			// Change as required
			CBitmapHandle hBitmap16 = LoadBitmap(g_hResourceMod, MAKEINTRESOURCE(IDR_MMCICONS_16x16));
			if (hBitmap16 != NULL)
			{
				CBitmapHandle hBitmap32 = LoadBitmap(g_hResourceMod, MAKEINTRESOURCE(IDR_MMCICONS_32x32));
				if (hBitmap32 != NULL)
				{
					hr = pImageList->ImageListSetStrip(
										reinterpret_cast<LONG_PTR*>((HBITMAP)hBitmap16), 
										reinterpret_cast<LONG_PTR*>((HBITMAP)hBitmap32),
										0, 
										RGB(0, 128, 128)
										);
					if (FAILED(hr))
						ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
				}
			}
			break;
		}  
	}
	return hr;
}

LPOLESTR CSnapinData::GetResultPaneColInfo(int nCol)
{
	if (nCol == 0)
		return m_bstrDisplayName;
	// TODO : Return the text for other columns
	return OLESTR("Override GetResultPaneColInfo");
}

/******************************************************************
 *
 *                  CSnapin
 *
 ******************************************************************/
//////////////////////////////////////////////////////////////////////////////
/*++

CSnapin::GetClassID

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapin::GetClassID(CLSID* pClassID)
{
	ATLTRACE(_T("CSnapin::GetClassID\n"));
	_ASSERTE( pClassID != NULL );

	*pClassID = CLSID_MSMQSnapin;
	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapin::IsDirty

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapin::IsDirty()
{
	ATLTRACE(_T("CSnapin::IsDirty\n"));

	// We just return S_OK because we're always dirty.
	return S_OK;
}


//
// Version number of the file data
// To be incremented each time the data of the 
// saved file changes.
//              
static const DWORD x_dwFileVersion = 5;
//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::Load


--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapin::Load(IStream* pStream)
{
	ATLTRACE(_T("CSnapin::Load"));

	
	_ASSERTE( pStream != NULL );
    HRESULT hr;
    DWORD version;
    DWORD res;

    //
    // Load Version
    //
    hr = pStream->Read(&version, sizeof(DWORD), &res);

    //
    // res will be zero if the msc file was saved without mqsnap information
    //
    if(FAILED(hr) || res == 0)
        return(hr);


    ASSERT(res == sizeof(DWORD));

    //
    // Check version number
    //
    if(version != x_dwFileVersion)
        return(S_OK);

    //
    // Placeholder - load any information that the snapin had saved
    //

    return(hr);
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapin::Save


--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapin::Save(IStream* pStream, BOOL  /*clearDirty*/)
{
	ATLTRACE(_T("CComponentData::Save"));


	_ASSERTE( pStream != NULL );
    HRESULT hr;
    DWORD res;

    //
    // Save Version
    //
    hr = pStream->Write(&x_dwFileVersion, sizeof(DWORD), &res);
    ASSERT(res == sizeof(DWORD));

    if(FAILED(hr))
        return(hr);

    //
    // Placeholder - any saved data should be placed here.
    //

    return(hr);


}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapin::GetSizeMax

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapin::GetSizeMax(ULARGE_INTEGER* size)
{
	ATLTRACE(_T("CSnapin::GetSizeMax\n"));
    DWORD dwSize;

    //
    // Add version number size
    //
    dwSize = sizeof(DWORD);


	size->HighPart = 0;
	size->LowPart = dwSize;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapin::Initialize

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSnapin::Initialize(LPUNKNOWN pUnknown)
{
	HRESULT hr = IComponentDataImpl<CSnapin, CSnapinComponent >::Initialize(pUnknown);
	if (FAILED(hr))
		return hr;

	CComPtr<IImageList> spImageList;

	if (m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
	{
		ATLTRACE(_T("IConsole::QueryScopeImageList failed\n"));
		return E_UNEXPECTED;
	}

	// Load bitmaps associated with the scope pane
	// and add them to the image list
	// Loads the default bitmaps generated by the wizard
	// Change as required
	CBitmapHandle hBitmap16 = LoadBitmap(g_hResourceMod, MAKEINTRESOURCE(IDR_MMCICONS_16x16));
	if (hBitmap16 == NULL)
		return S_OK;

	CBitmapHandle hBitmap32 = LoadBitmap(g_hResourceMod, MAKEINTRESOURCE(IDR_MMCICONS_16x16));
	if (hBitmap32 == NULL)
		return S_OK;

	if (spImageList->ImageListSetStrip(
						reinterpret_cast<LONG_PTR*>((HBITMAP)hBitmap16), 
						reinterpret_cast<LONG_PTR*>((HBITMAP)hBitmap32),
						0, 
						RGB(0, 128, 128)
						) != S_OK)
	{
		ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
		return E_UNEXPECTED;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::Notify

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CSnapinComponent::Notify(
	LPDATAOBJECT lpDataObject, 
	MMC_NOTIFY_TYPE event, 
	LPARAM arg, 
	LPARAM param
	)
{
    HRESULT hr = S_OK;


    if(lpDataObject != NULL && MMCN_SHOW != event)
     		return IComponentImpl<CSnapinComponent>::Notify(lpDataObject, event, arg, param);


    //
    // In this routine we handle only 
    // lpDataObject ==NULL, or we have a MMCN_SHOW event.
    //

    
    switch (event)
	{
		case MMCN_SHOW:
		{
		  //
		  // On Show event, we want to keep, or reset
		  // the node currenlty selected
		  //
		  ASSERT(lpDataObject != NULL);

		  //
		  // Retreive the pItem data type
		  //
		  CSnapInItem* pItem;
		  DATA_OBJECT_TYPES type;
		  hr = m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
  
		  if(FAILED(hr))
			  return(hr);

		  if( arg )
		  {
			 // We are being selected.   
			 m_pSelectedNode = pItem;

		  }
		  else
		  {
			 // We are being deselected.

			 // Check to make sure that our result view doesn't think
			 // this node is the currently selected one.
			 if( m_pSelectedNode == pItem)
			 {
				// We don't want to be the selected node anymore.
				m_pSelectedNode = NULL;
			 }

		  }

		  //
		  // Call SnapinItem notification routine
		  //
		  return IComponentImpl<CSnapinComponent>::Notify(lpDataObject, event, arg, param);
		}

		case MMCN_COLUMN_CLICK:
		{
			//
			// A column was clicked. We will sort the result pane accordingly
			//
            return S_OK;
		}
	}



    //
    // lpDataObject == NULL
    //

    // Currently handling only View Change (UpdateAllViews)
	ASSERT(event == MMCN_VIEW_CHANGE);

    if (param == UPDATE_REMOVE_ALL_RESULT_NODES) // delete all result items
	{
		CComQIPtr<IResultData, &IID_IResultData> spResultData(m_spConsole);

		hr = spResultData->DeleteAllRsltItems();
		return hr;
	}
     
	if( ( arg == NULL || (CSnapInItem *) arg == m_pSelectedNode ) && m_pSelectedNode != NULL )
    {

      // We basically tell MMC to simulate reselecting the
      // currently selected node, which causes it to redraw.
      // This will cause MMC to send the MMCN_SHOW notification
      // to the selected node.
      // This function requires an HSCOPEITEM.  This is the ID member
      // of the HSCOPEDATAITEM associated with this node.
      SCOPEDATAITEM *pScopeDataItem;
      m_pSelectedNode->GetScopeData( &pScopeDataItem );
      return m_spConsole->SelectScopeItem( pScopeDataItem->ID );
   }

  return(hr);	

}

//
// IResultDataCompare
//
STDMETHODIMP CSnapinComponent::Compare(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult)
{
    ASSERT(cookieA != 0 && cookieB != 0);

	CSnapInItem* pItemA = (CSnapInItem*) cookieA;
	CSnapInItem* pItemB = (CSnapInItem*) cookieB;

    GUID guidTypeA, guidTypeB;

    HRESULT hr = GetSnapinItemNodeType(pItemA, &guidTypeA);
    if FAILED(hr)
    {
        return hr;
    }

    hr = GetSnapinItemNodeType(pItemB, &guidTypeB);
    if FAILED(hr)
    {
        return hr;
    }

    if (guidTypeA != guidTypeB)
    {
        //
        // Different types. Consider them equal
        //
        *pnResult = 0;
        return S_OK;
    }

    //
    // Handle different types
    //
    if (guidTypeA == *CMessage::m_NODETYPE)
    {
        return ((CMessage*)pItemA)->Compare(lUserParam, (CMessage*)pItemB, pnResult);
    }

	if (guidTypeA == *CTrigResult::m_NODETYPE)
	{
		CTrigResult::Compare(
			reinterpret_cast<CTrigResult*>(pItemA),
			reinterpret_cast<CTrigResult*>(pItemB),
			pnResult
			);
		return S_OK;
	} 

	if (guidTypeA == *CRuleResult::m_NODETYPE)
	{
		CRuleResult::Compare(
			reinterpret_cast<CRuleResult*>(pItemA),
			reinterpret_cast<CRuleResult*>(pItemB),
			pnResult
			);
		return S_OK;
	} 

    return E_NOTIMPL;
};

//////////////////////////////////////////////////////////////////////////////
/*++
ISnapinHelp interface support

CSnapin::GetHelpTopic
This routine returns the path of the msmq.chm help file

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT 
STDMETHODCALLTYPE
CSnapin::GetHelpTopic(
    LPOLESTR* lpCompiledHelpFile
    )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    WCHAR Path[MAX_PATH];

    ASSERT( lpCompiledHelpFile != NULL );

    CString strHelpPath;
    strHelpPath.LoadString(IDS_HELPPATH);

    ExpandEnvironmentStrings(strHelpPath, Path, sizeof(Path)/sizeof(WCHAR));
    *lpCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc((wcslen(Path) + 1) * sizeof(Path[0]));
    wcscpy(*lpCompiledHelpFile, Path );

    return S_OK;
}

//
// GetSnapinItemNodeType - Get the GUID node type of a snapin item
//
HRESULT GetSnapinItemNodeType(CSnapInItem *pNode, GUID *pGuidNode)
{
    //
    // Gets the other Node type 
    //
	CGlobalPointer hGlobal(GPTR, sizeof(GUID));
    if (0 == (HGLOBAL)hGlobal)
    {
        return E_OUTOFMEMORY;
    }

	CComPtr<IStream> spStream;
	HRESULT hr = CreateStreamOnHGlobal(hGlobal, FALSE, &spStream);
	if (FAILED(hr))
    {
        return hr;
    }

    hr = pNode->FillData(CSnapInItem::m_CCF_NODETYPE, spStream);
    if FAILED(hr)
    {
        return hr;
    }

    *pGuidNode = *(GUID *)((HGLOBAL)hGlobal);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\sitegate.h ===
#if !defined(AFX_SITEGATE_H__57A77016_D858_11D1_9C86_006008764D0E__INCLUDED_)
#define AFX_SITEGATE_H__57A77016_D858_11D1_9C86_006008764D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SiteGate.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSiteGate dialog

class CSiteGate : public CMqPropertyPage
{
    DECLARE_DYNCREATE(CSiteGate)

// Construction
public:
	CSiteGate(const CString& strDomainController = CString(L""), const CString& LinkPathName = CString(L""));
    ~CSiteGate();

    HRESULT
    Initialize(
        const GUID* FirstSiteId,
        const GUID* SecondSiteId,
        const CALPWSTR* SiteGateFullPathName
        );


// Dialog Data
	//{{AFX_DATA(CSiteGate)
	enum { IDD = IDD_SITE_LINK_GATES };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSiteGate)
	public:
    virtual BOOL OnApply();
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSiteGate)
	afx_msg void OnSiteGateAdd();
	afx_msg void OnSiteGateRemove();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    typedef CList<LPCWSTR, LPCWSTR&> SiteFrsList;

    
    HRESULT
    InitializeSiteFrs(
        const GUID* pSiteId
        );

    void
    UpdateSiteGateArray(
        void
        );


    CMap<LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR&> m_Name2FullPathName;
    CMap<LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR&> m_FullPathName2Name;
    SiteFrsList m_SiteGateList;

    CListBox* m_pFrsListBox;
    CListBox* m_pSiteGatelistBox;

    CString m_LinkPathName;
    CString m_strDomainController;
    CALPWSTR m_SiteGateFullName;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SITEGATE_H__57A77016_D858_11D1_9C86_006008764D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\snapin.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	snapin.h

Abstract:

	Definition for the SnapinExt snapnin node class.

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __SNAPIN_H_
#define __SNAPIN_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "compext.h"
#include "qext.h"
#include "mgmtext.h"
#include "version.h"

class CSnapinPage : public CSnapInPropertyPageImpl<CSnapinPage>
{
public :
	CSnapinPage(LONG_PTR lNotifyHandle, bool bDeleteHandle = false, TCHAR* pTitle = NULL) : 
		CSnapInPropertyPageImpl<CSnapinPage> (pTitle),
		m_lNotifyHandle(lNotifyHandle),
		m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
	{
	}

	~CSnapinPage()
	{
		if (m_bDeleteHandle)
			MMCFreeNotifyHandle(m_lNotifyHandle);
	}

	enum { IDD = IDD_SNAPIN };

BEGIN_MSG_MAP(CSnapinPage)
	CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CSnapinPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	HRESULT PropertyChangeNotify(LPARAM param)
	{
		return MMCPropertyChangeNotify(m_lNotifyHandle, param);
	}

public:
	LONG_PTR m_lNotifyHandle;
	bool m_bDeleteHandle;
};


class CSnapinData : public CSnapInItemImpl<CSnapinData>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

	CComPtr<IControlbar> m_spControlBar;

	BEGIN_SNAPINCOMMAND_MAP(CSnapinData, FALSE)
	END_SNAPINCOMMAND_MAP()

	SNAPINMENUID(IDR_SNAPIN_MENU)

	BEGIN_SNAPINTOOLBARID_MAP(CSnapinData)
		// Create toolbar resources with button dimensions 16x16 
		// and add an entry to the MAP. You can add multiple toolbars
		// SNAPINTOOLBARID_ENTRY(Toolbar ID)
	END_SNAPINTOOLBARID_MAP()

	CSnapinData()
	{
		// Image indexes may need to be modified depending on the images specific to 
		// the snapin.
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
		m_scopeDataItem.displayname = MMC_CALLBACK;
		m_scopeDataItem.nImage = 0;			// May need modification
		m_scopeDataItem.nOpenImage = 0;		// May need modification
		m_scopeDataItem.lParam = (LPARAM) this;
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
		m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
		m_resultDataItem.str = MMC_CALLBACK;
		m_resultDataItem.nImage = 0;		// May need modification
		m_resultDataItem.lParam = (LPARAM) this;
	}

	~CSnapinData()
	{
	}

   STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem);

    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem);

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type);

	LPOLESTR GetResultPaneColInfo(int nCol);
};


class CSnapin;

class CSnapinComponent : public CComObjectRootEx<CComSingleThreadModel>,
	public CSnapInObjectRoot<2, CSnapin >,
  	public IExtendPropertySheetImpl<CSnapinComponent>,
    public IExtendContextMenuImpl<CSnapinComponent>,
	public IExtendControlbarImpl<CSnapinComponent>,
	public IComponentImpl<CSnapinComponent>,
    public IResultDataCompare
{
public:
BEGIN_COM_MAP(CSnapinComponent)
	COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IResultDataCompare)
END_COM_MAP()

	// A pointer to the currently selected node used for refreshing views.
	// When we need to update the view, we tell MMC to reselect this node.
	CSnapInItem * m_pSelectedNode;

public:
	CSnapinComponent()
	{
        m_pSelectedNode = NULL;
	}

	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

    //
    // IResultDataCompare
    //
    STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);
};


class CSnapin : public CComObjectRootEx<CComSingleThreadModel>,
	public CSnapInObjectRoot<1, CSnapin>,
	public IComponentDataImpl<CSnapin, CSnapinComponent>,
   	public IExtendPropertySheetImpl<CSnapin>,
    public IExtendContextMenuImpl<CSnapin>,
	public IExtendControlbarImpl<CSnapin>,
	public IPersistStream,
    public ISnapinHelp,
    public CComCoClass<CSnapin, &CLSID_MSMQSnapin>
{
public:
	CSnapin()
	{
		m_pNode = new CSnapinData;
		_ASSERTE(m_pNode != NULL);
		m_pComponentData = this;

        m_CQueueExtData.m_pComponentData = this;
        m_CComputerExtData.m_pComponentData = this;
		m_CComputerMgmtExtData.m_pComponentData = this;
	}
	~CSnapin()
	{
		delete m_pNode;
		m_pNode = NULL;
	}

EXTENSION_SNAPIN_DATACLASS(CQueueExtData)
EXTENSION_SNAPIN_DATACLASS(CComputerExtData)
EXTENSION_SNAPIN_DATACLASS(CComputerMgmtExtData)


BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CSnapin)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CQueueExtData)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CComputerExtData)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CComputerMgmtExtData)
END_EXTENSION_SNAPIN_NODEINFO_MAP()

BEGIN_COM_MAP(CSnapin)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

//
// The standard macro "DECLARE_REGISTRY_RESOURCEID(IDR_SNAPIN);" was replaced with this 
// code to allow localization of the snapin name - bug #4187
// This solution was suggested by Jeff Miller (YoelA, 30-Jun-99)
//
static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	//
	// name of the snapin is stored in the string resource IDS_PROJNAME
	//
	CString strPorjectName;
	strPorjectName.LoadString(IDS_PROJNAME);

	_ATL_REGMAP_ENTRY re[] = 
	{
		L"SNAPINNAME", (LPCTSTR)strPorjectName,
		NULL, NULL
	};
	
	//
	// I don't just do "return _Module.UpdateRegistryFromResource" as
	// strPorjectName would get destroyed before the method finishes
	//
	HRESULT hr = _Module.UpdateRegistryFromResource(IDR_SNAPIN, 
		bRegister, re);

	return hr;
}

DECLARE_NOT_AGGREGATABLE(CSnapin)


    //
    // IPersist Interface
    // 
   	STDMETHOD(GetClassID)(CLSID* pClassID);

    //
    // IPersistStream Interface
    //
	STDMETHOD(IsDirty)();
	STDMETHOD(Load)(IStream* stream);
	STDMETHOD(Save)(IStream* stream, BOOL /* clearDirty */);
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER* size);


    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

	static void WINAPI ObjectMain(bool bStarting)
	{
		if (bStarting)
			CSnapInItem::Init();
	}

    //
    // ISnapinHelp Interface
    //
    STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);
};

class ATL_NO_VTABLE CSnapinAbout : public ISnapinAbout,
	public CComObjectRoot,
	public CComCoClass< CSnapinAbout, &CLSID_MSMQSnapinAbout>
{
public:
	DECLARE_REGISTRY(CSnapinAbout, _T("MSMQSnapinAbout.1"), _T("MSMQSnapinAbout.1"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CSnapinAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

private:
HRESULT
AboutHelper(
	UINT		nID, 
	LPOLESTR*	lpPtr)
{
	CString		szString;

    if (lpPtr == NULL)
	{
        return E_POINTER;
	}

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	szString.LoadString(nID);

    return AboutHelper(szString, lpPtr);
}

HRESULT
AboutHelper(
	CString &szString, 
	LPOLESTR*	lpPtr)
{
	UINT len = szString.GetLength() + 1;
    *lpPtr = reinterpret_cast<LPOLESTR>( CoTaskMemAlloc(len * sizeof(WCHAR)) );          		

    if (*lpPtr == NULL)
	{
        return E_OUTOFMEMORY;
	}

    lstrcpy(*lpPtr, szString);
    return S_OK;
}

public:
	STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
    {
        return AboutHelper(IDS_PRODUCT_DESCRIPTION, lpDescription);
    }

    STDMETHOD(GetProvider)(LPOLESTR *lpName)
    {
        return AboutHelper(IDS_COMPANY, lpName);
    }

    STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        CString strVersion;

        strVersion.FormatMessage(IDS_VERSION_FORMAT, rmj, rmm, rup);
        return AboutHelper(strVersion, lpVersion);
    }

    STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
    {
        if (hAppIcon == NULL)
            return E_POINTER;

        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        *hAppIcon = LoadIcon(g_hResourceMod, MAKEINTRESOURCE(IDI_COMPUTER_MSMQ));

        ASSERT(*hAppIcon != NULL);
        return (*hAppIcon != NULL) ? S_OK : E_FAIL;
    }

    STDMETHOD(GetStaticFolderImage)(
    	HBITMAP * /*hSmallImage*/,
        HBITMAP *hSmallImageOpen,
        HBITMAP *hLargeImage,
        COLORREF * /*cMask*/
        )
	{
		*hSmallImageOpen = *hLargeImage = *hLargeImage = 0;
		return S_OK;
	}
};

//
// GetSnapinItemNodeType - Get the GUID node type of a snapin item
//
HRESULT GetSnapinItemNodeType(CSnapInItem *pNode, GUID *pGuidNode);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\sitegate.cpp ===
// SiteGate.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "globals.h"
#include "mqPPage.h"
#include "SiteGate.h"
#include "dsext.h"

#include "sitegate.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSiteGate property page

IMPLEMENT_DYNCREATE(CSiteGate, CMqPropertyPage)


CSiteGate::CSiteGate(
    const CString& strDomainController /* CString(L"") */,
    const CString& LinkPathName  /* CString(L"") */
    ) :
    CMqPropertyPage(CSiteGate::IDD),
	m_strDomainController(strDomainController),
    m_LinkPathName(LinkPathName)
{
    //{{AFX_DATA_INIT(CSiteGate)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    //
    // Set Pointer to List Box to NULL
    //
    m_pFrsListBox = NULL;
    m_pSiteGatelistBox = NULL;

    m_SiteGateFullName.cElems = 0;
    m_SiteGateFullName.pElems = NULL;

}


CSiteGate::~CSiteGate()
{
    //
    // Don't use DestructElement. Since CSiteGate contains few maps and Clist
    // that pointe to the same object. Using of DestructElement cause destruction
    // of same object twice.
    //
    POSITION pos = m_Name2FullPathName.GetStartPosition();
    while(pos != NULL)
    {
        LPCWSTR FrsName;
        LPCWSTR FrsFullPathName;

        m_Name2FullPathName.GetNextAssoc(pos, FrsName, FrsFullPathName);
        MQFreeMemory(const_cast<LPWSTR>(FrsName));
        MQFreeMemory(const_cast<LPWSTR>(FrsFullPathName));
    }

    delete [] m_SiteGateFullName.pElems;
}


BEGIN_MESSAGE_MAP(CSiteGate, CMqPropertyPage)
    //{{AFX_MSG_MAP(CSiteGate)
    ON_BN_CLICKED(IDB_SITE_GATE_ADD, OnSiteGateAdd)
    ON_BN_CLICKED(IDB_SITE_GATE_REMOVE, OnSiteGateRemove)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSiteGate message handlers

void CSiteGate::OnSiteGateAdd() 
{
    MoveSelected(m_pFrsListBox, m_pSiteGatelistBox);
    OnChangeRWField();
}

void CSiteGate::OnSiteGateRemove() 
{
    MoveSelected(m_pSiteGatelistBox, m_pFrsListBox);
    OnChangeRWField();
}

BOOL CSiteGate::OnInitDialog() 
{
    //
    // This closure is used to keep the DLL state. For UpdateData we need
    // the mmc.exe state.
    //
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
        //
        // Initialize pointer to ListBox
        //
        m_pFrsListBox = (CListBox *)GetDlgItem(IDC_SITE_FRS_LIST);
        m_pSiteGatelistBox = (CListBox *)GetDlgItem(IDC_SITE_GATES_LIST);

        POSITION pos = m_Name2FullPathName.GetStartPosition();
        while(pos != NULL)
        {
            LPCWSTR FrsName;
            LPCWSTR FrsFullPathName;

            m_Name2FullPathName.GetNextAssoc(pos, FrsName, FrsFullPathName);
            VERIFY(m_pFrsListBox->AddString(FrsName) != CB_ERR);
        }

        pos = m_SiteGateList.GetHeadPosition();
        while (pos != NULL)
        {
            LPCWSTR SitegateName;
            SitegateName = m_SiteGateList.GetNext(pos);

            //
            // remove the site gate from the FRS list Box
            //
            int Index = m_pFrsListBox->FindString(-1, SitegateName);
            VERIFY(Index != LB_ERR);
            VERIFY(m_pFrsListBox->DeleteString(Index) != CB_ERR);

            //
            // Add the site gate to Site gate list box
            //
            VERIFY(m_pSiteGatelistBox->AddString(SitegateName) != CB_ERR);
        }

    }
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CSiteGate::OnApply() 
{
    //
    // Call DoDataExchange
    //
    if (!m_fModified || !UpdateData(TRUE))
    {
        return TRUE;
    }

    UpdateSiteGateArray();

    PROPID paPropid[] = { PROPID_L_GATES_DN };
    const DWORD x_iPropCount = sizeof(paPropid) / sizeof(paPropid[0]);
    PROPVARIANT apVar[x_iPropCount];
    
    DWORD iProperty = 0;

    //
    // PROPID_L_GATES_DN
    //
    ASSERT(paPropid[iProperty] == PROPID_L_GATES_DN);
    apVar[iProperty].vt = VT_LPWSTR | VT_VECTOR;
    apVar[iProperty++].calpwstr = m_SiteGateFullName;
    
    //
    // set the new value
    //    
    HRESULT hr = ADSetObjectProperties(
                eROUTINGLINK,
                GetDomainController(m_strDomainController),
				true,	// fServerName
                m_LinkPathName,
                x_iPropCount, 
                paPropid, 
                apVar
                );

    if (MQ_OK != hr)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
        CString strSiteLink;
        strSiteLink.LoadString(IDS_SITE_LINK);

        MessageDSError(hr, IDS_OP_SET_PROPERTIES_OF, strSiteLink);
        return FALSE;
    }
    
    return CMqPropertyPage::OnApply();

}


HRESULT
CSiteGate::Initialize(
    const GUID* FirstSiteId,
    const GUID* SecondSiteId,
    const CALPWSTR* SiteGateFullPathName
    )
{ 
    HRESULT hr;

    hr = InitializeSiteFrs(FirstSiteId);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = InitializeSiteFrs(SecondSiteId);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Get Site Link
    //
    for (DWORD i = 0; i < SiteGateFullPathName->cElems; ++i)
    {
        LPCWSTR SiteGateName;
        BOOL f = m_FullPathName2Name.Lookup(SiteGateFullPathName->pElems[i], SiteGateName);

        //
        // If we did not find the site gate, it means that it no longer exists as a server
        // (for example, MSMQ was uninstalled) so we do not add it.
        //
        if (f)
        {
            m_SiteGateList.AddTail(SiteGateName);
        }
    }

    return hr;
}

HRESULT
CSiteGate::InitializeSiteFrs(
    const GUID* pSiteId
    )
/*++

Routine Description:
    The routine retrieves from the DS the FRS machines that belong to the site    

Arguments:
     pSiteId - Pointer to site id.
     FrsList - a return list of FRS machine that belong to the site

Returned value:
    Operation result

--*/
{    
    //
    // Get the FRS machine name
    //
    //
    PROPID aPropId[] = {PROPID_QM_PATHNAME, PROPID_QM_FULL_PATH};
    const DWORD x_nProps = sizeof(aPropId) / sizeof(aPropId[0]);
    CColumns AttributeColumns;

    for (DWORD i=0; i<x_nProps; i++)
    {
        AttributeColumns.Add(aPropId[i]);
    }

    //
    // This search request will be recognized and specially simulated by DS
    //    
    HRESULT hr;
    HANDLE hEnume;
    {
        CWaitCursor wc; //display wait cursor while query DS
        hr = ADQuerySiteServers(
                    GetDomainController(m_strDomainController),
					true,		// fServerName
                    pSiteId,
                    eRouter,
                    AttributeColumns.CastToStruct(),
                    &hEnume
                    );
    }

    DSLookup dslookup (hEnume, hr);

    if (!dslookup.HasValidHandle())
    {
        return MQ_ERROR;
    }

    //
    // Get the properties
    //
    PROPVARIANT result[x_nProps*3];
    DWORD dwPropCount = sizeof(result) / sizeof(result[0]);;

    HRESULT rc = dslookup.Next(&dwPropCount, result);

    while (SUCCEEDED(rc) && (dwPropCount != 0))
    {
        for (DWORD i =0; i < dwPropCount; i += AttributeColumns.Count())
        {
            LPWSTR FrsName = result[i].pwszVal;
            LPWSTR FrsFullPathName = result[i+1].pwszVal;

            //
            // Can't add the same FRS twice
            //
            #ifdef _DEBUG
                LPCWSTR temp;
                ASSERT(!m_Name2FullPathName.Lookup(FrsName, temp));
            #endif

            m_Name2FullPathName[FrsName] = FrsFullPathName;
            m_FullPathName2Name[FrsFullPathName] = FrsName;
        }
        rc = dslookup.Next(&dwPropCount, result);
    }

    return rc;
}


void
CSiteGate::UpdateSiteGateArray(
    void
    )
/*++
Routine Description:
    The routine Initiaize an array of site gates full path name. The routine
    is called OnOk and initialize the array before calling the DS API.

Arguments: 
    None

Returned Value:
    None
--*/
{
    //
    // Get the number of site gates
    //
    DWORD NumOfSiteGates = m_pSiteGatelistBox->GetCount();
    VERIFY(NumOfSiteGates != LB_ERR);

    //
    // Craete a new site gates array
    //
    delete [] m_SiteGateFullName.pElems;
    m_SiteGateFullName.cElems = 0;
    m_SiteGateFullName.pElems = NULL;
    
    if (m_fModified && (NumOfSiteGates > 0))
    {
        m_SiteGateFullName.cElems = NumOfSiteGates;
        m_SiteGateFullName.pElems = new LPWSTR[NumOfSiteGates];

        for (DWORD i=0; i < NumOfSiteGates; ++i)
        {
            CString FrsName;

            m_pSiteGatelistBox->GetText(i, FrsName);
            BOOL f = m_Name2FullPathName.Lookup(FrsName, m_SiteGateFullName.pElems[i]);

            //
            // The full path should be exist. It was retrieved with the FRS.
            // 
            ASSERT(f);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\snpnscp.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    NodeWithScopeChildrenList.h

Abstract:

	This is the header file for CNodeWithScopeChildrenList, a class which 
	implements a node that has a list of scope pane children.

	This is an inline template class.
	Include NodeWithScopeChildrenList.cpp in the .cpp files
	of the classes in which you use this template.

Author:

    Original: Michael A. Maguire 
    Modifications: RaphiR

Changes:
    Support for Extension snapins 
    Enables multiple class of childs

--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NODE_WITH_SCOPE_CHILDREN_LIST_H_)
#define _NODE_WITH_SCOPE_CHILDREN_LIST_H_


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "snpnode.h"
//
//
// where we can find what this class has or uses:
//
#include <atlapp.h>			// for CSimpleArray
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



template <class T,BOOL bIsExtension>
class CNodeWithScopeChildrenList : public CSnapinNode< T, bIsExtension >
{

public:

	
	
	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::AddChild

	Adds a child to the list of children.

	This has to be public as it must be accessible even from a separate dialog
	(e.g. a Connect to Server dialog) that may want to add a child.

	Here we add the child item to the list of children and call InsertItem
	to add the child to the scope pane.

	This is one difference between adding nodes into the scope
	pane and the result pane.  When we were inserting a child into
	the result pane, we didn't call InsertItem in the AddChild methods(s)
	because we needed to worry about sending an UpdataAllViews
	notification and repopulating the result pane in each view.
	
	Because MMC takes care of replicating scope pane changes to all views, 
	we don't need to worry about this.  Instead, we just do InsertItem once here.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT AddChild(CSnapInItem * pChildNode, SCOPEDATAITEM* pScopeDataItem);



	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::RemoveChild

	Removes a child from the list of children.

	This has to be public so that child nodes can ask their parent to be deleted
	from the list of children when they receive the MMCN_DELETE notification.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	// virtual HRESULT RemoveChild(CSnapInItem * pChildNode );



	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::OnShow

	Don't override this in your derived class.  Instead, override methods
	which it calls: InsertColumns 

	This method is an override of CSnapinNode::OnShow.  When MMC passes the
	MMCN_SHOW method for this node.
	
	For more information, see CSnapinNode::OnShow.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT OnShow(	
					  LPARAM arg
					, LPARAM param
					, IComponentData * pComponentData
					, IComponent * pComponent
					, DATA_OBJECT_TYPES type 
					);

	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::OnRefresh

    You shouldn't need to override this in your derived method.  Simply
    enable the MMC_VERB_REFRESH for your node.

    In our implementation, this method gets called when the MMCN_REFRESH
    Notify message is sent for this node.  

    For more information, see CSnapinNode::OnRefresh.


	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT OnRefresh(	
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);

	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildren::OnExpand

	Don't override this in your derived class.  Instead, override methods 
	which it calls: PopulateScopeChildrenList

	This method is an override of CSnapinNode::OnExpand.  When MMC passes the
	MMCN_EXPAND method for this node, we are to add children into the 
	scope pane.  In this class we add them from a list we maintain.
	
	For more information, see CSnapinNode::OnExpand.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT OnExpand(	
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	



protected:

    // The ScopeChild structure contains all the information needed to modify or remove a node
    // in the scope pane: A pointer to CSnapinItem (needs to be freed) and a scope item id
    // that can be used to modify or remove the node itself
    struct ScopeChild
    {
        CSnapInItem *pChildNode;
        HSCOPEITEM  ID;
    };

	// Array of scope items representing children nodes
	CSimpleArray<ScopeChild> m_ScopeChildrenList;

	// Flag indicating whether list has been initially populated
	BOOL m_bScopeChildrenListPopulated;


	/////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::CNodeWithScopeChildrenList

	Constructor

	This is an base class which we don't want instantiated on its own,
	so the contructor is protected

	--*/
	//////////////////////////////////////////////////////////////////////////////
	CNodeWithScopeChildrenList(CSnapInItem * pParentNode, CSnapin * pComponentData);



	/////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::~CNodeWithScopeChildrenList

	Destructor

	--*/
	//////////////////////////////////////////////////////////////////////////////
	~CNodeWithScopeChildrenList();



	/////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::PopulateScopeChildrenList

	Override this in your derived class to populate the list of children nodes.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT PopulateScopeChildrenList();

	// override in your derived class and do something like:

/*
	virtual HRESULT PopulateScopeChildrenList( void )
	{
		CSomeChildNode *myChild1 = new CSomeChildNode();
		AddChild(myChild1);
	
		CSomeChildNode *myChild2 = new CSomeChildNode();
		AddChild(myChild2);
	
		CSomeChildNode *myChild3 = new CSomeChildNode();
		AddChild(myChild3);

		return S_OK;
	}
*/

	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::InsertColumns

	Override this in your derived class.

	This method is called by OnShow when it needs you to set the appropriate 
	column headers to be displayed in the result pane for this node.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );


	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::OnUnSelect

    Override this in your derived class.

    This method is called by OnShow when the node is unselected.
    Useful to overidde this if to retreive columns header width for example

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT OnUnSelect( IHeaderCtrl* pHeaderCtrl );


	/////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::EnumerateScopeChildren

	Don't override this in your derived class. Instead, override the method 
	it calls, PopulateScopeChildrenList.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT EnumerateScopeChildren( IConsoleNameSpace* pConsoleNameSpace );
};




//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::AddChild

Adds a child to the list of children.

This has to be public as it must be accessible even from a separate dialog
(e.g. a Connect to Server dialog) that may want to add a child.

Here we add the child item to the list of children and call InsertItem
to add the child to the scope pane.

This is one difference between adding nodes into the scope
pane and the result pane.  When we were inserting a child into
the result pane, we didn't call InsertItem in the AddChild methods(s)
because we needed to worry about sending an UpdataAllViews
notification and repopulating the result pane in each view.

Because MMC takes care of replicating scope pane changes to all views, 
we don't need to worry about this.  Instead, we just do InsertItem once here.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::AddChild(
                                             CSnapInItem*       pChildNode,
                                             SCOPEDATAITEM*     pScopeDataItem)
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::AddChild\n"));
	

	// Check for preconditions:
	// None.


	HRESULT hr = S_OK;

    //
    // Get the Console
    //
    CComQIPtr<IConsoleNameSpace2, &IID_IConsoleNameSpace2> spConsoleNameSpace(m_pComponentData->m_spConsole); 


	// We hand our HSCOPEITEM as the parent ID for this child.
    pScopeDataItem->relativeID = (HSCOPEITEM) m_scopeDataItem.ID;


	hr = spConsoleNameSpace->Expand(m_scopeDataItem.ID);
	if ( hr == S_OK )
	{
		//
		// Do not insert new item if the node was not expanded yet.
		// OnExpand() calls populate function, and the new object will 
		// be showed twice. In order to avoid it, we return here.
		delete pChildNode;
		return hr;
	}

	hr = spConsoleNameSpace->InsertItem(pScopeDataItem);
	if (FAILED(hr))
	{
		delete pChildNode;
		return hr;
	}

	// Check: On return, the ID member of 'm_scopeDataItem' 
	// contains the handle to the newly inserted item.
	_ASSERT( NULL != pScopeDataItem->ID);

    // scopeChild item is created added to the list to allow deletion 
    // or modification of the object
    ScopeChild scopeChild = {pChildNode, pScopeDataItem->ID};
    if( 0 == m_ScopeChildrenList.Add( scopeChild ) )
    {
		// Failed to add => out of memory
        spConsoleNameSpace->DeleteItem(pScopeDataItem->ID, TRUE);
        hr = E_OUTOFMEMORY;
    }

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::RemoveChild

Removes a child from the list of children.

This has to be public so that child nodes can ask their parent to be deleted
from the list of children when they receive the MMCN_DELETE notification.

--*/
//////////////////////////////////////////////////////////////////////////////
/*
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T, bIsExtension>::RemoveChild(CSnapInItem * pChildNode )
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::RemoveChild\n"));
	

	// Check for preconditions:
	// None.


	HRESULT hr = S_OK;


	if( m_ScopeChildrenList.Remove(pChildNode ) )
	{
        //
        // Need IConsoleNameSpace
        //
        CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_pComponentData->m_spConsole); 
		
        //
        // Need to see if this works because of multi node scope
        //

        //hr = spConsoleNameSpace->DeleteItem(pChildNode->m_scopeDataItem.ID, TRUE ); 


		if (FAILED(hr))
		{
			return hr;
		}

	}
	else
	{
		// If we failed to remove, probably the child was never in the list
		// ISSUE: determine what do here -- this should never happen
		_ASSERTE( FALSE );

		hr = S_FALSE;
	}

	return hr;
}
*/


/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::CNodeWithScopeChildrenList

Constructor

This is an base class which we don't want instantiated on its own,
so the contructor is protected

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
CNodeWithScopeChildrenList<T,bIsExtension>::CNodeWithScopeChildrenList(CSnapInItem * pParentNode, CSnapin * pComponentData): 
                CSnapinNode< T, bIsExtension >(pParentNode, pComponentData)
{
	ATLTRACE(_T("# +++ CNodeWithScopeChildrenList::CNodeWithScopeChildrenList\n"));
	

	// Check for preconditions:
	// None.


	// We have not yet loaded the child nodes' data
	m_bScopeChildrenListPopulated = FALSE;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::~CNodeWithScopeChildrenList

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
CNodeWithScopeChildrenList<T, bIsExtension>::~CNodeWithScopeChildrenList()
{
	ATLTRACE(_T("# --- CNodeWithScopeChildrenList::~CNodeWithScopeChildrenList\n"));
	

	// Check for preconditions:
	// None.



	// Delete each node in the list of children
	for (int i = 0; i < m_ScopeChildrenList.GetSize(); i++)
	{
        delete m_ScopeChildrenList[i].pChildNode;
        m_ScopeChildrenList[i].pChildNode = 0;
	}

	// Empty the list
	m_ScopeChildrenList.RemoveAll();

}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::PopulateScopeChildrenList

Override this in your derived class to populate the list of children nodes.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T, bIsExtension>::PopulateScopeChildrenList()
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::PopulateScopeChildren -- override in your derived class\n"));
		

	// Check for preconditions:
	// None.


	// override in your derived class and do something like:
/*
	CSomeChildNode *myChild1 = new CSomeChildNode();
	m_CChildrenList.Add(myChild1);

	CSomeChildNode *myChild2 = new CSomeChildNode();
	m_CChildrenList.Add(myChild2);

	CSomeChildNode *myChild3 = new CSomeChildNode();
	m_CChildrenList.Add(myChild3);
*/
	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::OnShow

Don't override this in your derived class.  Instead, override methods
which it calls: InsertColumns 

This method is an override of CSnapinNode::OnShow.  When MMC passes the
MMCN_SHOW method for this node.

For more information, see CSnapinNode::OnShow.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CNodeWithScopeChildrenList<T, bIsExtension>::OnShow(	
	LPARAM arg,
	LPARAM /*param*/,
	IComponentData * pComponentData,
	IComponent * pComponent,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CNodeScopeChildrenList::OnShow\n"));
	

	// Check for preconditions:
	_ASSERTE( pComponentData != NULL || pComponent != NULL );


	HRESULT hr = S_FALSE;



	// Need IHeaderCtrl.

	// But to get that, first we need IConsole
	CComPtr<IConsole> spConsole;
	if( pComponentData != NULL )
	{
		 spConsole = ((CSnapin*)pComponentData)->m_spConsole;
	}
	else
	{
		// We should have a non-null pComponent
		 spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
	}
	_ASSERTE( spConsole != NULL );

	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeaderCtrl(spConsole);
	_ASSERT( spHeaderCtrl != NULL );

	if( arg ) 
	{
		// 
		// In some cases MMC calls us twice with same IHeaderCtrl. try to delete 
		// previous colums
		//					Uri Habusha, 28-Jan-2001
		//
		while(SUCCEEDED(spHeaderCtrl->DeleteColumn(0)))
		{
			NULL;
		}

		// arg <> 0 => we are being selected.
		hr = InsertColumns( spHeaderCtrl );
		_ASSERT( S_OK == hr );

	}
    else
    {
        //
        // We are unselected
        //
        hr = OnUnSelect(spHeaderCtrl);
    }

	return hr;


}

/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::OnRefresh


You shouldn't need to override this in your derived method.  Simply
enable the MMC_VERB_REFRESH for your node.

In our implementation, this method gets called when the MMCN_REFRESH
Notify message is sent for this node.  

For more information, see CSnapinNode::OnRefresh.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CNodeWithScopeChildrenList<T, bIsExtension>::OnRefresh(	
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::OnRefresh\n"));

	HRESULT hr;

    //
    // Need IConsoleNameSpace
    //
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_pComponentData->m_spConsole); 


    // Get rid of what we had.
    // Calling DeleteItem with FALSE deletes all the child objects of the current 
    // node but does not delete the current node itself.
    hr = spConsoleNameSpace->DeleteItem(m_scopeDataItem.ID, FALSE ); 
	if (FAILED(hr))
	{
		return hr;
	}

	// Free the memory allocated for each child
	for (int i = 0; i < m_ScopeChildrenList.GetSize(); i++)
	{
        delete m_ScopeChildrenList[i].pChildNode;
        m_ScopeChildrenList[i].pChildNode = 0;
	}

	// Empty the list
	m_ScopeChildrenList.RemoveAll();


	// Repopulate the children list: Unst the flag, fill the list with data,
    // reset the flag
	m_bScopeChildrenListPopulated = FALSE;
	hr = PopulateScopeChildrenList();
	if( FAILED(hr) )
	{
		return( hr );
	}
	m_bScopeChildrenListPopulated = TRUE;
	
	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::InsertColumns

Override this in your derived class.

This method is called by OnShow when it needs you to set the appropriate 
column headers to be displayed in the result pane for this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::InsertColumns -- override in your derived class\n"));
	

	// Check for preconditions:
	_ASSERTE( pHeaderCtrl != NULL );


	HRESULT hr;

	// override in your derived class and do something like:
	hr = pHeaderCtrl->InsertColumn( 0, L"@Column 1 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 120 );
	_ASSERT( S_OK == hr );

	hr = pHeaderCtrl->InsertColumn( 1, L"@Column 2 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 300 );
	_ASSERT( S_OK == hr );

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::OnUnSelect

Override this in your derived class.

This method is called by OnShow when the node is unselected.
Useful to overidde this if to retreive columns header width for example


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::OnUnSelect( IHeaderCtrl* pHeaderCtrl )
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::OnUnSelect -- override in your derived class\n"));
	
	//
	// Check for preconditions:
	//
	ASSERT( pHeaderCtrl != NULL );

	//
	// Delete result pane columns
	//
	while(SUCCEEDED(pHeaderCtrl->DeleteColumn(0)))
	{
		NULL;
	}

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildren::OnExpand

Don't override this in your derived class.  Instead, override methods 
which it calls: PopulateScopeChildrenList

This method is an override of CSnapinNode::OnExpand.  When MMC passes the
MMCN_EXPAND method for this node, we are to add children into the 
scope pane.  In this class we add them from a list we maintain.

For more information, see CSnapinNode::OnExpand.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CNodeWithScopeChildrenList<T,bIsExtension>::OnExpand(	
	LPARAM arg,
	LPARAM param,
	IComponentData * pComponentData,
	IComponent * pComponent,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CNodeWithScopeChildren::OnExpand\n"));
	

	// Check for preconditions:
	_ASSERTE( pComponentData != NULL || pComponent != NULL );



	HRESULT hr = S_FALSE;

	if( TRUE == arg )
	{

		// Need IConsoleNameSpace

		// But to get that, first we need IConsole
		CComPtr<IConsole> spConsole;
		if( pComponentData != NULL )
		{
			 spConsole = ((CSnapin*)pComponentData)->m_spConsole;
		}
		else
		{
			// We should have a non-null pComponent
			 spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
		}
		_ASSERTE( spConsole != NULL );


		CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
		_ASSERT( spConsoleNameSpace != NULL );

        if(bIsExtension)
        {
            //
            // For extensions, keep the scope
            //
            m_scopeDataItem.ID = (HSCOPEITEM) param;
        }

		hr = EnumerateScopeChildren( spConsoleNameSpace );

	}
	else	// arg != TRUE so not expanding
	{

		// do nothing for now -- I don't think arg = FALSE is even implemented 
		// for MMC v. 1.0 or 1.1

	}

	return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::EnumerateScopeChildren

Don't override this in your derived class. Instead, override the method 
it calls, PopulateScopeChildrenList.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CNodeWithScopeChildrenList<T,bIsExtension>::EnumerateScopeChildren( IConsoleNameSpace* /*pConsoleNameSpace*/)
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::EnumerateScopeChildren\n"));
	

	// Check for preconditions:
	// None.


	HRESULT hr;

	if ( FALSE == m_bScopeChildrenListPopulated )
	{
		// We have not yet loaded all of our children into our list.
		hr = PopulateScopeChildrenList();
		if( FAILED(hr) )
		{
			return( hr );
		}

		// We've already loaded our children objects with
		// data necessary to populate the result pane.
		m_bScopeChildrenListPopulated = TRUE;	// We only want to do this once.
	}


	// We don't need any code here to InsertItem the children into the
	// scope pane as we did in the EnumerateScopeChildren method
	// for CNodeWithResultChildrenList.
	// This is one difference between adding nodes into the scope
	// pane and the result pane.  Because MMC takes care of replicating
	// scope pane changes to all views, we don't need to worry about
	// sending an UpdateAllViews notification and handling insertion
	// there for each result pane.  Instead, we just do InsertItem once.
	// So for CNodeWithScopePaneChildren, we call InsertItem
	// in the AddChild method which is called by PopulateScopeChildrenList
	// above.

	return S_OK;
}



#endif // _NODE_WITH_SCOPE_CHILDREN_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\snpnres.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    snpres.h

Abstract:

	This is the header file for CNodeWithResultChildrenList, a class which 
	implements a node that has a list of scope pane children.

	This is an inline template class.
	Include NodeWithScopeChildrenList.cpp in the .cpp files
	of the classes in which you use this template.

Author:

    Original: Michael A. Maguire 
    Modifications: RaphiR

Changes:
    Support for Extension snapins 


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NODE_WITH_RESULT_CHILDREN_LIST_H_)
#define _NODE_WITH_RESULT_CHILDREN_LIST_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "snpnode.h"
//
//
// where we can find what this class has or uses:
//
#include <atlapp.h>			// for CSimpleArray
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


template < class T, class CChildNode, class TArray, BOOL bIsExtension>
class CNodeWithResultChildrenList : public CSnapinNode< T, bIsExtension>
{

	// Constructor/Destructor

public:
	CNodeWithResultChildrenList(CSnapInItem * pParentNode, CSnapin * pComponentData);
	~CNodeWithResultChildrenList();


	// Child list management.

public:
	// Flag indicating whether list has been initially populated
	BOOL m_bResultChildrenListPopulated;

protected:
	// Override these in your derived classes
	virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );
   	virtual HRESULT OnUnSelect( IHeaderCtrl* pHeaderCtrl );
	virtual HRESULT PopulateResultChildrenList(void );

	// Stuff which must be accessible to subclasses.  These methods shouldn't need to be overidden.
	virtual HRESULT RepopulateResultChildrenList(void);
	
	virtual HRESULT AddChildToList( CChildNode * pChildNode );

	virtual HRESULT EnumerateResultChildren( IResultData * pResultData );

	// Array of pointers to children nodes.
	// This is protected so that it can be visible in the derived classes.
 	TArray m_ResultChildrenList;


	// Overrides for standard MMC functionality.	
public:
    //////////////////////////////////////////////////////////////////////////////
    /*++

    CNodeWithScopeChildrenList::RemoveChild

    Removes a child from the list of children.

    This has to be public so that child nodes can ask their parent to be deleted
    from the list of children when they receive the MMCN_DELETE notification.

    --*/
    //////////////////////////////////////////////////////////////////////////////
    virtual HRESULT RemoveChild( CChildNode * pChildNode );

	virtual HRESULT OnShow(	
					  LPARAM arg
					, LPARAM param
					, IComponentData * pComponentData
					, IComponent * pComponent
					, DATA_OBJECT_TYPES type 
					);
	virtual HRESULT OnRefresh(	
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);


};


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::InsertColumns

Override this in your derived class.

This method is called by OnShow when it needs you to set the appropriate 
column headers to be displayed in the result pane for this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
	ATLTRACE(_T("# CNodeWithResultChildrenList::InsertColumns -- override in your derived class\n"));
	

	// Check for preconditions:
	_ASSERTE( pHeaderCtrl );


	HRESULT hr;

	// override in your derived class and do something like:
	hr = pHeaderCtrl->InsertColumn( 0, L"@Column 1 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 120 );
	_ASSERT( S_OK == hr );

	hr = pHeaderCtrl->InsertColumn( 1, L"@Column 2 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 300 );
	_ASSERT( S_OK == hr );

	return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::OnUnSelect

Override this in your derived class.

This method is called by OnShow when the node is unselected.
Useful to overidde this if you want to retreive columns header width for example


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::OnUnSelect( IHeaderCtrl* pHeaderCtrl )
{
	ATLTRACE(_T("# CNodeWithResultChildrenList::OnUnSelect -- override in your derived class\n"));
	

	//
	// Check for preconditions:
	//
	ASSERT( pHeaderCtrl != NULL );

	//
	// Delete result pane columns
	//
	while(SUCCEEDED(pHeaderCtrl->DeleteColumn(0)))
	{
		NULL;
	}

	return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::PopulateResultChildrenList

Override this in your derived class.

This is called by EnumerateResultChildren which is called by OnShow when
you need to populate the list of children of this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::PopulateResultChildrenList( void )
{
	ATLTRACE(_T("# CNodeWithResultChildrenList::PopulateResultChildrenList -- override in your derived class\n"));
	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::RepopulateResultChildrenList

DON'T Override this in your derived class.

Call this to empty the list of children and repopulate it.
This method will call PopulateResultChildrenList, which you should override.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::RepopulateResultChildrenList(void)
{

	// Check for preconditions:
	// None.


	HRESULT hr;

	// Get rid of what we had.

	// Delete each node in the list of children
	int iSize = m_ResultChildrenList.GetSize();
	for (int i = 0; i < iSize; i++)
	{
		R<CChildNode> pChildNode = m_ResultChildrenList[i];
	}

	// Empty the list
	m_ResultChildrenList.RemoveAll();


	// We no longer have a populated list.
	m_bResultChildrenListPopulated = FALSE;


	// Repopulate the list.
	hr = PopulateResultChildrenList();
	if( FAILED(hr) )
	{
		return( hr );
	}

	// We've already loaded our children ClientNode objects with
	// data necessary to populate the result pane.
	m_bResultChildrenListPopulated = TRUE;	// We only want to do this once.

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::CNodeWithResultChildrenList

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
CNodeWithResultChildrenList<T,CChildNode, TArray,bIsExtension>::CNodeWithResultChildrenList(CSnapInItem * pParentNode, CSnapin * pComponentData): CSnapinNode<T,bIsExtension>(pParentNode, pComponentData)
{
	ATLTRACE(_T("# +++ CNodeWithResultChildrenList::CNodeWithResultChildrenList\n"));
	

	// Check for preconditions:
	// None.


	// We have not yet loaded the child nodes' data
	m_bResultChildrenListPopulated = FALSE;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::~CNodeWithResultChildrenList

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::~CNodeWithResultChildrenList()
{
	ATLTRACE(_T("# --- CNodeWithResultChildrenList::~CNodeWithResultChildrenList\n"));
	

	// Check for preconditions:
	// None.



	// Delete each node in the list of children
	int iSize = m_ResultChildrenList.GetSize();
	for (int i = 0; i < iSize; i++)
	{
		R<CChildNode> pChildNode = m_ResultChildrenList[i];
	}

	// Empty the list
	m_ResultChildrenList.RemoveAll();

}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::AddChildToList

Adds a child to the list of children.  Does not cause a view update.

Use this in your PopulateResultChildrenList method.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode, TArray, bIsExtension>::AddChildToList( CChildNode * pChildNode )
{
	

	// Check for preconditions:
	// None.


	HRESULT hr = S_OK;
	
	if( m_ResultChildrenList.Add(pChildNode ) )
	{

		hr = S_OK;

	}
	else
	{
		// Failed to add => out of memory
		hr = E_OUTOFMEMORY;
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::OnShow

Don't override this in your derived class.  Instead, override methods 
which it calls: InsertColumns and (indirectly) PopulateResultChildrenList

This method is an override of CSnapinNode::OnShow.  When MMC passes the
MMCN_SHOW method for this node, we are to add children into the 
result pane.  In this class we add them from a list we maintain.

For more information, see CSnapinNode::OnShow.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT
CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::OnShow(	
	LPARAM arg,
	LPARAM /*param*/,
	IComponentData * pComponentData,
	IComponent * pComponent,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CNodeWithResultChildrenList::OnShow\n"));
	

	// Check for preconditions:
	_ASSERTE( pComponentData != NULL || pComponent != NULL );


	HRESULT hr = S_FALSE;

	T * pT = static_cast<T*>( this );


	// Need IHeaderCtrl.

	// But to get that, first we need IConsole
	CComPtr<IConsole> spConsole;
	if( pComponentData != NULL )
	{
		 spConsole = ((CSnapin*)pComponentData)->m_spConsole;
	}
	else
	{
		// We should have a non-null pComponent
		 spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
	}
	_ASSERTE( spConsole != NULL );

	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeaderCtrl(spConsole);
	_ASSERT( spHeaderCtrl != NULL );

	if( arg ) 
	{

		// arg <> 0 => we are being selected.

		// Note: This method will only get called with 
		// arg <> 0 (i.e. selected) if you responded appropriately to
		// the MMCN_ADD_IMAGES method

		// We have been asked to display result pane nodes belonging under this node.

		// It appears we must do IResultData->InsertItems each time we receive 
		// the MMCN_SHOW message -- MMC doesn't remember what nodes
		// we have previously inserted.

		
		// Set the column headers in the results pane
		// Note: if you don't set these, MMC will never 
		// bother to put up your result-pane only items

		// When this Notify method is called from IComponentDataImpl, we 
		// get pHeader (and pToolbar) passed in as NULL, so we aren't
		// going to bother using it and will instead always
		// QI pConsole for this pointer
		

		// 
		// In some cases MMC calls us twice with same IHeaderCtrl. try to delete 
		// previous colums
		//					Uri Habusha, 28-Jan-2001
		//
		while(SUCCEEDED(spHeaderCtrl->DeleteColumn(0)))
		{
			NULL;
		}

		hr = pT->InsertColumns( spHeaderCtrl );
		ASSERT( S_OK == hr );

		// Display our list of children in the result pane

		// Need IResultData
		CComQIPtr<IResultData, &IID_IResultData> spResultData(spConsole);
		_ASSERT( spResultData != NULL );

		hr = pT->EnumerateResultChildren(spResultData );
    }
    else
    {
        //
        // We are unselected
        //
        hr = OnUnSelect(spHeaderCtrl);
	}

	return hr;


}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::OnRefresh


You shouldn't need to override this in your derived method.  Simply
enable the MMC_VERB_REFRESH for your node.

In our implementation, this method gets called when the MMCN_REFRESH
Notify message is sent for this node.  

For more information, see CSnapinNode::OnRefresh.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT
CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::OnRefresh(	
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CNodeWithResultChildrenList::OnRefresh\n"));
	
	//
	// Before calling RepopulateResultChildrenList ensures that MMC release all reference to 
	// the result pane items in all views. It can't be done directly since in this stage we
	// don't have an access to result data in all view. UpdateAllViews reach to 
	// CSnapinComponent::notify with MMCN_VIEW_CHANGE event. If the param value is 
	// UPDATE_REMOVE_ALL_RESULT_NODES the routine only deletes all the items in the current view
	// 
    HRESULT hr = m_pComponentData->m_spConsole->UpdateAllViews( NULL,(LPARAM) this, UPDATE_REMOVE_ALL_RESULT_NODES);
    ASSERT(("UpdateAllView Failed", SUCCEEDED(hr)));

	// Rebuild our list of nodes from the uderlying data source.
	T * pT = static_cast<T*> (this);
	hr = pT->RepopulateResultChildrenList();
	

	// Update the views.

	// We weren't passed an IConsole pointer here, so 
	// we use the one we saved in out CComponentData object.
	_ASSERTE( m_pComponentData != NULL );
	_ASSERTE( m_pComponentData->m_spConsole != NULL );

	// We pass in a pointer to 'this' because we want each
	// of our CComponent objects to update its result pane
	// view if 'this' node is the same as the saved currently
	// selected node.
	m_pComponentData->m_spConsole->UpdateAllViews( NULL, (LPARAM)this, NULL);

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::EnumerateResultChildren

Don't override this in your derived class. Instead, override the method 
it calls, PopulateResultChildrenList.  

This is called by the OnShow method.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::EnumerateResultChildren( IResultData * pResultData )
{
	ATLTRACE(_T("# CNodeWithResultChildrenList::EnumerateResultChildren\n"));
	

	// Check for preconditions:
	_ASSERTE( pResultData != NULL );


	HRESULT hr = S_OK;

	T * pT = static_cast<T*> (this);

	if ( FALSE == m_bResultChildrenListPopulated )
	{
		// We have not yet loaded all of our children into our list.
		// This call will add items to the list from whatever data source.
		hr = pT->PopulateResultChildrenList();
		if( FAILED(hr) )
		{
			return( hr );
		}

		// We've already loaded our children ClientNode objects with
		// data necessary to populate the result pane.
		m_bResultChildrenListPopulated = TRUE;	// We only want to do this once.

	}


	// From MeanGene's Step4 -- need to first remove all items from result pane
	hr = pResultData->DeleteAllRsltItems();
	if( FAILED(hr) )
	{
		return hr;
	}

	// The ResultChildrenList is already populated, so we
	// just need to show the CChildNode objects to the world
	// by populating the result pane.

	CChildNode* pChildNode;
	for (int i = 0; i < m_ResultChildrenList.GetSize(); i++)
	{
		pChildNode = m_ResultChildrenList[i];
		if ( NULL == pChildNode )
		{
			continue;
		}

		// Insert the item into the result pane.
		hr = pResultData->InsertItem( &(pChildNode->m_resultDataItem) );
		if (FAILED(hr))
		{
			return hr;
		}

		// Check: On return, the itemID member of 'm_resultDataItem' 
		// contains the handle to the newly inserted item.
		_ASSERT( NULL != pChildNode->m_resultDataItem.itemID );
	
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::RemoveChild

Removes a child from the list of children.

This is declared public because it must be accessed from a child node when that
node receives the MMCN_DELETE message and tries to delete itself.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, BOOL bIsExtension>
HRESULT CNodeWithResultChildrenList<T,CChildNode,TArray,bIsExtension>::RemoveChild( CChildNode * pChildNode )
{
	ATLTRACE(_T("CNodeWithResultChildrenList::RemoveChild"));


    // Check for preconditions:
    // None.


    HRESULT hr = S_OK;

    if( m_ResultChildrenList.Remove( pChildNode ) )
    {

        // We don't remove the item directly from the result pane now
        // using IResultData->RemoveItem, as we have no way of
        // removing it from all the possible views.
        // Instead, we call IConsole->UpdateAllViews which will
        // cause MMC to call Notify on each of our IComponent objects
        // with the MMCN_VIEW_CHANGE notification, and we will
        // repopulate the result view when we handle that notification.

        // We weren't passed an IConsole pointer here, so
        // we use the one we saved in out CComponentData object.
        _ASSERTE( m_pComponentData != NULL );
        _ASSERTE( m_pComponentData->m_spConsole != NULL );

        // We pass in a pointer to 'this' because we want each
        // of our CComponent objects to update its result pane
        // view if 'this' node is the same as the saved currently
        // selected node.
        m_pComponentData->m_spConsole->UpdateAllViews( NULL,(LPARAM) this, NULL);

    }
    else
    {
        // If we failed to remove, probably the child was never in the list
        // ISSUE: determine what do here -- this should never happen
        _ASSERTE( FALSE );
        hr = S_FALSE;
    }

    return hr;
}

#endif // _NODE_WITH_RESULT_CHILDREN_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\snpqueue.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	SnpQueue.h

Abstract:
	General queue (private, public...) functionality

Author:

    YoelA


--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __SNPQUEUE_H_
#define __SNPQUEUE_H_

#include "snpnscp.h"
#include "lqDsply.h"
#include "privadm.h"
#include "localq.h"


///////////////////////////////////////////////////////////////////////////////////////////
//
// CQueueDataObject - used for public queue extention
//
class CQueueDataObject : 
    public CQueue,
    public CMsmqDataObject,
   	public CComCoClass<CQueueDataObject,&CLSID_MsmqQueueExt>,
    public IDsAdminCreateObj,
    public IDsAdminNotifyHandler
{
public:
    DECLARE_NOT_AGGREGATABLE(CQueueDataObject)
    DECLARE_REGISTRY_RESOURCEID(IDR_MsmqQueueExt)

    BEGIN_COM_MAP(CQueueDataObject)
	    COM_INTERFACE_ENTRY(IDsAdminCreateObj)
	    COM_INTERFACE_ENTRY(IDsAdminNotifyHandler)
	    COM_INTERFACE_ENTRY_CHAIN(CMsmqDataObject)
    END_COM_MAP()

    CQueueDataObject();
    //
    // IShellPropSheetExt
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    //
    // IContextMenu
    //
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);

    //
    // IDsAdminCreateObj methods
    //
    STDMETHOD(Initialize)(IADsContainer* pADsContainerObj, 
                          IADs* pADsCopySource,
                          LPCWSTR lpszClassName);
    STDMETHOD(CreateModal)(HWND hwndParent,
                           IADs** ppADsObj);

    // IQueryForm
    STDMETHOD(AddForms)(THIS_ LPCQADDFORMSPROC pAddFormsProc, LPARAM lParam);
    STDMETHOD(AddPages)(THIS_ LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam);

    //
    // IDsAdminNotifyHandler
    //
    STDMETHOD(Initialize)(THIS_ /*IN*/ IDataObject* pExtraInfo, 
                          /*OUT*/ ULONG* puEventFlags);
    STDMETHOD(Begin)(THIS_ /*IN*/ ULONG uEvent,
                     /*IN*/ IDataObject* pArg1,
                     /*IN*/ IDataObject* pArg2,
                     /*OUT*/ ULONG* puFlags,
                     /*OUT*/ BSTR* pBstr);

    STDMETHOD(Notify)(THIS_ /*IN*/ ULONG nItem, /*IN*/ ULONG uFlags); 

    STDMETHOD(End)(THIS_); 


protected:
    HPROPSHEETPAGE CreateGeneralPage();
    HPROPSHEETPAGE CreateMulticastPage();
	virtual HRESULT ExtractMsmqPathFromLdapPath (LPWSTR lpwstrLdapPath);
    virtual HRESULT HandleMultipleObjects(LPDSOBJECTNAMES pDSObj);

   	virtual const DWORD GetObjectType();
    virtual const PROPID *GetPropidArray();
    virtual const DWORD  GetPropertiesCount();
	virtual HRESULT EnableQueryWindowFields(HWND hwnd, BOOL fEnable);
	virtual void ClearQueryWindowFields(HWND hwnd);
	virtual HRESULT GetQueryParams(HWND hWnd, LPDSQUERYPARAMS* ppDsQueryParams);
    HRESULT GetFormatNames(CArray<CString, CString&> &astrFormatNames);

    enum _MENU_ENTRY
    {
        mneDeleteQueue = 0
    };


private:
    CString m_strComputerName;
	CString m_strContainerDispFormat;
	CArray<CString, CString&> m_astrLdapNames;
	CArray<CString, CString&> m_astrQNames;
    CArray<HANDLE, HANDLE&> m_ahNotifyEnums;

};

inline const DWORD CQueueDataObject::GetObjectType()
{
    return MQDS_QUEUE;
};

inline const PROPID *CQueueDataObject::GetPropidArray()
{
    return mx_paPropid;
}


HRESULT 
CreatePrivateQueueSecurityPage(
       HPROPSHEETPAGE *phPage,
    IN LPCWSTR lpwcsFormatName,
    IN LPCWSTR lpwcsDescriptiveName);

HRESULT
CreatePublicQueueSecurityPage(
    HPROPSHEETPAGE *phPage,
    IN LPCWSTR lpwcsDescriptiveName,
    IN LPCWSTR lpwcsDomainController,
	IN bool	   fServerName,
    IN GUID*   pguid
	);


#endif // __SNPQUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\snpnerr.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	snperr.h

Abstract:

	Definition and implementation file for the CErrorNode snapin node class 

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////

#ifndef __SNPNERR_H_
#define __SNPNERR_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnode.h"


/////////////////////////////////////////////////////////////////////////////
// CErrorNode
// {B1320C00-BCB2-11d1-9B9B-00E02C064C39}
static const GUID CErrorNodeGUID_NODETYPE = 
{ 0xb1320c00, 0xbcb2, 0x11d1, { 0x9b, 0x9b, 0x0, 0xe0, 0x2c, 0x6, 0x4c, 0x39 } };

//////////////////////////////////////////////////////////////////////////////

class CErrorNode : public CSnapinNode<CErrorNode, FALSE>
{
public:
 
	CComPtr<IControlbar> m_spControlBar; 

  	BEGIN_SNAPINCOMMAND_MAP(CErrorNode, FALSE)
	END_SNAPINCOMMAND_MAP()


    CErrorNode(CSnapInItem * pParentNode, CSnapin * pComponentData) : 
        CSnapinNode<CErrorNode, FALSE>(pParentNode, pComponentData)
	{       
        SetIcons(IMAGE_ERROR, IMAGE_ERROR);
	}

	~CErrorNode()
	{
	}



private:
};

#ifdef INIT_ERROR_NODE
    const GUID*  CErrorNode::m_NODETYPE = &CErrorNodeGUID_NODETYPE;
    const OLECHAR* CErrorNode::m_SZNODETYPE = OLESTR("B1320C00-BCB2-11d1-9B9B-00E02C064C39");
    const OLECHAR* CErrorNode::m_SZDISPLAY_NAME = OLESTR("MSMQ Message Admin");
    const CLSID* CErrorNode::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\snpnode.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    snpnode.h

Abstract:

	Header for the CSnapinNode class.

	This is our virtual base class for an MMC Snap-in node.

	As this is a template class and is all implemented inline,
	there is no SnapinNode.cpp for implementation.


Author:

    Original: Michael A. Maguire 
    Modifications: RaphiR

Changes:
    Specific MSMQ support:
        Default images
        Default columns
    Support for Extension snapins 
    Add a CComponentData pointer
    SetIcons method
    

--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_SNAPIN_NODE_H_)
#define _SNAPIN_NODE_H_

#include <tr.h>
#include <ref.h>


class CSnapin;



template <class T, BOOL bIsExtension>
class CSnapinNode : public CSnapInItemImpl< T, bIsExtension>, public CReference
{

protected:

	// Constructor/Destructor	
	CSnapinNode(CSnapInItem * pParentNode, CSnapin * pComponentData);
	~CSnapinNode();

private:

	virtual CString GetHelpLink();


public:


	// For IDataObject handling.
	IDataObject* m_pDataObject;
	void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault);


    //
    // Change the default icon id
    //
    void SetIcons(DWORD idStandard, DWORD idOpen);

	// Clipboard formats which IDataObjects on all MMC nodes must support.
	static const GUID* m_NODETYPE;
	static const TCHAR* m_SZNODETYPE;
	static const TCHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;



	// Pointer to parent node.  This is passed in the call to our 
	// constructor.  Needed so that a node can access its parent.
	// For example, when we receive the MMCN_DELETE notification, we might tell
	// our parent node to remove us from its list of children.
	CSnapInItem * m_pParentNode;

    //
    // Pointer to the component data. Allow us to
    // access Snapin global data
    //
    CSnapin *     m_pComponentData;


public:


	// Standard MMC functionality -- override if you need to.
	STDMETHOD(CreatePropertyPages)(
		  LPPROPERTYSHEETCALLBACK lpProvider
		, LONG_PTR handle
		, IUnknown* pUnk
		, DATA_OBJECT_TYPES type
		);
    STDMETHOD(QueryPagesFor)( DATA_OBJECT_TYPES type );
	void* GetDisplayName();
    STDMETHOD(GetScopePaneInfo)( SCOPEDATAITEM *pScopeDataItem );
	STDMETHOD(GetResultPaneInfo)( RESULTDATAITEM *pResultDataItem );
	virtual LPOLESTR GetResultPaneColInfo(int nCol);
	virtual HRESULT SetVerbs( IConsoleVerb * pConsoleVerb );


	// Notify method will call notification handlers below -- shouldn't need to override.
	STDMETHOD( Notify ) ( 
			  MMC_NOTIFY_TYPE event
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			);


	// Notification handlers -- override when you want to intercept.
	virtual HRESULT OnActivate( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnAddImages( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnButtonClick( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnClick( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnContextHelp( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnContextMenu( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnDoubleClick( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnDelete( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				, BOOL fSilent = FALSE
				);
	virtual HRESULT OnExpand(
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnHelp(
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnMenuButtonClick( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnMinimized( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnPaste( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnPropertyChange( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnQueryPaste( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnRefresh( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnRemoveChildren( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnRename( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnSelect( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnShow( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnViewChange( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);
	virtual HRESULT OnColumnsChanged( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);


	// Special notification handler -- saves off the currently selected node.
	HRESULT PreOnShow( 
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type 
				);



	// Taskpad functionality.
	STDMETHOD(TaskNotify)(
				  IDataObject * pDataObject
				, VARIANT * pvarg
				, VARIANT * pvparam
				);
	STDMETHOD(EnumTasks)(
				  IDataObject * pDataObject
				, BSTR szTaskGroup
				, IEnumTASK** ppEnumTASK
				);


};




//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:SetIcons

    Specify the Open and Close icons of the snapin node

Remarks: 


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
void CSnapinNode<T, bIsExtension>::SetIcons(DWORD idStandard, DWORD idOpen)
{
	m_scopeDataItem.nImage = idStandard;  
	m_scopeDataItem.nOpenImage = idOpen;

	m_resultDataItem.nImage = idStandard;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:CreatePropertyPages

Adds pages to a property sheet.


HRESULT CreatePropertyPages(
  LPPROPERTYSHEETCALLBACK lpProvider,
							  // Pointer to the callback interface
  LONG_PTR handle,            // Handle for routing notification
  LPDATAOBJECT lpIDataObject  // Pointer to the data object
);


Remarks: 


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP
CSnapinNode<T, bIsExtension>::CreatePropertyPages(
	LPPROPERTYSHEETCALLBACK /*lpProvider*/,
	LONG_PTR /*handle*/,
	IUnknown* /*pUnk*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::CreatePropertyPages -- override in your derived class\n"));

	return E_NOTIMPL;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:QueryPagesFor

Determines whether the object requires pages.


HRESULT QueryPagesFor(  DATA_OBJECT_TYPES type  );


Parameters

	void


Return Value

	S_OK 
	Properties exist for this cookie.

	E_UNEXPECTED 
	An unexpected error occurred.

	E_INVALID 
	The parameter is invalid. 

	ISSUE: So what do we return if an item doesn't have property pages?  
		S_FALSE is used in sburns' localsec code

Remarks

	The console calls this method to determine whether the Properties menu 
	item should be added to the context menu.


  Override this in your derived class, if your object supports menu

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::QueryPagesFor( DATA_OBJECT_TYPES /*type*/)
{
	ATLTRACE(_T("# CSnapinNode::QueryPagesFor -- override in your derived class if you have property pages\n"));

	// this method should be overriden and should return S_OK if you
	// have property pages for this node otherwise it should return S_FALSE.

	return S_FALSE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:InitDataClass

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
void CSnapinNode<T, bIsExtension>::InitDataClass(IDataObject* pDataObject, CSnapInItem* /*pDefault*/)
{
	// The default code stores off the pointer to the Dataobject the class is wrapping
	// at the time. 
	// Alternatively you could convert the dataobject to the internal format
	// it represents and store that information

	m_pDataObject = pDataObject;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetDisplayName

ISSUE: what are the parameters to this function?  Why not void?

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
void* CSnapinNode<T, bIsExtension>::GetDisplayName()
{
	ATLTRACE(_T("# CSnapinNode::GetDisplayName\n"));

//		ISSUE: It looks as thought the m_SZDISPLAY_NAME is a totally
//		bogus variable -- we should think about eliminating it
//		Problematic -- const m_SZDISPLAY_NAME can't be localized
//		return (void*)m_SZDISPLAY_NAME;

	return (void*)m_bstrDisplayName;
}

//	void* GetSnapInCLSID()
//	{
//		ATLTRACE(_T("# CSnapinNode::GetSnapInCLSID\n"));
//
//		return (void*)m_SNAPIN_CLASSID;
//	}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetScopePaneInfo


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::GetScopePaneInfo( SCOPEDATAITEM *pScopeDataItem )
{
	ATLTRACE(_T("# CSnapinNode::GetScopePaneInfo\n"));

	if (pScopeDataItem->mask & SDI_STR)
		pScopeDataItem->displayname = m_bstrDisplayName;
	if (pScopeDataItem->mask & SDI_IMAGE)
		pScopeDataItem->nImage = m_scopeDataItem.nImage;
	if (pScopeDataItem->mask & SDI_OPENIMAGE)
		pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
	if (pScopeDataItem->mask & SDI_PARAM)
		pScopeDataItem->lParam = m_scopeDataItem.lParam;
	if (pScopeDataItem->mask & SDI_STATE )
		pScopeDataItem->nState = m_scopeDataItem.nState;

	// TODO : Add code for SDI_CHILDREN 
	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetResultPaneInfo


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>::GetResultPaneInfo( RESULTDATAITEM *pResultDataItem )
{
	ATLTRACE(_T("# CSnapinNode::GetResultPaneInfo\n"));

	if (pResultDataItem->bScopeItem)
	{
		if (pResultDataItem->mask & RDI_STR)
		{
			pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
		}
		if (pResultDataItem->mask & RDI_IMAGE)
		{
			pResultDataItem->nImage = m_scopeDataItem.nImage;
		}
		if (pResultDataItem->mask & RDI_PARAM)
		{
			pResultDataItem->lParam = m_scopeDataItem.lParam;
		}

		return S_OK;
	}

	if (pResultDataItem->mask & RDI_STR)
	{
		pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
	}
	if (pResultDataItem->mask & RDI_IMAGE)
	{
		pResultDataItem->nImage = m_resultDataItem.nImage;
	}
	if (pResultDataItem->mask & RDI_PARAM)
	{
		pResultDataItem->lParam = m_resultDataItem.lParam;
	}
	if (pResultDataItem->mask & RDI_INDEX)
	{
		pResultDataItem->nIndex = m_resultDataItem.nIndex;
	}

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::Notify


This method is this node's response to the MMC calling Notify on 
IComponent or IComponentData.


STDMETHOD( Notify ) ( 
		  MMC_NOTIFY_TYPE event
		, LPARAM arg
		, LPARAM param
		, IComponentData * pComponentData
		, IComponent * pComponent
		, DATA_OBJECT_TYPES type 
		
		
		)


Parameters 

	event 
	[in] Identifies an action taken by a user. IComponent::Notify and 
	IComponentData::Notify can receive the following notifications for a 
	specific node: 

		MMCN_ACTIVATE
		MMCN_ADD_IMAGES
		MMCN_BTN_CLICK
		MMCN_CLICK
		MMCN_CONTEXTMENU
		MMCN_DBLCLICK
		MMCN_DELETE
		MMCN_EXPAND
		MMCN_HELP
		MMCN_MENU_BTNCLICK
		MMCN_MINIMIZED
		MMCN_PROPERTY_CHANGE
		MMCN_REFRESH
		MMCN_REMOVE_CHILDREN
		MMCN_RENAME
		MMCN_SELECT
		MMCN_SHOW
		MMCN_VIEW_CHANGE
		MMCN_CONTEXTHELP

	See CSnapinNode::OnActivate, OnAddImages, OnButtonClick, etc. for
	a detailed explanation of each of these notify events

	arg 
	Depends on the notification type.

	param 
	Depends on the notification type. 


Return Values 

	S_OK 
	Depends on the notification type.

	E_UNEXPECTED 
	An unexpected error occurred. 


Remarks

	Our IComponentData and IComponent implementations were passed a LPDATAOBJECT 
	which corresponds to a node.  This was converted to a pointer to
	a node object.  Below is the Notify method on this node object, were
	the node object can deal with the Notify event itself.

	Our implementation of Notify is a large switch statement which delegates the
	task of dealing with virtual OnXxxxxx methods which can overridden in
	derived classes.  As all events are dealt with this way here, you shouldn't
	need to implement a Notify method for any of your derived nodes.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP CSnapinNode<T, bIsExtension>:: Notify ( 
		  MMC_NOTIFY_TYPE event
		, LPARAM arg
		, LPARAM param
		, IComponentData * pComponentData
		, IComponent * pComponent
		, DATA_OBJECT_TYPES type
		)
{
	ATLTRACE(_T("# CSnapinNode::Notify\n"));

	HRESULT hr = S_FALSE;

	// this makes for faster code.
	T* pT = static_cast<T*> (this);



	switch( event )
	{

	case MMCN_ACTIVATE:
		hr = pT->OnActivate( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_ADD_IMAGES:
		hr = pT->OnAddImages( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_BTN_CLICK:
		hr = pT->OnButtonClick( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_CLICK:
		hr = pT->OnClick( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_SNAPINHELP:
	case MMCN_CONTEXTHELP:
		hr = pT->OnContextHelp( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_CONTEXTMENU:
		hr = pT->OnContextMenu( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_CUTORMOVE:
		hr = pT->OnDelete( arg, param, pComponentData, pComponent, type, TRUE );
		break;

	case MMCN_DBLCLICK:
		hr = pT->OnDoubleClick( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_DELETE:
		hr = pT->OnDelete( arg, param, pComponentData, pComponent, type, FALSE );
		break;

	case MMCN_EXPAND:
		hr = pT->OnExpand( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_HELP:
		hr = pT->OnHelp( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_MENU_BTNCLICK:
		hr = pT->OnMenuButtonClick( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_MINIMIZED:
		hr = pT->OnMinimized( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_PASTE:
		hr = pT->OnPaste( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_PROPERTY_CHANGE:
		hr = pT->OnPropertyChange( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_QUERY_PASTE:
		hr = pT->OnQueryPaste( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_REFRESH:
		hr = pT->OnRefresh( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_REMOVE_CHILDREN:
		hr = pT->OnRemoveChildren( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_RENAME:
		hr = pT->OnRename( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_SELECT: 
		// For nodes with result-pane children
		hr = pT->OnSelect( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_SHOW: 
		// For nodes with result-pane children
		// We call PreOnShow which will then call OnShow.
		// PreOnShow will save away the selected node in a member variable
		// of out CComponent class.
		//hr = pT->PreOnShow( arg, param, pComponentData, pComponent, type );
		hr = pT->OnShow( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_VIEW_CHANGE:
		hr = pT->OnViewChange( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_COLUMNS_CHANGED:
		hr = pT->OnColumnsChanged( arg, param, pComponentData, pComponent, type );
		break;

	default:
		// Unhandled notify event.
		//  MMC wants E_NOTIMPL if you can't do something or it will crash
		hr = E_NOTIMPL;
		break;

	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:CSnapinNode 

Constructor

This class is to be the virtual base class for all our nodes
We never want people instantiating it so the constructor is protected

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
CSnapinNode<T, bIsExtension>::CSnapinNode(CSnapInItem * pParentNode, CSnapin * pComponentData)
{
	ATLTRACE(_T("# +++ CSnapinNode::CSnapinNode\n"));

	// Set the parent node below which this node is displayed.
	m_pParentNode = pParentNode;

    // Set the componet data
    m_pComponentData = pComponentData;



	// We set cookie for both scope and result pane data items,
	// as this class can be subclassed for either a scope-pane
	// or a result-pane-only node.

	// Sridhar moved this initialization code out of SnapInItemImpl
	memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
	m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
	m_scopeDataItem.displayname = MMC_CALLBACK;
	m_scopeDataItem.nImage = 0;			// May need modification
	m_scopeDataItem.nOpenImage = 0;		// May need modification
	// If this node is inserted in to the scope pane using
	// IConsoleNamespace->InsertItem, the value stored in lParam 
	// will be what MMC later passes back as the cookie for this node.
	m_scopeDataItem.lParam = (LPARAM) this;

	// Sridhar moved this initialization code out of SnapInItemImpl
	memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
	m_resultDataItem.str = MMC_CALLBACK;
	m_resultDataItem.nImage = 0;		// May need modification
	// If this node is inserted in to the result pane using 
	// IResultData->InsertItem, the value stored in lParam will
	// be what MMC later passes back as the cookie for this node.
	m_resultDataItem.lParam = (LPARAM) this;


}






//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:~CSnapinNode 

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
CSnapinNode<T, bIsExtension>::~CSnapinNode()
{
	ATLTRACE(_T("# --- CSnapinNode::~CSnapinNode\n"));
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetResultPaneColInfo


  By default, we return the display name in the first column, and blank ("") 
  for other columns.
  Override in your derived class if you want more columns support
--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
LPOLESTR CSnapinNode<T, bIsExtension>::GetResultPaneColInfo(int nCol)
{
	ATLTRACE(_T("# CSnapinNode::GetResultPaneColInf\n"));

	if (nCol == 0)
	{
		return m_bstrDisplayName;
	}

	// Return the blank for other columns
	return OLESTR(" ");
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnActivate

virtual HRESULT OnActivate(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_ACTIVATE 
Notify message is sent for this node.  

MMC sends this message to the snap-in's IComponent::Notify method when a window is 
being activated or deactivated.


Parameters

	arg 
	TRUE if the window is activated; otherwise, it is FALSE.

	param 
	Not used. 


Return Values

	Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnActivate( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnActivate  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnAddImages

virtual HRESULT OnAddImages(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

We have chosen to handle this on a per-IComponent object basis, since it has
very little to do (for us at least) with the particular IDataObject.

See CComponent::OnAddImages for where we add images.


This method loads the default ImageList we have
Override this, if you want different imagelist

By default, Loads specific images for this project

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnAddImages( 
	LPARAM arg,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnAddImages  -- Override in your derived class\n"));
    HRESULT hr;

	IImageList* pImageList = (IImageList*) arg;
	hr = E_FAIL;
	// Load bitmaps associated with the scope pane
	// and add them to the image list
	// Loads the default bitmaps generated by the wizard
	// Change as required
	CBitmapHandle hBitmap16 = LoadBitmap(g_hResourceMod, MAKEINTRESOURCE(IDR_MMCICONS_16x16));
	if (hBitmap16 != NULL)
	{
		CBitmapHandle hBitmap32 = LoadBitmap(g_hResourceMod, MAKEINTRESOURCE(IDR_MMCICONS_32x32));
		if (hBitmap32 != NULL)
		{
			hr = pImageList->ImageListSetStrip(
								reinterpret_cast<LONG_PTR*>((HBITMAP)hBitmap16), 
								reinterpret_cast<LONG_PTR*>((HBITMAP)hBitmap32), 
								0, 
								RGB(0, 128, 128)
								);
			if (FAILED(hr))
				ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
		}
	}
	return(hr);
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnButtonClick

virtual HRESULT OnButtonClick(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_BTN_CLICK Notify message is 
sent for this node.  

MMC sends this message to the snap-in's IComponent, IComponentData, 
or IExtendControlbar implementation when a user clicks on one of the 
toolbar buttons.


Parameters

For IComponent::Notify or IComponentData::Notify:

	arg 
	Must be zero.

	param 
	CmdID of the button equal to a value of the MMC_CONSOLE_VERB enumeration. 

For IExtendControlBar::ControlbarNotify:

	arg 
	Data object of the currently selected scope or result pane item.

	param 
	[in] CmdID of the button equal to a value of the MMC_CONSOLE_VERB enumeration. 


Return Values

	Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnButtonClick( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnButtonClick  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnClick

virtual HRESULT OnClick(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_CLICK Notify message is 
sent for this node.  

MMC sends this message to IComponent when a user clicks a mouse button 
on a list view item.


Parameters

 	arg 
	Not used.

	param 
	Not used. 


Return Values

	Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnClick( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnClick  -- Override in your derived class\n"));

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::GetHelpLink

virtual CString GetHelpLink(	
	VOID
	)

	Called when user requests help about a selected item


Parameters

	arg 
	0.

	param 
	0. 


Return Values

  Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
CString CSnapinNode<T, bIsExtension>::GetHelpLink( 
	VOID
	)
{
	CString strHelpLink;
    strHelpLink.LoadString(IDS_HELPTOPIC_GENERAL); // sag_MSMQtopnode.htm

	return strHelpLink;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnContextHelp

virtual HRESULT OnContextHelp(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_CONTEXTHELP Notify message is 
sent for this node.  

MMC sends this message when the user requests help about a selected item


Parameters

	arg 
	0.

	param 
	0. 


Return Values

  Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnContextHelp( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * pComponentData,
	IComponent * pComponent,
	DATA_OBJECT_TYPES /*type*/
	)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    //
    // Get Display help interface
    //
	CComPtr<IConsole> spConsole;
 	if( pComponentData != NULL )
	{
		 spConsole = ((CSnapin*)pComponentData)->m_spConsole;
	}
	else
	{
        //
		// We should have a non-null pComponent
        //
		 spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
	}
	_ASSERTE( spConsole != NULL );

    CComQIPtr<IDisplayHelp, &IID_IDisplayHelp> spDisplayHelp(spConsole);
    _ASSERTE( spDisplayHelp != NULL );

    if (spDisplayHelp == NULL)
    {
        return E_FAIL;
    }

    //
    // construct help topic path = (help file::topic string)
    //
    CString strTopicPath;
    CString strHelpTopic;

    CString strHelpPath;
    strTopicPath.LoadString(IDS_HTMLHELP_NAME); // \help\msmqconcepts.chm

	strHelpTopic = GetHelpLink();

    strTopicPath += _T("::/");
    strTopicPath += strHelpTopic;           // \help\msmqconcepts.chm::/sag_MSMQtopnode.htm

    return spDisplayHelp->ShowTopic(strTopicPath.AllocSysString());
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnContextMenu

virtual HRESULT OnContextMenu(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_CONTEXTMENU Notify 
message is sent for this node.  

In the Fall 97 Platform SDK documentation, this event is listed as not used. 


Parameters

	arg 
	TBD

	param 
	TBD 

Return Values

	Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnContextMenu( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnContextMenu  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnDoubleClick

virtual HRESULT OnDoubleClick(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_DBLCLICK Notify message is 
sent for this node.  

MMC sends this message to IComponent when a user double clicks a mouse 
button on a list view item.


Parameters

	arg 
	Not used.

	param 
	Not used. 


Return Values

	Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnDoubleClick( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnDoubleClick  -- Override in your derived class if you don't want default verb action\n"));

	// Through speaking with Eugene Baucom, I discovered that if you return S_FALSE
	// here, the default verb action will occur when the user double clicks on a node.
	// For the most part we have Properties as default verb, so a double click
	// will cause property sheet on a node to pop up.
//		return E_NOTIMPL;
	return S_FALSE;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnDelete

virtual HRESULT OnDelete(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_DELETE Notify
message is sent for this node.  

MMC sends this message to the snap-in's IComponent and IComponentData implementation to inform the snap-in that the object should be deleted.


Parameters

	arg 
	Not used.

	param 
	Not used. 

Return Values

	Not used.


Remarks

	This message is generated when the user presses the delete key or uses
	the mouse to click on the toolbar's delete button.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnDelete( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/,
	BOOL /*fSilent*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnDelete  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnExpand

virtual HRESULT OnExpand(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

If your node will have scope-pane children, 
this method should be overidden in your derived class.

In our implementation, this method gets called when the MMCN_EXPAND Notify message is 
sent for this node.  

MMC sends this message to the snap-in's IComponentData 
implementation when a folder node needs to be expanded or contracted.


Parameters

	arg 
	[in] If TRUE, the folder needs to be expanded. If FALSE, the folder needs to be contracted.

	Param 
	[in] The HSCOPEITEM of the item that needs to be expanded. 


Return Values

	HRESULT


Remarks

	On receipt of this notification the snap-in should enumerate the 
	children (sub-containers only) of the specified scope item, if any, 
	using IConsoleNameSpace methods. Subsequently, if a new item is added to 
	or deleted from this scope object through some external means, then 
	that item should also be added to or deleted from the console's 
	namespace using IConsoleNameSpace methods.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnExpand(
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnExpand  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnHelp

virtual HRESULT OnHelp(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_HELP Notify 
message is sent for this node.  

In the Fall 97 Platform SDK documentation, this event is listed as not used. 

MMC sends this message when the user presses the F1 help key. 


Parameters

	arg 
	TBD

	param 
	Pointer to a GUID. If NULL, the NodeType is used instead. 


Return Values

	Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnHelp(
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnHelp  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnMenuButtonClick

virtual HRESULT OnMenuButtonClick(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)


In our implementation, this method gets called when the MMCN_MENU_BTNCLICK Notify
message is sent for this node.  

MMC sends this ify message is sent Sent to the snap-in's IExtendControlbar 
interface when a user clicks on a menu button.


Parameters

	arg 
	Data object of currently selected scope or result pane item. 

	param 
	[in] Pointer to a MENUBUTTONDATA structure. 


Return Values
	
	  Not Used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnMenuButtonClick( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnMenuButtonClick  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnMinimized

virtual HRESULT OnMinimized(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)


In our implementation, this method gets called when the MMCN_MINIMIZED Notify message is 
sent for this node.  
  
MMC sends this message to the snap-in's IComponent implementation when 
a window is being minimized or maximized.


Parameters

	arg 
	TRUE if the window has been minimized; otherwise, it is FALSE.

	Param 
	Not used. 


Return Values

  Not Used


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnMinimized( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnMinimized  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnPaste

virtual HRESULT OnPaste(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_PASTE 
Notify message is sent for this node.  

Called to ask the snap-ins folder to paste the selected items. 


Parameters

	pDataobject 
	The data object in which to paste the selected items provided by the snap-in. 
	arg 
	The data object of the selected item(s) provided by the source snap-in that need to be pasted. 
	param 
	NULL for move (as opposed to cut). 
	For a single-item paste: 

	BOOL* pPasted = (BOOL*)param; Set this to TRUE here if the item was successfully pasted. 

	For a multiitem paste: 

	LPDATAOBJECT* ppDataObj = (LPDATAOBJECT*)param; 

	Use this to return a pointer to a data object consisting of the items successfully pasted. See MMCN_CUTORMOVE.


Return Values
	
	Not used.


See Also
	
	MMCN_CUTORMOVE 

 
--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnPaste( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnPaste  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnPropertyChange

virtual HRESULT OnPropertyChange(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_PROPERTY_CHANGE 
Notify message is sent for this node.  

When the snap-in uses the MMCPropertyChangeNotify function to notify it's 
views about changes, MMC_PROPERTY_CHANGE is sent to the snap-in's 
IComponentData and IComponent implementations.


Parameters

	arg 
	[in] TRUE if the property change is for a scope pane item.

	lParam 
	This is the param passed into MMCPropertyChangeNotify. 


Return Values
	
	  Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnPropertyChange( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnPropertyChange  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnQueryPaste

virtual HRESULT OnQueryPaste(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_QUERY_PASTE
Notify message is sent for this node.  

Sent to the snap-in before pasting into the snap-in's folder to determine if the 
snap-in can accept the data. 


Parameters

	pdataobject 
	The dataobject of the selected item provided by the snap-in. 
	arg 
	The dataobject of the item(s) provided by the source snap-in that need to be pasted. 
	param 
	Not used. 

  
Return Values

	Not used.


See Also

	MMCN_PASTE


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnQueryPaste( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnQueryPaste  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnRefresh

virtual HRESULT OnRefresh(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_REFRESH
Notify message is sent for this node.  

In the Fall 97 Platform SDK documentation, this event is listed as TBD.


Parameters


Return Values

	Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnRefresh( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnRefresh  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnRemoveChildren

virtual HRESULT OnRemoveChildren(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_REMOVE_CHILDREN 
Notify message is sent for this node.  

MMC sends this message to the snap-in's IComponentData implementation to inform 
the snap-in that it must delete all the cookies (the entire subtree) it has 
added below the specified node.


Parameters

	arg 
	Specifies the HSCOPEITEM of the node whose children need to be deleted.

	param 
	Not used. 


Return Values
	
	  Not used.


Remarks

  	Use IConsoleNameSpace methods GetChildItem and GetNextItem to traverse
	the tree and determine the cookies to be deleted.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnRemoveChildren( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnRemoveChildren  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnRename

virtual HRESULT OnRename(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_RENAME Notify 
message is sent for this node.  
	
ISSUE: I do not seem to be seeing the two-call behaviour documented below

MMC sends this message the first time to query for a rename and the 
second time to do the rename. 


Parameters

	arg 
	Not used. 

	param 
	LPOLESTR for containing the new name. 

Return Values

	S_OK 
	Allows the rename.

	S_FALSE 
	Disallows the rename. 


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnRename( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnRename  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnSelect

virtual HRESULT OnSelect(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

You shouldn't need to override this method.  The OnSelect method has common 
behaviour for all nodes, only the verbs to be set are different.  Rather 
than overriding OnSelect in each node, simply override SetVerbs, which this
implementation of OnSelect calls.

In our implementation, this method gets called when the MMCN_SELECT Notify message is 
sent through IComponent::Notify for this node.  

Note: MMC also sends the MMCN_SELECT message through IExtendControlbar::ControlbarNotify
but we don't respond to that here -- See CSnapInItem::ControlbarNotify for that.


Parameters

For IComponent::Notify:

	arg 
	BOOL bScope = (BOOL) LOWORD(arg);
	BOOL bSelec = (BOOL) HIWORD(arg); 

	bScope
	TRUE if an item in the scope pane is selected.
	FALSE if an item in the result view pane is selected.

	bSelect 
	TRUE if the item is selected. 
	FALSE if the item is deselected.

	param 
	This parameter is ignored. 

Return Values

	Not used.


Remarks

	When an IComponent::Notify method receives the MMCN_SELECT notification
	it should update the standard verbs. 

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnSelect( 
	LPARAM arg,
	LPARAM /*param*/,
	IComponentData * pComponentData,
	IComponent * pComponent,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnSelect\n"));

	
	
	_ASSERTE( pComponentData != NULL || pComponent != NULL );


	HRESULT hr = S_FALSE;
	CComPtr<IConsoleVerb> spConsoleVerb;

	BOOL bSelected = (BOOL) HIWORD( arg );

	if( bSelected )
	{

		// Need IConsoleVerb

		// But to get that, first we need IConsole
		CComPtr<IConsole> spConsole;
		if( pComponentData != NULL )
		{
			 spConsole = ((CSnapin*)pComponentData)->m_spConsole;
		}
		else
		{
			// We should have a non-null pComponent
			 spConsole = ((CSnapinComponent*)pComponent)->m_spConsole;
		}
		_ASSERTE( spConsole != NULL );

		hr = spConsole->QueryConsoleVerb( &spConsoleVerb );
		_ASSERT( SUCCEEDED( hr ) );

		hr = SetVerbs( spConsoleVerb );

	}
	else
	{

		// Anything to do here? Don't think so -- see sburns localsec example.

		hr = S_OK;

	}


	return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::SetVerbs

virtual HRESULT SetVerbs( IConsoleVerb * pConsoleVerb )

Override this method in your derived class.

This method is called by our default implementation of OnSelect 
when the verbs for this node need to be set.

Parameters

	IConsoleVerb * pConsoleVerb


Return Values

	HRESULT


Remarks

	The OnSelect method has common behaviour for all nodes, only the verbs 
	to be set are different.  Rather than duplicate code by implementing OnSelect
	in each node, simply override this SetVerbs method

	Every time an item is selected, the verb states for all the commands 
	are returned to disabled and visible. It is up to the snap-in writer 
	to use IConsoleVerb to update the verb state every time an item is selected.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::SetVerbs( IConsoleVerb * /*pConsoleVerb*/)
{
	ATLTRACE(_T("# CSnapinNode::SetVerbs -- Override in your derived class\n"));

	HRESULT hr = S_OK;

	// Override in your derived class and do something like:
/*		
	// We want the user to be able to choose properties on this node
	hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );

	// We want the default verb to be Properties
	hr = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

	// We want the user to be able to rename this node
	hr = pConsoleVerb->SetVerbState( MMC_VERB_RENAME, ENABLED, TRUE );
*/	
	return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::PreOnShow

virtual HRESULT PreOnShow(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

We call this instead of OnShow, so that we can save away the selected node.

This method will then just call OnShow.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT CSnapinNode<T, bIsExtension>::PreOnShow( 
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)
{
	ATLTRACE(_T("# CSnapinNode::PreOnShow  -- Don't override in your derived class\n"));


	if( NULL != pComponent )
	{

		CSnapinComponent * pMyComponent = static_cast<CSnapinComponent *>( pComponent );

		if( arg ) 
		{
			// We are being selected.

			// Save our 'this' pointer as the currently selected node for this result view.  
			pMyComponent->m_pSelectedNode = static_cast<CSnapInItem *>( this );

		}
		else
		{
			// We are being deselected.

			// Check to make sure that our result view doesn't think
			// this node is the currently selected one.
			if( pMyComponent->m_pSelectedNode == static_cast<CSnapInItem *>( this ) )
			{
				// We don't want to be the selected node anymore.
				pMyComponent->m_pSelectedNode = NULL;
			}

		}

	}

	return OnShow( arg, param, pComponentData, pComponent, type );
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnShow

virtual HRESULT OnShow(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

If your node will have result-pane children, 
this method should be overidden in your derived class.

In our implementation, this method gets called when the MMCN_SHOW Notify message is 
sent for this node.  

MMC sends this message when a scope item is selected or deselected for the 
first time. 


Parameters

	arg 
	TRUE (<>0 ) if selecting; True indicates that the snap-in should set 
	up the result pane and add the enumerated items. 
	FALSE (0) if deselecting. indicates that the snap-in is going out of 
	focus and that it should clean up all cookies the right hand side 
	(the result pane), because current result pane will be replaced by a new one.

	param 
	The HSCOPEITEM of the selected or deselected item. 


Return Values

	Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnShow( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnShow  -- Override in your derived class\n"));

	// Returning E_NOTIMPL seems to be a bad thing here.  
	// It caused all kinds of problems with toolbar buttons persisting to
	// the wrong node, as well as verbs not getting set correctly for nodes.
	// Basically, if you don't respond with S_OK to the MMCN_SHOW notification,
	// you won't get sent the appropriate MMCN_SELECT notification.
	// return E_NOTIMPL;
	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnViewChange

virtual HRESULT OnViewChange(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_VIEW_CHANGE Notify 
message is sent for this node.  

MMC sends this message to the snap-in's IComponent implementation so it 
can update all views when a change occurs.  This node data object passed 
to IConsole::UpdateAllViews.


Parameters

	arg 
	[in] The data parameter passed to IConsole::UpdateAllViews.

	param 
	[in] The hint parameter passed to IConsole::UpdateAllViews. 


Return Values

	Not used.


Remarks

	This notification is generated when the snap-in (IComponent or
	IComponentData) calls IConsole::UpdateAllViews.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnViewChange( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnViewChange  -- Override in your derived class\n"));

	return E_NOTIMPL;
}
/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnColumnsChanged

virtual HRESULT OnColumnsChanged(	
			, LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type 
			)

In our implementation, this method gets called when the MMCN_COLUMNS_CHANGED Notify 
message is sent for this node.  

MMC sends this message to the snap-in's IComponent implementation when some of the columns were
changed. By default, we return S_OK - meaning that the change is accepted. In result,
MMC will actually update the columns.
To prevent MMC from updating the columns, return E_UNEXPECTED.


Parameters

	arg 
	[in] Not used.

	param 
	[in] pointer to MMC_VISIBLE_COLUMNS structure.


Return Values

	S_OK to accept the changes, E_UNEXPECTED to reject them.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
HRESULT
CSnapinNode<T, bIsExtension>::OnColumnsChanged( 
	LPARAM /*arg*/,
	LPARAM /*param*/,
	IComponentData * /*pComponentData*/,
	IComponent * /*pComponent*/,
	DATA_OBJECT_TYPES /*type*/
	)
{
	ATLTRACE(_T("# CSnapinNode::OnColumnsChanged  -- Override in your derived class\n"));

	//
	// By default - accept the columns change
	//
	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::TaskNotify

Called when MMC wants to notify us that the user clicked on a task 
on a taskpad belonging to this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP
CSnapinNode<T, bIsExtension>::TaskNotify(
	IDataObject * /*pDataObject*/,
	VARIANT * /*pvarg*/,
	VARIANT * /*pvparam*/
	)
{
	ATLTRACENOTIMPL(_T("# CSnapInItemImpl::TaskNotify\n"));
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::EnumTasks

Called when MMC wants us to enumerate the tasks	on a taskpad 
belonging to this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, BOOL bIsExtension>
STDMETHODIMP
CSnapinNode<T, bIsExtension>::EnumTasks(
	IDataObject * /*pDataObject*/,
	BSTR /*szTaskGroup*/,
	IEnumTASK** /*ppEnumTASK*/
	)
{
	ATLTRACENOTIMPL(_T("# CSnapInItemImpl::EnumTasks\n"));
}


#endif // _SNAPIN_NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\srvcsec.cpp ===
// SrvAuthn.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "mqppage.h"
#include "srvcsec.h"

#define DLL_EXPORT  __declspec(dllexport)
#define DLL_IMPORT  __declspec(dllimport)

#include <wincrypt.h>
#include <cryptui.h>
#include "mqcert.h"
#include "uniansi.h"
#include "_registr.h"
#include "mqcast.h"
#include <mqnames.h>
#include <rt.h>
#include <mqcertui.h>
#include "srvcsec.tmh"
#include "globals.h"

#define  MY_STORE	L"My"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CServiceSecurityPage property page

IMPLEMENT_DYNCREATE(CServiceSecurityPage, CMqPropertyPage)

CServiceSecurityPage::CServiceSecurityPage(BOOL fIsDepClient, BOOL fIsDsServer) : 
    CMqPropertyPage(CServiceSecurityPage::IDD),    
    m_fClient(fIsDepClient),
    m_fDSServer(fIsDsServer)
{
	//{{AFX_DATA_INIT(CServiceSecurityPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT    
    m_fModified = FALSE; 
}

CServiceSecurityPage::~CServiceSecurityPage()
{
}

void CServiceSecurityPage::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);    
	//{{AFX_DATA_MAP(CServiceSecurityPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
        DDX_Control(pDX, IDC_CRYPTO_KEYS_FRAME, m_CryptoKeysFrame); 
        DDX_Control(pDX, IDC_SERVER_AUTHENTICATION_FRAME, m_ServerAuthFrame);
        DDX_Control(pDX, ID_RenewCryp, m_RenewCryp);
        DDX_Control(pDX, IDC_SERVER_AUTHENTICATION, m_ServerAuth);
        DDX_Control(pDX, IDC_CRYPTO_KEYS_LABEL, m_CryptoKeysLabel);
        DDX_Control(pDX, IDC_SERVER_AUTHENTICATION_LABEL, m_ServerAuthLabel);
	//}}AFX_DATA_MAP    
}

BOOL CServiceSecurityPage::OnInitDialog()
{
    CMqPropertyPage::OnInitDialog();
  
    if(m_fClient)
    {
        //
        // Hide useless stuff when running on dep. clients
        //
        m_CryptoKeysFrame.ShowWindow(SW_HIDE);        
        m_RenewCryp.ShowWindow(SW_HIDE);
        m_CryptoKeysLabel.ShowWindow(SW_HIDE);        
    }

    if (!m_fDSServer)
    {
        //
        // it will be hidden on non-DC computer
        //
        m_ServerAuthFrame.ShowWindow(SW_HIDE);
        m_ServerAuth.ShowWindow(SW_HIDE);
        m_ServerAuthLabel.ShowWindow(SW_HIDE);
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BEGIN_MESSAGE_MAP(CServiceSecurityPage, CMqPropertyPage)
	//{{AFX_MSG_MAP(CServiceSecurityPage)
	ON_BN_CLICKED(IDC_SERVER_AUTHENTICATION, OnServerAuthentication)
    ON_BN_CLICKED(ID_RenewCryp, OnRenewCryp)    
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServiceSecurityPage message handlers

void CServiceSecurityPage::OnServerAuthentication()
{   
    SelectCertificate() ;
}


#define STORE_NAME_LEN  48
WCHAR  g_wszStore[ STORE_NAME_LEN ] ;
GUID   g_guidDigest ;

void CServiceSecurityPage::SelectCertificate()
{	    
    CString strErrorMsg;
       
    CHCertStore hStoreMy = CertOpenStore( CERT_STORE_PROV_SYSTEM,
                                          0,
                                          0,
                                          CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                          MY_STORE );
    if (!hStoreMy)
    {
        strErrorMsg.LoadString(IDS_FAIL_OPEN_MY) ;        
        AfxMessageBox(strErrorMsg, MB_OK | MB_ICONEXCLAMATION);

        return ;
    }

    HCERTSTORE hStores[]   = { hStoreMy } ;
    LPWSTR wszStores[] = { MY_STORE } ;
    DWORD cStores = TABLE_SIZE(hStores);

    CString strCaption;
    strCaption.LoadString(IDS_SELECT_SRV_CERT) ;
    
	PCCERT_CONTEXT pCertContext = CryptUIDlgSelectCertificateFromStore(
										hStoreMy,
										0,
										strCaption,
										L"",
										CRYPTUI_SELECT_EXPIRATION_COLUMN,
										0,
										NULL
										);
    if (!pCertContext)
    {
        return ;
    }

    R<CMQSigCertificate> pCert = NULL ;
    HRESULT hr = MQSigCreateCertificate( &pCert.ref(),
                                         pCertContext ) ;
    if (FAILED(hr))
    {
        strErrorMsg.LoadString(IDS_FAIL_CERT_OBJ) ;        
        AfxMessageBox(strErrorMsg, MB_OK | MB_ICONEXCLAMATION);

        return ;
    }

    hr = pCert->GetCertDigest( &g_guidDigest) ;
    if (FAILED(hr))
    {
        strErrorMsg.LoadString(IDS_FAIL_CERT_OBJ) ;        
        AfxMessageBox(strErrorMsg, MB_OK | MB_ICONEXCLAMATION);

        return ;
    }

    LPWSTR  lpwszStore = NULL ;
    for ( DWORD j = 0 ; j < cStores ; j++ )
    {
        if ( pCertContext->hCertStore == hStores[j])
        {
            lpwszStore = wszStores[j] ;
            break ;
        }
    }

    if (!lpwszStore)
    {
        strErrorMsg.LoadString(IDS_FAIL_OPEN_MY) ;        
        AfxMessageBox(strErrorMsg, MB_OK | MB_ICONEXCLAMATION);

        return ;
    }

    wcsncpy(g_wszStore, lpwszStore, STORE_NAME_LEN);
    m_fModified = TRUE ;
    
}

BOOL CServiceSecurityPage::OnApply() 
{
    if (!m_fModified || !UpdateData(TRUE))
    {
        return TRUE;     
    }

    //
    // Save changes to registry
    // 

    if (m_fDSServer)
    {
        DWORD dwSize = sizeof(GUID) ;
        DWORD dwType = REG_BINARY ;

        LONG  rc = SetFalconKeyValue( SRVAUTHN_CERT_DIGEST_REGNAME,
                                      &dwType,
                                      &g_guidDigest,
                                      &dwSize );

        dwSize = (numeric_cast<DWORD>(_tcslen(g_wszStore) + 1)) * sizeof(WCHAR) ;
        dwType = REG_SZ ;

        rc = SetFalconKeyValue( SRVAUTHN_STORE_NAME_REGNAME,
                                &dwType,
                                g_wszStore,
                                &dwSize );
    }

    m_fNeedReboot = TRUE;    
    m_fModified = FALSE;        // Reset the m_fModified flag

    return CMqPropertyPage::OnApply();
}

void CServiceSecurityPage::OnRenewCryp()
{
    HRESULT hr;
    CString strCaption;
    CString strErrorMessage;
    
    strCaption.LoadString(IDS_NEW_CRYPT_KEYS_CAPTION);
    strErrorMessage.LoadString(IDS_NEW_CRYPT_KEYS_WARNING);

    if (MessageBox(strErrorMessage,
                   strCaption,
                   MB_YESNO | MB_DEFBUTTON1 | MB_ICONQUESTION) == IDYES)
    {

        CWaitCursor wait;  //display hourglass cursor

        //
        // [adsrv] Update the machine object
        //
        hr = MQSec_StorePubKeysInDS( TRUE,
                                     NULL,
                                     MQDS_MACHINE) ;
        if (FAILED(hr))
        {
            MessageDSError(hr, IDS_RENEW_CRYP_ERROR);
            return;
        }
        else
        {              
              m_fModified = TRUE;
              
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\snpqueue.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	SnpQueue.cpp

Abstract:
	General queue (private, public...) functionality

Author:

    YoelA


--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "shlobj.h"
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "mqPPage.h"
#include "dataobj.h"
#include "mqDsPage.h"
#include "strconv.h"
#include "QGeneral.h"
#include "QMltcast.h"
#include "Qname.h"
#include "rdmsg.h"
#include "icons.h"
#include "generrpg.h"
#include "dsext.h"
#include "qnmsprov.h"
#include "localfld.h"
#include "SnpQueue.h"
#include "ldaputl.h"


#import "mqtrig.tlb" no_namespace
#include "rule.h"
#include "trigger.h"
#include "trigdef.h"
#include "mqcast.h"
#include <adsiutl.h>

#include "snpqueue.tmh"


EXTERN_C BOOL APIENTRY RTIsDependentClient(); //implemented in mqrt.dll


///////////////////////////////////////////////////////////////////////////////////////////
//
// CQueueDataObject
//
CQueueDataObject::CQueueDataObject()
{
}

HRESULT CQueueDataObject::ExtractMsmqPathFromLdapPath(LPWSTR lpwstrLdapPath)
{
    return ExtractQueuePathNameFromLdapName(m_strMsmqPath, lpwstrLdapPath);
}

//
// HandleMultipleObjects
//
HRESULT CQueueDataObject::HandleMultipleObjects(LPDSOBJECTNAMES pDSObj)
{
    return ExtractQueuePathNamesFromDSNames(pDSObj, m_astrQNames, m_astrLdapNames);
}

//
// IShellPropSheetExt
//
STDMETHODIMP CQueueDataObject::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    HPROPSHEETPAGE hPage = 0;
    HRESULT hr = S_OK;

    //
    // Call GetProperties and capture the errors
    //
    {
        CErrorCapture errstr;
        hr = GetProperties();
        if (FAILED(hr))
        {
            hPage = CGeneralErrorPage::CreateGeneralErrorPage(m_pDsNotifier, errstr);
            if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
            {
                ASSERT(0);
                return E_UNEXPECTED;
            }
        return S_OK;
        }
    }

    hPage = CreateGeneralPage();
    if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
    {
        ASSERT(0);
        return E_UNEXPECTED;
    }
   

	//
	// Create Multicast page only for non-transactional queues
	//
	PROPVARIANT propVarTransactional;
	PROPID pid = PROPID_Q_TRANSACTION;
	VERIFY(m_propMap.Lookup(pid, propVarTransactional));

	if ( !propVarTransactional.bVal )
	{
		hPage = CreateMulticastPage();    
		if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
		{
			ASSERT(0);
			return E_UNEXPECTED;
		}
	}

    //
    // Add the "Member Of" page using the cached interface
    //
    if (m_spMemberOfPage != 0)
    {
        VERIFY(SUCCEEDED(m_spMemberOfPage->AddPages(lpfnAddPage, lParam)));
    }

    //
    // Add the "Object" page using the cached interface
    //
    if (m_spObjectPage != 0)
    {
        VERIFY(SUCCEEDED(m_spObjectPage->AddPages(lpfnAddPage, lParam)));
    }
    
    //
    // Add security page
    //
    PROPVARIANT propVarGuid;
    pid = PROPID_Q_INSTANCE;
    VERIFY(m_propMap.Lookup(pid, propVarGuid));

    hr = CreatePublicQueueSecurityPage(
				&hPage, 
				m_strMsmqPath, 
				GetDomainController(m_strDomainController), 
				true,	// fServerName
				propVarGuid.puuid
				);

    if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
    {
        ASSERT(0);
        return E_UNEXPECTED;
    }

    return S_OK;
}

HPROPSHEETPAGE CQueueDataObject::CreateGeneralPage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // By using template class CMqDsPropertyPage, we extend the basic functionality
    // of CQueueGeneral and add DS snap-in notification on release
    //
	CMqDsPropertyPage<CQueueGeneral> *pqpageGeneral = 
        new CMqDsPropertyPage<CQueueGeneral>(m_pDsNotifier);

    if FAILED(pqpageGeneral->InitializeProperties(
									m_strMsmqPath, 
									m_propMap, 
									&m_strDomainController
									))
    {
        delete pqpageGeneral;

        return 0;
    }

	return pqpageGeneral->CreateThemedPropertySheetPage();
}

HPROPSHEETPAGE CQueueDataObject::CreateMulticastPage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // By using template class CMqDsPropertyPage, we extend the basic functionality
    // of CQueueMulticast and add DS snap-in notification on release
    //
	CMqDsPropertyPage<CQueueMulticast> *pqpageMulticast = 
        new CMqDsPropertyPage<CQueueMulticast>(m_pDsNotifier);
    
    if FAILED(pqpageMulticast->InitializeProperties(
									m_strMsmqPath, 
                                    m_propMap,
									&m_strDomainController
									))
    {
        delete pqpageMulticast;

        return 0;
    }   

	return pqpageMulticast->CreateThemedPropertySheetPage();
}

const DWORD CQueueDataObject::GetPropertiesCount()
{
    return mx_dwPropertiesCount;
}

STDMETHODIMP CQueueDataObject::QueryContextMenu(
    HMENU hmenu, 
    UINT indexMenu, 
    UINT idCmdFirst, 
    UINT /*idCmdLast*/, 
    UINT /*uFlags*/)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // If we are not called from "Find" window, users can use the regular "Delete"
    //
    if (!m_fFromFindWindow)
    {
        return 0;
    }

    CString strDeleteQueueMenuEntry;
    strDeleteQueueMenuEntry.LoadString(IDS_DELETE);

    InsertMenu(hmenu,
         indexMenu, 
         MF_BYPOSITION|MF_STRING,
         idCmdFirst + mneDeleteQueue,
         strDeleteQueueMenuEntry);

    return 1;
}

STDMETHODIMP CQueueDataObject::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    switch((INT_PTR)lpici->lpVerb)
    {
        case mneDeleteQueue:
        {
            HRESULT hr;
            CString strDeleteQuestion;
            CString strError;
            CString strErrorMsg;
            CString strMultiErrors;
            DWORD_PTR dwQueuesCount = m_astrQNames.GetSize();
            ASSERT(dwQueuesCount > 0);

            if (dwQueuesCount == 1)
            {
                strDeleteQuestion.FormatMessage(IDS_DELETE_QUESTION, m_strMsmqPath);
            }
            else
            {
                strDeleteQuestion.FormatMessage(IDS_MULTI_DELETE_QUESTION, DWORD_PTR_TO_DWORD(dwQueuesCount));
            }

            if (IDYES != AfxMessageBox(strDeleteQuestion, MB_YESNO))
            {
                break;
            }

            CArray<CString, CString&> astrFormatNames;
            hr = GetFormatNames(astrFormatNames);

            if (FAILED(hr))
            {
                return hr;
            }

            dwQueuesCount = astrFormatNames.GetSize();
            for (DWORD_PTR i=0; i<dwQueuesCount; i++)
            {
                HRESULT hr1 = MQDeleteQueue(astrFormatNames[i]);

                if(FAILED(hr1))
                {
       			    MQErrorToMessageString(strError, hr1);
                    strErrorMsg.FormatMessage(IDS_DELETE_ONE_QUEUE_ERROR, m_astrQNames[i], strError);
                    strMultiErrors += strErrorMsg;

                    hr = hr1;
                }
            }
            if FAILED(hr)
            {
                CString strErrorPrompt;
                strErrorPrompt.FormatMessage(IDS_MULTI_DELETE_ERROR, strMultiErrors);
                AfxMessageBox(strErrorPrompt);
                return hr;
            }

            AfxMessageBox(IDS_QUEUES_DELETED_HIT_REFRESH);
        }
    }

    return S_OK;
}

//
// IDsAdminCreateObj methods
//


STDMETHODIMP CQueueDataObject::Initialize(
                        IADsContainer* pADsContainerObj, 
                        IADs* pADsCopySource,
                        LPCWSTR lpszClassName)
{
    if ((pADsContainerObj == NULL) || (lpszClassName == NULL))
    {
        return E_INVALIDARG;
    }

    //
    // We do not support copy at the moment
    //
    if (pADsCopySource != NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    R<IADs> pIADs;
    hr = pADsContainerObj->QueryInterface(IID_IADs, (void **)&pIADs);
    ASSERT(SUCCEEDED(hr));

    //
    // Get the container distinguish name
    //
    BSTR bstrDN = L"distinguishedName";
    VARIANT var;

    hr = pIADs->Get(bstrDN, &var);
    ASSERT(SUCCEEDED(hr));

	//
    // Extract the machine name
    //
    hr = ExtractComputerMsmqPathNameFromLdapName(m_strComputerName, var.bstrVal);
    ASSERT(SUCCEEDED(hr));

	GetContainerPathAsDisplayString(var.bstrVal, &m_strContainerDispFormat);

    VariantClear(&var);

	//
	// Get Domain Controller name
	// This is neccessary because in this case we call CreateModal()
	// and not the normal path that call CDataObject::Initialize
	// so m_strDomainController is not initialized yet
	//
	BSTR bstr;
 	hr = pIADs->get_ADsPath(&bstr);
    ASSERT(SUCCEEDED(hr));
	hr = ExtractDCFromLdapPath(m_strDomainController, bstr);
	ASSERT(("Failed to Extract DC name", SUCCEEDED(hr)));
	
    return S_OK;
}


HRESULT CQueueDataObject::CreateModal(HWND /*hwndParent*/, IADs** ppADsObj)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	R<CQueueName> pQueueNameDlg = new CQueueName(m_strComputerName, m_strContainerDispFormat);
	CGeneralPropertySheet propertySheet(pQueueNameDlg.get());
	pQueueNameDlg->SetParentPropertySheet(&propertySheet);

	//
	// We want to use pQueueNameDlg data also after DoModal() exitst
	//
	pQueueNameDlg->AddRef();
    INT_PTR iStatus = propertySheet.DoModal();

    if(iStatus == IDCANCEL || FAILED(pQueueNameDlg->GetStatus()))
    {
        //
        // We should return S_FALSE here to instruct the framework to 
        // do nothing. If we return an error code, the framework will 
        // pop up an additional error dialog box.
        //
        return S_FALSE;
    }

    //
    // Get the New object Full path name
    //
    PROPID x_paPropid[] = {PROPID_Q_FULL_PATH};
    PROPVARIANT var[1];
    var[0].vt = VT_NULL;

    HRESULT hr = ADGetObjectProperties(
                    eQUEUE,
                    GetDomainController(m_strDomainController),
					true,	// fServerName
                    pQueueNameDlg->GetNewQueuePathName(),
                    1, 
                    x_paPropid,
                    var
                    );
    if(FAILED(hr))
    {
        //
        // Queue was created, but does not exist in the DS. This is probably 
        // a private queue.
        //
        AfxMessageBox(IDS_CREATED_CLICK_REFRESH);
        return S_FALSE;
    }

    if (SUCCEEDED(hr))
    {
        // 
        // Transfering to LDAP name: Add escape characters and prefix
        //        
        const WCHAR x_wchLimitedChar   = L'/';

        CString strTemp = x_wstrLdapPrefix;
        for (DWORD i =0; i < lstrlen(var[0].pwszVal); i++)
        {
            if (var[0].pwszVal[i] == x_wchLimitedChar)
            {
                strTemp += L'\\';
            }
            strTemp += var[0].pwszVal[i];
        }

        MQFreeMemory(var[0].pwszVal);

	    hr = ADsOpenObject( 
		        (LPWSTR)(LPCWSTR)strTemp,
				NULL,
				NULL,
				ADS_SECURE_AUTHENTICATION,
				IID_IADs,
				(void**) ppADsObj
				);

        if(FAILED(hr))
        {
            AfxMessageBox(IDS_CREATED_WAIT_FOR_REPLICATION);
            return S_FALSE;
        }
    }
    return S_OK;
}


HRESULT CQueueDataObject::EnableQueryWindowFields(HWND hwnd, BOOL fEnable)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    EnableWindow(GetDlgItem(hwnd, IDC_FIND_EDITLABEL), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_FIND_EDITTYPE), fEnable);
    return S_OK;
}

void CQueueDataObject::ClearQueryWindowFields(HWND hwnd)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    SetDlgItemText(hwnd, IDC_FIND_EDITLABEL, TEXT(""));
    SetDlgItemText(hwnd, IDC_FIND_EDITTYPE, TEXT(""));
}


/*---------------------------------------------------------------------------*/
//
// Build a parameter block to pass to the query handler.  Each page is called
// with a pointer to a pointer which it must update with the revised query
// block.   For the first page this pointer is NULL, for subsequent pages
// the pointer is non-zero and the page must append its data into the
// allocation.
//
// Returning either and error or S_FALSE stops the query.   An error is
// reported to the user, S_FALSE stops silently.
//

FindColumns CQueueDataObject::Columns[] =
{
    0, 50, IDS_NAME, TEXT("cn"),
    0, 50, IDS_LABEL, TEXT("mSMQLabelEx"),
    0, 50, IDS_FULL_PATH, TEXT("distinguishedName")
};

HRESULT CQueueDataObject::GetQueryParams(HWND hWnd, LPDSQUERYPARAMS* ppDsQueryParams)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    const LPWSTR x_wstrQueueFilterPrefix = TEXT("(&(objectClass=mSMQQueue)");
    const LPWSTR x_wstrQueueTypeFilterPrefix = TEXT("(mSMQQueueType=");
    const LPWSTR x_wstrQueueLabelFilterPrefix = TEXT("(mSMQLabelEx=");
    const LPWSTR x_wstrDefaultValuePrefix = TEXT("(|(!");
    const LPWSTR x_wstrDefaultValuePostfix = TEXT("*))");
    const LPWSTR x_wstrFilterPostfix = TEXT(")");

    HRESULT hr;
    LPDSQUERYPARAMS pDsQueryParams = 0;
    CString szFilter;
    ULONG offset, cbStruct = 0;
    INT i;
    ADsFree  szOctetGuid;

    //
    // This page doesn't support appending its query data to an
    // existing DSQUERYPARAMS strucuture, only creating a new block,
    // therefore bail if we see the pointer is not NULL.
    //

    if ( *ppDsQueryParams )
    {
        ASSERT(0);
        return E_INVALIDARG;
    }
    szFilter = x_wstrQueueFilterPrefix;

    TCHAR szGuid[MAX_PATH];
    if (0 < GetDlgItemText(hWnd, IDC_FIND_EDITTYPE, szGuid, ARRAYSIZE(szGuid)))
    {
        GUID guid;
        hr = IIDFromString(szGuid, &guid);
        BOOL fDefaultValue = FALSE;
        //
        // GUID_NULL is the default value for type guid.
        // We need special handling for default values, that will catch
        // the case where the attribute is not defined at all, and thus
        // treated as it has the default value
        //
        if (GUID_NULL == guid)
        {
            fDefaultValue = TRUE;
            szFilter += x_wstrDefaultValuePrefix;
            szFilter += x_wstrQueueTypeFilterPrefix;
            szFilter += x_wstrDefaultValuePostfix;
        }

        szFilter += x_wstrQueueTypeFilterPrefix;
        if (FAILED(hr))
        {
            AfxMessageBox(IDE_INVALIDGUID);
            SetActiveWindow(GetDlgItem(hWnd, IDC_FIND_EDITTYPE));
            return hr;
        }

        hr = ADsEncodeBinaryData(
            (unsigned char *)&guid,
            sizeof(GUID),
            &szOctetGuid
            );
        if (FAILED(hr))
        {
            ASSERT(0);
            return hr;
        }

        szFilter += szOctetGuid;
        szFilter += x_wstrFilterPostfix;
        //
        // In case f default, this is an "or" query and needs an additional
        // postfix.
        //
        if (fDefaultValue)
        {
            szFilter += x_wstrFilterPostfix;
        }
    }

    TCHAR szLabel[MAX_PATH];
    if (0 < GetDlgItemText(hWnd, IDC_FIND_EDITLABEL, szLabel, ARRAYSIZE(szGuid)))
    {
        szFilter += x_wstrQueueLabelFilterPrefix;
        szFilter += szLabel;
        szFilter += x_wstrFilterPostfix;
    }

    szFilter += x_wstrFilterPostfix;

    offset = cbStruct = sizeof(DSQUERYPARAMS) + ((ARRAYSIZE(Columns)-1)*sizeof(DSCOLUMN));
   
    cbStruct += numeric_cast<ULONG>(StringByteSize(szFilter));
    for (int iColumn = 0; iColumn<ARRAYSIZE(Columns); iColumn++)
    {
        cbStruct += numeric_cast<ULONG>(StringByteSize(Columns[iColumn].pDisplayProperty));
    }

    //
    // Allocate it and populate it with the data, the header is fixed
    // but the strings are referenced by offset.  StringByteSize and StringByteCopy
    // make handling this considerably easier.
    //

    CCoTaskMemPointer CoTaskMem(cbStruct);

    if ( 0 == (PVOID)CoTaskMem )
    {
        ASSERT(0);
        return E_OUTOFMEMORY;
    }


    pDsQueryParams = (LPDSQUERYPARAMS)(PVOID)CoTaskMem;

    pDsQueryParams->cbStruct = cbStruct;
    pDsQueryParams->dwFlags = 0;
    pDsQueryParams->hInstance = g_hResourceMod;
    pDsQueryParams->offsetQuery = offset;
    pDsQueryParams->iColumns = ARRAYSIZE(Columns);

    //
    // Copy the filter string and bump the offset
    //

    StringByteCopy(pDsQueryParams, offset, szFilter);
    offset += numeric_cast<ULONG>(StringByteSize(szFilter));

    //
    // Fill in the array of columns to dispaly, the cx is a percentage of the
    // current view, the propertie names to display are UNICODE strings and
    // are referenced by offset, therefore we bump the offset as we copy
    // each one.
    //

    for ( i = 0 ; i < ARRAYSIZE(Columns); i++ )
    {
        pDsQueryParams->aColumns[i].fmt = Columns[i].fmt;
        pDsQueryParams->aColumns[i].cx = Columns[i].cx;
        pDsQueryParams->aColumns[i].idsName = Columns[i].uID;
        pDsQueryParams->aColumns[i].offsetProperty = offset;

        StringByteCopy(pDsQueryParams, offset, Columns[i].pDisplayProperty);
        offset += numeric_cast<ULONG>(StringByteSize(Columns[i].pDisplayProperty));
    }
   
    //
    // Success, therefore set the pointer to referenece this parameter
    // block and return S_OK!
    //

    *ppDsQueryParams = pDsQueryParams;
    //
    // Prevent auto-release
    //
    CoTaskMem = (LPVOID)0;


    return S_OK;
}


STDMETHODIMP CQueueDataObject::AddForms(THIS_ LPCQADDFORMSPROC pAddFormsProc, LPARAM lParam)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CQFORM cqf;

    if ( !pAddFormsProc )
        return E_INVALIDARG;

    cqf.cbStruct = sizeof(cqf);
    //
    // Do not display the global pages (advanced search). Also, display
    // this search property pages only if the optional flag is set - that is,
    // only when called from MMC, and not when called from "My Network Place" 
    // in the shell.
    //
    cqf.dwFlags = CQFF_NOGLOBALPAGES | CQFF_ISOPTIONAL;
    cqf.clsid = CLSID_MsmqQueueExt;
    cqf.hIcon = NULL;

    CString strFindTitle;
    strFindTitle.LoadString(IDS_FIND_QUEUE_TITLE);

    cqf.pszTitle = (LPTSTR)(LPCTSTR)strFindTitle;

    return pAddFormsProc(lParam, &cqf);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CQueueDataObject::AddPages(THIS_ LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CQPAGE cqp;

    // AddPages is called after AddForms, it allows us to add the pages for the
    // forms we have registered.  Each page is presented on a seperate tab within
    // the dialog.  A form is a dialog with a DlgProc and a PageProc.  
    //
    // When registering a page the entire structure passed to the callback is copied, 
    // the amount of data to be copied is defined by the cbStruct field, therefore
    // a page implementation can grow this structure to store extra information.   When
    // the page dialog is constructed via CreateDialog the CQPAGE strucuture is passed
    // as the create param.

    if ( !pAddPagesProc )
        return E_INVALIDARG;

    cqp.cbStruct = sizeof(cqp);
    cqp.dwFlags = 0x0;
    cqp.pPageProc = (LPCQPAGEPROC)QueryPageProc;
    cqp.hInstance = AfxGetResourceHandle( );
    cqp.idPageName = IDS_FIND_QUEUE_TITLE;
    cqp.idPageTemplate = IDD_FINDQUEUE;
    cqp.pDlgProc = FindDlgProc;        
    cqp.lParam = (LPARAM)this;

    return pAddPagesProc(lParam, CLSID_MsmqQueueExt, &cqp);
}

HRESULT CQueueDataObject::GetFormatNames(CArray<CString, CString&> &astrFormatNames)
{
    HRESULT hr;

    const DWORD x_dwInitFormatnameLen = 128;
    DWORD dwFormatNameLen = x_dwInitFormatnameLen;
    BOOL fFailedOnce = FALSE;
    CString strFormatName;

    for (int i=0; i<m_astrQNames.GetSize(); i++)
    {
        do
        {
            //
            // Loop at most twice to get the right buffer length
            //
            hr = MQPathNameToFormatName(m_astrQNames[i], strFormatName.GetBuffer(dwFormatNameLen), 
                                        &dwFormatNameLen);
            strFormatName.ReleaseBuffer();
            if (MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL == hr)
            {
                if (fFailedOnce)
                {
                    ASSERT(0);
                    break;
                }
                fFailedOnce = TRUE;;

                //
                // At this stage, dwFormatNameLen contains the right value. We can simply re-do the procedure
                //
                continue;
            }
        } while (FALSE);

        if (FAILED(hr))
        {
            //
            // If the queue was not found using MSMQ DS APIs, it is probably because of
            // replication delays between the DC that MSMQ is using and the DC that the
            // DS snap-in is using. Either the queue was created in the later and was 
            // not replicated to the former, or the queue was already deleted in the former,
            // and the deletion was not replicated to the later. (YoelA, 29-Jun-98).
            //
            IF_NOTFOUND_REPORT_ERROR(hr)
            else
            {
                MessageDSError(hr, IDS_OP_GETFORMATNAME, m_strMsmqPath);
            }
            return hr;
        }
        astrFormatNames.Add(strFormatName);
    }
    return S_OK;
}

//
// IDsAdminNotifyHandler
//
STDMETHODIMP
CQueueDataObject::Initialize(
	IDataObject* /*pExtraInfo*/,
    ULONG* puEventFlags
    )
{
  if (puEventFlags == NULL)
    return E_INVALIDARG;

  *puEventFlags = DSA_NOTIFY_DEL;
  return S_OK;
}

STDMETHODIMP CQueueDataObject::Begin(THIS_ /*IN*/ ULONG uEvent,
                 /*IN*/ IDataObject* pArg1,
             /*IN*/ IDataObject* /*pArg2*/,
                 /*OUT*/ ULONG* puFlags,
                 /*OUT*/ BSTR* pBstr)
{
	//
    //  This routine handles delete-notification of queue and
    //  msmq-configuration objects.
    //

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT (uEvent & DSA_NOTIFY_DEL);
	UNREFERENCED_PARAMETER(uEvent);

    if (pBstr != NULL)
    {
        *pBstr = NULL;
    }
    *puFlags = 0;

    HRESULT hr =  ExtractPathNamesFromDataObject(
                                pArg1,
                                m_astrQNames,
                                m_astrLdapNames,
                                TRUE    // fExtractAlsoComputerMsmqObjects
                                );

    if FAILED(hr)
    {
        CString szError;
        MQErrorToMessageString(szError, hr);
        TRACE(_T("CQueueDataObject::Begin: Could not Extract queue pathname from data object. Error %X - %s\n"),
              hr, szError);
        ASSERT(0);
        return hr;
    }
    DWORD_PTR dwNumQueues = m_astrQNames.GetSize();

    if (dwNumQueues == 0) // No queues in the list
    {
        //
        // Don't do anything - simply return S_OK for non-queues
        //
        return S_OK;
    }

	//
	// Get Domain Controller name
	// This is neccessary because in this case we call Begin()
	// and not the normal path that call CDataObject::Initialize
	// so m_strDomainController is not initialized yet
	//
	hr = ExtractDCFromLdapPath(m_strDomainController, m_astrLdapNames[0]);
	ASSERT(("Failed to Extract DC name", SUCCEEDED(hr)));

    for (DWORD_PTR i=0; i<dwNumQueues; i++)
    {
		HANDLE hNotifyEnum; 
        //
        // it may be msmq object too, so check if there is delimiter in m_astrQNames[i]
        // if there is "\" it means that it is queue object
        // otherwise msmq object
        //
        int iSlash = m_astrQNames[i].Find(L'\\');

        if ( iSlash != -1 )
        {
            //
            // it is queue object
            //
            hr = ADBeginDeleteNotification(
                    eQUEUE,
                    GetDomainController(m_strDomainController),
					true,	// fServerName
                    m_astrQNames[i],
                    &hNotifyEnum
                    );            
        }
        else
        {
            //
            // it was only computer name
            //
            hr = ADBeginDeleteNotification(
                    eMACHINE,
                    GetDomainController(m_strDomainController),
					true,	// fServerName
                    m_astrQNames[i],
                    &hNotifyEnum
                    );
        }       

        if (hr == MQ_INFORMATION_QUEUE_OWNED_BY_NT4_PSC && *pBstr == NULL)
        {
            CString strNt4Object;
            strNt4Object.LoadString(IDS_QUEUES_BELONG_TO_NT4);
            *pBstr = strNt4Object.AllocSysString();
            *puFlags = DSA_NOTIFY_FLAG_ADDITIONAL_DATA | DSA_NOTIFY_FLAG_FORCE_ADDITIONAL_DATA;
        }
        if (hr == MQ_INFORMATION_MACHINE_OWNED_BY_NT4_PSC && *pBstr == NULL)
        {
            CString strNt4Object;
            strNt4Object.LoadString(IDS_MACHINE_BELONG_TO_NT4);
            *pBstr = strNt4Object.AllocSysString();
            *puFlags = DSA_NOTIFY_FLAG_ADDITIONAL_DATA | DSA_NOTIFY_FLAG_FORCE_ADDITIONAL_DATA;
        }
        else if FAILED(hr)
        {
            CString szError;
            MQErrorToMessageString(szError, hr);
            TRACE(_T("CQueueDataObject::Begin: DSBeginDeleteNotification failed. Error %X - %s\n"), 
                  hr, szError);
            hNotifyEnum = 0;
        }
        m_ahNotifyEnums.Add(hNotifyEnum);
    }

    m_astrQNames.RemoveAll();

    return S_OK;
}

STDMETHODIMP CQueueDataObject::Notify(THIS_ /*IN*/ ULONG /*nItem*/, /*IN*/ ULONG /*uFlags*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CQueueDataObject::End(THIS_) 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    DWORD_PTR dwNumQueues = m_ahNotifyEnums.GetSize();
    for (DWORD_PTR i=0; i<dwNumQueues; i++)
    {
        if (m_ahNotifyEnums[i])
        {
            IADs* pADsObj;
		
			AP<WCHAR> pEscapeAdsPathNameToFree;
	
		    HRESULT hr = ADsOpenObject( 
									UtlEscapeAdsPathName(m_astrLdapNames[i], pEscapeAdsPathNameToFree),
									NULL,
									NULL,
									ADS_SECURE_AUTHENTICATION,
									IID_IADs,
									(void**) &pADsObj
									);
		
            if FAILED(hr)
            {
                //
                // If we get that error, the object was deleted. Otherwise,
                // we have problems accessing the DS server
                //
                if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
                {                    
                    hr = ADNotifyDelete(
                            m_ahNotifyEnums[i]
                            );
                    if (hr == MQ_ERROR_WRITE_REQUEST_FAILED)
                    {
                        AfxMessageBox(IDS_WRITE_REQUEST_FAILED);
                    }
                }
                else
                {
                    //
                    // Some unexpected error
                    //
                    ASSERT(0);
                }
            }
            else
            {
                pADsObj->Release();
            }
            
            hr = ADEndDeleteNotification(
                    m_ahNotifyEnums[i]
                    );

            m_ahNotifyEnums[i] = 0;
        }
    }
    m_ahNotifyEnums.RemoveAll();
    m_astrLdapNames.RemoveAll();
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\srvcsec.h ===
#if !defined(AFX_SRVAUTHN_H__F30DC8B3_05A1_11D2_B964_0060081E87F0__INCLUDED_)
#define AFX_SRVAUTHN_H__F30DC8B3_05A1_11D2_B964_0060081E87F0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// srvcsec. : header file
//

#include <mqcacert.h>

/////////////////////////////////////////////////////////////////////////////
// CServiceSecurityPage dialog

class CServiceSecurityPage : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CServiceSecurityPage)

// Construction
public:
	CServiceSecurityPage(BOOL fIsDepClient = FALSE, BOOL fIsDsServer = FALSE);
	~CServiceSecurityPage();

// Dialog Data
	//{{AFX_DATA(CServiceSecurityPage)
	enum { IDD = IDD_SERVICE_SECURITY };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
    CButton m_CryptoKeysFrame;
    CButton m_RenewCryp;
    CButton m_ServerAuthFrame; 
    CButton m_ServerAuth;
    CStatic m_CryptoKeysLabel;
    CStatic m_ServerAuthLabel;
	//}}AFX_DATA  

    BOOL m_fClient;  
    BOOL m_fDSServer;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CServiceSecurityPage)
    public:
    virtual BOOL OnApply();
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CServiceSecurityPage)
	afx_msg void OnServerAuthentication();
    afx_msg void OnRenewCryp();    
    virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    void SelectCertificate() ;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SRVAUTHN_H__F30DC8B3_05A1_11D2_B964_0060081E87F0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once

#if !defined(AFX_STDAFX_H__74E56371_B98C_11D1_9B9B_00E02C064C39__INCLUDED_)
#define AFX_STDAFX_H__74E56371_B98C_11D1_9B9B_00E02C064C39__INCLUDED_


#include "_stdafx.h"

#pragma warning(push, 3)

#include <afxcmn.h>
#include <iostream>
#include <lim.h>

#pragma warning(pop)
 

#include "cmnquery.h"
#include "dsquery.h"

#include "mqsymbls.h"
#include "mqprops.h"
#include "mqtypes.h"
#include "mqcrypt.h"
#include "mqsec.h"
#include "_propvar.h"
#include "ad.h"
#include "_rstrct.h"
#include "_mqdef.h"
#include "rt.h"
#include "_guid.h"
#include "admcomnd.h"

#pragma warning(disable: 4201)
#include "mmc.h"

#include "shlobj.h"
#include "dsclient.h"
#include "dsadmin.h"

#include "automqfr.h"

#include "winsock2.h"
#include "autohandle.h"



#include <afxwin.h>
#include <afxdisp.h>
#include <afxdlgs.h>
#include <afxtempl.h>


#define _ATL_APARTMENT_THREADED
#define _ATL_NO_DEBUG_CRT
#define ATLASSERT ASSERT

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

#pragma warning(disable: 4267)
#include <comdef.h>
#pragma warning(default: 4267)

#include <autoptr.h>

//
// ISSUE-2000/12/19-urih: duplicate decleration. Need to be removed and using decleration form mm.h
//
// mqsnap working in mix enviroment, it uses include files from lib\inc while it isn't using
// mqenv.h. This cause a conflict. For now I declared MmIsStaticAddress	here instead include
// mm.h, but we need to change snap-in to use MSMQ enviroment.
//
inline bool
MmIsStaticAddress(
    const void* /*Address*/
    )
{
	return true;
}

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_STDAFX_H__74E56371_B98C_11D1_9B9B_00E02C064C39__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\storage.cpp ===
// Storage.cpp : implementation file
//
#include "stdafx.h"
#include <winreg.h>
#include "mqsnap.h"
#include "resource.h"
#include "globals.h"
#include "mqppage.h"
#include "_registr.h"
#include "localutl.h"
#include "Storage.h"
#include "infodlg.h"
#include "mqsnhlps.h"
#include "mqcast.h"

#include "storage.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Verify that an edit control is a directory
//
static
void 
DDV_IsDirectory(
	CDataExchange* pDX, 
	int Id, 
	LPCTSTR szDir)
{
	if(IsDirectory(szDir))
	{
		return;
	}

	//
	// If this is not a directory IsDirectory() already displayed
	// a corresponding error mesage.
    // Set the focus on the edit control
    //
    pDX->PrepareEditCtrl(Id);

    //
    // And fail the validation
    //
    pDX->Fail();
}


/////////////////////////////////////////////////////////////////////////////
// CStoragePage property page

IMPLEMENT_DYNCREATE(CStoragePage, CMqPropertyPage)

CStoragePage::CStoragePage() : CMqPropertyPage(CStoragePage::IDD)
{
    HRESULT rc;
    DWORD dwSize;
    DWORD dwType = REG_SZ;
	TCHAR szTemp[1000];
	TCHAR szRegName[1000];
	

	//
	// Get Message Files Folder
	//
	_tcscpy(szRegName, MSMQ_STORE_PERSISTENT_PATH_REGNAME);

    dwSize = sizeof(szTemp);
    rc = GetFalconKeyValue(szRegName,&dwType,szTemp,&dwSize);

    if (rc != ERROR_SUCCESS)
    {
        DisplayFailDialog();
        return;
    }

	m_OldMsgFilesDir = szTemp;


	//
	// Get Message Logger Folder
	//
	_tcscpy(szRegName,MSMQ_STORE_LOG_PATH_REGNAME);

    dwSize = sizeof(szTemp);
    rc = GetFalconKeyValue(szRegName,&dwType,szTemp,&dwSize);

    if (rc != ERROR_SUCCESS)
    {
        DisplayFailDialog();
        return;
    }

	m_OldMsgLoggerDir = szTemp;


	//
	// Get Transaction Logger Folder
	//
	_tcscpy(szRegName,FALCON_XACTFILE_PATH_REGNAME);

    dwSize = sizeof(szTemp);
    rc = GetFalconKeyValue(szRegName,&dwType,szTemp,&dwSize);
    if (rc != ERROR_SUCCESS)
    {
        DisplayFailDialog();
        return;
    }

	m_OldTxLoggerDir = szTemp;

    //{{AFX_DATA_INIT(CStoragePage)
    m_MsgFilesDir = m_OldMsgFilesDir;
    m_MsgLoggerDir = m_OldMsgLoggerDir;
    m_TxLoggerDir = m_OldTxLoggerDir;
    //}}AFX_DATA_INIT
}

CStoragePage::~CStoragePage()
{
}


void CStoragePage::DoDataExchange(CDataExchange* pDX)
{    
    CMqPropertyPage::DoDataExchange(pDX);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //{{AFX_DATA_MAP(CStoragePage)
    DDX_Text(pDX, ID_MessageFiles, m_MsgFilesDir);
	DDV_NotEmpty(pDX, m_MsgFilesDir, IDS_MISSING_MSGFILES_FOLDER);
	DDV_MaxChars(pDX, m_MsgFilesDir, xMaxStorageDirLength);

    DDX_Text(pDX, ID_MessageLogger, m_MsgLoggerDir);
	DDV_NotEmpty(pDX, m_MsgLoggerDir, IDS_MISSING_LOGGER_FOLDER);
	DDV_MaxChars(pDX, m_MsgLoggerDir, xMaxStorageDirLength);

    DDX_Text(pDX, ID_TransactionLogger, m_TxLoggerDir);
	DDV_NotEmpty(pDX, m_TxLoggerDir, IDS_MISSING_TX_LOGGER_FOLDER);
	DDV_MaxChars(pDX, m_TxLoggerDir, xMaxStorageDirLength);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        //
        // Identify changes in directory names. For each directory name that
        // had changed, verify that it is a valid directory and create it if
        // neccessary. The check should be done only once per directory name.
        // This is because we warn about the security of the directroy and
        // we do not want to warn more than once per directory.
        //

        if (_tcsicmp(m_MsgFilesDir, m_OldMsgFilesDir) != 0)
        {
            DDV_IsDirectory(pDX, ID_MessageFiles, m_MsgFilesDir);
            m_fModified = TRUE;
        }

        if (_tcsicmp(m_MsgLoggerDir, m_OldMsgLoggerDir) != 0)
        {
            if (m_MsgLoggerDir != m_MsgFilesDir)
            {
                DDV_IsDirectory(pDX, ID_MessageLogger, m_MsgLoggerDir);
            }
            
			m_fModified = TRUE;
        }

        if (_tcsicmp(m_TxLoggerDir, m_OldTxLoggerDir) != 0)
        {
			BOOL fCheckedTxDir = (m_TxLoggerDir == m_MsgFilesDir || m_TxLoggerDir == m_MsgLoggerDir);

            if (!fCheckedTxDir)
            {
                DDV_IsDirectory(pDX, ID_TransactionLogger, m_TxLoggerDir);
            }
            
			m_fModified = TRUE;
        }      
    }
}


BOOL CStoragePage::MoveFilesToNewFolders()
{
    //
    // Get the current persistent storage directory and compare it with the new
    // directory. Only if the directories are different, we try to move the files.
    // Otherwise we will end up with an error becasue we try to move the files over
    // them selves.
    //
	TCHAR szPrevDir[MAX_PATH];
	DWORD dwType = REG_SZ;
    DWORD dwSize = sizeof(szPrevDir);
    
	HRESULT rc = GetFalconKeyValue(MSMQ_STORE_PERSISTENT_PATH_REGNAME,&dwType,szPrevDir,&dwSize);

	TCHAR szNewDir[MAX_PATH];
	_tcscpy(szNewDir,m_MsgFilesDir);
	
    if (_tcscmp(szPrevDir, szNewDir) != 0)
    {
		TCHAR szPrevLQSDir[MAX_PATH];
        TCHAR wszNewLQSDir[MAX_PATH];
        TCHAR szNewLQSDir[MAX_PATH];

        //
        // The LQS moves together with the persistent storage. So first find
        // the source and edstination LQS directories. Try to create the
        // destination LQS directory.
        //

		_tcscat(_tcscpy(szPrevLQSDir, szPrevDir), TEXT("\\LQS"));
        _tcscat(_tcscpy(wszNewLQSDir, szNewDir), TEXT("\\LQS"));

		_tcscpy(szNewLQSDir,wszNewLQSDir);

		if (CreateDirectory(szNewLQSDir, NULL))
        {
            if (!SetDirectorySecurity(szNewLQSDir))
            {
       			CString strMessage;
                CString strError;

                RemoveDirectory(szNewLQSDir);

                GetLastErrorText(strError);
                strMessage.FormatMessage(IDS_SET_DIR_SECURITY_ERROR, szNewLQSDir, (LPCTSTR)strError);
                AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);

                return FALSE;                    
            }
        }
        else if (GetLastError() != ERROR_ALREADY_EXISTS)
        {
            //
            // Failed to create the destination LQS directory.
            //
            CString strMessage;
            CString strError;

            GetLastErrorText(strError);
            strMessage.FormatMessage(IDS_FAILED_TO_CREATE_LQS_DIR, (LPCTSTR)strError);            
            AfxMessageBox(strMessage, MB_OK | MB_ICONEXCLAMATION);

            return FALSE;                
        }

        //
        // Move the persistent messages.
        //
        if (!MoveFiles(szPrevDir, szNewDir, TEXT("p*.mq")))
        {
            return FALSE;                
        }

        //
        // Move the LQS files.
        //
        if (!MoveFiles(szPrevLQSDir, wszNewLQSDir, TEXT("*.*")))
        {
            //
            // Faield to copy the LQS files, replace the persistent messages in the
            // original directory.
            //
            MoveFiles(szNewDir, szPrevDir, TEXT("p*.mq"), TRUE);
            return FALSE;                
        }

        //
        // Update the registry.
        //
        dwSize = (numeric_cast<DWORD>(_tcslen(szNewDir) + 1)) * sizeof(TCHAR);

        rc = SetFalconKeyValue(MSMQ_STORE_PERSISTENT_PATH_REGNAME,&dwType,szNewDir,&dwSize);
        ASSERT(rc == ERROR_SUCCESS);
    }

    //
    // Similar operations for the journal messages.
    //
    dwSize = sizeof(szPrevDir);
    rc = GetFalconKeyValue(MSMQ_STORE_JOURNAL_PATH_REGNAME,&dwType,szPrevDir,&dwSize);

    if (_tcscmp(szPrevDir, szNewDir) != 0)
    {
        if (!MoveFiles(szPrevDir, szNewDir, TEXT("j*.mq")))
        {
            //
            // Failed to move the files, do not update the registry.
            //
            return FALSE;                
        }

        //
        // Update the registry.
        //
        dwSize = (numeric_cast<DWORD>(_tcslen(szNewDir) + 1)) * sizeof(TCHAR);

        rc = SetFalconKeyValue(MSMQ_STORE_JOURNAL_PATH_REGNAME,&dwType,szNewDir,&dwSize);
		ASSERT(rc == ERROR_SUCCESS);
    }

    //
    // Similar operations for the reliable messages.
    //
    dwSize = sizeof(szPrevDir);
    rc = GetFalconKeyValue(MSMQ_STORE_RELIABLE_PATH_REGNAME,&dwType,szPrevDir,&dwSize);

    if (_tcscmp(szPrevDir, szNewDir) != 0)
    {
        if (!MoveFiles(szPrevDir, szNewDir, TEXT("r*.mq")))
        {
            //
            // Failed to move the files, do not update the registry.
            //
            return FALSE;                
        }

        //
        // Update the registry.
        //
        dwSize = (numeric_cast<DWORD>(_tcslen(szNewDir) + 1)) * sizeof(TCHAR);

        rc = SetFalconKeyValue(MSMQ_STORE_RELIABLE_PATH_REGNAME,&dwType,szNewDir,&dwSize);
        ASSERT(rc == ERROR_SUCCESS);
    }

    //
    // Similar operations for the message log files.
    //
    dwSize = sizeof(szPrevDir);
    rc = GetFalconKeyValue(MSMQ_STORE_LOG_PATH_REGNAME,&dwType,szPrevDir,&dwSize);

	_tcscpy(szNewDir, m_MsgLoggerDir);
    
    if (_tcscmp(szPrevDir, szNewDir) != 0)
    {
        if (!MoveFiles(szPrevDir, szNewDir, TEXT("l*.mq")))
        {
            //
            // Failed to move the files, do not update the registry.
            //
            return FALSE;                
        }

        //
        // Update the registry.
        //
        dwSize =(numeric_cast<DWORD>( _tcslen(szNewDir) + 1)) * sizeof(TCHAR);

        rc = SetFalconKeyValue(MSMQ_STORE_LOG_PATH_REGNAME,&dwType,szNewDir,&dwSize);
        ASSERT(rc == ERROR_SUCCESS);
    }

    //
    // Similar operations for the transaction files.
    //
    dwSize = sizeof(szPrevDir);
    rc = GetFalconKeyValue(FALCON_XACTFILE_PATH_REGNAME,&dwType,szPrevDir,&dwSize);

	_tcscpy(szNewDir, m_TxLoggerDir);

    if (_tcscmp(szPrevDir, szNewDir) != 0)
    {
        //
        // move the *.lg1 files.
        // 
        if (!MoveFiles(szPrevDir, szNewDir, TEXT("*.lg1")))
        {
            //
            // Failed to move the files, do not update the registry.
            //
            return FALSE;                
        }

        //
        // move the *.lg2 files.
        //
        if (!MoveFiles(szPrevDir, szNewDir, TEXT("*.lg2")))
        {
            //
            // Faield to move the *.lg2 files. Replace the *.lg1 files in the
            // original source directory and do not update the registry.
            //
            MoveFiles(szNewDir, szPrevDir, TEXT("*.lg1"), TRUE);
            return FALSE;                
        }

        //
        // Move the QMLog file
        //
        if (!MoveFiles(szPrevDir, szNewDir, TEXT("QMLog")))
        {
            //
            // Faield to move the QMLog file. Replace the *.lg1 and *.lg2 files
            // in the original source directory and do not update the registry.
            //
            MoveFiles(szNewDir, szPrevDir, TEXT("*.lg1"), TRUE);
            MoveFiles(szNewDir, szPrevDir, TEXT("*.lg2"), TRUE);
            return FALSE;                
        }

        //
        // Update the registry.
        //
        dwSize = (numeric_cast<DWORD>(_tcslen(szNewDir) +1 )) * sizeof(TCHAR);

        rc = SetFalconKeyValue(FALCON_XACTFILE_PATH_REGNAME,&dwType,szNewDir,&dwSize);
        ASSERT(rc == ERROR_SUCCESS);
    }
	
	return TRUE;
}


BOOL CStoragePage::OnApply() 
{

    if (!m_fModified)
    {
        return TRUE;     
    }

	//
	// This function will check MSMQ service state, ask the user
	// whether to stop it, and stop the service. Error messages inside.
	//
	BOOL fServiceWasRunning;
	if (!TryStopMSMQServiceIfStarted(&fServiceWasRunning, this))
	{
		return FALSE;
	}

    CString strMovingFiles;
    strMovingFiles.LoadString(IDS_MOVING_FILES);

    {
		CInfoDlg CopyFilesDlg(strMovingFiles, this);

		BOOL fRes = MoveFilesToNewFolders();

		if (!fRes)
		{
			return FALSE;
		}
    }

	if (fServiceWasRunning)
	{
		m_fNeedReboot = TRUE;
	}

	//
	// Update old values
	//
	m_OldMsgFilesDir = m_MsgFilesDir;
	m_OldMsgLoggerDir = m_MsgLoggerDir;
	m_OldTxLoggerDir = m_TxLoggerDir;

	m_fModified = FALSE;

    return CMqPropertyPage::OnApply();
}

BEGIN_MESSAGE_MAP(CStoragePage, CMqPropertyPage)
    //{{AFX_MSG_MAP(CStoragePage)  
    ON_EN_CHANGE(ID_MessageFiles, OnChangeRWField)
    ON_EN_CHANGE(ID_MessageLogger, OnChangeRWField)
    ON_EN_CHANGE(ID_TransactionLogger, OnChangeRWField)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStoragePage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\strconv.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    strconv.h

Abstract:

    String conversion functions. This module contains conversion functions of
    MSMQ codes to strings - for display

Author:

    Yoel Arnon (yoela)

--*/

#ifndef _STRCONV_H_
#define _STRCONV_H_

#define DEFINE_CONVERSION_FUNCTION(fName) LPTSTR fName(DWORD dwCode);

DEFINE_CONVERSION_FUNCTION(PrivacyToString)

LPTSTR MsmqServiceToString(BOOL fRout, BOOL fDepCl, BOOL fForeign);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\strconv.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    strconv.cpp

Abstract:

    String conversion functions. This module contains conversion functions of
    MSMQ codes to strings - for display

Author:

    Yoel Arnon (yoela)

--*/
#include "stdafx.h"
#include "mqsnap.h"
#include "mqsymbls.h"
#include "mqprops.h"
#include "resource.h"
#include "dataobj.h"
#include "globals.h"
#include "strconv.h"

#include "strconv.tmh"

//
// Max display length - this is the maximum number of characters we will display anywhere
//
static const DWORD x_dwMaxDisplayLen = 256;
struct StringIdMap 
{
    DWORD dwCode;
    UINT  uiStrId;
};

#define BEGIN_CONVERSION_FUNCTION(fName) \
LPTSTR fName(DWORD dwCode) \
{ \
    static StringIdMap l_astrIdMap[] = { 

#define STRING_CONV_ENTRY(Code) \
        {Code, IDS_ ## Code},

#define END_CONVERSION_FUNCTION \
    }; \
    static const  DWORD x_dwMapSize = sizeof(l_astrIdMap) / sizeof(l_astrIdMap[0]); \
    static BOOL l_fFirstTime = TRUE; \
    static TCHAR l_atstrResults[x_dwMapSize][x_dwMaxDisplayLen]; \
    return CodeToString(dwCode, l_atstrResults, l_astrIdMap, \
                        x_dwMapSize, &l_fFirstTime); \
}


LPTSTR CodeToString (
    DWORD dwCode,
    TCHAR atstrResults[][x_dwMaxDisplayLen], 
    const StringIdMap astrIdMap[],
    DWORD dwMapSize,
    BOOL *fFirstTime)
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState()); 
    if (*fFirstTime)
    {
        *fFirstTime = FALSE;
        for (DWORD i = 0; i<dwMapSize; i++)
        { 
            DWORD nChars = 
				::LoadString(g_hResourceMod, astrIdMap[i].uiStrId, 
					         atstrResults[i], x_dwMaxDisplayLen);
            if (0 == nChars) 
            {
				#ifdef _DEBUG
					HRESULT hr = GetLastError();
				#endif
				ASSERT(0);
                atstrResults[i][0] = 0;
            }
        }
    }
    for (DWORD i=0; i < dwMapSize; i++)
    { 
        if (astrIdMap[i].dwCode == dwCode) 
        {
            return atstrResults[i]; 
        } 
    } 
    return TEXT("");
}

BEGIN_CONVERSION_FUNCTION(PrivacyToString)
    STRING_CONV_ENTRY(MQ_PRIV_LEVEL_NONE)
    STRING_CONV_ENTRY(MQ_PRIV_LEVEL_OPTIONAL)
    STRING_CONV_ENTRY(MQ_PRIV_LEVEL_BODY)
END_CONVERSION_FUNCTION


//---------------------------------------------------------
//
//  Get a string describing the service type
//
//---------------------------------------------------------
//
// Service codes - internal for the snapin
//
enum MsmqServiceCodes
{
    MQSRV_ROUTING_SERVER,
    MQSRV_SERVER,
    MQSRV_FOREIGN_WORKSTATION,
    MQSRV_INDEPENDENT_CLIENT
};

BEGIN_CONVERSION_FUNCTION(MsmqInternalSeriveToString)
    STRING_CONV_ENTRY(MQSRV_ROUTING_SERVER)
    STRING_CONV_ENTRY(MQSRV_SERVER)
    STRING_CONV_ENTRY(MQSRV_FOREIGN_WORKSTATION)
    STRING_CONV_ENTRY(MQSRV_INDEPENDENT_CLIENT)
END_CONVERSION_FUNCTION


LPTSTR MsmqServiceToString(BOOL fRout, BOOL fDepCl, BOOL fForeign)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Routing server
    //
    if (fRout)
    {
        return MsmqInternalSeriveToString(MQSRV_ROUTING_SERVER);
    }

    //
    // MSMQ server (no routing)
    //
    if (fDepCl)
    {
        return MsmqInternalSeriveToString(MQSRV_SERVER);
    }

    //
    // Foreign client
    //
	if ( fForeign)
	{
		return MsmqInternalSeriveToString(MQSRV_FOREIGN_WORKSTATION);
	}


    //
    // Independent client
    //
	return MsmqInternalSeriveToString(MQSRV_INDEPENDENT_CLIENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\sysq.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	sysq.h

Abstract:

	Definition for the computer extension snapnin node class.

Author:

    RaphiR

--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef __SYSQ_H_
#define __SYSQ_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "rdmsg.h"

#include "icons.h"

/****************************************************

        CPrivateFolder Class
    
 ****************************************************/
class CPrivateFolder : public CNodeWithScopeChildrenList<CPrivateFolder, FALSE>
{
public:
	GUID                    m_guidId;           // Guid of the computer
	CString                 m_pwszGuid;         // Ditto - but as a string
	CString					m_szMachineName;

   	BEGIN_SNAPINCOMMAND_MAP(CPrivateFolder, FALSE)
	END_SNAPINCOMMAND_MAP()

    CPrivateFolder(CSnapInItem * pParentNode, CSnapin * pComponentData, CString strMachineName) : 
		CNodeWithScopeChildrenList<CPrivateFolder, FALSE>(pParentNode, pComponentData),
		m_szMachineName(strMachineName)
    {
        SetIcons(IMAGE_PRIVATE_FOLDER_CLOSE, IMAGE_PRIVATE_FOLDER_OPEN);
    }

	~CPrivateFolder()
	{
	}

    virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );

  	virtual HRESULT OnUnSelect( IHeaderCtrl* pHeaderCtrl );

	virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

private:
    static GUID m_LocalQmGUID;
    static bool m_fLocalQmGUIDInitialized;

    bool IsMyMachine();
};


/****************************************************

        CSystemQueues Class
    
 ****************************************************/
class CSystemQueues : public CNodeWithScopeChildrenList<CSystemQueues, FALSE>
{
public:
	GUID                    m_guidId;           // Guid of the computer
	CString                 m_pwszGuid;         // Ditto - but as a string

   	BEGIN_SNAPINCOMMAND_MAP(CSystemQueues, FALSE)
	END_SNAPINCOMMAND_MAP()

    CSystemQueues(CSnapInItem * pParentNode, CSnapin * pComponentData, CString &pwszComputerName) : 
        CNodeWithScopeChildrenList<CSystemQueues, FALSE>(pParentNode, pComponentData)
    {
        m_guidId = GUID_NULL;
        m_pwszGuid = L"";

        if(pwszComputerName == L"")
        {
            HRESULT hr = GetComputerNameIntoString(m_pwszComputerName);
            if FAILED(hr)
            {
                ASSERT(0);
                m_pwszComputerName = L"" ;
            }
        }
        else
        {
            m_pwszComputerName = pwszComputerName;
        }
        SetIcons(IMAGE_SYSTEM_FOLDER_CLOSE, IMAGE_SYSTEM_FOLDER_OPEN);
    }

	~CSystemQueues()
	{
	}

	virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );

  	virtual HRESULT OnUnSelect( IHeaderCtrl* pHeaderCtrl );

	virtual HRESULT PopulateScopeChildrenList();

private:

	virtual CString GetHelpLink();

protected:
	CString m_pwszComputerName;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\sysq.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	sysq.cpp

Abstract:


Author:

    RaphiR, YoelA


--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include "mqsnap.h"
#include "globals.h"
#include "sysq.h"
#include "snapin.h"
#include "rdmsg.h"
#include "rt.h"
#include "dsext.h"
#include "qnmsprov.h"
#include "localfld.h"
#include "localq.h"
#include "SnpQueue.h"
#include "admmsg.h"

#include "mqutil.h"

#include "sysq.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/****************************************************

        CPrivateFolder Class
    
 ****************************************************/
/////////////////////////////////////////////////////////////////////////////
// CPrivateFolder
// {3F965592-CF62-11d1-9B9D-00E02C064C39}
static const GUID CPrivateFolderGUID_NODETYPE = 
{ 0x3f965592, 0xcf62, 0x11d1, { 0x9b, 0x9d, 0x0, 0xe0, 0x2c, 0x6, 0x4c, 0x39 } };

const GUID*  CPrivateFolder::m_NODETYPE = &CPrivateFolderGUID_NODETYPE;
const OLECHAR* CPrivateFolder::m_SZNODETYPE = OLESTR("3F965592-CF62-11d1-9B9D-00E02C064C39");
const OLECHAR* CPrivateFolder::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CPrivateFolder::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;

//////////////////////////////////////////////////////////////////////////////
/*++

CPrivateFolder::IsMyMachine
Returns true if this is my machine - providing m_guidId was initialized
--*/
//////////////////////////////////////////////////////////////////////////////
bool CPrivateFolder::m_fLocalQmGUIDInitialized = false;
GUID CPrivateFolder::m_LocalQmGUID = GUID_NULL;

bool CPrivateFolder::IsMyMachine()
{
    if (!m_fLocalQmGUIDInitialized)
    {
        //
        // Get the current machine GUID from the registry
        //
	    DWORD dwValueType = REG_BINARY ;
	    DWORD dwValueSize = sizeof(GUID);
	    LONG rc = GetFalconKeyValue(
						    MSMQ_QMID_REGNAME,
						    &dwValueType,
						    &m_LocalQmGUID,
						    &dwValueSize);
	    if (FAILED(rc))
	    {
            //
            // Failed - maybe running on a dependent client
            //
       	    TrTRACE(GENERAL, "Could not read Machine GUID from registry");

		    return false;
	    }
        m_fLocalQmGUIDInitialized = true;
    }

    return (memcmp(&m_LocalQmGUID, &m_guidId, sizeof(GUID)) == 0);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPrivateFolder::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPrivateFolder::PopulateScopeChildrenList()
{

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    CString strTitle;
    CPrivateQueue *pQ;
    CString strFn;
    CString strPrefix;

    //
    // Display private queues
    //
    AP<UCHAR> pListofPrivateQ;
    DWORD dwNoofQ;

    {
        CWaitCursor wc;

        //
        // Send an admin message to request the list of private queues
        //
        hr = RequestPrivateQueues(m_guidId, &pListofPrivateQ, &dwNoofQ);
    }

    if(FAILED(hr))
    {
		//
		// Issue clear error message in timeout case
		//
		if ( hr == MQ_ERROR_IO_TIMEOUT )
		{
			DisplayErrorAndReason(IDS_OP_REQUESTPRIVATEQUEUE, IDS_MSMQ_MAY_BE_DOWN, L"", hr);
			return S_OK;
		}

        MessageDSError(hr, IDS_OP_REQUESTPRIVATEQUEUE);
        return(S_OK);
    }


    strPrefix = L"PRIVATE=" + m_pwszGuid;

    PUCHAR pPrivQPos = (PUCHAR)pListofPrivateQ;

    bool fIsMyMachine = IsMyMachine();

    for(DWORD i = 0; i < dwNoofQ; i++)
    {
        //
        //Retrieve Private Queue ID;
        //
        DWORD dwQueueID = *(DWORD UNALIGNED *)pPrivQPos;
        pPrivQPos += sizeof(DWORD);
        //
        // Retreive PATHNAME
        //   
        CString csName = (LPTSTR)pPrivQPos; 

        pPrivQPos += (wcslen(csName) + 1)*sizeof(WCHAR);

        //
        // Create Private queue
        //
        pQ = new CPrivateQueue(this, m_pComponentData);

        pQ->m_szPathName = csName;
		pQ->m_szMachineName = m_szMachineName;

        //
        // Extract the queue name only from the full private path name
        //
        CString szUpperName = csName;
        szUpperName.MakeUpper();

        int n = szUpperName.Find(PRIVATE_QUEUE_PATH_INDICATIOR);
        ASSERT(n != -1);

        pQ->m_bstrDisplayName = csName.Mid(n + PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH);

        // Set the format name
        strFn.Format(L"%s"
                     FN_PRIVATE_SEPERATOR    // "\\"
                     FN_PRIVATE_ID_FORMAT,
                     strPrefix, dwQueueID);
        pQ->m_szFormatName = strFn;
        pQ->SetIcons(IMAGE_PRIVATE_QUEUE, IMAGE_PRIVATE_QUEUE);
        
        //
        // Add queue to the left pane, except for one case:
        // If I query the local machine, the admin response queue is returned
        // and then deleted. This is confusing for users, because they always 
        // see that queue, and they get an error message when they try to access 
        // it. (Bug 7140, YoelA, 13-Nov-01)
        //
   
        if (!fIsMyMachine || !pQ->IsAdminRespQueue())
        {
    	    AddChild(pQ, &pQ->m_scopeDataItem);
        }
    }

    return(hr);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CPrivateFolder::InsertColumns

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPrivateFolder::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString title;

    title.LoadString(IDS_COLUMN_NAME);
    pHeaderCtrl->InsertColumn(0, title, LVCFMT_LEFT, g_dwGlobalWidth);

    return(S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPrivateFolder::OnUnSelect

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPrivateFolder::OnUnSelect( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    HRESULT hr;

    hr = pHeaderCtrl->GetColumnWidth(0, &g_dwGlobalWidth);
    return(hr);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPrivateFolder::SetVerbs

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPrivateFolder::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hr = S_OK;
    //
    // Display verbs that we support
    //
    hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );


    return(hr);
}
        

/****************************************************

        CSystemQueues Class
    
 ****************************************************/
/////////////////////////////////////////////////////////////////////////////
// CSystemQueues
// {A97E9501-D2BF-11d1-9B9D-00E02C064C39}
static const GUID CSystemQueuesGUID_NODETYPE = 
{ 0xa97e9501, 0xd2bf, 0x11d1, { 0x9b, 0x9d, 0x0, 0xe0, 0x2c, 0x6, 0x4c, 0x39 } };

const GUID*  CSystemQueues::m_NODETYPE = &CSystemQueuesGUID_NODETYPE;
const OLECHAR* CSystemQueues::m_SZNODETYPE = OLESTR("A97E9501-D2BF-11d1-9B9D-00E02C064C39");
const OLECHAR* CSystemQueues::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CSystemQueues::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;



//////////////////////////////////////////////////////////////////////////////
/*++

CSystemQueues::PopulateScopeChildrenList

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSystemQueues::PopulateScopeChildrenList()
{

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    CString strTitle;

    CReadSystemMsg *p;
    CString strPrefix;
    strPrefix.Format(L"%s%s%s", FN_DIRECT_TOKEN FN_EQUAL_SIGN FN_DIRECT_OS_TOKEN, 
                m_pwszComputerName, FN_PRIVATE_SEPERATOR 
                SYSTEM_QUEUE_PATH_INDICATIOR);

    //
    // Create a Journal queue
    //   
    p = new CReadSystemMsg (
                this, 
                m_pComponentData, 
                strPrefix + FN_JOURNAL_SUFFIX, 
                m_pwszComputerName,
                FN_JOURNAL_SUFFIX);    

    strTitle.LoadString(IDS_READJOURNALMESSAGE);
    p->m_bstrDisplayName = strTitle;
    p->SetIcons(IMAGE_JOURNAL_QUEUE,IMAGE_JOURNAL_QUEUE);

    AddChild(p, &p->m_scopeDataItem);


    //
    // Create a DeadLetter queue
    //    
    p = new CReadSystemMsg (
                this, 
                m_pComponentData, 
                strPrefix + FN_DEADLETTER_SUFFIX, 
                m_pwszComputerName,
                FN_DEADLETTER_SUFFIX);

    strTitle.LoadString(IDS_MACHINEQ_TYPE_DEADLETTER);
    p->m_bstrDisplayName = strTitle;
    p->SetIcons(IMAGE_DEADLETTER_QUEUE,IMAGE_DEADLETTER_QUEUE);

    AddChild(p, &p->m_scopeDataItem);


    //
    // Create a Xact DeadLetter queue
    //    
    p = new CReadSystemMsg (
                this, 
                m_pComponentData, 
                strPrefix + FN_DEADXACT_SUFFIX, 
                m_pwszComputerName,
                FN_DEADXACT_SUFFIX );

    strTitle.LoadString(IDS_MACHINEQ_TYPE_DEADXACT);
    p->m_bstrDisplayName = strTitle;
    p->SetIcons(IMAGE_DEADLETTER_QUEUE,IMAGE_DEADLETTER_QUEUE);

    AddChild(p, &p->m_scopeDataItem);

    return(hr);

}

//////////////////////////////////////////////////////////////////////////////
/*++

CSystemQueues::InsertColumns

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSystemQueues::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString title;

    title.LoadString(IDS_COLUMN_NAME);
    pHeaderCtrl->InsertColumn(0, title, LVCFMT_LEFT, g_dwGlobalWidth);

    return(S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSystemQueues::OnUnSelect

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CSystemQueues::OnUnSelect( IHeaderCtrl* pHeaderCtrl )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    HRESULT hr;

    hr = pHeaderCtrl->GetColumnWidth(0, &g_dwGlobalWidth);
    return(hr);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSystemQueues::GetHelpLink

--*/
//////////////////////////////////////////////////////////////////////////////
CString 
CSystemQueues::GetHelpLink( 
	VOID
	)
{
	CString strHelpLink;
    strHelpLink.LoadString(IDS_HELPTOPIC_QUEUES);

	return strHelpLink;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\storage.h ===
// Storage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CStoragePage dialog


#define xMaxStorageDirLength 230


class CStoragePage : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CStoragePage)

// Construction
public:
	CStoragePage();
	~CStoragePage();    

// Dialog Data
	//{{AFX_DATA(CStoragePage)
	enum { IDD = IDD_STORAGE };
	CString	m_MsgFilesDir;
	CString	m_MsgLoggerDir;
	CString	m_TxLoggerDir;
	//}}AFX_DATA
	CString m_OldMsgFilesDir;
	CString m_OldMsgLoggerDir;
	CString m_OldTxLoggerDir;
 
// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CStoragePage)
    public:
    virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CStoragePage)   
	afx_msg void OnBrowseLogFolder();
	afx_msg void OnBrowseMsgFolder();
	afx_msg void OnBrowseXactFolder();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void DDV_FullPathNames(CDataExchange* pDX);
	BOOL MoveFilesToNewFolders(void);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\testmsg.cpp ===
// testmsg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "globals.h"
#include "dsext.h"
#include "mqppage.h"
#include "admmsg.h"
#include "testmsg.h"

#include "testmsg.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static HRESULT GetGuidFromFormatName(LPCTSTR szFormatName, GUID *pGuid);

/////////////////////////////////////////////////////////////////////////////
// CSetReportQDlg dialog



/////////////////////////////////////////////////////////////////////////////
// CTestMsgDlg dialog


CTestMsgDlg::CTestMsgDlg(
	const GUID& gMachineID,
	const CString& strMachineName, 
	const CString& strDomainController,
	BOOL fLocalMgmt,
	CWnd* pParentWnd
	) : 
	CMqDialog(IDD, pParentWnd), m_gMachineID(gMachineID),
    m_strMachineName(strMachineName),
	m_strDomainController(strDomainController),
	m_fLocalMgmt(fLocalMgmt)
{
	//{{AFX_DATA_INIT(CTestMsgDlg)
	//}}AFX_DATA_INIT
    m_iSentCount = 0;
}


void CTestMsgDlg::DoDataExchange(CDataExchange* pDX)
{
	CMqDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTestMsgDlg)
	DDX_Control(pDX, IDC_TESTMESSAGE_SEND, m_ctlSendButton);
	DDX_Control(pDX, IDC_TESTMESSAGE_DESTQ, m_DestQueueCtrl);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTestMsgDlg, CMqDialog)
	//{{AFX_MSG_MAP(CTestMsgDlg)
	ON_BN_CLICKED(IDC_TESTMESSAGE_NEW, OnTestmessageNew)
	ON_BN_CLICKED(IDC_TESTMESSAGE_SEND, OnTestmessageSend)
	ON_BN_CLICKED(IDC_TESTMESSAGE_CLOSE, OnTestmessageClose)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTestMsgDlg private functions

    
/////////////////////////////////////////////////////////////////////////////
// CTestMsgDlg message handlers


void CTestMsgDlg::OnTestmessageNew() 
{
	static const GUID x_TestGuidType = MQ_QTYPE_TEST;

    CNewQueueDlg NewQDlg(this, IDS_TESTQ_LABEL, x_TestGuidType);
    if(NewQDlg.DoModal() == IDOK)
    {

        //
        // add queue to the combo-box. Enable "Send" button in case
        // the list was empty previousely
        //
	    int iItem = m_DestQueueCtrl.AddString(NewQDlg.m_strPathname);
        if (CB_ERR == iItem)
        {
            ASSERT(0);
            return;
        }

        INT_PTR iArrayIndex = m_aguidAllQueues.Add(NewQDlg.m_guid);
        m_DestQueueCtrl.SetItemData(iItem, iArrayIndex);

        m_DestQueueCtrl.SelectString(-1, NewQDlg.m_strPathname);
        m_ctlSendButton.EnableWindow(TRUE);
    }
}

BOOL CTestMsgDlg::OnInitDialog() 
{
    GUID TestGuidType = MQ_QTYPE_TEST;

    CMqDialog::OnInitDialog();
    //
    // Set the title to "Sending messages from ..."
    //
    CString strTitleFormat;
    strTitleFormat.LoadString(IDS_TEST_TITLE_FORMAT);

    CString strTitle;
    strTitle.FormatMessage(strTitleFormat, m_strMachineName);

    SetWindowText(strTitle);
	
	//
    // Query the DS for all the test-queues and insert them into 
    // the combo-box
    //
    CRestriction restriction;
    restriction.AddRestriction(&TestGuidType, PROPID_Q_TYPE, PREQ);

    CColumns columns;
    columns.Add(PROPID_Q_PATHNAME);
    columns.Add(PROPID_Q_INSTANCE);

    const DWORD x_dwResultBufferSize = 64;
    PROPVARIANT apResultProps[x_dwResultBufferSize];
    DWORD dwPropCount = x_dwResultBufferSize;
  
    HRESULT hr;
    HANDLE hEnume;
    {
        CWaitCursor wc; //display wait cursor while query DS
        hr = ADQueryQueues(
					m_fLocalMgmt ? MachineDomain() : GetDomainController(m_strDomainController),
					m_fLocalMgmt ? false : true,		// fServerName
                    restriction.CastToStruct(),
                    columns.CastToStruct(),
                    0,
                    &hEnume
                    );
    }
    DSLookup dslookup(hEnume, hr);

    if (!dslookup.HasValidHandle())
    {
        return TRUE;
    }

    while ( SUCCEEDED(dslookup.Next(&dwPropCount, apResultProps))
            && (dwPropCount != 0) )
    {
        for (DWORD i=0; i<dwPropCount; i++)
        {
            int iItem = m_DestQueueCtrl.AddString(apResultProps[i].pwszVal);
            MQFreeMemory(apResultProps[i].pwszVal);

            i++;
            INT_PTR iArrayIndex = m_aguidAllQueues.Add(*apResultProps[i].puuid);
            m_DestQueueCtrl.SetItemData(iItem, iArrayIndex);
            MQFreeMemory(apResultProps[i].puuid);
        }
        dwPropCount = x_dwResultBufferSize;
    }

    //
    // make the first item the default selection (if any items exist)
    //
    if (CB_ERR == m_DestQueueCtrl.SetCurSel(0))
    {
        m_ctlSendButton.EnableWindow(FALSE);
    }
    else
    {
        m_ctlSendButton.EnableWindow(TRUE);
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CNewQueueDlg dialog


CNewQueueDlg::CNewQueueDlg(CWnd* pParent /*=NULL*/,
                                           UINT uiLabel /* = IDS_TESTQ_LABEL */,
                                           const GUID &guid_Type /* = GUID_NULL */
                                           )
	: CMqDialog(CNewQueueDlg::IDD, pParent),
      m_fValid(FALSE)
{
	//{{AFX_DATA_INIT(CNewQueueDlg)
	m_strPathname = _T("");
	//}}AFX_DATA_INIT
    VERIFY(m_strQLabel.LoadString(uiLabel));
    m_guidType = guid_Type;
}


void CNewQueueDlg::DoDataExchange(CDataExchange* pDX)
{
	CMqDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewQueueDlg)
	DDX_Text(pDX, IDC_NEWQTYPE_QUEUENAME, m_strPathname);
	//}}AFX_DATA_MAP
    DDV_NotPrivateQueue(pDX, m_strPathname);
}


BEGIN_MESSAGE_MAP(CNewQueueDlg, CMqDialog)
	//{{AFX_MSG_MAP(CNewQueueDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CNewQueueDlg::OnOK() 
{
    if (0 == UpdateData(TRUE))
    {
        //
        // Update data failed
        //
        return;
    }

    CWaitCursor wait;
    CString csNewPathName;

    HRESULT hr;
    //
    // Create the queue
    //
    PROPID aProp[] = {PROPID_Q_PATHNAME, PROPID_Q_LABEL, PROPID_Q_TYPE};
    const x_nProps = sizeof(aProp) / sizeof(aProp[0]);
    PROPVARIANT apVar[x_nProps];

    DWORD iProp = 0;

    ASSERT(PROPID_Q_PATHNAME == aProp[iProp]);
    apVar[iProp].vt = VT_LPWSTR;
    apVar[iProp].pwszVal = (LPTSTR)(LPCTSTR)(m_strPathname);
    iProp++;

    ASSERT(PROPID_Q_LABEL == aProp[iProp]);
    apVar[iProp].vt = VT_LPWSTR;
    apVar[iProp].pwszVal = (LPTSTR)(LPCTSTR)(m_strQLabel);
    iProp++;

    ASSERT(PROPID_Q_TYPE == aProp[iProp]);
    apVar[iProp].vt = VT_CLSID;
    apVar[iProp].puuid = &m_guidType;

    MQQUEUEPROPS mqp = {x_nProps, aProp, apVar, 0};

    WCHAR strFormatName[64];
    DWORD dwFormatLen = sizeof(strFormatName) / sizeof(strFormatName[0]);

    hr = MQCreateQueue(0, &mqp, strFormatName, &dwFormatLen);

    if(FAILED(hr))
    {
        MessageDSError(hr, IDS_OP_CREATE, m_strPathname);
        return;
    }

    if (FAILED(GetGuidFromFormatName(strFormatName, &m_guid)))
    {
        ASSERT(0);
        return;
    }
	
	CMqDialog::OnOK();
}


//
// This function verifies that the given queue pathname is not a private
// queue pathname
//
void CNewQueueDlg::DDV_NotPrivateQueue(CDataExchange * pDX, CString& strQueuePathname)
{
    if (pDX->m_bSaveAndValidate)
    {
        CString strUpperName = strQueuePathname;
        strUpperName.MakeUpper();

        if (-1 != strUpperName.Find(PRIVATE_QUEUE_PATH_INDICATIOR))
        {
            //
            // This is a private queue pathname
            //
            AfxMessageBox(IDS_PRIVATE_QUEUE_NOT_SUPPORTED);
            pDX->Fail();
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CTestMsgDlg dialog


void CTestMsgDlg::OnTestmessageSend() 
{
    CWaitCursor wc;
	//
    // retrieve the selected queue
    //
	int iSelectedQueue = m_DestQueueCtrl.GetCurSel();

	if (iSelectedQueue == CB_ERR)
    {
        //
        // If nothing is selected, send should not be enabled
        //
        ASSERT(0);
        return;
    }
    
    INT_PTR iArrayIndex = m_DestQueueCtrl.GetItemData(iSelectedQueue);
    ASSERT(CB_ERR != iArrayIndex);

    HRESULT rc = SendQMTestMessage(m_gMachineID, m_aguidAllQueues[iArrayIndex]);
    if(FAILED(rc))
    {
        MessageDSError(rc, IDS_OP_SEND_TEST_MESSAGE, m_strMachineName);
    }
    else
    {
        IncrementSentCount();
    }
}

void CTestMsgDlg::IncrementSentCount() 
{
    CStatic *pstaticCounter = (CStatic *)GetDlgItem(IDC_TESTMESSAGE_NO_SENT);
    CString strCountText;
    m_iSentCount++;

    strCountText.Format(TEXT("%d"), m_iSentCount);

    pstaticCounter->SetWindowText(strCountText);
}

void CTestMsgDlg::OnTestmessageClose() 
{
    EndDialog(TRUE);
}

/*===================================================
GetGuidFromFormatName

Get a Format Name of the form "PUBLIC=xxxx.x.x.x" and
return the GUID
(Quite ugly code - but it is better than a query to the DS)

 ===================================================*/
HRESULT GetGuidFromFormatName(LPCTSTR szFormatName, GUID *pGuid)
{
    TCHAR szTmpName[64];
    HRESULT hr;


    if(memcmp(szFormatName, TEXT("PUBLIC="), 14) != 0)
        return(MQ_ERROR);

    lstrcpy(szTmpName,&szFormatName[6]);

    szTmpName[0] = L'{';
    szTmpName[37] = L'}';
    szTmpName[38] = 0;

    hr = IIDFromString(&szTmpName[0], pGuid);

    return(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\trigadm.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    trigger.h

Abstract:
	Definition for the trigger objects

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __TRIGADM_H__
#define __TRIGADM_H__

#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"
#include "snpnerr.h"

#include "rule.h"
#include "trigger.h"

// -----------------------------------------------------
//
// CTriggerLocalAdmin
//
// -----------------------------------------------------
class CTriggerLocalAdmin : public CNodeWithScopeChildrenList<CTriggerLocalAdmin, FALSE>
{
public:
   	SNAPINMENUID(IDR_TRIGADM_MENUE)

    CTriggerLocalAdmin(
        CSnapInItem * pParentNode, 
        CSnapin * pComponentData, 
        CString strComputer
        ) : 
        CNodeWithScopeChildrenList<CTriggerLocalAdmin, FALSE>(pParentNode, pComponentData),
        m_szMachineName(strComputer),
        m_pRuleSet(GetRuleSet(strComputer)),
        m_pTrigSet(GetTriggerSet(strComputer))
    {
		SetIcons(IMAGE_TRIGGERS_GENERAL,IMAGE_TRIGGERS_GENERAL);
    }

	~CTriggerLocalAdmin()
    {
    }

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

	virtual HRESULT PopulateScopeChildrenList();
	virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);

    HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

private:
    HRESULT CreateConfigurationPage(HPROPSHEETPAGE *phConfig);
	virtual CString GetHelpLink();

public:
    CString m_szMachineName;
    R<CRuleSet> m_pRuleSet;
    R<CTriggerSet> m_pTrigSet;
};

#endif // __TRIGADM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\triggen.cpp ===
// triggen.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"

#import "mqtrig.tlb" no_namespace

#include "mqtg.h"
#include "mqppage.h"
#include "triggen.h"

#include "triggen.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTriggerGen property page

IMPLEMENT_DYNCREATE(CTriggerGen, CMqPropertyPage)

CTriggerGen::CTriggerGen() : 
    CMqPropertyPage(CTriggerGen::IDD),
    m_triggerCnf(L"MSMQTriggerObjects.MSMQTriggersConfig.1")
{
    long temp;

    //
    // get defaultmsg body size. 
    //
    m_triggerCnf->get_DefaultMsgBodySize(&temp);
    m_orgDefaultMsgBodySize = static_cast<DWORD>(temp);

    //
    // Vaidate default message body size. If it's greater then the max value
    // set the maximum
    //
    if (m_orgDefaultMsgBodySize > xDefaultMsbBodySizeMaxValue)
    {
        m_defaultMsgBodySize = xDefaultMsbBodySizeMaxValue;
    }
    else
    {
        m_defaultMsgBodySize = static_cast<DWORD>(temp);
    }

    //
    // Get maximume number of trhead
    //
    m_triggerCnf->get_MaxThreads(&temp);
    m_orgMaxThreadsCount = static_cast<DWORD>(temp);

    //
    // Validate max number of thread. If it's greater then the max value set the maximum
    //
    if (m_orgMaxThreadsCount > xMaxThreadNumber)
    {
        m_maxThreadsCount = xMaxThreadNumber;
    }
    else
    {
        m_maxThreadsCount = static_cast<DWORD>(temp);
    }

    //
    // Get Initial number of thread. If it's greater then the max number of thread set the value
    // to max thread number
    //
    m_triggerCnf->get_InitialThreads(&temp);
    m_orgInitThreadsCount = static_cast<DWORD>(temp);
    if (m_orgInitThreadsCount > m_maxThreadsCount)
    {
        m_initThreadsCount = m_maxThreadsCount;
    }
    else
    {
        m_initThreadsCount = static_cast<DWORD>(temp);
    }
}

CTriggerGen::~CTriggerGen()
{
}

void CTriggerGen::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTriggerGen)
	DDX_Text(pDX, IDC_DefaultMsgBodySize, m_defaultMsgBodySize);
    DDV_DefualtBodySize(pDX);

	DDX_Text(pDX, IDC_MaxThreadCount, m_maxThreadsCount);
    DDV_MaxThreadCount(pDX);

	DDX_Text(pDX, IDC_InitThreadsCount, m_initThreadsCount);
    DDV_InitThreadCount(pDX);
	//}}AFX_DATA_MAP

}


BEGIN_MESSAGE_MAP(CTriggerGen, CPropertyPage)
	//{{AFX_MSG_MAP(CTriggerGen)
	ON_EN_CHANGE(IDC_InitThreadsCount, OnChangeRWField)
	ON_EN_CHANGE(IDC_MaxThreadCount, OnChangeRWField)
	ON_EN_CHANGE(IDC_DefaultMsgBodySize, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CTriggerGen::DDV_MaxThreadCount(CDataExchange* pDX)
{
    if (! pDX->m_bSaveAndValidate)
        return;

    if ((m_maxThreadsCount > xMaxThreadNumber) || (m_maxThreadsCount < 1))
    {
        CString strError;
        strError.FormatMessage(IDS_MAX_MUST_BE_LESS_THEN, xMaxThreadNumber);

        AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);
        pDX->Fail();
    }
}


void CTriggerGen::DDV_InitThreadCount(CDataExchange* pDX)
{
    if (!pDX->m_bSaveAndValidate)
        return;
    

    if ((m_initThreadsCount > m_maxThreadsCount) || (m_initThreadsCount < 1))
    {
        CString strError;
        strError.FormatMessage(IDS_INIT_THREAD_MUST_BE_LESS_THEN_MAX, m_maxThreadsCount);

        AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);
        pDX->Fail();
    }
}


void CTriggerGen::DDV_DefualtBodySize(CDataExchange* pDX)
{
    if (!pDX->m_bSaveAndValidate)
        return;
    
    if (m_defaultMsgBodySize > xDefaultMsbBodySizeMaxValue)
    {
        CString strError;
        strError.FormatMessage(IDS_ILLEGAL_DEAFULT_MSG_BODY_SIZE, xDefaultMsbBodySizeMaxValue);

        AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);

        pDX->Fail();
    }
}

/////////////////////////////////////////////////////////////////////////////
// CTriggerGen message handlers

BOOL CTriggerGen::OnApply() 
{
    try
    {
        //
        // Propogate Trigger configuration parameters to registry
        //
        if (m_defaultMsgBodySize != m_orgDefaultMsgBodySize)
        {
            m_triggerCnf->put_DefaultMsgBodySize(m_defaultMsgBodySize);
            m_orgDefaultMsgBodySize = m_defaultMsgBodySize;
        }

        if (m_maxThreadsCount != m_orgMaxThreadsCount)
        {

            m_triggerCnf->put_MaxThreads(m_maxThreadsCount);
            m_orgMaxThreadsCount = m_maxThreadsCount;
        }

        if (m_initThreadsCount != m_orgInitThreadsCount)
        {
            m_triggerCnf->put_InitialThreads(m_initThreadsCount); 
            m_orgInitThreadsCount = m_initThreadsCount;
        }

	    return CPropertyPage::OnApply();
    }
    catch(const _com_error&)
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\triggen.h ===
#if !defined(AFX_TRIGGEN_H__197B248D_33BE_467E_9E4D_4D5AA59B7A4B__INCLUDED_)
#define AFX_TRIGGEN_H__197B248D_33BE_467E_9E4D_4D5AA59B7A4B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// triggen.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CTriggerGen dialog


class CTriggerGen : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CTriggerGen)

// Construction
public:
    CTriggerGen();
	~CTriggerGen();

// Dialog Data
	//{{AFX_DATA(CTriggerGen)
	enum { IDD = IDD_TRIGGER_CONFIG };
	DWORD	m_defaultMsgBodySize;
	DWORD	m_maxThreadsCount;
	DWORD	m_initThreadsCount;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTriggerGen)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTriggerGen)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    void DDV_MaxThreadCount(CDataExchange* pDX);
    void DDV_InitThreadCount(CDataExchange* pDX);
    void DDV_DefualtBodySize(CDataExchange* pDX);

private:
    IMSMQTriggersConfigPtr m_triggerCnf;

	DWORD	m_orgDefaultMsgBodySize;
	DWORD	m_orgMaxThreadsCount;
	DWORD	m_orgInitThreadsCount;

};
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TRIGGEN_H__197B248D_33BE_467E_9E4D_4D5AA59B7A4B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\testmsg.h ===
// SetRQDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTestMsgDlg dialog

class CTestMsgDlg : public CMqDialog
{
// Construction
public:
	CTestMsgDlg(
		const GUID& gMachineID, 
		const CString& strMachineName, 
		const CString& strDomainController,
		BOOL fLocalMgmt,
		CWnd* pParentWnd
		);

    

// Dialog Data

    CString m_strSelectedQueue;

	//{{AFX_DATA(CTestMsgDlg)
	enum { IDD = IDD_TESTMESSAGE };
	CButton	m_ctlSendButton;
	CComboBox	m_DestQueueCtrl;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTestMsgDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

    GUID m_gMachineID;
	CString m_strMachineName;
	CString m_strDomainController;
	int m_iSentCount;
	void IncrementSentCount();
    CArray<GUID, const GUID&> m_aguidAllQueues;

	// Generated message map functions
	//{{AFX_MSG(CTestMsgDlg)
	afx_msg void OnTestmessageNew();
	virtual BOOL OnInitDialog();
	afx_msg void OnTestmessageSend();
	afx_msg void OnTestmessageClose();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	BOOL m_fLocalMgmt;
};
/////////////////////////////////////////////////////////////////////////////
// CNewQueueDlg dialog

class CNewQueueDlg : public CMqDialog
{
// Construction
public:
	CString m_strQLabel;
	BOOL m_fValid;
	GUID m_guid;
	CNewQueueDlg(CWnd* pParent = NULL,
                         UINT uiLabel = IDS_TESTQ_LABEL,
                         const GUID &guid_Type = GUID_NULL);

// Dialog Data
	//{{AFX_DATA(CNewQueueDlg)
	enum { IDD = IDD_NEWTYPED_QUEUE };
	CString	m_strPathname;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewQueueDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewQueueDlg)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	void DDV_NotPrivateQueue(CDataExchange* pDX, CString& strQueuePathname);
	GUID m_guidType;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\trigger.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    trigger.cpp

Abstract:
	Implementation for trigger class

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/
#include "stdafx.h"

#import "mqtrig.tlb" no_namespace
#include "rule.h"
#include "trigger.h"
#include "mqsymbls.h"

#include "trigger.tmh"

using namespace std;

static CTriggerSet* s_pTriggerSet = NULL;

R<CTriggerSet> GetTriggerSet(const CString& strComputer)
{
    if (s_pTriggerSet == NULL)
    {
        s_pTriggerSet = new CTriggerSet(strComputer);
    }

    return SafeAddRef(s_pTriggerSet);
}


//
// CTrigger Class implementation
//

CTrigger::CTrigger(
    CTriggerSet* pTrigSet,
    const _bstr_t& id,
    const _bstr_t& name,
    const _bstr_t& queuePathName,
    SystemQueueIdentifier queueType,
    long noOfRules,
    bool fEnabled,
    bool fSerialize,
	MsgProcessingType msgProcType
    ) :
    m_pTrigSet(SafeAddRef(pTrigSet)),
    m_id(id),
    m_name(name),
    m_queuePathName(queuePathName),
    m_queueType(queueType),
    m_noOfAttachedRules(noOfRules),
    m_fEnabled(fEnabled),
    m_fSerialize(fSerialize),
	m_msgProcType(msgProcType)
{
}


void CTrigger::Update(
    const _bstr_t& name,
    const _bstr_t& queuePathName,
    SystemQueueIdentifier queueType,
    bool fEnabled,
    bool fSerialize,
	MsgProcessingType msgProcType
    ) throw(_com_error)
{
    if ((name == m_name) &&
        (queuePathName == m_queuePathName) &&
        (queueType == m_queueType) &&
        (fEnabled == m_fEnabled) &&
        (fSerialize == m_fSerialize) &&
		(m_msgProcType == msgProcType))
    {
        return;
    }

    m_pTrigSet->Update(
            m_id, 
            name, 
            queuePathName, 
            queueType, 
            fEnabled, 
            fSerialize,
			msgProcType
            );

    m_name = name;
    m_queuePathName = queuePathName;
    m_queueType = queueType;
    m_fEnabled = fEnabled;
    m_fSerialize = fSerialize;
	m_msgProcType = msgProcType;
}


void 
CTrigger::Update(
    const _bstr_t&  name
    ) throw(_com_error)
{
    if (name == m_name)
        return;

    m_pTrigSet->Update(
            m_id, 
            name, 
            m_queuePathName, 
            m_queueType, 
            m_fEnabled, 
            m_fSerialize,
			m_msgProcType
            );

    m_name = name;
}


void 
CTrigger::UpdateEnabled(
    bool fEnabled
    ) throw(_com_error)
{
    if (m_fEnabled == fEnabled)
        return;

    m_pTrigSet->Update(
            m_id, 
            m_name, 
            m_queuePathName, 
            m_queueType, 
            fEnabled, 
            m_fSerialize,
			m_msgProcType
            );

    m_fEnabled = fEnabled;
}


void
CTrigger::UpdateAttachedRules(
    RuleList newRuleList
    ) throw(_com_error)
{
	// 
	// Attaching a rule to a trigger isn't atomic operation. For every rule attachment, a notification 
	// message is sent to the service and as a result the service adds the rule to the trigger.
    // When the trigger has its first rule it begins to process the messages in the queue so in some cases 
	// the first message processing will take place before the processing of the notification message about 
	// the second rule attachment.	From user point of view attaching a rule to a trigger is atomic operation.
	// For achiving this, the MSMQ snapin disables the trigger before attaching the rule and re-enabls it 
	// (if needed) after all rules have been attached.
	//
	bool fEnable = m_fEnabled;

	UpdateEnabled(false);
    m_pTrigSet->UpdateAttachedRules(m_id, newRuleList);
	UpdateEnabled(fEnable);

    m_noOfAttachedRules = numeric_cast<long>(newRuleList.size());
}



//
// CTriggerSet implementation
//

CTriggerSet::CTriggerSet(
     const CString& strComputer
    ) :
    m_trigSet(L"MSMQTriggerObjects.MSMQTriggerSet.1"),
    m_fChanged(false)
{
    m_trigSet->Init(static_cast<LPCWSTR>(strComputer));
    Refresh();
}


void 
CTriggerSet::Refresh(
    void
    ) throw(_com_error)
{
    m_trigSet->Refresh();

    m_triggerList.erase(m_triggerList.begin(), m_triggerList.end());

    long noOfTriggers = m_trigSet->GetCount();
    for(long trigIndex = 0; trigIndex < noOfTriggers; ++trigIndex)
    {        
        BSTR id = NULL;
        BSTR name = NULL;
        BSTR queuePathName = NULL;
        SystemQueueIdentifier queueType;
        long noOfRules;
        long fEnabled;
        long fSerialize;
		MsgProcessingType msgProcType;

        m_trigSet->GetTriggerDetailsByIndex(
                        trigIndex,
                        &id,
                        &name,
                        &queuePathName,
                        &queueType,
                        &noOfRules,
                        &fEnabled,
                        &fSerialize,
						&msgProcType
                        );

        R<CTrigger> pTrigger = new CTrigger(
                                this,
                                id, 
                                name, 
                                queuePathName, 
                                queueType, 
                                noOfRules,
                                (fEnabled != 0),
                                (fSerialize != 0),
								msgProcType
                                );
    
        m_triggerList.push_back(pTrigger);
    }
}


R<CTrigger> 
CTriggerSet::AddTrigger(
    const _bstr_t& name,
    const _bstr_t& queuePathName,
    SystemQueueIdentifier queueType,
    long fEnabled,
    long fSerialize,
	MsgProcessingType msgProcType
    ) throw(_com_error)
{
    BSTR trigId = NULL;

    m_trigSet->AddTrigger(
            name, 
            queuePathName, 
            queueType,
            fEnabled, 
            fSerialize,
			msgProcType,
            &trigId
            );

    R<CTrigger> pTrigger = new CTrigger(
                            this,
                            trigId, 
                            name, 
                            queuePathName, 
                            queueType, 
                            0,
                            (fEnabled != 0),
                            (fSerialize != 0),
							msgProcType
                            );

    m_triggerList.push_back(pTrigger);
    m_fChanged = true;

    return pTrigger;

}

    
void 
CTriggerSet::DeleteTrigger(
    const _bstr_t& trigId
    )throw (_com_error)
{
    m_trigSet->DeleteTrigger(trigId);

    for(TriggerList::iterator it = m_triggerList.begin(); it != m_triggerList.end(); ++it)
    {
        if (trigId == (*it)->GetTriggerId())
        {
            m_triggerList.erase(it);
            m_fChanged = true;
            return;
        }
    }

    ASSERT(0);
}


void 
CTriggerSet::Update(
    const _bstr_t& id,
    const _bstr_t& name,
    const _bstr_t& queuePathName,
    SystemQueueIdentifier queueType,
    long fEnabled,
    long fSerialize,
	MsgProcessingType msgProcType
    ) throw(_com_error)
{
    m_trigSet->UpdateTrigger(
                    id, 
                    name, 
                    queuePathName, 
                    queueType, 
                    fEnabled, 
                    fSerialize,
					msgProcType
                    );
}


void
CTriggerSet::UpdateAttachedRules(
    const _bstr_t& id,
    RuleList newRuleList
    ) throw(_com_error)
{
    m_trigSet->DetachAllRules(id);

    long index = 0;

    for(RuleList::iterator it = newRuleList.begin(); it != newRuleList.end(); ++it)
    {  
        m_trigSet->AttachRule(id, (*it)->GetRuleId(), index++);
    }
}


RuleList
CTriggerSet::GetAttachedRules(
    const _bstr_t& triggerId, 
    CRuleSet* pRuleSet,
    long noOfRules
    ) throw(_com_error)
{
    RuleList ruleList;

    for(long ruleIndex = 0; ruleIndex < noOfRules; ++ruleIndex)
    {
        BSTR ruleId = NULL;
        BSTR ruleName = NULL;
        BSTR ruleDescription = NULL;
        BSTR ruleCondition = NULL;
        BSTR ruleAction = NULL;
        long ruleShowWindow = NULL;

		try
		{
			m_trigSet->GetRuleDetailsByTriggerID(
                                        triggerId,
                                        ruleIndex,
                                        &ruleId,
                                        &ruleName,
                                        &ruleDescription,
                                        &ruleCondition,
                                        &ruleAction,
                                        NULL,
                                        &ruleShowWindow
                                        );

			R<CRule> pRule = new CRule(
									pRuleSet,
									ruleId, 
									ruleName, 
									ruleDescription, 
									ruleCondition, 
									ruleAction,
									(ruleShowWindow != 0)
									);  
        
			ruleList.push_back(pRule);
		}
		catch(const _com_error& e)
		{
			//
			// Legal case that the trigger already deleted
			//
			ASSERT(e.Error() == MQTRIG_TRIGGER_NOT_FOUND);
			DBG_USED(e);
		}
    }

    return ruleList;
}


TriggerList 
CTriggerSet::GetTriggerListForQueue(
    LPCTSTR queuePathName, 
    SystemQueueIdentifier queueType
    )
{
    TriggerList retList;

    for(TriggerList::iterator it = m_triggerList.begin(); it != m_triggerList.end(); ++it)
    {  
        R<CTrigger> pTrig = *it;

        if (pTrig->GetQueueType() != queueType)
            continue;

        if ((queueType != SYSTEM_QUEUE_NONE) || 
            _tcsicmp(pTrig->GetQueuePathName(), queuePathName) == 0)
        {
            retList.push_back(pTrig);
        }
    }

    return retList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\trigadm.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	trigger.cpp

Abstract:
	Implementation for the trigger Local administration

Author:
    Uri Habusha (urih), 25-Jun-2000

--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "mqppage.h"

#import "mqtrig.tlb" no_namespace

#include "rule.h"
#include "trigger.h"
#include "ruledef.h"
#include "trigadm.h"
#include "trigdef.h"
#include "triggen.h"

#include "trigadm.tmh"

/****************************************************

CTriggerLocalAdmin Class
    
 ****************************************************/
// {34C7ED18-4933-417f-8E88-EE832F0F580E}
static const GUID CCTriggerLocalAdminGUID_NODETYPE = 
{ 0x34c7ed18, 0x4933, 0x417f,{0x8e, 0x88, 0xee, 0x83, 0x2f, 0xf, 0x58, 0xe} };

const GUID*  CTriggerLocalAdmin::m_NODETYPE = &CCTriggerLocalAdminGUID_NODETYPE;
const OLECHAR* CTriggerLocalAdmin::m_SZNODETYPE = OLESTR("34C7ED18-4933-417f-8E88-EE832F0F580E");
const OLECHAR* CTriggerLocalAdmin::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CTriggerLocalAdmin::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;
  

HRESULT CTriggerLocalAdmin::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hr;

    //
    // Display verbs that we support
    //
    hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );
    ASSERT(SUCCEEDED(hr));

    if (m_szMachineName[0] != 0)
        return S_OK;

    //
    // On local machine, the user can set the trigger configuration parameters
    //
    hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );
    ASSERT(SUCCEEDED(hr));

    //
    // We want the default verb to be Properties
    //
	hr = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
    ASSERT(SUCCEEDED(hr));

    return S_OK;
}
                                   

HRESULT CTriggerLocalAdmin::PopulateScopeChildrenList()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    CString strTitle;
    HRESULT hr;

    //
    // Add trigger definition folder
    //
    CTriggerDefinition* pTrigger = new CTriggerDefinition(this, m_pComponentData, m_pTrigSet.get(), m_pRuleSet.get(), NULL);
    if (pTrigger == NULL)
        return S_OK;

    strTitle.LoadString(IDS_TRIGGER_DEFINITION);
    pTrigger->m_bstrDisplayName = strTitle;

    hr = AddChild(pTrigger, &pTrigger->m_scopeDataItem);
    if (FAILED(hr))
        return hr;

    //
    // Add Rule definition folder
    //
    CRulesDefinition* pRule = new CRulesDefinition(this, m_pComponentData, m_pRuleSet.get());
    if (pRule == NULL)
        return S_OK;

    strTitle.LoadString(IDS_RULE_DEFINITION);
    pRule->m_bstrDisplayName = strTitle;

	hr = AddChild(pRule, &pRule->m_scopeDataItem);
    
    return hr;
}


HRESULT 
CTriggerLocalAdmin::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR /*handle*/, 
	IUnknown* /*pUnk*/,
	DATA_OBJECT_TYPES /*type*/
    )
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HPROPSHEETPAGE hConfigPage = 0;
    HRESULT hr = CreateConfigurationPage(&hConfigPage);
    
    if (SUCCEEDED(hr))
    {
        lpProvider->AddPage(hConfigPage); 
        return S_OK;
    }

    MessageDSError(hr, IDS_OP_DISPLAY_TRIGGER_CONFIG_PAGE);
    return(S_OK);
}


HRESULT 
CTriggerLocalAdmin::CreateConfigurationPage(
    HPROPSHEETPAGE *phConfig
    )
{   
    CTriggerGen* pConfig = NULL;

    try
    {
        pConfig = new CTriggerGen;
    }
    catch(const _com_error&)
    {
        return E_UNEXPECTED;
    }

    if (pConfig == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HPROPSHEETPAGE hPage = pConfig->CreateThemedPropertySheetPage();
    if (hPage)
    {
        *phConfig = hPage;
        return S_OK;
    }

    ASSERT(0);
    return E_UNEXPECTED;    
}


HRESULT 
CTriggerLocalAdmin::InsertColumns(
    IHeaderCtrl* pHeaderCtrl
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
    CString title;
    title.LoadString(IDS_NAME);

    return pHeaderCtrl->InsertColumn(0, title, LVCFMT_LEFT, g_dwGlobalWidth);
}


CString 
CTriggerLocalAdmin::GetHelpLink()
{
	CString strHelpLink;
	strHelpLink.LoadString(IDS_HELPTOPIC_TRIGGERS);
	return strHelpLink;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\trigdef.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    trigdef.h

Abstract:
	Definition for the triggers class

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __TRIGDEF_H__
#define __TRIGDEF_H__

#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"
#include "snpnerr.h"
#include "snpnres.h"

class CTriggerSet;
class CTrigger;
class CRuleResult;
class CTriggerProp;
class CAttachedRule;
class CTrigResult;
class CTriggerDefinition;


// -----------------------------------------------------
//
// CTriggerDefinition
//
// -----------------------------------------------------
class CTriggerDefinition :  public CNodeWithResultChildrenList<CTriggerDefinition, CTrigResult, CSimpleArray<CTrigResult*>, FALSE>
{
public:
   	BEGIN_SNAPINCOMMAND_MAP(CTriggerDefinition, FALSE)
		SNAPINCOMMAND_ENTRY(ID_NEW_TRIGGER, OnNewTrigger)
	END_SNAPINCOMMAND_MAP()

   	SNAPINMENUID(IDR_TRIGGER_DEF_MENU)

    CTriggerDefinition(
        CSnapInItem * pParentNode, 
        CSnapin * pComponentData, 
        CTriggerSet* pTrigSet,
        CRuleSet* pRuleSet,
        LPCTSTR queuePathName
        ) : 
        CNodeWithResultChildrenList<CTriggerDefinition, CTrigResult, CSimpleArray<CTrigResult*>, FALSE>(pParentNode, pComponentData),
        m_pRuleSet(SafeAddRef(pRuleSet)),
        m_pTriggerSet(SafeAddRef(pTrigSet)),
        m_queuePathName(queuePathName)
    {
		//
		// Specify that trigger scop item doesn't have any child item
		//
		m_scopeDataItem.mask |= SDI_CHILDREN;
		m_scopeDataItem.cChildren = 0;

		SetIcons(IMAGE_TRIGGERS_DEFINITION,IMAGE_TRIGGERS_DEFINITION);
    }

	~CTriggerDefinition()
    {
    }

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

	virtual HRESULT PopulateResultChildrenList();
	virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);
    
    HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    R<CRuleSet> GetRuleSet(void) const
    {
        return m_pRuleSet;
    }


    RuleList GetRuleList(void)
    {
        return m_pRuleSet->GetRuleList();
    }

private:
	//
	// Menu functions
	//
	HRESULT OnNewTrigger(bool &bHandled, CSnapInObjectRootBase* pObj);
	virtual CString GetHelpLink();

private:
    R<CTriggerSet> m_pTriggerSet;
    R<CRuleSet> m_pRuleSet;

    LPCTSTR m_queuePathName;
};


//*********************************************
//
// CTrigResult
//
//*********************************************

class CTrigResult : public CSnapinNode<CTrigResult, FALSE>
{
public:
   	BEGIN_SNAPINCOMMAND_MAP(CTrigResult, FALSE)
		SNAPINCOMMAND_ENTRY(ID_TASK_ENABLE, OnEnableTrigger)
		SNAPINCOMMAND_ENTRY(ID_TASK_DISABLE, OnDisableTrigger)
	END_SNAPINCOMMAND_MAP()

   	SNAPINMENUID(IDR_TRIGGER_MENU)

    CTrigResult(
        CTriggerDefinition * pParentNode, 
        CSnapin * pComponentData,
        CTrigger* pTrigger
        ) : 
        CSnapinNode<CTrigResult, FALSE>(pParentNode, pComponentData),
        m_pTrigger(SafeAddRef(pTrigger)),
		m_pGeneral(NULL)
    {
        m_bstrDisplayName = static_cast<LPCTSTR>(GetTriggerName());

		SetIcons(IMAGE_TRIGGERS_DEFINITION, IMAGE_TRIGGERS_DEFINITION);
    }

	~CTrigResult()
    {
    }

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

    HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);
    HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);
	void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags);

    LPOLESTR GetResultPaneColInfo(int nCol);

    virtual HRESULT OnDelete( 
			LPARAM arg,
			LPARAM param,
			IComponentData * pComponentData,
			IComponent * pComponent,
			DATA_OBJECT_TYPES type,
            BOOL fSilent
			);

    void OnApply(CTriggerProp* p) throw(_com_error);
    void OnApply(CAttachedRule* p) throw(_com_error);

    RuleList GetRuleList(void);
    RuleList GetAttachedRulesList(void) throw(_com_error);

	void OnDestroyPropertyPages(void);

public:
	static void Compare(CTrigResult *pItem1, CTrigResult *pItem2, int* pnResult);


private:
    HRESULT CreateGenralPage(HPROPSHEETPAGE *phGeneral);
    HRESULT CreateAttachedRulePage(HPROPSHEETPAGE *phGeneral);


	//
	// Menu functions
	//
	HRESULT OnEnableTrigger(bool &bHandled, CSnapInObjectRootBase* pObj);
	HRESULT OnDisableTrigger(bool &bHandled, CSnapInObjectRootBase* pObj);
	virtual CString GetHelpLink();

public:

    const _bstr_t& GetTriggerId(void) const
    {
        return m_pTrigger->GetTriggerId();
    }


    const _bstr_t& GetTriggerName(void) const
    {
        return m_pTrigger->GetTriggerName();
    }

    
    const _bstr_t& GetQeuePathName(void) const
    {
        return m_pTrigger->GetQueuePathName();
    }

    
    SystemQueueIdentifier GetQueueType(void) const
    {
        return m_pTrigger->GetQueueType();
    }

    
    long GetNumberOfAttachedRule(void) const
    {
        return m_pTrigger->GetNumberOfAttachedRule();
    }


    bool IsEnabled(void) const
    {
        return m_pTrigger->IsEnabled();
    }


    bool IsSerialize(void) const
    {
        return m_pTrigger->IsSerialize();
    }

	MsgProcessingType GetMsgProcessingType(void) const
	{
		return m_pTrigger->GetMsgProcessingType();
	}

private:
    R<CTrigger> m_pTrigger;

    WCHAR m_strNoOfRules[20];

    CTriggerProp* m_pGeneral;
};



#endif // __TRIGDEF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\trigdef.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	trigdef.cpp

Abstract:
	Implementation for the triggers and rules definition

Author:
    Uri Habusha (urih), 25-Jun-2000

--*/
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "mqppage.h"

#import "mqtrig.tlb" no_namespace

#include "rule.h"
#include "trigger.h"
#include "triggen.h"
#include "trigdef.h"
#include "ruledef.h"
#include "trigprop.h"
#include "newtrig.h"
#include "qname.h"

#include "trigdef.tmh"

static CString s_strYes;
static CString s_strNo;
static CString	s_strPeek;
static CString	s_strReceive;
static CString	s_strReceiveXact;

/****************************************************

CTriggerDefinition Class
    
 ****************************************************/
// {BA3FA90D-70AE-4414-9459-2299E98BC485}
static const GUID CTRiggerDefinitionGUID_NODETYPE = 
{ 0xba3fa90d, 0x70ae, 0x4414, {0x94, 0x59, 0x22, 0x99, 0xe9, 0x8b, 0xc4, 0x85} };

const GUID*  CTriggerDefinition::m_NODETYPE = &CTRiggerDefinitionGUID_NODETYPE;
const OLECHAR* CTriggerDefinition::m_SZNODETYPE = OLESTR("BA3FA90D-70AE-4414-9459-2299E98BC485");
const OLECHAR* CTriggerDefinition::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CTriggerDefinition::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;
  

HRESULT CTriggerDefinition::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    //
    // Display verbs that we support
    //
    HRESULT hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );
    ASSERT(SUCCEEDED(hr));

    return S_OK;
}
                                   

HRESULT CTriggerDefinition::PopulateResultChildrenList()
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());


    try
    {
        m_pTriggerSet->Refresh();
        TriggerList trigList = m_pTriggerSet->GetTriggerList(m_queuePathName);

        for(TriggerList::iterator it = trigList.begin(); it != trigList.end(); ++it)
        {        
            P<CTrigResult> pTrigger = new CTrigResult(this, m_pComponentData, (*it).get());

            AddChildToList(pTrigger);

            pTrigger.detach();
        }
    }
    catch (const _com_error&)
    {
    }
    return S_OK;
}


HRESULT 
CTriggerDefinition::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK /*lpProvider*/,
    LONG_PTR /*handle*/,
	IUnknown* /*pUnk*/,
	DATA_OBJECT_TYPES /*type*/
    )
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return(S_OK);
}


HRESULT 
CTriggerDefinition::OnNewTrigger(
    bool & /*bHandled*/, 
    CSnapInObjectRootBase* /*pSnapInObjectRoot*/
    )
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CNewTrigger newTrig(m_pTriggerSet.get(), m_pRuleSet.get(), m_queuePathName);
    if (newTrig.DoModal() == ID_WIZFINISH)
    {
        Notify(MMCN_REFRESH, 0, 0, m_pComponentData, NULL, CCT_RESULT);
    }

    return(S_OK);
}


CColumnDisplay TriggerDefintionColumn[] = {
    { IDS_TRIGGER_NAME, 80 },
    { IDS_TRIGGER_QUEUE, 150 },
    { IDS_NUM_OF_RULES, 90 },
    { IDS_TRIGGER_ENABLED, 50 },
    { IDS_TRIGGER_SERIALIZED, 60 },
	{ IDS_PROC_TYPE, 150 },
    { IDS_TRIGGER_ID, HIDE_COLUMN },
};


HRESULT 
CTriggerDefinition::InsertColumns(
    IHeaderCtrl* pHeaderCtrl
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
	//
	// Initialize column values
	//
	s_strYes.LoadString(IDS_YES);
	s_strNo.LoadString(IDS_NO);
	s_strPeek.LoadString(IDS_DISPLAY_PEEK);
	s_strReceive.LoadString(IDS_DISPLAY_RECEIVE);
	s_strReceiveXact.LoadString(IDS_DISPLAY_RECEIVE_XACT);

    for (DWORD i = 0; i < ARRAYSIZE(TriggerDefintionColumn); ++i)
    {
        CString title;
        title.LoadString(TriggerDefintionColumn[i].m_columnNameId);

        HRESULT hr = pHeaderCtrl->InsertColumn(
                                        i, 
                                        title, 
                                        LVCFMT_LEFT, 
                                        TriggerDefintionColumn[i].m_width
                                        );
        if (FAILED(hr))
            return hr;
    }

    return(S_OK);
}


CString 
CTriggerDefinition::GetHelpLink( 
	VOID
	)
{
	CString strHelpLink;
    strHelpLink.LoadString(IDS_HELPTOPIC_TRIGGERS);

	return strHelpLink;
}


/****************************************************

CTrigResult Class
    
 ****************************************************/

// {081FFF0E-1922-4f86-9D5F-3664ECAF8968}
static const GUID CTrigResultGUID_NODETYPE = 
{ 0x081fff0e, 0x1922, 0x4f86, {0x9d, 0x5f, 0x36, 0x64, 0xec, 0xaf, 0x89, 0x68} };

const GUID*  CTrigResult::m_NODETYPE = &CTrigResultGUID_NODETYPE;
const OLECHAR* CTrigResult::m_SZNODETYPE = OLESTR("081FFF0E-1922-4f86-9D5F-3664ECAF8968");
const OLECHAR* CTrigResult::m_SZDISPLAY_NAME = OLESTR("MSMQ Admin");
const CLSID* CTrigResult::m_SNAPIN_CLASSID = &CLSID_MSMQSnapin;
  

HRESULT CTrigResult::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    //
    // Display verbs that we support
    //
    HRESULT hr;

    hr = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
    ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
    ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES);
    ASSERT(SUCCEEDED(hr));

    return S_OK;
}


void CTrigResult::UpdateMenuState(UINT id, LPTSTR /*pBuf*/, UINT *pflags)
{

	//
	// Gray out menu when in enable state
	//
	if((id == ID_TASK_ENABLE) && IsEnabled())
	{
        *pflags |= MFS_DISABLED;
		return;
	}

	//
	// Gray out menu when in disable state
	//
	if((id == ID_TASK_DISABLE) && !IsEnabled())
	{
        *pflags |= MFS_DISABLED;
		return;
	}
}


HRESULT 
CTrigResult::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR /*handle*/, 
	IUnknown* /*pUnk*/,
	DATA_OBJECT_TYPES /*type*/
    )
{
   	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	//
	// If the propery page already open bring it to top
	//
	if ((m_pGeneral != NULL) && (m_pGeneral->GetParent() != NULL))
	{		
		(m_pGeneral->GetParent())->BringWindowToTop();
		return S_FALSE;
	}

    //
    // Add general trigger property page
    //
    HPROPSHEETPAGE hGeneralRule = 0;
    HRESULT hr = CreateGenralPage(&hGeneralRule);
    
    if (FAILED(hr))
    {
        AfxMessageBox(IDS_TRIGGER_GENERAL_FAILED, MB_OK | MB_ICONERROR);
        return(S_OK);
    }

    lpProvider->AddPage(hGeneralRule); 


    //
    // Add attached rule page
    //
    
    HPROPSHEETPAGE hAttachedRule = 0;
    hr = CreateAttachedRulePage(&hAttachedRule);
    
    if (FAILED(hr))
    {
        AfxMessageBox(IDS_TRIGGER_ATTACHED_RULE_FAILED, MB_OK | MB_ICONERROR);
        return(S_OK);
    }

    lpProvider->AddPage(hAttachedRule); 

    return S_OK;
}


HRESULT 
CTrigResult::CreateGenralPage(
    HPROPSHEETPAGE *phGeneral
    )
{   
    try
    {
        m_pGeneral = new CViewTriggerProp(this);
    
        HPROPSHEETPAGE hPage = m_pGeneral->CreateThemedPropertySheetPage();
        if (hPage)
        {
            *phGeneral = hPage;
            return S_OK;
        }
    }
    catch (const exception&)
    {
    }

    return E_UNEXPECTED;    
}


HRESULT 
CTrigResult::CreateAttachedRulePage(
    HPROPSHEETPAGE *phAtachedRule
    )
{  
    try
    {
        CAttachedRule* pAttachedRule = new CAttachedRule(this);
    
        HPROPSHEETPAGE hPage = pAttachedRule->CreateThemedPropertySheetPage();
        if (hPage)
        {
            *phAtachedRule = hPage;
            return S_OK;
        }
    }
    catch (const exception&)
    {
    }

    return E_UNEXPECTED;    
}



LPOLESTR CTrigResult::GetResultPaneColInfo(int nCol)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(ARRAYSIZE(TriggerDefintionColumn) >= nCol);

    switch (TriggerDefintionColumn[nCol].m_columnNameId)
    {
        case IDS_TRIGGER_NAME:
            return GetTriggerName();

        case IDS_TRIGGER_ID:
            return GetTriggerId();

        case IDS_TRIGGER_QUEUE:
            return GetQeuePathName();

        case IDS_NUM_OF_RULES:
            swprintf(m_strNoOfRules, L"%d",GetNumberOfAttachedRule());
            return m_strNoOfRules;

        case IDS_TRIGGER_ENABLED:
			if ( IsEnabled() )
			{
				return const_cast<LPWSTR>(static_cast<LPCWSTR>(s_strYes));
			}
			return const_cast<LPWSTR>(static_cast<LPCWSTR>(s_strNo));

        case IDS_TRIGGER_SERIALIZED:
			if ( IsSerialize() )
			{
				return const_cast<LPWSTR>(static_cast<LPCWSTR>(s_strYes));
			}

			return const_cast<LPWSTR>(static_cast<LPCWSTR>(s_strNo));

		case IDS_PROC_TYPE:
			if ( GetMsgProcessingType() == PEEK_MESSAGE )
			{
				return const_cast<LPWSTR>(static_cast<LPCWSTR>(s_strPeek));
			}
			
			if ( GetMsgProcessingType() == RECEIVE_MESSAGE )
			{
				return const_cast<LPWSTR>(static_cast<LPCWSTR>(s_strReceive));
			}

			return const_cast<LPWSTR>(static_cast<LPCWSTR>(s_strReceiveXact));

        default:
            ASSERT(0);
            return _T("");
    }
}


HRESULT CTrigResult::OnEnableTrigger(bool & /*bHandled*/, CSnapInObjectRootBase* /*pObj*/)
{
    try
    {
        m_pTrigger->UpdateEnabled(true);
        return S_OK;
    }
    catch(const _com_error&)
    {
        //
        // BUGBUG: error message
        //
        return E_UNEXPECTED;
    }
}


HRESULT CTrigResult::OnDisableTrigger(bool & /*bHandled*/, CSnapInObjectRootBase* /*pObj*/)
{
    try
    {
        m_pTrigger->UpdateEnabled(false);
        return S_OK;
    }
    catch(const _com_error&)
    {
        //
        // BUGBUG: error message
        //
        return E_UNEXPECTED;
    }
}


HRESULT CTrigResult::OnDelete( 
			LPARAM,
			LPARAM,
			IComponentData* /*pComponentData*/,
			IComponent * /*pComponent*/,
			DATA_OBJECT_TYPES,
            BOOL
			)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString strDeleteQuestion;
    strDeleteQuestion.FormatMessage(IDS_DELETE_QUESTION, static_cast<LPCTSTR>(GetTriggerName()));

    if (IDYES != AfxMessageBox(strDeleteQuestion, MB_YESNO))
    {
        return S_FALSE;
    }

    try
    {
        ASSERT(m_pParentNode != NULL);

        m_pTrigger->Delete();

		//
		// Remove the trigger from result list so next time the reult pane view it will
		// not present the deleted trigger
		//
		R<CTrigResult> ar = this;
		HRESULT hr = static_cast<CTriggerDefinition*>(m_pParentNode)->RemoveChild(this);
		ASSERT(SUCCEEDED(hr));

        return S_OK;
    }
    catch(const _com_error&)
    {
        CString strError;
        strError.FormatMessage(IDS_OP_DELETE, static_cast<LPCWSTR>(GetTriggerName()));

        AfxMessageBox(strError, MB_OK | MB_ICONERROR);

        return S_FALSE;
    }
}


void CTrigResult::OnApply(CTriggerProp* p) throw(_com_error)
{
    m_pTrigger->Update(
                    static_cast<LPCTSTR>(p->m_triggerName),
                    static_cast<LPCTSTR>(p->m_queuePathName),
                    p->m_queueType,
                    (p->m_fEnabled != 0),
                    (p->m_fSerialized != 0),
					p->m_msgProcType
                    );
}


void CTrigResult::OnApply(CAttachedRule* p) throw(_com_error)
{
    m_pTrigger->UpdateAttachedRules(p->GetAttachedRules());
}


RuleList CTrigResult::GetRuleList(void)
{
    CTriggerDefinition* pTrigDef = reinterpret_cast<CTriggerDefinition*>(m_pParentNode);
    return pTrigDef->GetRuleList();
}


RuleList CTrigResult::GetAttachedRulesList(void) throw(_com_error)
{
    CTriggerDefinition* pTrigDef = reinterpret_cast<CTriggerDefinition*>(m_pParentNode);
    R<CRuleSet> pRuleSet = pTrigDef->GetRuleSet();
    
    return m_pTrigger->GetAttachedRules(pRuleSet.get());
}



void 
CTrigResult::Compare(
	CTrigResult* pItem1, 
	CTrigResult* pItem2,
	int* pnResult
	)
{
	LPCWSTR pVal1 = pItem1->GetResultPaneColInfo(*pnResult);
	LPCWSTR pVal2 = pItem2->GetResultPaneColInfo(*pnResult);

	*pnResult = wcscmp(pVal2, pVal1);
}


CString 
CTrigResult::GetHelpLink()
{
	CString strHelpLink;
	strHelpLink.LoadString(IDS_HELPTOPIC_TRIGGERS);
	return strHelpLink;
}


void
CTrigResult::OnDestroyPropertyPages()
{
	m_pGeneral = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\trigprop.cpp ===
// trigprop.cpp : implementation file
//

#include "stdafx.h"
#include "mqsnap.h"
#include "snapin.h"
#include "globals.h"
#include "mqppage.h"

#import "mqtrig.tlb" no_namespace

#include "rule.h"
#include "rulecond.h"
#include "ruleact.h"
#include "trigger.h"
#include "trigdef.h"
#include "trigprop.h"
#include "ruledef.h"
#include "newtrig.h"
#include "mqcast.h"
#include "fn.h"

#include "trigprop.tmh"

using namespace std;


static
HRESULT
IsQueueTransactional(
	LPCWSTR queuePathName,
	LPWSTR queueFormatName,
	bool* isXact
	)
{
	AP<WCHAR> StringToFree;
	LPCWSTR ExpandedPathName;
    QUEUE_PATH_TYPE qpt;
    try
    {
    	qpt = FnValidateAndExpandQueuePath(
        	    queuePathName,
            	&ExpandedPathName,
	            &StringToFree
    	        );
    }
    catch(const bad_alloc&)
    {
    	TrERROR(GENERAL, "Failed to get full path name. Error: %!hresult!", MQ_ERROR_INSUFFICIENT_RESOURCES);
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
    catch(const bad_hresult& err)
    {
	    TrERROR(GENERAL, "Failed to get full path name. Error: %!hresult!", err.error());
		return err.error(); 
    }

    DWORD cPropId = 0;
	MQQUEUEPROPS qprops;
	PROPVARIANT aQueuePropVar[1];
	QUEUEPROPID aQueuePropId[1];
	HRESULT aQueueStatus[1];

	aQueuePropId[cPropId] = PROPID_Q_TRANSACTION; // Property ID
	aQueuePropVar[cPropId].vt = VT_UI1;            // Type indicator
	cPropId++;

	qprops.cProp = cPropId;           // Number of properties
	qprops.aPropID = aQueuePropId;        // Ids of properties
	qprops.aPropVar = aQueuePropVar;      // Values of properties
	qprops.aStatus = aQueueStatus;        // Error reports


	////////////////////////////////////////////////////////////////////
	// Get queue property.
	////////////////////////////////////////////////////////////////////

	//
	// The option to use triggers is enabled only in computer managment on local machine.
	// so for public queues we need to call ADGetObjectProperties() and specify the local machine domain
	//
    HRESULT hr;
	
    switch(qpt)
    {
    case PRIVATE_QUEUE_PATH_TYPE:
		//
		// for Private queues call MQGetQueueProperties
		//
		TrTRACE(GENERAL, "queue %ls is private queue", queuePathName);
		hr = MQGetQueueProperties(queueFormatName, &qprops);
		break;
	case PUBLIC_QUEUE_PATH_TYPE:
		//
		// for Public queues call ADGetObjectProperties and specify the local machine domain
		//
		hr = ADGetObjectProperties(
					eQUEUE,
					LocalMachineDomain(),
					false,	// fServerName
					ExpandedPathName,
					cPropId, 
					aQueuePropId,
					aQueuePropVar
					);
		break;
	default:
		ASSERT(0);
		hr = MQ_ERROR;
		break;
	}
		
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to get PROPID_Q_TRANSACTION for queue %ls, hr = 0x%x", queuePathName, hr);
		return hr;
	}


	if (aQueuePropVar[0].bVal == MQ_TRANSACTIONAL)
	{
		*isXact = true;
	}
	else
	{
		*isXact = false;
	}

	return S_OK;
}


static
bool
ValidateTransactionalQueue(
	CString queuePathName,
	LPWSTR queueFormatName
	)
{
	bool isXact;
	HRESULT hr = IsQueueTransactional(queuePathName, queueFormatName, &isXact);
	if ( FAILED(hr) )
	{
		CString strMessage;
		strMessage.FormatMessage(IDS_XACT_NO_RETRIEVE, queuePathName);
		if (AfxMessageBox(strMessage, MB_YESNO | MB_ICONQUESTION) == IDNO)
		{
			return false;   
		}
	}

	if ( SUCCEEDED(hr) && !isXact )
	{
		CString strError;
		strError.FormatMessage(IDS_QUEUE_NOT_XACT, queuePathName);

		AfxMessageBox(strError);
		return false;   
	}

	return true;
}


/////////////////////////////////////////////////////////////////////////////
// CTriggerProp property page

CTriggerProp::CTriggerProp(
	UINT nIDPage,
	UINT nIdCaption
    ) : 
	CMqPropertyPage(nIDPage, nIdCaption)
{
}


CTriggerProp::~CTriggerProp()
{
}


void CTriggerProp::DoDataExchange(CDataExchange* pDX)
{
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTriggerProp)
	DDX_Check(pDX, IDC_Enabled_CHK, m_fEnabled);
	DDX_Check(pDX, IDC_Serialized_CHK, m_fSerialized);
	//}}AFX_DATA_MAP

	SetMsgProcessingType();
}


/////////////////////////////////////////////////////////////////////////////
// CTriggerProp message handlers

BOOL CTriggerProp::OnInitDialog() 
{
	SetDialogHeading();
	//
	// Initialize the Message Processing Type Property
	//
	if ( m_msgProcType == PEEK_MESSAGE )
	{
		((CButton*)GetDlgItem(IDC_PeekMessage_RDB))->SetCheck(1);
	}
	else if ( m_msgProcType == RECEIVE_MESSAGE )
	{
		((CButton*)GetDlgItem(IDC_ReceiveMessage_RDB))->SetCheck(1);
	}
	else
	{
		((CButton*)GetDlgItem(IDC_ReceiveMessageXact_RDB))->SetCheck(1);
		((CButton*)GetDlgItem(IDC_Serialized_CHK))->SetCheck(1);
		GetDlgItem(IDC_Serialized_CHK)->EnableWindow(FALSE);
	}

	return CMqPropertyPage::OnInitDialog();
}


void CTriggerProp::SetMsgProcessingType(void)
{
    if (((CButton*)GetDlgItem(IDC_PeekMessage_RDB))->GetCheck() == 1)
    {
        m_msgProcType = PEEK_MESSAGE;
    }
    else if (((CButton*)GetDlgItem(IDC_ReceiveMessage_RDB))->GetCheck() == 1)
    {
        m_msgProcType = RECEIVE_MESSAGE;
    }
    else if (((CButton*)GetDlgItem(IDC_ReceiveMessageXact_RDB))->GetCheck() == 1)
    {
        m_msgProcType = RECEIVE_MESSAGE_XACT;
    }
    else
    {
        ASSERT(0);
        m_msgProcType = PEEK_MESSAGE;
    }
}


void CTriggerProp::OnReceiveXact() 
{
    CMqPropertyPage::OnChangeRWField();

	//
	// If ReceiveXact is really selected, set and disable the serialized check box
	//
	if (((CButton*)GetDlgItem(IDC_ReceiveMessageXact_RDB))->GetCheck() == 1)
	{
		((CButton*)GetDlgItem(IDC_Serialized_CHK))->SetCheck(1);
		GetDlgItem(IDC_Serialized_CHK)->EnableWindow(FALSE);
	}
}


void CTriggerProp::OnReceiveOrPeek() 
{
    CMqPropertyPage::OnChangeRWField();

	if ((((CButton*)GetDlgItem(IDC_ReceiveMessage_RDB))->GetCheck() == 1) ||
		(((CButton*)GetDlgItem(IDC_PeekMessage_RDB))->GetCheck() == 1))
	{
		GetDlgItem(IDC_Serialized_CHK)->EnableWindow(TRUE);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CNewTriggerProp page


CNewTriggerProp::CNewTriggerProp(
    CNewTrigger* pParent,
    LPCTSTR queuePathName
    ) : 
    m_pNewTrig(pParent),
	CTriggerProp(CNewTriggerProp::IDD, IDS_NEW_TRIGGER_CAPTION)
{
	m_triggerName = _T("");
	m_queuePathName = queuePathName;
    m_queueType = SYSTEM_QUEUE_NONE;
	m_fEnabled = TRUE;
	m_fSerialized = FALSE;
	m_msgProcType = PEEK_MESSAGE;
}


void CNewTriggerProp::DDV_ValidQueuePathName(CDataExchange* pDX, CString& queuePathName)
{
    if (!pDX->m_bSaveAndValidate)
        return;

    if (m_queueType != SYSTEM_QUEUE_NONE)
        return;

    if (queuePathName.IsEmpty())
    {
        AfxMessageBox(IDS_MISSING_QUEUE_PATHNAME);
        pDX->Fail();
        return;
    }

    WCHAR queueFormatName[256];
    DWORD length = ARRAYSIZE(queueFormatName);

    HRESULT hr = MQPathNameToFormatName(queuePathName, queueFormatName, &length);

    if (hr == MQ_ERROR_ILLEGAL_QUEUE_PATHNAME)
    {
       AfxMessageBox(IDS_ILLEGAL_QUEUE_PATH);
       pDX->Fail();
       return;
    }

    if (hr == MQ_ERROR_QUEUE_NOT_FOUND)
    {
        CString strError;
        strError.FormatMessage(IDS_QUEUE_NOT_REGISTER, queuePathName);

        AfxMessageBox(strError);
        pDX->Fail();
        return;

    }

	//
	// Operation not supported in workgroup - this error will return 
	// when processing public queue pathname while in workgroup mode
	//
	if (hr == MQ_ERROR_UNSUPPORTED_OPERATION)
	{
		CString strIllegal;
		strIllegal.LoadString(IDS_ILLEGAL_QUEUE_PATH);

		CString strWorkgroup;
		strWorkgroup.LoadString(IDS_PUBLIC_PATHNAME_IN_WORKGROUP);

		AfxMessageBox(strIllegal + L"\n" + strWorkgroup);
        pDX->Fail();
        return;
	}

    if ((hr == MQ_ERROR_SERVICE_NOT_AVAILABLE) || 
        (hr == MQ_ERROR_NO_DS))
    {
        if (AfxMessageBox(IDS_QUEUE_NOT_VALIDATE, MB_YESNO | MB_ICONQUESTION) == IDYES)
           return;

        pDX->Fail();
        return;
    }

	//
	// This is the handler for all other error cases
	// Just inform about illegal pathname
	//
	if ( FAILED(hr) )
	{
       AfxMessageBox(IDS_ILLEGAL_QUEUE_PATH);
       pDX->Fail();
       return;
	}

	if (m_msgProcType == RECEIVE_MESSAGE_XACT)
	{
		if ( !ValidateTransactionalQueue(queuePathName, queueFormatName) )
		{
			pDX->Fail();
			return;   
		}
	}

}


void CNewTriggerProp::SetQueueType(void)
{
    if (((CButton*)GetDlgItem(IDC_QueueMessages_RDB))->GetCheck() == 1)
    {
        m_queueType = SYSTEM_QUEUE_NONE;
    }
    else if (((CButton*)GetDlgItem(IDC_JournalMessages_RDB))->GetCheck() == 1)
    {
        m_queueType = SYSTEM_QUEUE_JOURNAL;
    }
    else if (((CButton*)GetDlgItem(IDC_DeadlLetter_RDB))->GetCheck() == 1)
    {
        m_queueType = SYSTEM_QUEUE_DEADLETTER;
    }
    else if (((CButton*)GetDlgItem(IDC_TransactionalDeadLetter_RDB))->GetCheck() == 1)
    {
        m_queueType = SYSTEM_QUEUE_DEADXACT;
    }
    else
    {
        ASSERT(0);
        m_queueType = SYSTEM_QUEUE_NONE;
    }
}


void CNewTriggerProp::DoDataExchange(CDataExchange* pDX)
{
	CTriggerProp::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CNewTriggerProp)
	DDX_Text(pDX, IDC_TriggerName_EDIT, m_triggerName);
    DDV_NotEmpty(pDX, m_triggerName, IDS_MISSING_TRIGGER_NAME);
	DDX_Text(pDX, IDC_QueuePathName, m_queuePathName);
	//}}AFX_DATA_MAP

    SetQueueType();
    DDV_ValidQueuePathName(pDX, m_queuePathName);
}


BEGIN_MESSAGE_MAP(CNewTriggerProp, CTriggerProp)
	//{{AFX_MSG_MAP(CNewTriggerProp)
	ON_BN_CLICKED(IDC_QueueMessages_RDB, OnQueueMessages)
	ON_BN_CLICKED(IDC_JournalMessages_RDB, OnSystemQueue)
	ON_BN_CLICKED(IDC_DeadlLetter_RDB, OnSystemQueue)
	ON_BN_CLICKED(IDC_TransactionalDeadLetter_RDB, OnSystemQueue)
	ON_EN_CHANGE(IDC_TriggerName_EDIT, OnChangeRWField)
	ON_BN_CLICKED(IDC_Enabled_CHK, OnChangeRWField)
	ON_BN_CLICKED(IDC_Serialized_CHK, OnChangeRWField)
	ON_EN_CHANGE(IDC_QueuePathName, OnChangeRWField)
	ON_BN_CLICKED(IDC_PeekMessage_RDB, OnReceiveOrPeek)
	ON_BN_CLICKED(IDC_ReceiveMessage_RDB, OnReceiveOrPeek)
	ON_BN_CLICKED(IDC_ReceiveMessageXact_RDB, OnReceiveXact)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CNewTriggerProp::OnInitDialog() 
{

	if (m_queuePathName != _T(""))
    {
        //
        // Queue path name was specified. The new trigger wizard was called for a 
        // specific queue. disable the queue windows
        //
        ((CButton*)GetDlgItem(IDC_QueueMessages_RDB))->SetCheck(1);
        GetDlgItem(IDC_QueuePathName)->EnableWindow(FALSE);
        GetDlgItem(IDC_QueueMessages_RDB)->EnableWindow(FALSE);
        GetDlgItem(IDC_JournalMessages_RDB)->EnableWindow(FALSE);
        GetDlgItem(IDC_DeadlLetter_RDB)->EnableWindow(FALSE);
        GetDlgItem(IDC_TransactionalDeadLetter_RDB)->EnableWindow(FALSE);

	    return CTriggerProp::OnInitDialog();
    }

    ((CButton*)GetDlgItem(IDC_QueueMessages_RDB))->SetCheck(1);

	return CTriggerProp::OnInitDialog();
}


void CNewTriggerProp::OnQueueMessages() 
{
    CMqPropertyPage::OnChangeRWField();
	if(((CButton*)GetDlgItem(IDC_QueueMessages_RDB))->GetCheck() == 1) 
	{
		GetDlgItem(IDC_QueuePathName)->EnableWindow(TRUE);
		GetDlgItem(IDC_ReceiveMessageXact_RDB)->EnableWindow(TRUE);
	}
}


void CNewTriggerProp::OnSystemQueue() 
{
    CMqPropertyPage::OnChangeRWField();

	//
	// If no one of the system queues was choosen; no further change is required.
	//
	if ((((CButton*)GetDlgItem(IDC_JournalMessages_RDB))->GetCheck() == 0) &&
		(((CButton*)GetDlgItem(IDC_DeadlLetter_RDB))->GetCheck() == 0) &&
		(((CButton*)GetDlgItem(IDC_TransactionalDeadLetter_RDB))->GetCheck() == 0))
		return;

    GetDlgItem(IDC_QueuePathName)->EnableWindow(FALSE);
	
	if ( ((CButton*)GetDlgItem(IDC_ReceiveMessageXact_RDB))->GetCheck() == 1 )
	{
		((CButton*)GetDlgItem(IDC_ReceiveMessageXact_RDB))->SetCheck(0);
		((CButton*)GetDlgItem(IDC_PeekMessage_RDB))->SetCheck(1);
		GetDlgItem(IDC_Serialized_CHK)->EnableWindow(TRUE);
	}

	GetDlgItem(IDC_ReceiveMessageXact_RDB)->EnableWindow(FALSE);
}


BOOL CNewTriggerProp::OnSetActive() 
{
    return m_pNewTrig->SetWizardButtons();
}



/////////////////////////////////////////////////////////////////////////////
// CViewTriggerProp page

CViewTriggerProp::CViewTriggerProp(
    CTrigResult* pParent
    ) : 
    m_pParent(SafeAddRef(pParent)),
	CTriggerProp(CViewTriggerProp::IDD)
{
	//{{AFX_DATA_INIT(CTriggerProp)
	m_fEnabled = pParent->IsEnabled();
	m_fSerialized = pParent->IsSerialize();
	m_triggerName = static_cast<LPCTSTR>(pParent->GetTriggerName());
	m_queuePathName = static_cast<LPCTSTR>(pParent->GetQeuePathName());
	m_queueType = pParent->GetQueueType();
	m_msgProcType = pParent->GetMsgProcessingType();
	m_initMsgProcessingType = m_msgProcType;
	//}}AFX_DATA_INIT

	InitQueueDisplayName();
}


CViewTriggerProp::~CViewTriggerProp(
	VOID
	)
{
	ASSERT(m_pParent.get() != NULL);
	m_pParent->OnDestroyPropertyPages();
}


void CViewTriggerProp::DoDataExchange(CDataExchange* pDX)
{
	CTriggerProp::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CViewTriggerProp)
	DDX_Text(pDX, IDC_Monitored_Queue, m_strDisplayQueueName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CViewTriggerProp, CTriggerProp)
	//{{AFX_MSG_MAP(CViewTriggerProp)
	ON_BN_CLICKED(IDC_Enabled_CHK, OnChangeRWField)
	ON_BN_CLICKED(IDC_Serialized_CHK, OnChangeRWField)
	ON_BN_CLICKED(IDC_PeekMessage_RDB, OnReceiveOrPeek)
	ON_BN_CLICKED(IDC_ReceiveMessage_RDB, OnReceiveOrPeek)
	ON_BN_CLICKED(IDC_ReceiveMessageXact_RDB, OnReceiveXact)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


void CViewTriggerProp::InitQueueDisplayName()
{
	if (m_queueType == SYSTEM_QUEUE_NONE)
	{
		m_strDisplayQueueName = m_queuePathName;
	}
	else if (m_queueType == SYSTEM_QUEUE_JOURNAL)
	{
		m_strDisplayQueueName.LoadString(IDS_COMPUTER_JOURNAL);
	}
	else if (m_queueType == SYSTEM_QUEUE_DEADLETTER)
	{
		m_strDisplayQueueName.LoadString(IDS_COMPUTER_DEADLETTER);
	}
	else
	{
		m_strDisplayQueueName.LoadString(IDS_COMPUTER_XACT_DEADLETTER);
	}
}


void CViewTriggerProp::SetDialogHeading()
{
	SetDlgItemText(IDC_TRIGGER_GENERAL_HEADER, m_triggerName);
}


BOOL CViewTriggerProp::OnInitDialog() 
{
	if ( m_queueType != SYSTEM_QUEUE_NONE)
	{
		GetDlgItem(IDC_ReceiveMessageXact_RDB)->EnableWindow(FALSE);
	}

	return CTriggerProp::OnInitDialog();
}


BOOL CViewTriggerProp::OnApply() 
{
	if (!m_fModified)
	{
		return TRUE;
	}

    UpdateData();

    try
    {
		//
		// Do not perform queue path check if message proccessing type
		// was not changed. This was already done on trigger creation.
		// 
		if (m_initMsgProcessingType !=  m_msgProcType &&
			m_msgProcType == RECEIVE_MESSAGE_XACT)
		{
		    WCHAR queueFormatName[256];
			DWORD length = ARRAYSIZE(queueFormatName);

			HRESULT hr = MQPathNameToFormatName(m_queuePathName, queueFormatName, &length);
			if ( FAILED(hr) )
			{
				CString strMessage;
				strMessage.FormatMessage(IDS_XACT_NO_RETRIEVE, m_queuePathName);

				if (AfxMessageBox(strMessage, MB_YESNO | MB_ICONQUESTION) == IDNO)
				{
					return FALSE;   
				}
			}

			if( SUCCEEDED(hr) && 
				!ValidateTransactionalQueue(m_queuePathName, queueFormatName) )
			{
				return FALSE;
			}
		}
				
		ASSERT(m_pParent.get() != NULL);
        m_pParent->OnApply(this);
    }
    catch(const _com_error& e)
    {
		CString strError;

		if (e.Error() == MQTRIG_ERROR_MULTIPLE_RECEIVE_TRIGGER)
		{
			AfxMessageBox(IDS_MULTIPLERECEIVE_TRIGGER, MB_OK | MB_ICONEXCLAMATION);
			return FALSE;
		}

		if (e.Error() == MQTRIG_TRIGGER_NOT_FOUND)
		{
			ASSERT(m_pParent.get() != NULL);

			strError.FormatMessage(IDS_TRIGGER_ALREADY_DELETED, static_cast<LPCWSTR>(m_pParent->GetTriggerName()));
			AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);
			return FALSE;
		}


		strError.FormatMessage(IDS_TRIGGER_UPDATE_FAILED, e.Error());
        AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);

        return FALSE;
    }

	OnChangeRWField(FALSE);
	return CTriggerProp::OnApply();
}


/////////////////////////////////////////////////////////////////////////////
// CAttachedRule dialog


CAttachedRule::CAttachedRule(
    CTrigResult* pParent
    ) : 
	CMqPropertyPage(CAttachedRule::IDD_VIEW),
    m_pParent(SafeAddRef(pParent)),
    m_pNewTrig(NULL)
{
	//{{AFX_DATA_INIT(CAttachedRule)
	//}}AFX_DATA_INIT
    m_attachedRuleList = m_pParent->GetAttachedRulesList();

	BuildExistingRulesList();
}


CAttachedRule::CAttachedRule(
    CNewTrigger* pParent
    ) : 
    CMqPropertyPage(CAttachedRule::IDD_NEW, IDS_NEW_TRIGGER_CAPTION),
    m_pParent(NULL),
    m_pNewTrig(pParent)
{
	//{{AFX_DATA_INIT(CAttachedRule)
	//}}AFX_DATA_INIT
    m_existingRuleList = m_pNewTrig->GetRuleList();
}


bool CAttachedRule::IsAttachedRule(const _bstr_t& id)
{
    for(RuleList::iterator it = m_attachedRuleList.begin(); it != m_attachedRuleList.end(); ++it)
    {
        if ((*it)->GetRuleId() == id)
            return true;
    }

    return false;
}


void CAttachedRule::BuildExistingRulesList()
{
	m_existingRuleList = m_pParent->GetRuleList();
    
    for(RuleList::iterator it = m_existingRuleList.begin(); it != m_existingRuleList.end();)
    {
        if(IsAttachedRule((*it)->GetRuleId()))
        {
            it = m_existingRuleList.erase(it);
			continue;
        }
		
		++it;
    }
}


void CAttachedRule::SetScrollSize() 
{
	SetScrollSizeForList(m_pAttachedRuleList);
	SetScrollSizeForList(m_pExistingRuleList);
}


//
// Selection functions
// Handle different configurations of selection
// For example, if only one attached rule is selected, all actions for
// attached rules are allowed, but if more that one attached rule is selected
// only detaching is allowed (up/down forbidden for multiple selection).
//
void CAttachedRule::SetAttachedNoOrSingleSelectionButtons(bool fSingleSelection) 
{
	GetDlgItem(IDC_RemoveRule_BTM)->EnableWindow(fSingleSelection);
	GetDlgItem(IDC_UpRule_BTM)->EnableWindow(fSingleSelection);
	GetDlgItem(IDC_Down_BTM)->EnableWindow(fSingleSelection);
	GetDlgItem(IDC_ATTACHED_RULE_PROPS)->EnableWindow(fSingleSelection);
}


void CAttachedRule::SetAttachedMultipleSelectionButtons() 
{
	GetDlgItem(IDC_RemoveRule_BTM)->EnableWindow(TRUE);
	GetDlgItem(IDC_UpRule_BTM)->EnableWindow(FALSE);
	GetDlgItem(IDC_Down_BTM)->EnableWindow(FALSE);
	GetDlgItem(IDC_ATTACHED_RULE_PROPS)->EnableWindow(FALSE);
}


void CAttachedRule::SetExistingNoOrSingleSelectionButtons(bool fSingleSelection) 
{
	GetDlgItem(IDC_ATTACH_RULES_BTM)->EnableWindow(fSingleSelection);
	GetDlgItem(IDC_EXISTING_RULE_PROPS)->EnableWindow(fSingleSelection);
}


void CAttachedRule::SetExistingMultipleSelectionButtons() 
{
	GetDlgItem(IDC_ATTACH_RULES_BTM)->EnableWindow(TRUE);
	GetDlgItem(IDC_EXISTING_RULE_PROPS)->EnableWindow(FALSE);
}


void CAttachedRule::Display(int dwAttachedSelIndex, int dwExistSelIndex)
{

    m_pAttachedRuleList->ResetContent();
	m_pExistingRuleList->ResetContent();

	//
	// Display attached rules
	//
    DWORD index = 0;
    for(RuleList::iterator it = m_attachedRuleList.begin(); it != m_attachedRuleList.end(); ++it)
    {
		m_pAttachedRuleList->InsertString(index, (*it)->GetRuleName());

        ++index;
    }

	//
	// Display existing rules
	//
    for(RuleList::iterator it = m_existingRuleList.begin(); it != m_existingRuleList.end(); ++it)
    {
		int pos = m_pExistingRuleList->AddString((*it)->GetRuleName());
		m_pExistingRuleList->SetItemDataPtr(pos, (*it).get());
    }

	bool fSingleSelection = ( m_attachedRuleList.size() != 0 );
	
	SetAttachedNoOrSingleSelectionButtons(fSingleSelection);

	fSingleSelection = ( m_existingRuleList.size() != 0 );
	
	SetExistingNoOrSingleSelectionButtons(fSingleSelection);


	m_pAttachedRuleList->SetSel(dwAttachedSelIndex);
	m_pExistingRuleList->SetSel(dwExistSelIndex);

	SetScrollSize();
}


BEGIN_MESSAGE_MAP(CAttachedRule, CMqPropertyPage)
	//{{AFX_MSG_MAP(CAttachedRule)
	ON_BN_CLICKED(IDC_ATTACH_RULES_BTM, OnAttachRule)
	ON_BN_CLICKED(IDC_RemoveRule_BTM, OnDetachRule)
	ON_LBN_DBLCLK(IDC_RULE_LIST, OnAttachRule)
	ON_LBN_DBLCLK(IDC_ATTACHED_RULE_LIST, OnDetachRule)
	ON_BN_CLICKED(IDC_UpRule_BTM, OnUpRule)
	ON_BN_CLICKED(IDC_Down_BTM, OnDownRule)
	ON_BN_CLICKED(IDC_ATTACHED_RULE_PROPS, OnViewAttachedRulesProperties)
	ON_BN_CLICKED(IDC_EXISTING_RULE_PROPS, OnViewExistingRulesProperties)
	ON_LBN_SELCHANGE(IDC_ATTACHED_RULE_LIST, OnAttachedSelChanged)
	ON_LBN_SELCHANGE(IDC_RULE_LIST, OnExistingSelChanged)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CAttachedRule message handlers

BOOL CAttachedRule::OnInitDialog() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    m_pAttachedRuleList = (CListBox*)GetDlgItem(IDC_ATTACHED_RULE_LIST);
	m_pExistingRuleList = (CListBox*)GetDlgItem(IDC_RULE_LIST);
     
    Display(0, 0);

    return CMqPropertyPage::OnInitDialog();
}


void CAttachedRule::OnDetachRule() 
{
    int numSel = m_pAttachedRuleList->GetSelCount();
	ASSERT(numSel != 0);

	AP<int> pSelItems = new int[numSel];
	
	int nSucc = m_pAttachedRuleList->GetSelItems(numSel, pSelItems);
	ASSERT(("Did not get all selections", nSucc == numSel));

	bool fLastSelected = (pSelItems[numSel-1] == numeric_cast<int>(m_attachedRuleList.size()-1));
    DWORD noOfDeletedRules = 0;

    for (int i = 0; i < numSel; i++)
    {
		DWORD nItem = pSelItems[i] - noOfDeletedRules;

        for(RuleList::iterator it = m_attachedRuleList.begin(); it != m_attachedRuleList.end(); ++it)
        {
            if (nItem == 0)
            {
                R<CRule> pRule = *it;

                m_attachedRuleList.erase(it);
				m_existingRuleList.push_back(pRule);
                break;
            }
            --nItem;
        }
        ++noOfDeletedRules;
    }
    
	Display(
		pSelItems[numSel-1] - noOfDeletedRules + (fLastSelected ? 0 : 1), 
		0
		);
    
	CMqPropertyPage::OnChangeRWField();
}


void CAttachedRule::OnAttachRule() 
{ 
    int numSel = m_pExistingRuleList->GetSelCount();
	ASSERT(numSel != 0);

	AP<int> pSelItems = new int[numSel];
	
	int nSucc = m_pExistingRuleList->GetSelItems(numSel, pSelItems);
	ASSERT(("Did not get all selections", nSucc == numSel));

	DWORD noOfDeletedRules = 0;
	bool fLastSelected = (pSelItems[numSel-1] == numeric_cast<int>(m_existingRuleList.size()-1));

    for (int i = 0; i < numSel; i++)
    {
		void* pSelectedRule = m_pExistingRuleList->GetItemDataPtr(pSelItems[i]);

		for(RuleList::iterator it = m_existingRuleList.begin(); it != m_existingRuleList.end(); ++it)
        {
            R<CRule> pRule = *it;

			//
			// Check pointer to rule to distinguish between rules with identical names
			//
			if (pRule.get() == pSelectedRule)
			{
				m_existingRuleList.erase(it);
				m_attachedRuleList.push_back(pRule);
				break;
			}
        }
        ++noOfDeletedRules;
    }

    Display(
		numeric_cast<int>(m_attachedRuleList.size()-1), 
		pSelItems[numSel-1] - noOfDeletedRules + (fLastSelected ? 0 : 1)
		);

    CMqPropertyPage::OnChangeRWField();
}


void CAttachedRule::OnUpRule() 
{
    ASSERT(m_pAttachedRuleList->GetSelCount() == 1);

	int nItem;
    int nSucc = m_pAttachedRuleList->GetSelItems(1, &nItem);
	ASSERT(("Did not get all selections", nSucc == 1));

    if (nItem == 0)
    {
        m_pAttachedRuleList->SetSel(0);
        return;
    }

    int newIndex = nItem - 1;
    m_pAttachedRuleList->DeleteString(nItem);

    RuleList::iterator preit = NULL;
    for(RuleList::iterator it = m_attachedRuleList.begin(); it != m_attachedRuleList.end(); ++it)
    {
        if (nItem == 0)
        {
            R<CRule> pRule = *it;
            m_attachedRuleList.erase(it);
            m_attachedRuleList.insert(preit, pRule);

            m_pAttachedRuleList->InsertString(newIndex, pRule->GetRuleName());
            break;
        }
         
        preit = it;
        --nItem;
    }

    m_pAttachedRuleList->SetSel(newIndex);

    CMqPropertyPage::OnChangeRWField();
}


void CAttachedRule::OnDownRule() 
{
    ASSERT(m_pAttachedRuleList->GetSelCount() == 1);

	int nItem;
    int nSucc = m_pAttachedRuleList->GetSelItems(1, &nItem);
	ASSERT(("Did not get all selections", nSucc == 1));

    if ( (numeric_cast<DWORD>(nItem + 1))  == m_attachedRuleList.size() )
    {
		m_pAttachedRuleList->SetSel(nItem);
        return;
    }

    int newIndex = nItem + 1;
    m_pAttachedRuleList->DeleteString(nItem);

    for(RuleList::iterator it = m_attachedRuleList.begin(); it != m_attachedRuleList.end(); ++it)
    {
        if (nItem == 0)
        {
            R<CRule> pRule = *it;
            it = m_attachedRuleList.erase(it);
            ++it;
            m_attachedRuleList.insert(it, pRule);

            m_pAttachedRuleList->InsertString(newIndex, pRule->GetRuleName());
            break;
        }

        --nItem;
    }

    m_pAttachedRuleList->SetSel(newIndex);

    CMqPropertyPage::OnChangeRWField();	
}


BOOL CAttachedRule::OnApply() 
{
	if (m_fModified)
    {
        try
        {
            m_pParent->OnApply(this);
        }
        catch(_com_error&)
        {
            //
            // BUGBUG: Error message
            //
            return FALSE;
        }
    }

    CMqPropertyPage::OnChangeRWField(false);
	return CMqPropertyPage::OnApply();
}



BOOL CAttachedRule::OnSetActive() 
{
    if (m_pNewTrig == NULL)
        return TRUE;

    return m_pNewTrig->SetWizardButtons();
}


BOOL CAttachedRule::OnWizardFinish()
{
    //
    // We reach here only when creating a new trigger
    //
    ASSERT(m_pNewTrig != NULL);
    
    UpdateData();

    try
    {
        m_pNewTrig->OnFinishCreateTrigger();
        return TRUE;
    }
    catch(const _com_error& e)
    {
		DisplayErrorFromCOM(IDS_NEW_TRIGGER_FAILED, e);
        return FALSE;
    }
}


void CAttachedRule::OnViewAttachedRulesProperties() 
{
    ASSERT(m_pAttachedRuleList->GetSelCount() == 1);

	int nItem;
    int nSucc = m_pAttachedRuleList->GetSelItems(1, &nItem);
	ASSERT(("Did not get all selections", nSucc == 1));

    R<CRule> pRule;
	int index = 0;
    for(RuleList::iterator it = m_attachedRuleList.begin(); it != m_attachedRuleList.end(); ++it, index++)
    {
        if (index == nItem)
        {
			pRule = *it;
            break;
        }
    }

	DisplaySingleRuleProperties(pRule.get());
}


void CAttachedRule::OnViewExistingRulesProperties() 
{
    ASSERT(m_pExistingRuleList->GetSelCount() == 1);

	int nItem;
    int nSucc = m_pExistingRuleList->GetSelItems(1, &nItem);
	ASSERT(("Did not get all selections", nSucc == 1));

	void* pSelectedRule = m_pExistingRuleList->GetItemDataPtr(nItem);

    R<CRule> pRule;
    for(RuleList::iterator it = m_existingRuleList.begin(); it != m_existingRuleList.end(); ++it)
    {
	    pRule = *it;

		if (pRule.get() == pSelectedRule)
		{
				break;
        }
    }

	DisplaySingleRuleProperties(pRule.get());
}


void CAttachedRule::DisplaySingleRuleProperties(CRule* pRule)
{
	m_rule = SafeAddRef(pRule);

	AP<WCHAR> pRuleName = new WCHAR[wcslen(m_rule->GetRuleName()) + 1];
	wcscpy(pRuleName, m_rule->GetRuleName());
	
	CString strPropSheetTitle;
	strPropSheetTitle.FormatMessage(IDS_PROPERTIES, pRuleName);
	
	CPropertySheetEx rulePropSheet(strPropSheetTitle);
	
	m_pGeneral = new CViewRuleGeneral(this, m_rule->GetRuleName(), m_rule->GetRuleDescription());
	rulePropSheet.AddPage(m_pGeneral);

	m_pCond = new CRuleCondition(this, m_rule->GetRuleCondition());
	rulePropSheet.AddPage(m_pCond);

	m_pAction = new CRuleAction(this, m_rule->GetRuleAction(), m_rule->GetShowWindow());
	rulePropSheet.AddPage(m_pAction);

	rulePropSheet.DoModal();
}


void CAttachedRule::OnAttachedSelChanged()
{
	int nSel = m_pAttachedRuleList->GetSelCount();

	if (nSel == 0 || nSel == 1)
	{
		SetAttachedNoOrSingleSelectionButtons(nSel == 1);
		return;
	}

	SetAttachedMultipleSelectionButtons();
}


void CAttachedRule::OnExistingSelChanged()
{
	int nSel = m_pExistingRuleList->GetSelCount();

	if (nSel == 0 || nSel == 1)
	{
		SetExistingNoOrSingleSelectionButtons(nSel == 1);
		return;
	}

	SetExistingMultipleSelectionButtons();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\usercert.cpp ===
// UserCert.cpp : Implementation of CUserCertificate
#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "globals.h"
#include "mqcert.h"
#include "rtcert.h"
#include "mqPPage.h"
#include "UserCert.h"
#include "CertGen.h"
#include <adsiutl.h>

#include "usercert.tmh"



/////////////////////////////////////////////////////////////////////////////
// CUserCertificate

HRESULT
CUserCertificate::InitializeUserSid(
    LPCWSTR lpcwstrLdapName
    )
{
    //
    // bind to the obj
    //
    R<IADs> pIADs;
    CoInitialize(NULL);

	AP<WCHAR> pEscapeAdsPathNameToFree;

	HRESULT	hr = ADsOpenObject(
					UtlEscapeAdsPathName(lpcwstrLdapName, pEscapeAdsPathNameToFree),
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**) &pIADs
					);
	
    if (FAILED(hr))
    {
        TrERROR(GENERAL, "CUserCertificate::InitializeUserSid. ADsOpenObject failed. User - %ls, hr - %x", lpcwstrLdapName, hr);
        return hr;
    }

	VARIANT var;
    VariantInit(&var);

    //
    // Get the SID as a safe array
    //
    hr = pIADs->Get(GetSidPropertyName(), &var);
    if (FAILED(hr))
    {
        TrERROR(GENERAL, "CUserCertificate::InitializeUserSid. pIADs->Get failed. User - %ls, hr - %x", lpcwstrLdapName, hr);
        VariantClear(&var);
        return hr;
    }

	if (var.vt != (VARTYPE)(VT_ARRAY | VT_UI1))
    {
        ASSERT(0);
        VariantClear(&var);
        TrERROR(GENERAL, "CUserCertificate::InitializeUserSid. User - %ls, Wrong VT %x", lpcwstrLdapName, var.vt);
        hr = MQ_ERROR_ILLEGAL_PROPERTY_VT;
        return hr;
    }

    //
    // Extract value out of the safe array, to m_psid
    //
    ASSERT(SafeArrayGetDim(var.parray) == 1);

    LONG    lUbound;
    LONG    lLbound;

    SafeArrayGetUBound(var.parray, 1, &lUbound);
    SafeArrayGetLBound(var.parray, 1, &lLbound);
    LONG len = lUbound - lLbound + 1;

    ASSERT(0 == m_psid);
    m_psid = new BYTE[len];

    for ( long i = 0; i < len; i++)
    {
        hr = SafeArrayGetElement(var.parray, &i, m_psid + i);
        if (FAILED(hr))
        {
            TrERROR(GENERAL, "CUserCertificate::InitializeUserSid. SafeArrayGetElement failed. User - %ls, Wrong VT %x", lpcwstrLdapName, var.vt);
            VariantClear(&var);
            return hr;
        }
    }

    VariantClear(&var);
    return hr;
}


HRESULT
CUserCertificate::InitializeMQCretificate(
    void
    )
{
    HRESULT hr;

    delete [] m_pMsmqCertificate;
    m_pMsmqCertificate = NULL;
    m_NumOfCertificate = 0;
    //
    // Get the number of Certificate
    //
    hr = RTGetUserCerts(NULL, &m_NumOfCertificate, m_psid);
    if (FAILED(hr))
    {
        return hr;
    }

    m_pMsmqCertificate = new CMQSigCertificate*[m_NumOfCertificate];

    CMQSigCertificate **pCerts = &m_pMsmqCertificate[0];
    hr = RTGetUserCerts(pCerts, &m_NumOfCertificate, m_psid);

    return hr;
}


//
// IShellExtInit
//
STDMETHODIMP CUserCertificate::Initialize (
    LPCITEMIDLIST /*pidlFolder*/,
    LPDATAOBJECT lpdobj,
    HKEY /*hkeyProgID*/
    )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    if (0 == lpdobj || IsBadReadPtr(lpdobj, sizeof(LPDATAOBJECT)))
    {
        return E_INVALIDARG;
    }

    //
    // Gets the LDAP path
    //
    STGMEDIUM stgmedium =  {  TYMED_HGLOBAL,  0  };
    FORMATETC formatetc =  {  0, 0,  DVASPECT_CONTENT,  -1,  TYMED_HGLOBAL  };

	LPDSOBJECTNAMES pDSObj;
	
	formatetc.cfFormat = DWORD_TO_WORD(RegisterClipboardFormat(CFSTR_DSOBJECTNAMES));
	hr = lpdobj->GetData(&formatetc, &stgmedium);

    if (SUCCEEDED(hr))
    {
        ASSERT(0 != stgmedium.hGlobal);
        CGlobalPointer gpDSObj(stgmedium.hGlobal); // Automatic release
        stgmedium.hGlobal = 0;

        pDSObj = (LPDSOBJECTNAMES)(HGLOBAL)gpDSObj;
		m_lpwstrLdapName = (LPCWSTR)((BYTE*)pDSObj + pDSObj->aObjects[0].offsetName);
    }

    return hr;
}


STDMETHODIMP
CUserCertificate::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam
    )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (0 == m_psid)
    {
        HRESULT hr = InitializeUserSid(m_lpwstrLdapName);
        if (FAILED(hr))
        {
            TrERROR(GENERAL, "CUserCertificate::AddPages. InitializeUserSid failed. hr - %x", hr);
            return E_UNEXPECTED;
        }

        hr = InitializeMQCretificate();
        if (FAILED(hr))
        {
            TrERROR(GENERAL, "CUserCertificate::AddPages. InitializeMQCretificate failed. hr - %x", hr);
            return E_UNEXPECTED;
        }
    }

    //
    // Display the property page only if exist MSMQ
    // personal certificate
    //
    if (m_NumOfCertificate != 0)
    {
        HPROPSHEETPAGE hPage = CreateMSMQCertificatePage();
        if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
        {
            ASSERT(0);
            return E_UNEXPECTED;
        }
    }

    return S_OK;
}


CUserCertificate::CUserCertificate() :
    m_psid(NULL),
    m_pMsmqCertificate(NULL),
    m_NumOfCertificate(0)
{
}


CUserCertificate::~CUserCertificate()
{
    delete [] m_psid;
    //
    // Don't delete m_pMsmqCertificate. The class pass it to
    // CCertGen class that will release it when destruct
    //
}

HPROPSHEETPAGE
CUserCertificate::CreateMSMQCertificatePage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(m_NumOfCertificate != 0);

    //
    // Note: CEnterpriseDataObject is auto-delete by default
    //
	CCertGen  *pGeneral = new CCertGen();
    pGeneral->Initialize( m_pMsmqCertificate,
                          m_NumOfCertificate,
                          reinterpret_cast<SID*> (m_psid)) ;

	return pGeneral->CreateThemedPropertySheetPage();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\trigger.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    trigger.h 

Abstract:
	Definition for trigger class

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __TRIGGER_H__
#define __TRIGGER_H__

#include <Tr.h>
#include <Ref.h>
#include <autoptr.h>
#include <comdef.h>
#include <list>
#include "mqcast.h"

class CTrigger;

typedef std::list< R<CTrigger> > TriggerList;

class CTriggerSet : public CReference
{
public:
    CTriggerSet(const CString& strComputer);

    void Refresh(void);

    R<CTrigger> 
    AddTrigger(
        const _bstr_t& name,
        const _bstr_t& queuePathName,
        SystemQueueIdentifier queueType,
        long fEnabled,
        long fSerialize,
		MsgProcessingType msgProcType
        ) throw(_com_error);

    void 
    DeleteTrigger(
        const _bstr_t& id
        ) throw(_com_error);

    void 
    Update(
        const _bstr_t& id,
        const _bstr_t& name,
        const _bstr_t& queuePathName,
        SystemQueueIdentifier queueType,
        long fEnabled,
        long fSerialize,
		MsgProcessingType msgProcType
        ) throw(_com_error);

    void
    UpdateAttachedRules(
        const _bstr_t& id,
        RuleList newRuleList
        ) throw(_com_error);

    RuleList 
    GetAttachedRules(
        const _bstr_t& triggerId,
        CRuleSet* pRuleSet,
        long noOfRules
        ) throw(_com_error);

    TriggerList GetTriggerList(LPCTSTR queuePathName)
    {
        if (queuePathName == NULL)
            return m_triggerList;

        return GetTriggerListForQueue(queuePathName, SYSTEM_QUEUE_NONE);
    }

private:
    TriggerList 
    GetTriggerListForQueue(
        LPCTSTR queuePathName, 
        SystemQueueIdentifier queueType
        );

private:
    IMSMQTriggerSetPtr m_trigSet;
    TriggerList m_triggerList;

    bool m_fChanged;
};


class CTrigger : public CReference
{
public:
    CTrigger(
        CTriggerSet* pTrigSet,
        const _bstr_t& id,
        const _bstr_t& name,
        const _bstr_t& queuePathName,
        SystemQueueIdentifier queueType,
        long noOfRules,
        bool fEnabled,
        bool fSerialize,
		MsgProcessingType msgProcType
        );


    void Update(
        const _bstr_t& name,
        const _bstr_t& queuePathName,
        SystemQueueIdentifier queueType,
        bool fEnabled,
        bool fSerialize,
		MsgProcessingType msgProcType
        ) throw(_com_error);

    
    void 
    Update(
        const _bstr_t&  name
        ) throw(_com_error);


    void 
    UpdateEnabled(
        bool f
        ) throw(_com_error);


    void
    UpdateAttachedRules(
        RuleList newRuleList
        ) throw(_com_error);


    void
    Delete(
        void
        ) throw(_com_error)
    {
        m_pTrigSet->DeleteTrigger(m_id);
    }


    RuleList 
    GetAttachedRules(
        CRuleSet* pRuleSet
        ) throw(_com_error)
    {
        return m_pTrigSet->GetAttachedRules(m_id,  pRuleSet, m_noOfAttachedRules);
    }


    const _bstr_t& GetTriggerName(void) const
    {
        return m_name;
    }


    const _bstr_t& GetTriggerId(void) const
    {
        return m_id;
    }
 

    const _bstr_t& GetQueuePathName(void) const
    {
        return m_queuePathName;
    }


    SystemQueueIdentifier GetQueueType(void) const
    {
        return m_queueType;
    }

    
    long GetNumberOfAttachedRule(void) const
    {
        return m_noOfAttachedRules;
    }


    bool IsEnabled(void) const
    {
        return m_fEnabled;
    }


    bool IsSerialize(void) const
    {
        return m_fSerialize;
    }

	MsgProcessingType GetMsgProcessingType(void) const
	{
		return m_msgProcType;
	}

private:
    R<CTriggerSet> m_pTrigSet;

    _bstr_t m_id;
    _bstr_t m_name;
    _bstr_t m_queuePathName;
    SystemQueueIdentifier m_queueType;
    long m_noOfAttachedRules;
    bool m_fSerialize;
    bool m_fEnabled;
	MsgProcessingType m_msgProcType;
};


R<CTriggerSet> GetTriggerSet(const CString& strComputer);

#endif // __TRIGGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bkuprstr\backup.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    backup.cpp

Abstract:

    Backup MSMQ, Registry, Message files, Logger and Transaction files and LQS

Author:

    Erez Haba (erezh) 14-May-98

--*/

#pragma warning(disable: 4201)

#include <windows.h>
#include <stdio.h>
#include <autohandle.h>
#include "br.h"
#include "resource.h"
#include "snapres.h"

void DoBackup(LPCWSTR pBackupDir, LPCWSTR pMsmqClusterResourceName)
{
    //
    //  1. Verify that the backup directory is empty
    //  2. Verify that the backup directory is writeable
    //  3. Get Registry Values for all subdirectories
    //  4. Stop MSMQ Service (or cluster resource) if running and remember running state.
    //  5. Calculate Required disk space at destinaion (collect all MSMQ files that will be backed-up)
    //  6. Save Registry \HKLM\Software\Microsoft\MSMQ (or MSMQ cluster resource root registry) to file
    //  7. Copy all message files to target directory
    //  8. Copy logger files and mapping files to target directory
    //  9. Copy LQS files to target backup directory
    // 10. Save the web directory permissions into a file in the backup directory
    // 11. Restart MSMQ service (or cluster resource) if needed.
    // 12. Issue a final message
    //

    WCHAR BackupDir[MAX_PATH];
    wcscpy(BackupDir, pBackupDir);
    if (BackupDir[wcslen(BackupDir)-1] != L'\\')
    {
        wcscat(BackupDir, L"\\");
    }

    WCHAR BackupDirMapping[MAX_PATH];
    wcscpy(BackupDirMapping, BackupDir);
    wcscat(BackupDirMapping, L"MAPPING\\");

    WCHAR BackupDirStorage[MAX_PATH];
    wcscpy(BackupDirStorage, BackupDir);
    wcscat(BackupDirStorage, L"STORAGE\\");

    WCHAR BackupDirStorageLqs[MAX_PATH];
    wcscpy(BackupDirStorageLqs, BackupDirStorage);
    wcscat(BackupDirStorageLqs, L"LQS\\");

    //
    // 0. Verify user permissions to backup.
    //
    CResString str(IDS_VERIFY_BK_PRIV);
    BrpWriteConsole(str.Get());
    BrInitialize(SE_BACKUP_NAME);
    
    //
    //  1. Verify that the backup directory is empty
    //
    str.Load(IDS_CHECK_BK_DIR);
    BrpWriteConsole(str.Get());
    BrCreateDirectoryTree(BackupDir);
    BrEmptyDirectory(BackupDir);
    BrCreateDirectory(BackupDirMapping);
    BrEmptyDirectory(BackupDirMapping);
    BrCreateDirectory(BackupDirStorage);
    BrEmptyDirectory(BackupDirStorage);
    BrCreateDirectory(BackupDirStorageLqs);
    BrEmptyDirectory(BackupDirStorageLqs);

    //
    //  2. Verify that the backup directory is writeable
    //
    BrVerifyFileWriteAccess(BackupDir);

    //
    //  3. Get Registry Values for subdirectories
    //

    AP<WCHAR> pTriggersClusterResourceName;
    if (pMsmqClusterResourceName != NULL)
    {
        BrGetTriggersClusterResourceName(pMsmqClusterResourceName, pTriggersClusterResourceName);
    }

    str.Load(IDS_READ_FILE_LOCATION);
    BrpWriteConsole(str.Get());

    WCHAR MsmqRootRegistry[MAX_PATH] = {0};
    BrGetMsmqRootRegistry(pMsmqClusterResourceName, MsmqRootRegistry);

    WCHAR MsmqParametersRegistry[MAX_PATH] = {0};
    BrGetMsmqParametersRegistry(MsmqRootRegistry, MsmqParametersRegistry);

    STORAGE_DIRECTORIES sd;
    BrGetStorageDirectories(MsmqParametersRegistry, sd);
    
    WCHAR MappingDirectory[MAX_PATH];
    BrGetMappingDirectory(MsmqParametersRegistry, MappingDirectory, sizeof(MappingDirectory));

	 
    //  
    //  4.  A. Notify the user on affected application due to the stopping of MSMQ service (NT5 and higher).
    //         Not needed if MSMQ is a cluster resource since cluster takes offline dependent apps.
	//		B. Stop MSMQ Service and dependent services (or cluster resource) if running and remember running state. 
    //

    BOOL fStartService = false;
    bool fStartMsmqClusterResource = false;
    bool fStartMsmqTriggersClusterResource = false;

    ENUM_SERVICE_STATUS * pDependentServices = NULL;
    DWORD NumberOfDependentServices = 0;
    if (pMsmqClusterResourceName == NULL)
    {
	    if(BrIsSystemNT5())
	    {
		    BrNotifyAffectedProcesses(L"mqrt.dll");
	    }
        fStartService = BrStopMSMQAndDependentServices(&pDependentServices, &NumberOfDependentServices);
    }
    else
    {
        if (pTriggersClusterResourceName.get() != NULL)
        {
            fStartMsmqTriggersClusterResource = BrTakeOfflineResource(pTriggersClusterResourceName);
        }

        fStartMsmqClusterResource = BrTakeOfflineResource(pMsmqClusterResourceName);
    }

    //
    //  5. Calculate Required disk space at destinaion (collect all MSMQ files that will be backed-up)
    //     pre allocate 32K for registry save.
    //
    str.Load(IDS_CHECK_AVAIL_DISK_SPACE);
    BrpWriteConsole(str.Get());
    ULONGLONG RequiredSpace = 32768;
    RequiredSpace += BrGetUsedSpace(sd[ixRecover], L"\\p*.mq");
    RequiredSpace += BrGetUsedSpace(sd[ixJournal], L"\\j*.mq");
    RequiredSpace += BrGetUsedSpace(sd[ixLog],     L"\\l*.mq");

    RequiredSpace += BrGetXactSpace(sd[ixXact]);
    RequiredSpace += BrGetUsedSpace(sd[ixLQS], L"\\LQS\\*");

    RequiredSpace += BrGetUsedSpace(MappingDirectory, L"*");

    ULONGLONG AvailableSpace = BrGetFreeSpace(BackupDir);
    if(AvailableSpace < RequiredSpace)
    {
        str.Load(IDS_NOT_ENOUGH_DISK_SPACE_BK);
        BrErrorExit(0, str.Get(), BackupDir);
    }

    //
    //  6. Save Registry HKLM\Software\Microsoft\MSMQ (or MSMQ cluster resource root registry) to file
    //
    str.Load(IDS_BACKUP_REGISTRY);
    BrpWriteConsole(str.Get());
    {
        CRegHandle hKey = BrCreateKey(MsmqRootRegistry);
        BrSaveKey(hKey, BackupDir, xRegistryFileName);
    }
    if(pTriggersClusterResourceName.get() != NULL)
    {
        WCHAR TriggersClusterRegistry[MAX_PATH] = {0};
        BrGetTriggersClusterRegistry(pTriggersClusterResourceName.get(), TriggersClusterRegistry);
        
        CRegHandle hKey = BrCreateKey(TriggersClusterRegistry);
        BrSaveKey(hKey, BackupDir, xTriggersClusterResourceRegistryFileName);
    }

    //
    //  7. Copy all message files to target directory
    //
    str.Load(IDS_BACKUP_MSG_FILES);
    BrpWriteConsole(str.Get());
    BrCopyFiles(sd[ixRecover], L"\\p*.mq", BackupDirStorage);
    BrCopyFiles(sd[ixJournal], L"\\j*.mq", BackupDirStorage);
    BrCopyFiles(sd[ixLog],     L"\\l*.mq", BackupDirStorage);

    //
    //  8. Copy logger files and mapping files to target directory
    //
    BrCopyXactFiles(sd[ixXact], BackupDirStorage);
    BrCopyFiles(MappingDirectory, L"\\*", BackupDirMapping);

    //
    //  9. Copy LQS files to target directory
    //
    BrCopyFiles(sd[ixLQS], L"\\LQS\\*", BackupDirStorageLqs);
    BrpWriteConsole(L"\n");

    //
    // 10. Save the web directory permissions into a file in the backup directory.
    //     MSMQ cluster resources do not use a dedicated web directory.
    //
    if (pMsmqClusterResourceName == NULL)
    {
        WCHAR WebDirectory[MAX_PATH+1];
        BrGetWebDirectory(WebDirectory, sizeof(WebDirectory));
        BrSaveWebDirectorySecurityDescriptor(WebDirectory,BackupDir);
    }

    //
    // 11. Restart MSMQ and dependent services (or cluster resource) if needed
    //
    if(fStartService)
    {
        BrStartMSMQAndDependentServices(pDependentServices, NumberOfDependentServices);
    }
    if (fStartMsmqClusterResource)
    {
        BrBringOnlineResource(pMsmqClusterResourceName);
    }
    if (fStartMsmqTriggersClusterResource)
    {
        BrBringOnlineResource(pTriggersClusterResourceName.get());
    }

    //
    // 12. Issue a final message
    //
    str.Load(IDS_DONE);
    BrpWriteConsole(str.Get());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\trigprop.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    trigprop.h                                     *

Abstract:
	Definition for the trigger property page

Author:
    Uri Habusha (urih), 25-Jul-2000


--*/

#pragma once

#ifndef __TRIGPROP_H__
#define __TRIGPROP_H__

#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include "atlsnap.h"
#include "snpnscp.h"

#include "icons.h"
#include "snpnerr.h"
#include "snpnres.h"
#include "ruledef.h"

#include <map>
#include <list>

// trigprop.h : header file
//

class CTrigResult;
class CNewTrigger;


/////////////////////////////////////////////////////////////////////////////
// CTriggerProp dialog

class CTriggerProp : public CMqPropertyPage
{
friend class CTrigResult;
friend class CNewTrigger;

// Construction
public:
	CTriggerProp(UINT nIDPage, UINT nIdCaption = 0);
	~CTriggerProp();

// Dialog Data
	//{{AFX_DATA(CTriggerProp)
	BOOL	m_fEnabled;
	BOOL	m_fSerialized;
    CString	m_triggerName;
	CString	m_queuePathName;
	MsgProcessingType m_msgProcType;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTriggerProp)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTriggerProp)
	virtual BOOL OnInitDialog();
	afx_msg void OnReceiveXact();
	afx_msg void OnReceiveOrPeek();
	//}}AFX_MSG
	//DECLARE_MESSAGE_MAP()

protected:
    SystemQueueIdentifier m_queueType;

private:
	void SetMsgProcessingType(void);
	virtual void SetDialogHeading(void) {};

};


/////////////////////////////////////////////////////////////////////////////
// CNewTriggerProp page

class CNewTriggerProp : public CTriggerProp
{

public:
	CNewTriggerProp(CNewTrigger* pParent, LPCTSTR queuePathName);

	// Dialog Data
	enum { IDD = IDD_NEW_TRIGGER_GEN };

	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTriggerProp)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	// Generated message map functions
	//{{AFX_MSG(CTriggerProp)
	virtual BOOL OnSetActive();
	virtual BOOL OnInitDialog();
	afx_msg void OnQueueMessages();
	afx_msg void OnSystemQueue();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()


private:
    void SetQueueType(void);
    void DDV_ValidQueuePathName(CDataExchange* pDX, CString& str);
 
	CNewTrigger* m_pNewTrig;
};


/////////////////////////////////////////////////////////////////////////////
// CViewTriggerProp page

class CViewTriggerProp : public CTriggerProp
{

public:
	CViewTriggerProp(CTrigResult* pParent);
	~CViewTriggerProp();

	// Dialog Data
	enum { IDD = IDD_TRIGGER_GEN };

	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTriggerProp)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:

	//{{AFX_MSG(CTriggerProp)
	virtual BOOL OnInitDialog();
	virtual BOOL OnApply();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()


private:
	void SetDialogHeading(void);
	void InitQueueDisplayName();

    R<CTrigResult> m_pParent;
	CString m_strDisplayQueueName;
	MsgProcessingType m_initMsgProcessingType;
};


/////////////////////////////////////////////////////////////////////////////
// CAttachedRule dialog

class CAttachedRule : public CMqPropertyPage, public CRuleParent
{
public:
	CAttachedRule(
        CTrigResult* pParent
        );

	CAttachedRule(
        CNewTrigger* pParent
        );

	virtual void AddRef() 
	{
		CMqPropertyPage::AddRef();
	}

	virtual void Release()
	{
		CMqPropertyPage::Release();
	}

    //{{AFX_DATA(CAttachedRule)
	enum { IDD_NEW = IDD_NEW_ATTACH_RULE, IDD_VIEW = IDD_ATTACH_RULE };
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAttachedRule)
	public:
	virtual BOOL OnApply();
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAttachedRule)
    virtual BOOL OnWizardFinish();
	virtual BOOL OnInitDialog();
	afx_msg void OnDetachRule();
    afx_msg void OnAttachRule();
	afx_msg void OnUpRule();
	afx_msg void OnDownRule();
	afx_msg void OnViewAttachedRulesProperties();
	afx_msg void OnViewExistingRulesProperties();
	afx_msg void OnAttachedSelChanged();
	afx_msg void OnExistingSelChanged();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
    RuleList GetAttachedRules(void)
    {
        return m_attachedRuleList;
    }

    BOOL OnSetActive();

private:
    void Display(int dwAttachedSelIndex, int dwExistSelIndex);
	void BuildExistingRulesList(void);
	void DisplaySingleRuleProperties(CRule* pRule);
	void SetScrollSize();

    bool IsAttachedRule(const _bstr_t& id);

	void SetAttachedNoOrSingleSelectionButtons(bool fSingleSelection);
	void SetAttachedMultipleSelectionButtons(); 
	void SetExistingNoOrSingleSelectionButtons(bool fSingleSelection);
	void SetExistingMultipleSelectionButtons();

private:       
    CListBox* m_pAttachedRuleList;
	CListBox* m_pExistingRuleList;

    RuleList m_attachedRuleList; 
    RuleList m_existingRuleList;

    R<CTrigResult> m_pParent;
    CNewTrigger* m_pNewTrig;
};


#endif // __TRIGPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\usercert.h ===
// UserCert.h : Declaration of the CUserCertificate

#ifndef __USERCERTIFICATE_H_
#define __USERCERTIFICATE_H_

#include "resource.h"       // main symbols
#include "dataobj.h"

#define USER_OBJECT_SID_ATTRIBUTE   (L"objectSid")
#ifndef MSMQ_OBJECT_SID_ATTRIBUTE
    #define MSMQ_OBJECT_SID_ATTRIBUTE   (L"mSMQUserSid")
#endif

class CMQSigCertificate;

/////////////////////////////////////////////////////////////////////////////
// CUserCertificate
class CUserCertificate : 
	public CDataObject
{
public:

    CUserCertificate();
    ~CUserCertificate();

    //
    // IShellExtInit
    //
	STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hkeyProgID);

    //
    // IShellPropSheetExt
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    //
    // IContextMenu
    //
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);

protected:
    HPROPSHEETPAGE CreateMSMQCertificatePage();

    virtual HRESULT ExtractMsmqPathFromLdapPath (LPWSTR lpwstrLdapPath);
   	virtual const DWORD GetObjectType();
    virtual const PROPID *GetPropidArray();
    virtual const DWORD  GetPropertiesCount();


protected:

    virtual 
    HRESULT 
    InitializeUserSid(
        LPCWSTR lpwstrLdapName
        );

    HRESULT
    InitializeMQCretificate(
        void
        );

    BYTE* m_psid;
    CMQSigCertificate** m_pMsmqCertificate;
    DWORD m_NumOfCertificate;
    CString m_lpwstrLdapName;

private:
	virtual BSTR GetSidPropertyName() = 0;
};


inline
HRESULT 
CUserCertificate::ExtractMsmqPathFromLdapPath(
    LPWSTR /*lpwstrLdapPath*/
    )
{
    return MQ_OK;
}

inline
const 
DWORD 
CUserCertificate::GetObjectType()
{
    ASSERT(0);
    return 0;
}

inline
const 
PROPID*
CUserCertificate::GetPropidArray()
{
    ASSERT(0);
    return NULL;
}

inline
const 
DWORD  
CUserCertificate::GetPropertiesCount()
{
    ASSERT(0);
    return 0;
}


//
// IContextMenu
//
inline
STDMETHODIMP 
CUserCertificate::QueryContextMenu(
    HMENU /*hmenu*/, 
    UINT /*indexMenu*/, 
    UINT /*idCmdFirst*/, 
    UINT /*idCmdLast*/, 
    UINT /*uFlags*/
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return 0;
}

inline
STDMETHODIMP 
CUserCertificate::InvokeCommand(
    LPCMINVOKECOMMANDINFO /*lpici*/
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(0);

    return S_OK;
}

//
// Derived classes
//
class CRegularUserCertificate : 
    public CUserCertificate,
	public CComCoClass<CRegularUserCertificate, &CLSID_UserCertificate>
{
public:
    DECLARE_NOT_AGGREGATABLE(CRegularUserCertificate)
    DECLARE_REGISTRY_RESOURCEID(IDR_USERCERTIFICATE)
private:
	virtual BSTR GetSidPropertyName()
	{
		return USER_OBJECT_SID_ATTRIBUTE;
	}
};

class CMigratedUserCertificate : 
    public CUserCertificate,
	public CComCoClass<CMigratedUserCertificate, &CLSID_MigratedUserCertificate>
{
public:
    DECLARE_NOT_AGGREGATABLE(CMigratedUserCertificate)
    DECLARE_REGISTRY_RESOURCEID(IDR_MIGRATEDUSERCERTIFICATE)

private:
	virtual BSTR GetSidPropertyName()
	{
		return MSMQ_OBJECT_SID_ATTRIBUTE;
	}
};

#endif //__USERCERTIFICATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bkuprstr\resource.h ===
#include "bkupres.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bkuprstr\br.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    br.cpp

Abstract:

    Common function for MSMQ Backup & Restore.

Author:

    Erez Haba (erezh) 14-May-98

--*/

#pragma warning(disable: 4201)

#include <windows.h>
#include <stdio.h>
#include <clusapi.h>
#include <resapi.h>
#include "br.h"
#include "resource.h"
#include "mqtime.h"
#include <acioctl.h>
#include "uniansi.h"
#include "autorel.h"
#include <winbase.h>
#include <tlhelp32.h>
#include <dbghelp.h>
#include <assert.h>
#include <stdlib.h>
#include <_mqini.h>
#include <_mqreg.h>
#include <mqmacro.h>
#include <lim.h>
#include <mqcast.h>
#include <tchar.h>
#include <mqtg.h>
#include "snapres.h"
#include "autorel2.h"
#include "autohandle.h"
#include "autoptr.h"
#include "autorel3.h"

extern bool g_fNoPrompt;

typedef BOOL (WINAPI *EnumerateLoadedModules_ROUTINE) (HANDLE, PENUMLOADED_MODULES_CALLBACK64, PVOID);


//-----------------------------------------------------------------------------
//
// Configuration
//

//
// File name to write into backup directory
//
const WCHAR xBackupIDFileName[] = L"\\mqbackup.id";

//
// Signature written in the signature file (need to be in chars)
//
const char xBackupSignature[] = "MSMQ Backup\n";

//
// Backup file containing the web directory DACL (Access information)
//
const WCHAR xWebDirDACLFileName[] = L"\\WebDirDACL.bin";

//
// MSMQ Registry settings location
//
const WCHAR xInetStpRegNameParameters[] = L"Software\\Microsoft\\InetStp";

const LPCWSTR xXactFileList[] = {
    L"\\qmlog",
    L"\\mqinseqs.*",
    L"\\mqtrans.*",
};

const int xXactFileListSize = sizeof(xXactFileList) / sizeof(xXactFileList[0]);

//-----------------------------------------------------------------------------

BOOL
BrpFileIsConsole(
    HANDLE fp
    )
{
    unsigned htype;
 
    htype = GetFileType(fp);
    htype &= ~FILE_TYPE_REMOTE;
    return htype == FILE_TYPE_CHAR;
}
 

void
BrpWriteConsole(
    LPCWSTR  pBuffer
    )
{
    //
    // Jump through hoops for output because:
    //
    //    1.  printf() family chokes on international output (stops
    //        printing when it hits an unrecognized character)
    //
    //    2.  WriteConsole() works great on international output but
    //        fails if the handle has been redirected (i.e., when the
    //        output is piped to a file)
    //
    //    3.  WriteFile() works great when output is piped to a file
    //        but only knows about bytes, so Unicode characters are
    //        printed as two Ansi characters.
    //
 
    static HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
    DWORD NumOfChars = static_cast<DWORD>(wcslen(pBuffer));

    if (BrpFileIsConsole(hStdOut))
    {
        WriteConsole(hStdOut, pBuffer, NumOfChars, &NumOfChars, NULL);
        return;
    }

    DWORD NumOfBytes = (NumOfChars + 1) * sizeof(WCHAR);
    LPSTR pAnsi = (LPSTR)LocalAlloc(LMEM_FIXED, NumOfBytes);
    if (pAnsi == NULL)
    {
        return;
    }

    NumOfChars = WideCharToMultiByte(CP_OEMCP, 0, pBuffer, NumOfChars, pAnsi, NumOfBytes, NULL, NULL);
    if (NumOfChars != 0)
    {
        WriteFile(hStdOut, pAnsi, NumOfChars, &NumOfChars, NULL);
    }

    LocalFree(pAnsi);
}


static
DWORD
BrpFormatMessage(
    IN DWORD   dwFlags,
    IN LPCVOID lpSource,
    IN DWORD   dwMessageId,
    IN DWORD   dwLanguageId,
    OUT LPWSTR lpBuffer,
    IN  DWORD  nSize,
    IN ...
    )
/*++

Routine Description:
    Wrapper for FormatMessage()

    Caller of this wrapper should allocate a large enough buffer 
    for the formatted string and pass a valid pointer (lpBuffer).
    
    Allocation made by FormatMessage() is deallocated by this
    wrapper before returning to caller. 

    Caller of this wrapper should simply pass arguments for formatting.
    Packing to va_list is done by this wrapper.
    (Caller of FormatMessage() needs to pack arguments for 
    formatting to a va_list or an array and pass a pointer
    to this va_list or array) 

Arguments:
    dwFlags      -  passed as is to FormatMessage()
    lpSource     -  passed as is to formatMessage()
    dwMessageId  -  passed as is to FormatMessage()
    dwLanguageId -  passed as is to FormatMessage()
    lpBuffer     -  pointer to a large enough buffer allocated by
                    caller. This buffer will hold the formatted string.
    nSize        -  passed as is to FormatMessage 
    ...          -  arguments for formatting

Return Value:
    passed as is from FormatMessage()

--*/
{
    va_list va;
    va_start(va, nSize);

    LPTSTR pBuf = 0;
    DWORD dwRet = FormatMessage(
        dwFlags,
        lpSource,
        dwMessageId,
        dwLanguageId,
        reinterpret_cast<LPWSTR>(&pBuf),
        nSize,
        &va
        );
    if (dwRet != 0)
    {
        wcscpy(lpBuffer, pBuf);
        LocalFree(pBuf);
    }

    va_end(va);
    return dwRet;

} //BrpFormatMessage


void
BrErrorExit(
    DWORD Status,
    LPCWSTR pErrorMsg,
    ...
    )
{
    va_list va;
    va_start(va, pErrorMsg);

    LPTSTR pBuf = 0;
    DWORD dwRet = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        pErrorMsg,
        0,
        0,
        reinterpret_cast<LPWSTR>(&pBuf),
        0,
        &va
        );
    if (dwRet != 0)
    {
        BrpWriteConsole(pBuf);
        LocalFree(pBuf);
    }

    va_end(va);

    if(Status != 0)
    {
         //
        // Display error code
        //
        WCHAR szBuf[1024] = {0};
        CResString strErrorCode(IDS_ERROR_CODE);
        DWORD rc = BrpFormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            strErrorCode.Get(),
            0,
            0,
            szBuf,
            0,
            Status
            );

        if (rc != 0)
        {
            BrpWriteConsole(L" ");
            BrpWriteConsole(szBuf);
        }
        BrpWriteConsole(L"\n");

        //
        // Display error description
        //
        rc = BrpFormatMessage(
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS |
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_MAX_WIDTH_MASK,
            L"%1",
            Status,
            0,
            szBuf,
            0,
            0
            );

        if (rc != 0)
        {
            BrpWriteConsole(szBuf);
            BrpWriteConsole(L"\n");
        }
    }

	exit(-1);

} //BrErrorExit


static
void
BrpEnableTokenPrivilege(
    HANDLE hToken,
    LPCWSTR pPrivilegeName
    )
{
    BOOL fSucc;
    LUID Privilege;
    fSucc = LookupPrivilegeValue(
                NULL,       // system name
                pPrivilegeName,
                &Privilege
                );
    if(!fSucc)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_LOOKUP_PRIV_VALUE);
        BrErrorExit(gle, strErr.Get(), pPrivilegeName);
    }


    TOKEN_PRIVILEGES TokenPrivilege;
    TokenPrivilege.PrivilegeCount = 1;
    TokenPrivilege.Privileges[0].Luid = Privilege;
    TokenPrivilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    fSucc = AdjustTokenPrivileges(
                hToken,
                FALSE,  // Do not disable all
                &TokenPrivilege,
                sizeof(TOKEN_PRIVILEGES),
                NULL,   // Ignore previous info
                NULL    // Ignore previous info
                );

    if(!fSucc)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_ENABLE_PRIV);
        BrErrorExit(gle, strErr.Get(), pPrivilegeName);
    }
}


void
BrInitialize(
    LPCWSTR pPrivilegeName
    )
{
    BOOL fSucc;
    HANDLE hToken;
    fSucc = OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_ADJUST_PRIVILEGES,
                &hToken
                );
    if(!fSucc)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_OPEN_PROCESS_TOKEN);
        BrErrorExit(gle, strErr.Get());
    }

    BrpEnableTokenPrivilege(hToken, pPrivilegeName);

    CloseHandle(hToken);
}


static
void
BrpWarnUserBeforeDeletion(
    LPCTSTR pDirName
    )
{
    WCHAR szBuf[1024] = {L'\0'};

    if (g_fNoPrompt)
    {
        CResString strDeleting(IDS_DELETING_FILES);
        DWORD rc = BrpFormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            strDeleting.Get(),
            0,
            0,
            szBuf,
            0,
            pDirName
            );

        if (rc != 0)
        {
            BrpWriteConsole(szBuf);
        }
        return;
    }

    CResString strWarn(IDS_WARN_BEFORE_DELETION);
    CResString strY(IDS_Y);
    CResString strN(IDS_N);

    DWORD rc = BrpFormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        strWarn.Get(),
        0,
        0,
        szBuf,
        0,
        pDirName,
        strY.Get(),
        strN.Get()
        );

    if (rc == 0)
    {
        //
        // Failed to generate "are you sure" message,
        // don't take any chances - abort!
        //
        exit(-1);
    }

    for (;;)
    {
        BrpWriteConsole(szBuf);
        
        WCHAR sz[80] = {0};
        wscanf(L"%79s", sz);

        if (0 == CompareStringsNoCase(sz, strY.Get()))
        {
            break;
        }

        if (0 == CompareStringsNoCase(sz, strN.Get()))
        {
            CResString strAbort(IDS_ABORT);
            BrpWriteConsole(strAbort.Get());
            exit(-1);
        }
    }

} //BrpWarnUserBeforeDeletion


void
BrEmptyDirectory(
    LPCWSTR pDirName
    )
/*++

Routine Description:
    Deletes all files in the directory. 
    Ignores files with zero size (eg subdirectories)

Arguments:
    pDirName - Directory Path.

Return Value:
    None.

--*/
{
    WCHAR szDirName[MAX_PATH];
    wcscpy(szDirName, pDirName);
    if (szDirName[wcslen(szDirName)-1] != L'\\')
    {
        wcscat(szDirName, L"\\");
    }

    WCHAR FileName[MAX_PATH];
    wcscpy(FileName, szDirName);
    wcscat(FileName, L"*");

    HANDLE hEnum;
    WIN32_FIND_DATA FindData;
    hEnum = FindFirstFile(
                FileName,
                &FindData
                );

    if(hEnum == INVALID_HANDLE_VALUE)
    {
        DWORD gle = GetLastError();

        if(gle == ERROR_FILE_NOT_FOUND)
        {
            //
            // Great, no files found. 
            // If path does not exists this is another error (3).
            //
            return;
        }

        CResString strErr(IDS_CANT_ACCESS_DIR);
        BrErrorExit(gle, strErr.Get(), pDirName);
    }

    bool fUserWarned = false;
    do
    {
        if (FindData.nFileSizeLow == 0 && FindData.nFileSizeHigh == 0)
        {
            continue;
        }

        if (!fUserWarned)
        {
            BrpWarnUserBeforeDeletion(pDirName);
            fUserWarned = true;
        }

        wcscpy(FileName, szDirName);
        wcscat(FileName, FindData.cFileName);
        if (!DeleteFile(FileName))
        {
            DWORD gle = GetLastError();
            CResString strErr(IDS_CANT_DEL_FILE);
            BrErrorExit(gle, strErr.Get(), FindData.cFileName);
        }

    } while(FindNextFile(hEnum, &FindData));

    FindClose(hEnum);

} //BrEmptyDirectory


void
BrVerifyFileWriteAccess(
    LPCWSTR pDirName
    )
{
    WCHAR FileName[MAX_PATH];
    wcscpy(FileName, pDirName);
    wcscat(FileName, xBackupIDFileName);

    HANDLE hFile;
    hFile = CreateFile(
                FileName,
                GENERIC_WRITE,
                0,              // share mode
                NULL,           // pointer to security attributes
                CREATE_NEW,
                FILE_ATTRIBUTE_NORMAL,
                NULL            // template file
                );
    
    if(hFile == INVALID_HANDLE_VALUE)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_CREATE_FILE);
        BrErrorExit(gle, strErr.Get(), FileName);
    }

    BOOL fSucc;
    DWORD nBytesWritten;
    fSucc = WriteFile(
                hFile,
                xBackupSignature,
                sizeof(xBackupSignature) - 1,
                &nBytesWritten,
                NULL    // overlapped structure
                );
    if(!fSucc)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_WRITE_FILE);
        BrErrorExit(gle, strErr.Get(), FileName);
    }

    CloseHandle(hFile);
}


static
void
BrpQueryStringValue(
    HKEY hKey,
    LPCWSTR pValueName,
    LPWSTR pValue,
    DWORD cbValue
    )
{
    LONG lRes;
    DWORD dwType;
    lRes = RegQueryValueEx(
            hKey,
            pValueName,
            NULL,   // reserved
            &dwType,
            reinterpret_cast<PBYTE>(pValue),
            &cbValue
            );

    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_QUERY_REGISTRY_VALUE);
        BrErrorExit(lRes, strErr.Get(), pValueName);
    }
}

static
void
BrpQueryDwordValue(
    HKEY hKey,
    LPCWSTR pValueName,
    DWORD *pValue
    )
{
    LONG lRes;
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);

    lRes = RegQueryValueEx(
            hKey,
            pValueName,
            NULL,   // reserved
            &dwType,
            reinterpret_cast<PBYTE>(pValue),
            &dwSize
            );
    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_QUERY_REGISTRY_VALUE);
        BrErrorExit(lRes, strErr.Get(), pValueName);
    }
}

static
void
BrpSetDwordValue(
    HKEY hKey,
    LPCWSTR pValueName,
    DWORD dwValue
    )
{
    LONG lRes;
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);

    lRes = RegSetValueEx(
            hKey,
            pValueName,
            NULL,   // reserved
            dwType,
            reinterpret_cast<PBYTE>(&dwValue),
            dwSize
            );
    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_SET_REGISTRY_VALUE);
        BrErrorExit(lRes, strErr.Get(), pValueName);
    }
}

 


void
BrGetStorageDirectories(
    LPCWSTR pMsmqParametersRegistry,                         
    STORAGE_DIRECTORIES& sd
    )
{
    LONG lRes;
    HKEY hKey;
    lRes = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            pMsmqParametersRegistry,
            0,
            KEY_READ,
            &hKey
            );

    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_OPEN_MSMQ_REGISTRY_READ);
        BrErrorExit(lRes, strErr.Get(), pMsmqParametersRegistry);
    }

    BrpQueryStringValue(hKey, L"StoreReliablePath",    sd[ixExpress], sizeof(sd[ixExpress]));
    BrpQueryStringValue(hKey, L"StorePersistentPath",  sd[ixRecover], sizeof(sd[ixRecover]));
    BrpQueryStringValue(hKey, L"StoreJournalPath",     sd[ixJournal], sizeof(sd[ixJournal]));
    BrpQueryStringValue(hKey, L"StoreLogPath",         sd[ixLog],     sizeof(sd[ixLog]));
    BrpQueryStringValue(hKey, L"StoreXactLogPath",     sd[ixXact],    sizeof(sd[ixXact]));

    RegCloseKey(hKey);
}


void
BrGetMsmqRootPath(
    LPCWSTR pMsmqParametersRegistry,
    LPWSTR  pMsmqRootPath
    )
{
    CRegHandle hKey;
    LONG status;
    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pMsmqParametersRegistry, 0, KEY_READ, &hKey);

    if(status != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_OPEN_MSMQ_REGISTRY_READ);
        BrErrorExit(status, strErr.Get(), pMsmqParametersRegistry);
    }

    WCHAR MsmqRootPath[MAX_PATH];
    DWORD cbMsmqRootPath = sizeof(MsmqRootPath);
    DWORD dwType;
    status = RegQueryValueEx(
                 hKey, 
                 MSMQ_ROOT_PATH, 
                 NULL, 
                 &dwType, 
                 reinterpret_cast<PBYTE>(MsmqRootPath), 
                 &cbMsmqRootPath
                 );

    if(status == ERROR_SUCCESS)
    {
        wcscpy(pMsmqRootPath, MsmqRootPath);
        return;
    }

    GetSystemDirectory(MsmqRootPath, TABLE_SIZE(MsmqRootPath));
    wcscat(MsmqRootPath, L"\\MSMQ");
    wcscpy(pMsmqRootPath, MsmqRootPath);
}


void
BrGetMappingDirectory(
    LPCWSTR pMsmqParametersRegistry,
    LPWSTR MappingDirectory,
    DWORD  MappingDirectorySize
    )
{
    //
    // Lookup the mapping directory in registry
    //

    LONG lRes;
    CRegHandle hKey;
    lRes = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            pMsmqParametersRegistry,
            0,      // reserved
            KEY_READ,
            &hKey
            );

    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_OPEN_MSMQ_REGISTRY_READ);
        BrErrorExit(lRes, strErr.Get(), pMsmqParametersRegistry);
    }

    DWORD dwType;
    lRes = RegQueryValueEx(
            hKey,
            MSMQ_MAPPING_PATH_REGNAME,
            NULL,   // reserved
            &dwType,
            reinterpret_cast<PBYTE>(MappingDirectory),
            &MappingDirectorySize
            );

    if(lRes == ERROR_SUCCESS)
    {
        return;
    }

    //
    // Not in registry. Lookup the MSMQ root dir in registry and append MAPPING to it
    //
    BrGetMsmqRootPath(pMsmqParametersRegistry, MappingDirectory);
    wcscat(MappingDirectory, DIR_MSMQ_MAPPING);
}

void
BrGetWebDirectory(
    LPWSTR lpwWebDirectory,
    DWORD  dwWebDirectorySize
    )
{	
	//
	// Check if we are working with the IIS directory
	//
    CRegHandle hKey;
    DWORD dwType;
    DWORD dwReadSize;
    LONG lRes = RegOpenKeyEx(
		            HKEY_LOCAL_MACHINE,
		            MSMQ_REG_PARAMETER_SETUP_KEY,
		            0,      // reserved
		            KEY_READ,
		            &hKey
		            );

    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_OPEN_MSMQ_REGISTRY_READ);
        BrErrorExit(lRes, strErr.Get(), MSMQ_REG_SETUP_KEY);
    }

    DWORD dwMsmqInetpubWebDirAvailable = 0;
    dwReadSize = sizeof DWORD;
    lRes = RegQueryValueEx(
            hKey,
            MSMQ_INETPUB_WEB_KEY_REGNAME,
            NULL,   // reserved
            &dwType,
            reinterpret_cast<PBYTE>(&dwMsmqInetpubWebDirAvailable),
            &dwReadSize
            );

	//
	// Return if not updated to work with IIS yet
	//
	if ((1 != dwMsmqInetpubWebDirAvailable) || (lRes != ERROR_SUCCESS))
	{
	    //
	    // Setup the defaults in case we can not find the path in the registry
	    //
	    GetSystemDirectory(lpwWebDirectory, dwWebDirectorySize/sizeof(lpwWebDirectory[0]));
		if (wcslen(lpwWebDirectory) + wcslen(L"\\MSMQ\\WEB") < dwWebDirectorySize/sizeof(lpwWebDirectory[0]))
	    	wcscat(lpwWebDirectory, L"\\MSMQ\\WEB");
		return;
	}


	//
	// Get the IIS WWWRoot directory
	//
    CRegHandle hKey1;
    lRes = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            xInetStpRegNameParameters,
            0,      // reserved
            KEY_READ,
            &hKey1
            );

    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_OPEN_MSMQ_REGISTRY_READ);
        BrErrorExit(lRes, strErr.Get(), xInetStpRegNameParameters);
    }

	dwReadSize = dwWebDirectorySize;
    lRes = RegQueryValueEx(
            hKey1,
            TEXT("PathWWWRoot"),
            NULL,   // reserved
            &dwType,
            reinterpret_cast<PBYTE>(lpwWebDirectory),
            &dwReadSize
            );

	//
	// Add the MSMQ dub directory
	//
	if (lRes == ERROR_SUCCESS)
	{
		if (wcslen(lpwWebDirectory) + wcslen(L"\\MSMQ") < dwWebDirectorySize/sizeof(lpwWebDirectory[0]))
		    wcscat(lpwWebDirectory, L"\\MSMQ");
		return;
	}

	// 
	// In case of failure, use default directory
	//
    GetSystemDirectory(lpwWebDirectory, dwWebDirectorySize/sizeof(lpwWebDirectory[0]));
	if (wcslen(lpwWebDirectory) + wcslen(L"\\MSMQ\\WEB") < dwWebDirectorySize/sizeof(lpwWebDirectory[0]))
	    wcscat(lpwWebDirectory, L"\\MSMQ\\WEB");

    return;
}


void
BrSaveFileSecurityDescriptor(
	LPWSTR lpwFile,
	SECURITY_INFORMATION SecurityInformation,
	LPWSTR lpwPermissionFile
	)
{
/*++

Routine Description:
    This routine does the following:
    1. Get the security descriptor information of the file
    2. Store the security information in a target file

Arguments:
    lpwFile - The source file from which to get the permission information
    SecurityInformation - The type of permission information we want to save
    lpwPermissionFile - The file to which we will save the permission information
    

Return Value:
    None.

--*/
	//
	// Create the target file. This will cleanup the file in case we have some 
	// undeleted residue
	//
	CHandle hFile (CreateFile(
                		lpwPermissionFile,
		                GENERIC_WRITE,
        		        0,              // share mode
                		NULL,           // pointer to security attributes
		                CREATE_ALWAYS,
        		        FILE_ATTRIBUTE_NORMAL,
                		NULL            // template file
		                ));
    if(hFile == INVALID_HANDLE_VALUE)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_CREATE_FILE);
        BrErrorExit(gle, strErr.Get(), lpwPermissionFile);
    }

	//
	// Get the length of the security descriptor of the file
	//
	DWORD dwLengthNeeded;
	BOOL fSucc = GetFileSecurity(
						lpwFile,                        
						SecurityInformation, 
						NULL,  					// SD
						0,                      // size of SD
						&dwLengthNeeded         
						);
	if (!fSucc)
	{
		DWORD gle = GetLastError();
		if (ERROR_INSUFFICIENT_BUFFER != gle)
		{
			if (ERROR_FILE_NOT_FOUND == gle)
			{
				//
				// We will get here if the file does not exist. Just exit since we already initialized the target file
				//
				return;
			}

			if (ERROR_PRIVILEGE_NOT_HELD == gle || ERROR_ACCESS_DENIED == gle)
			{
				// 
				// Not enough privilege to get the security descriptor
				//
		        CResString strErr(IDS_NO_PRIVILEGE);
		        BrErrorExit(gle, strErr.Get(), lpwFile);
			}

			//
			// Unexpected problem, print it out
			//
	        CResString strErr(IDS_UNEXPECTED_FILE_ERROR);
	        BrErrorExit(gle, strErr.Get(), lpwFile);
		}
	}

	//
	// Get the security descriptor
	//
	AP<char> pDescriptor = new char[dwLengthNeeded];
	if (pDescriptor == NULL)
	{
        CResString strErr(IDS_NO_MEMORY);
        BrErrorExit(0, strErr.Get());
	}
	DWORD dwLengthReturned;
	fSucc = GetFileSecurity(
						lpwFile,                        
						SecurityInformation, 
						pDescriptor,  
						dwLengthNeeded,                             
						&dwLengthReturned                    
						);
	if (!fSucc)
	{
        DWORD gle = GetLastError();
        CResString strErr(IDS_UNEXPECTED_FILE_ERROR);
        BrErrorExit(gle, strErr.Get(), lpwFile);
	}

	// 
	// Save the security descriptor into the target file
	//
    DWORD dwBytesWritten = 0;
    fSucc = WriteFile(
                hFile,
                pDescriptor,
                dwLengthNeeded, 
                &dwBytesWritten,
                NULL    // overlapped structure
                );
    if(!fSucc)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_WRITE_FILE);
        BrErrorExit(gle, strErr.Get(), lpwPermissionFile);
    }
    assert(dwBytesWritten == dwLengthNeeded);
}
 

void
BrSaveWebDirectorySecurityDescriptor(
    LPWSTR lpwWebDirectory,
    LPWSTR lpwBackuDir
    )
/*++

Routine Description:
    This routine saves the DACL of the web directory into a file in the backup directory
    NOTE that we are saving only the DACL and not the owner or group information since they might change
    between backup and restore

Arguments:
    lpwWebDirectory - The web directory
    lpwBackupDir - The backup directory

Return Value:
    None.

--*/
{
    WCHAR PermissionFileName[MAX_PATH+1];
    wcscpy(PermissionFileName, lpwBackuDir);
    wcscat(PermissionFileName, xWebDirDACLFileName);

	BrSaveFileSecurityDescriptor(lpwWebDirectory, DACL_SECURITY_INFORMATION, PermissionFileName);
}
 

void
BrRestoreFileSecurityDescriptor(
	LPWSTR lpwFile,
	SECURITY_INFORMATION SecurityInformation,
	LPWSTR lpwPermissionFile
    )
/*++

Routine Description:
    This routine restores the web directory security descriptor 
    1. Read the security descriptor stored in the backup directory
    2. Convert it to a binary security descriptor
    3. Set the security descriptor to the file.

Arguments:
    lpwFile - The file to which to restore the permission information
    SecurityInformation - The type of permission information we want to save
    lpwPermissionFile - The file from which we will read the permission information

Return Value:
    None.

--*/
{
	CHandle hFile (CreateFile(
                		lpwPermissionFile,
		                GENERIC_READ,
        		        0,              // share mode
                		NULL,           // pointer to security attributes
		                OPEN_EXISTING,
        		        FILE_ATTRIBUTE_NORMAL,
                		NULL            // template file
		                ));
    if(hFile == INVALID_HANDLE_VALUE)
    {
        DWORD gle = GetLastError();
        if (ERROR_FILE_NOT_FOUND == gle)
        {
        	// 
        	// The file was not created in the last backup (maybe an old backup)
        	// return and do not break the restore
        	//
        	return;
        }     
        
        CResString strErr(IDS_CANT_CREATE_FILE);
        BrErrorExit(gle, strErr.Get(), lpwPermissionFile);
    }

    //
    // Get the file size
    //
    DWORD dwSecurityDescriptorSize;
    dwSecurityDescriptorSize = GetFileSize(hFile, NULL);
    if (INVALID_FILE_SIZE == dwSecurityDescriptorSize)
    {
        DWORD gle = GetLastError(); 
        CResString strErr(IDS_CANT_GET_FILE_SIZE);
        BrErrorExit(gle, strErr.Get(), lpwPermissionFile);
    }

    if (0 == dwSecurityDescriptorSize)
    {
    	//
    	// Nothing there (probably no web directory was found in the back up)
    	return;
    }

    //
    // Read the security descriptor string
    //
	AP<char> pDescriptor = new char[dwSecurityDescriptorSize];
	if (pDescriptor == NULL)
	{
        CResString strErr(IDS_NO_MEMORY);
        BrErrorExit(0, strErr.Get());
	}
	
    DWORD dwBytesRead;
    BOOL fSucc = ReadFile(
                hFile,
                pDescriptor,
                dwSecurityDescriptorSize,
                &dwBytesRead,
                NULL    // overlapped structure
                );
    if(!fSucc)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_READ_FILE);
        BrErrorExit(gle, strErr.Get(), lpwPermissionFile);
    }
    assert(dwBytesRead == dwSecurityDescriptorSize);

    //
    // Set the security descriptor to the web directory
    //
	fSucc = SetFileSecurity(
						lpwFile,                        
						SecurityInformation, 
						pDescriptor  
						);
	if (!fSucc)
	{
		DWORD gle = GetLastError();
		if (ERROR_PRIVILEGE_NOT_HELD == gle || ERROR_ACCESS_DENIED == gle)
		{
			// 
			// Not enough privilege to set the security descriptor
			//
	        CResString strErr(IDS_NO_PRIVILEGE);
	        BrErrorExit(gle, strErr.Get(), lpwFile);
		}

		//
		// Unexpected problem, print it out
		//
        CResString strErr(IDS_UNEXPECTED_FILE_ERROR);
	    BrErrorExit(gle, strErr.Get(), lpwFile);
	}
}
 

void
BrRestoreWebDirectorySecurityDescriptor(
    LPWSTR lpwWebDirectory,
    LPWSTR lpwBackuDir
    )
/*++

Routine Description:
    This routine restores the DACL of the web directory from a file saved in the backup directory
    NOTE that we are restoring only the DACL and not the owner or group information since they might change
    between backup and restore

Arguments:
    lpwWebDirectory - The web directory
    lpwBackupDir - The backup directory

Return Value:
    None.

--*/
{
    WCHAR PermissionFileName[MAX_PATH+1];
    wcscpy(PermissionFileName, lpwBackuDir);
    wcscat(PermissionFileName, xWebDirDACLFileName);

	BrRestoreFileSecurityDescriptor(lpwWebDirectory, DACL_SECURITY_INFORMATION, PermissionFileName);

	return;
}


static
SC_HANDLE
BrpGetServiceHandle(
    LPCWSTR pServiceName,
    DWORD AccessType
    )
{
    CServiceHandle hSvcCtrl(OpenSCManager(
										NULL,   // machine name
										NULL,   // services database
										SC_MANAGER_ALL_ACCESS
										));

    if(hSvcCtrl == NULL)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_OPEN_SCM);
        BrErrorExit(gle, strErr.Get());
    }

    SC_HANDLE hService;
    hService = OpenService(
                hSvcCtrl,
                pServiceName,
                AccessType
                );

    if(hService == NULL)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_OPEN_SERVICE);
        BrErrorExit(gle, strErr.Get(), pServiceName);
    }

    return hService;
}


static
bool
BrpIsServiceStopped(
    LPCWSTR pServiceName
    )
{
    CServiceHandle hService( BrpGetServiceHandle(pServiceName, SERVICE_QUERY_STATUS) );

    BOOL fSucc;
    SERVICE_STATUS ServiceStatus;
    fSucc = QueryServiceStatus(
                hService,
                &ServiceStatus
                );

    DWORD LastError = GetLastError();

    if(!fSucc)
    {
        CResString strErr(IDS_CANT_QUERY_SERVICE);
        BrErrorExit(LastError, strErr.Get(), pServiceName);
    }

    return (ServiceStatus.dwCurrentState == SERVICE_STOPPED);
}


static
void
BrpSendStopControlToService(
	SC_HANDLE hService,
	LPCWSTR pServiceName
	)
{
   	SERVICE_STATUS statusService;
	if (ControlService(
            hService,
            SERVICE_CONTROL_STOP,
            &statusService
            ))
	{
		return;
	}

	DWORD LastError = GetLastError();

	//
	// Service already stopped, and cannot accept stop control
	//
	if (LastError == ERROR_SERVICE_NOT_ACTIVE)
	{
		return;
	}

	//
	// Service cannot accept stop control if he is in 
	// SERVICE_STOP_PENDING state. This is OK.
	//
	if (LastError == ERROR_SERVICE_CANNOT_ACCEPT_CTRL && 
		statusService.dwCurrentState == SERVICE_STOP_PENDING)
	{
		return;
	}

    BrpWriteConsole(L"\n");
    CResString strErr(IDS_CANT_STOP_SERVICE);
    BrErrorExit(LastError, strErr.Get(), pServiceName);
}


static
void
BrpStopAnyService(
	SC_HANDLE hService,
	LPCWSTR pServiceName
	)
{
	//
	// Ask the service to stop
	//
	BrpSendStopControlToService(hService, pServiceName);

    //
    // Wait for the service to stop
    //

    for (;;)
    {
   		SERVICE_STATUS SrviceStatus;
        if (!QueryServiceStatus(hService, &SrviceStatus))
        {
            DWORD gle = GetLastError();
            BrpWriteConsole(L"\n");
            CResString strErr(IDS_CANT_QUERY_SERVICE);
            BrErrorExit(gle, strErr.Get(), pServiceName);
        }
        if (SrviceStatus.dwCurrentState == SERVICE_STOPPED)
        {
            break;
        }

        Sleep(2000);

        BrpWriteConsole(L".");
    }

    BrpWriteConsole(L"\n");

} // BrpStopAnyService


static
void
BrpStopMSMQService(
	SC_HANDLE hService
	)
{
	//
	// Get service process ID
	//
    SERVICE_STATUS_PROCESS ServiceStatusProcess;
	DWORD dwBytesNeeded;
    BOOL fSucc = QueryServiceStatusEx(
								hService,
								SC_STATUS_PROCESS_INFO,
								reinterpret_cast<LPBYTE>(&ServiceStatusProcess),
								sizeof(ServiceStatusProcess),
								&dwBytesNeeded
								);
    
    DWORD LastError = GetLastError();

    if(!fSucc)
    {
        BrpWriteConsole(L"\n");
        CResString strErr(IDS_CANT_QUERY_SERVICE);
        BrErrorExit(LastError, strErr.Get(), L"MSMQ");
    }

	//
	// Get hanlde to the service process
	//
	CHandle hProcess( OpenProcess(SYNCHRONIZE, FALSE, ServiceStatusProcess.dwProcessId) );
	
	LastError = GetLastError();

	if (hProcess == NULL)
	{
		//
		// The service is stopped. Either we got a 0
		// process ID in ServiceStatusProcess, or the ID
		// that we got was of a process that already stopped
		//
		if (LastError == ERROR_INVALID_PARAMETER)
		{
		    BrpWriteConsole(L"\n");
			return;
		}

        BrpWriteConsole(L"\n");
        CResString strErr(IDS_CANT_OPEN_PROCESS);
        BrErrorExit(LastError, strErr.Get(), L"MSMQ");
	}

	//
	// Ask the service to stop
	//
	BrpSendStopControlToService(hService, L"MSMQ");

    //
    // Wait for the service to terminate
    //
    for (;;)
    {
		DWORD dwRes = WaitForSingleObject(hProcess, 2000);
        
		if (dwRes == WAIT_FAILED)
        {
            DWORD gle = GetLastError();
            BrpWriteConsole(L"\n");
            CResString strErr(IDS_CANT_STOP_SERVICE);
            BrErrorExit(gle, strErr.Get(), L"MSMQ");
        }

        if (dwRes == WAIT_OBJECT_0)
        {
            break;
        }

        BrpWriteConsole(L".");
    }

    BrpWriteConsole(L"\n");

} // BrpStopAnyService


static
void
BrpStopService(
    LPCWSTR pServiceName
    )
{
    CServiceHandle hService(BrpGetServiceHandle(
										pServiceName, 
										SERVICE_STOP | SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG
										));

    BYTE ConfigData[4096];
    QUERY_SERVICE_CONFIG * pConfigData = reinterpret_cast<QUERY_SERVICE_CONFIG*>(&ConfigData);
    DWORD BytesNeeded;
    BOOL fSucc = QueryServiceConfig(hService, pConfigData, sizeof(ConfigData), &BytesNeeded);
    if (fSucc)
    {
        BrpWriteConsole(L"\t");
        BrpWriteConsole(pConfigData->lpDisplayName);
    }

	if (wcscmp(pServiceName, L"MSMQ") == 0)
	{
		BrpStopMSMQService(hService);
	}
	else
	{
		BrpStopAnyService(hService, pServiceName);
	}

} // BrpStopService


static
void
BrpStopDependentServices(
    LPCWSTR pServiceName,
    ENUM_SERVICE_STATUS * * ppDependentServices,
    DWORD * pNumberOfDependentServices
    )
{
    CServiceHandle hService( BrpGetServiceHandle(pServiceName, SERVICE_ENUMERATE_DEPENDENTS) );

    BOOL fSucc;
    DWORD BytesNeeded;
    DWORD NumberOfEntries;
    fSucc = EnumDependentServices(
                hService,
                SERVICE_ACTIVE,
                NULL,
                0,
                &BytesNeeded,
                &NumberOfEntries
                );

    DWORD LastError = GetLastError();

	if (BytesNeeded == 0)
    {
        return;
    }

    assert(!fSucc);

    if( LastError != ERROR_MORE_DATA)
    {
        CResString strErr(IDS_CANT_ENUM_SERVICE_DEPENDENCIES);
        BrErrorExit(LastError, strErr.Get(), pServiceName);
    }

    

    BYTE * pBuffer = new BYTE[BytesNeeded];
    if (pBuffer == NULL)
    {
        CResString strErr(IDS_NO_MEMORY);
        BrErrorExit(0, strErr.Get());
    }

    ENUM_SERVICE_STATUS * pDependentServices = reinterpret_cast<ENUM_SERVICE_STATUS*>(pBuffer);
    fSucc = EnumDependentServices(
                hService,
                SERVICE_ACTIVE,
                pDependentServices,
                BytesNeeded,
                &BytesNeeded,
                &NumberOfEntries
                );

    LastError = GetLastError();

    if(!fSucc)
    {
        CResString strErr(IDS_CANT_ENUM_SERVICE_DEPENDENCIES);
        BrErrorExit(LastError, strErr.Get(), pServiceName);
    }

    for (DWORD ix = 0; ix < NumberOfEntries; ++ix)
    {
        BrpStopService(pDependentServices[ix].lpServiceName);
    }

    *ppDependentServices = pDependentServices;
    *pNumberOfDependentServices = NumberOfEntries;
}


BOOL
BrStopMSMQAndDependentServices(
    ENUM_SERVICE_STATUS * * ppDependentServices,
    DWORD * pNumberOfDependentServices
    )
{
    //
    // MSMQ service is stopped, this is a no-op.
    //
    if (BrpIsServiceStopped(L"MSMQ"))
    {
        return FALSE;
    }

    CResString str(IDS_BKRESTORE_STOP_SERVICE);
    BrpWriteConsole(str.Get());

    //
    // Stop dependent services
    //
    BrpStopDependentServices(L"MSMQ", ppDependentServices, pNumberOfDependentServices);
	
    //
    // Stop MSMQ Service
    //
    BrpStopService(L"MSMQ");
    return TRUE;
}


static
void
BrpStartService(
    LPCWSTR pServiceName
    )
{
    CServiceHandle hService(BrpGetServiceHandle(
										pServiceName, 
										SERVICE_START | SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG
										));

    BYTE ConfigData[4096];
    QUERY_SERVICE_CONFIG * pConfigData = reinterpret_cast<QUERY_SERVICE_CONFIG*>(&ConfigData);
    DWORD BytesNeeded;
    BOOL fSucc = QueryServiceConfig(hService, pConfigData, sizeof(ConfigData), &BytesNeeded);
    if (fSucc)
    {
        BrpWriteConsole(L"\t");
        BrpWriteConsole(pConfigData->lpDisplayName);
    }

    fSucc = StartService(
                hService,
                0,      // number of arguments
                NULL    // array of argument strings 
                );

    if(!fSucc)
    {
        DWORD gle = GetLastError();
        BrpWriteConsole(L"\n");
        CResString strErr(IDS_CANT_START_SERVICE);
        BrErrorExit(gle, strErr.Get(), pServiceName);
    }

    //
    // Wait for the service to start
    //
    for (;;)
    {
        Sleep(2000);
        SERVICE_STATUS SrviceStatus;
        if (!QueryServiceStatus(hService, &SrviceStatus))
        {
            DWORD gle = GetLastError();
            BrpWriteConsole(L"\n");
            CResString strErr(IDS_CANT_QUERY_SERVICE);
            BrErrorExit(gle, strErr.Get(), pServiceName);
        }
        if (SrviceStatus.dwCurrentState == SERVICE_RUNNING)
        {
            break;
        }
        if (SrviceStatus.dwCurrentState == SERVICE_STOPPED)
        {
            break;
        }

        BrpWriteConsole(L".");
    }

    BrpWriteConsole(L"\n");
}



void
BrStartMSMQAndDependentServices(
    ENUM_SERVICE_STATUS * pDependentServices,
    DWORD NumberOfDependentServices
    )
{
    CResString str(IDS_START_SERVICE);
    BrpWriteConsole(str.Get());

    BrpStartService(L"MSMQ");

    if (pDependentServices == NULL)
    {
        return;
    }

    for (DWORD ix = 0; ix < NumberOfDependentServices; ++ix)
    {
        BrpStartService(pDependentServices[ix].lpServiceName);
    }

    delete [] pDependentServices;
}


inline
DWORD
AlignUp(
    DWORD Size,
    DWORD Alignment
    )
{
    Alignment -= 1;
    return ((Size + Alignment) & ~Alignment);
}


ULONGLONG
BrGetUsedSpace(
    LPCWSTR pDirName,
    LPCWSTR pMask
    )
{
    WCHAR FileName[MAX_PATH];
    wcscpy(FileName, pDirName);
    wcscat(FileName, pMask);

    HANDLE hEnum;
    WIN32_FIND_DATA FindData;
    hEnum = FindFirstFile(
                FileName,
                &FindData
                );

    if(hEnum == INVALID_HANDLE_VALUE)
    {
        DWORD gle = GetLastError();
        if(gle == ERROR_FILE_NOT_FOUND)
        {
            //
            // No matching file, used space is zero. if path does not exists
            // this is another error (3).
            //
            return 0;
        }

        CResString strErr(IDS_CANT_ACCESS_DIR);
        BrErrorExit(gle, strErr.Get(), pDirName);
    }

    ULONGLONG Size = 0;
    do
    {
        //
        // Round up to sectore alignment and sum up file sizes
        //
        Size += AlignUp(FindData.nFileSizeLow, 512);

    } while(FindNextFile(hEnum, &FindData));

    FindClose(hEnum);
    return Size;
}


ULONGLONG
BrGetXactSpace(
    LPCWSTR pDirName
    )
{
    ULONGLONG Size = 0;
    for(int i = 0; i < xXactFileListSize; i++)
    {
        Size += BrGetUsedSpace(pDirName, xXactFileList[i]);
    }

    return Size;
}


ULONGLONG
BrGetFreeSpace(
    LPCWSTR pDirName
    )
{
    BOOL fSucc;
    ULARGE_INTEGER CallerFreeBytes;
    ULARGE_INTEGER CallerTotalBytes;
    ULARGE_INTEGER AllFreeBytes;
    fSucc = GetDiskFreeSpaceEx(
                pDirName,
                &CallerFreeBytes,
                &CallerTotalBytes,
                &AllFreeBytes
                );
    if(!fSucc)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_GET_FREE_SPACE);
        BrErrorExit(gle, strErr.Get(), pDirName);
    }

    return CallerFreeBytes.QuadPart;
}


HKEY
BrCreateKey(
    LPCWSTR pMsmqRootRegistry
    )
{
    LONG lRes;
    HKEY hKey;
    lRes = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            pMsmqRootRegistry,
            0,      // reserved
            0,      // address of class string
            REG_OPTION_BACKUP_RESTORE,
            0,      // desired security access
            0,      // address of key security structure
            &hKey,
            0       // address of disposition value buffer
            );

    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_OPEN_MSMQ_REG);
        BrErrorExit(lRes, strErr.Get(), pMsmqRootRegistry);
    }

    return hKey;
}


void
BrSaveKey(
    HKEY hKey,
    LPCWSTR pDirName,
    LPCWSTR pFileName
    )
{
    WCHAR FileName[MAX_PATH];
    wcscpy(FileName, pDirName);
    wcscat(FileName, pFileName);

    LONG lRes;
    lRes = RegSaveKey(
            hKey,
            FileName,
            NULL    // file security attributes
            );

    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_SAVE_MSMQ_REGISTRY);
        BrErrorExit(lRes, strErr.Get());
    }
}


void
BrRestoreKey(
    HKEY hKey,
    LPCWSTR pDirName,
    LPCWSTR pFileName
    )
{
    WCHAR FileName[MAX_PATH];
    wcscpy(FileName, pDirName);
    wcscat(FileName, pFileName);

    LONG lRes;
    lRes = RegRestoreKey(
            hKey,
            FileName,
            0   // option flags
            );

    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_RESTORE_MSMQ_REGISTRY);
        BrErrorExit(lRes, strErr.Get());
    }
}


void
BrSetRestoreSeqID(
    LPCWSTR pMsmqParametersRegistry
    )
{
    LONG lRes;
    HKEY hKey;
    DWORD RegSeqID = 0;
    
    lRes = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            pMsmqParametersRegistry,
            0,
            KEY_READ | KEY_WRITE,
            &hKey
            );

    if(lRes != ERROR_SUCCESS)
    {
        CResString strErr(IDS_CANT_OPEN_REG_KEY_READ_WRITE);
        BrErrorExit(lRes, strErr.Get(), pMsmqParametersRegistry);
    }

    //
    // get last SeqID used before backup
    //
    BrpQueryDwordValue(hKey,  L"SeqID", &RegSeqID);

    //
    // Increment by 1, so we will not use the same SeqID more than once in successive restores.
    //
    ++RegSeqID;

    //
    // Select the max SeqID, Time or Registry. This overcomes date/time changes on this computer 
    // in a following scenario: Backup, Restore, reset time back, Start QM 
    //      (without max with Time here QM at start will not move SeqID enough to avoid races)
    //      
    DWORD TimeSeqID = MqSysTime();
    DWORD dwSeqID = max(RegSeqID, TimeSeqID);

    //
    // Write-back selected SeqID so we will start from this value
    //
    BrpSetDwordValue(hKey,  L"SeqID", dwSeqID);

    //
    // Write-back selected SeqIDAtRestoreTime so that we'll know the boundary
    //
    BrpSetDwordValue(hKey,  L"SeqIDAtLastRestore", dwSeqID);
}


void
BrCopyFiles(
    LPCWSTR pSrcDir,
    LPCWSTR pMask,
    LPCWSTR pDstDir
    )
{
    WCHAR SrcPathName[MAX_PATH];
    wcscpy(SrcPathName, pSrcDir);
    wcscat(SrcPathName, pMask);
    LPWSTR pSrcName = wcsrchr(SrcPathName, L'\\') + 1;

    WCHAR DstPathName[MAX_PATH];
    wcscpy(DstPathName, pDstDir);
    if (DstPathName[wcslen(DstPathName)-1] != L'\\')
    {
        wcscat(DstPathName, L"\\");
    }


    HANDLE hEnum;
    WIN32_FIND_DATA FindData;
    hEnum = FindFirstFile(
                SrcPathName,
                &FindData
                );

    if(hEnum == INVALID_HANDLE_VALUE)
    {
        DWORD gle = GetLastError();
        if(gle == ERROR_FILE_NOT_FOUND)
        {
            //
            // No matching file, just return without copy. if path does not
            // exists this is another error (3).
            //
            return;
        }

        CResString strErr(IDS_CANT_ACCESS_DIR);
        BrErrorExit(gle, strErr.Get(), pSrcDir);
    }

    do
    {
        //
        // We don't copy sub-directories
        //
        if((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
            continue;

        BrpWriteConsole(L".");
        wcscpy(pSrcName, FindData.cFileName);
        WCHAR DstName[MAX_PATH];
        wcscpy(DstName, DstPathName);
        wcscat(DstName, FindData.cFileName);

        BOOL fSucc;
        fSucc = CopyFile(
                    SrcPathName,
                    DstName,
                    TRUE   // fail if file exits
                    );
        if(!fSucc)
        {
            DWORD gle = GetLastError();
            CResString strErr(IDS_CANT_COPY);
            BrErrorExit(gle, strErr.Get(), SrcPathName, DstPathName);
        }

    } while(FindNextFile(hEnum, &FindData));

    FindClose(hEnum);
}


void
BrCopyXactFiles(
    LPCWSTR pSrcDir,
    LPCWSTR pDstDir
    )
{
    for(int i = 0; i < xXactFileListSize; i++)
    {
        BrCopyFiles(pSrcDir, xXactFileList[i], pDstDir);
    }
}


void
BrSetDirectorySecurity(
    LPCWSTR pDirName
    )
/*++

Routine Description:
    Configures security on a directory. Failures ignored.

    The function sets the security of the given directory such that
    any file that is created in the directory will have full control
    for  the local administrators group and no access at all to
    anybody else.


Arguments:
    pDirName - Directory Path.

Return Value:
    None.

--*/
{
    //
    // Get the SID of the local administrators group.
    //
    PSID pAdminSid;
    SID_IDENTIFIER_AUTHORITY NtSecAuth = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(
                &NtSecAuth,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,
                0,
                0,
                0,
                0,
                0,
                &pAdminSid
                ))
    {
        return; 
    }

    //
    // Create a DACL so that the local administrators group will have full
    // control for the directory and full control for files that will be
    // created in the directory. Anybody else will not have any access to the
    // directory and files that will be created in the directory.
    //
    ACL* pDacl;
    DWORD dwDaclSize;

    WORD dwAceSize = (WORD)(sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminSid) - sizeof(DWORD));
    dwDaclSize = sizeof(ACL) + 2 * (dwAceSize);
    pDacl = (PACL)(char*) new BYTE[dwDaclSize];
    if (NULL == pDacl)
    {
        return; 
    }
    ACCESS_ALLOWED_ACE* pAce = (PACCESS_ALLOWED_ACE) new BYTE[dwAceSize];
    if (NULL == pAce)
    {
        delete [] pDacl;
        return;
    }

    pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    pAce->Header.AceFlags = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;
    pAce->Header.AceSize = dwAceSize;
    pAce->Mask = FILE_ALL_ACCESS;
    memcpy(&pAce->SidStart, pAdminSid, GetLengthSid(pAdminSid));

    //
    // Create the security descriptor and set the it as the security
    // descriptor of the directory.
    //
    SECURITY_DESCRIPTOR SD;

    if (!InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION) ||
        !InitializeAcl(pDacl, dwDaclSize, ACL_REVISION) ||
        !AddAccessAllowedAce(pDacl, ACL_REVISION, FILE_ALL_ACCESS, pAdminSid) ||
        !AddAce(pDacl, ACL_REVISION, MAXDWORD, (LPVOID) pAce, dwAceSize) ||
        !SetSecurityDescriptorDacl(&SD, TRUE, pDacl, FALSE) ||
        !SetFileSecurity(pDirName, DACL_SECURITY_INFORMATION, &SD))
    {
        // 
        // Ignore failure
        //
    }

    FreeSid(pAdminSid);
    delete [] pDacl;
    delete [] pAce;

} //BrpSetDirectorySecurity


static
bool
BrpIsDirectory(
    LPCWSTR pDirName
    )
{
    DWORD attr = GetFileAttributes(pDirName);
    
    if ( 0xFFFFFFFF == attr )
    {
        //
        // BUGBUG? Ignore errors, just report to caller this is
        // not a directory.
        //
        return false;
    }
    
    return ( 0 != (attr & FILE_ATTRIBUTE_DIRECTORY) );

} //BrpIsDirectory


void
BrCreateDirectory(
    LPCWSTR pDirName
    )
{
    //
    // First, check if the directory already exists
    //
    if (BrpIsDirectory(pDirName))
    {
        return;
    }

    //
    // Second, try to create it.
    //
    // Don't remove the code for checking ERROR_ALREADY_EXISTS.
    // It could be that we fail to verify that the directory exists
    // (eg security or parsing problems - see documentation of GetFileAttributes() ), 
    // but when trying to create it we get an error that it already exists. 
    // Be on the safe side. (ShaiK, 31-Dec-98)
    //
    if (!CreateDirectory(pDirName, 0) && 
        ERROR_ALREADY_EXISTS != GetLastError())
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_CREATE_DIR);
        BrErrorExit(gle, strErr.Get(), pDirName);
    }
} //BrCreateDirectory


void
BrCreateDirectoryTree(
    LPCWSTR pDirName
    )
/*++

Routine Description:
    Creates local or remote directory tree

Arguments:
    pDirName - full pathname

Return Value:
    None.

--*/
{
    if (BrpIsDirectory(pDirName))
    {
        return;
    }

    if (CreateDirectory(pDirName, 0) || 
        ERROR_ALREADY_EXISTS == GetLastError())
    {
        return;
    }

    TCHAR szDir[MAX_PATH];
    wcscpy(szDir, pDirName);
    if (szDir[wcslen(szDir)-1] != L'\\')
    {
        wcscat(szDir, L"\\");
    }

    PTCHAR p = &szDir[0];
    if (wcslen(szDir) > 2 && szDir[0] == L'\\' && szDir[1] == L'\\')
    {
        //
        // Remote full path: \\machine\share\dir1\dir2\dir3
        // 
        // Point to top level remote parent directory: \\machine\share\dir1
        //
        p = wcschr(&szDir[2], L'\\');
        if (p != 0)
        {
            p = wcschr(CharNext(p), L'\\');
            if (p != 0)
            {
                p = CharNext(p);
            }
        }
    }
    else
    {
        //
        // Local full path: x:\dir1\dir2\dir3
        //
        // Point to top level parent directory: x:\dir1
        //
        p = wcschr(szDir, L'\\');
        if (p != 0)
        {
            p = CharNext(p);
        }
    }

    for ( ; p != 0 && *p != 0; p = CharNext(p))
    {
        if (*p != L'\\')
        {
            continue;
        }

        *p = 0;
        BrCreateDirectory(szDir);
        *p = L'\\';
    }
} //BrCreateDirectoryTree


void
BrVerifyBackup(
    LPCWSTR pBackupDir,
    LPCWSTR pBackupDirStorage
    )
{
    //
    //  1. Verify that this is a valid backup
    //
    if(BrGetUsedSpace(pBackupDir, xBackupIDFileName) == 0)
    {
        CResString strErr(IDS_NOT_VALID_BK);
        BrErrorExit(0, strErr.Get(), xBackupIDFileName);
    }

    //
    //  2. Verify that all must exist files are there
    //
    if(BrGetUsedSpace(pBackupDir, xRegistryFileName) == 0)
    {
        CResString strErr(IDS_NOT_VALID_BK);
        BrErrorExit(0, strErr.Get(), xRegistryFileName);
    }

    for(int i = 0; i < xXactFileListSize; i++)
    {
        if(BrGetUsedSpace(pBackupDirStorage, xXactFileList[i]) == 0)
        {
            CResString strErr(IDS_NOT_VALID_BK);
            BrErrorExit(0, strErr.Get(), xXactFileList[i]);
        }
    }

    //
    //  3. Verify that this backup belong to this machine
    //
} 


BOOL 
BrIsFileInUse(
	LPCWSTR pFileName
	)
/*++

Routine Description:

	Checks whether the given file in the system's directory is in use (loaded)

Arguments:

    pFileName - File name to check

Return Value:

    TRUE             - In use
    FALSE            - Not in use 

--*/
{
    //
    // Form the path to the file
    //   
    WCHAR szFilePath[MAX_PATH ];
	WCHAR szSystemDir[MAX_PATH];
	GetSystemDirectory(szSystemDir, MAX_PATH);

    swprintf(szFilePath, L"%s\\%s", szSystemDir, pFileName);

    //
    // Attempt to open the file for writing
    //
    HANDLE hFile = CreateFile(szFilePath, GENERIC_WRITE, 0, NULL,
                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    DWORD err = GetLastError();
	//
    // A sharing violation indicates that the file is already in use
    //
    if (hFile == INVALID_HANDLE_VALUE &&
        err == ERROR_SHARING_VIOLATION)
    {
        return TRUE;
    }

    //
    // The file handle is no longer needed
    //
    CloseHandle(hFile);


    return FALSE;
}

 
BOOL CALLBACK BrFindSpecificModuleCallback(
									PSTR       Name,
									DWORD64     Base,
									ULONG       Size,
									PVOID       Context
									)

/*++

Routine Description:

    Callback function for module enumeration - search for a specific module

Arguments:

    Name        - Module name
    Base        - Base address
    Size        - Size of image
    Context     - User context pointer

Return Value:

    TRUE             - Continue enumeration
    FALSE            - Stop enumeration

--*/

{
	UNREFERENCED_PARAMETER( Base);
	UNREFERENCED_PARAMETER( Size);

	pEnumarateData pEd = reinterpret_cast<pEnumarateData>(Context);

    WCHAR wzName[255];
	ConvertToWideCharString(Name, wzName, sizeof(wzName)/sizeof(wzName[0]));
	BOOL fDiff= CompareStringsNoCase(wzName,pEd->pModuleName);

	if (!fDiff)
	{	
		//
		// The Moudle name was found
		//
        pEd->fFound = TRUE;
        return FALSE; // Found Module so stop enumerating
    }

    return TRUE;// Continue enumeration.
}



BOOL
BrChangeDebugPriv(
    BOOL fEnable
    )

/*++

Routine Description:

    Changes the process's privilige so that EnumerateLoadedModules64 works properly.
	set the process's privilige according to fEnable

Arguments:

	BOOL fEnable     - Enable or Disable the process's privilige

Return Value:

    TRUE             - success
    FALSE            - failure

--*/

{  
	//
    // Retrieve a handle of the access token
    //
	CHandle hToken;
	BOOL fSuccess = OpenProcessToken(
						GetCurrentProcess(),
						TOKEN_ADJUST_PRIVILEGES,
						&hToken
						);
    if (!fSuccess) 
	{
        return FALSE;
    }

    //
    // Enable/Disable the SE_DEBUG_NAME privilege 
    //
	LUID DebugValue;
	fSuccess = LookupPrivilegeValue(
					NULL,
				    SE_DEBUG_NAME,
					&DebugValue
					);
    if (!fSuccess)
	{
        return FALSE;
    }

	TOKEN_PRIVILEGES tkp;
    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid = DebugValue;
    
	if(fEnable)
	{
		tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	}
	else
	{
		tkp.Privileges[0].Attributes = 0;
	}

	return AdjustTokenPrivileges(
					hToken,
		            FALSE,
			        &tkp,
				    sizeof(TOKEN_PRIVILEGES),
					(PTOKEN_PRIVILEGES) NULL,
				    (PDWORD) NULL
					);

}

eModuleLoaded 
BrIsModuleLoaded(
	DWORD processId,
	LPCWSTR pModuleName,
    EnumerateLoadedModules_ROUTINE pfEnumerateLoadedModules
	)
/*++

Routine Description:

	Check if a certain module is loaded

Arguments:

   processId	- process Id 
   pModuleName	- module name
   pfEnumerateLoadedModules - function pointer to EnumerateLoadedModules64()
   
Return Value:

    TRUE	-	loaded
	FALSE	-	not loaded

--*/
{
	EnumarateData ed;
	ed.fFound = FALSE;
	ed.pModuleName = pModuleName;
	
	//
	// Note: EnumerateLoadedModules64() is supported On NT5 
	// The API enumerate all modles in the process and execute the callback function for every module
	//

    BOOL fSuccess = pfEnumerateLoadedModules(
						(HANDLE)(LONG_PTR)processId,
					    BrFindSpecificModuleCallback,
					    &ed
						);
	if(!fSuccess)
	{
		//
		// Access denied, warn user that we don't know if this process uses the "mqrt.dll" module
		//
		return e_CANT_DETERMINE;
	}
	
	if(ed.fFound)
	{
		return e_LOADED;
	}
	
	return e_NOT_LOADED;
}


void
BrPrintAffecetedProcesses(
	LPCWSTR pModuleName
	)
/*++

Routine Description:

	Print all processes that loaded a certain module.
	Note: this function assumes that the system is NT5 .

Arguments:

   pModuleName        - Module name
    
Return Value:

    None

--*/
{
    
	
	//
    // Obtain pointers to the tool help functions.
    //
	// Note: we can't call these function in the conventional way becouse that result in
	// an error trying to load this executable under NT4 (undefined entry point)
    //

    assert(BrIsSystemNT5());

    HINSTANCE hKernelLibrary = GetModuleHandle(L"kernel32.dll");
	assert(hKernelLibrary != NULL);

    typedef HANDLE (WINAPI *FUNCCREATETOOLHELP32SNAPSHOT)(DWORD, DWORD);
    FUNCCREATETOOLHELP32SNAPSHOT pfCreateToolhelp32Snapshot =
		(FUNCCREATETOOLHELP32SNAPSHOT)GetProcAddress(hKernelLibrary,
													 "CreateToolhelp32Snapshot");
	if(pfCreateToolhelp32Snapshot == NULL)
    {   
        WCHAR szBuf[1024] = {0};
        CResString strLoadProblem(IDS_CANT_LOAD_FUNCTION);
        DWORD rc = BrpFormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            strLoadProblem.Get(),
            0,
            0,
            szBuf,
            0,
            L"CreateToolhelp32Snapshot"
            );

        if (rc != 0)
        {
            BrpWriteConsole(szBuf);
        }
        return;
    }

	typedef BOOL (WINAPI *PROCESS32FIRST)(HANDLE ,LPPROCESSENTRY32 );
	PROCESS32FIRST pfProcess32First = (PROCESS32FIRST)GetProcAddress(hKernelLibrary,
																	"Process32FirstW");

    if(pfProcess32First == NULL)
    {   
        WCHAR szBuf[1024] = {0};
        CResString strLoadProblem(IDS_CANT_LOAD_FUNCTION);
        DWORD rc = BrpFormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            strLoadProblem.Get(),
            0,
            0,
            szBuf,
            0,
            L"pfProcess32First"
            );

        if (rc != 0)
        {
            BrpWriteConsole(szBuf);
            BrpWriteConsole(L"\n");
        }
        return;
    }
    
	typedef BOOL (WINAPI *PROCESS32NEXT)(HANDLE ,LPPROCESSENTRY32 );
	PROCESS32NEXT pfProcess32Next = (PROCESS32NEXT)GetProcAddress(hKernelLibrary,
																	"Process32NextW");
    
    if(pfProcess32Next == NULL)
    {   
        WCHAR szBuf[1024] = {0};
        CResString strLoadProblem(IDS_CANT_LOAD_FUNCTION);
        DWORD rc = BrpFormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            strLoadProblem.Get(),
            0,
            0,
            szBuf,
            0,
            L"pfProcess32Next"
            );

        if (rc != 0)
        {
            BrpWriteConsole(szBuf);
        }
        return;
    }

	

    CAutoFreeLibrary hDbghlpLibrary = LoadLibrary(L"dbghelp.dll");
	if (hDbghlpLibrary == NULL)
    {
        CResString strLibProblem(IDS_CANT_SHOW_PROCESSES_LIB_PROBLEM);
        BrpWriteConsole(strLibProblem.Get());
        return;
    }

    
    EnumerateLoadedModules_ROUTINE pfEnumerateLoadedModules = (EnumerateLoadedModules_ROUTINE)
        GetProcAddress(hDbghlpLibrary, "EnumerateLoadedModules64");

	if(pfEnumerateLoadedModules == NULL)
    {   
        WCHAR szBuf[1024] = {0};
        CResString strLoadProblem(IDS_CANT_LOAD_FUNCTION);
        DWORD rc = BrpFormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            strLoadProblem.Get(),
            0,
            0,
            szBuf,
            0,
            L"EnumerateLoadedModules64"
            );

        if (rc != 0)
        {
            BrpWriteConsole(szBuf);
        }
        return;
    }

	//
	// Take the current snapshot of the system
	//

	HANDLE hSnapshot = pfCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)	;
    if(hSnapshot == INVALID_HANDLE_VALUE)
    {
        CResString strSnapProblem(IDS_CANT_CREATE_SNAPSHOT);
        BrpWriteConsole(strSnapProblem.Get());
        return;

    }


    PROCESSENTRY32 entryProcess;
    entryProcess.dwSize = sizeof(entryProcess);

	BOOL bNextProcess = pfProcess32First(hSnapshot, &entryProcess);
	
	
	//
    // Enable access to all processes, to check if they use pModuleName.
    //
    if(!BrChangeDebugPriv(TRUE))
	{
		BrpWriteConsole(L"Can't access all processes, Notice we can't determine the affect on all processes\n");
	}
	
	//
	// Iterate on all running processes and check if the loaded a certain module
	//
	while (bNextProcess)
	{
    
		//
		// For every process check it's loaded modules and if pModuleName
		// is loaded print the process name 
		//
		eModuleLoaded eModuleStatus = BrIsModuleLoaded(entryProcess.th32ProcessID,pModuleName,pfEnumerateLoadedModules);
		if(eModuleStatus == e_LOADED)
		{
            BrpWriteConsole(entryProcess.szExeFile);
            BrpWriteConsole(L" \n");
		}
		
		bNextProcess = pfProcess32Next(hSnapshot, &entryProcess);
	}  

	//
    // Restore access to all processes as it was before last call to BrChangeDebugPriv().
    //
    BrChangeDebugPriv(FALSE);
}	

void
BrVerifyUserWishToContinue()
/*++

Routine Description:

	Verify the user wish to continue.

Arguments:

    None

Return Value:

    None
	
--*/
{
	CResString strVerify(IDS_VERIFY_CONTINUE);
    CResString strY(IDS_Y);
    CResString strN(IDS_N);
	WCHAR szBuf[MAX_PATH] = {0};

    DWORD rc = BrpFormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        strVerify.Get(),
        0,
        0,
        szBuf,
        0,
        strY.Get(),
        strN.Get()
        );

    if (rc == 0)
    {
        //
        // NOTE:  Failed to generate  message, continue as if the user chose yes, not harmful
        //
        return;
    }

    for (;;)
    {
        BrpWriteConsole(szBuf);
        
        WCHAR sz[260] = {0};
        wscanf(L"%259s", sz);

        if (0 == CompareStringsNoCase(sz, strY.Get()))
        {
            break;
        }

        if (0 == CompareStringsNoCase(sz, strN.Get()))
        {
            CResString strAbort(IDS_ABORT);
            BrpWriteConsole(strAbort.Get());
            exit(-1);
        }
    }
}//BrVerifyUserWishToContinue


void
BrNotifyAffectedProcesses(
		  LPCWSTR pModuleName
		  )
/*++

Routine Description:

    Checks whether a certain file in the system's directory is loaded by any process,
	and notify the user 

Arguments:

    pModuleName        - Module name
    
Return Value:

    None
--*/

{
	BOOL fUsed = BrIsFileInUse(pModuleName);
	if(!fUsed)
	{
		//
		// The file is not in use -> not loaded ,no reason to continue
		//
		return;
	}
	else 
	{
		CResString str(IDS_SEARCHING_AFFECTED_PROCESSES);
        BrpWriteConsole(str.Get());
		BrPrintAffecetedProcesses(pModuleName);
		if(!g_fNoPrompt)
		{
			BrVerifyUserWishToContinue();
		}
	}
}


BOOL 
BrIsSystemNT5()
/*++

Routine Description:

	Checks whether the operating system is NT5 or later
	Note:if the function can't verify the current running version of the system
		 the assumption is that the version is other than NT5

Arguments:

    None

Return Value:

    TRUE             - Operating system is NT5 or later
    FALSE            - Other

--*/

{	
	OSVERSIONINFO systemVer;
	systemVer.dwOSVersionInfoSize  =  sizeof(OSVERSIONINFO) ;
	BOOL fSucc = GetVersionEx (&systemVer);
	if(!fSucc)
	{
		//
		// could not verify system's version , we return false just to be on the safe side
		//
		return FALSE;
	}
	else 
	{
		if( (systemVer.dwPlatformId == VER_PLATFORM_WIN32_NT) && (systemVer.dwMajorVersion >= 5))
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}

}


HRESOURCE
BrClusterResourceNameToHandle(
    LPCWSTR pResourceName
    )
/*++

Routine Description:

    Opens a handle to the specified cluster resource and returns it.
    It is the responsibility of the caller to close the handle.

Arguments:

    pResourceName - The name of the cluster resource.

Return Value:

    A valid open handle to the specified cluster resource.

--*/
{
    CAutoCluster hCluster(OpenCluster(NULL));
    if (hCluster == NULL)
    {
        CResString strErr(IDS_CANNOT_OPEN_HANDLE_TO_CLUSTER);
        BrErrorExit(GetLastError(), strErr.Get());
    }

    CClusterResource hResource(OpenClusterResource(hCluster, pResourceName));
    if (hResource == NULL)
    {
        CResString strErr(IDS_CANNOT_OPEN_HANDLE_TO_RESOURCE);
        BrErrorExit(GetLastError(), strErr.Get(), pResourceName);
    }

    return hResource.detach();
}


DWORD
BrClusterResourceControl(
    LPCWSTR pResourceName,
    DWORD ControlCode,
    LPCWSTR pInString,
    LPWSTR pOutString,
    DWORD  cbOutBufferSize
    )
/*++

Routine Description:

    A wrapper for the ClusterResourceControl API that handles opening/closing
    a handle to the resource.

Arguments:

    pResourceName - The name of the cluster resource.

    ControlCode   - The control code.
    
    pInString     - NULL pointer, or pointer to input buffer that must contain a string.

    pOutString    - NULL pointer, or pointer to output buffer that will be filled with a string.

    cbOutBufferSize - The size in bytes of the output buffer, or zero if none.

Return Value:

    The status returned from ClusterResourceControl, either success or failure.

--*/
{
    CClusterResource hResource(BrClusterResourceNameToHandle(pResourceName));

    DWORD cbInBufferSize = 0;
    if (pInString != NULL)
    {
        cbInBufferSize = numeric_cast<DWORD>((wcslen(pInString) + 1)* sizeof(WCHAR));
    }

    DWORD BytesReturned = 0;
    DWORD status;
    status = ClusterResourceControl(
                 hResource,
                 NULL,
                 ControlCode,
                 const_cast<LPWSTR>(pInString),
                 cbInBufferSize,
                 pOutString,
                 cbOutBufferSize,
                 &BytesReturned
                 );

    return status;
};


bool
BrCopyResourceNameOnTypeMatch(
    LPCWSTR pClusterResourceName,
    LPCWSTR pClusterResourceType,
    AP<WCHAR>& pResourceName
    )
/*++

Routine Description:

    If the specified cluster resources is of the specified type, allocates a buffer
    for the resource name and copies the resource name onto the buffer.

    The buffers is allocated by the callee and deallocated by the caller using the
    autoclass template AP<>.

Arguments:

    pClusterResourceName - Name of a cluster resource, to query its type.

    pClusterResourceType - Type of a cluster resource, to try to match with the resource.

    pResourceName - Points to a buffer that will be filled with the name of the resource,
                    in case there's a match between the resource type and specified type.

Return Value:

    true  - The specified cluster resource is of the specified type.
    false - The specified cluster resource is not of the specified type.

--*/
{
    WCHAR TypeName[255] = L"";
    DWORD status = BrClusterResourceControl(
                       pClusterResourceName, 
                       CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                       NULL, 
                       TypeName,
                       sizeof(TypeName)
                       );

    if (status == ERROR_MORE_DATA)
        return false;

    if (FAILED(status))
    {
        CResString strErr(IDS_CANNOT_GET_RESOURCE_TYPE);
        BrErrorExit(status, strErr.Get(), pClusterResourceName);
    }

    if (wcscmp(TypeName, pClusterResourceType) != 0)
        return false;

    pResourceName = new WCHAR[wcslen(pClusterResourceName) + 1];
    if (pResourceName == NULL)
    {
        CResString strErrNoMemory(IDS_NO_MEMORY);
        BrErrorExit(0, strErrNoMemory.Get());
    }

    wcscpy(pResourceName.get(), pClusterResourceName);
    return true;
}


void
BrGetClusterResourceServiceName(
    LPCWSTR pPrefix,
    LPCWSTR pClusterResourceName,
    LPWSTR  pServiceName
    )
/*++

Routine Description:

    Fills the buffer with the NT service name that is encapsulated by the
    specified MSMQ or MSMQ Triggers cluster resource.

    The code to compose the service name out of the resource name is taken
    directly from the MSMQ cluster resource DLLs (mqclusp.cpp and trigclusp.cpp), 
    including the length of the buffer (200 WCHARs).

Arguments:

    pPrefix - The prefix of the NT service name.

    pClusterResourceName - The name of the MSMQ or MSMQ Triggers cluster resource.

    pServiceName - Points to buffer that will be filled with the NT service name.
                   The buffer is assumed to be of size MAX_PATH (in WCHARs).

Return Value:

    None.

--*/
{
    WCHAR ServiceName[200];
    ZeroMemory(ServiceName, sizeof(ServiceName));

    wcscpy(ServiceName, pPrefix);

    wcsncat(ServiceName, pClusterResourceName, STRLEN(ServiceName) - wcslen(ServiceName));
    wcscpy(pServiceName, ServiceName);
}


void
BrGetMsmqRootRegistry(
    LPCWSTR pMsmqClusterResourceName,
    LPWSTR pMsmqRootRegistry
    )
/*++

Routine Description:

    Fills the buffer with the MSMQ root registry section name.
    For standard MSMQ service: Software\Microsoft\MSMQ
    For cluster resource: Software\Microsoft\MSMQ\Clustered Qms\MSMQ$<Resource Name>

Arguments:

    pMsmqClusterResourceName - The name of the MSMQ cluster resource, if any.

    pMsmqRootRegistry - Points to buffer that will be filled with the registry section name.
                        The buffer is assumed to be of size MAX_PATH (in WCHARs).

Return Value:

    None.

--*/
{
    //
    // Standard MSMQ service: Software\Microsoft\MSMQ
    //
    if (pMsmqClusterResourceName == NULL)
    {
        wcscpy(pMsmqRootRegistry, FALCON_REG_MSMQ_KEY);
        return;
    }

    //
    // MSMQ cluster resource: Software\Microsoft\MSMQ\Clustered QMs\MSMQ$<Resource Name>
    //
    LPCWSTR x_SERVICE_PREFIX = L"MSMQ$";
    WCHAR ServiceName[MAX_PATH];
    BrGetClusterResourceServiceName(x_SERVICE_PREFIX, pMsmqClusterResourceName, ServiceName);

    wcscpy(pMsmqRootRegistry, FALCON_CLUSTERED_QMS_REG_KEY);
    wcscat(pMsmqRootRegistry, ServiceName);
}


void
BrGetMsmqParametersRegistry(
    LPCWSTR pMsmqRootRegistry,
    LPWSTR  pMsmqParametersRegistry
    )
{
    wcscpy(pMsmqParametersRegistry, pMsmqRootRegistry);
    wcscat(pMsmqParametersRegistry, FALCON_REG_KEY_PARAM);
}


bool
BrTakeOfflineResource(
    LPCWSTR pClusterResourceName
    )
/*++

Routine Description:

    Takes offline the specified cluster resource and return a bool indicating if
    it was online or not.

Arguments:

    pClusterResourceName - The name of the MSMQ or MSMQ Triggers cluster resource.

Return Value:

    true -  The resource was online.
    false - The resource was not online.

--*/
{
    CClusterResource hResource(BrClusterResourceNameToHandle(pClusterResourceName));

    CLUSTER_RESOURCE_STATE state = GetClusterResourceState(hResource, NULL, NULL, NULL, NULL);
    if (state == ClusterResourceStateUnknown)
    {
        CResString strErr(IDS_CANNOT_GET_RESOURCE_STATE);
        BrErrorExit(0, strErr.Get(), pClusterResourceName);
    }

    bool fRestart = (state == ClusterResourceInitializing || state == ClusterResourceOnline || state == ClusterResourceOnlinePending);
    if (fRestart || state == ClusterResourcePending || state == ClusterResourceOfflinePending)
    {
        //
        // MSMQ resoucess and MSMQ Triggers resources do not return ERROR_IO_PENDING.
        // The MSMQ cluster resource DLL stops and deletes the MSMQ service/driver before
        // returning the Offline call.
        //
        DWORD status = OfflineClusterResource(hResource);
        if (FAILED(status) || status == ERROR_IO_PENDING)
        {
            CResString strErr(IDS_CANNOT_TAKE_RESOURCE_OFFLINE);
            BrErrorExit(status, strErr.Get(), pClusterResourceName);
        }
    }

    return fRestart;
}


void
BrBringOnlineResource(
    LPCWSTR pClusterResourceName
    )
/*++

Routine Description:

    Brings online the specified cluster resource.

Arguments:

    pClusterResourceName - The name of the MSMQ or MSMQ Triggers cluster resource.

Return Value:

    None.

--*/
{
    CClusterResource hResource(BrClusterResourceNameToHandle(pClusterResourceName));

    DWORD status = OnlineClusterResource(hResource);
    if (FAILED(status))
    {
        CResString strErr(IDS_CANNOT_BRING_RESOURCE_ONLINE);
        BrErrorExit(status, strErr.Get(), pClusterResourceName);
    }
};


void
BrAddRegistryCheckpoint(
    LPCWSTR pClusterResourceName,
    LPCWSTR pRegistrySection
    )
/*++

Routine Description:

    Adds a cluster registry checkpoint.

Arguments:

    pClusterResourceName - The name of the MSMQ or MSMQ Triggers cluster resource.

    pRegistrySection - The name of the MSMQ or MSMQ Triggers cluster resource registry.

Return Value:

    None.

--*/
{
    DWORD status = BrClusterResourceControl(
                       pClusterResourceName, 
                       CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT,
                       pRegistrySection, 
                       NULL,
                       0
                       );

    if (status == ERROR_ALREADY_EXISTS)
        return;

    if (FAILED(status))
    {
        CResString strErr(IDS_CANNOT_ADD_REGISTRY_CHECKPOINT);
        BrErrorExit(status, strErr.Get(), pRegistrySection, pClusterResourceName);
    }
};


void
BrRemoveRegistryCheckpoint(
    LPCWSTR pClusterResourceName,
    LPCWSTR pRegistrySection
    )
/*++

Routine Description:

    Deletes a cluster registry checkpoint.

Arguments:

    pClusterResourceName - The name of the MSMQ or MSMQ Triggers cluster resource.

    pRegistrySection - The name of the MSMQ or MSMQ Triggers cluster resource registry.

Return Value:

    None.

--*/
{
    DWORD status = BrClusterResourceControl(
                       pClusterResourceName, 
                       CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT,
                       pRegistrySection, 
                       NULL,
                       0
                       );

    if (status == ERROR_FILE_NOT_FOUND)
        return;

    if (FAILED(status))
    {
        CResString strErr(IDS_CANNOT_DELETE_REGISTRY_CHECKPOINT);
        BrErrorExit(status, strErr.Get(), pRegistrySection, pClusterResourceName);
    }
};


void
BrGetTriggersClusterResourceName(
    LPCWSTR     pMsmqClusterResourceName, 
    AP<WCHAR>&  pTriggersClusterResourceName
    )
/*++

Routine Description:

    Finds the MSMQ Triggers cluster resource, if any, that depends on the specified
    MSMQ cluster resource, and copies its name onto the buffer.

    The buffers is allocated by the callee and deallocated by the caller using the
    autoclass template AP<>.

Arguments:

    pMsmqClusterResourceName - The name of the MSMQ cluster resource.

    pTriggersClusterResourceName - The buffer that will hold the name of the 
                                   MSMQ Triggers cluster resource.

Return Value:

    None.

--*/
{
    CClusterResource hResource(BrClusterResourceNameToHandle(pMsmqClusterResourceName));

    const DWORD xEnumType = CLUSTER_RESOURCE_ENUM_PROVIDES;
    CResourceEnum hResourceEnum(ClusterResourceOpenEnum(hResource, xEnumType));
    if (hResourceEnum == NULL)
    {
        CResString strErr(IDS_CANNOT_OPEN_ENUM_HANDLE_TO_RESOURCE);
        BrErrorExit(GetLastError(), strErr.Get(), pMsmqClusterResourceName);
    }

    DWORD index = 0;
    for(;;)
    {
        DWORD length = 1000;
        AP<WCHAR> pResourceName = new WCHAR[length];
        if (pResourceName == NULL)
        {
            CResString strErrNoMemory(IDS_NO_MEMORY);
            BrErrorExit(0, strErrNoMemory.Get());
        }
        DWORD EnumType = xEnumType;
        DWORD status = ClusterResourceEnum(hResourceEnum, index++, &EnumType, pResourceName.get(), &length);
        if (status == ERROR_NO_MORE_ITEMS)
            return;

        if (status == ERROR_MORE_DATA)
        {
            delete [] pResourceName.get();
            pResourceName = new WCHAR[++length];
            if (pResourceName == NULL)
            {
                CResString strErrNoMemory(IDS_NO_MEMORY);
                BrErrorExit(0, strErrNoMemory.Get());
            }
            EnumType = xEnumType;
            status = ClusterResourceEnum(hResourceEnum, index - 1, &EnumType, pResourceName.get(), &length);
        }

        if (FAILED(status))
        {
            CResString strErr(IDS_CANNOT_ENUM_RESOURCES);
            BrErrorExit(status, strErr.Get(), pMsmqClusterResourceName);
        }

        if (BrCopyResourceNameOnTypeMatch(pResourceName.get(), xTriggersResourceType, pTriggersClusterResourceName))
            return;
    }
}


void
BrGetTriggersClusterRegistry(
    LPCWSTR pTriggersClusterResourceName,
    LPWSTR  pTriggersClusterRegistry
    )
{
    //
    // MSMQTriggers cluster resource: Software\Microsoft\MSMQ\Triggers\Clustered\MSMQTriggers$<Resource Name>
    //
    LPCWSTR x_SERVICE_PREFIX = L"MSMQTriggers$";
    WCHAR ServiceName[MAX_PATH];
    BrGetClusterResourceServiceName(x_SERVICE_PREFIX, pTriggersClusterResourceName, ServiceName);

    wcscpy(pTriggersClusterRegistry, REGKEY_TRIGGER_PARAMETERS);
    wcscat(pTriggersClusterRegistry, REG_SUBKEY_CLUSTERED);
    wcscat(pTriggersClusterRegistry, ServiceName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bkuprstr\restore.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    restore.cpp

Abstract:

    Restore MSMQ, Registry, Message files, Logger and Transaction files and LQS

Author:

    Erez Haba (erezh) 14-May-98

--*/

#pragma warning(disable: 4201)

#include <windows.h>
#include <stdio.h>
#include <autohandle.h>
#include "br.h"
#include "bkupres.h"

void DoRestore(LPCWSTR pBackupDir, LPCWSTR pMsmqClusterResourceName)
{
    WCHAR BackupDir[MAX_PATH];
    wcscpy(BackupDir, pBackupDir);
    if (BackupDir[wcslen(BackupDir)-1] != L'\\')
    {
        wcscat(BackupDir, L"\\");
    }

    WCHAR BackupDirMapping[MAX_PATH];
    wcscpy(BackupDirMapping, BackupDir);
    wcscat(BackupDirMapping, L"MAPPING\\");

    WCHAR BackupDirStorage[MAX_PATH];
    wcscpy(BackupDirStorage, BackupDir);
    wcscat(BackupDirStorage, L"STORAGE\\");

    WCHAR BackupDirStorageLqs[MAX_PATH];
    wcscpy(BackupDirStorageLqs, BackupDirStorage);
    wcscat(BackupDirStorageLqs, L"LQS\\");

    //
    //  0. Verify user premissions to restore
    //
    CResString str(IDS_VERIFY_RESTORE_PRIV);
    BrpWriteConsole(str.Get());
    BrInitialize(SE_RESTORE_NAME);
    
    //
    //  1. Verify that this is a valid backup
    //
    str.Load(IDS_VERIFY_BK);
    BrpWriteConsole(str.Get());
    BrVerifyBackup(BackupDir, BackupDirStorage);

    //
    //  4.  A. Notify the user on affected application due to the stopping of MSMQ service (NT5 and higher).
    //         Not needed if MSMQ is a cluster resource since cluster takes offline dependent apps.
	//		B. Stop MSMQ Service and dependent services (or cluster resource) if running and remember running state. 
    //

    AP<WCHAR> pTriggersClusterResourceName;
    if (pMsmqClusterResourceName != NULL)
    {
        BrGetTriggersClusterResourceName(pMsmqClusterResourceName, pTriggersClusterResourceName);
    }

    BOOL fStartService = false;
    bool fStartMsmqClusterResource = false;
    bool fStartMsmqTriggersClusterResource = false;

    ENUM_SERVICE_STATUS * pDependentServices = NULL;
    DWORD NumberOfDependentServices = 0;
    if (pMsmqClusterResourceName == NULL)
    {
	    if(BrIsSystemNT5())
	    {
		    BrNotifyAffectedProcesses(L"mqrt.dll");
	    }
        //
        // IDS_STOP_SERVICE is used and have different TEXT,
        // i.e. changed to IDS_BKRESTORE_STOP_SERVICE
        //
        fStartService = BrStopMSMQAndDependentServices(&pDependentServices, &NumberOfDependentServices);
    }
    else
    {
        if (pTriggersClusterResourceName.get() != NULL)
        {
            fStartMsmqTriggersClusterResource = BrTakeOfflineResource(pMsmqClusterResourceName);
        }

        fStartMsmqClusterResource = BrTakeOfflineResource(pMsmqClusterResourceName);
    }

    //
    //  5. Restore registry settings from backed-up file
    //     Before restoring registry remove MSMQ and MSMQ Triggers cluster registry checkpoints.
    //
    str.Load(IDS_RESTORE_REGISTRY);
    BrpWriteConsole(str.Get());

    WCHAR MsmqRootRegistry[MAX_PATH];
    BrGetMsmqRootRegistry(pMsmqClusterResourceName, MsmqRootRegistry);

    WCHAR MsmqParametersRegistry[MAX_PATH];
    BrGetMsmqParametersRegistry(MsmqRootRegistry, MsmqParametersRegistry);

    if (pMsmqClusterResourceName != NULL)
    {
        BrRemoveRegistryCheckpoint(pMsmqClusterResourceName, MsmqParametersRegistry);
    }

    {
        CRegHandle hKey = BrCreateKey(MsmqRootRegistry);
        BrRestoreKey(hKey, BackupDir, xRegistryFileName);
    }

    WCHAR TriggersClusterRegistry[MAX_PATH] = {0};
    if (pTriggersClusterResourceName.get() != NULL)
    {
        BrGetTriggersClusterRegistry(pTriggersClusterResourceName.get(), TriggersClusterRegistry);
        BrRemoveRegistryCheckpoint(pTriggersClusterResourceName.get(), TriggersClusterRegistry);

        CRegHandle hKey = BrCreateKey(TriggersClusterRegistry);
        BrRestoreKey(hKey, BackupDir, xTriggersClusterResourceRegistryFileName);
    }

    
    // 
    //  5a. Keep in registry (SeqIDAtLastRestore) SeqID at restore time
    //      After registry is restored, add MSMQ and MSMQ Triggers cluster registry checkpoints.
    //
    str.Load(IDS_REMEMBER_SEQID_RESTORE);
    BrpWriteConsole(str.Get());
    BrSetRestoreSeqID(MsmqParametersRegistry);

    if (pMsmqClusterResourceName != NULL)
    {
        BrAddRegistryCheckpoint(pMsmqClusterResourceName, MsmqParametersRegistry);
    }

    if (pTriggersClusterResourceName.get() != NULL)
    {
        BrAddRegistryCheckpoint(pTriggersClusterResourceName.get(), TriggersClusterRegistry);
    }

    //
    //  6. Get Registry Values for subdirectories
    //     MSMQ cluster resources do not use a dedicated web directory.
    //
    str.Load(IDS_READ_FILE_LOCATION);
    BrpWriteConsole(str.Get());
    STORAGE_DIRECTORIES sd;
    BrGetStorageDirectories(MsmqParametersRegistry, sd);

    WCHAR MappingDirectory[MAX_PATH+1];
    BrGetMappingDirectory(MsmqParametersRegistry, MappingDirectory, sizeof(MappingDirectory));

    WCHAR WebDirectory[MAX_PATH+1];
    if (pMsmqClusterResourceName == NULL)
    {
        BrGetWebDirectory(WebDirectory, sizeof(WebDirectory));
    }

    //
    //  7. Create all directories: storage, LQS, mapping, web
    //
    str.Load(IDS_VERIFY_STORAGE_DIRS);
    BrpWriteConsole(str.Get());

    BrCreateDirectoryTree(sd[ixExpress]);
    BrCreateDirectoryTree(sd[ixRecover]);
    BrCreateDirectoryTree(sd[ixJournal]);
    BrCreateDirectoryTree(sd[ixLog]);

    WCHAR LQSDir[MAX_PATH];
    wcscpy(LQSDir, sd[ixLQS]);
    wcscat(LQSDir, L"\\LQS");
    BrCreateDirectory(LQSDir);

    BrCreateDirectoryTree(MappingDirectory);

    if (pMsmqClusterResourceName == NULL)
    {
        BrCreateDirectoryTree(WebDirectory);
    }

    //
    //  8. Delete all files in storage/LQS/mapping/web directories
    //
    BrEmptyDirectory(sd[ixExpress]);

    BrEmptyDirectory(sd[ixRecover]);

    BrEmptyDirectory(sd[ixJournal]);

    BrEmptyDirectory(sd[ixLog]);

    BrEmptyDirectory(LQSDir);

    BrEmptyDirectory(MappingDirectory);

	//
    // Restore web directory permissions
    //
    if (pMsmqClusterResourceName == NULL)
    {
        BrRestoreWebDirectorySecurityDescriptor(WebDirectory,BackupDir);
    }

    //
    //  9  Check for available disk space
    //


    //
    // 10. Restore message files
    //
    str.Load(IDS_RESTORE_MSG_FILES);
    BrpWriteConsole(str.Get());
    BrCopyFiles(BackupDirStorage, L"\\p*.mq", sd[ixRecover]);
    BrCopyFiles(BackupDirStorage, L"\\j*.mq", sd[ixJournal]);
    BrCopyFiles(BackupDirStorage, L"\\l*.mq", sd[ixLog]);

    //
    // 11. Restore logger files and mapping files
    //
    BrCopyXactFiles(BackupDirStorage, sd[ixXact]);
    BrCopyFiles(BackupDirMapping, L"\\*", MappingDirectory);

    //
    // 12. Restore LQS directory
    //
    BrCopyFiles(BackupDirStorageLqs, L"*", LQSDir);
    BrpWriteConsole(L"\n");

    //
    // Set security on all subdirectories
    //
    BrSetDirectorySecurity(sd[ixExpress]);
    BrSetDirectorySecurity(sd[ixRecover]);
    BrSetDirectorySecurity(sd[ixJournal]);
    BrSetDirectorySecurity(sd[ixLog]);

    BrSetDirectorySecurity(LQSDir);
    BrSetDirectorySecurity(MappingDirectory);

    WCHAR MsmqRootDirectory[MAX_PATH];
    BrGetMsmqRootPath(MsmqParametersRegistry, MsmqRootDirectory);
    BrSetDirectorySecurity(MsmqRootDirectory);

    //
    // 13. Restart MSMQ and dependent services (or cluster resource) if needed
    //
    if(fStartService)
    {
        BrStartMSMQAndDependentServices(pDependentServices, NumberOfDependentServices);
    }
    if (fStartMsmqClusterResource)
    {
        BrBringOnlineResource(pMsmqClusterResourceName);
    }
    if (fStartMsmqTriggersClusterResource)
    {
        BrBringOnlineResource(pTriggersClusterResourceName.get());
    }

    //
    // 14. Issue a final message.
    //
    str.Load(IDS_DONE);
    BrpWriteConsole(str.Get());











/*                        BUGBUG: localize here

    //
    //  5. Calculate Required disk space at destinaion (collect all MSMQ files that will be backed-up)
    //     pre allocate 32K for registry save.
    //
    BrpWriteConsole(L"Checking available disk space\n");
    ULONGLONG RequiredSpace = 32768;
    RequiredSpace += BrGetUsedSpace(sd[ixRecover], L"\\p*.mq");
    RequiredSpace += BrGetUsedSpace(sd[ixJournal], L"\\j*.mq");
    RequiredSpace += BrGetUsedSpace(sd[ixLog],     L"\\l*.mq");

    RequiredSpace += BrGetXactSpace(sd[ixXact]);
    RequiredSpace += BrGetUsedSpace(sd[ixLQS], L"\\LQS\\*");

    ULONGLONG AvailableSpace = BrGetFreeSpace(BackupDir);
    if(AvailableSpace < RequiredSpace)
    {
        BrErrorExit(0, L"Not enought disk space for backup on '%s'", BackupDir);
    }
*/

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\errorh.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bkuprstr\br.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    br.h

Abstract:

    Common function for MSMQ Backup & Restore.

Author:

    Erez Haba (erezh) 14-May-98

--*/

#ifndef __BR_H__
#define __BR_N__

#define ASSERT
#include <autoptr.h>

extern HMODULE	g_hResourceMod;


//
// Registry backup file name.
// For standard MSMQ service, holds all MSMQ registry settings, including Triggers.
// For MSMQ cluster resource, holds all MSMQ registry settings, not including Triggers cluster resources.
//
const WCHAR xRegistryFileName[] = L"msmqreg";

//
// Registry backup file name for MSMQ Triggers cluster resource.
//
const WCHAR xTriggersClusterResourceRegistryFileName[] = L"msmqtrigreg";


class CResString
{
public:
    explicit CResString(UINT id=0) { Load(id); }

    WCHAR * const Get() { return m_sz; }

    void Load(UINT id)
    {
        m_sz[0] = 0;
        if (id != 0)
        {
            LoadString(g_hResourceMod, id, m_sz, sizeof(m_sz) / sizeof(m_sz[0]));
        }
    }
        
private:
    WCHAR m_sz[1024];
};
  
typedef struct _EnumarateData
{
	BOOL fFound;
	LPCWSTR pModuleName;
}EnumarateData,*pEnumarateData;

void
BrErrorExit(
    DWORD Status,
    LPCWSTR pErrorMsg,
    ...
    );

void
BrpWriteConsole(
    LPCWSTR pBuffer
    );

void
BrInitialize(
     LPCWSTR pPrivilegeName
    );

void
BrEmptyDirectory(
    LPCWSTR pDirName
    );

void
BrVerifyFileWriteAccess(
    LPCWSTR pDirName
    );


enum sdIndex {
    ixExpress,
    ixRecover,
    ixLQS = ixRecover,
    ixJournal,
    ixLog,
    ixXact,
    ixLast
};

typedef WCHAR STORAGE_DIRECTORIES[ixLast][MAX_PATH];

void
BrGetStorageDirectories(
    LPCWSTR pMsmqParametersRegistry,
    STORAGE_DIRECTORIES& StorageDirectories
    );

void
BrGetMsmqRootPath(
    LPCWSTR pMsmqParametersRegistry,
    LPWSTR  pMsmqRootPath
    );

void
BrGetMappingDirectory(
    LPCWSTR pMsmqParametersRegistry,
    LPWSTR MappingDirectory,
    DWORD  MappingDirectorySize
    );

void
BrGetWebDirectory(
    LPWSTR WebDirectory,
    DWORD  WebDirectorySize
    );

void
BrSaveWebDirectorySecurityDescriptor(
    LPWSTR lpwWebDirectory,
    LPWSTR lpwBackuDir
    );

void
BrRestoreWebDirectorySecurityDescriptor(
    LPWSTR lpwWebDirectory,
    LPWSTR lpwBackuDir
    );

BOOL
BrStopMSMQAndDependentServices(
    ENUM_SERVICE_STATUS * * ppDependentServices,
    DWORD * pNumberOfDependentServices
    );

void
BrStartMSMQAndDependentServices(
    ENUM_SERVICE_STATUS * pDependentServices,
    DWORD NumberOfDependentServices
    );

ULONGLONG
BrGetUsedSpace(
    LPCWSTR pDirName,
    LPCWSTR pMask
    );

ULONGLONG
BrGetXactSpace(
    LPCWSTR pDirName
    );

ULONGLONG
BrGetFreeSpace(
    LPCWSTR pDirName
    );

HKEY
BrCreateKey(
    LPCWSTR pMsmqRootRegistry
    );

void
BrSaveKey(
    HKEY hKey,
    LPCWSTR pDirName,
    LPCWSTR pFileName
    );

void
BrRestoreKey(
    HKEY hKey,
    LPCWSTR pDirName,
    LPCWSTR pFileName
    );
    
void
BrSetRestoreSeqID(
    LPCWSTR pMsmqParametersRegistry
    );
    
void
BrCopyFiles(
    LPCWSTR pSrcDir,
    LPCWSTR pMask,
    LPCWSTR pDstDir
    );

void
BrCopyXactFiles(
    LPCWSTR pSrcDir,
    LPCWSTR pDstDir
    );

void
BrCreateDirectory(
    LPCWSTR pDirName
    );

void
BrCreateDirectoryTree(
    LPCWSTR pDirName
    );

void
BrVerifyBackup(
    LPCWSTR pBackupDir,
    LPCWSTR pBackupDirStorage
    );

void
BrSetDirectorySecurity(
    LPCWSTR pDirName
    );

BOOL 
BrIsSystemNT5(
		void
		);

void
BrNotifyAffectedProcesses(
		LPCWSTR pModuleName
		);

void
BrGetMsmqRootRegistry(
    LPCWSTR pMsmqClusterResourceName,
    LPWSTR pMsmqRootRegistry
    );

void
BrGetMsmqParametersRegistry(
    LPCWSTR pMsmqRootRegistry,
    LPWSTR  pMsmqParametersRegistry
    );

bool
BrTakeOfflineResource(
    LPCWSTR pMsmqClusterResourceName
    );

void
BrBringOnlineResource(
    LPCWSTR pMsmqClusterResourceName
    );

void
BrAddRegistryCheckpoint(
    LPCWSTR pClusterResourceName,
    LPCWSTR pRegistrySection
    );

void
BrRemoveRegistryCheckpoint(
    LPCWSTR pClusterResourceName,
    LPCWSTR pRegistrySection
    );

void
BrGetTriggersClusterResourceName(
    LPCWSTR     pMsmqClusterResourceName, 
    AP<WCHAR>&  pTriggersClusterResourceName
    );

void
BrGetTriggersClusterRegistry(
    LPCWSTR pTriggersClusterResourceName,
    LPWSTR  pTriggersClusterRegistry
    );


enum eModuleLoaded {
    e_NOT_LOADED,
	e_LOADED,
	e_CANT_DETERMINE
};

#endif // __BR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bkuprstr\main.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    Backup & Restore MSMQ 1.0, Registry, Message files, Logger and Transaction files and LQS

Author:

    Erez Haba (erezh) 14-May-98

--*/

#pragma warning(disable: 4201)

#include <windows.h>
#include <stdio.h>
#include "br.h"
#include "resource.h"
#include "stdlib.h"
#include "_mqres.h"

bool g_fNoPrompt = false;

void DoBackup(LPCWSTR pBackupDir, LPCWSTR pMsmqClusterResourceName);
void DoRestore(LPCWSTR pBackupDir, LPCWSTR pMsmqClusterResourceName);

//
// Handle to the resource only DLL, i.e. mqutil.dll
//
HMODULE	g_hResourceMod = NULL;

static void Usage()
{
    CResString str(IDS_USAGE);
    BrpWriteConsole(str.Get());

	exit(-1);
}


extern "C" int _cdecl wmain(int argc, WCHAR* argv[])
{
    //
    // If you add/change these constants, change also
    // the usage message.
    //
    const WCHAR x_cBackup = L'b';
    const WCHAR x_cRestore = L'r';
    const WCHAR x_cNoPrompt = L'y';
    const WCHAR x_cCluster = L'c';


    WCHAR cAction = 0;
    WCHAR cNoPrompt = 0;
    WCHAR cCluster = 0;
    WCHAR szPath[MAX_PATH] = {0};
    LPWSTR pMsmqClusterResourceName = NULL;

	//
	// Obtain the handle to the resource only dll, i.e. mqutil.dll
	//
	g_hResourceMod = MQGetResourceHandle();

    for (int i=1; i < argc; ++i)
    {
        WCHAR c = argv[i][0];
        if (c == L'-' || c == L'/')
        {
            if (wcslen(argv[i]) != 2)
            {
                Usage();
            }

            c = static_cast<WCHAR>(towlower(argv[i][1]));
            switch (c)
            {
                case x_cBackup:
                case x_cRestore:
                {
                    if (cAction != 0)
                    {
                        Usage();
                    }
                    cAction = c;
                    break;
                }

                case x_cNoPrompt:
                {
                    if (cNoPrompt != 0)
                    {
                        Usage();
                    }
                    cNoPrompt = c;
                    break;
                }

                case x_cCluster:
                {
                    if (cAction == 0)
                    {
                        Usage();
                    }

                    if (cCluster != 0)
                    {
                        Usage();
                    }
                    
                    cCluster = c;
                    break;
                }

                default:
                {
                    Usage();
                    break;
                }
            }
        }
        else
        {
            if (cCluster != 0)
            {
                if (pMsmqClusterResourceName == NULL)
                {
                    pMsmqClusterResourceName = argv[i];
                    continue;
                }
            }

            if (szPath[0] != 0)
            {
                Usage();
            }

            wcscpy(szPath, argv[i]);
        }
    }

    //
    // Some arguments are must
    //
    if (cAction == 0      ||
        szPath[0] == 0)
    {
        Usage();
    }

    if (cCluster != 0 && pMsmqClusterResourceName == NULL)
    {
        Usage();
    }

    //
    // Some arguments are optional
    //
    if (cNoPrompt != 0)
    {
        g_fNoPrompt = true;
    }

    WCHAR szFullPath[MAX_PATH];
    DWORD dwLenFullPath = sizeof(szFullPath) / sizeof(szFullPath[0]);
    LPWSTR pFilePart = 0;
    DWORD rc = GetFullPathName(
        szPath,                                     // pointer to name of file to find path for
        dwLenFullPath,                              // size, in characters, of path buffer
        szFullPath,                                 // pointer to path buffer
        &pFilePart                                  // pointer to filename in path
        );
    if (0 == rc)
    {
        DWORD gle = GetLastError();
        CResString strErr(IDS_CANT_GET_FULL_PATH);
        BrErrorExit(gle, strErr.Get(), szPath);
    }
    if (rc > dwLenFullPath)
    {
        CResString strErr(IDS_PATH_TOO_LONG_ERROR);
        BrErrorExit(0, strErr.Get(), szPath, dwLenFullPath-1);
    }

	
    switch(cAction)
    {
        case x_cBackup:          
            DoBackup(szFullPath, pMsmqClusterResourceName);
            break;

        case x_cRestore:          
            DoRestore(szFullPath, pMsmqClusterResourceName);
            break;

        default:
            Usage();
            break;
    }




    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\auth.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Auth.cpp

Abstract:
	
	This is the Test that checks authenticate messages with or without authenticate queue
	This is part of the Security.
		
Author:
    
	  Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#pragma warning( disable : 4786 )

#include "msmqbvt.h"
using namespace std;
extern BOOL g_bRunOnWhistler;
	
extern DWORD TestResult[Total_Tests];
INT 
cTest::ThreadMain()
/*++

Function Description:

    Function to run as a speparete thread
    

Arguments:
    None
Return code:
    return MSMQ_BVT_SUCC / MSMQ_BVT_FAILED


--*/
{
	bool fOleInit=true;
	int res;
	
	HRESULT hr = CoInitializeEx(NULL,COINIT_MULTITHREADED);
	if ( FAILED (hr) )
	{
			fOleInit=false;
	}
	{
		Description();
		res =  Start_test();
		Sleep(MqBvt_SleepBeforeWait*2);
		if( res == MSMQ_BVT_SUCC )
		{
			res = CheckResult();
		}

	}
	if( fOleInit == true)
	{
		CoUninitialize();
	}
	TestResult[m_testid] = res;
	return res;
}


wstring GetJPNProplematicChars()

/*++
	Function Description:
	 This functions return problematic JPN charcters
		//add buffer for JPN DBCS codes after GUID 
		//0x3042 : Double byte Hiragana
		//0x30A2 : Double byte Katakana
		//0x4FFF,0x5000: normal DBCS Kanji
		//0x8868 : Trailing byte contains symbolic char
		//0x9670 : Trailing byte contains alphabet char
		//0x2121 : Trailing byte contains leading byte char
		//0x3231 : n:1 conversion between ANSI and Unicode
		//0x3305 : JPN char only in Unicode
		//0x30FC : JPN char poteintial issue w CompareString
		//0xFF76, 0xFF9E : single byte Katakana
	Arguments:
		None
	Return code:
		wstring that contains JPN characters.
--*/
	
{

		
		WORD wDbcs[] = {0x3042,0x30A2,0x4FFF,0x5000,0x8868,0x9670,0x2121,0x3231,0x3305,0x30FC,0xFF76,0xFF9E,0x0000};
		wstring wcsTemp = L"{";
		wcsTemp += wDbcs;
		wcsTemp += L"}";
		return wcsTemp;
}

bool cTest::IsLocalQueue(std::wstring wcsFormatName,std::wstring & wcsQueuePathName )
/*++ 
	Function Description:
		Check if queue is local queue,
		if this a remote queue return the full queue pathname.
	Arguments:
		wcsFormatName - queue format name.
		wcsQueuePathName - queue path name.
	Return code:
		true - local 
		false - remote.
	
--*/

{
	wcsQueuePathName = g_wcsEmptyString;
	const int iTotalPropCount = 2;
	QUEUEPROPID propId[iTotalPropCount] = {0};
	MQPROPVARIANT propVar[iTotalPropCount]= {0};
	HRESULT propStatus[iTotalPropCount] = {0};
	DWORD cprop = 0;

	wstring wcsObjectType = L"QUEUE=";
	wcsObjectType += wcsFormatName;

	propId[cprop] = PROPID_MGMT_QUEUE_LOCATION;
	propVar[cprop].vt = VT_NULL;
	++cprop;

	propId[cprop] = PROPID_MGMT_QUEUE_PATHNAME;
	propVar[cprop].vt = VT_NULL;
	++cprop;

	MQMGMTPROPS mqProps={0};
	mqProps.cProp = cprop;
	mqProps.aPropID = propId;
	mqProps.aPropVar = propVar;
	mqProps.aStatus = propStatus;
					  
	HRESULT hr = MQMgmtGetInfo(NULL,wcsObjectType.c_str(), &mqProps);
	if(FAILED(hr))
	{        
		printf("Investigate - MQMgmtGetInfo failed to retrive information \n");
		throw INIT_Error("Investiage failed");
	}
	size_t iCmp = 1;
	if( propVar[0].vt != VT_NULL )
	{
		iCmp = _wcsicmp(propVar[0].pwszVal,L"local");
		MQFreeMemory(propVar[0].pwszVal);
	}
	if( propVar[1].vt != VT_NULL )
	{
		wcsQueuePathName = 	propVar[1].pwszVal;
		MQFreeMemory(propVar[1].pwszVal);
	}
	return iCmp ==0 ? true:false;
}

wstring GetRemoteComputerNameForFormatName( wstring wcsFormatName )
/*++ 
	Function Description:
		Parase remote machine name from queue format names
	Arguments:
		queue format name
	Return code:
		remote machine name or empty string.
	
--*/

{
	wcsFormatName = ToLower(wcsFormatName);
	size_t iPos = wcsFormatName.find(L"http");
	if( iPos == -1 )
	{
		iPos = wcsFormatName.find(L"os:");
		iPos += wcslen(L"os:");
	}
	else
	{ 
		//
		// Handle situation for HTTPS too.
		// 
		iPos = wcsFormatName.find(L"//");
		iPos += wcslen(L"//");
	}
	if ( iPos == -1 )
	{
		return g_wcsEmptyString;
	}
	wcsFormatName = wcsFormatName.substr(iPos,wcsFormatName.length());
	iPos = wcsFormatName.find_first_of(L"\\");
	size_t iPos1 = wcsFormatName.find_first_of(L"/");
	if( iPos1 != -1 && iPos1 < iPos )
	{
		iPos = iPos1;
	}
	if ( iPos == -1 )
	{
		return g_wcsEmptyString;
	}
	return wcsFormatName.substr(0,iPos);

}
void cTest::UpdateInvestigateOutingQueueState(wstring wcsFormatName,wstring wcsMachineName)
/*++ 
	Function Description:
		update internal data structre with the machine name and queue formatname
	Arguments:
		None
	Return code:
		None
	
--*/

{
	wstring wcsQueuePathName = g_wcsEmptyString;
	if( wcsMachineName == g_wcsEmptyString && IsLocalQueue(wcsFormatName,wcsQueuePathName) == false )
	{
		if( wcsQueuePathName != g_wcsEmptyString)
		{
			size_t iPos = wcsQueuePathName.find_first_of(L"\\");
			if(iPos == -1 )
			{
				return;
			}
			wcsQueuePathName = wcsQueuePathName.substr(0,iPos);
		}		
		else
		{
			wcsQueuePathName = GetRemoteComputerNameForFormatName(wcsFormatName);
		}
	}
	else
	{
		wcsQueuePathName = wcsMachineName;
	}

	if(wcsQueuePathName !=  g_wcsEmptyString )
	{
		m_OutGoingQueueObjects.push_back(OUT_GOING_QUEUE_OBJECT(wcsQueuePathName,wcsFormatName));
		m_bInvestigate = true;
	}

}


void cTest::VerifySendSucceded( wstring wcsDestQueueFormatName, wstring wcsAdminQueueFormatName )
/*++
	Function Description:		
		  Add information about the destination queue and admin queue for verify phase,
		  note that verify phase run only if thread failed
	Arguments:
		None
	Return code:
		None
--*/

{
	UpdateInvestigateOutingQueueState(wcsDestQueueFormatName,L".");
	if( wcsAdminQueueFormatName != g_wcsEmptyString )
	{
		wstring wcsRemoteMachineName = GetRemoteComputerNameForFormatName(wcsDestQueueFormatName);
		if (wcsRemoteMachineName != g_wcsEmptyString)
		{
			UpdateInvestigateOutingQueueState(wcsAdminQueueFormatName,wcsRemoteMachineName);
		}
	}
}

void cTest::AutoInvestigate()
{
	if(m_bInvestigate == false )
	{
		return ;
	}
	MqLog("---------------------------------------------------------------------\n");
	CheckOutGoingQueueState();
	MqLog("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
}

HRESULT cTest::CheckOutGoingQueueState()
/*++ 
	Function Description:
		Check outgoing queue state and reports:
			1.Number of messages that are waiting for delivery.
			2.Outgoing queue state.
			3.Next hop
	Arguments:
		None
	Return code:
		None
	
--*/
{
	
	
	HRESULT hr = MQ_OK;
	std::vector <OUT_GOING_QUEUE_OBJECT>::iterator p = m_OutGoingQueueObjects.begin();
	while( p != m_OutGoingQueueObjects.end())
	{
			//
			// Per delivry object check the outgoing queue state.
			//
			const int iTotalPropCount = 3;
			QUEUEPROPID propId[iTotalPropCount] = {0};
			MQPROPVARIANT propVar[iTotalPropCount]= {0};
			HRESULT propStatus[iTotalPropCount] = {0};
			DWORD cprop = 0;

			wstring wcsObjectType = L"QUEUE=";
			wcsObjectType += p->second;

			if( g_bDebug )
			{
				wMqLog(L"Check outgoing of machine %s\n queue format name:%s\n",p->first.c_str(),p->second.c_str());
			}

			propId[cprop] = PROPID_MGMT_QUEUE_MESSAGE_COUNT;
			propVar[cprop].vt = VT_NULL;
			const int iMsgCount = cprop;
			++cprop;

			propId[cprop] = PROPID_MGMT_QUEUE_STATE;
			propVar[cprop].vt = VT_NULL;
			const int iOutGoingState = 	cprop;
			++cprop;

			propId[cprop] = PROPID_MGMT_QUEUE_NEXTHOPS;
			propVar[cprop].vt = VT_NULL;
			const int iNextHope = cprop;
			++cprop;
			 
			MQMGMTPROPS mqProps={0};
			mqProps.cProp = cprop;
			mqProps.aPropID = propId;
			mqProps.aPropVar = propVar;
			mqProps.aStatus = propStatus;

			const WCHAR * pMachineName = (p->first == L".") ? NULL:p->first.c_str();
			hr = MQMgmtGetInfo(pMachineName,wcsObjectType.c_str(), &mqProps);
			if(FAILED(hr))
			{        
				//printf("ERROR: can't find Internal Queue Information. Maybe the queue already closed\n");
				return hr;
			}
			if( propVar[iMsgCount].ulVal>0 )
			{			
				wMqLog(L"AutoInvestigate(%d) ->%d Messages are waiting in outgoing queue @ %s machine \n",m_testid,propVar[iMsgCount].ulVal,
						pMachineName == NULL ? L"local":pMachineName);
			}
			if( propVar[iOutGoingState].vt != VT_NULL )
			{
				wMqLog(L"AutoInvestigate(%d) ->Formatname:%s,OutGoingQueueState=%s\n",m_testid,wcsObjectType.c_str(),
					propVar[iOutGoingState].pwszVal);
				MQFreeMemory(propVar[iOutGoingState].pwszVal);
			}
			if( propVar[iNextHope].vt != VT_NULL )
			{
				int iNextHop = propVar[iNextHope].calpwstr.cElems;
				for( int i=0;i<iNextHop;i++)
				{
					wMqLog(L"Next hop for message is %s\n", propVar[iNextHope].calpwstr.pElems[i]);
					MQFreeMemory(propVar[iNextHope].calpwstr.pElems[i]);
				}
				MQFreeMemory(propVar[iNextHope].calpwstr.pElems);
			}
			p++;
	}
	
	return hr;
}
inline void cTest::EnableInvestigate()
/*++ 
	Function Description:
		Enable global failure investigate procdure.
	Arguments:
		None
	Return code:
		None

	
--*/
{
	m_bInvestigate = true;
}

//--------------------------------------------------------------
//
// cTest constructor call from every tests 
// The constructor create common GUID for all the tests
//

cTest::cTest(INT index):
m_testid( index ),m_bInvestigate(false)
{

	m_OutGoingQueueObjects.clear();
	UCHAR * csMessageGuid;
	UUID gAllMessageGuid;
	if (UuidCreate( & gAllMessageGuid ) != RPC_S_OK )
	{
		MqLog("cTest::cTest UUIDCreateFailed to Create GUID \n");
		throw INIT_Error("cTest failed to create GUID");
	}	
	const int iMAX_GUID_LEN = MAX_GUID;
	WCHAR wcsMessageGUID[iMAX_GUID_LEN + 1];
	RPC_STATUS  hr = UuidToString( & gAllMessageGuid , & csMessageGuid );
	if( hr != RPC_S_OK )
	{
		throw INIT_Error("cTest failed to create GUID");
	}
	MultiByteToWideChar(CP_ACP,0,(char *)csMessageGuid,-1,wcsMessageGUID,iMAX_GUID_LEN);
	RpcStringFree(&csMessageGuid);
	m_wcsGuidMessageLabel = wcsMessageGUID + GetJPNProplematicChars();
	m_testid ++;
	m_wcsDescription = L"";

}; 


//------------------------------------------------------
//
//


void CheckNotAuthQueueWITHAuthMessage::Description()
{
	MqLog("Thread %d Not used \n");
}

//------------------------------------------------
// SecCheackAuthMess::~SecCheackAuthMess () Empty
//

SecCheackAuthMess::~SecCheackAuthMess ()
{
 
}

//-------------------------------------------------------------------
// CheckNotAuthQueueWITHAuthMessage 
// Bugbug need to add this tests to mqbvt

CheckNotAuthQueueWITHAuthMessage::
CheckNotAuthQueueWITHAuthMessage ( 	int iTestId , std::map < std::wstring , std::wstring > & Tparms ) 
: SecCheackAuthMess (iTestId , Tparms ) 
{
	try 
	{	
		m_ResualtVal = MQMSG_CLASS_ACK_REACH_QUEUE;	
		m_Destqinfo->Refresh();	
		m_Destqinfo->Label = "SecurityCheackAuthMessWithNOTAuthQueue";
		m_Destqinfo->Authenticate=MQ_AUTHENTICATE_NONE; 
		m_Destqinfo->Update(); 
		m_Adminqinfo->Refresh();
		m_Adminqinfo->Label = "SecCheackAuthMess_AdminQ";
		m_Adminqinfo->Update();
	}
	catch (_com_error & ComErr)
	{	
	
		CatchComErrorHandle ( ComErr,iTestId );
		throw INIT_Error("Error during construct CheckNotAuthQueueWITHAuthMessage");
	}
}



CheackAuthQueueWithOutAuthMessgae::CheackAuthQueueWithOutAuthMessgae(int i , std :: map < std ::  wstring  ,std :: wstring> & Tparms) :SecCheackAuthMess (i , Tparms)
{
		m_ResualtVal=MQMSG_CLASS_NACK_BAD_SIGNATURE;
} 

// -------------------------------------------------------------------------
// CheackAuthQueueWithOutAuthMessgae::Start_test
// Send express message with authticate to authnticate queue.
//

int CheackAuthQueueWithOutAuthMessgae::Start_test()
{

	SetThreadName(-1,"CheackAuthQueueWithOutAuthMessgae - Start_test ");
	try 
	{
		
		MSMQ::IMSMQQueuePtr m_DestqinfoHandle;
		MSMQ::IMSMQMessagePtr m_msg( "MSMQ.MSMQMessage" );
		m_DestqinfoHandle=m_Destqinfo->Open ( MQ_SEND_ACCESS,MQ_DENY_NONE );	
		m_msg->Label = "Test_Auth_Messgae_NACKExpected";
		m_msg->AdminQueueInfo=m_Adminqinfo; 
		m_msg->Ack = MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE;
		m_msg->Send ( m_DestqinfoHandle );
		m_DestqinfoHandle->Close();

	}
	catch (_com_error & ComErr)
	{	
		return CatchComErrorHandle ( ComErr , m_testid );
	}
return MSMQ_BVT_SUCC;
}

//------------------------------------------------------------------
// SecCheackAuthMess :: Description
// This test send authenticate message to authenticate queue
//

void SecCheackAuthMess::Description()
{
	WCHAR * p = L"";
	if( m_testid == 26 )
	{
		p = L"(HTTP)";
	}
	else if ( m_testid == 28 )
	{
		p = L"(HTTPS)";
	}
	wMqLog(L"Thread %d : Send / Receive Authenticate messages %s\n", m_testid,p);
}

//------------------------------------------------------------------
// SecCheackAuthMess :: CheckResult
// Test receive message from dest queue.
//


INT SecCheackAuthMess::CheckResult() 
{

	map <wstring,wstring> mPrepareBeforeRecive;
	HRESULT rc = MQ_OK;
	int iNumberOfExpectedMessage = cNumerOfMessages - 1 + ( g_bRunOnWhistler == TRUE ) ? 2:0;
	WCHAR wstrMclass[10];
	if(g_bDebug)
	{
		MqLog("Verify that ACK reached to queue\n");
	}
	swprintf(wstrMclass,L"%d",MQMSG_CLASS_ACK_REACH_QUEUE);
	mPrepareBeforeRecive[L"MClass"]= wstrMclass;
	mPrepareBeforeRecive[L"M_Label"] = m_wcsGuidMessageLabel;
	mPrepareBeforeRecive[L"FormatName"] = ConvertHTTPToDirectFormatName((wstring)(m_Adminqinfo->FormatName));
	mPrepareBeforeRecive[L"DebugInfromation"] = L"Receive message from admin queue"; 	
	for (INT Index=0; Index < iNumberOfExpectedMessage ; Index++ )
	{
		
		if( Index == cNumerOfMessages - 1  )
		{
			mPrepareBeforeRecive[L"M_Label"] = m_wcsGuidMessageLabel2;
			swprintf(wstrMclass,L"%d",MQMSG_CLASS_NACK_BAD_SIGNATURE);
			mPrepareBeforeRecive[L"MClass"]= wstrMclass;
			if ( m_bUseHttpFormatName )
			{ // No need to check NACK with http format name
				break;
			}
		}
		rc = RetrieveMessageFromQueue( mPrepareBeforeRecive );
		if( rc != MSMQ_BVT_SUCC )
		{
			wMqLog (L"Admin message was not found in the destination queue. (%d)\n",Index);
			return MSMQ_BVT_FAILED;
		}
	}

	if (g_bDebug)
	{
		MqLog("Verify that message reached to queue\n");
	}
	if( g_bDebug && m_bNeedToRefresh )
	{	
		m_Destqinfo->Refresh();
		_bstr_t  bStr =m_Destqinfo->PathName;
		wMqLog( L"Try to receive message from queue: %s \n" , bStr );
	}
	mPrepareBeforeRecive[L"M_Label"] = m_wcsGuidMessageLabel;
	mPrepareBeforeRecive[L"FormatName"] = ConvertHTTPToDirectFormatName((wstring)m_Destqinfo->FormatName);
	mPrepareBeforeRecive[L"DebugInfromation"] = L"Receive message from dest queue"; 	
	for( INT Index=0; Index < iNumberOfExpectedMessage ; Index ++ )
	{
		rc = RetrieveMessageFromQueue( mPrepareBeforeRecive );
		if(rc != MSMQ_BVT_SUCC)
		{
			wMqLog (L"Message was not found in the destination queue. (%d)\n",Index);
			return MSMQ_BVT_FAILED;
		}
	}
	
	
return MSMQ_BVT_SUCC;
}



//------------------------------------------------------------------
// SecCheackAuthMess :: Start_test
// Send authenticate message to authenticate queue 
// ask for ACK that message reach to queue.
// send auth message with handle that get from MQGetSecurityContext.
//

#define NUMOF_PROPS (8) // This is needed only for this test
int SecCheackAuthMess::Start_test() 
{
	SetThreadName(-1,"SecCheackAuthMess - Start_test ");
	try 
	{
		MSMQ::IMSMQQueuePtr m_DestqinfoHandle;
		MSMQ::IMSMQMessagePtr m_msg;

		m_msg.CreateInstance("MSMQ.MSMQMessage");
		m_DestqinfoHandle=m_Destqinfo->Open (MQ_SEND_ACCESS,MQ_DENY_NONE);
		if(g_bDebug)
		{
			MqLog("Send authenticate message to queue \n");
		}
		m_msg->Label = m_wcsGuidMessageLabel.c_str();
		m_msg->Body = m_wcsGuidMessageLabel.c_str();
		m_msg->AdminQueueInfo = m_Adminqinfo; 
		m_msg->Ack = (m_bUseHttpFormatName) ? MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL:MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE;
		m_msg->AuthLevel = MQMSG_AUTH_LEVEL_ALWAYS; // Send Auth Message
		m_msg->MaxTimeToReceive = MQBVT_MAX_TIME_TO_BE_RECEIVED;
		m_msg->Send ( m_DestqinfoHandle );
		VerifySendSucceded(m_DestqinfoFormatName,m_AdminqinfoFormatName);

		if(g_bRunOnWhistler)
		{
			m_msg->AuthLevel = MQMSG_AUTH_LEVEL_SIG20; // Send Auth Message
			m_msg->Send ( m_DestqinfoHandle );
			m_msg->AuthLevel = MQMSG_AUTH_LEVEL_SIG30; // Send Auth Message
			m_msg->Send ( m_DestqinfoHandle );
		}
		if( g_bDebug )
		{
			wprintf(L"Succeded to send auth message to queue:%s\n",m_DestQueueInfoPathName.c_str());
		}
		if(!m_bUseHttpFormatName) 
		{
		    m_msg->Label = m_wcsGuidMessageLabel2.c_str();
 		    m_msg->Body = m_wcsGuidMessageLabel2.c_str();
		    m_msg->AuthLevel = MQMSG_AUTH_LEVEL_NONE; // Send Auth Message
 		    m_msg->Send ( m_DestqinfoHandle );
 		    if( g_bDebug )
		    {
				wMqLog(L"Succeded to send none - auth message to queue:%s\n",m_DestQueueInfoPathName.c_str());
		    }
		}
		m_DestqinfoHandle->Close();
		HANDLE hSecCtx = NULL ;
		HRESULT hr;
        
		//Call to get Internal certificate Conext
		if(g_bDebug)
		{
			MqLog("call-> MQGetSecurityContext(NULL,,)\n");
		}

        hr = MQGetSecurityContext( NULL,
                                   0,
                                   &hSecCtx );
        
		ErrHandle( hr ,MQ_OK,L"MQGetSecurityContext failed ");
		WCHAR wszFormatName[ BVT_MAX_FORMATNAME_LENGTH+1 ]={0};
		WCHAR wszAdminQFormatName[BVT_MAX_FORMATNAME_LENGTH+1]={0};
		DWORD dwAdminQFormatNamelength = BVT_MAX_FORMATNAME_LENGTH;
		DWORD dwFormatNamelength = BVT_MAX_FORMATNAME_LENGTH;
		MSGPROPID     aMsgPropId[NUMOF_PROPS]={0};
		MQPROPVARIANT aMsgPropVar[NUMOF_PROPS]={0};
		HRESULT aResult[NUMOF_PROPS]={0};

		// Convert Form COM To C API By Take the Queue Format Name
		// From now using only C API .
		if( ! m_bUseHttpFormatName)
		{
			hr = MQPathNameToFormatName( m_Destqinfo->PathName,wszFormatName,&dwFormatNamelength );
			ErrHandle(hr,MQ_OK,L"MQPathNameToFormatName failed to retrive dest queue");

			hr = MQPathNameToFormatName( m_Adminqinfo->PathName,wszAdminQFormatName,&dwAdminQFormatNamelength );
			ErrHandle(hr,MQ_OK,L"MQPathNameToFormatName failed to retrive admin queue ");
		}
		else
		{
				wcscpy(wszFormatName,(WCHAR * ) m_Destqinfo->FormatName);
				wcscpy(wszAdminQFormatName,(WCHAR * ) m_Adminqinfo->FormatName);
		}
		HANDLE hQueue;
		hr = MQOpenQueue( wszFormatName, MQ_SEND_ACCESS, MQ_DENY_NONE, &hQueue );
		ErrHandle(hr,MQ_OK,L"MQOpenQueue failed to open authenticate queue");
		
		if( g_bDebug )
		{
			wMqLog(L"Succeded to send authenticated message with MQGetSecurityContext to queue:%s\n",m_DestQueueInfoPathName.c_str());
		}

		//------------------------------------------
		// Send message using security context.
		//

		ULONG uIndex = 0 ;

		aMsgPropId[ uIndex ] = PROPID_M_SECURITY_CONTEXT ;
		aMsgPropVar[ uIndex ].vt = VT_UI4;
		aMsgPropVar[ uIndex ].ulVal = PtrToLong( hSecCtx );
		uIndex++ ; 
		 
		 
		aMsgPropId [ uIndex ] = PROPID_M_BODY ;
	    aMsgPropVar[ uIndex ].vt = VT_VECTOR|VT_UI1;         
		aMsgPropVar[ uIndex ].caub.pElems = (UCHAR *) m_wcsGuidMessageLabel.c_str();
		aMsgPropVar[ uIndex ].caub.cElems = ( (ULONG)(wcslen (m_wcsGuidMessageLabel.c_str()))) * sizeof (WCHAR) ;
        uIndex++;

		 		 
		aMsgPropId [ uIndex ] = PROPID_M_LABEL ;
	    aMsgPropVar[ uIndex ].vt = VT_LPWSTR;
		aMsgPropVar[ uIndex ].pwszVal =(USHORT *) m_wcsGuidMessageLabel.c_str() ;
        uIndex++;

		aMsgPropId [ uIndex ] = PROPID_M_ADMIN_QUEUE ;
		aMsgPropVar[ uIndex ].vt = VT_LPWSTR;
		aMsgPropVar[ uIndex ].pwszVal = wszAdminQFormatName; //Admin Queue Format Name
		uIndex++;

		aMsgPropId [ uIndex ] = PROPID_M_ACKNOWLEDGE ;
		aMsgPropVar[ uIndex ].vt = VT_UI1;
		aMsgPropVar[ uIndex ].bVal = (UCHAR)((m_bUseHttpFormatName) ? MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL:MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE);
		uIndex++ ; 
		
	    aMsgPropId [ uIndex ] = PROPID_M_AUTH_LEVEL;
		aMsgPropVar[ uIndex ].vt = VT_UI4;
		aMsgPropVar[ uIndex ].ulVal = MQMSG_AUTH_LEVEL_ALWAYS;	
        uIndex++ ;  

		aMsgPropId [ uIndex ] = PROPID_M_TIME_TO_BE_RECEIVED;
		aMsgPropVar[ uIndex ].vt = VT_UI4;
		aMsgPropVar[ uIndex ].ulVal = MQBVT_MAX_TIME_TO_BE_RECEIVED;	
        uIndex++ ;  
			
		MQMSGPROPS MsgProps = { uIndex, aMsgPropId, aMsgPropVar, aResult};
		hr = MQSendMessage( hQueue, &MsgProps, NULL);
		MQFreeSecurityContext(hSecCtx);
		if( FAILED(hr)) 
		{
			MqLog ("Error can't send authenticated message rc=0x%x\n",hr);
			return MSMQ_BVT_FAILED;
		}
	
	}
	
	catch(_com_error & ComErr)
	{	
		return CatchComErrorHandle ( ComErr , m_testid);
	}
return MSMQ_BVT_SUCC;
}

SecCheackAuthMess::SecCheackAuthMess( INT iTestid ,   map <wstring,wstring> TestParms ) 
: cTest(iTestid) , m_Destqinfo("MSMQ.MSMQQueueInfo") , m_Adminqinfo("MSMQ.MSMQQueueInfo") 
, cNumerOfMessages(3),m_bUseHttpFormatName(TRUE)
{
	try 
	{	
		m_ResualtVal = MQMSG_CLASS_ACK_REACH_QUEUE;
		m_DestqinfoFormatName = TestParms [L"DestFormatName"];
		m_Destqinfo->FormatName = m_DestqinfoFormatName.c_str();
		m_bNeedToRefresh = TestParms [L"FormatNameType"] == L"Http" ? 0:1 ;
		m_AdminqinfoFormatName = TestParms [L"AdminFormatName"];
		m_Adminqinfo->FormatName = m_AdminqinfoFormatName.c_str();
		if( m_bNeedToRefresh )
		{
			//
			// No need to refresh Qinfo when used with HTTP format name
			//
			m_bUseHttpFormatName = FALSE;
			m_Destqinfo -> Refresh();		
			m_Adminqinfo ->Refresh(); 
		}
		m_DestQueueInfoPathName = TestParms[L"DestQueuePathName"];
		ReturnGuidFormatName( m_wcsGuidMessageLabel2 , 0 , true);
 	}
	catch( _com_error & ComErr )
	{	
		CatchComErrorHandle ( ComErr , m_testid);
		wMqLog(L"SecCheackAuthMess::SecCheackAuthMess failed with error 0x%x\n",ComErr.Error());
		throw INIT_Error("SecCheackAuthMess: constructor refresh queue parameters failed");
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\encrpt.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Encrypt.cpp

Abstract:
	
	  Send / receive encrypted message to encrypted queue
		
Author:

    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#include "msmqbvt.h"
using namespace std;



VOID InvetigateTimeOut(CONST WCHAR * pLabel, CONST WCHAR * pBody );
//------------------------------------------------------
// PrivateMessage::Start_test
//
// Send encrypted message using 40 and 128 bit encrypted
//


int PrivateMessage::Start_test() 
{
	
	SetThreadName(-1,"PrivateMessage - Start_test ");
	try 
	{
		
		//
		// Send Encrypted messge without body 
		//
				
		MSMQ::IMSMQQueuePtr m_DestqinfoHandle;
		m_DestqinfoHandle  = m_Destqinfo->Open( MQ_SEND_ACCESS,MQ_DENY_NONE );
		
		m_msg->AdminQueueInfo = m_Adminqinfo; 
		m_msg->Ack = MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE;

		if ( g_bDebug )
		{
			wstring wcsDestQueueLabe = m_Destqinfo->Label;
			wMqLog(L"Privq - Try to send encrypted message to :%s\n" , wcsDestQueueLabe.c_str());
		}

		m_msg->PrivLevel = MQMSG_PRIV_LEVEL_BODY_BASE;
		m_msg->Label = m_wcsGuidMessageLabel.c_str();
		m_msg->MaxTimeToReceive = MQBVT_MAX_TIME_TO_BE_RECEIVED;
		m_msg->Send( m_DestqinfoHandle);
		
		if (g_bDebug)
		{
			wMqLog(L"Privq - Send encrypted messages without body \n");
		}
		//
		// Send encrypted message with body 
		//

		m_msg->Body = "Test Encription With messgae body";
		m_msg->Label = m_wcsGuidMessageLabel.c_str();
		m_msg->PrivLevel = MQMSG_PRIV_LEVEL_BODY_BASE;
		m_msg->Send ( m_DestqinfoHandle );
		
		if( g_bDebug )
		{
			wMqLog( L"Privq - Send encrypted messages with body \n" );
		}

		//
		// Send message without priv level need to get NACK in the admin queue
		//

		m_msg->Label = wcsNACKMessageGuid.c_str();
		m_msg->PrivLevel = MQMSG_PRIV_LEVEL_NONE;
		m_msg->Send( m_DestqinfoHandle );
		
		if( g_bDebug )
		{
			wMqLog( L"Privq - Send without encrypt messages to encrypted queue\n");
		}

		m_DestqinfoHandle->Close();

		//-------------------------------------------------------------------------
		// Send encrypted message using 128 bit encryption 
		// This is W2K only & need to install 128 before.
		//
				
		if ( m_bUseEnhEncrypt == TRUE )
		{
			if( g_bDebug )
			{
				wMqLog( L"Privq - Send encrypt messages using 128 bit encryption \n");
			}
						
			const int c_NumOfProp=7;
			cPropVar Sprop( c_NumOfProp );

			
			wcscpy( wcszMlabel , L"Test 128 Encrypt !@#$%^&**");
			
			HANDLE hQueue;
			HRESULT rc = MQOpenQueue( m_Destqinfo->FormatName , MQ_SEND_ACCESS , MQ_DENY_NONE, &hQueue );
			ErrHandle(rc,MQ_OK,L"MQOpenqueue failed to open encrypted queue to send 128 bit encryption ");

			Sprop.AddProp( PROPID_M_LABEL , VT_LPWSTR , m_wcsGuidMessageLabel.c_str() );
			wstring tempString = m_Adminqinfo->FormatName;
			Sprop.AddProp( PROPID_M_ADMIN_QUEUE , VT_LPWSTR , tempString.c_str() );
			UCHAR ucTemp = MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE;
			Sprop.AddProp( PROPID_M_ACKNOWLEDGE , VT_UI1 , &ucTemp );	
			ULONG ulTemp = MQMSG_PRIV_LEVEL_BODY_ENHANCED;
			Sprop.AddProp( PROPID_M_PRIV_LEVEL , VT_UI4, &ulTemp );
			ulTemp = MQBVT_MAX_TIME_TO_BE_RECEIVED;
			Sprop.AddProp( PROPID_M_TIME_TO_BE_RECEIVED , VT_UI4, &ulTemp );

			rc = MQSendMessage( hQueue , Sprop.GetMSGPRops() , NULL );	
			ErrHandle(rc,MQ_OK,L"MQSendMessage failed to send 128 bit encrypted message" );

			Sprop.AddProp( PROPID_M_BODY , VT_UI1|VT_VECTOR , m_wcsGuidMessageLabel.c_str() );	
			
			rc = MQSendMessage( hQueue , Sprop.GetMSGPRops() , NULL );
			ErrHandle(rc,MQ_OK,L"MQSendMessage failed to send 128 bit encrypted message with body");
			
			rc = MQCloseQueue ( hQueue );
			ErrHandle( rc , MQ_OK , L"MQClosequeue failed" );
		}

	}
	catch( _com_error& ComErr )
	{	
		return CatchComErrorHandle ( ComErr , m_testid );
	}
	
return MSMQ_BVT_SUCC;
}


//------------------------------------------------------
// PrivateMessage::CheckResult() 
// Retrive the messgae from Encrypted queue.
//
//

INT PrivateMessage::CheckResult() 
{
		//
		// Check the Admin queue for ACK / NACK messages
		//
	HRESULT rc = MQ_OK;
	try
	{
	
		map <wstring,wstring> mPrepareBeforeRecive;

		WCHAR wstrMclass[10];
		if (g_bDebug)
		{
			wMqLog (L"Privq - receive from admin queue the ACK & NACK messages\n");
		}

		mPrepareBeforeRecive[L"FormatName"]=m_wcsAdminQFormatName;
		mPrepareBeforeRecive[L"DebugInformation"]=L"Recive ack 1 from admin queue";
		mPrepareBeforeRecive[L"M_Label"]=m_wcsGuidMessageLabel;
		swprintf(wstrMclass,L"%d",MQMSG_CLASS_ACK_REACH_QUEUE);
		mPrepareBeforeRecive[L"MClass"]= wstrMclass;
		const int iExpectedMessage = (	m_bUseEnhEncrypt== TRUE) ? 4:2;
		int i = 0;
		for (i=0;i<iExpectedMessage;i++)
		{
			rc = RetrieveMessageFromQueue(  mPrepareBeforeRecive );
			if( rc !=  MSMQ_BVT_SUCC ) 
			{
				wMqLog (L"Privq - can't find ACK #%d in the admin queue (1)\n",i);
				return MSMQ_BVT_FAILED;
			}
		}

		mPrepareBeforeRecive[L"DebugInformation"]=L"Recive Nack from admin queue";
		mPrepareBeforeRecive[L"M_Label"]=wcsNACKMessageGuid;

		swprintf(wstrMclass,L"%ld",MQMSG_CLASS_NACK_BAD_ENCRYPTION);
		mPrepareBeforeRecive[L"MClass"]= wstrMclass;

		rc = RetrieveMessageFromQueue(  mPrepareBeforeRecive );
		if( rc !=  MSMQ_BVT_SUCC ) 
		{
			wMqLog (L"Privq - can't find NACK in the admin queue \n");
			return MSMQ_BVT_FAILED;
		} 


 
	}
	catch( _com_error& ComErr )
	{
		MqLog( "Privq- Can't find ACK/NACK message" );
		return CatchComErrorHandle ( ComErr , m_testid );
	}

	try 
	{

		
		map < wstring,wstring > map_ReceiveFromQueue;
		map_ReceiveFromQueue[L"DestFormatName"] = ( wstring ) m_Destqinfo->FormatName;
		map_ReceiveFromQueue[L"mLabel"] = m_wcsGuidMessageLabel;
		// Need to check message class in the Recive need to add new input.
		if (g_bDebug)
		{
				wMqLog (L"Privq - Try to receive message from dest queue \n");
		}
		try
		{
			int iMessageInDestQueue = 2;
			if ( m_bUseEnhEncrypt == TRUE )
			{
				iMessageInDestQueue = 4;
			}
			for (int Index = 0; Index < iMessageInDestQueue ; Index ++ )
			{
				rc = RetrieveMessageFromQueueViaCom( map_ReceiveFromQueue );
				if( rc != MSMQ_BVT_SUCC )
				{
					wMqLog( L"Privq- PrivateMessage::CheckResult can't find message in the queue %d\n",Index );
					return MSMQ_BVT_FAILED;
				}
				if (g_bDebug)
				{	
					wMqLog (L"Privq - Message found. \n");			
				}
			}
		}
		catch( _com_error& ComErr )
		{
			MqLog( "Privq- Error during search of message in the queue \n" );
			return CatchComErrorHandle ( ComErr , m_testid );
		}

	}
	catch(_com_error & ComErr )
	{	
		return CatchComErrorHandle ( ComErr , m_testid );
	}

	return MSMQ_BVT_SUCC;
}

void PrivateMessage::Description()
{
		MqLog ("Thread %d : Send / Receive encryption messages \n",m_testid );
}

//------------------------------------------------------------------------------
// PrivateMessage Constructor
// This prepare the test for Send / Receive message with encrypted body.
//

PrivateMessage::PrivateMessage (INT index, std :: map <std::wstring, std::wstring > TestParms):
 cTest(index), m_Destqinfo("MSMQ.MSMQQueueInfo"), m_Adminqinfo("MSMQ.MSMQQueueInfo"),m_msg("MSMQ.MSMQMessage")
{

	try 
	{	
		
		m_ResualtVal = MQMSG_CLASS_ACK_REACH_QUEUE;	
		m_Destqinfo->FormatName = TestParms[L"DestFormatName"].c_str();
		m_Destqinfo->Refresh();
		m_Adminqinfo->FormatName = TestParms[L"AdminFormatName"].c_str();
		m_Adminqinfo->Refresh();
		m_wcsAdminQFormatName = TestParms[L"AdminFormatName"];
		m_bUseEnhEncrypt = FALSE;
		if ( TestParms[L"Enh_Encrypt"] ==  L"True" )
		{
			m_bUseEnhEncrypt = TRUE;
		}

		if ( g_bDebug )
		{
			wcout << L"Privq - DestQ Formatname: " << (wstring ) m_Destqinfo->FormatName <<endl;
			wcout << L"Privq - DestQ PathName: " << (wstring ) m_Destqinfo->PathName <<endl;
			wcout << L"Privq - DestQ Label: " << (wstring ) m_Destqinfo->Label <<endl;
			wcout << L"Privq - AdminQ PathName: " << (wstring ) m_Adminqinfo->PathName <<endl;
		}
		
		//
		// Create guid for the NACK message label
		// 
		
		ReturnGuidFormatName( wcsNACKMessageGuid , 0 , true);

	}
	catch ( _com_error & ComErr )
	{		
		CatchComErrorHandle ( ComErr , index );
		throw INIT_Error("Problem during construct PrivateMessage class");
	}

}

//---------------------------------------------------------------------------------------
// PrivateMessage Distractor 
// Empty
//

PrivateMessage::~PrivateMessage() 
{ 
}

//---------------------------------------------------------------------------------------
// RetrieveMessageFromQueueViaCom
// This function search for specific message in the queue with C-API function
// If the message found the function receive the message from the queue
//
// Input parameters:
//	   mRetrieveParms map that expect those keys:
//     mRetrieveParms[L"M_Label"] - Message label to search.
//     mRetrieveParms[L"FormatName"] - Queue format name.
//
// retrun value: 
// True - message found.
// false - message NOT found.
//

HRESULT RetrieveMessageFromQueueViaCom( map <wstring,wstring> & mRetrieveParms )
{
	
	BOOL bMessageFound = FALSE;
	DWORD dwTestId = 66;
	try
	{
	
		MSMQ::IMSMQQueueInfoPtr m_Destqinfo( "MSMQ.MSMQQueueInfo" );
	//	MSMQ::IMSMQMessage2Ptr m_msg( "MSMQ.MSMQMessage" );
		MSMQ::IMSMQMessagePtr m_msg( "MSMQ.MSMQMessage" );
			
		if(g_bDebug)
		{
			wMqLog (L"RetrieveMessageFromQueueViaCom - DestQueueFormatName: %s\n",mRetrieveParms[L"DestFormatName"].c_str());
		}

		m_Destqinfo->FormatName = mRetrieveParms[L"DestFormatName"].c_str();
		wstring wcsQueueuFormatName = mRetrieveParms[L"DestFormatName"];
		if ( wcsstr(wcsQueueuFormatName.c_str(),L"DIRECT=") == NULL )
		{
			m_Destqinfo->Refresh();
		}

		wstring wcsGuidLabel = mRetrieveParms[L"mLabel"];
		
		MSMQ::IMSMQQueuePtr m_DestqinfoHandle;
		m_DestqinfoHandle = m_Destqinfo->Open(MQ_RECEIVE_ACCESS,MQ_DENY_NONE);

		_variant_t timeout( long(BVT_RECEIVE_TIMEOUT) );
		
		
		// Convert string to DWORD.

		wstring wcsTemp = mRetrieveParms[L"TestId"];
		if ( _snwscanf( wcsTemp.c_str() , wcsTemp.length(), L"%d", & dwTestId ) == EOF )
		{
			MqLog("RetrieveMessageFromQueueViaCom failed to convert from string to DWORD \n");
			return MQ_ERROR;
		}

		//
		// Loop to find the message
		// 

		try
		{
			m_msg = m_DestqinfoHandle ->PeekCurrent( &vtMissing , &vtMissing , &timeout );
		}
		catch( _com_error & ComErr )
		{
			wMqLogErr(L"RetrieveMessageFromQueueViaCom PEEK CURRENT operation catch unexpected error 0x%x  Queue:%s   Message Label:%s\n", ComErr.Error(),  mRetrieveParms[L"DestFormatName"].c_str(),wcsGuidLabel.c_str());
			if( ComErr.Error() == MQ_ERROR_IO_TIMEOUT )
			{	
				InvetigateTimeOut(wcsQueueuFormatName.c_str(),wcsGuidLabel.c_str());
			}
			return CatchComErrorHandle( ComErr , dwTestId );
		}

		while ( m_msg != NULL && ! bMessageFound )
		{
			if( !wcscmp( m_msg->Label , wcsGuidLabel.c_str() ) ) 
			{
				try 
				{	
						//
						// Message found need to remove message from the queue.
						//
						m_msg = m_DestqinfoHandle -> ReceiveCurrent( &vtMissing , &vtMissing , &vtMissing , &timeout);
						if ( wcscmp( m_msg->Label , wcsGuidLabel.c_str() ) ) 
						{
							printf ("Mqbvt received messgae that is not the expected one  Expected label:%s  Received Message label:%s!\n",wcsGuidLabel.c_str(), m_msg->Label);
							return MSMQ_BVT_FAILED;
						}

						bMessageFound = TRUE ;	
						break;
				}
				catch( _com_error & ComErr )
				{
					wMqLogErr(L"RetrieveMessageFromQueueViaCom RECEIVE MESSAGE operation catch unexpected error 0x%x  Queue:%s   Message Label:%s\n", ComErr.Error(),  mRetrieveParms[L"DestFormatName"].c_str(),wcsGuidLabel.c_str());
					if( ComErr.Error() == MQ_ERROR_IO_TIMEOUT )
					{	
						InvetigateTimeOut(wcsQueueuFormatName.c_str(),wcsGuidLabel.c_str());
					}
					return CatchComErrorHandle( ComErr , dwTestId );
				}
			}

			try 
			{
				m_msg = m_DestqinfoHandle -> PeekNext( &vtMissing , &vtMissing , &timeout);
			}
			catch( _com_error & ComErr )
			{
				wMqLogErr(L"RetrieveMessageFromQueueViaCom PEEK NEXT operation catch unexpected error 0x%x  Queue:%s   Message Label:%s\n", ComErr.Error(),  mRetrieveParms[L"DestFormatName"].c_str(),wcsGuidLabel.c_str());
				if( ComErr.Error() == MQ_ERROR_IO_TIMEOUT )
				{	
					InvetigateTimeOut(wcsQueueuFormatName.c_str(),wcsGuidLabel.c_str());
				}
				return CatchComErrorHandle( ComErr , dwTestId );
			}
		}
		
		if( bMessageFound == FALSE )
		{
			wMqLogErr(L"RetrieveMessageFromQueueViaCom: Can't locate messages in queue.  Queue:%s   Message Label:%s\n",  mRetrieveParms[L"DestFormatName"].c_str(),wcsGuidLabel.c_str());
			return MSMQ_BVT_FAILED;
		}
		
		if( _winmajor >= Win2K && mRetrieveParms[L"TransBoundary"] != L"" ) 
		{
			MSMQ::IMSMQMessage2Ptr m_msg2( "MSMQ.MSMQMessage" );
			m_msg2=m_msg;
			// 1 message first &last
			if( m_msg2->IsFirstInTransaction != 0 )
			{
				mRetrieveParms[L"TransBoundary"] = L"First";
			}
			else if( m_msg2->IsLastInTransaction != 0)
			{
				mRetrieveParms[L"TransBoundary"] = L"Last";
			}
			else
			{
			
				mRetrieveParms[L"TransBoundary"]=g_wcsEmptyString;
			}
		}
		if( mRetrieveParms[L"mBody"] == g_wcsEmptyString)
		{
			_bstr_t  bstrBody = m_msg->Body;
			mRetrieveParms[L"mBody"] = (wstring) bstrBody;
		}

		m_DestqinfoHandle->Close();
	}
	catch( _com_error & ComErr )
	{
		wMqLogErr(L"RetrieveMessageFromQueueViaCom catch unexpected error 0x%x  Queue:%s   Message Label:%s\n", ComErr.Error(),  mRetrieveParms[L"DestFormatName"].c_str(),mRetrieveParms[L"mLabel"].c_str());
		return CatchComErrorHandle( ComErr , 66 );
	}
	return bMessageFound ? MSMQ_BVT_SUCC : MSMQ_BVT_FAILED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\dcom.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Mqf.cpp

Abstract:
	      DCOM thread verify that msmq can work throw dcom.
Author:
    
	  Eitan klein (EitanK)  24-Jul-2001

Revision History:

--*/

#include "msmqbvt.h"

using namespace std;



void cDCom::Description()
{
	MqLog("Thread %d : DCOM Test \n", m_testid);
}
cDCom::~cDCom()
/*++  
	Function Description:
		destractor.
	Arguments:
		None
	Return code:
		PASS /FAILED
	
--*/
{

	   if( m_pIQueueInfoInterface != NULL )
	   {			   
			m_pIQueueInfoInterface->Delete();
			m_pIQueueInfoInterface->Release();
	   }
	   if( m_pIQueueHandle != NULL )
	   {
			m_pIQueueHandle->Release();
	   }
	   if( m_pIMsg != NULL )
	   {
			m_pIMsg->Release();
	   }
}

cDCom::cDCom( INT iTid, std::map <std::wstring,std::wstring> & mParams , bool bWkg)
: cTest(iTid),m_pIMsg(NULL),m_pIQueueInfoInterface(NULL),m_pIQueueHandle(NULL),m_bWkg(bWkg)
/*++  
	Function Description:
		Constractor.
	Arguments:
		None
	Return code:
		PASS /FAILED
	
--*/

{
	m_wcsRemoteMachieName =  mParams[L"RemoteMachine"];
	m_PublicQueuePathName = mParams[L"PublicQueuePathName"]; 
	m_PublicQueueFormatName = mParams[L"PublicQueueFormatName"]; 
}

cDCom::Start_test()
/*++  
	Function Description:
		Create local private queue and send message throw DCOM.
		---  For debugging you need to attach to dllhost.exe
	Arguments:
		None
	Return code:
		PASS /FAILED
	
--*/

{

	HRESULT hr = MQ_ERROR;
	MULTI_QI    mq={0};
#ifdef _MSMQ3ONLY
	
	mq.pIID =  &IID_IMSMQQueueInfo;		
	mq.pItf = NULL;
	mq.hr = S_OK;	
	COSERVERINFO csi, *pcsi = NULL;
	memset(&csi, 0, sizeof(COSERVERINFO));
	csi.pwszName = const_cast<WCHAR*>(m_wcsRemoteMachieName.c_str());
	pcsi = &csi;
	//
	// Get 	CLSID_MSMQQueueInfo interface on remote machine
	//
	hr = CoCreateInstanceEx(CLSID_MSMQQueueInfo, NULL, CLSCTX_REMOTE_SERVER, pcsi, 1, &mq);
#endif // _MSMQ3ONLY
	if(FAILED(hr))
	{
		MqLog("DCOM CoCreateInstanceEx failed with error 0x%x\n",hr);
		return MSMQ_BVT_FAILED;
	} 
	if( g_bDebug )
	{
		MqLog("DCOM call to CoCreateInstanceEx to create to init remote interfacce \n");
	}
	//
	// Get CLSID_MSMQMessage interface on remote machine
	//
#ifdef _MSMQ3ONLY
	m_pIQueueInfoInterface = (IMSMQQueueInfo *)mq.pItf;
	mq.pIID =  &IID_IMSMQMessage;
    mq.pItf = NULL;
    mq.hr = S_OK;

	hr = CoCreateInstanceEx(CLSID_MSMQMessage, NULL, CLSCTX_REMOTE_SERVER, pcsi, 1, &mq);
	
#endif //_MSMQ3ONLY
	if(FAILED(hr))
	{
		MqLog("DCOM CoCreateInstanceEx failed with error 0x%x\n",hr);
		return MSMQ_BVT_FAILED;

	}
	
	m_pIMsg = (IMSMQMessage *)mq.pItf;

	if( g_bDebug )
	{ 
		MqLog("DCOM - Create private queue on remote machine through DCOM  and send single message\n");
	}

	wstring wcsQueuePathName = L".\\private$\\DCom" + m_wcsGuidMessageLabel;
	_bstr_t bQueuePathName =  wcsQueuePathName.c_str();	 
	//
	// Create private queue on remote machine.
	// 
	hr = m_pIQueueInfoInterface->put_PathName(bQueuePathName);
	ErrHandle(hr,MQ_OK,L"DCom - put_PathName Failed");

	hr = m_pIQueueInfoInterface->Create(&vtMissing,&vtMissing);
	ErrHandle(hr,MQ_OK,L"DCom - Create queue Failed");
	
	hr=m_pIQueueInfoInterface->Open(MQ_SEND_ACCESS,MQ_DENY_NONE,&m_pIQueueHandle);	
	ErrHandle(hr,MQ_OK,L"DCom - Open queue for send Failed");

	//
	// Send message to queue
	//
	_bstr_t bsMsgLabel = m_wcsGuidMessageLabel.c_str();
	 
	hr = m_pIMsg->put_Label(bsMsgLabel);
	ErrHandle(hr,MQ_OK,L"DCom - Open queue for send Failed");

	hr = m_pIMsg->Send(m_pIQueueHandle,&vtMissing);
	ErrHandle(hr,MQ_OK,L"DCom - Send Failed");

	if( g_bDebug )
	{ 
		MqLog("DCOM - Send message succeeded.\n");
	}
	
	//
	// close queue
	//
	hr =m_pIQueueHandle->Close();
	ErrHandle(hr,MQ_OK,L"DCom - Close Failed");


	return MSMQ_BVT_SUCC;
}

int 
cDCom::CheckResult()
/*++  
	Function Description:
		verify that message succeded to reach remote machine throw DCOM.
	Arguments:
		None
	Return code:
		PASS /FAILED
	
--*/
{

	if( g_bDebug )
	{ 
		MqLog("DCOM - Receive message and compare message to expected results. \n");
	}
	
	HRESULT hr = m_pIQueueInfoInterface->Open(MQ_RECEIVE_ACCESS,MQ_DENY_NONE,&m_pIQueueHandle );		
	ErrHandle(hr,MQ_OK,L"DCom - Open for receive failed");
	
	//
	// Receive message from queue
	//
	hr =m_pIQueueHandle->ReceiveCurrent(&vtMissing,&vtMissing,&vtMissing,&vtMissing,&m_pIMsg);
	ErrHandle(hr,MQ_OK,L"DCom - ReceiveCurrent Failed");
	
	hr =m_pIQueueHandle->Close();
	ErrHandle(hr,MQ_OK,L"DCom - Close Failed");

	BSTR p;
	hr = m_pIMsg->get_Label(&p);
	ErrHandle(hr,MQ_OK,L"DCom - Get label Failed");
	
	if( m_wcsGuidMessageLabel != p )
	{
		wMqLog(L"DCOM thread received incorrect message expected:%s\n Found:%s\n",m_wcsGuidMessageLabel.c_str(),p);
		return MSMQ_BVT_FAILED;
	}

	//
	// Delete queue
	//
	hr = m_pIQueueInfoInterface->Delete();
	ErrHandle(hr,MQ_OK,L"DCom - Delete Failed");	

	if( m_bWkg == false )
	{
		if( g_bDebug )
		{ 
			MqLog("DCOM - Verify access to active directory call to refresh method. \n");
		}
		_bstr_t bsPathName(m_PublicQueuePathName.c_str());
		hr = m_pIQueueInfoInterface->put_PathName(bsPathName);
		ErrHandle(hr,MQ_OK,L"DCom - put_PathName Failed");

		hr = m_pIQueueInfoInterface->Refresh();
		ErrHandle(hr,MQ_OK,L"DCom - Refresh Failed");

		hr = m_pIQueueInfoInterface->get_FormatName(&p);
		ErrHandle(hr,MQ_OK,L"DCom - get_FormatName Failed");

		if( m_PublicQueueFormatName != p )
		{
		   wMqLog(L"DCOM thread get incorrect format name expected:%s\n Found:%s\n",m_wcsGuidMessageLabel.c_str(),p);
		   return MSMQ_BVT_FAILED;
		}
	}

	//
	// Delete release interface
	//
	m_pIQueueInfoInterface->Release();
	m_pIQueueInfoInterface = NULL;
	return MSMQ_BVT_SUCC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\handleer.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: HandleEr.cpp

Abstract:

	  Log and error handle function 
	
Author:

    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#include "msmqbvt.h"
using namespace std;

extern bool g_bRaiseASSERTOnError;
// ------------------------------------------------------------
// INIT_Error::INIT_Error Constructor
// Create the error message into the member variable 
// Input parmeter:
// wcsDescription - Error description.
//


INIT_Error::INIT_Error (const CHAR * wcsDescription) :m_wcsErrorMessages( wcsDescription )
{
} 


//----------------------------------------------------------------------------
// Print to standard error the error description that contain the line & filename 
// 
// Input parmeters:
// wcsMessage - Discription for the error 
// rc - HRESULT value for the related error.
// File - File name from __FILE__ .
// iline - Line number __LINE__ .
//


void ErrorHandleFunction (wstring wcsMessage,HRESULT rc,const CHAR * csFileName ,const INT iLine)
{

	UNREFERENCED_PARAMETER(iLine);
	wMqLogErr(L"%s rc=0x%x",wcsMessage.c_str(),rc);
	CHAR token[]= "\\";
	CHAR  * pwcString;
	
	P < CHAR > pcsFile = (CHAR * ) malloc( sizeof( CHAR  ) * ( strlen(csFileName) + 1 ) );	
	if ( ! pcsFile )
	{
		MqLog( "malloc failed to allocate memory for error message ! (Exit without error )\n" );
		return ;
	}


	P < CHAR > pcsTemp = ( CHAR * ) malloc( sizeof( CHAR ) * ( strlen(csFileName) + 1 ) );
	if ( ! pcsTemp )
	{
		MqLog("malloc failed to allocate memory for error message ! (Exit without error )\n");
		return ;
	}
	
	//
	// Remove full path name from the __FILE__ value.
	// i.e. \\eitan5\rootc\msmq\src\Init.cpp --> Init.cpp.
	// 

	strcpy( pcsFile , csFileName);
	pwcString = pcsFile;
	CHAR * csFilePos = pcsFile;

	while( pwcString != NULL && csFileName )
	{

		 strcpy( pcsTemp , pwcString);
		 pwcString = strtok(csFilePos , token);
		 csFilePos = NULL;
	}
	MqLogErr(" Filename: %s\n",pcsTemp);	
	if(g_bRaiseASSERTOnError == false)
	{
		MessageBoxW(NULL,wcsMessage.c_str(),L"Mqbvt ",MB_SETFOREGROUND|MB_OK);
	}
}

//----------------------------------------------------------------------------------------
// CatchComErrorHandle retrieve information from _com_error object
// And Print the error message .
// Input parmeters:
// ComErr - COM error object that cached.
// iTestID - Test Identifier.
//
// Output parmeter:
// MSMQ_BVT_FAILED  only.


INT CatchComErrorHandle ( _com_error & ComErr , int  iTestID)
{

	_bstr_t  bStr = ( ComErr.Description() ); 
	MqLog("Thread %d got error: 0x%x\n",iTestID,ComErr.Error());
	// Check if description is exist for the related error value
	const WCHAR * pbStrString = (WCHAR * ) bStr;
	if(pbStrString != NULL &&  *pbStrString )
	{
		if (!wcscmp (pbStrString,L""))
		{
			MqLog("Bug this com_error error is without description\n");
		}
		wMqLog(L"%s\n",pbStrString);
	}

	return MSMQ_BVT_FAILED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\client.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Client.cpp

Abstract:
	      This code sends the server request to run again specific machine		
Author:
    
	  Eitan klein (EitanK)  18-Aug-1999

Revision History:

--*/
#include "msmqbvt.h"
using namespace std;

int ClientCode (int argc, char ** argv )
{
    char    inbuf[80];
    char    outbuf[80];
    DWORD   bytesRead;
    BOOL    ret;
    LPSTR   lpszPipeName = "\\\\.\\pipe\\simple";	
	string  wcsCommandLineArguments;
    
	
	//
	// Need to send the command line paramters to mqbvt 
	// Need to support those parm -r:  -s  - NT4
	// 
	CInput CommandLineArguments( argc,argv );
	wcsCommandLineArguments = "";
	if(CommandLineArguments.IsExists ("r"))
	{
		wcsCommandLineArguments += ( string )" /r:"+ CommandLineArguments["r"].c_str() + (string)" ";
	}
		
	if(CommandLineArguments.IsExists ("s"))
	{
		wcsCommandLineArguments +=  (string)" /s ";
	}
	if(CommandLineArguments.IsExists ("i"))
	{
		wcsCommandLineArguments += (string) " /i" ;
	}
	if(CommandLineArguments.IsExists ("NT4"))
	{
		wcsCommandLineArguments += (string) " /NT4" ;
	}

	if(CommandLineArguments.IsExists ("t"))
	{
		wcsCommandLineArguments += (string) " /t:" +  CommandLineArguments["t"].c_str();
	}
	
	if(CommandLineArguments.IsExists ("multicast"))
	{
		wcsCommandLineArguments += (string) " /multicast:" +  CommandLineArguments["multicast"].c_str();
	}

	if(CommandLineArguments.IsExists ("wsl"))
	{
		wcsCommandLineArguments += (string) " /wsl:";
	}
	if(CommandLineArguments.IsExists ("https"))
	{
		wcsCommandLineArguments += (string) " /https";
	}
	if(CommandLineArguments.IsExists ("d"))
	{
		wcsCommandLineArguments += (string) " /d:";
	}

    strcpy( outbuf, wcsCommandLineArguments.c_str() );
	
    ret = CallNamedPipeA(lpszPipeName,
                         outbuf, sizeof(outbuf),
                         inbuf, sizeof(inbuf),
                         &bytesRead, NMPWAIT_WAIT_FOREVER);

    if (!ret) {
        MqLog("client: CallNamedPipe failed, GetLastError = %d\n", GetLastError());
        exit(1);
    }

    MqLog("client: received: %s\n", inbuf);
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\imp.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Auth.cpp

Abstract:
	
		
Author:
	Written by:Gilsh@microsoft.com
    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#include "msmqbvt.h"
#include <rpc.h>
#include "sec.h"
#include "ptrs.h"
using namespace std;
#pragma warning( disable: 4786)


//
// Auto handle class
//

inline Handle_t::Handle_t(HANDLE handle):m_handle(handle)
{
 
}
inline HANDLE Handle_t::get()
{
	return m_handle;
}

inline Handle_t::~Handle_t()
{
	CloseHandle(m_handle);
}




// impersonate with given tokem
inline Impersonate_t::Impersonate_t(HANDLE hToken):m_impersonated(true)
{
   bool bResult=(ImpersonateLoggedOnUser(hToken)==TRUE);
   if(bResult == FALSE)
   {
	   throw INIT_Error("could not impersonate");
   }
}

//does impersonation for the calling thread

// 
// End of impersonate class
//


inline void LoadCurrentThreadHive( wstring & szAccoutName )
{
   std::basic_string<unsigned char> sid=GetCurrentThreadSid( szAccoutName );
   LoadHiveForSid(sid);
}

inline std::basic_string<unsigned char> GetCurrentThreadSid( wstring & wcsAccountName )
{
	//WCHAR szAccountName[]=L"middleeast\\v-ofiry";
	//WCHAR pwszDomainController[]=L"middleeast";


	BYTE abSidBuff[128];
    PSID pSid = (PSID)abSidBuff;
    DWORD dwSidBuffSize = sizeof(abSidBuff);
    WCHAR szRefDomain[128];
    DWORD dwRefDomainSize = sizeof(szRefDomain) / sizeof(WCHAR);
    SID_NAME_USE eUse;
    
	// WCHAR szTextSid[256];
    // DWORD szTextSidBuffSize = sizeof(szTextSid);


	
	if (!LookupAccountNameW( NULL,
                                wcsAccountName.c_str(),
                                pSid,
                                &dwSidBuffSize,
                                szRefDomain,
                                &dwRefDomainSize,
                                &eUse ))
        {
            MqLog("Failed in LookupAccountName(%S), error = %lut\n",
                                          wcsAccountName.c_str(), GetLastError()) ;
        }

 /* HANDLE  hToken;
  if(!OpenThreadToken(GetCurrentThread(),
	                  TOKEN_QUERY,
					  TRUE,
					  &hToken))
  {
     if(GetLastError() != ERROR_NO_TOKEN)
     {
	  
		 throw INIT_Error("could not get thread token");     
       
	 }

     if(!OpenProcessToken(GetCurrentProcess(),
	                     TOKEN_QUERY,
					      &hToken))
	 {
	   
		 throw INIT_Error("could not get thread token");     
       
     }
  }
  Handle_t Token(hToken);
  DWORD cbBuf=0; 	  
  BOOL b=GetTokenInformation(hToken,
	                  TokenUser,
					  NULL,
					  0,
					  &cbBuf);

  assert(b == 0);

  SPTR<BYTE> rgbTokenUserSid(new(BYTE[cbBuf]));
  b=GetTokenInformation(Token.get(),
                        TokenUser,
  			            rgbTokenUserSid.get(),
					    cbBuf,
					    &cbBuf);
  


  if(b == FALSE)
  {
	   throw INIT_Error("could not token information");   
  }
*/
//  TOKEN_USER* ptokenuser=reinterpret_cast<TOKEN_USER*>(rgbTokenUserSid.get());
  //PSID sid = ptokenuser->User.Sid;

  if(IsValidSid(pSid) == FALSE)
  {
	throw INIT_Error("sid is invalid");
  }
  
	
  DWORD sidlen=GetLengthSid(pSid);
  std::basic_string <unsigned char> retsid(reinterpret_cast<unsigned char*>(pSid),sidlen); 
  return retsid;
}


inline void UnloadHiveForSid(const std::basic_string<unsigned char>& sid)
{
   std::string textsid=GetTextualSid((void*)sid.c_str());
   RegUnLoadKey(HKEY_USERS, textsid.c_str());    
   SetSpecificPrivilegeInThreadAccessToken(SE_RESTORE_NAME, FALSE);
}

inline void LoadHiveForSid(const std::basic_string<unsigned char>& sid)
{
  std::string textsid=GetTextualSid((void*)sid.c_str());
  HKEY hProf;

  //
  // Remark if user never do logon on that machine this key doesn't exist
  // need to Logon as user before run this tests !!
  //
  std::string reg="Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\"+textsid;
  HRESULT hr=RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		                  reg.c_str(),
				          0,
				          KEY_QUERY_VALUE,
				          &hProf);

  if(hr != ERROR_SUCCESS)
  {
    
	  throw INIT_Error("You try to use user that never logon on that machine  \n");
  }
  
  DWORD dwType;
  DWORD dwProfileImagePathBuffSize=0;
  hr=RegQueryValueExA(hProf,
	                 "ProfileImagePath",
					 0,
					 &dwType,
					 NULL,
					 &dwProfileImagePathBuffSize);

  SPTR<unsigned char> szProfileImagePath( new unsigned char[dwProfileImagePathBuffSize]);

  hr=RegQueryValueExA(hProf,
	                 "ProfileImagePath",
					 0,
					 &dwType,
					 szProfileImagePath.get(),
					 &dwProfileImagePathBuffSize);

  if(hr != ERROR_SUCCESS)
  {
    RegCloseKey(hProf);
    throw INIT_Error("");
  }
  RegCloseKey(hProf);

  char szExpandProfileImagePath[MAX_PATH];
  if(!ExpandEnvironmentStringsA((char*)szProfileImagePath.get(),
	                         szExpandProfileImagePath,
						     sizeof(szExpandProfileImagePath)))

  {
    throw INIT_Error("");
  }
  
  std::string StrszExpandProfileImagePath=szExpandProfileImagePath+std::string("\\NTUSER.DAT");

  SetSpecificPrivilegeInThreadAccessToken(SE_RESTORE_NAME, TRUE);

  hr=RegLoadKeyA(HKEY_USERS,
	            textsid.c_str(),
				StrszExpandProfileImagePath.c_str());


  if(hr != ERROR_SUCCESS)
  {
     throw INIT_Error("");
  }
 
 SetSpecificPrivilegeInThreadAccessToken(SE_RESTORE_NAME, FALSE);
                                   

  hr=RegCloseKey(HKEY_CURRENT_USER);     
  
}

inline std::basic_string<unsigned char> GetSidFromUser(const std::string& username)
{

  
  SPTR<unsigned char> sid(NULL);
  DWORD cbSid=0;
  SPTR<unsigned char> ReferencedDomainName(NULL);
  SID_NAME_USE eUse ;
  DWORD cbReferencedDomainName=0;
  BOOL b=LookupAccountName(NULL,
	                     username.c_str(),
                         sid.get(),
                         &cbSid,
						 reinterpret_cast<char*>(ReferencedDomainName.get()),
                         &cbReferencedDomainName, 
                         &eUse);
                         


 
						 
 
 sid = SPTR<unsigned char>(new(unsigned char[cbSid]));

 

 ReferencedDomainName = SPTR<unsigned char>(new(unsigned char[cbReferencedDomainName]));



 b=LookupAccountName(NULL,
                     username.c_str(),
                     sid.get(),
                     &cbSid,
 				     reinterpret_cast<char*>(ReferencedDomainName.get()),
                     &cbReferencedDomainName, 
                     &eUse);
                         
 
 
  if(b == FALSE)
  {
    throw INIT_Error("");    
  }
  
 

  std::basic_string<unsigned char> ret(sid.get(),cbSid);

  return ret;


}


//unload current thread hive
inline void UnloadHiveForUser(const std::string & username)
{
   std::basic_string<unsigned char> sid=GetSidFromUser(username);
   UnloadHiveForSid(sid);
}

//unload current thread hive
inline void UnlLoadCurrentThreadHive( std::wstring wcsAccountName )
{
   std::basic_string<unsigned char> sid=GetCurrentThreadSid(wcsAccountName);

   //
   //  Bubgug - There is NT5 bug Need to Unloadhive after using it ..
   //
   //
  // UnloadHiveForSid(sid);
  
}

//class that load current thread hive and unload it in the destructor
class LoadCurrentThreadHive_t
{

public:
	LoadCurrentThreadHive_t( wstring & szAccoutName)
	{
	  m_szAccountName = szAccoutName;
      LoadCurrentThreadHive( m_szAccountName );
    } 
    virtual ~LoadCurrentThreadHive_t()
    {
      UnlLoadCurrentThreadHive(m_szAccountName);
    }
private:
	std::wstring m_szAccountName;

}; 

//return user name string for given user SID
inline std::string UserNameFromSid(PSID  sid)
{
  LPCTSTR lpSystemName=NULL;
  SPTR<char> Name(NULL);
  DWORD cbName=0;
  SPTR<char> ReferencedDomainName(NULL);
  DWORD cbReferencedDomainName=0;
  SID_NAME_USE peUse;
  
  BOOL b= LookupAccountSid(lpSystemName, // address of string for system name
                           sid,             // address of security identifier
                           Name.get(),          // address of string for account name
                           &cbName,       // address of size account string
                           ReferencedDomainName.get(),                // address of string for referenced domain
                           &cbReferencedDomainName, // address of size domain string
                           &peUse);// address of structure for SID type);



  Name=SPTR<char>(new(char[cbName])); 
  ReferencedDomainName=SPTR<char>(new(char[cbReferencedDomainName])); 


   b= LookupAccountSidA(lpSystemName, // address of string for system name
                           sid,             // address of security identifier
                           Name.get(),          // address of string for account name
                           &cbName,       // address of size account string
                           ReferencedDomainName.get(),                // address of string for referenced domain
                           &cbReferencedDomainName, // address of size domain string
                           &peUse);// address of structure for SID type);

  if(b == FALSE)
  {
     throw INIT_Error("");
  }

  std::string ret=std::string(ReferencedDomainName.get())+ "\\" + Name.get();

  return ret;
}

//
// This function return thread Security context 
// Needs to do impersonate as user before preform 
// MQGetSecuritycontext
// 
HANDLE FAL_GetThreadSecurityContext(Impersonate_t  & user, wstring & szAccoutName)
{
   LoadCurrentThreadHive_t hive (szAccoutName);
   HANDLE hSec;
   user.ImpersonateUser();
   
   HRESULT hr=MQGetSecurityContext(NULL,0,&hSec);
   if (hr != MQ_OK)
   {
	    throw INIT_Error("Can't Retrive the computer name");
   }

   hr=RegCloseKey(HKEY_CURRENT_USER);
   
   if(hr != ERROR_SUCCESS)
   {
    throw INIT_Error("");
   }

  return hSec;
}



//return textual string for given sid
inline std::string GetTextualSid(PSID pSid)
{
  if(!IsValidSid(pSid))
  {
    throw INIT_Error("");
  }
  PSID_IDENTIFIER_AUTHORITY psia=GetSidIdentifierAuthority(pSid);
  if(psia == NULL)
  {
    throw INIT_Error("");
  }

  DWORD dwSubAuthorities=*GetSidSubAuthorityCount(pSid);
  DWORD dwSidRev=SID_REVISION;

  std::stringstream TextualSid;
  TextualSid<<"S-"<<dwSidRev<<"-";

  if( (psia->Value[0] !=0) ||(psia->Value[1] != 0))
  {
	 TextualSid.width(2);
	 TextualSid<<std::hex<<psia->Value[0]<<psia->Value[1]<<psia->Value[2]<<psia->Value[3]<<psia->Value[4]<<psia->Value[5];	  
  }
  else
  {
	  TextualSid<<std::dec<<(psia->Value[5])+(psia->Value[4]<<8)+(psia->Value[3]<<16)+(psia->Value[2]<<24);
  }
  for(DWORD i=0;i<dwSubAuthorities;i++)
  {
    TextualSid<<std::dec<<"-"<<*GetSidSubAuthority(pSid,i);
  }

  return TextualSid.str();
}

inline
void
SetSpecificPrivilegeInThreadAccessToken(LPCTSTR lpwcsPrivType, BOOL bEnabled)
{

    HANDLE hAccessToken;
    BOOL bRet=OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES, TRUE, &hAccessToken);
	if(bRet == FALSE)
    {
       bRet=OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hAccessToken);
	   if(bRet == FALSE)
	   {
         throw INIT_Error("");
	   }
    }
	SetSpecificPrivilegeInAccessToken(hAccessToken, lpwcsPrivType, bEnabled);
	CloseHandle(hAccessToken);
    if (bRet == FALSE)
    {
       throw INIT_Error("");
    }
}

//+-------------------------------------------------------------------
//
// Function:
//      SetSpecificPrivilegeInAccessToken.
//
// Description:
//      Enable/Disable a security privilege in the access token.
//
// Parameters:
//      hAccessToken - the access token on which the function should operate.
//          The toekn should be opened with the TOKEN_ADJUST_PRIVILEGES flag.
//      lpwcsPrivType - the privilege type.
//      bEnabled - Indicates whether the privilige should be enabled or
//          disabled.
//
//+-------------------------------------------------------------------
inline
void
SetSpecificPrivilegeInAccessToken( HANDLE  hAccessToken,
                                   LPCTSTR lpwcsPrivType,
                                   BOOL    bEnabled )
{
    LUID             luidPrivilegeLUID;
    TOKEN_PRIVILEGES tpTokenPrivilege;

    if (!LookupPrivilegeValue(NULL,
                              lpwcsPrivType,
                              &luidPrivilegeLUID))
    {
        throw INIT_Error("");
    }


    tpTokenPrivilege.PrivilegeCount = 1;
    tpTokenPrivilege.Privileges[0].Luid = luidPrivilegeLUID;
    tpTokenPrivilege.Privileges[0].Attributes = bEnabled?SE_PRIVILEGE_ENABLED:0;
    if(! AdjustTokenPrivileges (hAccessToken,
                                  FALSE,  // Do not disable all
                                  &tpTokenPrivilege,
                                  sizeof(TOKEN_PRIVILEGES),
                                  NULL,   // Ignore previous info
                                  NULL))

    {
         throw INIT_Error("");
    }
								  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\init.cpp ===
/*

  	//
	// bugbug - place this code in separate cpp for re-use
	//


This is the MQBvt setup stage in this stage all the queue create before the tests
This creates to solve replication delay for the tests.
There is two ways to run the BVT
1. Work with static queue ( queue create before the tests ).
2. Create the queue during the tests, ( Need to Sleep Before use this tests ).

Written by :Eitank @ Microsoft.com

*/
#include "msmqbvt.h"

#define MAX_MACH_NAME_LEN (100)
#define Configuration_Detect (7)
#define Configuration_Detect_Failed (8)
#define Configuration_Detect_Warning (9)
#define MAX_RANDOM_CHAR		(10)

#include <svcguid.h>
#include "mqf.h"
#include <_mqreg.h>
#include <_mqini.h>
#include <wincrypt.h>
#include "errorh.h"
#include "Randstr.h"

#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include <atlimpl.cpp>

#include <comdef.h>
using namespace std;

extern BOOL g_bRunOnWhistler;
extern bool g_bRemoteWorkgroup ;
void PreTestPreparation(cBvtUtil & CurrentTest, SetupType eSetupType );
std::string InitpGetAnonymousUserName ();
std::string InitpGetAllWorldUserName (); 
HRESULT EnableDCOM();

class cQueueProp
{
	public:
			cQueueProp ():m_wcsFormatName (g_wcsEmptyString),m_wcsPathName(g_wcsEmptyString),
				m_wcsQueueLabel(g_wcsEmptyString),m_wcsMultiCastAddress(g_wcsEmptyString) {};

			cQueueProp (const cQueueProp & cObject);

			cQueueProp (wstring wcsPathname,wstring Qlabel):
				m_wcsFormatName (wcsPathname),m_wcsPathName(Qlabel),m_wcsQueueLabel(L"") {};

			void SetProp (wstring wcsPathname,wstring Qlabel,ULONG ulFlag,wstring wcsMutliCast = g_wcsEmptyString );
			virtual ~cQueueProp () {};

			void SetFormatName(WCHAR * wcsFormatName) { m_wcsFormatName=wcsFormatName; }
			const wstring getFormatName() {return m_wcsFormatName;  }
			const wstring getQLabel() { return  m_wcsQueueLabel; }
			const wstring getPathName () { return m_wcsPathName; }

			INT CreateQ (bool bTryToCreate , SetupType eSetupType , cBvtUtil & cTestParms );
			friend 	HRESULT APIENTRY  MQCreateQueue( IN PSECURITY_DESCRIPTOR , IN OUT MQQUEUEPROPS* ,OUT LPWSTR ,
					IN OUT LPDWORD lpdwFormatNameLength);
   private: 
	 wstring m_wcsFormatName;
	 wstring m_wcsPathName;
	 wstring m_wcsQueueLabel;
	 wstring m_wcsMultiCastAddress;
	 ULONG ulQCreateFalgs;
};

HRESULT SetMulticastAddress ( WCHAR * wcsFormatName, const WCHAR * wcsMulticastAddress )
/*++
	Function Description:
		SetMulticastAddress
	Arguments:
		wcsFormatName queue format name
		wcsMulticastAddress multicast address.
	Return code:
		HRESULT
--*/
{
		int iProps = 0;
		QUEUEPROPID QPid[1]={0};
		MQPROPVARIANT QPVar[1]={0};
		HRESULT hQStat[1]={0};
		MQQUEUEPROPS QProps;
	
		QPid [0] = PROPID_Q_MULTICAST_ADDRESS;
		QPVar[0].vt = VT_LPWSTR;
		QPVar[0].pwszVal = const_cast <WCHAR *>(wcsMulticastAddress);
		iProps = 1;

		// modify the queue
		QProps.cProp = iProps;
		QProps.aPropID = QPid;
		QProps.aPropVar = QPVar;
		QProps.aStatus = hQStat;

		HRESULT rc = MQSetQueueProperties( wcsFormatName,&QProps );
		if (FAILED(rc))
		{
			MqLog("MQSetQueueProperties failed to set queue multicast address error 0x%x\n",rc);
		}
		else
		{
			if(g_bDebug)
			{
				wMqLog(L"SetMulticastAddress - Set queue multicast %s \n",wcsMulticastAddress);    
			}
		}
		return rc;
}

//---------------------------------------------------------------------------
// This metod return the Evreyone string in all lang.
//

string InitpGetAllWorldUserName ()
/*++
	Function Description:
		Return string the describe all world user name dependent on the machine locale
	Arguments:
		None
	Return code:
		std::string.
--*/
{
	//
	// Create Evreyone SID
	//

	PSID   pWorldSid = NULL ;
	SID_IDENTIFIER_AUTHORITY WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
	BOOL bRet = AllocateAndInitializeSid( &WorldAuth,
                                     1,
                                     SECURITY_WORLD_RID,
                                     0,
                                     0,
                                     0,
                                     0,
                                     0,
                                     0,
                                     0,
                                     &pWorldSid );

	if ( ! bRet )
	{
		MqLog ("Can't Init everyone's SID \n ");
	}
	char csAccountName[100];
	DWORD dwAccountNamelen = 100;
	char csDomainName[100];
	DWORD dwDomainNamelen = 100;
	
	csAccountName[0] = NULL;
	SID_NAME_USE eUse;

	//
	// Ask the account name for the user SID
	//

	bRet = LookupAccountSid(NULL,pWorldSid,csAccountName,&dwAccountNamelen,csDomainName,&dwDomainNamelen,&eUse);
	if (! bRet )
	{
		MqLog ("Can't get everyone's account name\n");
	}
	
	FreeSid (pWorldSid);
	
		
	if ( csDomainName)
		return csAccountName;
	else
		return "Everyone";
}



string InitpGetAnonymousUserName ()
/*++
	Function Description:
		Return string the describe Anonymous user name dependent on the machine locale
	Arguments:
		None
	Return code:
		std::string.
--*/
{
	//
	// Create AnonyMouse SID
	//
	BOOL bRet = TRUE;
	PSID pAnonymSid = NULL ;
    SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;
    //
    // Anonymous logon SID.
    //
    bRet = AllocateAndInitializeSid( &NtAuth,
                                     1,
                                     SECURITY_ANONYMOUS_LOGON_RID,
                                     0,
                                     0,
                                     0,
                                     0,
                                     0,
                                     0,
                                     0,
                                     &pAnonymSid );

	if ( ! bRet )
	{
		MqLog ("Can't Init Anonymous SID \n ");
		return "";
	}
	char csAccountName[100];
	DWORD dwAccountNamelen = 100;
	char csDomainName[100];
	DWORD dwDomainNamelen = 100;
	
	csAccountName[0] = NULL;
	SID_NAME_USE eUse;

	//
	// Retrive the account name for the user SID
	//
	bRet = LookupAccountSid(NULL,pAnonymSid,csAccountName,&dwAccountNamelen,csDomainName,&dwDomainNamelen,&eUse);
	if (! bRet )
	{
		MqLog ("Can't get Anonymous account name\n");
		FreeSid (pAnonymSid);
		return "";
	}
	
	FreeSid (pAnonymSid);
	
		
	if ( csDomainName )
		return csAccountName;
	else
		return "ANONYMOUS LOGON";
}




//---------------------------------------------------------------------------
// cPropVar::ReturnMSGValue
//
// This method locates a value in the property structure
// of a received message
//
// For integer and char values, the value is returned through the OUT arument,
// else the vlaue is already in the outside buffer.
//
// The method returns success if it finds the property,
// else it returns fail.
//
int cPropVar::ReturnMSGValue ( QUEUEPROPID cPropID ,VARTYPE MQvt  ,/*OUT*/void  * pValue )
{
	 INT iPlace = -1 ;
	 for (INT iIndex=0 ; iIndex < iNumberOfProp && iPlace == -1  ; iIndex ++)
	 {
		if ( pQueuePropID[iIndex] == cPropID )
			iPlace = iIndex;
	 }

	 if ( iPlace != -1 )
	 {
		 switch (MQvt)
		 {
		   case VT_UI1: {
							* (UCHAR * ) pValue = pPropVariant[ iPlace ].bVal;
						}
						break;

  		  case VT_UI2:	{
							
							*( (USHORT * ) pValue) = pPropVariant[ iPlace ].uiVal;
						}
						break;

		case VT_UI4:	{
							* (ULONG * ) pValue = pPropVariant[ iPlace ].ulVal;
						}
						break;
		case VT_UI8:	{
							* (ULONGLONG * ) pValue = pPropVariant[ iPlace ].hVal.QuadPart;
						}
						break;
		default:
			pValue = NULL;
		
		 };
	 }
	 return ( iPlace != -1 ) ? MSMQ_BVT_SUCC:MSMQ_BVT_FAILED;
}

//
// cPropVar::ReturnOneProp
//
// This method locates and returns a MQPROPVARIANT property structure
// of a received message.
//
// The method returns and empty structure if it doesn't find
// the desired propid.
//
MQPROPVARIANT cPropVar::ReturnOneProp( QUEUEPROPID aPropID)
{

	 INT ifound = -1 ;
	 for (INT iIndex=0 ; iIndex < iNumberOfProp && ifound == -1  ; iIndex ++)
	 {
		if ( pQueuePropID[iIndex] == aPropID)
			ifound = iIndex;
	 }

	 if (ifound != -1 )
		return pPropVariant[ifound];

	 //
	 // propid not found
	 //
	 MQPROPVARIANT Empty;
	 Empty.vt=VT_EMPTY;
	 return Empty;

}

//
// Create uuid for queue pathname, solve the duplicate path name
// Input value:
// wcsQueuePathname - string to init with guid
// GUID type - 0 / 1 / 2 Type of guid
// QType - False - Public.
//         TRUE - Private.
//

INT ReturnGuidFormatName( std::wstring & wcsQueuePath , INT GuidType , BOOL bWithOutLocalString )
{

	// Acoring to stl bug
	wstring wcsQueuePathName;
	if (  GuidType == 0  )
	{
		wcsQueuePathName = L".\\";
	}
	else if (  GuidType == 1  )
	{
		wcsQueuePathName = L".\\private$\\";
	}
	else if (  GuidType == 2  )
	{
	 	wcsQueuePathName = L"";
	}
	
	GUID GuidName={0};
	unsigned char* csName= NULL;
	if ( UuidCreate(&GuidName) !=  RPC_S_OK )
	{
		MqLog("ReturnGuidFormatName - failed to create guid \n");
		return MSMQ_BVT_FAILED;
	}
	RPC_STATUS  hr = UuidToString(&GuidName,&csName);
	if(hr != RPC_S_OK )
	{
		MqLog("ReturnGuidFormatName - UuidToString failed to covert guid to string return empty string \n");
		return MSMQ_BVT_FAILED;
	}

	wstring wcsTempString;
	wcsTempString =  My_mbToWideChar ((char *) csName );
	
	if ( ! bWithOutLocalString )
	{
		DWORD lcid = LocalSystemID ();
		WCHAR wcsTemp[MAX_RANDOM_CHAR + 2];
		wstring  wcsTemp1 = L"{";
		int iBuffer = MAX_RANDOM_CHAR;
		
		if (GetRandomStringUsingSystemLocale (lcid, wcsTemp , iBuffer ))
		{
			wcsTemp1 += wcsTemp;
		}
		wcsTemp1 += L"}";
		wcsTempString += wcsTemp1;
	}

	wcsQueuePathName += wcsTempString;
	RpcStringFree(&csName);
	wcsQueuePath = wcsQueuePathName;
return MSMQ_BVT_SUCC;
}

//
// cQueueProp::CreateQ
//
// This method create the queues for all the BVT tests
// -- or just retrieve the format name if they already exist.
//
INT cQueueProp::CreateQ (bool bTryToCreate ,SetupType eSetupType ,cBvtUtil & cTestParms )
{
	cPropVar MyPropVar(5);
	HRESULT rc=MQ_OK;
	WCHAR wcsFormatName [BVT_MAX_FORMATNAME_LENGTH];
	ULONG ulFormatNameLength = BVT_MAX_FORMATNAME_LENGTH ;
	UCHAR Flag=0;
	MQPROPVARIANT vrPathName;
	string csAllWorldAccountName="";
	string csAnonymousAccountName="";;
	MyPropVar.AddProp (PROPID_Q_PATHNAME,VT_LPWSTR,m_wcsPathName.c_str());
	MyPropVar.AddProp (PROPID_Q_LABEL,VT_LPWSTR,m_wcsQueueLabel.c_str());
	bool bNeedToSetMulticastAddress = false;
	if (ulQCreateFalgs == CREATEQ_TRANSACTION )
	{
		Flag=MQ_TRANSACTIONAL;
		MyPropVar.AddProp (PROPID_Q_TRANSACTION,VT_UI1,&Flag);
	}
	else if (ulQCreateFalgs == CREATEQ_AUTHENTICATE )
	{
		Flag=MQ_AUTHENTICATE;
		MyPropVar.AddProp (PROPID_Q_AUTHENTICATE,VT_UI1,&Flag);
	}

	else if (ulQCreateFalgs == CREATEQ_PRIV_LEVEL )
	{
		ULONG ulFlag=MQ_PRIV_LEVEL_BODY;
		MyPropVar.AddProp (PROPID_Q_PRIV_LEVEL,VT_UI4,&ulFlag);
	}
	else if (ulQCreateFalgs == CREATEQ_QUOTA )
	{
		ULONG ulFlag=30;
		MyPropVar.AddProp (PROPID_Q_QUOTA,VT_UI4,&ulFlag);
	}
	else if( wcsstr(m_wcsMultiCastAddress.c_str(),L":") != NULL && g_bRunOnWhistler && ulQCreateFalgs == MULTICAST_ADDRESS )
	{
		MyPropVar.AddProp(PROPID_Q_MULTICAST_ADDRESS,VT_LPWSTR,m_wcsMultiCastAddress.c_str());
		bNeedToSetMulticastAddress = true;
	}

	//
	// All queues receive the same type GUID
	//
// 	BSTR AllQueueType = _bstr_t("{00000000-1111-2222-3333-444444444444}");
//	MyPropVar.AddProp (PROPID_Q_TYPE,VT_CLSID,& AllQueueType );

	//
	// Create Security descriptor.
	//
	
	PSECURITY_DESCRIPTOR pSecurityDescriptor=NULL;
	CSecurityDescriptor cSD;

	
	if ( eSetupType == ONLYSetup )
	{
		csAllWorldAccountName = InitpGetAllWorldUserName ();
		csAnonymousAccountName = InitpGetAnonymousUserName ();
		cSD.InitializeFromProcessToken();
		if (ulQCreateFalgs == CREATEQ_DENYEVERYONE_SEND )
		{
			rc = cSD.Allow(csAllWorldAccountName.c_str(), MQSEC_QUEUE_GENERIC_ALL);
			if (rc != S_OK)
			{
				 throw INIT_Error("Createq - Can't create SecurityDescriptor ");
			}
			rc = cSD.Allow(csAnonymousAccountName.c_str(),MQSEC_QUEUE_GENERIC_ALL);
			if (rc != S_OK)
			{
				 throw INIT_Error("Createq - Can't create SecurityDescriptor ");
			}
			rc = cSD.Deny(csAllWorldAccountName.c_str(), MQSEC_WRITE_MESSAGE);
			rc = cSD.Deny(csAnonymousAccountName.c_str(), MQSEC_WRITE_MESSAGE);

		}
		else
		{
			rc = cSD.Allow(csAllWorldAccountName.c_str(), MQSEC_QUEUE_GENERIC_ALL);
			if (rc != S_OK)
			{
				 throw INIT_Error("Createq - Can't create SecurityDescriptor ");
			}
			rc = cSD.Allow(csAnonymousAccountName.c_str(),MQSEC_QUEUE_GENERIC_ALL);
			if (rc != S_OK)
			{
				 throw INIT_Error("Createq - Can't create SecurityDescriptor ");
			}
		}		
		
		if (rc != S_OK)
		{
			 throw INIT_Error("Createq - Can't create SecurityDescriptor ");
		}
		pSecurityDescriptor = cSD.m_pSD;
	}
		

	//
	// Create the queue
	//
	vrPathName = MyPropVar.ReturnOneProp (PROPID_Q_PATHNAME);
	bool bApiType = TRUE;
	if ( bTryToCreate )
	{
		rc=MQCreateQueue(pSecurityDescriptor,MyPropVar.GetMQPROPVARIANT() , wcsFormatName , &ulFormatNameLength );
		if( rc == MQ_ERROR_QUEUE_EXISTS )
		{
			//
			// This will fix the problem when user run -I without -multicast and he want to set the multicast address
			//
			rc = MQPathNameToFormatName ( vrPathName.pwszVal, wcsFormatName , & ulFormatNameLength);
			if(FAILED(rc))
			{
				MqLog("MQPathNameToFormatName failed for queue that already exists\n");
				throw INIT_Error("MQPathNameToFormatName failed \n");
			}
			
			if (bNeedToSetMulticastAddress && SetMulticastAddress(wcsFormatName,m_wcsMultiCastAddress.c_str()) != MQ_OK )
			{
				wMqLog(L"Please check if user can set queue props on queue %s\n",vrPathName.pwszVal);
			}
		}
	}
	else
	{
		
		bApiType = FALSE;
		if (vrPathName.vt )
		{
			if ( cTestParms.m_eMSMQConf != WKG )
			{
				rc = MQPathNameToFormatName ( vrPathName.pwszVal, wcsFormatName , & ulFormatNameLength);
			
			}
			else
			{
				if ( ulFormatNameLength >= ( wcslen (L"Direct=os:")+  wcslen (vrPathName.pwszVal) + 1 ))
				{
					wcscpy( wcsFormatName , L"DIRECT=os:" );
					wcscat( wcsFormatName , vrPathName.pwszVal);
					rc = MQ_OK;
				}
				else
				{	
					// Buffer to small need to relocate new buffer
					rc = MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL;
				}
					
			}
			
		}
	}

	if ( rc == MQ_OK || rc == MQ_ERROR_QUEUE_EXISTS )
	{
		m_wcsFormatName = wcsFormatName;
	}
	else // rc != MQ_OK
	{

		wstring wcstemp = bTryToCreate ? L"MQCreateQueue" : L"MQPathNameToFormatName";
		
		
		wMqLog(L"%s failed with error:0x%x\n", wcstemp.c_str() , rc);
		MQPROPVARIANT vrQueueLabel = MyPropVar.ReturnOneProp (PROPID_Q_LABEL);
		wMqLog(L"With queue label: %s\n",vrQueueLabel.pwszVal );
		//
		// Print machine name from the tests
		//
		vrPathName = MyPropVar.ReturnOneProp (PROPID_Q_PATHNAME);
		if( vrPathName.pwszVal == NULL )
		{
			throw INIT_Error( "Init Stage : Can't create or update queue parameters.\n");
		}
		wstring csQueueName = vrPathName.pwszVal;
		wstring Token=L"\\";
		size_t iPos = csQueueName.find_first_of ( Token );	
		wstring csMachineName = csQueueName.substr(0,iPos);
		wMqLog(L"Can't create / refresh queue path name: %s\n",vrPathName.pwszVal);
		wMqLog(L"On machine: %s\n",csMachineName.c_str());
		throw INIT_Error( "Init Stage : Can't create or update queue parameters.\n");
	}
	return MSMQ_BVT_SUCC; // error handle in
}

//---------------------------------------------------------------------------
// Init cQueueProp with PathName , Qlabel , ulFalg
//

void cQueueProp::SetProp(wstring wcsPathname,wstring wcsQlabel,ULONG ulFlag,wstring wcsMultiCastAddress)
{
	m_wcsQueueLabel=wcsQlabel;
	m_wcsPathName=wcsPathname;
	
	if( wcsMultiCastAddress != g_wcsEmptyString )
	{
		m_wcsMultiCastAddress = wcsMultiCastAddress + PGM_PORT;
	}

	ulQCreateFalgs = ulFlag;
}

////---------------------------------------------------------------------------
// Create everyone security descriptor
//

CSecurityDescriptor* CreateFullControllSecDesc()
{
	CSecurityDescriptor *  pcSD = new CSecurityDescriptor();
	HRESULT rc=MQ_OK;
	string csAllWorldAccountName = InitpGetAllWorldUserName ();
	string csAnonymousAccountName = InitpGetAnonymousUserName ();
	pcSD->InitializeFromProcessToken();
	rc = pcSD->Allow(csAllWorldAccountName.c_str(), MQSEC_QUEUE_GENERIC_ALL);
	if (rc != S_OK)
	{
		 throw INIT_Error("Createq - Can't create SecurityDescriptor ");
	}
	rc = pcSD->Allow(csAnonymousAccountName.c_str(),MQSEC_QUEUE_GENERIC_ALL);
	if (rc != S_OK)
	{
		 throw INIT_Error("Createq - Can't create SecurityDescriptor ");
	}
	return pcSD;
}
////---------------------------------------------------------------------------
// Copy constructor
//


cQueueProp::cQueueProp(const cQueueProp & cObject)
{

	m_wcsFormatName=cObject.m_wcsFormatName;
	m_wcsPathName=cObject.m_wcsPathName;
	m_wcsQueueLabel=cObject.m_wcsQueueLabel;
	ulQCreateFalgs = cObject.ulQCreateFalgs;

}

void my_Qinfo::PutFormatName (std::wstring wcsFormatName )
{
   wcsQFormatName = wcsFormatName;
}


//---------------------------------------------------------------------------
// This function preform the setup process - Create all queues
// Those Queues:
// 1. Private Queue Defualt Security Descriptor
// 2. Private Admin Q
// 3. BVT Log State Q
// 4. Private Transaction Q
// 5. Public authenticate Q
// 6. Public Privacy level Q
// 7. Public Trans  Q
//
//10.Public support
//11.
//12.
//
//


//
// cMQSetupStage
//
// This routine
//
// Parameters;
//	CurrentTest - pointer to configuration information
//	eSetupType	- see Setup stage comment
//
// INT cMQSetupStage (wstring pwcsLocalComputerName , cBvtUtil & CurrentTest , SetupType eSetupType )


INT cMQSetupStage ( SetupType eSetupType ,  cBvtUtil & CurrentTest  )
{
	//
	// Create queue info structure for the BVT queues
	//
	const int NumberOfqueue = 32;
	vector<cQueueProp> AllQueues(NumberOfqueue);
	vector<cQueueProp>::iterator itpCurrentObject=AllQueues.begin();

	wstring wcsBasePrivateQPath = CurrentTest.m_wcsCurrentLocalMachine + L"\\Private$\\" + CurrentTest.m_wcsCurrentLocalMachine;
	wstring wcsBasePublicQPath;

	wcsBasePublicQPath = CurrentTest.m_wcsCurrentLocalMachine + L"\\" + CurrentTest.m_wcsCurrentLocalMachine;
	wstring wcPathName,wcsQLabel;

	int iNumberOfQueue =0;

	//
	// Register certificate before use the setup.
	//
	// NT5 Only & ! Local user || workgroup computer.
	//
	// Remove this code no need to register certificate
	
	if( _winmajor >= Win2K &&  ( CurrentTest.m_eMSMQConf !=  LocalU ) && ( CurrentTest.m_eMSMQConf !=  WKG )
		&& ( CurrentTest.m_eMSMQConf != DepClientLocalU))
	{
		HRESULT hr = CheckCertificate (MQCERT_REGISTER_IF_NOT_EXIST);
		if( hr != MQ_INFORMATION_INTERNAL_USER_CERT_EXIST )
		{
			MqLog("Warning - MQRegisterCertificate return 0x%x expected 0x%x\n",hr,MQ_INFORMATION_INTERNAL_USER_CERT_EXIST);
		}
	}
    
	/*if( CurrentTest.m_eMSMQConf != DepClientLocalU && g_bRunOnWhistler == TRUE )
	{
		EnableDCOM();
	}*/

	//
	// Prepare queues
	//

	if ( eSetupType == RunTimeSetup )
	{
		ReturnGuidFormatName (wcPathName , 1 ,CurrentTest.bWin95 );
	}
	else
	{
		wcPathName= CurrentTest.m_wcsCurrentLocalMachine + L"\\Private$\\" + L"Private-MQBVT";
	}


	wcsQLabel=L"Defualt PrivateQ";
	itpCurrentObject->SetProp( wcPathName ,wcsQLabel,NULL);

	itpCurrentObject++;
	iNumberOfQueue++;

	if( eSetupType == RunTimeSetup )
	{
		ReturnGuidFormatName (wcPathName , 1 , CurrentTest.bWin95);
	}
	else
	{
		wcPathName=wcsBasePrivateQPath + L"-Private-AdminQ";
	}
	
	wcsQLabel=L"Private Admin Q";
	//itpCurrentObject->SetProp( wcPathName ,wcsQLabel,MULTICAST_ADDRESS,CurrentTest.GetMultiCastAddress());
	itpCurrentObject->SetProp(wcPathName,wcsQLabel,NULL);
	itpCurrentObject++;
	iNumberOfQueue++;

	wcPathName= g_cwcsDebugQueuePathName;
	itpCurrentObject->SetProp( wcPathName , L"PeekPeekPeek" , CREATEQ_QUOTA);
	itpCurrentObject++;
	iNumberOfQueue++;
	

	if ( eSetupType != RunTimeSetup )
	{
		wcPathName= L".\\PRIVATE$\\-PeekMe-PeekMe-Remotly";
		itpCurrentObject->SetProp( wcPathName , L"PeekPeekPeek" , CREATEQ_QUOTA);
		itpCurrentObject++;
		iNumberOfQueue++;
	}



	if( eSetupType == RunTimeSetup )
	{
		ReturnGuidFormatName (wcPathName , 1 ,CurrentTest.bWin95 );
	}
	else
	{
		wcPathName=wcsBasePrivateQPath + L"-StateInfo";
	}

	wcsQLabel=L"MSMQ-BVT-State";
	itpCurrentObject->SetProp( wcPathName ,wcsQLabel,NULL);
	itpCurrentObject++;
	iNumberOfQueue++;


	if( eSetupType == RunTimeSetup )
	{
		ReturnGuidFormatName (wcPathName , 1 ,CurrentTest.bWin95 );
	}
	else
	{
		if ( eSetupType == ONLYUpdate && CurrentTest.m_eMSMQConf == WKG )
		{
			wcPathName = CurrentTest.m_wcsCurrentRemoteMachine + L"\\private$\\" + CurrentTest.m_wcsCurrentRemoteMachine +  L"-PrivateTrans";
		}
		else
		{
			wcPathName =wcsBasePrivateQPath + L"-PrivateTrans";
		}
		
	}

	wcsQLabel=L"Private Transaction";
	itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_TRANSACTION);
	itpCurrentObject++;
	iNumberOfQueue++;


	if ( eSetupType == RunTimeSetup )
	{
		ReturnGuidFormatName (wcPathName , 1 ,CurrentTest.bWin95 );
	}
	else
	{
		wcPathName=wcsBasePrivateQPath + L"-" + g_cwcsDlSupportCommonQueueName + L"1";
	}
	wcsQLabel= L"MQCast1";
	itpCurrentObject->SetProp( wcPathName ,wcsQLabel ,MULTICAST_ADDRESS,CurrentTest.GetMultiCastAddress());
	itpCurrentObject++;
	iNumberOfQueue++;

	if ( eSetupType == RunTimeSetup )
	{
		ReturnGuidFormatName (wcPathName , 1 ,CurrentTest.bWin95 );
	}
	else
	{
		wcPathName=wcsBasePrivateQPath + L"-" + g_cwcsDlSupportCommonQueueName + L"2";
	}

  	wcsQLabel= L"MQCast2";
	itpCurrentObject->SetProp( wcPathName ,wcsQLabel ,MULTICAST_ADDRESS,CurrentTest.GetMultiCastAddress());
	itpCurrentObject++;
	iNumberOfQueue++;


	if ( eSetupType == RunTimeSetup )
	{
		ReturnGuidFormatName (wcPathName , 1 ,CurrentTest.bWin95 );
	}
	else
	{
		wcPathName=wcsBasePrivateQPath + L"-" + g_cwcsDlSupportCommonQueueName + L"3";
	}

  	wcsQLabel= L"MQCast3";
	itpCurrentObject->SetProp( wcPathName ,wcsQLabel ,MULTICAST_ADDRESS,CurrentTest.GetMultiCastAddress());
	itpCurrentObject++;
	iNumberOfQueue++;

	if ( eSetupType != RunTimeSetup  )
	{
		//
		// Trigger Queues
		// 
		if ( eSetupType != RunTimeSetup )
		{
			wcPathName=wcsBasePrivateQPath + L"-" + L"Mqbvt-PeekTriggerQueue";
		}
		wcsQLabel = L"PeekTrigger";
		itpCurrentObject->SetProp( wcPathName,wcsQLabel , NULL);
		itpCurrentObject++;
		iNumberOfQueue++;

		if ( eSetupType != RunTimeSetup )
		{
			wcPathName=wcsBasePrivateQPath + L"-" + L"Mqbvt-RetrievalTriggerQueue";
		}
		wcsQLabel = L"RetrievalTrigger";
		itpCurrentObject->SetProp( wcPathName,wcsQLabel , NULL);
		itpCurrentObject++;
		iNumberOfQueue++;


		if ( eSetupType != RunTimeSetup )
		{
			wcPathName=wcsBasePrivateQPath + L"-" + L"Mqbvt-TxRetrievalTriggerQueue";
		}
		wcsQLabel = L"TxRetrievalTrigger";
		itpCurrentObject->SetProp( wcPathName,wcsQLabel , CREATEQ_TRANSACTION);
		itpCurrentObject++;
		iNumberOfQueue++;

		
		if ( eSetupType != RunTimeSetup )
		{
			wcPathName=(wstring)L".\\private$\\" + L"TriggerTestQueue";
		}
		wcsQLabel = L"TriggerTest";
		itpCurrentObject->SetProp( wcPathName,wcsQLabel , NULL);
		itpCurrentObject++;
		iNumberOfQueue++;
	}

	if ( CurrentTest.m_eMSMQConf != WKG )
	{

		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName (wcPathName , 0 , CurrentTest.bWin95 );
		}
		else
		{
			wcPathName=wcsBasePublicQPath + L"-Public-MQBVT";
		}

		wcsQLabel=L"Regular PublicQ";
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,NULL);
		itpCurrentObject++;
		iNumberOfQueue++;

		//
		// This is remote queue.
		// In MSMQ2 enteprize need to create queue with full dns name.
		//

		if ( eSetupType == ONLYUpdate || eSetupType == RunTimeSetup )
		{
			if ( eSetupType != RunTimeSetup )
			{
				wcPathName= CurrentTest.m_wcsCurrentRemoteMachine + L"\\" + CurrentTest.m_wcsCurrentRemoteMachine +  L"-RemotePublic-MQBVT";
			}
			else
			{
				wstring wcsTemp;
				ReturnGuidFormatName ( wcsTemp , 0 , CurrentTest.bWin95);
				// Need to remove the
				wstring Token=L"\\";
				size_t iPos = wcsTemp.find_first_of (Token);
				wcPathName= CurrentTest.m_wcsCurrentRemoteMachine + wcsTemp.substr(iPos);
			}

			wcsQLabel=L"Remote Read Queue";
			itpCurrentObject->SetProp( wcPathName ,wcsQLabel,NULL);
			itpCurrentObject++;
			iNumberOfQueue++;
		}

		else
		{
			if ( eSetupType == RunTimeSetup )
			{
				ReturnGuidFormatName(wcPathName , 0 ,CurrentTest.bWin95);
			}
			else
			{
				wcPathName=wcsBasePublicQPath +  L"-RemotePublic-MQBVT";
			}
			wcsQLabel=L"Remote Read Queue";
			itpCurrentObject->SetProp( wcPathName ,wcsQLabel,NULL);
			itpCurrentObject++;
			iNumberOfQueue++;
			//
			// Create remote machine with Full DNS name / need to find the SP4 support this ?
			//
			if ( _winmajor >=  Win2K )
			{

				if ( eSetupType == RunTimeSetup )
				{
					ReturnGuidFormatName (wcPathName , 0 );
				}
				else
				{
					wcPathName=L".\\"+ CurrentTest.m_wcsLocalComputerNameFullDNSName +  L"-RemotePublic-MQBVT";
				}
				wcsQLabel=L"Remote Read Queue";
				itpCurrentObject->SetProp( wcPathName ,wcsQLabel,NULL);
				itpCurrentObject++;
				iNumberOfQueue++;
			}
		}
		
		//
		// Remote transaction queue.
		//

		
		if ( eSetupType != RunTimeSetup )
		{
			if ( eSetupType == ONLYUpdate )
			{
				wcPathName= CurrentTest.m_wcsCurrentRemoteMachine + L"\\" + CurrentTest.m_wcsCurrentRemoteMachine +  L"-Remote-Transaction-Queue";
			}
			else
			{
				wcPathName= CurrentTest.m_wcsCurrentLocalMachine + L"\\" + CurrentTest.m_wcsCurrentLocalMachine +  L"-Remote-Transaction-Queue";
			}
		}
		else
		{
			wstring wcsTemp;
			ReturnGuidFormatName( wcsTemp, 2 , CurrentTest.bWin95 );
			wcPathName= CurrentTest.m_wcsCurrentRemoteMachine + L"\\" + wcsTemp;
		}
		wcsQLabel=L"Remote Transaction queue";
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_TRANSACTION);
		itpCurrentObject++;
		iNumberOfQueue++;
		
		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName (wcPathName , 0 , CurrentTest.bWin95);
		}
		else
		{
			wcPathName=wcsBasePrivateQPath + L"-Trans";
		}

		wcsQLabel=L"Private Transaction";
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_TRANSACTION);
		itpCurrentObject++;
		iNumberOfQueue++;

		//
		// Remote transaction queue with FULL dns name / Only on NT5
		//	
		if( _winmajor >= Win2K )
		{
			if ( eSetupType != RunTimeSetup )
			{
				if ( eSetupType == ONLYUpdate )
				{
					wcPathName= CurrentTest.m_wcsRemoteMachineNameFullDNSName + L"\\" + CurrentTest.m_wcsRemoteMachineNameFullDNSName +  L"-Remote-Transaction-Queue";
				}
				else
				{
					wcPathName= CurrentTest.m_wcsLocalComputerNameFullDNSName + L"\\" + CurrentTest.m_wcsLocalComputerNameFullDNSName +  L"-Remote-Transaction-Queue";
				}
			}
			else
			{
				wstring wcsTemp;
				ReturnGuidFormatName( wcsTemp, 2 , CurrentTest.bWin95);
				wcPathName= CurrentTest.m_wcsCurrentRemoteMachine + L"\\" + wcsTemp;
			}

			wcsQLabel=L"Remote Transaction queue";
			itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_TRANSACTION);
			itpCurrentObject++;
			iNumberOfQueue++;
		}
		
		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName (wcPathName , 0 , CurrentTest.bWin95 );
		}
		else
		{
			wcPathName=wcsBasePrivateQPath + L"-Trans";
		}

		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName(wcPathName , 0 , CurrentTest.bWin95 );
		}
		else
		{
			wcPathName=wcsBasePublicQPath + L"-TransQ1";
		}
		

		wcsQLabel=L"TransQ1";
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_TRANSACTION);
		itpCurrentObject++;
		iNumberOfQueue++;




		if ( eSetupType == RunTimeSetup )
			ReturnGuidFormatName (wcPathName , 0 , CurrentTest.bWin95);
		else
			wcPathName=wcsBasePublicQPath + L"-TransQ2";

		wcsQLabel=L"TransQ2";
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_TRANSACTION);
		itpCurrentObject++;
		iNumberOfQueue++;


		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName (wcPathName , 0 , CurrentTest.bWin95 );
		}
		else
		{
			wcPathName=wcsBasePublicQPath + L"-Auth";
		}

		wcsQLabel=L"Authnticate Q";
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_AUTHENTICATE);
		itpCurrentObject++;
		iNumberOfQueue++;

				
		if ( eSetupType == RunTimeSetup )
		{
			//
			// PathName = RemoteMachineName + "\\" + strguid
			//
			wstring wcsTemp;
			ReturnGuidFormatName( wcsTemp, 2,CurrentTest.bWin95 );
			wcPathName= CurrentTest.m_wcsCurrentRemoteMachine + L"\\" + wcsTemp;
		}
		else
		{
				if ( eSetupType == ONLYUpdate )
				{
					wcPathName= CurrentTest.m_wcsRemoteComputerNetBiosName + L"\\" + CurrentTest.m_wcsRemoteComputerNetBiosName +  L"-Remote-Auth-Queue";
				}
				else
				{
					wcPathName= CurrentTest.m_wcsLocalComputerNetBiosName + L"\\" + CurrentTest.m_wcsLocalComputerNetBiosName +  L"-Remote-Auth-Queue";
				}
		}

		wcsQLabel=L"Remote authenticate";
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_AUTHENTICATE);
		itpCurrentObject++;
		iNumberOfQueue++;


		//
		// Local encryption queue.
		//

		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName (wcPathName , 0 , CurrentTest.bWin95);
		}
		else
		{
			wcPathName=wcsBasePublicQPath + L"-Encrypt";
		}

		wcsQLabel=L"Local encrypt";
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_PRIV_LEVEL);
		itpCurrentObject++;
		iNumberOfQueue++;


		//
		// Create encrypted queue used by remote thread - Netbios name.
		//
			
		if ( eSetupType == RunTimeSetup )
		{
			//
			// PathName = RemoteMachineName + "\\" + strguid
			//

			wstring wcsTemp;
			ReturnGuidFormatName( wcsTemp, 2 , CurrentTest.bWin95);
			wcPathName= CurrentTest.m_wcsCurrentRemoteMachine + L"\\" + wcsTemp;
		}
		else
		{
				if ( eSetupType == ONLYUpdate )
				{
					wcPathName= CurrentTest.m_wcsRemoteComputerNetBiosName + L"\\" + CurrentTest.m_wcsRemoteComputerNetBiosName +  L"-Remote-Encrypt-Queue";
				}
				else
				{
					wcPathName= CurrentTest.m_wcsLocalComputerNetBiosName + L"\\" + CurrentTest.m_wcsLocalComputerNetBiosName +  L"-Remote-Encrypt-Queue";
				}
		}

		wcsQLabel=L"privQ";
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_PRIV_LEVEL);
		itpCurrentObject++;
		iNumberOfQueue++;
/*
		//
		// Create encrypted queue used by remote thread - with full DNS name.
		//
		
		if ( eSetupType == RunTimeSetup )
		{
			//
			// PathName = RemoteMachineName + "\\" + strguid
			//

			wstring wcsTemp;
			ReturnGuidFormatName( wcsTemp, 2 , CurrentTest.bWin95 );
			wcPathName= CurrentTest.m_wcsCurrentRemoteMachine + L"\\" + wcsTemp;
		}
		else
		{
				if ( eSetupType == ONLYUpdate )
				{
					wcPathName= CurrentTest.m_wcsRemoteMachineNameFullDNSName + L"\\" + CurrentTest.m_wcsRemoteMachineNameFullDNSName +  L"-Remote-Transaction-Queue";
				}
				else
				{
					wcPathName= CurrentTest.m_wcsLocalComputerNameFullDNSName + L"\\" + CurrentTest.m_wcsLocalComputerNameFullDNSName +  L"-Remote-Transaction-Queue";
				}
		}

		wcsQLabel=L"privQ"
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel,CREATEQ_PRIV_LEVEL);
		itpCurrentObject++;
		iNumberOfQueue++;

*/


		//
		// Create queue for the locate thread
		// Label it with the machine GUID
		//
		wstring wcsLocalQmID;
		
		wcsLocalQmID = CurrentTest.m_wcsLocateGuid;
		
		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName( wcPathName , 0 , CurrentTest.bWin95 );
		}
		else
		{
			wcPathName = wcsBasePublicQPath + L"-Locate1";
		}
		wcsQLabel=L"LocateQ";
		itpCurrentObject->SetProp( wcPathName ,wcsLocalQmID ,NULL);
		itpCurrentObject++;
		iNumberOfQueue++;


		if ( eSetupType == RunTimeSetup )
			ReturnGuidFormatName (wcPathName , 0 , CurrentTest.bWin95 );
		else
			wcPathName=wcsBasePublicQPath + L"-Locate2";

  		wcsQLabel=L"LocateQ";
		itpCurrentObject->SetProp( wcPathName ,wcsLocalQmID ,NULL);
		itpCurrentObject++;
		iNumberOfQueue++;

		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName (wcPathName , 0 ,CurrentTest.bWin95 );
			wcsQLabel = L"MqDL1";
		}
		else
		{
			wcPathName=wcsBasePublicQPath + L"-" + g_cwcsDlSupportCommonQueueName + L"1";
			wcsQLabel= CurrentTest.m_wcsCurrentLocalMachine + g_cwcsDlSupportCommonQueueName;
		}
  		
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel ,CREATEQ_AUTHENTICATE);
		itpCurrentObject++;
		iNumberOfQueue++;

		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName (wcPathName , 0 ,CurrentTest.bWin95 );
			wcsQLabel = L"MqDL2";
		}
		else
		{
			wcPathName=wcsBasePublicQPath + L"-" + g_cwcsDlSupportCommonQueueName + L"2";
			wcsQLabel= CurrentTest.m_wcsCurrentLocalMachine + g_cwcsDlSupportCommonQueueName;
		}

  		
		itpCurrentObject->SetProp( wcPathName ,wcsQLabel ,CREATEQ_AUTHENTICATE);
		itpCurrentObject++;
		iNumberOfQueue++;


		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName (wcPathName , 0 ,CurrentTest.bWin95 );
			wcsQLabel = L"MqDL3";
		}
		else
		{
			wcPathName=wcsBasePublicQPath + L"-" + g_cwcsDlSupportCommonQueueName + L"3";
			wcsQLabel= CurrentTest.m_wcsCurrentLocalMachine + g_cwcsDlSupportCommonQueueName;
		}

		itpCurrentObject->SetProp( wcPathName ,wcsQLabel ,CREATEQ_AUTHENTICATE);
		itpCurrentObject++;
		iNumberOfQueue++;


		if ( eSetupType == RunTimeSetup )
		{
				ReturnGuidFormatName (wcPathName , 0 ,CurrentTest.bWin95 );
		}
		else
		{
			wcPathName=wcsBasePublicQPath + L"-" + g_cwcsDlSupportCommonQueueName + L"Admin";
		}

  		wcsQLabel= CurrentTest.m_wcsCurrentLocalMachine + g_cwcsDlSupportCommonQueueName;
		itpCurrentObject->SetProp( wcPathName , L"DL Admin Queue" , NULL);
		itpCurrentObject++;
		iNumberOfQueue++;
	
	

	
	}


	//
	// Create the queues - or just retrieve the format name if they already exist.
	//
	
	bool bTryToCreate = ( eSetupType ==  ONLYUpdate ) ?  FALSE: TRUE ;

	INT iIndex=0;
	DebugMqLog(" +++++++++ Update internal sturcture about queue format names +++++++++\n");
	
	for (itpCurrentObject=AllQueues.begin(),iIndex=0; iIndex < iNumberOfQueue  ; itpCurrentObject++ , iIndex++)
	{
		if (g_bDebug)
		{
			if( bTryToCreate )
			{
				wMqLog(L"MQCreateQueue path= %s\n" ,(itpCurrentObject->getPathName()).c_str());
				
			}
			else
			{
				wMqLog(L"MQPathNameToFormatName path= %s\n" ,(itpCurrentObject->getPathName()).c_str());
			}
		}
		itpCurrentObject->CreateQ( bTryToCreate , eSetupType ,CurrentTest);
		CurrentTest.UpdateQueueParams( itpCurrentObject->getPathName(),itpCurrentObject->getFormatName(),itpCurrentObject->getQLabel());
		
	}
	DebugMqLog("-------------------------------------------------------------------\n");
	
	PreTestPreparation(CurrentTest,eSetupType);
	//
	// errors are handled in catch and destructor
	//

	return MSMQ_BVT_SUCC;
}


const wstring g_wcsPeekBody = L"--Bom--" ;
const wstring g_wcsPeekLabel =  L"=~-Tic";
const wstring g_wcsFormatName = L"direct=https://MightBeBuginNT4\\MSMQ\\Private$\\qaqq";


void PreTestPreparation(cBvtUtil & CurrentTest, SetupType eSetupType )
/*++
	Function Description:
		This function run once during installation phase and prepare additional setting on MSMQ properties	
	Arguments:
		None
	Return code:
		None

	
--*/
{
	if( CurrentTest.m_eMSMQConf != DepClientLocalU && g_bRunOnWhistler == TRUE )
	{
		EnableDCOM();
	}
	if( eSetupType == ONLYSetup && CurrentTest.m_eMSMQConf != DepClient )
	{
		CRemotePeek pTemp;
	}
}

//
// cPropVar::GetMQPROPVARIANT
//
// This method assigns pointers from the MSMQ propety
// structures to the MQQUEUEPROPS structure
//
// Return value is a pointer to the private member structure.
// Since the MQCreateQueue function is a friend of this class,
// it has access to the structure to use during the API call.
//
MQQUEUEPROPS * cPropVar::GetMQPROPVARIANT ()
{
	m_QueueProps.cProp=iNumberOfProp;
	m_QueueProps.aPropID=pQueuePropID;
	m_QueueProps.aPropVar=pPropVariant;
	m_QueueProps.aStatus=hResultArray;
	return &m_QueueProps;
}

//
// cPropVar::GetMSGPRops
//
// This method assigns pointers from the MSMQ propety
// structures to the MQMSGPROPS structure
//
// Return value is a pointer to the private member structure.
// Since the MQSendMessage and MQReceiveMessage functions are friends of this class,
// they have access to the structure to use during the API call.
//
MQMSGPROPS * cPropVar::GetMSGPRops ()
{
	m_myMessageProps.cProp=iNumberOfProp;
	m_myMessageProps.aPropID=pQueuePropID;
	m_myMessageProps.aPropVar=pPropVariant;
	m_myMessageProps.aStatus=hResultArray;
	return & m_myMessageProps;
}

//
// cPropVar::cPropVar
//
// This constructor creates a buffer for the MSMQ property structures
// Input is number of properties the buffer must hold.
//
cPropVar::cPropVar ( INT iNumberOFProp ) : pQueuePropID(NULL),pPropVariant(NULL), hResultArray(NULL),iNumberOfProp(0)
{
	if ( iNumberOFProp > 0 ) // Not minus
	{
		pQueuePropID = ( QUEUEPROPID * ) malloc ( sizeof ( QUEUEPROPID ) * iNumberOFProp);
		if ( ! pQueuePropID )
		{
			throw INIT_Error( "Can't allocate memory for pQueuePropID" );
		}
		
		pPropVariant =  ( MQPROPVARIANT * ) malloc ( sizeof (MQPROPVARIANT) * iNumberOFProp );
		if ( ! pPropVariant )
		{
			throw INIT_Error("Can't allocate memory for pQueuePropID" );
		}
		hResultArray = ( HRESULT * ) malloc ( sizeof ( HRESULT ) * iNumberOFProp );
		if ( ! hResultArray )
		{
			throw INIT_Error("Can't allocate memory for pQueuePropID" );
		}
	}
}


cPropVar::~cPropVar ()
{

	//
	// bugbug - I don't know why I can't free pPropvariant
	//
	free ( pPropVariant ); 
	free ( hResultArray );
	free ( pQueuePropID );
}

//
// cPropVar:: AddProp
//
// This method adds a entries to the  MSMQ property structures
//
// Return value:  success / falied.
//

INT cPropVar:: AddProp( QUEUEPROPID cPropID , VARTYPE MQvt , const void *pValue ,DWORD dwsize )
{
    BOOL bOperationSucess = TRUE ;
	
	//
	// Look for this property in the existing PROPID array
	// reuse the entry if found.
	//
	INT iSaveIndex = -1;
	INT iPlace;
	for ( INT iIndex=0 ; iIndex < iNumberOfProp && iSaveIndex == -1 ; iIndex ++)
	{
		if ( pQueuePropID [ iIndex ] == cPropID )
			iSaveIndex = iIndex ;
	}

	//
	// If PROPID not found. Add it to the end of the array
	//
	if (iSaveIndex != -1 )
		iPlace = iSaveIndex;
	else
		iPlace = iNumberOfProp;

	//
	// Create the requested VT entry
	//
	switch (MQvt)
	{
	case VT_UI1:	{
						UCHAR * bVal=(UCHAR * )  pValue;
						pPropVariant[iPlace].vt=VT_UI1;
						if ( pValue )
							pPropVariant[ iPlace ].bVal = * bVal;
					}
					break;

	case VT_UI2:	{
						USHORT * ulVal=(USHORT * )  pValue;
						pPropVariant[iPlace].vt=VT_UI2;
						if ( pValue )
							pPropVariant[ iPlace ].ulVal = * ulVal;
					}
					break;

	case VT_UI4:	{
						ULONG * ulVal=(ULONG * )  pValue;
						pPropVariant[iPlace].vt=VT_UI4;
						if ( pValue )
							pPropVariant[ iPlace ].ulVal = * ulVal;
					}
					break;
	case VT_UI8:	{
						pPropVariant[iPlace].vt=VT_UI8;
					}
					break;
	 case VT_UI1|VT_VECTOR:
					{
						UCHAR * pwcsBuffer= (UCHAR * ) pValue;
						pPropVariant[iNumberOfProp].vt=VT_UI1|VT_VECTOR;
						if (dwsize == 0 )
							pPropVariant[iPlace].caub.cElems = sizeof (WCHAR) *( (ULONG)(wcslen ((WCHAR * )pwcsBuffer)) + 1);
						else
							pPropVariant[iPlace].caub.cElems = dwsize;

						pPropVariant[iPlace].caub.pElems= pwcsBuffer;


					}
					break;

	 case VT_LPWSTR:
					{
						WCHAR * pwcstr = (WCHAR * ) pValue ;
						pPropVariant[iPlace].vt=VT_LPWSTR;
						if ( pValue )
							pPropVariant[iPlace].pwszVal = pwcstr;
					}
					break;

	 case VT_CLSID:	{
						GUID gQtype;
						if ( UuidFromString( (unsigned char *) pValue,&gQtype) != RPC_S_OK ) 
						{
							 MqLog("AddProp - Failed to convert string to guid \n");
							 return MSMQ_BVT_FAILED;
						}
 						pPropVariant[iPlace].vt=VT_CLSID;
						if ( pValue )
							pPropVariant[ iPlace ].puuid = &gQtype;
					}
					break;
    default:
		bOperationSucess = FALSE;
	};


	if ( bOperationSucess && iSaveIndex == -1)
	{
	    pQueuePropID [ iNumberOfProp ] = cPropID;
		iNumberOfProp ++;
		//
		// Need to update all the vector in the Memory
		//
		m_myMessageProps.cProp=iNumberOfProp;
		m_myMessageProps.aPropID=pQueuePropID;
		m_myMessageProps.aPropVar=pPropVariant;
		m_myMessageProps.aStatus=hResultArray;
	}
	
	
	return bOperationSucess ? MSMQ_BVT_SUCC:MSMQ_BVT_FAILED;
}

//
// cBvtUtil Installation stage
//

//
// Check the Encrypt installation type
//
EncryptType cBvtUtil::GetEncryptionType ()
{
	return m_EncryptType;
}
//
// Check the Encryption type if the machine has Enhanced Encryption support.
//
EncryptType cBvtUtil::HasEnhancedEncryption( wstring wcsMachineName )
{	
	const int iNumberOfPropId = 1;
	QMPROPID QMPropId[iNumberOfPropId];
	MQPROPVARIANT QMPropVar[iNumberOfPropId];
	MQQMPROPS QMProps = {iNumberOfPropId,QMPropId,QMPropVar,NULL};
	
	int iIndex = 0;
	QMPropId[iIndex] = PROPID_QM_ENCRYPTION_PK_ENHANCED;
	QMPropVar[iIndex].vt = VT_NULL;
	iIndex ++ ;

	HRESULT rc = MQGetMachineProperties(wcsMachineName.c_str(),NULL,&QMProps);
    if( rc == MQ_OK )
	{
		if( QMPropVar[0].vt == (VT_UI1 | VT_VECTOR )) 
		{
			MQFreeMemory(QMPropVar[0].caub.pElems);
		}
		return Enh_Encrypt;
	}
	else if ( FAILED (rc) )
	{
		iIndex = 0;
		QMPropId[iIndex] = PROPID_QM_ENCRYPTION_PK;
		QMPropVar[iIndex].vt = VT_NULL;
		iIndex ++ ;
		rc = MQGetMachineProperties(wcsMachineName.c_str(),NULL,&QMProps);
		if (FAILED (rc))
		{
			MqLog("MQGetMachineProperties failed to detect any encryption support 0x%x\n",rc);
		}
		else
		{
			if(QMPropVar[0].vt == (VT_UI1 | VT_VECTOR)) 
			{
				MQFreeMemory(QMPropVar[0].caub.pElems);
				return Base_Encrypt;
			}
			else
			{
				MqLog("MQGetMachineProperties return value the is not matched to the expected result(2)\n");
			}
		}
  }
  return No_Encrypt;
}

EncryptType cBvtUtil::DetectEnhancedEncrypt ()
{

		HCRYPTPROV hProv = NULL;
		char pwszContainerName[]="Eitank";

		//
		BOOL bRet = CryptAcquireContext( &hProv,
										 pwszContainerName,
										 MS_ENHANCED_PROV,
										 PROV_RSA_FULL,
										(CRYPT_MACHINE_KEYSET | CRYPT_DELETEKEYSET));
		//
		// Re-create the key container.
		//
		bRet = CryptAcquireContext( &hProv,
									pwszContainerName,
									MS_ENHANCED_PROV,
									PROV_RSA_FULL,
									(CRYPT_MACHINE_KEYSET | CRYPT_NEWKEYSET));
		if (bRet)
		{
			if (!CryptReleaseContext(hProv, 0))
			{
				MqLog("Error %x during CryptReleaseContext!\n", GetLastError());
			}		
		}
		
		return  bRet ? Enh_Encrypt:Base_Encrypt;

}
//
// This Function get queue pathname and return the queue format name
//


wstring cBvtUtil::ReturnQueueFormatName ( wstring wcsQueueLabel )
{
	return AllQueuesInTheTest.ReturnQueueProp (wcsQueueLabel);

}

INT cBvtUtil::Delete ()
{
	if ( DeleteAllQueues() == MSMQ_BVT_FAILED )
	{
		return MSMQ_BVT_FAILED;
	}
	return AllQueuesInTheTest.del_all_queue();
}


wstring cBvtUtil::ReturnQueuePathName ( wstring wcsQueueLabel )
{
	return AllQueuesInTheTest.ReturnQueueProp (wcsQueueLabel, 2);
}



void cBvtUtil::dbg_PrintAllQueueInfo ()
{
	AllQueuesInTheTest.dbg_printAllQueueProp();
}


inline
void cBvtUtil::UpdateQueueParams (std::wstring wcsQueuePathName,std::wstring wcsQueueFormatName , std::wstring wcsQueueLabel )
{

	AllQueuesInTheTest.UpdateQueue ( wcsQueuePathName,wcsQueueFormatName, wcsQueueLabel);
}



//
// AmIWin9x method tried to detect win9x configuration.
//
// Return value:
// True - this is win9x
// False - other operating system
//

bool cBvtUtil::AmIWin9x ()
{
	SC_HANDLE hSCManager = OpenSCManager( "NoComputer" , NULL, GENERIC_READ );
	DWORD err = GetLastError();
	if ( err == ERROR_CALL_NOT_IMPLEMENTED )
	{
		return TRUE;
	}
	if( hSCManager != NULL)
	{
		CloseServiceHandle (hSCManager);
	}
	return FALSE;

}

//
// iAmDC method tried to detect dependent client configuration
// And retrieve the supporting server and local computer name
//


INT cBvtUtil::iAmDC ( void )
{

	
	DWORD dwType;
	HKEY  hKey;
	LONG rc = RegOpenKeyEx(
		          FALCON_REG_POS,
				  FALCON_REG_KEY,
				  0,
				  KEY_QUERY_VALUE,
				  &hKey
				  );

	if (ERROR_SUCCESS != rc)
	{
		MqLog("Can't open registry, to retrieve information about MSMQ configuration\n");
		return Configuration_Detect_Warning;
	}
	
	ULONG ulServerNameSize = MAX_MACH_NAME_LEN;
	char csRemoteMachineName[MAX_MACH_NAME_LEN + 1 ];

	rc = RegQueryValueEx(	hKey,				// handle to key to query
							RPC_REMOTE_QM_REGNAME,// address of name of value to query
							NULL,				// reserved
							&dwType,			// address of buffer for value type
							(LPBYTE) csRemoteMachineName, // address of data buffer
							&ulServerNameSize   // address of data buffer size
						);
		
	if(ERROR_SUCCESS == rc)							//ERROR_SUCCESS return = reg key exists for DC
    {
    	m_eMSMQConf = DepClient;
		m_wcsLocalComputerNetBiosName = My_mbToWideChar(csRemoteMachineName);   	
    }
	RegCloseKey(hKey);

	return Configuration_Detect;
}


bool cBvtUtil::IsLocalUserSupportEnabled()
/*++  
	Function Description:
		Check if MSMQ is working in AD/MQIS enviroment.
	Arguments:
		none
	Return code:
	
		true/false

--*/
{

	
	
	HKEY hKey = NULL;
	LONG rc = RegOpenKeyEx(
						    FALCON_REG_POS,
							FALCON_REG_KEY,
							0,
							KEY_QUERY_VALUE,
							&hKey
							);

	if (ERROR_SUCCESS != rc)
	{
		MqLog("Can't open registry, to retrieve information about MSMQ configuration\n");
		return false;
	}

	DWORD dwType = REG_DWORD;
	DWORD dwVal=MSMQ_DS_ENVIRONMENT_UNKNOWN;
	DWORD dwSize = sizeof(dwVal);
	rc = RegQueryValueEx(
						 hKey,				
						 MSMQ_DS_ENVIRONMENT_REGNAME,
						 NULL,		
						 &dwType,
						 (BYTE*)&dwVal,
						 &dwSize		
						);
	
	if(ERROR_SUCCESS != rc)				
    {
		RegCloseKey(hKey);
    	return false;
    }
	if( dwVal == MSMQ_DS_ENVIRONMENT_PURE_AD ) // Check this reg key only on XP when use MQAD.DLL
	{
		dwVal = 0;
		rc = RegQueryValueEx(
	  						 hKey,				
	  						 MSMQ_ENABLE_LOCAL_USER_REGNAME,
							 NULL,		
							 &dwType,
							 (BYTE*)&dwVal,
							 &dwSize		
							 );

		RegCloseKey(hKey);	
		if( dwVal != 1 )
		{
			return false;
		}
		
	}
	// MqDSCli should work
	
	return true;
}

//------------------------------------------------------------
// TypeDef for cluster api use for dynmic link to clusapi.dll
//

typedef HCLUSTER
(WINAPI * DefOpenCluster)
(LPCWSTR lpszClusterName );
	
typedef DWORD
(WINAPI * DefGetClusterInformation)
(HCLUSTER hCluster,LPWSTR lpszClusterName,LPDWORD lpcchClusterName,LPCLUSTERVERSIONINFO lpClusterInfo);

typedef BOOL
(WINAPI * DefCloseCluster)
(HCLUSTER hCluster);

//------------------------------------------------------------
// iAmCluster method tried to detect cluster installation,
// The function retrieve the cluster name from cluster API.
//

bool cBvtUtil::iAmCluster()
{
	
	HCLUSTER hCluster = NULL;
    DWORD    dwError  = ERROR_SUCCESS;
    DWORD    cbNameSize = MAX_MACH_NAME_LEN;
    DWORD    cchNameSize = cbNameSize;
    HMODULE  h_ClusDll;
    FARPROC  pFuncOpenCluster;
    FARPROC  pFuncGetClusterInformation;
	FARPROC  pFuncCloseCluster;

    CLUSTERVERSIONINFO ClusterInfo;
    ClusterInfo.dwVersionInfoSize = sizeof(CLUSTERVERSIONINFO);

    LPWSTR lpszClusterName = (LPWSTR) LocalAlloc( LPTR, cbNameSize );
    if( lpszClusterName == NULL )
    {
		MqLog ("LocalAlloc failed to allocate memory for the cluster name\n");
		return false;
    }

	h_ClusDll = GetModuleHandle("clusapi.dll");
	if( h_ClusDll == NULL )
	{
		LocalFree( lpszClusterName );
		return false;
	}

	pFuncOpenCluster = GetProcAddress(h_ClusDll,"OpenCluster");
    if (pFuncOpenCluster == NULL)
	{
		LocalFree( lpszClusterName );
		FreeLibrary(h_ClusDll);
		return false;
	}
	
	DefOpenCluster xOpenCluster =(DefOpenCluster) pFuncOpenCluster;
	hCluster = xOpenCluster(NULL);
    if( hCluster == NULL )
	{
	    LocalFree( lpszClusterName );
		FreeLibrary(h_ClusDll);
	    return false;
    }

	pFuncGetClusterInformation = GetProcAddress(h_ClusDll,"GetClusterInformation");
    if (pFuncGetClusterInformation == NULL)
	{
		LocalFree( lpszClusterName );
		FreeLibrary(h_ClusDll);
		return false;
	}
	
	DefGetClusterInformation xGetClusterInformation = (DefGetClusterInformation) pFuncGetClusterInformation;
		
    dwError = xGetClusterInformation( hCluster,
                                     lpszClusterName,
                                     &cchNameSize,
                                     &ClusterInfo );
    //
    // Reallocate if the name buffer was too small
    // The cchNameSize parameter now holds the count of
    // characters in the cluster name minus the terminating NULL
    //

    if ( dwError == ERROR_MORE_DATA )
    {
        LocalFree( lpszClusterName );
		
        cchNameSize++;

		lpszClusterName = (LPWSTR) LocalAlloc( LPTR, cchNameSize );

        if( lpszClusterName == NULL )
        {
            MqLog ("LocalAlloc failed to allocate memory for the cluster name\n");
			FreeLibrary(h_ClusDll);
            return false;
        }


   		dwError = xGetClusterInformation( hCluster,
                                         lpszClusterName,
                                         &cchNameSize,
                                         &ClusterInfo );
    }

    if ( dwError != ERROR_SUCCESS )
    {
		LocalFree( lpszClusterName );
		FreeLibrary(h_ClusDll);
		return false;
    }
	
	pFuncCloseCluster = GetProcAddress(h_ClusDll,"CloseCluster");//amir
    if (pFuncCloseCluster == NULL)
	{
		LocalFree( lpszClusterName );
		FreeLibrary(h_ClusDll);
	    return false;
	}
	
	DefCloseCluster xCloseCluster =(DefCloseCluster) pFuncCloseCluster;//amir
    BOOL bRes = xCloseCluster( hCluster );
	if ( bRes == FALSE )
	{
		MqLog ("CloseCluster failed with error 0x%x\n",GetLastError());
	}

	m_wcsClusterNetBiosName=lpszClusterName;
	m_bMachineIsCluster = true;
	FreeLibrary(h_ClusDll);
    LocalFree( lpszClusterName );

    return true;
}



std::wstring GetFullDNSNameEx(std::wstring wcsHostName)
/*++

	Function Description:  
 	  This function use WinSock2 API to get full DNS name for computer.
	Arguments:
		Compuetr name netbios name.
	Return code:
		return FULL DNS name.
--*/
{

	WSADATA WSAData;
    if ( WSAStartup(MAKEWORD(2,0), &WSAData) != 0)
	{
		return g_wcsEmptyString;
	}
	DWORD           dwResult;
    DWORD           dwError = NO_ERROR;
    WSAQUERYSETW    qset;
    HANDLE          hLookUp = INVALID_HANDLE_VALUE;
    DWORD           dwRespLength = 0;
    static AFPROTOCOLS afp[2] = { {AF_INET, IPPROTO_UDP}, {AF_INET, IPPROTO_TCP} };
    static GUID guidSvc =SVCID_INET_HOSTADDRBYNAME;

	memset(&qset, 0x0, sizeof(WSAQUERYSET)); 
    qset.dwSize = sizeof(WSAQUERYSET);
    qset.lpszServiceInstanceName =const_cast<WCHAR*>(wcsHostName.c_str());
    qset.lpServiceClassId = &guidSvc;
    qset.dwNameSpace = NS_ALL;
    qset.dwNumberOfProtocols = 2;
    qset.lpafpProtocols = &afp[0];

	dwResult = WSALookupServiceBeginW(&qset, LUP_RETURN_BLOB | LUP_RETURN_NAME, &hLookUp);
    if(dwResult != NO_ERROR)
    {
        dwError = WSAGetLastError();
		return g_wcsEmptyString;
    }
    dwResult = WSALookupServiceNextW(hLookUp, 0, &dwRespLength, &qset);
    dwError =  WSAGetLastError();
    if(dwError == WSAEFAULT && dwRespLength > 0)
    {
        WSAQUERYSETW * prset = (WSAQUERYSETW*)malloc(dwRespLength);
        if(prset == NULL)
        {
			printf("GetFullDNSNameEx failed to allocate memory \n");
            return g_wcsEmptyString;
        }
        dwResult = WSALookupServiceNextW(hLookUp, 0, &dwRespLength, prset);
        if(dwResult != NO_ERROR)
        {
            dwError = WSAGetLastError();
        }
        else
        {
			if( prset->lpszServiceInstanceName != NULL ) 
			{	
				wstring wcsTemp = prset->lpszServiceInstanceName;
				free(prset);
				WSACleanup ();    
				return wcsTemp;
			}
		}
		free(prset);
	}

	WSACleanup ();    
	return g_wcsEmptyString;

}

//
// GetFullDNSName method Retrieve  Full DNS Name using WinSock API
//
// Input parmeters:
// WcsHostName - Netbios name for computer name.
// Return value:
// Success - Full DNS name.
// Failed - Empty string .
//

std::wstring cBvtUtil::GetFullDNSName(std::wstring  wcsHostName)
{
    //
    // initialize winsock
    //
	if( _winmajor >= Win2K )
	{
		return GetFullDNSNameEx(wcsHostName);
	}

    WSADATA WSAData;
	WCHAR MachName[MAX_MACH_NAME_LEN];
	BOOL bFlag=TRUE;
    int iRc = WSAStartup(MAKEWORD(1,1), &WSAData);
	if (iRc)
	{
		//	Rem try to find winsock DLL
		std::cout << "GetFullDNSName function failed to find WinSock dll";
		return g_wcsEmptyString;
	}
	CHAR wcsMultiMachiNeme[MAX_MACH_NAME_LEN * 2 ];
	INT T=1;
	WideCharToMultiByte(  CP_ACP, WC_COMPOSITECHECK,  wcsHostName.c_str(),
							-1,wcsMultiMachiNeme, MAX_MACH_NAME_LEN,NULL,&T);
	struct hostent* pHost = gethostbyname(wcsMultiMachiNeme);
	WSACleanup();
	if (pHost == NULL)
		bFlag=FALSE;
    else
		MultiByteToWideChar(CP_ACP,0,pHost->h_name,-1,MachName,MAX_MACH_NAME_LEN);

	return bFlag ? (wstring)MachName:g_wcsEmptyString;
}

//
// iAmLocalUser method check if MSMQ work on local user
// Supported only in NT4 ( > Sp4 ) & W2K machines only
//
// Return value :
// True  - Local user.
// False - Domain user.
//

BOOL cBvtUtil::iAmLocalUser ()
{
	WCHAR wcsEnvSpecifyDomainName[]=L"USERDOMAIN";
	WCHAR wcsDomainNameBuffer[100]={0};
	DWORD dDomainNameBufferSize=100;
	WCHAR wcsComputerName[100]={0};
	DWORD dComputerName=100;
	GetEnvironmentVariableW(wcsEnvSpecifyDomainName,wcsDomainNameBuffer,dDomainNameBufferSize);
	GetComputerNameW(wcsComputerName,&dComputerName);
	return ! wcscmp (wcsComputerName,wcsDomainNameBuffer);
}

//
// iAmMSMQInWorkGroup method return if the machine installed as workgroup computer
//


INT cBvtUtil::iAmMSMQInWorkGroup ()
{
	HKEY pkey;
	HRESULT hResult;
	
	//
	// Open Registry to decide the type of msmqInstallation
	//
	 hResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\MSMQ\\Parameters", 0, KEY_QUERY_VALUE, &pkey);
	
	 if (hResult  != ERROR_SUCCESS )
	 {
		MqLog ("iAmMSMQInWorkGroup - Can't open registry file error :0x%x\n",hResult);
		return Configuration_Detect_Warning;
	 }
	
	 DWORD dwInstallType;
	 ULONG ulInstallTypeSize=sizeof (dwInstallType);
	 ULONG RegType=REG_DWORD;
	
	 hResult=RegQueryValueEx(pkey,"Workgroup",0, & RegType, (UCHAR * ) & dwInstallType, & ulInstallTypeSize);	
		
	 RegCloseKey(pkey);
	
	// update member varible workgroup detected.
	if ( hResult == ERROR_SUCCESS )
	{
		if ( dwInstallType == 1 )
		{
			m_eMSMQConf = WKG;
		}		
		
	}
	return Configuration_Detect;
}

//
// Ctor - Collect the computer parameters
// 1. Dep client.
// 2. Cluster name.
// 3. Machine name.
// 4. Workgroup / local user
//

cBvtUtil::cBvtUtil (std::wstring wcsRemoteComputerName,
				    const std::list<wstring> & listOfRemoteMachine,
					const std::wstring & wcsMultiCastAddress,
					BOOL bUseFullDNSName,
					SetupType eSetupType,
					BOOL bTriggers,
					BOOL bIsNT4
				   )
				   : m_listOfRemoteMachine(listOfRemoteMachine),
					 m_bDeleteFullDNSQueue(false),
					 m_MuliCastAddress(wcsMultiCastAddress),
					 m_bIncludeTrigger(bTriggers),
					 m_bMachineIsCluster(false),
					 m_RemoteIsNT4(bIsNT4)
{




	// Check the insatllation process.

	// Check if the computer is Win9x
	
	bWin95 = AmIWin9x ();

	
	m_eMSMQConf=DomainU;
	// 1. Try to detect workgroup setup.
	if ( iAmMSMQInWorkGroup () == Configuration_Detect_Warning )
		throw INIT_Error ("Workgroup detect failed");
	
    if (g_bRemoteWorkgroup)
    {
	    m_eMSMQConf = WKG;
    }
	
	bool bCluster = iAmCluster();
	// 2. Try to Detect domain Envirment

	if( iAmDC() == Configuration_Detect_Warning )
	{
	   throw INIT_Error ("Dependent client failed during detect confguration");
	}
	else if ( m_eMSMQConf != DepClient && bCluster == false )
	{
		ULONG ulMachineNameLength = MAX_MACH_NAME_LEN;
		
		CHAR csLocalComputerName [MAX_MACH_NAME_LEN+1];
		DWORD dwErrorCode = GetComputerName( csLocalComputerName , &ulMachineNameLength);
		
		if(!dwErrorCode)
		{
			throw INIT_Error("GetComputerName failed to retrive the local computer name");
		}
		else
		{
			m_wcsLocalComputerNetBiosName = My_mbToWideChar( csLocalComputerName );
		}
	}
	if( bCluster )
	{
		CHAR csLocalComputerName[MAX_MACH_NAME_LEN+1]={0};
		ULONG ulMachineNameLength = MAX_MACH_NAME_LEN;
		DWORD dwErrorCode = GetComputerName( csLocalComputerName , &ulMachineNameLength);
		
		if(!dwErrorCode)
		{
			throw INIT_Error("GetComputerName failed to retrive the local computer name");
		}
		else
		{
			m_wcsLocalComputerNetBiosName = My_mbToWideChar( csLocalComputerName );
			wMqLog(L"A cluster is installed on this computer. Cluster name is %s\n", m_wcsClusterNetBiosName.c_str());
			if( m_wcsLocalComputerNetBiosName !=  m_wcsClusterNetBiosName )
			{
				wMqLog (L"Mqbvt is using computer name '%s'\n", m_wcsLocalComputerNetBiosName.c_str());
			}
		}
	
	}

	if( g_bDebug )
	{
	  wMqLog(L"Found computer NetBIOS name = %s \n",m_wcsLocalComputerNetBiosName.c_str());
	}	
	if (m_eMSMQConf != WKG )
	{
	
	   if ( iAmLocalUser() )
		{
		   ULONG ulMSMQVer = MSMQMajorVersion(L"");
		   ulMSMQVer &= 0x3000000;
		   if ( ulMSMQVer >= 0x3000000  && IsLocalUserSupportEnabled() == false )
		   {
				throw INIT_Error("This configuration is not supported on MSMQ3 unless you enable local user reg key");
		   }
		   if ( m_eMSMQConf == DepClient )
		   {
				m_eMSMQConf = DepClientLocalU;
		   }
		   else
		   {
			    m_eMSMQConf = LocalU;
		   }
	    }

	   if ( ( m_eMSMQConf != DepClientLocalU && m_eMSMQConf != DepClient )  && ! IsMSMQInstallSucceded() )
	   {
			throw INIT_Error("Failed to verify installation type");
	   }
	}
	//
	//  Check if service is ruuning not relvant for Win9x and dependet client and cluster.
	// 
	if ( m_eMSMQConf != DepClient && ! bWin95 && bCluster == false)
	{
		if ( ! CheckIfServiceRuning (m_wcsLocalComputerNetBiosName,"MSMQ")  )
		{
			MqLog (" ******************************************\n");
			MqLog (" MSMQ is not currently running as a service\n");
			MqLog (" ******************************************\n");
		}
	}

	// Get from command line arguments
	m_wcsRemoteComputerNetBiosName = wcsRemoteComputerName;

	// Retrieve full dns name using winsock API,
	// This will failed if there is problem with dns configuration on the computer,
	
	
	//
	// If machine has IPX only protocol or has problem with DNS HostName is missing
	// Mqbvt will use only NetBios name.
	//

	m_wcsLocalComputerNameFullDNSName = GetFullDNSName( m_wcsLocalComputerNetBiosName );
	if( ! IsDnsHostNameExist(m_wcsLocalComputerNameFullDNSName) )
	{
		wMqLog(L" Local machine full DNS name is missing!, \n",m_wcsLocalComputerNetBiosName);
		wMqLog(L" This error might effect on test results, please verify DNS setting");
		m_wcsLocalComputerNameFullDNSName = m_wcsLocalComputerNetBiosName;
	}
	m_fAmWorkingAgainstPEC = iamWorkingAgainstPEC();
	if( m_fAmWorkingAgainstPEC == TRUE )
	{
		m_wcsLocalComputerNameFullDNSName = m_wcsLocalComputerNetBiosName;
	}
	BOOL bNeedRemoteMachine = TRUE;

	
	if ( m_wcsRemoteComputerNetBiosName != g_wcsEmptyString )
	{
		m_wcsRemoteMachineNameFullDNSName=GetFullDNSName( m_wcsRemoteComputerNetBiosName );
		if ( ! IsDnsHostNameExist(m_wcsRemoteMachineNameFullDNSName) )
		{
			wMqLog ( L">>> Remote machine full DNS name is missing !!!\n",m_wcsLocalComputerNetBiosName);
			m_wcsRemoteMachineNameFullDNSName = m_wcsRemoteComputerNetBiosName;
		}
        if(m_fAmWorkingAgainstPEC  || m_RemoteIsNT4 == TRUE)
		{
			m_wcsRemoteMachineNameFullDNSName = m_wcsRemoteComputerNetBiosName;
		}
	}
	else
	{
		bNeedRemoteMachine = FALSE;
		m_wcsRemoteMachineNameFullDNSName = g_wcsEmptyString;
	}

	if ( eSetupType != ONLYSetup && m_wcsRemoteMachineNameFullDNSName == g_wcsEmptyString)
	{
		MqLog("Init Error : Remote machine is not available !! check remote machine name \n" );
	}
	if (g_bDebug)
	{
		wMqLog(L"GetHostbyname found the full dns name for the following machines:\n");
		wMqLog(L"Local machine full DNS: %s\n",m_wcsLocalComputerNameFullDNSName.c_str());
		wMqLog(L"Remote machine full DNS: %s\n",m_wcsRemoteMachineNameFullDNSName.c_str());

	}
	if ( ( m_wcsLocalComputerNameFullDNSName == g_wcsEmptyString ) || (! bNeedRemoteMachine &&  m_wcsRemoteComputerNetBiosName == g_wcsEmptyString  ))
	{
		if (bUseFullDNSName)
		{
			wMqLog( L"cBVTInit - Can't retrieve full DNS name using winsock api \n");
		}
	}


	if ( bUseFullDNSName )
	{
		m_wcsCurrentLocalMachine  = m_wcsLocalComputerNameFullDNSName;
		m_wcsCurrentRemoteMachine = m_wcsRemoteMachineNameFullDNSName;
	}
	else
	{
		m_wcsCurrentLocalMachine  = m_wcsLocalComputerNetBiosName;
		m_wcsCurrentRemoteMachine = m_wcsRemoteComputerNetBiosName;
	}

	//
	// Detect if Enhanced encrypt installed on the machine ( Win2k only )
	//

	if( eSetupType != ONLYSetup && m_eMSMQConf != WKG && _winmajor >=  Win2K && g_bRemoteWorkgroup != true)
	{
		//m_EncryptType = DetectEnhancedEncrypt ();
		if ( HasEnhancedEncryption( m_wcsCurrentLocalMachine ) == Enh_Encrypt  && HasEnhancedEncryption(m_wcsCurrentRemoteMachine) == Enh_Encrypt )
		{
			m_EncryptType = Enh_Encrypt;
		}
	}
	

	//	
	// Retreive local & Remote machine guid
	//
	// Not need in workgroup

	if ( m_eMSMQConf != WKG )
	{
		
		m_wcsMachineGuid = GetMachineID( g_wcsEmptyString );
		if( eSetupType != ONLYSetup )
		{
			m_wcsRemoteMachineGuid = GetMachineID( m_wcsCurrentRemoteMachine );
		}
		if ( eSetupType == RunTimeSetup )
		{
			ReturnGuidFormatName( m_wcsLocateGuid , 2 , bWin95 );		
		}
		else
		{
			m_wcsLocateGuid = m_wcsMachineGuid;
		}
		//m_wcsLocateGuid += L",\\*";
	}

}


//
// Retrieve parameter form INI file
//


INT RetriveParmsFromINIFile (wstring wcsSection,wstring wcsKey , wstring & wcsValue, wstring csFileName )
{
	const int iMaxInputStringAllow=MAX_GUID;
	WCHAR * wcsTempVal = ( WCHAR * ) malloc ( sizeof (WCHAR) * (iMaxInputStringAllow + 1 ));
	if ( ! wcsTempVal )
	{
		wMqLog (L"Can't Allocate memory at GetStrParameter\n");
		return MSMQ_BVT_FAILED;
	}
	DWORD dwString_len=GetPrivateProfileStringW( wcsSection.c_str(),wcsKey.c_str(),NULL,wcsTempVal,iMaxInputStringAllow,csFileName.c_str());
	if ( ! dwString_len )
	{
		wMqLog (L"Can't retrieve key from register\n");
		free (wcsTempVal);
		return MSMQ_BVT_FAILED;
	}
	wcsValue=wcsTempVal;
	free (wcsTempVal);
	return MSMQ_BVT_SUCC; // Strlen or Zero if didn't find the string
}

//
// My_mbToWideChar function convert from string to wstring.
//

std::wstring My_mbToWideChar( std::string csString)
{

	size_t dwStringLen = (csString.length() + 1)   * sizeof(WCHAR);
	WCHAR * wcsWideCharString = (WCHAR *) malloc ( dwStringLen );
	if( wcsWideCharString == NULL )
	{
		return g_wcsEmptyString;
	}
	if ( ! MultiByteToWideChar(CP_ACP,0,csString.c_str(),-1,wcsWideCharString,(DWORD)dwStringLen))
	{
		long lErorr = GetLastError();
		MqLog("Error converting string '%s' using MultiByteToWideChar. error:%x\n",csString.c_str(),lErorr);
		free(wcsWideCharString);
		return g_wcsEmptyString;
	}
	wstring wcsTemp = wcsWideCharString;
	free(wcsWideCharString);
	return wcsTemp;
}

//
// My_WideTOmbString function convert from wstring to string
//

std::string My_WideTOmbString( std::wstring wcsString)
{
	char * csValue;
	INT ciMaxMBlen = MAX_GUID;
	csValue = (char * ) malloc (sizeof (char) * (ciMaxMBlen + 1));
	if (! csValue )
	{
		return "Empty";
	}
	
	int ilen=WideCharToMultiByte (CP_ACP,WC_COMPOSITECHECK,wcsString.c_str (),-1,csValue,ciMaxMBlen,NULL,&ciMaxMBlen);
	if( !ilen )
	{
		free (csValue);
		return "Empty";
	}
	string wcTemp(csValue);
	free (csValue);
	return wcTemp;
}

//
// Dynamic link to MQRegisterCertificate,
// Need to use this because MQBvt need to be compatible with MSMQ 1.0.
// Inputs:
// bool bInstallType - Declare if mwregistercertificate need to work.
// dwRegisterFlag - Flag to mqregistercertificate one of MQCERT_REGISTER_ALWAYS / MQCERT_REGISTER_IF_NOT_EXIST
// returns value
// Pass / Fail


HRESULT CheckCertificate ( DWORD dwRegisterFlag )
{
	HMODULE h_MqrtDll;
	h_MqrtDll=GetModuleHandle("MQRT.Dll");
	FARPROC pFunc;
	HRESULT rc = MQ_ERROR;
	pFunc=GetProcAddress(  h_MqrtDll, "MQRegisterCertificate"  );
	//
	// check if the function exist
	//
	if (pFunc == NULL)
	{
		return rc;
	}
	else
	{
		DefMQRegisterCertificate xMQRegisterCertificate=(DefMQRegisterCertificate) pFunc;
		rc = xMQRegisterCertificate(dwRegisterFlag,NULL,0);
		
		FreeLibrary (h_MqrtDll);

		if (rc != MQ_OK && rc != MQ_INFORMATION_INTERNAL_USER_CERT_EXIST)
		{
			MqLog ("MQRegisterCertificate failed with error 0x%x\n",rc);
			return rc;
		}
	
	}

	return rc;
}


//
// GetMachineID retrieve the machine GUID for the Locate queue
// Using this for the static queues for locate operation created with label equal to the machine guid
//
// Input parameters:
// wcsRemoteMachineName - Remote machine
// If the parmers is empty that mean local machine.
//
// return value:
// Guid for the queue label.
//



wstring cBvtUtil::GetMachineID ( wstring wcsRemoteMachineName )
{
	
	  wstring wcsQmID;
	  DWORD cPropId=0;
	  const int iNumberOfProp = 1;
	  MQQMPROPS qmprops;
	  QMPROPID aQMPropId[iNumberOfProp];
	  PROPVARIANT aQMPropVar[iNumberOfProp];
	  HRESULT aQMStatus[iNumberOfProp];
	  HRESULT rc;
	  CLSID guidMachineId;
	  
	  aQMPropId[cPropId] = PROPID_QM_MACHINE_ID;
	  aQMPropVar[cPropId].vt = VT_CLSID;
	  aQMPropVar[cPropId].puuid = &guidMachineId;
	  cPropId++;
	  qmprops.cProp = cPropId;
	  qmprops.aPropID = aQMPropId;
	  qmprops.aPropVar = aQMPropVar;
	  qmprops.aStatus = aQMStatus;

	
	  const WCHAR *pMachineName = NULL;
	  if( wcsRemoteMachineName != g_wcsEmptyString )
	  {
		  pMachineName = wcsRemoteMachineName.c_str();
	  }

	  if( g_bDebug )
	  {
		  wMqLog(L"Try to retrive QMID using MQGetMachineProperties for machine %s\n",pMachineName ? pMachineName:L"NULL<LocalMachine>");
	  }

	  rc = MQGetMachineProperties(pMachineName,
								  NULL,
								  &qmprops);
	  if (FAILED(rc))
	  {
		 wMqLog(L"Failed to retrive QM ID for machine %s , using MQGetMachineProperties , error = 0x%x\n",pMachineName ? pMachineName:L"NULL<LocalMachine>",rc);
		 throw INIT_Error("Failed to retrive QM ID for machine using MQGetMachineProperties");
	  }

		
  	  UCHAR * pcsTempBuf;
	  RPC_STATUS  hr = UuidToString ( & guidMachineId , & pcsTempBuf );
	  if(hr != RPC_S_OK )
	  {
			MqLog("GetMachineID - UuidToString failed to covert guid to string return empty string \n");
			return L"";
	  }
	  wcsQmID = My_mbToWideChar( (CHAR *)pcsTempBuf );
	  RpcStringFree( &pcsTempBuf );
	  return wcsQmID;
}

//
// CheckMSMQServiceStatus method check if the MSMQ service is started
//
// Return value:
// True - MSMQ service is started.
// False - MSMQ service is stop.
//

bool cBvtUtil::CheckIfServiceRuning( wstring wcsMachineName , string csServiceName )
{
		
		
		BOOL bControlState;
		SC_HANDLE hSCManager = OpenSCManagerW( wcsMachineName.c_str() , NULL, GENERIC_READ );
		if (! hSCManager)
		{
			MqLog ("Can't open Service menager \n");
			return FALSE;
		}
		SC_HANDLE hService = OpenService( hSCManager, csServiceName.c_str() , GENERIC_READ );
		if ( hService == NULL )
		{
			CloseServiceHandle(hSCManager);
			return FALSE;	
		}
		SERVICE_STATUS  ssServiceStatus;
		bControlState = ControlService( hService, SERVICE_CONTROL_INTERROGATE, &ssServiceStatus );
		CloseServiceHandle(hService);
		CloseServiceHandle(hSCManager);
		return bControlState ? TRUE:FALSE;
}

//
// IsMSMQInstallSucceded method checks if MSMQ finish installation process.
//

bool cBvtUtil::IsMSMQInstallSucceded ()
{
				
		HKEY  hKey = NULL;
		HRESULT rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\MSMQ\\Parameters\\MachineCache", 0, KEY_QUERY_VALUE , &hKey);
		//
		// Local user can open registry
		//
		if ( rc == ERROR_ACCESS_DENIED )
		{
			return TRUE;
		}
		if (ERROR_SUCCESS != rc)
		{
			return FALSE;
		}
	    RegCloseKey(hKey);
		return TRUE;

}
//****************************************************************
//
// IsDnsHostNameExist - Check if DNSHostNameExist
// If machine has IPX only protocol or has problem with DNS HostName
// Mqbvt will use only NetBios name.
// return value
// True - exist
// False - not exist
//

bool cBvtUtil::IsDnsHostNameExist (wstring wcsRemoteMachineFullDNSname )
{
	cPropVar MyPropVar(1);
	HRESULT rc = MQ_OK;
	WCHAR wcsFormatName [BVT_MAX_FORMATNAME_LENGTH] = {0};
	ULONG ulFormatNameLength = BVT_MAX_FORMATNAME_LENGTH ;
	wstring wcsQueuePathName = wcsRemoteMachineFullDNSname + L"\\TestFullDnsName";
	MyPropVar.AddProp (PROPID_Q_PATHNAME,VT_LPWSTR,wcsQueuePathName.c_str());
	CSecurityDescriptor *pSec = CreateFullControllSecDesc();
	rc = MQCreateQueue( pSec->m_pSD, MyPropVar.GetMQPROPVARIANT(), wcsFormatName , &ulFormatNameLength );
	delete pSec;
	if ( rc == MQ_ERROR_INVALID_OWNER )
	{
		return false;
	}
	if( rc == MQ_OK || rc == MQ_ERROR_QUEUE_EXISTS )
	{
		if( rc != MQ_OK && wcsRemoteMachineFullDNSname == m_wcsLocalComputerNameFullDNSName )
		{
			ulFormatNameLength = BVT_MAX_FORMATNAME_LENGTH;
			rc = MQPathNameToFormatName(wcsQueuePathName.c_str(),wcsFormatName,&ulFormatNameLength);
			if( SUCCEEDED( rc ))
			{	
				//
				// Remote duplicate format name from the list.
				//

				list<my_Qinfo> ::iterator it = m_listQueuesFormatName.begin();
				while(  it != m_listQueuesFormatName.end() && it->GetQFormatName() != wcsFormatName )
				{
					it ++;
				}
				if( it == m_listQueuesFormatName.end() )
				{
					my_Qinfo mQueueInfoTempObject(wcsQueuePathName,wcsFormatName,L"");
					m_listQueuesFormatName.push_back(mQueueInfoTempObject);
				}
			}
		}
		m_bDeleteFullDNSQueue = true;
	}
	return true;
}

int cBvtUtil::DeleteAllQueues ()
/*
	Clean queues that are not used directly in the test.
*/
{
	list<my_Qinfo> ::iterator it;

	for( it = m_listQueuesFormatName.begin(); it != m_listQueuesFormatName.end(); it++ )
	{

		if( g_bDebug )
		{
			wMqLog(L"cBvtUtil::DeleteAllQueues Try to delete queue pathname=%s \nFormatName:%s\n",(it->GetQPathName()).c_str(),(it->GetQFormatName()).c_str());
		}
		HRESULT rc = MQDeleteQueue( (it->GetQFormatName()).c_str() );
		if ( rc != MQ_OK && rc != MQ_ERROR_QUEUE_NOT_FOUND )
		{
			wMqLog(L"cBvtUtil::DeleteAllQueues failed to delete queue %s\n",(it->GetQPathName()).c_str() );
			ErrHandle ( rc,MQ_OK,L"MQDelete queue failed");
		}
	}
	return MSMQ_BVT_SUCC;
}




BOOL cBvtUtil::iamWorkingAgainstPEC()
{
	HKEY  hKey = NULL;
	LONG rc = RegOpenKeyEx(
						    FALCON_REG_POS,
						    FALCON_REG_KEY,
							0,
							KEY_QUERY_VALUE,
							&hKey
							);

	if (ERROR_SUCCESS != rc)
	{
		MqLog("Can't open registry, to retrieve information about MSMQ configuration\n");
		return Configuration_Detect_Warning;
	}
	
	ULONG ulBufSize = 4;
	byte pBufValue[4];
	DWORD dwType = 0;
	rc = RegQueryValueEx(	hKey,				// handle to key to query
							MSMQ_DS_ENVIRONMENT_REGNAME,// address of name of value to query
							NULL,				// reserved
							&dwType,			// address of buffer for value type
							(LPBYTE) pBufValue, // address of data buffer
							&ulBufSize   // address of data buffer size
						);
	RegCloseKey(hKey);	
	if( rc == ERROR_SUCCESS  && dwType == REG_DWORD && *pBufValue == MSMQ_DS_ENVIRONMENT_MQIS )
	{
		if( g_bRunOnWhistler && g_bDebug )
		{
			MqLog("--- Found windows XP installed in MQIS Enterprise ----\n");
		}
		return true;
	}
	return false;
}

BOOL cBvtUtil::GetWorkingAgainstPEC()
{
	return m_fAmWorkingAgainstPEC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\level8.cpp ===
//
// This Test is written for tests level 8 problem
// In our ATCM  3904 
//
// Written by: Eitank @ Microsoft.com 
//


#include "msmqbvt.h"
#include <mq.h>
#include "sec.h"
#include <_mqreg.h> //to support falcon registry entries, andysm added
#include <_mqini.h> //also to support falcon registry entries, andysm added
#include <wincrypt.h>
using namespace std;

 
//
// Ctor - Do those steps:
// 1. Retrive parmeters from INI file
// 2. Impersonate to other user
// 3. Load Hive
// 4. Retrive Security context.
// 5. Revert to self.
// 
cLevel8::cLevel8 (std::map <std::wstring,std::wstring> & Params)
{
	 m_DestQueueFormatName= Params[L"DESTQFN"];
	 
	 RetriveParmsFromINIFile (L"ImpersonateTo",L"UsrName",m_wcsUserName);
	 RetriveParmsFromINIFile (L"ImpersonateTo",L"domain",m_wcsDomainName);
	 RetriveParmsFromINIFile (L"ImpersonateTo",L"Password",m_wcsPassWord);
	
	try
	 {
		

		 string csUserName=My_WideTOmbString( m_wcsUserName );
		 string csDomainName=My_WideTOmbString( m_wcsDomainName );
		 string csPassword=My_WideTOmbString( m_wcsPassWord );
		 
	 	 wstring wcsAccountName = m_wcsDomainName;
		 wcsAccountName +=L"\\";
		 wcsAccountName += m_wcsUserName;
		 // This Class impersonate to other user
		 Impersonate_t  user(csUserName.c_str(),csDomainName.c_str(),csPassword.c_str());
		 //
		 // Load hive + MQGetSecurityContext
		 //
		 m_hSeCtxt=FAL_GetThreadSecurityContext(user,wcsAccountName);
		 
		 // Revert To self called by the destractor 
	 }
	 catch (INIT_Error & err )
	 {
		wcout << L"Problem with Impersonate\n";
		throw err;
	 }
}

//
// Test tests related to level 8 problem
// With MQGetSecurityConext 
// FMQclient send auth messgae with using logon as other - mirror acount
// and send it with his securty conext
// This tests is in the atcm in test = 3904
//
//

//
// Need to modify all the tests that can get map as passed value 
//

//
// This Method writes to debug the application 
// This check if the HIVE is loaded well
//

//
// This code is written to debug load hive problems.
// You can logon as some one write in the registry.
//
int cLevel8::DebugIt()
{
		
		WCHAR szRegName[255];
		HKEY hProf = NULL ;
		LONG lRegError = 0 ;
		WCHAR szProfileImagePath[256];
        DWORD dwProfileImagePathBuffSize = sizeof(szProfileImagePath);


		wcscpy(szRegName, L"Software\\Microsoft\\MSMQ") ;
        lRegError = RegOpenKeyExW( HKEY_CURRENT_USER,
                                  szRegName,
                                  0,
                                  KEY_QUERY_VALUE,
                                  &hProf );
        if (lRegError != ERROR_SUCCESS)
        {
            MqLog("Failed in RegOpenKeyEx(%S), other hive, err- %lut\n",
                                                    szRegName, lRegError);
            return MSMQ_BVT_FAILED;
        }

        dwProfileImagePathBuffSize = sizeof(szProfileImagePath);
        DWORD dwType = REG_SZ ;

        lRegError = RegQueryValueExW( hProf,
                                     L"OtherHiveValue",
                                     0,
                                     &dwType,
                                     (PBYTE)szProfileImagePath,
                                     &dwProfileImagePathBuffSize );
        if (lRegError != ERROR_SUCCESS)
        {
            MqLog(
             "Failed in RegQueryValueEx(%S, OtherHiveValue), err- %lut\n",
                                                     szRegName, lRegError);
            return MSMQ_BVT_FAILED;
        }
        MqLog("Successfully RegQueryValueEx(), other hive, value- %S\n",
                                                     szProfileImagePath) ;

        lRegError = RegCloseKey(hProf);
return MSMQ_BVT_SUCC;    
}

//
// Send messages as other user. 
//

 
INT cLevel8::Start_test()
{
	HRESULT hRc;
	HANDLE Qh;
	cPropVar Level8Mprop (7);
	wstring Body (L"Test");
	wstring Label (L"Test");

	hRc=MQOpenQueue (m_DestQueueFormatName.c_str(),MQ_SEND_ACCESS,MQ_DENY_NONE, &Qh);
	Level8Mprop.AddProp (PROPID_M_BODY,VT_UI1|VT_VECTOR,Body.c_str());
	Level8Mprop.AddProp (PROPID_M_LABEL,VT_LPWSTR,Label.c_str());
	INT iTemp=MQMSG_PRIV_LEVEL_BODY_BASE;

	iTemp=MQMSG_AUTH_LEVEL_ALWAYS;
	Level8Mprop.AddProp (PROPID_M_AUTH_LEVEL,VT_UI4,&iTemp);

	if (g_bDebug)
	{
		wcout <<L"Try to send messages without security context" <<endl;
	}
	//
	//  Send message without security context - check if there is any problem.
	// 
	hRc=MQSendMessage (Qh, Level8Mprop.GetMSGPRops() ,NULL);
	ErrHandle(hRc,MQ_OK,L"MQSendMessage Failed");
	
	//
    // Add Security context to the message prop
	// 
	Level8Mprop.AddProp (PROPID_M_SECURITY_CONTEXT,VT_UI4,&m_hSeCtxt);		
	hRc=MQSendMessage(Qh, Level8Mprop.GetMSGPRops() ,NULL);
	ErrHandle(hRc,MQ_OK,L"MQSendMessage Failed");

return MSMQ_BVT_FAILED;
}

	
INT cLevel8::CheckResult()
{
	
	// Bugbug need to retrive the message and check the user SID
	MQFreeSecurityContext (m_hSeCtxt);
	//  ErrHandle(hRc,MQ_OK,L"MQFreeSecurityContext");

	return MSMQ_BVT_SUCC;
}


void cLevel8::Description() 
{
	wMqLog(L"Thread %d : Send auth message as other user\n", m_testid);
}

cLevel8::~cLevel8 ()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\mqadmapi.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: MqAdmAPI.cpp

Abstract:
	1. Send a message to a nonexisting queue. By doing so an outgoing queue is created that contains the message.
	2. Call MQMgmtGetIngo on the outgoing queue.
	3. Check the queue properties returned by it.
		
Author:
    
	Tal Kariv (talk) 1-7-2001
	
Revision History:

--*/
#include "msmqbvt.h"
using namespace std;
using namespace MSMQ;

void FreeMemory(PROPVARIANT* propVar);
void FreeValue(PROPVARIANT* propVar , INT PlaceToFree);

#define NUM_OF_ADMIN_PROPS 11
#define MESSAGE_COUNT_SENT_TO_EMPTY 1
#define EMPTY_QUOTA 236
#define ADMIN_TEST_QUEUE L"DIRECT=OS:Empty\\bvt-AdminTest"
#define NO_MESSAGES 0


void CMqAdminApi::Description()
{
	wMqLog(L"Thread %d : Admin API Thread\n", m_testid);
}

CMqAdminApi::CMqAdminApi(const INT iIndex , std::wstring wcsLocalComputerNetBiosName)
 :cTest(iIndex),m_wcsFormatName(L"")
{
	m_wcsFormatName = ADMIN_TEST_QUEUE;
	m_wcsLabel = L"Admin Test " + m_wcsGuidMessageLabel;

	m_wcsLocalComputerNetBiosName = wcsLocalComputerNetBiosName;
}
CMqAdminApi::~CMqAdminApi()
{
	if (propVar != NULL)
	{
		FreeMemory(propVar);
	}
}

HRESULT
CMqAdminApi::CleanQueue()
{
	map <wstring,wstring> mRemoveOurMsg;
	mRemoveOurMsg[L"DebugInformation"] = L"open outgoing queue and remove our message";
	mRemoveOurMsg[L"M_Label"] = m_wcsLabel;
	mRemoveOurMsg[L"FormatName"] = m_wcsFormatName;
	mRemoveOurMsg[L"Access"] = L"admin";

	HRESULT rc = RetrieveMessageFromQueue( mRemoveOurMsg );

	return rc;
}

CMqAdminApi::Start_test()
/*++  
	Function Description:
		sends a message to a nonexisting queue Empty\bvt-AdminTest
	Arguments:
		none
	Return code:
		none
--*/
{
	HRESULT rc=MQ_OK;
	HANDLE QueueuHandle = NULL;
	cPropVar AdmMessageProps(3);
	wstring Label(L"Admin Test");

	//
	//	open nonexisting queue Empty\bvt-AdminTest
	//
	if(g_bDebug)
	{
		MqLog("open nonexisting queue Empty\\bvt-AdminTest\n");
	}
	rc=MQOpenQueue( m_wcsFormatName.c_str(), MQ_SEND_ACCESS, MQ_DENY_NONE, &QueueuHandle );
	ErrHandle(rc, MQ_OK, L"MQOpenQueue with send access failed");
	//
	// Send express message to a nonexisting queue Empty\bvt-AdminTest
	//
	if(g_bDebug)
	{
		MqLog("Send message to nonexisting queue Empty\\bvt-AdminTest\n");
	}
	AdmMessageProps.AddProp( PROPID_M_LABEL, VT_LPWSTR, m_wcsLabel.c_str() );
	ULONG ulTemp = MQBVT_MAX_TIME_TO_BE_RECEIVED;
	AdmMessageProps.AddProp( PROPID_M_TIME_TO_BE_RECEIVED , VT_UI4, &ulTemp );
	AdmMessageProps.AddProp( PROPID_M_BODY , VT_UI1|VT_VECTOR , m_wcsLabel.c_str());

	rc = MQSendMessage( QueueuHandle , AdmMessageProps.GetMSGPRops() , NULL);
	ErrHandle(rc,MQ_OK,L"MQSendMessage Failed");
	//
	// MQCloseQueue queue Empty\bvt-AdminTest
	//
	rc=MQCloseQueue(QueueuHandle);
	ErrHandle(rc,MQ_OK,L"MQCloseQueue Failed");
	return MSMQ_BVT_SUCC;
}


CMqAdminApi::CheckResult()
/*++  
	Function Description:
		Calls MQMgmtGetInfo on outgoing queue direct=os:Empty\bvt-AdminTest and checks the values returned
	Arguments:
		none
	Return code:
		none
--*/
{
	DWORD cPropId = 0;

	
	// 0 
	propId[cPropId] = PROPID_MGMT_QUEUE_PATHNAME;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 1
	propId[cPropId] = PROPID_MGMT_QUEUE_FORMATNAME;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 2 
	propId[cPropId] = PROPID_MGMT_QUEUE_TYPE;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 3 
	propId[cPropId] = PROPID_MGMT_QUEUE_LOCATION ;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 4 
	propId[cPropId] = PROPID_MGMT_QUEUE_XACT;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 5 
	propId[cPropId] = PROPID_MGMT_QUEUE_FOREIGN;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 6 
	propId[cPropId] = PROPID_MGMT_QUEUE_MESSAGE_COUNT;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 7 
	propId[cPropId] = PROPID_MGMT_QUEUE_USED_QUOTA;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 8 
	propId[cPropId] = PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 9 
	propId[cPropId] = PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	// 10 
	propId[cPropId] = PROPID_MGMT_QUEUE_STATE;
	propVar[cPropId].vt = VT_NULL;
	cPropId++;

	mqProps.cProp = cPropId;
	mqProps.aPropID = propId;
	mqProps.aPropVar = propVar;
	mqProps.aStatus = NULL;

	//
	//	calling MQMgmtGetInfo
	//
	wstring QueueToPassToMgmt = L"QUEUE=";
	QueueToPassToMgmt += m_wcsFormatName;
	if(g_bDebug)
	{
		MqLog("Calling MqMgmtGetInfo on machine %S for queue %S\n" , m_wcsLocalComputerNetBiosName.c_str(), QueueToPassToMgmt.c_str());
	}
	HRESULT hr = MQMgmtGetInfo( m_wcsLocalComputerNetBiosName.c_str(), QueueToPassToMgmt.c_str(), &mqProps );
	ErrHandle(hr, MQ_OK, L"MQMgmtGetInfo Failed");
	
	//
	//	check queue pathname - should be unknown (since the target queue doesn't really exist)
	//
	if (propVar[0].pwszVal !=  NULL)
	{
		MqLog("Got incorrect pathname - %S\n" , propVar[0].pwszVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue pathname - OK\n");
		}
	}

	//
	//	check queue format name
	//
	if ( m_wcsFormatName != propVar[1].pwszVal)
	{
		MqLog("Got incorrect format name - %S\n" , propVar[1].pwszVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue format name - OK\n");
		}
	}

	//
	//	check queue type. should be public.
	//
	if (wcscmp(propVar[2].pwszVal , MGMT_QUEUE_TYPE_PUBLIC))
	{
		MqLog("Got incorrect type - %S\n" , propVar[2].pwszVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue type - OK\n");
		}
	}

	//
	//	check queue location. should be remote.
	//
	if (wcscmp(propVar[3].pwszVal , MGMT_QUEUE_REMOTE_LOCATION))
	{
		MqLog("Got incorrect location - %S\n" , propVar[3].pwszVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue location - OK\n");
		}
	}

	//
	//	check if queue is transactional. should be unknown since the target queue doesn't exist
	//
	if (wcscmp(propVar[4].pwszVal , MGMT_QUEUE_UNKNOWN_TYPE)) 
	{
		MqLog("Got incorrect transactional status - %S\n" , propVar[4].pwszVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue transactional status - OK\n");
		}
	}

	//
	//	check queue foreign status. should be unknown since target queue doesn't exist.
	//
	if (wcscmp(propVar[5].pwszVal , MGMT_QUEUE_UNKNOWN_TYPE))
	{
		MqLog("Got incorrect foreign status - %S\n" , propVar[5].pwszVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue foreign status - OK\n");
		}
	}

	//
	//	check queue message count. should be at least MESSAGE_COUNT_SENT_TO_EMPTY (1)
	//
	if (propVar[6].ulVal <  MESSAGE_COUNT_SENT_TO_EMPTY) 
	{
		MqLog("Got incorrect message count - %d\n" , propVar[6].ulVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue message count - OK\n");
		}
	}
	
	//
	//	check queue quota > 0 can't be prepdict the exact quota
	//
	if (propVar[7].ulVal <= 0 ) 
	{
		MqLog("Got incorrect used quota - %d\n" , propVar[7].ulVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue used quota - OK\n");
		}
	}
	
	//
	//	check journal message count. should be NO_MESSAGES (0)
	//
	if (propVar[8].ulVal != NO_MESSAGES) 
	{
		MqLog("Got incorrect journal message count - %d\n" , propVar[8].ulVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue journal message count - OK\n");
		}
	}

	//
	//	check journal used quota. should be NO_MESSAGES (0)
	//
	if (propVar[9].ulVal != NO_MESSAGES) 
	{
		MqLog("Got incorrect journal used quota - %d\n" , propVar[9].ulVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue journal used quota - OK\n");
		}
	}

	//
	//	check outgoing queue state. should be "waiting" or "nonactive" depending on how much time passed since it was created
	//
	if (wcscmp(propVar[10].pwszVal , MGMT_QUEUE_STATE_WAITING) && wcscmp(propVar[10].pwszVal , MGMT_QUEUE_STATE_NONACTIVE))
	{
		MqLog("Got incorrect state - %S\n" , propVar[10].pwszVal);
		return(MSMQ_BVT_FAILED);
	}
	else
	{
		if(g_bDebug)
		{
			MqLog("Queue state - OK\n");
		}
	}

	//
	//	open outgoing queue Empty\bvt-AdminTest and remove our message
	//
	HRESULT rc=MQ_OK;
	rc=CleanQueue();
	ErrHandle(rc,MQ_OK,L"CleanQueue failed");
	return MSMQ_BVT_SUCC;
}

void FreeMemory(PROPVARIANT* propVar)
/*++  
	Function Description:
		free memory allocated by MQMgmtGetInfo
	Arguments:
		propVar
	Return code:
		none
--*/
{
	FreeValue(propVar , 0);
	FreeValue(propVar , 1);
	FreeValue(propVar , 2);
	FreeValue(propVar , 3);
	FreeValue(propVar , 4);
	FreeValue(propVar , 5);
	FreeValue(propVar , 10);
}

void FreeValue(PROPVARIANT* propVar , INT PlaceToFree)
/*++  
	Function Description:
		free a string allocated by MQMgmtGetInfo
	Arguments:
		propVar , place in struct to free
	Return code:
		none
--*/
{
	if (propVar[PlaceToFree].vt == VT_LPWSTR)
	{
		MQFreeMemory(propVar[PlaceToFree].pwszVal);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\locateq.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Auth.cpp

Abstract:
	Locate thread preform DS operation.	
		
Author:
    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/



#include "msmqbvt.h"
using namespace std;
extern BOOL g_bRunOnWhistler;

void cLocateTest::Description()
{
	wMqLog(L"Thread %d : Locate queues in the DS\n", m_testid);
}

//----------------------------------------------------------------------------
// cLocateTest::cLocateTest
// Retrive the queue label that need to search
// 

cLocateTest::cLocateTest( INT iIndex , map <wstring ,wstring > Tparms )
: cTest(iIndex),icNumberOfQueues(2),m_bUseStaticQueue(true),m_bWorkAgainstNT4(false),
  m_iEmbedded(COM_API)

{
	wcsLocateForLabel = Tparms [L"QCommonLabel"];
	m_wcsLocalMachineComputerName = ToLower(Tparms[L"CurrentMachineName"]);
	m_wcsLocalMachineName = Tparms[L"CurrentMachineName"] + L"\\" + Tparms[L"CurrentMachineName"] + L"-";
	m_wcsLocalMachineName = ToLower(m_wcsLocalMachineName);
	m_wcsLocalMachineFullDNSName = ToLower(Tparms[L"CurrentMachineNameFullDNS"]);
	if ( Tparms[L"UseStaticQueue"] == L"No" )
	{
		m_bUseStaticQueue =  false;
	}
	if( Tparms[L"NT4SuportingServer"] == L"true" )
	{
		m_bWorkAgainstNT4 = true;
	}
	if (Tparms[L"SkipOnComApi"] == L"Yes" )
	{
		m_iEmbedded = C_API_ONLY;
	}
}

//----------------------------------------------------------------------------
// cLocateTest::CheckResult ( Empty )
// 
//

cLocateTest::CheckResult ()
{
	return MSMQ_BVT_SUCC;
}

//----------------------------------------------------------------------------
// cLocateTest::Start_test 
// Locate queue using C API + Com interface 
//
// Return value:
// Pass - MSMQ_BVT_SUCC 
// Fail - MSMQ_BVT_FAIL
//

#define MAXCOLUMNARRAY 7
#define INUMBEROFRESTRICATION 6

INT cLocateTest::Start_test()
{

	//
	// Locate queue using C api.
	// 
	SetThreadName(-1,"cLocateTest - Start_test ");	
	
	MQPROPERTYRESTRICTION MyPropertyRestriction [ INUMBEROFRESTRICATION ];
	MQPROPVARIANT mPropVar [ INUMBEROFRESTRICATION ];
	int iNumberOfClumn = 0;
	PROPID MyColumnArray [ MAXCOLUMNARRAY ];
	const int ciLabelInArray = iNumberOfClumn;
	MyColumnArray[iNumberOfClumn ++ ] = PROPID_Q_LABEL;
	MyColumnArray[iNumberOfClumn ++ ] = PROPID_Q_BASEPRIORITY;
	MyColumnArray[iNumberOfClumn ++ ] = PROPID_Q_PATHNAME;
	/*MyColumnArray[iNumberOfClumn ++ ] = PROPID_Q_INSTANCE;
	MyColumnArray[iNumberOfClumn ++ ] = PROPID_Q_TYPE;*/
	
	
	int iPathNameColmn = -1;
	if( g_bRunOnWhistler && !m_bWorkAgainstNT4 )
	{
		iPathNameColmn = iNumberOfClumn;
		MyColumnArray[iNumberOfClumn ++ ] = PROPID_Q_PATHNAME_DNS;
	}
    
	//
	// Init MQCOLUMNSET structures
    // 

	MQCOLUMNSET MyColumns;
	MyColumns.cCol = iNumberOfClumn;
	MyColumns.aCol = MyColumnArray;
	
	int iIndex = 0;
	MyPropertyRestriction[iIndex].rel = PREQ;
	MyPropertyRestriction[iIndex].prop = PROPID_Q_LABEL;
	MyPropertyRestriction[iIndex].prval.vt = VT_LPWSTR;
	MyPropertyRestriction[iIndex].prval.pwszVal = ( unsigned short * ) wcsLocateForLabel.c_str();
	iIndex ++;

	MQRESTRICTION MyRestriction;
	
	MyRestriction.cRes = iIndex;
	MyRestriction.paPropRes = MyPropertyRestriction;

	if( g_bDebug )
	{	
		wMqLog( L" Thread 4 - Start to locate all queues with label:=%s \n",wcsLocateForLabel.c_str() );		
		wMqLog( L"Call-> MQLocateBegin( NULL, &MyRestriction , &MyColumns , NULL , &hEnum );\n" \
				L" PROPID_Q_LABEL=%s",wcsLocateForLabel.c_str());
	}
	
	HANDLE hEnum;
	HRESULT rc = MQLocateBegin( NULL, &MyRestriction , &MyColumns , NULL , &hEnum );
	ErrHandle( rc , MQ_OK , L"MQLocateBegin failed to search queue in the DS " );
	DWORD dwCountProp = MAXCOLUMNARRAY;
	
	//
	// Retrive all the queue that contain the same queue label.
	int iFoundNumber = 0;
	do
	{
	
		dwCountProp = 4;
		if( g_bDebug )
		{
			wMqLog( L"Call-> MQLocateNext( hEnum, &dwCountProp,  mPropVar ) ");			
		}
		rc = MQLocateNext( hEnum, &dwCountProp,  mPropVar );
		ErrHandle( rc , MQ_OK , L"MQLocateNext failed to search queue in the DS " );
		if( g_bDebug )
		{	
			wMqLog( L"Thread 4 - MQLocateNext return with dwCountProp = %ld\n",dwCountProp);
		}
		WCHAR * pwcsPos = NULL;
		if ( mPropVar[2].pwszVal )
		{
			std::wstring wcsQueuePathName = mPropVar[2].pwszVal;
			pwcsPos = wcsstr(wcsQueuePathName.c_str(),m_wcsLocalMachineName.c_str());
			if( ! m_bUseStaticQueue && pwcsPos == NULL )
			{
				pwcsPos = wcsstr( wcsQueuePathName.c_str(),m_wcsLocalMachineComputerName.c_str() );
			}
		}
		//
		// if pwcsPos != NULL is means that queue is exist in the domain and need check if full dns name is exist.
		// 
		if( g_bRunOnWhistler && pwcsPos != NULL && ! m_bWorkAgainstNT4 )
		{
			if (g_bDebug)
			{
				wMqLog(L"Thread 4 - MQLocateNext check PROPID_Q_PATHNAME_DNS  %s\n",mPropVar[iPathNameColmn].vt == VT_LPWSTR ? mPropVar[iPathNameColmn].pwszVal:L"Empty");
			}
			if ( mPropVar[iPathNameColmn].pwszVal != NULL )
			{
				std::wstring wcsQueuePathName = mPropVar[3].pwszVal;
				if ( wcsQueuePathName.find_first_of(m_wcsLocalMachineFullDNSName) == -1 )
				{ 
					//
					// Machine full dns name is not exist in domain
					//
					wMqLog(L"Thread 4 - MQLocateNext Failed to retrive PROPID_Q_PATHNAME_DNS found:%s\n",mPropVar[iPathNameColmn].vt == VT_LPWSTR ? mPropVar[iPathNameColmn].pwszVal:L"Empty");
					return MSMQ_BVT_FAILED;
				}
				
			}
			else
			{
				wMqLog(L"Thread 4 - MQLocateNext Failed to retrive PROPID_Q_PATHNAME_DNS found:%s\n",mPropVar[iPathNameColmn].vt == VT_LPWSTR ? mPropVar[iPathNameColmn].pwszVal:L"Empty");
				return MSMQ_BVT_FAILED;
			}
		}
		if( dwCountProp != 0  &&
			mPropVar[ ciLabelInArray ].pwszVal != NULL &&
			wcsLocateForLabel ==  (wstring) mPropVar[0].pwszVal &&
			pwcsPos  
		  )
		{
			iFoundNumber ++;
			if( g_bDebug )
			{
				MqLog("Found %d from %d queues\n",iFoundNumber,icNumberOfQueues);
			}
		}
		
		
	} while( dwCountProp != 0 );  
	
	
	// 
	// Check if found all what we ask to .
	//
	
	if ( iFoundNumber != icNumberOfQueues  )
	{
		MqLog("Found %d from %d queues using C API\n",iFoundNumber,icNumberOfQueues);
		return MSMQ_BVT_FAILED;
	}

	rc = MQLocateEnd ( hEnum );
	ErrHandle( rc , MQ_OK , L"MQLocateEnd failed ");
	
	//
	// Need to contue to check sort as basepriprty
	//
	if( g_bDebug )
	{
		MqLog("	Thread 4 - try to locate queue using com interface \n" \
			  " Succeeded to search using C-API \n");
	}
	
	//
	// Locate queue via com objects
	// 
	if( m_iEmbedded != C_API_ONLY )
	{
		try
		{
			
			MSMQ::IMSMQQueueInfosPtr qinfos("MSMQ.MSMQQueueInfos");
			MSMQ::IMSMQQueueInfoPtr qinfo ("MSMQ.MSMQQueueInfo");
			MSMQ::IMSMQQueryPtr query("MSMQ.MSMQQuery");
			
			INT iNumberOfQueue = 0;
			_variant_t vQLabel(wcsLocateForLabel.c_str());
			
			qinfos = query->LookupQueue ( &vtMissing , &vtMissing, & vQLabel );
			qinfos->Reset();
			qinfo = qinfos->Next();
			while( qinfo != NULL )
			{
				wstring wcsQueuePathName = qinfo->PathName;
				WCHAR * pwcsPos = wcsstr(wcsQueuePathName.c_str(),m_wcsLocalMachineName.c_str());
				if(  ! m_bUseStaticQueue && pwcsPos == NULL )
				{
					pwcsPos = wcsstr( wcsQueuePathName.c_str(),m_wcsLocalMachineComputerName.c_str() );
				}
				if( wcsLocateForLabel == ( wstring )  qinfo -> Label && pwcsPos )
				{
					iNumberOfQueue ++;
				}
				else if( wcsLocateForLabel != ( wstring )  qinfo -> Label )
				{
					wMqLog (L"Thread 4 - Error to compare result:\n found: %s \n expected: %s\n" , qinfo -> Label , wcsLocateForLabel.c_str() );
					return MSMQ_BVT_FAILED;
				}
				qinfo = qinfos->Next();
				if( g_bDebug && qinfo != NULL )
				{
					if( qinfo )
					{
						wstring wcsLabel = (wstring)qinfo->Label;
						wMqLog(L"Thread 4 - qinfos->Next, queue found with label =%s\n",wcsLabel.c_str());
					}
				}					
			}  
			if( iNumberOfQueue != icNumberOfQueues )
			{
				MqLog("Found %d from %d queues using COM API\n",iNumberOfQueue,icNumberOfQueues);
				return MSMQ_BVT_FAILED;
			}
		}
		catch(_com_error & ComErr )
		{
			wcout  << L"Thread 4 - Locate using com interface failed " <<endl;
			CatchComErrorHandle( ComErr , m_testid );
			return MSMQ_BVT_FAILED;
		}
	}  
	return MSMQ_BVT_SUCC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\mqdlrt.h ===
#ifndef _MQDLRT
#define _MQDLRT
	#include <windows.h>
	#include <string>

	typedef enum MQDlTypes
	{	
		MQ_GLOBAL_GROUP	= 0x2,
		MQ_DOMAIN_LOCAL_GROUP = 0x4,
		MQ_UNIVERSAL_GROUP	= 0x8,
	};
					
	/*++ 
		Function Description:
		
		  MQCreateDistList - Create distribution list and return distribution list object GUID.
		
		Arguments:
			
		   pwcsContainerDnName - DL continer name.
		   pwcsDLName - New DL Name.
		   pSecurityDescriptor - pointer to SD.
		   lpwcsFormatNameDistList 
		   lpdwFormatNameLength
		
		Return code:
			
			 HRESULT 
			
	--*/
	HRESULT
	APIENTRY
	MQCreateDistList(
					 IN LPCWSTR pwcsContainerDnName,
					 IN LPCWSTR pwcsDLName,
					 IN MQDlTypes eCreateFlag,
					 IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
   					 OUT LPWSTR lpwcsFormatNameDistList,
					 IN OUT LPDWORD lpdwFormatNameLength
					);

					
	/*++ 
		Function Description:
		
		  Delete DL object.
		
		Arguments:
			
			lpwcsFormatNameElem - DL format name.

		Return code:
			
			 HRESULT 
			
	--*/
	HRESULT
	APIENTRY
	MQDeleteDistList(
						IN LPCWSTR lpwcsFormatNameElem
					);

				
	/*++ 
		Function Description:	
			MQAddElementToDistList - add queue guid to the DL object.
		Arguments:
			lpwcsFormatNameElem - DL GUID
			lpwcsFormatNameDistList - DL GUID
		Return code:
			HRESULT 
	--*/

	HRESULT
	APIENTRY
	MQAddElementToDistList(
							IN LPCWSTR lpwcsFormatNameDistList,
							IN LPCWSTR lpwcsFormatNameElem
						  );

	/*++ 
		Function Description:	
			MQRemoveElementFromDistList - add queue guid to the DL object.
		Arguments:
			lpwcsFormatNameElem - DL GUID
			lpwcsFormatNameDistList - DL GUID
		Return code:
			HRESULT 
	--*/
	HRESULT
	APIENTRY
	MQRemoveElementFromDistList(
						  		  IN LPCWSTR lpwcsFormatNameDistList,
								  IN LPCWSTR lpwcsFormatNameElem
							   );

	/*++ 
		Function Description:	

			MQGetDistListElement - add queue guid to the DL object.

		Arguments:
			lpwcsFormatNameDistList - DL GUID
			pwcsElementsFormatName - DL GUID
			lpdwFormatNameLength
		Return code:
			HRESULT 
	--*/

	HRESULT
	APIENTRY
	MQGetDistListElement(
						  IN LPCWSTR lpwcsFormatNameDistList,
	  					  OUT LPWSTR pwcsElementsFormatName,
						  IN OUT LPDWORD lpdwFormatNameLength
						 );



	HRESULT
	APIENTRY
	MQCreateAliasQueue (
						IN LPCWSTR pwcsContainerDnName,
						IN LPCWSTR pwcsAliasQueueName,
						IN LPCWSTR pwcsFormatName,
						std::wstring & wcsADsPath
						);




	HRESULT
	APIENTRY
	MQDnNameToFormatName(
						  IN LPCWSTR lpwcsPathNameDistList,  
						  OUT LPWSTR lpwcsFormatNameDistList,
						  IN OUT LPDWORD lpdwFormatNameLength
						 );


	HRESULT
	APIENTRY
	MQDeleteAliasQueue(	IN LPCWSTR lpwcsAdsPath );

#endif //_MQDLRT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\mqbvtse.cpp ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1997  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   simple.c
//
//  PURPOSE:  Implements the body of the service.
//            The default behavior is to open a
//            named pipe, \\.\pipe\simple, and read
//            from it.  It the modifies the data and
//            writes it back to the pipe.
//
//  FUNCTIONS:
//            ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
//            ServiceStop( );
//
//  COMMENTS: The functions implemented in simple.c are
//            prototyped in service.h
//              
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//  Changed by:Eitank for Mqbvt
//


#include "msmqbvt.h"
#include <tchar.h>
#include "service.h"
using namespace std;

// this event is signalled when the
// service should end
//
HANDLE  hServerStopEvent = NULL;


//
//  FUNCTION: ServiceStart
//
//  PURPOSE: Actual code of the service
//           that does the work.
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    The default behavior is to open a
//    named pipe, \\.\pipe\simple, and read
//    from it.  It the modifies the data and
//    writes it back to the pipe.  The service
//    stops when hServerStopEvent is signalled
//
INT WINAPIV main( INT argc , CHAR ** argv);
int RebuildCommandLineArguements ( int * iArgumentCount , char *** argv , char * csCommandLineArgument );

VOID ServiceStart (DWORD dwArgc, LPTSTR *lpszArgv)
{
    HANDLE                  hPipe = INVALID_HANDLE_VALUE;
    HANDLE                  hEvents[2] = {NULL, NULL};
    OVERLAPPED              os;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_ATTRIBUTES     sa;
    TCHAR                   szIn[80];
    TCHAR                   szOut[80];
    LPTSTR                  lpszPipeName = TEXT("\\\\.\\pipe\\simple");
    BOOL                    bRet;
    DWORD                   cbRead;
    DWORD                   cbWritten;
    DWORD                   dwWait;
    UINT                    ndx;

    ///////////////////////////////////////////////////
    //
    // Service initialization
    //

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        goto cleanup;

    // create the event object. The control handler function signals
    // this event when it receives the "stop" control code.
    //
    hServerStopEvent = CreateEvent(
        NULL,    // no security attributes
        TRUE,    // manual reset event
        FALSE,   // not-signalled
        NULL);   // no name

    if ( hServerStopEvent == NULL)
        goto cleanup;

    hEvents[0] = hServerStopEvent;

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        goto cleanup;

    // create the event object object use in overlapped i/o
    //
    hEvents[1] = CreateEvent(
        NULL,    // no security attributes
        TRUE,    // manual reset event
        FALSE,   // not-signalled
        NULL);   // no name

    if ( hEvents[1] == NULL)
        goto cleanup;

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        goto cleanup;

    // create a security descriptor that allows anyone to write to
    //  the pipe...
    //
    pSD = (PSECURITY_DESCRIPTOR) malloc( SECURITY_DESCRIPTOR_MIN_LENGTH );

    if (pSD == NULL)
        goto cleanup;

    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
        goto cleanup;

    // add a NULL disc. ACL to the security descriptor.
    //
    if (!SetSecurityDescriptorDacl(pSD, TRUE, (PACL) NULL, FALSE))
        goto cleanup;

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = TRUE;


    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        goto cleanup;


    // allow user tp define pipe name
    for ( ndx = 1; ndx < dwArgc-1; ndx++ )
    {

        if ( ( (*(lpszArgv[ndx]) == TEXT('-')) ||
               (*(lpszArgv[ndx]) == TEXT('/')) ) &&
             _tcsicmp( TEXT("pipe"), lpszArgv[ndx]+1 ) == 0 )
        {
            lpszPipeName = lpszArgv[++ndx];
        }

    }

    // open our named pipe...
    //
    hPipe = CreateNamedPipe(
                    lpszPipeName         ,  // name of pipe
                    FILE_FLAG_OVERLAPPED |
                    PIPE_ACCESS_DUPLEX,     // pipe open mode
                    PIPE_TYPE_MESSAGE |
                    PIPE_READMODE_MESSAGE |
                    PIPE_WAIT,              // pipe IO type
                    1,                      // number of instances
                    0,                      // size of outbuf (0 == allocate as necessary)
                    0,                      // size of inbuf
                    1000,                   // default time-out value
                    &sa);                   // security attributes

    if (hPipe == INVALID_HANDLE_VALUE) {
        AddToMessageLog(TEXT("Unable to create named pipe"));
        goto cleanup;
    }
	
					


    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_RUNNING,       // service state
        NO_ERROR,              // exit code
        0))                    // wait hint
        goto cleanup;

    //
    // End of initialization
    //
    ////////////////////////////////////////////////////////
//************************************************************************* //

    ////////////////////////////////////////////////////////
    //
    // Service is now running, perform work until shutdown
    //
	if ( ! SetStdHandle( STD_OUTPUT_HANDLE , hPipe ))
	{
	/*	HANDLE hEventSource = RegisterEventSource(NULL, TEXT(SZSERVICENAME));

//        _stprintf(szMsg, TEXT("%s error: %d"), TEXT(SZSERVICENAME), dwErr);
		const char * lpszStrings="RO";
        //szStrings[0] = szMsg;
        //szStrings[1] = lpszMsg;

        if (hEventSource != NULL) {
     							ReportEvent(hEventSource, // handle of event source
								EVENTLOG_ERROR_TYPE,  // event type
								0,                    // event category
								0,                    // event ID
								NULL,                 // current user's SID
								2,                    // strings in lpszStrings
								0,                    // no bytes of raw data
								lpszStrings, // array of error strings
								NULL);                // no raw data

            (VOID) DeregisterEventSource(hEventSource);  */
     }
	wcsFileName = L"ServiceLog.log";
    for(;;)
    {
        // init the overlapped structure
        //
        memset( &os, 0, sizeof(OVERLAPPED) );
        os.hEvent = hEvents[1];
        ResetEvent( hEvents[1] );

		try
		{
			RegisterCertificate();
		}
		catch( INIT_Error & err )
		{	
			UNREFERENCED_PARAMETER(err);
			// Might happend when mqbvt runs as networkservice.
		}
        // wait for a connection...
        //
        ConnectNamedPipe(hPipe, &os);

        if ( GetLastError() == ERROR_IO_PENDING )
        {
            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE );
            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred,
                break;                           // or server stop signaled
        }

        // init the overlapped structure
        //
        memset( &os, 0, sizeof(OVERLAPPED) );
        os.hEvent = hEvents[1];
        ResetEvent( hEvents[1] );

        // grab whatever's coming through the pipe...
        //
        bRet = ReadFile(
                    hPipe,          // file to read from
                    szIn,           // address of input buffer
                    sizeof(szIn),   // number of bytes to read
                    &cbRead,        // number of bytes read
                    &os);           // overlapped stuff, not needed

        if ( !bRet && ( GetLastError() == ERROR_IO_PENDING ) )
        {
            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE );
            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred,
                break;                           // or server stop signaled
        }

       
        memset( &os, 0, sizeof(OVERLAPPED) );
        os.hEvent = hEvents[1];
        ResetEvent( hEvents[1] );
	
				
		char ** ppcsMainArgv=NULL;
		int iArgc=0;
		int iRes = RebuildCommandLineArguements (&iArgc , &ppcsMainArgv , szIn );
		if ( iRes == MSMQ_BVT_SUCC )
		{
			int y = main ( iArgc , ppcsMainArgv );
			if ( y == MSMQ_BVT_SUCC )
			{
				_stprintf(szOut, TEXT("Mqbvt Pass"));
			}
			else
			{
				_stprintf(szOut, TEXT("Mqbvt failed"));
			}		
		}

		//
		// Need to return Pass or failed client need to wait..
		//
        
		bRet = WriteFile(
                    hPipe,          // file to write to
                    szOut,          // address of output buffer
                    sizeof(szOut),  // number of bytes to write
                    &cbWritten,     // number of bytes written
                    &os);           // overlapped stuff, not needed

        if ( !bRet && ( GetLastError() == ERROR_IO_PENDING ) )
        {
            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE );
            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred,
                break;                           // or server stop signaled
        }

        // drop the connection...
        //
        DisconnectNamedPipe(hPipe);
    }

  cleanup:

    if (hPipe != INVALID_HANDLE_VALUE )
        CloseHandle(hPipe);

    if (hServerStopEvent)
        CloseHandle(hServerStopEvent);

    if (hEvents[1]) // overlapped i/o event
        CloseHandle(hEvents[1]);

    if ( pSD )
        free( pSD );

}


//
//  FUNCTION: ServiceStop
//
//  PURPOSE: Stops the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    If a ServiceStop procedure is going to
//    take longer than 3 seconds to execute,
//    it should spawn a thread to execute the
//    stop code, and return.  Otherwise, the
//    ServiceControlManager will believe that
//    the service has stopped responding.
//    
VOID ServiceStop()
{
    if ( hServerStopEvent )
        SetEvent(hServerStopEvent);
}

//*****************************************************************
// RebuildCommandLineArguements - 
// This function get string and build from that argc,argv argument.
//


int RebuildCommandLineArguements ( int * iArgumentCount , char *** pppargv , char * csCommandLineArgument )
{

	char *p=csCommandLineArgument;
	string cspTemp=p;
	size_t pos=1;
	char ** argv;
	
	for ( (*iArgumentCount) = 0; pos !=0 ; (*iArgumentCount)++)
	{
		
		pos = cspTemp.find_first_of("/") + 1;
		if (pos != 0 )
		{
			cspTemp = cspTemp.substr(pos);
		}
	}
	
	
	argv = (char ** ) malloc (sizeof (char * ) * (*iArgumentCount));
	if (argv == NULL )
	{
		return MSMQ_BVT_FAILED;
	}
	argv[0]=NULL;
	
	char * t;
	t=p;
	
	char token[] = " /";
	t = strtok ( p ,token);

	for (int i=1; i < *iArgumentCount ; i ++ )
	{
		char csTemp[255];
		strcpy (csTemp,"-");
		strcat (csTemp,t);
		argv[i]= (char * ) malloc (sizeof (char) * (strlen (csTemp) + 1));
		if ( *argv[i] == NULL )
		{
			return MSMQ_BVT_FAILED;
		}
		strcpy( argv[i] , csTemp );
		t = strtok ( NULL ,token);
	}
	*pppargv =  argv;
return MSMQ_BVT_SUCC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\mqmain.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: mqmain.cpp

Abstract:
		

Author:
    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#include "msmqbvt.h"
using namespace std;
#include "service.h"
#include "mqf.h"
#include <conio.h>
#ifndef NO_TMH
	#include "mqmain.tmh"
#endif 
/*



#pragma warning( push, 3 )	
	
	#define ASSERT(x)


	using namespace std;
#pragma warning( pop ) 	

*/
void PrintHelp();
//
// Declare global varibels.
//


// Test names and numbers

#define SendLocalPrivate (0)
#define SendLocalPublic (1)
#define SendRemotePublic (2)
#define Locate (3)
#define xFormatName (4)
#define GetMachineProp (5)
#define LocalAuth (6)
#define RemoteEncrypt (7)
#define ComTx (8)
#define SendRemotePublicWithDirectFN (9)
#define IsMqOA (10)
#define RemoteTransactionQueue (11)
#define OpenSystemQueue (12)
#define LocalEncryption (13)
#define RemoteAuth (14)
#define RemoteTransactionQueueUsingCapi (15)
#define Mqf (16)
#define HTTPToLocalPrivateQueue (17)
#define HTTPToLocalQueue (18)
#define HTTPToRemoteQueue (19)
#define HTTPToRemotePrivateQueue (20)
#define	MqDistList (21)
#define MqSetGet (22)
#define EODHTTP (23)
#define MultiCast (24)
#define AuthHTTP (25)
#define Triggers (26)
#define HTTPS (27)
#define AdminAPI (28)
#define SRMP (29)
#define DCOM (30)
#define LOCALEODHTTP (31)
#define RemotePeek (32)
#define MixedFormatNames (33)
bool g_RunOnlyStartPhase=false;
bool RestartService( wstring wcsMachineName , string csServiceName );
bool g_bRaiseASSERTOnError = true;
std::string GetLogDirectory();
BOOL CheckMSMQVersion(list<wstring> & ListOfRemoteMachineName);
void ExcludeTests ( string & szExludeString, bool * bArray );
HRESULT TrigSetRegKeyParams();
HRESULT TrigInit(cBvtUtil & cTestParms, std::wstring wcsLocalComputerName);
bool TrigCheckRegKeyParams();
HRESULT DeleteAllTriggersAndRules();
void CleanOAInitAndExit();
BOOL WINAPI fHandleCtrlRoutine( DWORD dwCtrlType );
BOOL g_bDebug=FALSE;
BOOL g_bRunOnWhistler = FALSE;
DWORD  g_dwRxTimeOut = BVT_RECEIVE_TIMEOUT ; 
LONG g_hrOLEInit=-1;
const WCHAR* const g_wcsEmptyString=L"Empty";
P<cMqNTLog> pNTLogFile;
// ---------------------------------------------------------------------------
// SetupStage
//
// This routine gets the setup type - one of three types
//
// 1. Only create queues and exit
// 2. Create the queue at runttime (must wait for replication if needed)
// 3. Use only the static queues created above.
//
// Parameters:
//		eStBflag is the setup type from above.
//		cTestParms pointer to configuration structure
//      bRestartTriggerService - Required restart of triggers service.
//     
//
// Return Values: pass or fail
//
INT SetupStage( SetupType eStBflag , cBvtUtil & cTestParms, bool bRestartTriggerService )
{
   if( eStBflag == RunTimeSetup )
   {
	   //
	   // If we are running at runtime you need to wait for replication
	   //
	   cout <<"Warning -  You are creating new queues, replication might delay queue usage" <<endl;
	
   }

    try
	{
		//
		// Do all the initialization - E.g. Create queues.
		//
		cMQSetupStage( eStBflag ,  cTestParms );	
		if(cTestParms.GetTriggerStatus() && eStBflag == ONLYSetup )
		{
			if(TrigSetRegKeyParams() != MQ_OK )
			{
				MqLog("Failed to update registry for the trigger tests\n");
				return MSMQ_BVT_FAILED;
			}

			if (TrigInit(cTestParms, cTestParms.m_wcsLocalComputerNetBiosName) != MQ_OK)
			{
				MqLog("Failed to prepare triggers test\n");
				return MSMQ_BVT_FAILED;
			}
				
			if ( bRestartTriggerService == true )
			{
				MqLog("Restart MSMQ trigger service\n");
				RestartService(cTestParms.m_wcsCurrentLocalMachine,"msmqtriggers");
			}
		}
		
	}
	catch( INIT_Error & err )
	{
		MqLog ("cMQSetupStage threw unexpected exception\n");
		cout <<err.GetErrorMessgae();
		return MSMQ_BVT_FAILED;
	}
	return MSMQ_BVT_SUCC;
}



DWORD TestResult[Total_Tests]={MSMQ_BVT_SUCC};

const int iFailedToCreateTest = 88;
struct TestContainer
{
	// cTest *
	P<cTest> AllTests [Total_Tests];
	int bCreateTest[Total_Tests];
	void operator= (TestContainer &);
	TestContainer( const TestContainer & );
	TestContainer() { };
};

TestContainer TestArr;
CCriticalSection g_Cs;

void ReBuildTestCaseForReRun(TestContainer * pTestArr );


bool CreateSetOfTests(  TestContainer * TestArr ,
						cBvtUtil & cTestParms ,
						map <wstring,wstring> & mapCreateFlag,
						DWORD * TestResult,
						SetupType eStBflag,
						int iEmbeddedState,
						wstring wcsMultiCastAddress
					  );
int EnableEmbeddedTests (TestContainer * pTestCont,InstallType eInstallType);
int RunTest( TestContainer * TestArr ,  cBvtUtil & cTestParms , map <wstring,wstring> & mSpecificTestParams , bool bMultiThread, bool bInvestigate,DWORD dwSleepUntilRep);
int ClientCode (int argc, char ** argv );
void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv);

P<Log> pGlobalLog;
wstring wcsFileName=L"Mqbvt.log";

bool g_bRunAsMultiThreads =false;
bool g_bRemoteWorkgroup = false;


INT WINAPIV main( INT argc , CHAR ** argv)
{
	// set our output to unbuffered stream
	setvbuf( stdout, NULL, _IONBF, 0 );
	setvbuf( stderr, NULL, _IONBF, 0 );

	//
	// This tests get command line parmeters
	//

#ifndef NO_TMH	 
	WPP_INIT_TRACING(L"Microsoft\\MSMQ");
	TrTRACE(GENERAL, "Runing mqbvt...");
#endif

	DWORD dwRetCode=MSMQ_BVT_FAILED;
	try
	{
		ZeroMemory( & TestArr ,sizeof ( TestArr ));
		if( argc < 2 )
		{
			PrintHelp();
			
			SERVICE_TABLE_ENTRY dispatchTable[] =
			{	
				{ TEXT(SZSERVICENAME), (LPSERVICE_MAIN_FUNCTION)service_main },
				{ NULL, NULL }
			};
			if (!StartServiceCtrlDispatcher(dispatchTable))
				AddToMessageLog(TEXT("StartServiceCtrlDispatcher failed."));
			return MSMQ_BVT_FAILED;
		}

		CInput CommandLineArguments( argc,argv );
		g_hrOLEInit = CoInitializeEx(NULL,COINIT_MULTITHREADED);
		map <wstring,wstring> mapCreateFlag;
		mapCreateFlag.clear();
		bool bVerbose=TRUE;
		pGlobalLog = new Log( wcsFileName );	
		BOOL bTestTrigger = FALSE;
		
		// clear all the value field.
		// Need to be Globel because the CTRL + Break
		// TestContainer TestArr;

		SetupType eSTtype;
		INT iStatus;
		BOOL bNT4RegisterCertificate = FALSE;
		BOOL bDelete=FALSE;
		BOOL bUseFullDNSNameAsComputerName=FALSE; // Use the tests with FullDNSName as machine name
		BOOL bWorkagainstMSMQ1=FALSE;			  // work against MSMQ1.0
		wstring wcsRemoteMachineName=g_wcsEmptyString; //start with Empty string
		eSTtype = RunTimeSetup;
		DWORD dwSleepUntilRep=0;		
		BOOL bSingleTest = FALSE;
		DWORD dwTid = 0;
		DWORD dwTimeOut=0;
		BOOL bNeedRemoteMachine = TRUE;
		int iEmbeddedState = 0;

		SetConsoleCtrlHandler( fHandleCtrlRoutine, TRUE );
		BOOL bRunDLTest=FALSE;
		BOOL bRunDCOMTest= FALSE;
		
		
		
		//
		// Start to parse all the command line argument
		//

		if( CommandLineArguments.IsExists ("?") )
		{
		   // Print help about the tests
		   PrintHelp();
		   CleanOAInitAndExit();
		   return(MSMQ_BVT_SUCC);
		}
		
		if(CommandLineArguments.IsExists ("mt"))
		{
			g_bRunAsMultiThreads = true;
		}
		if(CommandLineArguments.IsExists ("emb"))
		{
			// init for min value.
			iEmbeddedState = C_API_ONLY;
		}
		if(CommandLineArguments.IsExists ("wsl"))
		{
			g_bRunOnWhistler = TRUE;
		}

		if(CommandLineArguments.IsExists ("dl"))
		{
			bRunDLTest = TRUE;
		}
		if(CommandLineArguments.IsExists ("dcom"))
		{
			bRunDCOMTest = TRUE;
		}

		bool bInvestigate = false;
		if(CommandLineArguments.IsExists ("invs"))
		{
			bInvestigate = true;
		}

		list<wstring> ListOfRemoteMachineName;
		
		if( CommandLineArguments.IsExists ("g"))
		{
				g_bRemoteWorkgroup = true;
		}
		if(CommandLineArguments.IsExists ("r"))
		{
		   _bstr_t bStr( CommandLineArguments["r"].c_str() );
		    wcsRemoteMachineName=bStr;
			wstring wcsToken=L";";
			size_t iPos = 0;
			do
			{
				iPos =wcsRemoteMachineName.find_first_of ( wcsToken );	
				ListOfRemoteMachineName.push_back(wcsRemoteMachineName.substr(0,iPos));
				wcsRemoteMachineName = wcsRemoteMachineName.substr(iPos+1,wcsRemoteMachineName.length());
			}
			while (iPos != -1 );
		}
		mapCreateFlag[L"eSTtype"] = L"RunTimeSetup";
		if(CommandLineArguments.IsExists ("s"))
		{
			eSTtype	= ONLYUpdate ;
			mapCreateFlag[L"eSTtype"]=L"WorkWithStaticQueue";
		}
		if(CommandLineArguments.IsExists ("i"))
		{
		   // Init Stage this part the computer create all the queues
		   eSTtype = ONLYSetup;
		   bNeedRemoteMachine = FALSE;
		}
		mapCreateFlag[L"bUseFullDNSNameAsComputerName"] = L"false";
		if(CommandLineArguments.IsExists ("dns"))
		{
				// The Tests will use full DNS name for all operation.
				mapCreateFlag[L"bUseFullDNSNameAsComputerName"] = L"true";
				// bugbug should be removed .!
				bUseFullDNSNameAsComputerName = true;
		}
		if( CommandLineArguments.IsExists("crppt"))
		{
			g_RunOnlyStartPhase=true;
		}
		mapCreateFlag[L"W2KAgainstNT4PEC"]=L"false";
		if( CommandLineArguments.IsExists("nt4") )
		{
				// Run against NT4 PEC
				// Mising BUG ID:
			mapCreateFlag[L"W2KAgainstNT4PEC"]=L"true";
			bWorkagainstMSMQ1 = TRUE;
		}
			
		if( CommandLineArguments.IsExists ("c") )
		{
			bNT4RegisterCertificate = TRUE;
		}
		bool bWithoutHttp = false;
		if(CommandLineArguments.IsExists ("nohttp"))
		{
			bWithoutHttp = TRUE;
		}

		
		if( CommandLineArguments.IsExists ("d"))
		{
				// needs debug information
				g_bDebug = TRUE;
				wcout << L"Enable debug log" <<endl;
		}
		BOOL bDeleteQueueAfterTest = TRUE;
		if( CommandLineArguments.IsExists ("ddq"))
		{
			bDeleteQueueAfterTest=FALSE;
			wcout << L"Test will not delete the queue " <<endl;
		}

		bool bServicePack6=FALSE;
		mapCreateFlag[L"bServicePack6"]=L"false";
		if( CommandLineArguments.IsExists ("sp6"))
		{
				// needs debug information
				wcout <<L"Enable tests for Service Pack 6"<<endl;
				mapCreateFlag[L"bServicePack6"]=L"true";
				bServicePack6=TRUE;

		}
		mapCreateFlag[L"bVerbose"] = L"true";
		if( CommandLineArguments.IsExists ("v"))
		{
				// needs debug information
				// bugbug need to be remove
				bVerbose= TRUE;
				mapCreateFlag[L"bVerbose"] = L"true";
		}

		if(CommandLineArguments.IsExists ("w"))
		{
				
				// Need to convert this to DWORD value
				string wcsTemp=CommandLineArguments["w"];
				int iReadVal = _snscanf (wcsTemp.c_str(), wcsTemp.length(), "%d", & dwSleepUntilRep);	
				if ( iReadVal == EOF )
				{
					MqLog("Invalid -w argument \n");;
					PrintHelp();
					CleanOAInitAndExit();
					return(MSMQ_BVT_FAILED);
				}

			
		}
			
		if (CommandLineArguments.IsExists ("delete"))
		{
		
		   // Need to delete all the static queue in the tests.
		   bNeedRemoteMachine = false;
		   eSTtype	= ONLYUpdate ;
		   bDelete = TRUE;
		
		}
		if (CommandLineArguments.IsExists("trig"))
		{
			bTestTrigger = true;
		}
		bool bRestartTriggerService = false;
		if (CommandLineArguments.IsExists("trgrst"))
		{
			bRestartTriggerService = true;
		}
		bool bHTTPS = false;
		if (CommandLineArguments.IsExists("https"))
		{
			bHTTPS = true;
		}

		BOOL bLevel8 = FALSE ;

		if (CommandLineArguments.IsExists ("level8"))
		{
		   // Delete all BVT queue from the computer.
		   bLevel8 = TRUE;
		}
		
		if (CommandLineArguments.IsExists ("install"))
		{
		   	CmdInstallService();
			cout <<"To start Mqbvt service type : net start mqbvtsrv"<<endl;
			CleanOAInitAndExit();
			
			return MSMQ_BVT_SUCC;
		}

		if (CommandLineArguments.IsExists ("service"))
		{	
			//
			//  Need to check service status
			
			ClientCode( argc,argv );		   	
			return MSMQ_BVT_SUCC;
		}

		if (CommandLineArguments.IsExists ("remove"))
		{
			CmdRemoveService();	
			CleanOAInitAndExit();
			return MSMQ_BVT_SUCC;
		}
		//
		// Integration with requirement from Unified lab - pass test ID to log file.
		//
		wstring wcsTestId = L" ";
		if (CommandLineArguments.IsExists ("tid"))
		{
			_bstr_t  bStr (CommandLineArguments["tid"].c_str());
			wcsTestId = bStr;
		}
		bool bRegisterNewCertificate = FALSE;
		if (CommandLineArguments.IsExists ("cert"))
		{
			bRegisterNewCertificate = TRUE;
		}
		
		if (CommandLineArguments.IsExists ("timeout"))
		{
			
			// Need to convert this to DWORD value
			string wcsTemp=CommandLineArguments["timeout"];
			int iReadVal = _snscanf (wcsTemp.c_str(), wcsTemp.length(), "%d", & dwTimeOut );
			if ( iReadVal == EOF )
			{
				MqLog("Invalid -timeout argument \n");;
				PrintHelp();
				CleanOAInitAndExit();
				return MSMQ_BVT_FAILED;
			}
			dwTimeOut *= 1000;

		}
		
		if (CommandLineArguments.IsExists ("rxtime"))
		{
			
			_bstr_t  bStr (CommandLineArguments["rxtime"].c_str());
			// Need to convert this to DWORD value
			string wcsTemp=bStr;
			int iReadVal = _snscanf (wcsTemp.c_str(), wcsTemp.length(), "%d", & g_dwRxTimeOut );
			if ( iReadVal == EOF )
			{
				MqLog("Invalid -rxtime argument \n");;
				PrintHelp();
				CleanOAInitAndExit();
				return MSMQ_BVT_FAILED;
			}
			wcout <<L"Using Receive timeout of " << g_dwRxTimeOut << L" Milliseconds"  <<endl;
		}
		
		//
		// enable to debug the MQBvt with Kernel Debuger.
		//
		if (CommandLineArguments.IsExists ("pause"))
		{
			wcout << L"Press any key to continue " <<endl;
			_getch();
		}
		mapCreateFlag[L"bSingleTest"] = L"false";
		// -t:3 Number of tests
		if (CommandLineArguments.IsExists ("t"))
		{
			bSingleTest = TRUE;
			mapCreateFlag[L"bSingleTest"] = My_mbToWideChar (CommandLineArguments["t"]);
			_bstr_t  bStr (CommandLineArguments["t"].c_str());
			string wcsTemp=bStr;
			
			int iReadVal = _snscanf (wcsTemp.c_str(), wcsTemp.length(), "%d", & dwTid);
			if ( iReadVal == EOF )
			{
				MqLog("Invalid -t argument \n");;
				PrintHelp();
				CleanOAInitAndExit();
				return MSMQ_BVT_FAILED;
			}
			TestArr.bCreateTest[dwTid-1]= TRUE;
			
			
		}
		BOOL bRunOnlyStartTest=FALSE;
		if (CommandLineArguments.IsExists ("ostart"))
		{
			bRunOnlyStartTest = TRUE;
		}
		wstring wcsMultiCastAddress = g_wcsEmptyString;
		if (CommandLineArguments.IsExists ("multicast"))
		{
			_bstr_t bStr( CommandLineArguments["multicast"].c_str() );
			wcsMultiCastAddress = bStr;
		}
		bool bExcludedByUserTest[Total_Tests] = {false};		
		string strExcludeTest = "";
		if (CommandLineArguments.IsExists ("exclude"))
		{
			strExcludeTest = CommandLineArguments["exclude"];
			ExcludeTests(strExcludeTest,bExcludedByUserTest);
		}
		if (CommandLineArguments.IsExists ("assert"))
		{
			g_bRaiseASSERTOnError = false;
		}
		BOOL bUseNTLog = FALSE;
		wstring wcsNTLogPath = L"";
		if (CommandLineArguments.IsExists ("ntlog"))
		{
			_bstr_t bStr( CommandLineArguments["ntlog"].c_str() );
			wcsNTLogPath = bStr;
			string csFileName = My_WideTOmbString(wcsNTLogPath);
			pNTLogFile = NULL;
			try
			{
				pNTLogFile = new cMqNTLog(csFileName);
				bUseNTLog = TRUE;
			}
			catch (INIT_Error & err )
			{
				pNTLogFile = NULL;
				cout << err.GetErrorMessgae() << endl;
			}
		}		
		BOOL bRunOnlyCheckResult=FALSE;
		if (CommandLineArguments.IsExists ("ocheckr"))
		{
			bRunOnlyCheckResult = TRUE;
		}		 

		if( pNTLogFile == NULL )
		{
			try
			{
				string csFilePath = GetLogDirectory();
				csFilePath += "\\MqBvtLog.txt";
				pNTLogFile = new cMqNTLog(csFilePath);
				bUseNTLog = TRUE;
				printf("Mqbvt succeded to create log file@ %s\n",csFilePath.c_str());
			}
			catch( INIT_Error & err )
			{
				UNREFERENCED_PARAMETER(err);
				pNTLogFile = NULL;
			}
		}
		
		if ( bNeedRemoteMachine && wcsRemoteMachineName == g_wcsEmptyString ) // && ! eSTtype == ONLYSetup )
		{
			// Can't start the tests if there is no remote machine.
			// Option 1. Remote - Local machien & continue.
			//        2. Exit and ask for that parmeter.
			cout << "can't find - remote machine" <<endl;
			CleanOAInitAndExit();
			return MSMQ_BVT_FAILED;

		}
		
		WCHAR wcsLocalComputerName[MAX_COMPUTERNAME_LENGTH+1]={0};
		DWORD dwComputerName = MAX_COMPUTERNAME_LENGTH + 1;
		GetComputerNameW(wcsLocalComputerName,&dwComputerName);
		
		if( !bNeedRemoteMachine )
		{
			wcsRemoteMachineName = wcsLocalComputerName;
		}

		// Start the time out thread
		if ( dwTimeOut )
		{
			DWORD tid;
			// This thread will kill the process no need to wait for his finish
			HANDLE hRestrictionThread  = CreateThread(NULL , 0 , TimeOutThread , (LPVOID)(ULONG_PTR) dwTimeOut , 0, &tid);
			if( hRestrictionThread == NULL )
			{
				printf("Failed to set timeout thread, Mqbvt continue to run and ignore the timeout flag\n");
			}
		}

		//
		//  Check if the tests in avalibe
		//


		if ( bSingleTest &&  dwTid > Total_Tests )
		{
			wcout << L"Error: Test number is out of range. test numbers are available from 1 to " << Total_Tests <<endl;
			CleanOAInitAndExit();
			return MSMQ_BVT_FAILED;
		}
		
		wMqLog(L"____Run from %s to %s ID:%s____\n",wcsLocalComputerName,wcsRemoteMachineName.c_str(),wcsTestId.c_str());
			
		//
		// Init Tests parmeters like local/Remote machine name.
		//
		
		cBvtUtil cTestParms( wcsRemoteMachineName ,
                             ListOfRemoteMachineName,
							 wcsMultiCastAddress,
                             bUseFullDNSNameAsComputerName,
                             eSTtype,
							 bTestTrigger,
							 bWorkagainstMSMQ1
						   );

		if ( _winmajor >= Win2K && bRegisterNewCertificate == TRUE )
		{
			RegisterCertificate();	
			if (dwSleepUntilRep == 0)
			{
				MqLog ("You didn't wait for replication, there might be problems\n");
			}
			else
			{
				if( g_bDebug )
				{
					MqLog ("MqBvt sleep for %d\n until certificate is replicated \n",dwSleepUntilRep);
				}
				Sleep (dwSleepUntilRep);
			}
		}
		
		//
		//
		//

		if( cTestParms.bWin95 )
		{
			wcout << L"Static queues on Win9x are not supported" <<endl;
			CleanOAInitAndExit();
			return MSMQ_BVT_FAILED;
		}

	

		iStatus=SetupStage(eSTtype,cTestParms,bRestartTriggerService);

		//	
		// Delete all the queue from the test.
		// For delete static queue need to use with -s: -delete:
		//

		if( bDelete == TRUE)
		{
			INT iRes = cTestParms.Delete();
			if ( iRes == MSMQ_BVT_SUCC)
			{
				wcout << L"Mqbvt deleted all the static queues successfully" << endl;
			}
			else
			{
				cerr << "Mqbvt failed to delete all the static queues" << endl;
			}
			
			//
			// Delete all triggers and rules (if exists) 
			// 
			if( g_bRunOnWhistler )
			{
				DeleteAllTriggersAndRules();
			}
			CleanOAInitAndExit();
			if( pNTLogFile )
			{
				pNTLogFile -> ReportResult(false,"Mqbvt setup failed !!");
			}
			return MSMQ_BVT_SUCC;
		}


		if ( iStatus != MSMQ_BVT_SUCC )
		{
			wMqLog (L"Failed to update queues parameters \n Try to run Mqbvt -i again or check replication \n ");
			if( pNTLogFile )
			{
				pNTLogFile -> ReportResult(false,"Mqbvt setup failed !!");
			}
			return MSMQ_BVT_FAILED;
		}

		// This code needs only for the installation part.
		if( eSTtype  == ONLYSetup )
		{
			if( iStatus == MSMQ_BVT_SUCC )
			{
				if( pNTLogFile )
				{
					pNTLogFile -> ReportResult(true,"Mqbvt setup passed");
				}
				wMqLog (L"Mqbvt setup passed\n");;
			}
			else
			{	
				if( pNTLogFile )
				{	
					pNTLogFile -> ReportResult(false,"Mqbvt setup failed !!");
				}
				wMqLog (L"Mqbvt setup failed !!\n");
			}
			
			CleanOAInitAndExit();
			return iStatus == MSMQ_BVT_SUCC ? 0:1;
		}

		
		
		//
		// By defualt dwSleepUntilRep = 0; else need to sleep the Wait time.
		//

		
		if( dwSleepUntilRep )
		{
			 if( g_bDebug )
			 {
				cout << "Wait for replication, sleep for " << dwSleepUntilRep << " Sec"<<endl;
			 }
			 Sleep( dwSleepUntilRep * 1000 );
		}
		
		if (cTestParms.m_eMSMQConf == DepClient && g_bRunOnWhistler )
		{
			MqLog("Warning - dependet client dosn't work with -wsl flag \n");
		}
		
		//
		// Enable all tests
		//

		if( ! bSingleTest )
			if ( cTestParms.m_eMSMQConf != WKG )
				{
					for(int iTid=0; iTid < Total_Tests ; iTid ++ )
					{
						if( bExcludedByUserTest[iTid] == false ) //if tests is not excluded
						{
							TestArr.bCreateTest[iTid]= TRUE;
						}
					}
					
					
					TestArr.bCreateTest[MultiCast] = (wcsMultiCastAddress != g_wcsEmptyString) ? TRUE:FALSE;
					TestArr.bCreateTest[MqDistList] = bRunDLTest;
					TestArr.bCreateTest[Triggers] = bTestTrigger;
					TestArr.bCreateTest[HTTPS] = bHTTPS;
					TestArr.bCreateTest[DCOM] = (g_bRemoteWorkgroup == false) ? bRunDCOMTest:false;

					if( eSTtype != ONLYUpdate )
					{	
						TestArr.bCreateTest[HTTPToRemotePrivateQueue]= FALSE;
						TestArr.bCreateTest[RemotePeek]=FALSE;
						TestArr.bCreateTest[MixedFormatNames]=FALSE;
					}
					if ( cTestParms.m_eMSMQConf == DepClient)
					{
						TestArr.bCreateTest[SRMP] = FALSE;
					}
					if( iEmbeddedState == C_API_ONLY) 
					{
						iEmbeddedState = EnableEmbeddedTests(&TestArr,cTestParms.m_eMSMQConf );
					}
					else
					{	
						if( !g_bRunOnWhistler )
						{
							TestArr.bCreateTest[HTTPToLocalPrivateQueue]= FALSE;
							TestArr.bCreateTest[HTTPToLocalQueue]= FALSE;
							TestArr.bCreateTest[HTTPToRemoteQueue]= FALSE;
							TestArr.bCreateTest[HTTPToRemotePrivateQueue]= FALSE;
							TestArr.bCreateTest[EODHTTP] = FALSE;
							TestArr.bCreateTest[LOCALEODHTTP] = FALSE;
							TestArr.bCreateTest[AuthHTTP] = FALSE;
							TestArr.bCreateTest[MqDistList] = FALSE;
							TestArr.bCreateTest[MultiCast] = FALSE;
							TestArr.bCreateTest[Triggers] = FALSE;
							TestArr.bCreateTest[HTTPS] = FALSE;
							TestArr.bCreateTest[Mqf] = FALSE;
							TestArr.bCreateTest[SRMP] = FALSE;
							TestArr.bCreateTest[RemotePeek] = FALSE;
							TestArr.bCreateTest[MixedFormatNames]=FALSE;

						}
					}

				}
		else
		{
				//
				// WorkGroup tests to run
				//
				// 1. Local private queue.
				// 4. GetMachineProp
				// 9. Remote read from private queue using direct format name
				// 13. Open system queue.
				//
				TestArr.bCreateTest[SendLocalPrivate] = TRUE;
				TestArr.bCreateTest[GetMachineProp] = TRUE;
				TestArr.bCreateTest[SendRemotePublicWithDirectFN] = TRUE;
				TestArr.bCreateTest[OpenSystemQueue]= TRUE;
				TestArr.bCreateTest[RemoteTransactionQueue] = TRUE;
				TestArr.bCreateTest[AdminAPI] = TRUE;
				TestArr.bCreateTest[DCOM] = (g_bRemoteWorkgroup == false) ? bRunDCOMTest:false;;
	
				if( g_bRunOnWhistler )
				{
					TestArr.bCreateTest[HTTPToLocalPrivateQueue] = TRUE;
					TestArr.bCreateTest[Mqf] = TRUE;
					TestArr.bCreateTest[HTTPToRemotePrivateQueue]= TRUE;
					TestArr.bCreateTest[EODHTTP] = TRUE;
					TestArr.bCreateTest[LOCALEODHTTP] = TRUE;
					if( bTestTrigger && eSTtype != RunTimeSetup )
					{
						TestArr.bCreateTest[Triggers] = TRUE;
					}
				}
				if( iEmbeddedState == C_API_ONLY) 
				{
					iEmbeddedState = EnableEmbeddedTests(&TestArr,cTestParms.m_eMSMQConf);
				}				
				if( eSTtype != ONLYUpdate )
				{	
					TestArr.bCreateTest[HTTPToRemotePrivateQueue]= FALSE;
				}

		}
	
	

		if( bWithoutHttp )
		{
			//
			// if machine configured without IIS
			//
			TestArr.bCreateTest[HTTPToLocalPrivateQueue]= FALSE;
			TestArr.bCreateTest[HTTPToLocalQueue]= FALSE;
			TestArr.bCreateTest[HTTPToRemoteQueue]= FALSE;
			TestArr.bCreateTest[HTTPToRemotePrivateQueue]= FALSE;
			TestArr.bCreateTest[EODHTTP] = FALSE;
			TestArr.bCreateTest[LOCALEODHTTP] = FALSE;
			TestArr.bCreateTest[AuthHTTP] = FALSE; 	
			TestArr.bCreateTest[SRMP] = FALSE; 	
		}
		//
		// Need to run only on NT4 sp6
		//
		
		TestArr.bCreateTest[RemoteTransactionQueueUsingCapi] = ( bServicePack6 == TRUE ) ? TRUE : FALSE;

		//
		// Can't run against MSMQ1
		//
		
		if ( bWorkagainstMSMQ1 == TRUE || _winmajor == 4 )
		{
			TestArr.bCreateTest[OpenSystemQueue] = FALSE;
		}
		//
		// Work only with static queue mode on NT5 only.
		//
		if( eSTtype == RunTimeSetup ||  _winmajor ==  4 )
		{
			TestArr.bCreateTest[SendRemotePublicWithDirectFN] = FALSE;
			if ( bServicePack6 == TRUE )
				TestArr.bCreateTest[SendRemotePublicWithDirectFN] = TRUE;
		}
		
		//
		// Local user dosn't support those tests.
		//

		if( cTestParms.m_eMSMQConf == LocalU ||  cTestParms.m_eMSMQConf == DepClientLocalU )
		{
			TestArr.bCreateTest[LocalAuth] = FALSE;
			TestArr.bCreateTest[RemoteAuth] = FALSE;
		}
		//
		// test that dosen't work in NT4
		if( ! bNT4RegisterCertificate &&  _winmajor ==  NT4 )
		{			
			MqLog("Disable authentication test on NT4/ Win9x \n -C will enable this\n");
			TestArr.bCreateTest[LocalAuth] = FALSE;	
			TestArr.bCreateTest[RemoteAuth]= FALSE;	
		}

		if ( _winmajor >= Win2K  && bWorkagainstMSMQ1 == TRUE && eSTtype == ONLYUpdate )
		{	
			
			//
			// W2K against nt4 pec disable remote read using direct format name.
			//

			TestArr.bCreateTest[SendRemotePublicWithDirectFN] = FALSE;

		}
	
		CreateSetOfTests(&TestArr,cTestParms,mapCreateFlag,TestResult,eSTtype,iEmbeddedState,wcsMultiCastAddress);

		//
		// This tests is related to level 8 problem
		//
		if( bLevel8 )
		{
			map <wstring,wstring> Level8Map;

			Level8Map[L"DESTQFN"]=cTestParms.ReturnQueueFormatName(L"Authnticate Q");
			Level8Map[L"ADMINFN"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");

			cLevel8 Level8Test(Level8Map);
			Level8Test.Start_test();
			return MSMQ_BVT_SUCC;
		}

		 dwRetCode = RunTest( & TestArr , cTestParms , mapCreateFlag, g_bRunAsMultiThreads,bInvestigate,dwSleepUntilRep);
		 if( dwRetCode == MSMQ_BVT_FAILED && bInvestigate == true )
		 {
			 //
			 // Re-Run the failed tests again with debug information enabled.
			 // 
			 MqLog("--- Test failed re-run failed test with debug enabled\n");
			 g_bDebug = true;
			 DWORD dwRes = RunTest(&TestArr,cTestParms,mapCreateFlag,g_bRunAsMultiThreads,bInvestigate,dwSleepUntilRep);
			 if ( dwRes != dwRetCode )
			 {
				 dwRetCode = MSMQ_BVT_WARN;
			 }
		 }
					
	}
	catch(INIT_Error & err )
	{
		try
		{	
			MqLog("%s\n",err.GetErrorMessgae());
			wMqLog (L"Mqbvt failed !!\n");
			cerr <<	"Mqbvt failed !! " <<endl;
			CHAR csLine[]="Mqbvt failed!";
			if( pNTLogFile )
			{
				pNTLogFile -> ReportResult(false,csLine);
			}
		}
		catch (...)
		{
			MqLog("Exception inside catch ... \n" );
			throw;
		}

		CleanOAInitAndExit();
		return MSMQ_BVT_FAILED;
	}
	catch(...)
	{
		MqLog("Mqbvt got unexpected exception\n");
		throw;
	}

	CleanOAInitAndExit();
	return dwRetCode;
	
}

//
// CleanOAInitAndExit -
// this function release all the OA information before call the
// OleUninitialize.
//
//


void CleanOAInitAndExit()
{
	for ( INT Index = 0 ; Index < Total_Tests ; Index ++ )
	{
		if( TestArr.bCreateTest[Index] == TRUE )
		{
			delete (TestArr.AllTests[Index]).detach();
		}
	
	}
	if( SUCCEEDED(g_hrOLEInit) )
	{
		CoUninitialize();
	}

}

void PrintHelp ()
{
	wcout <<L"Mqbvt is the BVT for Microsoft Message Queue" <<endl;
	wcout <<L" -d	   Enable debug information." <<endl;
	wcout <<L" -i        Create static queue." <<endl;
	wcout <<L" -v        verbose." <<endl;
	wcout <<L" -r:       <remote machine name > " <<endl;
	wcout <<L" -g        remote machine is workgroup " <<endl;
	wcout <<L" -s        Work with static queues. " <<endl;
	wcout <<L" -w:       < Sleep time in sec >  Sleep time while waiting for replication." <<endl;
	wcout <<L" -C:       run security test on NT4 client." <<endl;
	wcout <<L" -mt       Multithread enable" <<endl;
	wcout <<L" -wsl		 Support for whistler." <<endl;
	wcout <<L" -rxtime:  < Time in MilliSec >  Receive timeout." <<endl;
	wcout <<L" -timeout: < Time in Sec >  Maximum time to run." <<endl;
	wcout <<L" -delete:  delete the static queues." <<endl;
	wcout <<L" -dns      always use full dns name as machine names." <<endl;
	wcout <<L" -nt4      Works against MSMQ1.0 MQIS server." <<endl;
	wcout <<L" -sp6      Enable new tests for msmq service pack 6" <<endl;
	wcout <<L" -pause    < Time in Sec >  Press key to run test." <<endl;
	wcout <<L" -t:#number  Specific test number " <<endl;
	wcout <<L" -ntlog:    Specify file name     " <<endl;
	wcout <<L" -cert     always Create new certificate" <<endl;
	wcout <<L" -dcom     Enable dcom test" <<endl;
	wcout <<L" -install	 install Mqbvt service" <<endl;
	wcout <<L" -remove	 Remove Mqbvt service" <<endl;
	wcout <<L" -service  use to pass parameters to the Mqbvt service" <<endl;
	wcout <<L" -exclude: 1,2,3 (disable set of tests) " <<endl;
	wcout <<L" -dl       use dl object" <<endl;
	wcout <<L" -nohttp     don't use http test" <<endl;
	wcout <<L" -trig     triggers functionality test. note that you need to start and stop the service after initialization phase" <<endl;
	wcout <<L"Example" <<endl;
	wcout <<L"Setup: Mqbvt -i [-wsl -multicast:234.1.2.3] " <<endl;
	wcout <<L"Runing using static queue: Mqbvt -r:eitan5 -s [-wsl -multicast:234.1.2.3]" <<endl;
	wcout <<L"How to run as a service" <<endl;
	wcout <<L"To run the service use Net start mqbvtsrv"<<endl;
	wcout <<L"Mqbvt.exe -service -r:eitan5 -s"<<endl;
	wcout <<L"Mqbvt.exe -r:eitan5 -s -ntlog:c:\\Temp\\Mqbvt.log"<<endl;
	
}





//
// Handle CTRL+C / CTRL Break
// Call tests distractors.
//


BOOL
WINAPI fHandleCtrlRoutine(
		DWORD  dwCtrlType )		//  control signal type
{

	UNREFERENCED_PARAMETER(dwCtrlType);
	MqLog ("Mqbvt , Is now exiting \n");
	CS Lock(g_Cs);	
	CleanOAInitAndExit();
	exit (MSMQ_BVT_FAILED);
}
//****************************************************************
//
// CreateSetOfTests this function allocate all the tests
// Input paramters:
// 1. TestContainer * TestArr - Container for all the tests.
// 2. cBvtUtil & cTestParms - Test paramters
// 3. map <wstring,wstring> & mapCreateFlag - additional arguments to function
// List of additional arguments
//	
// mapCreateFlag[L"W2KAgainstNT4PEC"] = true / false - Specify if the supporting server is NT4/
// mapCreateFlag[L"bUseFullDNSNameAsComputerName"] = true / false - mean use full dns name as computer name
// mapCreateFlag[L"bServicePack6"]
// mapCreateFlag[L"bVerbose"] =
// mapCreateFlag[L"bSingleTest"] = TidNumber
//
//
// return value:
//
// dwNumberOfTest - number of tests.
//


bool  CreateSetOfTests( TestContainer * TestArr ,
						cBvtUtil & cTestParms ,
						map <wstring,wstring> & mapCreateFlag,
						DWORD * TestResult,
						SetupType eStBflag,
						int iEmbeddedState,
						wstring wcsMultiCastAddress
					  )
{
	DWORD dwNumberOfTest = 0;
	bool bSucc=true;	
	map <wstring,wstring> mapSendRecive1,mapSendRecive2,mapSendRecive3,map_MachineName,map_xxxFormatName,mapLocateParm;
		
		try
		{
			// tests 1 Send Receive from private Queue
			if( TestArr -> bCreateTest[ dwNumberOfTest ] )
			{
				mapSendRecive1[L"DESTQFN"]=cTestParms.ReturnQueueFormatName(L"Defualt PrivateQ");
				mapSendRecive1[L"ADMINFN"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mapSendRecive1[L"DestQName"]=cTestParms.ReturnQueuePathName(L"Defualt PrivateQ");
				mapSendRecive1[L"MachName"]=cTestParms.m_wcsCurrentLocalMachine;
				TestArr ->AllTests[dwNumberOfTest]=new cSendMessages(dwNumberOfTest ,mapSendRecive1);
			}
				
			
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Send receive message to private queue)\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;
		// tests 2 Send Receive from public local queue.
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mapSendRecive2[L"DESTQFN"]=cTestParms.ReturnQueueFormatName(L"Regular PublicQ");
				mapSendRecive2[L"ADMINFN"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mapSendRecive2[L"DestQName"]=cTestParms.ReturnQueuePathName(L"Regular PublicQ");
				mapSendRecive2[L"MachName"]=cTestParms.m_wcsCurrentLocalMachine;
				
				TestArr ->AllTests[dwNumberOfTest]=new cSendMessages(dwNumberOfTest ,mapSendRecive2);
			}	
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Send receive message to local public queue)\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;
		
		// tests 3 Send Receive from public remote queue.
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mapSendRecive3[L"DESTQFN"]=cTestParms.ReturnQueueFormatName(L"Remote Read Queue");
				mapSendRecive3[L"ADMINFN"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mapSendRecive3[L"DestQName"]=cTestParms.ReturnQueuePathName(L"Remote Read Queue");
				mapSendRecive3[L"MachName"]=cTestParms.m_wcsCurrentRemoteMachine;
				mapSendRecive3[L"UseOnlyDirectFN"] = L"TRUE";
				if ( mapCreateFlag[L"W2KAgainstNT4PEC"] == L"true")  //  bWorkagainstMSMQ1
				{
					mapSendRecive3[L"UseOnlyDirectFN"] = L"FALSE";
				}
				TestArr ->AllTests[dwNumberOfTest]=new cSendMessages(dwNumberOfTest , mapSendRecive3);
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Send receive message to Remote public queue)\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;
		try
		{
			if (TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mapLocateParm[L"QCommonLabel"]=cTestParms.m_wcsLocateGuid;
				mapLocateParm[L"UseFullDNSName"] = L"No";
				mapLocateParm[L"CurrentMachineName"] = cTestParms.m_wcsCurrentLocalMachine;
				mapLocateParm[L"CurrentMachineNameFullDNS"] = cTestParms.m_wcsLocalComputerNameFullDNSName;
				mapLocateParm[L"NT4SuportingServer"] = L"false";
				if ( mapCreateFlag[L"W2KAgainstNT4PEC"] == L"true" || 
				    ( g_bRunOnWhistler && cTestParms.GetWorkingAgainstPEC() == TRUE))  //  bWorkagainstMSMQ1
				{
					mapLocateParm[L"NT4SuportingServer"] = L"true";
				}
				
				if( mapCreateFlag[L"bUseFullDNSNameAsComputerName"] == L"true" )
				{
					mapLocateParm[L"UseFullDNSName"]=L"Yes";
				}	
				mapLocateParm[L"UseStaticQueue"] = L"UseStaticQueue";
				if( eStBflag == RunTimeSetup )
				{
					mapLocateParm[L"UseStaticQueue"] = L"No";
				}
				mapLocateParm[L"SkipOnComApi"] = L"No";
				if (iEmbeddedState == C_API_ONLY )
				{
					mapLocateParm[L"SkipOnComApi"] = L"Yes";
				}
				TestArr ->AllTests[dwNumberOfTest]=new cLocateTest(dwNumberOfTest , mapLocateParm);
				
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Locate queues )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;
		
		
		// tests 5 MachineProperty
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				map_MachineName [L"LMachine"] = cTestParms.m_wcsLocalComputerNetBiosName;
				map_MachineName [L"LMachineFDNS"] = cTestParms.m_wcsLocalComputerNameFullDNSName;
				map_MachineName [L"RMachine"] = cTestParms.m_wcsRemoteComputerNetBiosName;
				map_MachineName [L"RMachineFDNS"]= cTestParms.m_wcsRemoteMachineNameFullDNSName;

				//
				//  Need to know if supporting service is NT4
				//
				map_MachineName[L"MSMQ1Limit"] = mapCreateFlag[L"W2KAgainstNT4PEC"];
				map_MachineName [L"UseFullDns"]= L"No";				
				map_MachineName [L"IsCluster"] = cTestParms.IsCluster() ? L"true":L"NoNoCluster";

				if( _winmajor >=  Win2K && mapCreateFlag[L"W2KAgainstNT4PEC"] == L"false" )
				{
				   map_MachineName [L"UseFullDns"]= L"Yes";
				}
				if( g_bRunOnWhistler && cTestParms.GetWorkingAgainstPEC())
				{
					map_MachineName [L"MSMQ1Limit"]= L"true";
				}
				TestArr ->AllTests[dwNumberOfTest]=new MachineName( dwNumberOfTest , map_MachineName );
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( GetMachine Propery )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}

		dwNumberOfTest ++;
		//
		// tests 6 xToFormatName
		//
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				
				if( cTestParms.m_eMSMQConf == WKG )
				{
					map_xxxFormatName [L"Wkg"]=L"Wkg";
				}

				map_xxxFormatName [L"PrivateDestFormatName"] = cTestParms.ReturnQueueFormatName(L"Defualt PrivateQ");
				map_xxxFormatName [L"PrivateDestPathName"] = cTestParms.ReturnQueuePathName(L"Defualt PrivateQ");
				map_xxxFormatName [L"DestFormatName"] = cTestParms.ReturnQueueFormatName(L"Regular PublicQ");
				map_xxxFormatName [L"DestPathName"] = cTestParms.ReturnQueuePathName(L"Regular PublicQ");
				if( g_bRunOnWhistler )
				{
					map_xxxFormatName [L"WorkingAgainstPEC"] = cTestParms.GetWorkingAgainstPEC() ? L"Yes":L"No";
				}
				map_xxxFormatName[L"SkipOnComApi"] = L"No";
				if (iEmbeddedState == C_API_ONLY )
				{
					map_xxxFormatName[L"SkipOnComApi"] = L"Yes";
				}
				TestArr ->AllTests[dwNumberOfTest]=new xToFormatName(dwNumberOfTest , map_xxxFormatName );
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( xToFormatName )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}

		dwNumberOfTest ++;

		// tests 7 Security Authntication !!!.

		map <wstring,wstring> mapAuth , DTCMap , Encrypt;
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mapAuth[L"DestFormatName"]  = cTestParms.ReturnQueueFormatName(L"Authnticate Q");
				mapAuth[L"AdminFormatName"] = cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mapAuth[L"DestQueuePathName"] = cTestParms.ReturnQueuePathName(L"Authnticate Q");
				wstring temp = cTestParms.ReturnQueuePathName(L"Authnticate Q");
				TestArr ->AllTests[dwNumberOfTest]= new SecCheackAuthMess( dwNumberOfTest ,mapAuth);
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Authentication )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}

		
		dwNumberOfTest ++;
		
		//
		// Test 8 Privacy level ...  Encrepted messages
		//
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				Encrypt[L"DestFormatName"] = cTestParms.ReturnQueueFormatName(L"privQ");
				Encrypt[L"AdminFormatName"] = cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				Encrypt[L"Enh_Encrypt"] = L"False";
				if( _winmajor >= Win2K && cTestParms.GetEncryptionType() ==  Enh_Encrypt && mapCreateFlag[L"W2KAgainstNT4PEC"] == L"false" )
				{
					Encrypt[L"Enh_Encrypt"] = L"True";
				}
				TestArr ->AllTests[dwNumberOfTest]= new PrivateMessage( dwNumberOfTest ,Encrypt );
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Encryption  )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;

		//
		// Transaction tests.
		// trans Test
		
		map <wstring,wstring> RmapAuth,mapTrans, mapSendReciveDirectPrivateQ,SendTransUsingComI,TOpenQueues,LEncrypt;
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mapTrans[L"DestQFormatName1"]= cTestParms.ReturnQueueFormatName(L"TransQ1");
				mapTrans[L"DestQFormatName2"]= cTestParms.ReturnQueueFormatName(L"TransQ2");
				
				// bugbug need to load dtc on w2k depe client
				bool bStartDtc = FALSE;
				if( cTestParms.m_eMSMQConf == DepClient && _winmajor >=   Win2K)
				{
					bStartDtc=TRUE;
				}
				
				TestArr ->AllTests[dwNumberOfTest]= new cTrans( dwNumberOfTest , mapTrans , bStartDtc );
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Tranacation  )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;

		//
		// Send receive tests using direct format name
		//
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mapSendReciveDirectPrivateQ[L"DestQName"]=cTestParms.ReturnQueuePathName(L"Defualt PrivateQ");
				mapSendReciveDirectPrivateQ[L"DESTQFN"]=cTestParms.ReturnQueueFormatName(L"Defualt PrivateQ");
				mapSendReciveDirectPrivateQ[L"ADMINFN"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mapSendReciveDirectPrivateQ[L"UseOnlyDirectFN"]=L"TRUE";
				mapSendReciveDirectPrivateQ[L"MachName"]=cTestParms.m_wcsCurrentRemoteMachine;
				TestArr ->AllTests[dwNumberOfTest]=new cSendMessages(dwNumberOfTest ,mapSendReciveDirectPrivateQ);
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Transaction )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;
		
		// Test 9 use Check if MQOA registered..
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				TestArr ->AllTests[dwNumberOfTest]= new isOARegistered ( dwNumberOfTest );
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Is MqOA registered? )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;

		//
		// Send transaction message to remote queue using DTC via com interface
		//
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				
				if ( cTestParms.m_eMSMQConf == WKG )
				{
					// Use private queue.
					SendTransUsingComI[L"FormatName"]=cTestParms.ReturnQueueFormatName(L"Private Transaction");
				}
				else
				{
					// Use public queue.
					SendTransUsingComI[L"FormatName"]=cTestParms.ReturnQueueFormatName(L"Remote Transaction queue");
				}
				SendTransUsingComI[L"Sp6"]=L"NO";
				SendTransUsingComI[L"Desc"] = L"remote";
				TestArr ->AllTests[dwNumberOfTest]= new xActViaCom ( dwNumberOfTest , SendTransUsingComI);
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Remote Transaction )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;

		//
		// System queue open tests
		//
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				TOpenQueues[L"LocalMachineName"] = cTestParms.m_wcsCurrentLocalMachine;
				TOpenQueues[L"RemoteMachineName"] = cTestParms.m_wcsCurrentRemoteMachine;
				TOpenQueues[L"LocalMachineNameGuid"] = cTestParms.m_wcsMachineGuid;
				TOpenQueues[L"RemoteMachineNameGuid"] = cTestParms.m_wcsRemoteMachineGuid ;
				TOpenQueues[L"Wkg"]=L"";
				if( cTestParms.m_eMSMQConf == WKG )
				{
					TOpenQueues[L"Wkg"]=L"Wkg";
				}
				TOpenQueues[L"SkipOnComApi"] = L"No";
				if (iEmbeddedState == C_API_ONLY )
				{
					TOpenQueues[L"SkipOnComApi"] = L"Yes";
				}
		   		TestArr ->AllTests[dwNumberOfTest]= new COpenQueues ( dwNumberOfTest , TOpenQueues);
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Open System queue )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;

		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				LEncrypt[L"DestFormatName"] = cTestParms.ReturnQueueFormatName(L"Local encrypt");
				LEncrypt[L"AdminFormatName"] = cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				LEncrypt[L"Enh_Encrypt"] = L"False";
				if( _winmajor >=   Win2K && cTestParms.GetEncryptionType() ==  Enh_Encrypt )
					LEncrypt[L"Enh_Encrypt"] = L"True";
				TestArr ->AllTests[dwNumberOfTest]= new PrivateMessage( dwNumberOfTest ,LEncrypt );			
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( local Encryption  )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;

	
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{

				RmapAuth[L"DestFormatName"]  = cTestParms.ReturnQueueFormatName(L"Remote authenticate");
				RmapAuth[L"AdminFormatName"] = cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				wstring temp = cTestParms.ReturnQueuePathName(L"Authnticate Q");
				TestArr ->AllTests[dwNumberOfTest]= new SecCheackAuthMess( dwNumberOfTest ,RmapAuth);
			
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Authentication )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;
		//
		// transaction boundaries - for service pack 6
		//
		map <wstring , wstring > RemoteTransaction;

		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				RemoteTransaction[L"FormatName"]=cTestParms.ReturnQueueFormatName(L"Remote Transaction queue");
				RemoteTransaction[L"Sp6"]=L"NO";
				if( mapCreateFlag[L"bServicePack6"]  == L"true" )
				{
					RemoteTransaction[L"Sp6"]=L"YES";
				}
				TestArr ->AllTests[dwNumberOfTest]= new xActUsingCapi ( dwNumberOfTest , RemoteTransaction );
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Remote Transaction )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		


		dwNumberOfTest ++;
		//
		// MqFsupport
		//
		map <wstring , wstring > mMqFTestParams;
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mMqFTestParams[L"FormatName"]=cTestParms.ReturnQueueFormatName(L"Remote Transaction queue");
				mMqFTestParams[L"Sp6"]=L"NO";
				mMqFTestParams[L"AdminQFormatName"] = cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				if ( eStBflag == RunTimeSetup )
				{
					mMqFTestParams[L"q1"]=cTestParms.ReturnQueueFormatName(L"MQCast1");
					mMqFTestParams[L"q2"]=cTestParms.ReturnQueueFormatName(L"MQCast2");
					mMqFTestParams[L"q3"]=cTestParms.ReturnQueueFormatName(L"MQCast3");
					mMqFTestParams[L"SearchForQueue"]=L"Yes";
				}
				
				TestArr ->AllTests[dwNumberOfTest]= new MqF ( dwNumberOfTest , mMqFTestParams ,cTestParms.m_listOfRemoteMachine,cTestParms.m_eMSMQConf,cTestParms.m_eMSMQConf == WKG);
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Mqf support )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;


		//
		// SendReceive using direct http = format name to private local queue
		//
		map<std::wstring,std::wstring> mSendReciveUsingHTTPToLocalPrivate,
									   mSendLocalPublicUsingHTTPToLocalQueue,
									   mSendLocalPublicUsingHTTPToRemoteQueue,
									   mSendRemPrivateQueueUsingHTTP;
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mapSendReciveDirectPrivateQ[L"DestQName"]=cTestParms.ReturnQueuePathName(L"Defualt PrivateQ");
				mapSendReciveDirectPrivateQ[L"DESTQFN"]=cTestParms.ReturnQueueFormatName(L"Defualt PrivateQ");
				mapSendReciveDirectPrivateQ[L"ADMINFN"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mapSendReciveDirectPrivateQ[L"AdminQueuePathName"]= cTestParms.ReturnQueuePathName(L"Private Admin Q");
				mapSendReciveDirectPrivateQ[L"UseDirectHTTP"]=L"TRUE";
				mapSendReciveDirectPrivateQ[L"LocalMachName"] = mapSendReciveDirectPrivateQ[L"MachName"]= cTestParms.m_wcsCurrentLocalMachine;
				TestArr ->AllTests[dwNumberOfTest]=new cSendMessages(dwNumberOfTest ,mapSendReciveDirectPrivateQ);
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Send to local private queue using HTTP )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;


		//
		// SendReceive using direct http = format name to public local queue
		//

		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mSendLocalPublicUsingHTTPToLocalQueue[L"DestQName"]=cTestParms.ReturnQueuePathName(L"Regular PublicQ");
				mSendLocalPublicUsingHTTPToLocalQueue[L"DESTQFN"]=cTestParms.ReturnQueueFormatName(L"Regular PublicQ");
				mSendLocalPublicUsingHTTPToLocalQueue[L"ADMINFN"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mSendLocalPublicUsingHTTPToLocalQueue[L"AdminQueuePathName"]= cTestParms.ReturnQueuePathName(L"Private Admin Q");
				mSendLocalPublicUsingHTTPToLocalQueue[L"UseDirectHTTP"]=L"TRUE";
				mSendLocalPublicUsingHTTPToLocalQueue[L"LocalMachName"] = mSendLocalPublicUsingHTTPToLocalQueue[L"MachName"]=cTestParms.m_wcsCurrentLocalMachine;
				
				TestArr ->AllTests[dwNumberOfTest]=new cSendMessages(dwNumberOfTest ,mSendLocalPublicUsingHTTPToLocalQueue);
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Send to local public queue using HTTP )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;

		//
		// SendReceive using direct http = to remote public format name.
		//
		
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mSendLocalPublicUsingHTTPToRemoteQueue[L"UseDirectHTTP"]=L"TRUE";
				
				mSendLocalPublicUsingHTTPToRemoteQueue[L"DestQName"]=cTestParms.ReturnQueuePathName(L"Defualt PrivateQ");
				mSendLocalPublicUsingHTTPToRemoteQueue[L"DestQName"]=cTestParms.ReturnQueuePathName(L"Remote Read Queue");
				mSendLocalPublicUsingHTTPToRemoteQueue[L"DESTQFN"]=cTestParms.ReturnQueueFormatName(L"Remote Read Queue");
				mSendLocalPublicUsingHTTPToRemoteQueue[L"ADMINFN"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mSendLocalPublicUsingHTTPToRemoteQueue[L"AdminQueuePathName"]= cTestParms.ReturnQueuePathName(L"Private Admin Q");
				mSendLocalPublicUsingHTTPToRemoteQueue[L"MachName"]=cTestParms.m_wcsCurrentRemoteMachine;
				mSendLocalPublicUsingHTTPToRemoteQueue[L"LocalMachName"]=cTestParms.m_wcsCurrentLocalMachine;
				
				TestArr ->AllTests[dwNumberOfTest]=new cSendMessages(dwNumberOfTest ,mSendLocalPublicUsingHTTPToRemoteQueue);
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Send to public remote queue using HTTP )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;
		
		
		//
		// Send message to remote machine using direct http format name
		//

		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{

				mSendRemPrivateQueueUsingHTTP[L"DestQName"]=cTestParms.ReturnQueuePathName(L"Defualt PrivateQ");
				mSendRemPrivateQueueUsingHTTP[L"DESTQFN"]=cTestParms.ReturnQueueFormatName(L"Defualt PrivateQ");
				mSendRemPrivateQueueUsingHTTP[L"ADMINFN"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mSendRemPrivateQueueUsingHTTP[L"UseOnlyDirectFN"]=L"TRUE";
				mSendRemPrivateQueueUsingHTTP[L"UseDirectHTTP"]=L"TRUE";	
				mSendRemPrivateQueueUsingHTTP[L"AdminQueuePathName"]= cTestParms.ReturnQueuePathName(L"Private Admin Q");
				mSendRemPrivateQueueUsingHTTP[L"MachName"]=cTestParms.m_wcsCurrentRemoteMachine;
				mSendRemPrivateQueueUsingHTTP[L"LocalMachName"]=cTestParms.m_wcsCurrentLocalMachine;

				TestArr ->AllTests[dwNumberOfTest]=new cSendMessages(dwNumberOfTest ,mSendRemPrivateQueueUsingHTTP);
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Send to private remote queue using HTTP )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}

		dwNumberOfTest ++;
		//
		// MqDl
		//
		map <wstring , wstring > mMqDlTestParameters;
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mMqDlTestParameters[L"FormatName"]=cTestParms.ReturnQueueFormatName(L"Remote Transaction queue");
				mMqDlTestParameters[L"Sp6"]=L"NO";
				mMqDlTestParameters[L"AdminQFormatName"]=cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mMqDlTestParameters[L"PublicAdminQueue"]=cTestParms.ReturnQueueFormatName(L"DL Admin Queue");
				if ( eStBflag == RunTimeSetup )
				{
					mMqDlTestParameters[L"q1"]=cTestParms.ReturnQueueFormatName(L"MqDL1");
					mMqDlTestParameters[L"q2"]=cTestParms.ReturnQueueFormatName(L"MqDL2");
					mMqDlTestParameters[L"q3"]=cTestParms.ReturnQueueFormatName(L"MqDL3");
					mMqDlTestParameters[L"SearchForQueue"]=L"Yes";
				}

				TestArr ->AllTests[dwNumberOfTest]= new cSendUsingDLObject ( dwNumberOfTest , mMqDlTestParameters ,cTestParms.m_listOfRemoteMachine,cTestParms.m_eMSMQConf);
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Mqf support )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}

		dwNumberOfTest ++;


		try
		{	
			map <wstring , wstring > mSetQueueProps;
			mSetQueueProps.clear();
			if( cTestParms.m_eMSMQConf == WKG )
			{
				mSetQueueProps[L"Wkg"]=L"Wkg";
			}
			else
			{
				mSetQueueProps[L"Wkg"]=L"xxx";
				mSetQueueProps[L"FormatName"] = cTestParms.ReturnQueueFormatName(L"Regular PublicQ");
			}
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				TestArr ->AllTests[dwNumberOfTest]= new cSetQueueProp ( dwNumberOfTest,mSetQueueProps );
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( MqSetGetQueue support )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}

		dwNumberOfTest ++;

		//
		// Send transaction message to remote queue using HTTP format name using COM interface.
		//
		try
		{
			map <wstring , wstring > mEODTestParams;
			mEODTestParams.clear();
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{			
				if ( cTestParms.m_eMSMQConf == WKG )
				{
					mEODTestParams[L"FormatName"] = cTestParms.CreateHTTPFormatNameFromPathName(cTestParms.ReturnQueuePathName(L"Private Transaction"),FALSE);
				}
				else
				{
					// Use public queue.
					mEODTestParams[L"FormatName"] = cTestParms.CreateHTTPFormatNameFromPathName(cTestParms.ReturnQueuePathName(L"Remote Transaction queue"),FALSE);
				}
				mEODTestParams[L"Desc"] = L"remote";
				mEODTestParams[L"Sp6"]=L"NO";
				TestArr ->AllTests[dwNumberOfTest]= new xActViaCom ( dwNumberOfTest , mEODTestParams);
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			UNREFERENCED_PARAMETER(err);
			wMqLog(L"Failed create tests %d ( Remote Transaction )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
	
		dwNumberOfTest ++;
		//
		// Send message using multicast address.
		//
	
		map<wstring,wstring> mMultiCast;
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mMultiCast[L"AdminQFormatName"] = cTestParms.ReturnQueueFormatName(L"Private Admin Q");
				mMultiCast[L"MultiCastAddress"] = wcsMultiCastAddress;
				mMultiCast[L"SearchForQueue"]=L"No";
				if ( eStBflag == RunTimeSetup )
				{
					mMultiCast[L"q1"]=cTestParms.ReturnQueueFormatName(L"MQCast1");
					mMultiCast[L"q2"]=cTestParms.ReturnQueueFormatName(L"MQCast2");
					mMultiCast[L"q3"]=cTestParms.ReturnQueueFormatName(L"MQCast3");
					mMultiCast[L"SearchForQueue"]=L"Yes";
				}

				TestArr ->AllTests[dwNumberOfTest]= new CMultiCast ( dwNumberOfTest , mMultiCast ,cTestParms.m_listOfRemoteMachine,cTestParms.m_eMSMQConf);
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			UNREFERENCED_PARAMETER(err);
			wMqLog(L"Failed create tests %d ( multi cast support )\n",dwNumberOfTest+1);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}

		dwNumberOfTest ++;
		//
		// Check HTTP authtication level.
		//
		try
		{
			map<wstring,wstring> mHTTPAuth;
			mHTTPAuth.clear();
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mHTTPAuth[L"DestFormatName"]  = cTestParms.CreateHTTPFormatNameFromPathName(cTestParms.ReturnQueuePathName(L"Remote authenticate"),FALSE);
				mHTTPAuth[L"AdminFormatName"] = cTestParms.CreateHTTPFormatNameFromPathName(cTestParms.ReturnQueuePathName(L"Private Admin Q"),FALSE);
				mHTTPAuth[L"FormatNameType"] = L"Http";
				TestArr ->AllTests[dwNumberOfTest]= new SecCheackAuthMess( dwNumberOfTest ,mHTTPAuth);
			
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			UNREFERENCED_PARAMETER(err);
			wMqLog(L"Failed create tests %d ( http Authentication )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;


		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				TestArr ->AllTests[dwNumberOfTest]= new CMqTrig(dwNumberOfTest, cTestParms);			
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			UNREFERENCED_PARAMETER(err);
			wMqLog(L"Failed create tests %d ( Trigger test )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;

		try
		{
			map<wstring,wstring> mHTTPSConnection;
			mHTTPSConnection.clear();
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{

				mHTTPSConnection[L"DestFormatName"]  = cTestParms.CreateHTTPFormatNameFromPathName(cTestParms.ReturnQueuePathName(L"Remote authenticate"),TRUE);
				if ( cTestParms.m_eMSMQConf == WKG )
				{
				   mHTTPSConnection[L"DestFormatName"]  = cTestParms.CreateHTTPFormatNameFromPathName(cTestParms.ReturnQueuePathName(L"Remote Read Queue"),TRUE);
				}

				mHTTPSConnection[L"AdminFormatName"] = cTestParms.CreateHTTPFormatNameFromPathName(cTestParms.ReturnQueuePathName(L"Private Admin Q"),TRUE);
				mHTTPSConnection[L"FormatNameType"] = L"Http";
				TestArr ->AllTests[dwNumberOfTest]= new SecCheackAuthMess( dwNumberOfTest ,mHTTPSConnection);			
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;	
			UNREFERENCED_PARAMETER(err);
			wMqLog(L"Failed create tests %d ( HTTPS )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;

		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				TestArr ->AllTests[dwNumberOfTest]= new CMqAdminApi( dwNumberOfTest , cTestParms.m_wcsLocalComputerNetBiosName);			
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			UNREFERENCED_PARAMETER(err);
			wMqLog(L"Failed create tests %d ( Admin API Test )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;

		try
		{
			wstring wcsPublicQueueFormatName;
			if( TestArr->bCreateTest[ dwNumberOfTest ] )
			{
				wcsPublicQueueFormatName = cTestParms.CreateHTTPFormatNameFromPathName(cTestParms.ReturnQueuePathName(L"Remote Read Queue"), FALSE);
				TestArr->AllTests[dwNumberOfTest]= new CSRMP( dwNumberOfTest , wcsPublicQueueFormatName );			
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			UNREFERENCED_PARAMETER(err);
			wMqLog(L"Failed create tests %d ( SRMP Test )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;

		try
		{
			map<wstring,wstring> mDComParams;
			mDComParams.clear();
			mDComParams[L"RemoteMachine"] = cTestParms.m_wcsRemoteComputerNetBiosName;
			mDComParams[L"PublicQueuePathName"] = cTestParms.ReturnQueuePathName(L"Regular PublicQ");
			mDComParams[L"PublicQueueFormatName"] = cTestParms.ReturnQueueFormatName(L"Regular PublicQ");
			if( TestArr->bCreateTest[ dwNumberOfTest ] )
			{
				TestArr->AllTests[dwNumberOfTest]= new cDCom( dwNumberOfTest , mDComParams, cTestParms.m_eMSMQConf == WKG );			
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			UNREFERENCED_PARAMETER(err);
			wMqLog(L"Failed create tests %d ( DCOM Test )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;

		//
		// Send transaction message to local queue using HTTP format name using COM interface.
		//
		try
		{
			map <wstring , wstring > mEODLocalTestParams;
			mEODLocalTestParams.clear();
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{			
				if ( cTestParms.m_eMSMQConf == WKG )
				{
					mEODLocalTestParams[L"FormatName"] = cTestParms.CreateHTTPFormatNameFromPathName(cTestParms.ReturnQueuePathName(L"Private Transaction"),FALSE);
				}
				else
				{
					mEODLocalTestParams[L"FormatName"] = cTestParms.CreateHTTPFormatNameFromPathName(cTestParms.ReturnQueuePathName(L"TransQ1"),FALSE);
				}
				mEODLocalTestParams[L"Sp6"]=L"NO";
				mEODLocalTestParams[L"Desc"] = L"local";
				TestArr ->AllTests[dwNumberOfTest]= new xActViaCom ( dwNumberOfTest , mEODLocalTestParams);
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			UNREFERENCED_PARAMETER(err);
			wMqLog(L"Failed create tests %d ( local http transaction )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;

		try
		{
			map <wstring , wstring > mRemotePeekTest;
			mRemotePeekTest.clear();
			mRemotePeekTest[L"RemoteMachineName"] = cTestParms.m_wcsRemoteComputerNetBiosName;
			mRemotePeekTest[L"DependentClient"] = (cTestParms.m_eMSMQConf == DepClient) ? L"Yes":L"No";
			TestArr ->AllTests[dwNumberOfTest]= new CRemotePeek ( dwNumberOfTest , mRemotePeekTest);
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			UNREFERENCED_PARAMETER(err);
			wMqLog(L"Failed create tests %d ( Remote peek )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		
		dwNumberOfTest ++;
		
		//
		// MixMqf support
		//
		map <wstring , wstring > mMixMqfTestParams;
		try
		{
			if( TestArr ->bCreateTest[ dwNumberOfTest ] )
			{
				mMixMqfTestParams[L"RemoteMachineDNS"]=cTestParms.m_wcsRemoteMachineNameFullDNSName;
				mMixMqfTestParams[L"LocalMachine"]=cTestParms.m_wcsCurrentLocalMachine;
				mMixMqfTestParams[L"AdminQPathName"] = cTestParms.ReturnQueuePathName(L"Private Admin Q");
				std::list<std::wstring> listOfRemoteAndLocalMachine=cTestParms.m_listOfRemoteMachine;
				listOfRemoteAndLocalMachine.push_back(cTestParms.m_wcsCurrentLocalMachine);
				TestArr ->AllTests[dwNumberOfTest]= new MixMqf ( dwNumberOfTest, mMixMqfTestParams, listOfRemoteAndLocalMachine, cTestParms.m_eMSMQConf, cTestParms.m_eMSMQConf == WKG);
			}
		}
		catch(INIT_Error & err )
		{
			bSucc = false;
			wMqLog(L"Failed create tests %d ( Mix Mqf support )\n",dwNumberOfTest+1,err);
			TestArr ->bCreateTest[ dwNumberOfTest ] = iFailedToCreateTest; // Do not call to this test
			TestResult[ dwNumberOfTest ] = FALSE;
		}
		dwNumberOfTest ++;

	return bSucc;
}

//
//
// RunTest
//
// input paramters:
//
// 1. TestContainer * TestArr - Container for all the tests.
// 2.
// 3. map <wstring,wstring> & mapCreateFlag - additional arguments to function
//
// mSpecificTestParams[L"bVerbose"] = true / false ;
// mSpecificTestParams[L"eSTtype"] =
// mSpecificTestParams[L"bDeleteQueueAfterTest"] = ...


int RunTest( TestContainer * TestArr,
			 cBvtUtil & cTestParms,
			 map <wstring,wstring> & mSpecificTestParams, 
			 bool bMultiThread,
			 bool bInvestigate,
			 DWORD dwSleepUntilRep
			)
{
		//
		// Start the tests
		//
		
		//DWORD TestResult[Total_Tests];
		DWORD dwTid=0;

		if( bMultiThread == false )
		{
			
			string wcsTemp=My_WideTOmbString( mSpecificTestParams[L"bSingleTest"] ) ;
			if ( _snwscanf (mSpecificTestParams[L"bSingleTest"].c_str(), mSpecificTestParams[L"bSingleTest"].length(), L"%d", & dwTid ) == EOF )
			{
				printf("failed to convert string to dword\n");
				return MSMQ_BVT_FAILED; 
			}

			for ( INT Index = 0 ; Index < Total_Tests ; Index ++ )
			{	
				if(TestArr->AllTests[Index] && TestArr -> bCreateTest[Index] == TRUE )
				{		
					if ( mSpecificTestParams[L"bVerbose"] == L"true" )
					{
						( TestArr -> AllTests[Index] ) -> Description();
					}
					TestResult [Index] = ( TestArr->AllTests[Index] ) ->Start_test();
				}
			}

			
		if( g_RunOnlyStartPhase == true )
		{ 
			return MSMQ_BVT_FAILED;
		}	

			//
			//  need to sleep for resp time until chech the resualt.
			//
			


			
			if( dwSleepUntilRep )
			{
				if( g_bDebug )
				{
				  cout << "Sleep " << dwSleepUntilRep << "sec before call to check results." <<endl;
				}
				Sleep( dwSleepUntilRep * 1000 );
			}
			else
			{
				Sleep(MqBvt_SleepBeforeWait);
			}


			for ( Index =0 ; Index < Total_Tests ; Index ++ )
			{
				if( TestArr->AllTests[Index] && TestArr -> bCreateTest[Index] == TRUE )
				{
					if ( mSpecificTestParams[L"bVerbose"] == L"true" )
					{
							MqLog ("Result check:");
							(TestArr->AllTests[Index]) -> Description();
					}
				
					if ( TestResult [Index] == MSMQ_BVT_SUCC )
					  TestResult [Index] = (TestArr -> AllTests[Index]) -> CheckResult();
				}
			}
//
// AutoInvestigate phase.
//		
			if(bInvestigate)
			{
				for ( Index =0 ; Index < Total_Tests ; Index ++ )
				{
					if( TestResult [Index] != MSMQ_BVT_SUCC &&
						TestArr -> bCreateTest[Index] == TRUE && 
						TestArr->AllTests[Index] )
					{
						try
						{							
							(TestArr -> AllTests[Index])->AutoInvestigate();
						}
						catch( INIT_Error & err )
						{
							UNREFERENCED_PARAMETER(err);
							MqLog("AutoInvestigate failed with exception on thread %d\n", Index+1);
						}
					}
				}
			}

		}
		else
		{
			int Index;
			HANDLE hArr[Total_Tests];
			int i=0;
			g_dwRxTimeOut *= 5;
			for ( Index =0 ; Index < Total_Tests ; Index ++ )
			{
				if (TestArr->bCreateTest[Index] == TRUE && 
					TestArr->AllTests[Index] != NULL )
				{
				   //TestResult [Index] =
					(TestArr->AllTests[Index]) -> StartThread();
				   hArr[i++]=(TestArr->AllTests[Index])->GetHandle();
				}
			}
			
			WaitForMultipleObjects(i,hArr,TRUE,INFINITE);	
			

		}
		
		//
		// Check the array to decide Mqbvt pass / Failed
		//
		wstring wcsFailedTest = L"";
		int Index;
		BOOL bTestPass = TRUE;
		if ( mSpecificTestParams[L"bSingleTest"] != L"false" )
		{
			if ( TestArr->bCreateTest[dwTid-1] == iFailedToCreateTest ||
				TestResult [dwTid-1] != MSMQ_BVT_SUCC )
				bTestPass = FALSE;
		}
		else
		{
			
			for ( Index = 0 ; Index < Total_Tests ; Index ++ )
			{
				if ( (TestArr->bCreateTest[Index] == TRUE &&  TestResult [Index] != MSMQ_BVT_SUCC) || TestArr->bCreateTest[Index] == iFailedToCreateTest )
				{
					if( bTestPass == FALSE )
					{
						wcsFailedTest += L",";
					}
					bTestPass = FALSE;										
					MqLog("Mqbvt Failed in thread: %d \n", Index + 1 );
					WCHAR wcsFailed[4] ={0};
					swprintf(wcsFailed,L"%d",Index + 1);
					wcsFailedTest += wcsFailed;
					CHAR csLine[100]={0};
					sprintf(csLine,"Mqbvt Failed in thread: %d",Index + 1);
					if( pNTLogFile )
					{
						pNTLogFile -> ReportResult(false,csLine);
					}
				}
			}

		}
		
		
		
		//
		// Delete temp queue On Pass / Fail
		//
		INT bSuccToDelte = MSMQ_BVT_SUCC;
		if( mSpecificTestParams[L"eSTtype"] == L"RunTimeSetup" )
		{
			bSuccToDelte = cTestParms.Delete();
		}		

		
		// Print summary Pass / Failed. bubug need to change error in wkg
		string cswkg = "";
		if( cTestParms.m_eMSMQConf == WKG )
		{
			cswkg = " ( for workgroup configuration ) ";
		}
		if( bTestPass && ! bSuccToDelte )
		{
			MqLog("Mqbvt Passed! %s\n" ,cswkg.c_str());
			CHAR csSuccLine[100]={0};
			sprintf(csSuccLine,"Mqbvt Passed! %s",cswkg.c_str());
			if( pNTLogFile )
			{
				pNTLogFile -> ReportResult(true,csSuccLine);
			}
		}
		else
		{
			wMqLog(L"Summary BVT %s\n" ,wcsFailedTest.c_str());
			MqLog("Mqbvt Failed. %s\n" ,cswkg.c_str());
			cerr << "Mqbvt failed !! " <<endl;
			CHAR csFailedLine[100]={0};
			sprintf(csFailedLine,"Mqbvt failed! %s",cswkg.c_str());
			if( pNTLogFile )
			{
				pNTLogFile -> ReportResult(false,csFailedLine);
			}
		}
		if( bTestPass == FALSE && bInvestigate )
		{
			ReBuildTestCaseForReRun(TestArr);
		}
		
		return bTestPass ? MSMQ_BVT_SUCC:MSMQ_BVT_FAILED;
}


void ExcludeTests ( string & szExludeString, bool * bArray )
/*++
	Function Description:
		disable specfic tests 
	Arguments:
		szExludeString contains test or set of test separated by , to exclude
		bArray - Pointer to array that contain set of tests.
	Return code:
		None
--*/
{
	size_t iPos = 0;
	int i = 0;
	string str="";
	do
	{
		iPos = szExludeString.find_first_of(",");
		if(iPos != -1 )
		{
			str = szExludeString.substr(0,iPos);
			i = atoi (str.c_str());
			szExludeString=szExludeString.substr(iPos+1,szExludeString.length());
		}
		else
		{
			i = atoi (szExludeString.c_str());
		}
		if ( i>0 && i < Total_Tests )
		{
			bArray[i-1] = true;
		}
	}
	while ( iPos != -1 );
}



int EnableEmbeddedTests (TestContainer * pTestCont,InstallType eInstallType)
/*++
	Function Description:
		Disable not relevant tests for Embedded configuration
	Arguments:
		TestContainer 
	Return code:
		int - Embedded state
--*/
{
	int iStatus = iDetactEmbededConfiguration();
	if( eInstallType != WKG )
	{
		if( iStatus == C_API_ONLY )
		{
			//
			// disable com thread.
			//
			pTestCont->bCreateTest[IsMqOA] = FALSE;
			pTestCont->bCreateTest[LocalAuth] = FALSE;
			pTestCont->bCreateTest[LocalEncryption] = FALSE;
			pTestCont->bCreateTest[RemoteAuth] = FALSE;
			pTestCont->bCreateTest[RemoteEncrypt] = FALSE;
			pTestCont->bCreateTest[ComTx] = FALSE;
			pTestCont->bCreateTest[RemoteTransactionQueue] = FALSE;
			pTestCont->bCreateTest[EODHTTP] = FALSE;
			pTestCont->bCreateTest[LOCALEODHTTP] = FALSE;
			pTestCont->bCreateTest[AuthHTTP] = FALSE;
			pTestCont->bCreateTest[Mqf] = FALSE;
		}
	}
	else
	{
		if( iStatus == C_API_ONLY )
		{
			pTestCont->bCreateTest[Mqf] = FALSE;
			pTestCont->bCreateTest[EODHTTP] = FALSE;   
			pTestCont->bCreateTest[LOCALEODHTTP] = FALSE;   
			pTestCont->bCreateTest[RemoteTransactionQueue] = FALSE;
		}

	}
	return iStatus;
}





void ReBuildTestCaseForReRun(TestContainer * pTestArr )
{
	for ( int iIndex=0; iIndex < Total_Tests ; iIndex++ )
	{	
		if(pTestArr->AllTests[iIndex] != NULL &&
		   pTestArr->bCreateTest[iIndex] == TRUE  &&
		   TestResult [iIndex] == MSMQ_BVT_SUCC ) 
		{
		   pTestArr->AllTests[iIndex] = false;
		}
		TestResult[iIndex] = 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\mqf.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Mqf.cpp

Abstract:
	      Send message using Mqf format name
Author:
    
	  Eitan klein (EitanK)  8-May-2000

Revision History:

--*/

#include "msmqbvt.h"
#include "mqdlrt.h"
#include "mqmacro.h"
#include <iads.h>
#include <adshlp.h>
#include <oleauto.h>
using namespace std;
#include "mqf.h"
using namespace MSMQ;

#include "Windns.h"


extern BOOL g_bRunOnWhistler;
/*
1. Tests scenarions.
2. Locate all the relevents formatnames.
3. Send messages using the mqf format name.

Result check
4. Recive ack reach queue for dest queue name.
5. Consume the messages and receive ack.
6. Check the jornal queue if the message are there.

All these need for transcotinal and re

*/
#pragma warning(disable:4786)
const int g_ciMachineQueues =3;




void
MqDl::dbgPrintListOfQueues( 
						   const liQueues & pList
						  )
/*++


  
	Function Description:

		Debug function dump list of my_Qinfo to output
		use for debug infotmation 

	Arguments:
		None
	Return code:
		None

	
--*/
{
	itliQueues pq = pList.begin();
	wMqLog(L"Dump list of my_Qinfo information - \n");
	for(;pq != pList.end();pq++)
	{
		wstring qcsTempQueuePathName = pq->GetQPathName();
		wMqLog(L"QPath=%s\n",qcsTempQueuePathName.c_str());
	}

}


MqDl::MqDl( const INT iIndex ,
			std::map<wstring,wstring> Tparms,
			const list<wstring> &  ListOfMachine,
			const InstallType eMachineConfiguration,
			PubType ePubType 
		   ):
			m_iNumberOfQueuesPerMachine( g_ciMachineQueues ),
		    cTest(iIndex),
			m_MachineList(ListOfMachine),
			m_eMachineCobfiguration(eMachineConfiguration),
			m_ePubType(ePubType),
			m_bSearchForQueues(true)

/*++
	
	  

	Function Description:
	
		constructor

	Arguments:
		  iIndex - test id
		  Tparms - specific test argument.
		  ListOfMachine list that contain remote machine name.
		  eMachineConfiguration - Machine configuration domain / workgroup.
		  
	
	Return code:

		throw Init_error;  
	
--*/
{

	 m_wcsAdminQueueFormatName = Tparms[L"AdminQFormatName"];
	 m_wcsAdminQueueFormatName_toReceive = Tparms[L"AdminQFormatName"];
	 ReturnGuidFormatName( m_wcsGuidMessageLabel2 , 0 , true);
	 if (Tparms[L"SearchForQueue"] == L"Yes")
	 {
		 my_Qinfo mqQTemp(g_wcsEmptyString,g_wcsEmptyString,g_wcsEmptyString);
		 mqQTemp.PutFormatName( Tparms[L"q1"]);
		 m_QueueInfoList.push_back(mqQTemp);
 		 mqQTemp.PutFormatName( Tparms[L"q2"]);
		 m_QueueInfoList.push_back(mqQTemp);
		 mqQTemp.PutFormatName( Tparms[L"q3"]);
		 m_QueueInfoList.push_back(mqQTemp);
		 m_bSearchForQueues = false;
	 }
}
				

void MqDl::LocateDestinationQueues()
/*++


	Function Description:
   
 	  Search for the relevent queues in the DS verify that queues exist,
	  in workgroup mode try to open queues for remote read to verify that queue are exist
	  All the machines that participate in the DL/MQF test must have 
	  three queues for the test	  

	Arguments:
		
		None
	Return code:
		
		throw Init_error;  
--*/
{
	// 
	// For each machine search for the relevent queue and update list<mq_Qinfo>
	// structure
	//
	
		if( m_bSearchForQueues == false )
		{
			//
			// No need to search for the queues
			//
			return ; 
		}
		m_QueueInfoList.clear();
		list<wstring>::iterator itMachineList;
		for( itMachineList = m_MachineList.begin(); 
			 itMachineList != m_MachineList.end();
			 itMachineList++ )
		{
			
			if( g_bDebug)
			{
				wMqLog(L"Locate dest queues for machine %s\n",itMachineList->c_str());
			}
			if( m_ePubType != pub_MqF && m_ePubType != pub_multiCast )
			{ 
				//
				// Search for the queue in the AD
				//
				wstring wcsTempQueueName = *itMachineList + g_cwcsDlSupportCommonQueueName;
				LocateQueuesOnSpecificMachine(itMachineList->c_str(),true);
			}
			else
			{
			
				//
				//  Workgroup mode verify that queue exist using open for read.
				//
				int i;
				for( i=1; i<=m_iNumberOfQueuesPerMachine; i++)
				{
					//
					// Direct=os:machine\private\machine-DLQueues
					// Send MQF useing HTTP will be solve throw COM bugbug Need to think about Direct HTTP ...
					//
					WCHAR wcsTemp[2]={0};
					_itow(i,wcsTemp,10);
					wstring wcsTempbuf=L"Direct=OS:";
					wcsTempbuf+=*itMachineList + L"\\private$\\"+ *itMachineList + L"-" + g_cwcsDlSupportCommonQueueName + wcsTemp;
					LocateQueuesOnSpecificMachine(wcsTempbuf,false);
					//
					//	 Remove the format name man to different class.
					//

				}

			}

		}

		//
		// Verify that all the queues exist.
		// TotalNumberOfQueues = TotalNumberOfMachines * NumbersOfQueuesPerMachine
		//
		if( m_QueueInfoList.size() != ( m_MachineList.size() * m_iNumberOfQueuesPerMachine ))
		{
			MqLog("Found only %d from %d \n",
				   m_QueueInfoList.size(),
					m_MachineList.size() * m_iNumberOfQueuesPerMachine );
			if( g_bDebug )
			{
				dbgPrintListOfQueues(m_QueueInfoList);
			}
		}	 

}


void MqDl::LocateQueuesOnSpecificMachine( const wstring & wcsLookupInformation , bool bSearchInAD )
/*++
	Function Description:
		
		  This function Search for the queues in the AD,
		  or try to open queus in workgroup mode.

	Arguments:
		
		  wcsLookupInformation - list that contain all the DL /MQF queues format names.

	Return code:

  

--*/

{
		
		list<my_Qinfo> ListQueuePerSpecificMachine;
		int iCounter=0;
		if( bSearchInAD )
		{
			wstring wcsQueueLabel =  wcsLookupInformation + g_cwcsDlSupportCommonQueueName ;
			
			MSMQ::IMSMQQueueInfosPtr qinfos("MSMQ.MSMQQueueInfos");
			MSMQ::IMSMQQueueInfoPtr qinfo ("MSMQ.MSMQQueueInfo");
			MSMQ::IMSMQQueryPtr query("MSMQ.MSMQQuery");
			
			
			_variant_t vQLabel(wcsQueueLabel.c_str());
			try
			{
				qinfos = query->LookupQueue ( &vtMissing , &vtMissing, & vQLabel );
				qinfos->Reset();
				qinfo = qinfos->Next();			
				while( qinfo != NULL )
				{
					wstring wcsTemp=qinfo->Label;
					if( ! _wcsicmp(wcsQueueLabel.c_str(),wcsTemp.c_str()) )
					{
						//
						//  Bug 698479 - Verify that computer name exist in queue label 
						//  Possible problematic scenario when run mqbvt -i and later computer has been renamed 
						// 
					    wstring wcsQueueLabel = ToLower((wstring)qinfo->Label);
						wstring wcsPathName = ToLower((wstring)qinfo->PathName);
						size_t iPos = wcsPathName.find_first_of(L"\\");
						if ( iPos == -1 )
						{
							wMqLog(L"MqDl::LocateQueuesOnSpecificMachine - Unexpected to get queue path name w/o \\");
							break;
						}
						wcsPathName = wcsPathName.substr(0,iPos);
						if( wcsstr(wcsQueueLabel.c_str(), wcsPathName.c_str()) == NULL )
						{
							wMqLog(L"MqDl::LocateQueuesOnSpecificMachine - Inconsistent behavior expected to find queue label that contains the machine name found machine %s \n queue label %s \n",wcsPathName.c_str(),wcsQueueLabel.c_str());
							break;
						}
		
						my_Qinfo mqQTemp((wstring)qinfo->PathName,
										 (wstring)qinfo->FormatName,
										 (wstring)qinfo->Label );
						ListQueuePerSpecificMachine.push_back(mqQTemp);
						iCounter++;
						if (g_bDebug)
						{
							wstring wcstemp = qinfo->PathName;
							wMqLog(L"Thread %d found queue %s \n",m_testid,wcstemp.c_str());
						}
					}
					qinfo = qinfos->Next();			
					
				}
				if ( iCounter != m_iNumberOfQueuesPerMachine )
				{
					MqLog("LocateQueuesOnSpecificMachine Failed to search all queues from the AD found %d from %d \n",iCounter,m_iNumberOfQueuesPerMachine);
					throw INIT_Error("Failed to retrive all queues properites");
				}		
			}
			catch( _com_error & err )
			{
				printf("MqDl::LocateQueuesOnSpecificMachine failed with error 0x%x\n",err.Error());
			}
		}
		else
		{ 
			//
			// machine is in workgroup can't verify that queue exist by using remote read 
			// expected queue names are static queues
			//
			wstring wcsFormatName =  wcsLookupInformation;
			MSMQ::IMSMQQueueInfoPtr qinfo ("MSMQ.MSMQQueueInfo");
			MSMQ::IMSMQQueuePtr qh;
			try
			{
				qinfo->FormatName = wcsFormatName.c_str();
				qh = qinfo->Open(MQ_RECEIVE_ACCESS,MQ_DENY_NONE);
				qh->Close();

				my_Qinfo mqQTemp(L"Empty",
								 (wstring)qinfo->FormatName,
								 L"Empty");
				ListQueuePerSpecificMachine.push_back(mqQTemp);
				if (g_bDebug)
				{
					wMqLog(L"Thread %d found queue %s \n",m_testid,qinfo->FormatName);
				}
			}
			catch( _com_error & cErr )
			{
				if( cErr.Error() == MQ_ERROR_QUEUE_NOT_FOUND )
				{
					wMqLog(L"Mqf:failed to open dest queue for receive %s Error:0x%p\n",
						    wcsLookupInformation.c_str(),cErr.Error()); //missing debug information
				}
				else
				{
					CatchComErrorHandle ( cErr , m_testid);
				}
				throw INIT_Error("Mqf: Failed to check if the dest queue is exist \n");
			}

					
					
		}
		m_QueueInfoList.merge(ListQueuePerSpecificMachine);
}


MqF::MqF ( const INT iIndex, 
		   const mTable & Tparms,
		   const list<wstring> &  ListOfMachine,
		   const InstallType eMachineConfiguration,
		   bool bWkg
		 )
:MqDl( iIndex,Tparms,ListOfMachine,eMachineConfiguration,pub_MqF),m_bWorkgroup(bWkg)
/*++
	Function Description:
		constructor
	Arguments:
		None
	Return code:
		None
--*/
 
{
 
}

MqF::~MqF(void)
/*++
	Function Description:
		destructor
	Arguments:
		None
	Return code:
		None
--*/
{

}


void MqF::Description()
/*++
	Function Description:
		destructor
	Arguments:
		None
	Return code:
		None
--*/
{
	MqLog("Thread %d : Send messages using mqf format name\n", m_testid);
}

void MqDl::CreateMqFormatName()
/*++
	Function Description:
		CreateMqFormatName 
		This function concat all the formatnames into one string.
	Arguments:
		None
	Return code:
		None
--*/
{
	std::list<my_Qinfo> ::iterator itListOfQueue;
	m_wcsMqFFormatName=L"";
	for( itListOfQueue = m_QueueInfoList.begin(); 
		 itListOfQueue  != m_QueueInfoList.end() ; 
		 itListOfQueue ++ 
		)
	{
		
		if( itListOfQueue != m_QueueInfoList.begin() )
		{
			m_wcsMqFFormatName += L","; 
		}
		m_wcsMqFFormatName += itListOfQueue->GetQFormatName();
		
	}
}

//
// Need to dbgSendMessaga against MQF format name
// 

void MqDl::dbgSendMessage()
/*++
	Function Description:
		dbgSendMessage - this is a debug function that help to debug MQF,
		The function send messages to list of queues.
	Arguments:
		None
	Return code:
		None
--*/
{
	itliQueues p;
	for( p= m_QueueInfoList.begin();p != m_QueueInfoList.end(); 
		p++)
	{
		try
		{	
			
			IMSMQQueueInfoPtr qinfo("MSMQ.MSMQQueueInfo");
			IMSMQQueueInfoPtr AdminQinfo("MSMQ.MSMQQueueInfo");
			IMSMQQueuePtr qSend;
			IMSMQMessagePtr m("MSMQ.MSMQMessage");
			
			AdminQinfo->FormatName = m_wcsAdminQueueFormatName.c_str();
			wstring wcsFormatName = p->GetQFormatName();
			qinfo->FormatName =  wcsFormatName.c_str();
			qSend = qinfo->Open(MQ_SEND_ACCESS, MQ_DENY_NONE);
			m->AdminQueueInfo = AdminQinfo;
			m->Ack = MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE;
			m->Body = m_wcsGuidMessageLabel.c_str();
			m->Label = m_wcsGuidMessageLabel.c_str();
			m->Send(qSend);
			qSend->Close();

		}
		catch (_com_error & cErr )
		{
			MqLog("Thread %d failed to send message to a queue error 0x%x\n",m_testid,cErr.Error());
			throw INIT_Error("dbgSendMessage failed to send message to dest");
		}
	}
}
INT MqF::Start_test()
/*++
	Function Description:
		Implement the tests
		Send messages to all the destination queues.
	Arguments:
		None
	Return code:
		MSMQ_BVT_FAILED / MSMQ_BVT_SUCC
--*/
{
	//
	// Locate all the relevent queue from the enterpise 
	//
	SetThreadName(-1,"MqF - Start_test ");	
	try
	{
		LocateDestinationQueues();
	}
	catch( INIT_Error & err )
	{
		MqLog("Mqf tests exist didn't found all the queues error:%s\n ",err.GetErrorMessgae());
		return MSMQ_BVT_FAILED;
	}

	CreateMqFormatName();


	HRESULT rc = MQ_OK;
	
	HANDLE QueueuHandle=NULL;
	cPropVar MqfMessageProps(8);
	wstring Label(L"T1-3");
	MqfMessageProps.AddProp( PROPID_M_BODY , VT_UI1|VT_VECTOR , m_wcsGuidMessageLabel.c_str() );
	MqfMessageProps.AddProp( PROPID_M_LABEL , VT_LPWSTR , m_wcsGuidMessageLabel.c_str() );
	MqfMessageProps.AddProp( PROPID_M_ADMIN_QUEUE , VT_LPWSTR , m_wcsAdminQueueFormatName.c_str() );
	UCHAR tempValue=MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL;
	MqfMessageProps.AddProp(PROPID_M_ACKNOWLEDGE ,VT_UI1,&tempValue);
	ULONG ulTemp = MQBVT_MAX_TIME_TO_BE_RECEIVED;
	MqfMessageProps.AddProp( PROPID_M_TIME_TO_BE_RECEIVED , VT_UI4, &ulTemp );

	if ( !m_bWorkgroup )
	{
		ULONG ulType = g_bRunOnWhistler ? MQMSG_AUTH_LEVEL_SIG30:MQMSG_AUTH_LEVEL_SIG10;
		MqfMessageProps.AddProp(PROPID_M_AUTH_LEVEL ,VT_UI4,&ulType);
	}
	//
	// Send message using to using MQF format name and one admin queues.
	//
	
	if( g_bDebug )
	{
		wMqLog(L"Open queue for send to Mqfs: %s \n",m_wcsMqFFormatName.c_str());
	}
	
	rc = MQOpenQueue( m_wcsMqFFormatName.c_str() , MQ_SEND_ACCESS , MQ_DENY_NONE , &QueueuHandle );
	ErrHandle(rc,MQ_OK,L"MQOpenQueue Failed to open using Mqf Format Name");
	
	rc=MQSendMessage( QueueuHandle , MqfMessageProps.GetMSGPRops() , NULL);
	ErrHandle(rc,MQ_OK,L"MQSendMessage to Mqf Failed");
	rc=MQCloseQueue(QueueuHandle);
	ErrHandle(rc,MQ_OK,L"MQCloseQueue Failed");
	

	//
	// Send message using to one queue and specify MQF format name to the admin queues.
	//

	if( g_bDebug )
	{
		MqLog("MqF: Send message to admin queue and wait for ACK for all admin queues\n");
	}
	
	return MSMQ_BVT_SUCC;	
}
	
INT MqDl::CheckResult()
/*++
	Function Description:
		This function collects the information from the Mqf using remote read.

		a. Receive from admin messages.
		b. Collect all the messages from the queues.
		
	Arguments:
		None
	Return code:
		MSMQ_BVT_FAILED / MSMQ_BVT_SUCC
--*/
{
			
			HRESULT rc;
			mTable mPrepareBeforeRecive;
			WCHAR wstrMclass[10];
			
			//
			// receive ACK for admin queue
			// 

			mPrepareBeforeRecive[L"FormatName"]=m_wcsAdminQueueFormatName_toReceive;
			mPrepareBeforeRecive[L"DebugInformation"]=L"Recive from admin queue with direct formant name";
			mPrepareBeforeRecive[L"M_Label"]=m_wcsGuidMessageLabel;
			swprintf(wstrMclass,L"%d",MQMSG_CLASS_ACK_REACH_QUEUE);
			mPrepareBeforeRecive[L"MClass"]= wstrMclass;
			for(DWORD i =0;i<MqDl::m_QueueInfoList.size();i++)
			{
				DebugMqLog("------ Retreive admin messages from queue ------- \n");
				rc = RetrieveMessageFromQueue(  mPrepareBeforeRecive );	
				if( rc !=  MSMQ_BVT_SUCC ) 
				{
					//
					//bugbug need to specify the queue name.
					//
					MqLog("Failed to get receive ack on queue //bugbug");
					return MSMQ_BVT_FAILED;
				}
			}
			
			
			//
			// Receive message from the queue
			//
						
			itliQueues it;
			for( it = MqDl::m_QueueInfoList.begin(); 
				 it  != MqDl::m_QueueInfoList.end() ;
				 it ++
				)
			{
					 mPrepareBeforeRecive[L"FormatName"]=it->GetQFormatName();
		   			 mPrepareBeforeRecive[L"DebugInformation"]=L"Receive message from queue=" 
																+it->GetQPathName();
					 mPrepareBeforeRecive[L"M_Label"]=m_wcsGuidMessageLabel;
					 DebugMqLog("------ Retreive messages from queues ------- \n");
					 rc = RetrieveMessageFromQueue(  mPrepareBeforeRecive );
					 if( rc != MSMQ_BVT_SUCC )
					 {
						  return MSMQ_BVT_FAILED;
					 }

			}

				//
				// Check for duplicate messages
				//
				mPrepareBeforeRecive[L"CheckForDuplicate"]=L"CheckForDuplicate";

	 		for( it = MqDl::m_QueueInfoList.begin(); 
				 it  != MqDl::m_QueueInfoList.end() ;
				 it ++
				)
			{
				 
				 mPrepareBeforeRecive[L"FormatName"]=it->GetQFormatName();
		   		 mPrepareBeforeRecive[L"DebugInformation"]=L"Receive message from queue=" +it->GetQPathName();
				 swprintf(wstrMclass,L"%d",MQMSG_CLASS_ACK_REACH_QUEUE);
				 mPrepareBeforeRecive[L"MClass"]= wstrMclass;
					 
				 mPrepareBeforeRecive[L"M_Label"]=m_wcsGuidMessageLabel2;
				 DebugMqLog("------ Check for duplicate messages from the queues ------- \n");
				 rc = RetrieveMessageFromQueue(  mPrepareBeforeRecive );
				 if( rc != MSMQ_BVT_SUCC )
				 {
					 wMqLog(L"Mqf: Error found duplicate message \n");
					 return MSMQ_BVT_FAILED;
				 }
			}
return MSMQ_BVT_SUCC;
} 

MqDl::~MqDl()
/*++
	Function Description:
		constructor
	Arguments:
		None
	Return code:
		None
--*/

{
}




void cSendUsingDLObject::AddMemberToDlObject()
/*++
	Function Description:
		CreateMqFormatName 
		This function concat all the formatnames into one string.
	Arguments:
		None
	Return code:
		None
--*/
{
	std::list<my_Qinfo> ::iterator itListOfQueue;
	for( itListOfQueue = m_QueueInfoList.begin(); 
		 itListOfQueue  != m_QueueInfoList.end() ; 
		 itListOfQueue ++ 
		)
	{

		MQAddElementToDistList(	
								m_wcsDistListFormatName.c_str(),
								(itListOfQueue->GetQFormatName()).c_str()
							  );				
	}
}

INT MqDl::Start_test() 
/*++
	Function Description:
		constructor
	Arguments:
		None
	Return code:
		None
--*/

{
	return 1;
}
void MqDl::Description()
{
}

MqF::CheckResult()
/*++
	Function Description:
		constructor
	Arguments:
		None
	Return code:
		None
--*/
{
	SetThreadName(-1,"MqDistList - CheckResult ");	
	return MqDl::CheckResult();
}


cSendUsingDLObject::cSendUsingDLObject ( const INT iIndex, 
									     mTable & Tparms,
									     const list<wstring> &  ListOfMachine,
									     const InstallType eMachineConfiguration
	  								   ):MqDl( iIndex,Tparms,ListOfMachine,eMachineConfiguration,pub_DL),
m_wcsDistListFormatName(L""),m_wcsQueueAliasFormatName(L""),bCheckAliasQueue(true)								
{

	WCHAR wcsFormatName[BVT_MAX_FORMATNAME_LENGTH]={0};
	DWORD dwFormatNameBufferLen = BVT_MAX_FORMATNAME_LENGTH;
	GetCurrentDomainName();
	wstring wcsDLContainerName=L"CN=Computers,"+m_wcsCurrentDomainName;
	HRESULT hr = MQCreateDistList(wcsDLContainerName.c_str(),m_wcsGuidMessageLabel.c_str(),MQ_GLOBAL_GROUP,NULL,wcsFormatName,&dwFormatNameBufferLen);
	if(FAILED(hr))
	{
		MqLog("cSendUsingDLObject Failed to create DL object error 0x%x\n",hr);
		throw INIT_Error("cSendUsingDLObject:Failed to create DL under Computers container ");
	}
 	m_wcsDistListFormatName = wcsFormatName;

	//
	// Create admin queue mach for DL
	// Currently use DL and replace it with queue alias.
	// 

	wstring m_wcsAdminDLGuid;
	dwFormatNameBufferLen = BVT_MAX_FORMATNAME_LENGTH;
	wstring wcsAdminDLGuid;
	ReturnGuidFormatName( wcsAdminDLGuid , 2 , true);
	hr = MQCreateDistList(wcsDLContainerName.c_str(),wcsAdminDLGuid.c_str(),MQ_GLOBAL_GROUP,NULL,wcsFormatName,&dwFormatNameBufferLen);
	if(FAILED(hr))
	{
		MqLog("cSendUsingDLObject Failed to create DL object error 0x%x\n",hr);
		throw INIT_Error("cSendUsingDLObject:Failed to create DL under Computers container ");
	}
 	m_wcsAdminDestFormatName = wcsFormatName;
	m_wcsPublicAdminQueue = Tparms[L"PublicAdminQueue"];
	hr = MQAddElementToDistList(m_wcsAdminDestFormatName.c_str(),m_wcsPublicAdminQueue.c_str());
	if(FAILED(hr))
	{
		MqLog("MQAddElementToDistList Failed to add queue DL object error 0x%x\n",hr);
		throw INIT_Error("cSendUsingDLObject:Failed to create DL under Computers container ");
	}

	dwFormatNameBufferLen = BVT_MAX_FORMATNAME_LENGTH;
	wstring wcsQueueAliasFullDN = L"CN=Computers,"+ m_wcsCurrentDomainName;
	wstring wcsQueueAliasNameGuid =L"";
	ReturnGuidFormatName( wcsQueueAliasNameGuid , 2 , true);
	hr = MQCreateAliasQueue(wcsQueueAliasFullDN.c_str(),
							wcsQueueAliasNameGuid.c_str(),
							m_wcsPublicAdminQueue.c_str(),
							m_wcsQueueAliasFormatName
						   );
	if(FAILED(hr))
	{
		if ( hr == 0x8007200a ) // Schema attribute is not exist in Win2K schema.
		{ 
			//
			//  Happend because this alias queue is not part of Win2K schema.
			//
			bCheckAliasQueue = false;
		}
		else
		{
			MqLog("MQCreateAliasQueue Failed to create alias queue error 0x%x\n",hr);
			throw INIT_Error("cSendUsingDLObject:Failed to create alias queue under Computers container ");
		}
	}
}


wstring GetCurrentDomainNameDN()
/*++
	Function Description:
		
	Arguments:
		None
	Return code:
		None
--*/
{
	
    IADs * pRoot = NULL;
    HRESULT hr=ADsGetObject( L"LDAP://RootDSE",
							 IID_IADs,
							 (void**) &pRoot
						   );
    if(FAILED(hr)) 
	{ 
		return L"";
	}
	VARIANT varDSRoot;
	hr = pRoot->Get(L"defaultNamingContext",&varDSRoot);
	pRoot->Release();
	if ( FAILED(hr))
	{
		return L"";
	}
    wstring wcsCurrentDomainName = varDSRoot.bstrVal;
	VariantClear(&varDSRoot);
	return wcsCurrentDomainName;
}

void cSendUsingDLObject::GetCurrentDomainName()
/*++
	Function Description:
		Get Full DN name.
	Arguments:
		None
	Return code:
		None
--*/
{
	m_wcsCurrentDomainName = GetCurrentDomainNameDN();
}

cSendUsingDLObject::~cSendUsingDLObject(void)
/*++
	Function Description:
		destructor
	Arguments:
		None
	Return code:
		None
--*/
{
	MQDeleteDistList(m_wcsDistListFormatName.c_str());
	MQDeleteDistList(m_wcsAdminDestFormatName.c_str());
	if ( bCheckAliasQueue )
	{
		MQDeleteAliasQueue(m_wcsQueueAliasFormatName.c_str());
	}
}


void cSendUsingDLObject::Description()
/*++
	Function Description:
		destructor
	Arguments:
		None
	Return code:
		None
--*/
{
	MqLog("Thread %d : Send Messages using DL object \n", m_testid);
}
 

cSendUsingDLObject::CheckResult()
/*++
	Function Description:
		constructor
	Arguments:
		None
	Return code:
		None
--*/
{
	
	if( bCheckAliasQueue )
	{

		AutoFreeLib cMqrt("Mqrt.dll");
		DefMQADsPathToFormatName pfMQADsPathToFormatName = (DefMQADsPathToFormatName) GetProcAddress( cMqrt.GetHandle() ,"MQADsPathToFormatName");
		if ( pfMQADsPathToFormatName == NULL )
		{
			MqLog("Mqbvt failed to GetProcAddress MQADsPathToFormatName proc address \n");
			return MQ_ERROR;
		}
		WCHAR * pwcsFormtName = NULL;
		DWORD dwFormatNameLen = 0;
		HRESULT hr = pfMQADsPathToFormatName(m_wcsQueueAliasFormatName.c_str(),
										     NULL,
										     &dwFormatNameLen
										     );
		if (hr == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL) 
		{
			  pwcsFormtName = (WCHAR*) malloc( sizeof(WCHAR) * (dwFormatNameLen+1));
			  if(pwcsFormtName == NULL) 
			  {
					MqLog("Failed to allocate memory\n");
					return MSMQ_BVT_FAILED;
			  }
			  
			  hr = pfMQADsPathToFormatName(m_wcsQueueAliasFormatName.c_str(),
										   pwcsFormtName,
										   &dwFormatNameLen
										  );
			  ErrHandle(hr,MQ_OK,L"MQADsPathToFormatName Failed");
			  if( m_wcsPublicAdminQueue != pwcsFormtName )
			  {
					wMqLog(L"MQADsPathToFormatName failed to retrive queue \
						   format name \nFound %s \n Expected:%s\n",pwcsFormtName,m_wcsAdminDestFormatName.c_str());
					free(pwcsFormtName);
					return MSMQ_BVT_FAILED;
			  }
			  free(pwcsFormtName);
			  
		}
		else
		{
			ErrHandle(hr,MQ_OK,L"MQADsPathToFormatName Failed");
		}
	}
	return MqDl::CheckResult();
}



INT cSendUsingDLObject::Start_test()
/*++
	Function Description:
		Implement the tests
		Send messages to all the destination queues.
	Arguments:
		None
	Return code:
		MSMQ_BVT_FAILED / MSMQ_BVT_SUCC
--*/
{
	SetThreadName(-1,"cSendUsingDLObject - Start_test ");	
	//
	// Locate all the relevent queue from the enterpise 
	//
	
	try
	{
		LocateDestinationQueues();
	}
	catch( INIT_Error & err )
	{
		MqLog("ComMqF tests exist didn't found all the queues %s",err.GetErrorMessgae());
		return MSMQ_BVT_FAILED;
	}
	//
	// TBD use the DL / MQF API to propgate the message
	//
	
	AddMemberToDlObject();

	HRESULT rc;
	HANDLE QueueuHandle;
	cPropVar MqDLMessageProps(8);
	
	
	wstring Label(L"T1-3");
	
	MqDLMessageProps.AddProp( PROPID_M_BODY , VT_UI1|VT_VECTOR , m_wcsGuidMessageLabel.c_str() );
	MqDLMessageProps.AddProp( PROPID_M_LABEL , VT_LPWSTR , m_wcsGuidMessageLabel.c_str() );
	MqDLMessageProps.AddProp( PROPID_M_ADMIN_QUEUE , VT_LPWSTR ,m_wcsAdminQueueFormatName.c_str() );
	UCHAR tempValue=MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL;
	MqDLMessageProps.AddProp(PROPID_M_ACKNOWLEDGE ,VT_UI1,&tempValue);
	ULONG ulType = MQMSG_PRIV_LEVEL_BODY_BASE;
	MqDLMessageProps.AddProp(PROPID_M_PRIV_LEVEL ,VT_UI4,&ulType);
	ulType = MQMSG_AUTH_LEVEL_SIG30;
	MqDLMessageProps.AddProp(PROPID_M_AUTH_LEVEL ,VT_UI4,&ulType);
	ULONG ulTemp = MQBVT_MAX_TIME_TO_BE_RECEIVED;
	MqDLMessageProps.AddProp( PROPID_M_TIME_TO_BE_RECEIVED , VT_UI4, &ulTemp );	

	//
	// Send message using to using MQF format name and one admin queues.
	//
	if( g_bDebug )
	{
		wMqLog(L"Open queue for send to Mqfs: %s \n",m_wcsMqFFormatName.c_str());
	}
	rc = MQOpenQueue( m_wcsDistListFormatName.c_str() , MQ_SEND_ACCESS , MQ_DENY_NONE , &QueueuHandle );
	ErrHandle(rc,MQ_OK,L"MQOpenQueue Failed to open using DL=GUID Name");
	rc=MQSendMessage( QueueuHandle , MqDLMessageProps.GetMSGPRops() , NULL);
	ErrHandle(rc,MQ_OK,L"MQSendMessage to Mqf Failed");
	
	//
	// Verify that MqHandleToFormat works fine with DL.
	//

	WCHAR * pwcsFormatName = NULL;
	DWORD dwFormatNameLength = 0;
	rc = MQHandleToFormatName(QueueuHandle,pwcsFormatName,&dwFormatNameLength);
	if( rc != MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL )
	{
		MqLog("cSendUsingDLObject::Start_test MQHandleToFormatName expected to return %d found %d\n",MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL,rc);
		return MSMQ_BVT_FAILED;
	}
	dwFormatNameLength += 1;
	pwcsFormatName = (WCHAR *) malloc (sizeof(WCHAR) * (dwFormatNameLength));
	if(!pwcsFormatName)
	{
		MqLog("cSendUsingDLObject::Start_test Failed to allocate memory for pwcsFormatName buffer\n");
		return MSMQ_BVT_FAILED;
	}
	
	rc = MQHandleToFormatName(QueueuHandle,pwcsFormatName,&dwFormatNameLength);
	ErrHandle(rc,MQ_OK,L"MQHandleToFormatName Failed to return format name using DL=GUID Name");
	if( m_wcsDistListFormatName != pwcsFormatName )
	{
		wMqLog(L"MQHandleToFormatName failed expected:%s\nFound %s\n",m_wcsDistListFormatName.c_str(),pwcsFormatName);
		free(pwcsFormatName);
		return MSMQ_BVT_FAILED;
	}
	free(pwcsFormatName);
	rc=MQCloseQueue(QueueuHandle);
	ErrHandle(rc,MQ_OK,L"MQCloseQueue Failed");
	

	//
	// Send message using to one queue and specify MQF format name to the admin queues.
	//

	if( g_bDebug )
	{
		MqLog("MqF: Send message to admin queue and wait for ACK for all admin queues\n");
	}

	return MSMQ_BVT_SUCC;	
}


HRESULT
APIENTRY
MQReceiveMessageByLookupId(
    IN HANDLE hQueue,
    IN ULONG ulLookupId,
    IN DWORD dwAction,
    IN MQMSGPROPS* pmp,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN ITransaction *pTransaction
    );



	

extern DWORD  g_dwRxTimeOut ;


typedef
HRESULT
(APIENTRY * DefMQReceiveMessageByLookupId)
	(
		IN HANDLE hQueue,
		IN ULONGLONG ulLookupId,
		IN DWORD dwAction,
		IN MQMSGPROPS* pmp,
		IN OUT LPOVERLAPPED lpOverlapped,
		IN PMQRECEIVECALLBACK fnReceiveCallback,
		IN ITransaction *pTransaction
    );

typedef
HRESULT
(APIENTRY * DefMQGetOverlappedResult)
 (
 LPOVERLAPPED lpOverlapped
 );


HRESULT RetrieveMessageFromQueueById(map <wstring,wstring> & mRetriveParms )
/*++
	Function Description:
		
		Retrive message from queue by using LookupID
		Call three times to MQReceiveMessageByLookupId
		1. Peek Current Message
		2. Receive Current
		3. Peek Current and failed with Message has been deleted

	Arguments:
		
	Return code:
		MSMQ_BVT_FAILED / MSMQ_BVT_SUCC
--*/
{
		
		AutoFreeLib cMqrt("Mqrt.dll");
		FARPROC pfMQReceiveMessageByLookupId = GetProcAddress( cMqrt.GetHandle() ,"MQReceiveMessageByLookupId");
		FARPROC pfMQGetOverlappedResult = GetProcAddress( cMqrt.GetHandle() ,"MQGetOverlappedResult");
		if( pfMQReceiveMessageByLookupId == NULL || pfMQGetOverlappedResult == NULL )
		{
			MqLog("LookUpID: Faile to get MQReceiveMessageByLookupId proc address\n");
			return MSMQ_BVT_FAILED;
		}
		DefMQReceiveMessageByLookupId xMQReceiveMessageByLookupId = (DefMQReceiveMessageByLookupId) pfMQReceiveMessageByLookupId;
		DefMQGetOverlappedResult xMQGetOverlappedResult =  (DefMQGetOverlappedResult) pfMQGetOverlappedResult;
		
		ULONGLONG uLookUPID=0;
		mRetriveParms[L"MessageID"]=L"MessageID";
		HRESULT hr = RetrieveMessageFromQueue(mRetriveParms);
		if( hr != MSMQ_BVT_SUCC )
		{
			wMqLog(L"Failed to retrive messages ID using MQRecevieMessage return LookupID=%s\n",mRetriveParms[L"MessageID"].c_str());
			return MSMQ_BVT_FAILED;
		}
		if( mRetriveParms[L"MessageID"] != L"MessageID" )
		{
			string strMyVal = My_WideTOmbString(mRetriveParms[L"MessageID"]);
			uLookUPID = _atoi64(strMyVal.c_str());
		}
		
		
		if( g_bDebug )
		{
			wMqLog(L"Search For Message ID 0x%I64d ",uLookUPID);
			wMqLog(L"@Queue %s\n",mRetriveParms[L"FormatName"].c_str());
		}
		wstring wcsQueueFormatName=mRetriveParms[L"FormatName"];
		HANDLE hQueue=NULL;
		HRESULT rc=MQOpenQueue( wcsQueueFormatName.c_str(), MQ_RECEIVE_ACCESS , MQ_DENY_NONE  , &hQueue );
		ErrHandle(rc,MQ_OK,L"MQOpenQueue Failed");		

		cPropVar Rprop(2);
		WCHAR Label[MAX_GUID+1];
		Rprop.AddProp( PROPID_M_LABEL, VT_LPWSTR, Label , MAX_GUID );
		ULONG uTemp=MAX_GUID;
		Rprop.AddProp( PROPID_M_LABEL_LEN , VT_UI4,&uTemp );
		OVERLAPPED pOv = {0};
		pOv.hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
		if ( pOv.hEvent == 0 )
		{
			MqLog("CreateEvent failed with error 0x%x\n",GetLastError());
		}
		rc = xMQReceiveMessageByLookupId( hQueue , 
										  uLookUPID,
										  MQ_LOOKUP_PEEK_CURRENT,
										  Rprop.GetMSGPRops(),
										  &pOv,
										  NULL,
										  NULL
										);
			
		if( rc != MQ_INFORMATION_OPERATION_PENDING )
		{
			CloseHandle(pOv.hEvent);
			ErrHandle(rc,MQ_OK,L"MQReceiveMessageByLookupId Failed to MQ_LOOKUP_PEEK_CURRENT");
		}
		else
		{
			DWORD  dwAsync = WaitForSingleObject(pOv.hEvent,INFINITE); //g_dwRxTimeOut);
			ErrHandle(dwAsync,WAIT_OBJECT_0,L"WaitForSingleObject Failed to MQ_LOOKUP_PEEK_CURRENT");	
			hr = xMQGetOverlappedResult(&pOv);
			CloseHandle(pOv.hEvent);
			ErrHandle(hr,MQ_OK,L"MQGetOverlappedResult return error");
		}
		
		if ( mRetriveParms[L"M_Label"] != Label )
		{
			wMqLog(L"Failed to compare expected results\n found: %s\n,expected %s\n",Label,mRetriveParms[L"M_Label"].c_str());
			return MSMQ_BVT_FAILED;
		}
				
		Rprop.AddProp( PROPID_M_LABEL_LEN , VT_UI4,&uTemp );
		rc = xMQReceiveMessageByLookupId( hQueue , 
										  uLookUPID,
										  MQ_LOOKUP_RECEIVE_CURRENT,
										  Rprop.GetMSGPRops(),
										  NULL,
										  NULL,
										  NULL
										);
			
		ErrHandle(rc,MQ_OK,L"MQReceiveMessageByLookupId Failed to MQ_LOOKUP_RECEIVE_CURRENT");

		if ( mRetriveParms[L"M_Label"] != Label )
		{
			wMqLog(L"Failed to compare expected results\n found: %s\n,expected %s\n",Label,mRetriveParms[L"M_Label"].c_str());
			return MSMQ_BVT_FAILED;
		}
		Rprop.AddProp( PROPID_M_LABEL_LEN , VT_UI4,&uTemp );
		rc = xMQReceiveMessageByLookupId( hQueue , 
										  uLookUPID,
										  MQ_LOOKUP_RECEIVE_CURRENT,
										  Rprop.GetMSGPRops(),
										  NULL,
										  NULL,
										  NULL
										);
			

		ErrHandle(rc,MQ_ERROR_MESSAGE_NOT_FOUND,L"MQReceiveMessageByLookupId Failed to MQ_LOOKUP_RECEIVE_CURRENT");

		if ( mRetriveParms[L"M_Label"] != Label )
		{
			wMqLog(L"Failed to compare expected results\n found: %s\n,expected %s\n",Label,mRetriveParms[L"M_Label"].c_str());
			return MSMQ_BVT_FAILED;
		}

		rc = MQCloseQueue( hQueue );
		ErrHandle(rc,MQ_OK,L"MQcloseQueue Failed");

		return MSMQ_BVT_SUCC;
}


typedef (__stdcall *fptr)();
typedef HRESULT  
	(APIENTRY * 
	DefMQGetPrivateComputerInformation ) 
	(
	  IN LPCWSTR lpwcsComputerName,
	  IN OUT MQPRIVATEPROPS* pPrivateProps
	);


ULONG MSMQMajorVersion(const wstring & wcsComputerName )
/*++
	Function Description:
		MSMQMajorVersion
		Return MSMQ version 
	Arguments:
		wcsComputerName remote machine name
	Return code:
		0 - NT4
		2 - W2K
		5 - Whistler
--*/

{
	if ( _winmajor == NT4 )
	{
	      return 0;
	}
	INT index = 0;
	QMPROPID aQmPropId[1];
	MQPROPVARIANT aPropVar[1];
	MQPRIVATEPROPS aMqPrivateProps;
	HRESULT hr;
	fptr pFunc=NULL;
	DefMQGetPrivateComputerInformation xMQGetPrivateComputerInformation=NULL;

	aQmPropId[index] = PROPID_PC_VERSION;
	aPropVar[index].vt = VT_UI4;
	index ++;
	
	aMqPrivateProps.cProp = index;
	aMqPrivateProps.aPropID = aQmPropId;
	aMqPrivateProps.aPropVar = aPropVar;
	aMqPrivateProps.aStatus=NULL;
		
	AutoFreeLib cMqrt("Mqrt.dll");
		
	if (! cMqrt.GetHandle() )
	{
		return 0;
	}
	pFunc=(fptr)GetProcAddress( cMqrt.GetHandle(), "MQGetPrivateComputerInformation");
	
	if ( pFunc == NULL )
	{
		DWORD dw = GetLastError();
		MqLog("Mqbvt failed to get proc address of MQGetPrivateComputerInformation error:%d\n",dw);
		return 1;
	}
	
	xMQGetPrivateComputerInformation=(DefMQGetPrivateComputerInformation) pFunc;
	const WCHAR * pwcsComputerName = (wcsComputerName == L"") ? NULL : wcsComputerName.c_str();
	//
	// Workaround because BUG 5573 
	//
	WCHAR wcsLocalComputerName[MAX_COMPUTERNAME_LENGTH+1]={0};
	DWORD dwComputerName = MAX_COMPUTERNAME_LENGTH + 1;


	GetComputerNameW(wcsLocalComputerName,&dwComputerName);

	if ( pwcsComputerName && ! _wcsicmp(wcsLocalComputerName,pwcsComputerName))
	{
		pwcsComputerName = NULL;
	}

	hr = xMQGetPrivateComputerInformation( pwcsComputerName , &aMqPrivateProps );
  	if( hr != MQ_OK )
	{
		return 0;
	}
	return aPropVar[0].ulVal;
}



void CMultiCast::Description()
{
	MqLog("Thread %d : Send messages using multicast format name\n", m_testid);
}

CMultiCast::CMultiCast ( const INT iIndex, 
			  mTable & Tparms,
			  const list<wstring> &  ListOfMachine,
			  const InstallType eMachineConfiguration
			  )
			  :MqDl( iIndex,Tparms,ListOfMachine,eMachineConfiguration,pub_multiCast),
			  m_wcsMultiCastAddress(L""),m_wcsMultiCastFormatName(L"")
{
	m_wcsMultiCastAddress =  Tparms[L"MultiCastAddress"];
	
}

CMultiCast::~CMultiCast()
/*++
	Function Description:
	Arguments:

	Return code:
--*/

{
}

wstring CMultiCast::CreateMultiCastFormatName()
/*++
	Function Description:
	Arguments:

	Return code:
--*/

{
	wstring wcsMultiCastFormatName = L"MULTICAST=";
	wcsMultiCastFormatName += m_wcsMultiCastAddress;
	wcsMultiCastFormatName += PGM_PORT;
	return wcsMultiCastFormatName;
}

//
//  
//

CMultiCast::Start_test()
/*++
	Function Description:
		1. Send messages to multi cast group and ask for admin reach queue ACK.
		2. Send message to queue and set admin as multicast address.
	Arguments:

	Return code:
--*/
{

	SetThreadName(-1,"CMultiCast - Start_test ");	
	try
	{
		LocateDestinationQueues();
	}
	catch( INIT_Error & err )
	{
		MqLog("Mqf tests exist didn't found all the queues  error:%s\n ",err.GetErrorMessgae());
		return MSMQ_BVT_FAILED;
	}

	m_wcsMultiCastFormatName = CreateMultiCastFormatName();
	// send it as Mqf m_wcsMultiCastAddress += L"," + CreateMultiCastFormatName();
	
	
	HRESULT rc;
	HANDLE QueueuHandle;
	cPropVar MultiCastProps(7),MultiCastProps1(7);
	
	
	wstring Label(L"T1-3");
	
	MultiCastProps.AddProp( PROPID_M_BODY , VT_UI1|VT_VECTOR , m_wcsGuidMessageLabel.c_str() );
	MultiCastProps.AddProp( PROPID_M_LABEL , VT_LPWSTR , m_wcsGuidMessageLabel.c_str() );
	MultiCastProps.AddProp( PROPID_M_ADMIN_QUEUE , VT_LPWSTR , m_wcsAdminQueueFormatName.c_str() );
	UCHAR tempValue=MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL;
	MultiCastProps.AddProp(PROPID_M_ACKNOWLEDGE ,VT_UI1,&tempValue);
	ULONG ulVal = 180; 
	MultiCastProps.AddProp(PROPID_M_TIME_TO_BE_RECEIVED,VT_UI4,&ulVal);
	
	//
	// Send message using to using MQF format name and one admin queues.
	//
	
	if( g_bDebug )
	{
		wMqLog(L"Open queue for send to Mqfs: %s \n",m_wcsMultiCastFormatName.c_str());
	}
	rc = MQOpenQueue( m_wcsMultiCastFormatName.c_str() , MQ_SEND_ACCESS , MQ_DENY_NONE , &QueueuHandle );
	ErrHandle(rc	,MQ_OK,L"MQOpenQueue Failed to open using multicast Format Name");
	
	rc=MQSendMessage( QueueuHandle , MultiCastProps.GetMSGPRops() , NULL);
	ErrHandle(rc,MQ_OK,L"MQSendMessage to Mqf Failed");
	rc=MQCloseQueue(QueueuHandle);
	ErrHandle(rc,MQ_OK,L"MQCloseQueue Failed");
	

	
	return MSMQ_BVT_SUCC;	

}

CMultiCast::CheckResult()
/*++
	Function Description:
		CheckResult receive messages from the destination queues.
	Arguments:
		None
	Return code:
		MSMQBVT_SUCC / MSMQBVT_FAILED
--*/
{
	SetThreadName(-1,"CMultiCast - CheckResult ");	
	return MqDl::CheckResult();
}


static wstring ConvertPathNameToHTTPFormatName(const wstring & wcsLocalMachineName, const wstring & wcsPathName )
/*++	  

	Function Description:

	  ConvertPathNameToHTTPFormatName convert queue path name to HTTP direct format name

	Arguments:

		wcsPathName - Queue PathName

		wcsLocalMachineName
		 
	Return code:
		wstring contain a queue format name or an empty string if there is an error during parsing
	
--*/

{
	
	//
	// Build DIRECT=HTTP://MachineName\MsMq\QueuePath from Path Name
	//

	wstring wcsMachineName = wcsPathName;
	size_t iPos = wcsMachineName.find_first_of(L"\\");

	if(iPos == -1)
	{
		return g_wcsEmptyString;
	}

	wcsMachineName = wcsMachineName.substr(0,iPos);
	wstring wcsHTTPFormatName = L"DIRECT=hTTp://";
	if( wcsMachineName != L".")
	{
		wcsHTTPFormatName += wcsMachineName;
	}
	else
	{
	    wcsHTTPFormatName += wcsLocalMachineName;
	}
	wcsHTTPFormatName += (wstring)L"/mSmQ/";
	wcsHTTPFormatName += wcsPathName.substr(iPos+1,wcsPathName.length());
	return wcsHTTPFormatName;
}


MixMqf::MixMqf(
	const INT iIndex, 
	mTable & Tparms,
	const list<wstring> &  ListOfMachine,
	const InstallType eMachineConfiguration,
	bool bWkg
	):
	MqF(iIndex, Tparms, ListOfMachine, eMachineConfiguration, bWkg)
{
	m_wcsRemoteMachineFullDNSName = Tparms[L"RemoteMachineDNS"];
	m_wcsLocalMachineName = Tparms[L"LocalMachine"];

	//
	// convert the pathname wcsPathName to direct http formatname, into m_wcsAdminQueueFormatName
	// and convert the pathname wcsPathName again to private formatname (in order to perform the recieve operation).
	//
	wstring wcsPathName = Tparms[L"AdminQPathName"];
	m_wcsAdminQueueFormatName = ConvertPathNameToHTTPFormatName(m_wcsLocalMachineName,wcsPathName);
	WCHAR wcsNoHttp[100];
	DWORD dwFormatLong = TABLE_SIZE(wcsNoHttp);
	HRESULT hr = MQPathNameToFormatName(wcsPathName.c_str(), wcsNoHttp, &dwFormatLong);
	if FAILED(hr)
	{
		throw INIT_Error("Failed to initialize MixMqf due to fail in MQPathNameToFormatName");
	}
	m_wcsAdminQueueFormatName_toReceive = wcsNoHttp;
}



static bool 
GetMachineNameAndQueueNameFromFormatName(
	const wstring & wcsFormatName,
	const wstring & wcsLocalMachineName,
	wstring & wcsMachineName,
	wstring & wcsQueueName
	)
/*++	  

	Function Description:

	  GetMachineNameAndQueueNameFromFormatName gets data from wcsFormatName and puts the machine name, queue name in wcsMachineName, wcsQueueName accordingly.

	Arguments:

		 wcsFormatName - formatname of the form "DIRECT=OS:MachineName\QueueName"
		 wcsLocalMachineName - the local machine name (for case "DIRECT=OS:.\QueueName")
		 wcsMachineName - out
		 wcsQueueName - out
		
	Return code:
		false - in case the formatname is in unexpected form
		true - in case of success
	
--*/


{
	size_t pStart = wcsFormatName.find_first_of(L":");
	size_t pEnd = wcsFormatName.find_first_of(L"\\");
	if((pStart == -1)||(pEnd == -1))
	{
		return false;
	}
	
	wcsMachineName = wcsFormatName.substr(pStart+1,pEnd-pStart-1);
	if( wcsMachineName == L".")
	{
		wcsMachineName = wcsLocalMachineName;
	}
	wcsQueueName = wcsFormatName.substr(pEnd+1,wcsFormatName.length());
	return true;
}


static wstring ConvertDirectFormatNameToHTTPFormatName(const wstring & wcsLocalMachineName,const wstring & wcsFormatName, bool fHTTPS)
/*++	  

	Function Description:

	  ConvertDirectFormatNameToHTTPFormatName converts queue direct format name to HTTP direct format name

	Arguments:

		wcsFormatName - Queue FormatName
		bool fHTTPS - true return direct=hTTPS://
	Return code:

		wstring contain a queue format name or an empty string if there is an error during parsing
	
--*/

{
	
	//
	// Build DIRECT=HTTP://MachineName\MsMq\QueuePath from Format Name
	//
	wstring wcsMachineName = g_wcsEmptyString;
	wstring wcsQueueName = g_wcsEmptyString;
	if (!GetMachineNameAndQueueNameFromFormatName(wcsFormatName,wcsLocalMachineName,wcsMachineName,wcsQueueName))
	{
		return g_wcsEmptyString;	
	}

	//
	// choose http / https
	//
	wstring wcsHTTPFormatName = fHTTPS ?  L"DIRECT=hTTpS://" : L"DIRECT=hTTp://";
	wcsHTTPFormatName += wcsMachineName;
	wcsHTTPFormatName += (wstring)L"/mSmQ/";
	wcsHTTPFormatName += wcsQueueName;
	return wcsHTTPFormatName;
}

static wstring ConvertDirectFormatNameToPathName(const wstring & wcsFormatName)
/*++	  

	Function Description:

	  ConvertDirectFormatNameToPathName converts queue direct format name to path name
	  formatname being: "direct=*:'pathname'"
	  this function will not work on formatname of the form private=... , public=...

	Arguments:

		 wcsFormatName - Queue FormatName

	Return code:

		wstring contain a queue path name or an empty string if there is an error during parsing
	
--*/

{
	wstring wcsMachineName = wcsFormatName;
	size_t pStart = wcsMachineName.find_first_of(L":");
	if (pStart == -1)
	{
		return g_wcsEmptyString;
	}
	wstring wcsPathName = wcsFormatName.substr(pStart+1,wcsFormatName.length());
	return wcsPathName;
}


static wstring ConvertDirectFormatNameToTCPFormatName(const wstring & IPAdd,const wstring & wcsFormatName)
/*++	  

	Function Description:

	  ConvertDirectFormatNameToTCPFormatName converts queue direct format name to TCP direct format name

	Arguments:

		 wcsFormatName - Queue FormatName of the form DIRECT=OS:MachineName\QueueName

		 IPAdd - Remote machine ip-address

	Return code:

		wstring contain a queue format name or an empty string if there is an error during parsing
	
--*/

{
	//
	// build DIRECT=TCP:IPAddress\QueueName
	//
	
	wstring wcsMachineName = g_wcsEmptyString;
	wstring wcsQueueName = g_wcsEmptyString;
	if (!GetMachineNameAndQueueNameFromFormatName(wcsFormatName,wcsMachineName,wcsMachineName,wcsQueueName))
	{
		return g_wcsEmptyString;	
	}
	
	wstring wcsTCPFormatName = L"DIRECT=TCP:";
	wcsTCPFormatName += IPAdd;
	wcsTCPFormatName += L"\\";
	wcsTCPFormatName += wcsQueueName;
	return wcsTCPFormatName;
}


static wstring
GetRemoteMachineIPAddresses(
	const wstring & wcsRemoteMachine
	)
/*++

Function: wstring GetRemoteMachineIPAddresses()

Arguments:
		wcsRemoteMachine - the name of the machine to find ip-address of

Return Value:
		wstring containing ip-address of the remote machine in case of success
		g_wcsEmptyString if the function failed
--*/
{
	if( g_bDebug )
	{
		wMqLog(L"GetMachineIPAddresses for remote machine\n");
	}
    
    //
    // Obtain the IP information for the machine
    //

    SOCKADDR_IN* vIPAddr = new SOCKADDR_IN;
	//
    // perform a DNS query
	//
	PDNS_RECORD pQueryResultsSet;

	DNS_STATUS dnsRes = DnsQuery_W(wcsRemoteMachine.c_str(), DNS_TYPE_A, DNS_QUERY_STANDARD, NULL, &pQueryResultsSet, NULL);
	if( NO_ERROR == dnsRes)
	{
		//
		// get the first address
		//
		PDNS_RECORD pDnsRec=pQueryResultsSet;

		if ( NULL != pDnsRec)
		{
			vIPAddr->sin_addr.S_un.S_addr = pDnsRec->Data.A.IpAddress;
		}
	
		//
		// free the allocated query buffer
		//
		DnsRecordListFree( pQueryResultsSet, DnsFreeRecordListDeep );

		if ( NULL == pDnsRec)
		{
			wMqLog(L"DnsQuery_W Failed to resolve IPAddress for %ls with error 0x0000%x\n", wcsRemoteMachine.c_str(),dnsRes);
			return g_wcsEmptyString;
		}
	}
	else
	{
		wMqLog(L"DnsQuery_W Failed to resolve IPAddress for %ls with error 0x0000%x\n", wcsRemoteMachine.c_str(),dnsRes);
		return g_wcsEmptyString;
	}

	char* csIPAdd = inet_ntoa(vIPAddr->sin_addr);
	if (csIPAdd == NULL)
	{
		wMqLog(L"inet_ntoa Failed to resolve Address for %ls\n", wcsRemoteMachine.c_str());
		return g_wcsEmptyString;
	}

   	wchar_t wcIP[100];
   	size_t res_convstring = mbstowcs(wcIP,csIPAdd,TABLE_SIZE(wcIP));
   	if (res_convstring == -1)
   	{
		wMqLog(L"Failed during getting remote machine address\n");
		return g_wcsEmptyString;
	}
	wstring wcsIPadd = wcIP;
	if (g_bDebug)
	{
		wMqLog(L"remote machine IP address for direct tcp formatname is %ls\n",wcsIPadd.c_str());
	}
	return wcsIPadd;
}


void MixMqf::CreateMqFormatName()
/*++
	Function Description:
		CreateMqFormatName 
		This function concat formatnames of different kinds into one string (MqDl.m_wcsMqFFormatName).
	Arguments:
		None
	Return code:
		None
--*/
{
	if( g_bDebug )
	{
		wMqLog(L"Creating mixed formatnames for send to Mqfs, in these formats:\n");
		wMqLog(L"(local machine:) private= ,(2*)direct=https://, (remote machine:) direct=tcp:,(2*) direct=http:// \n");
	}
	
	std::list<my_Qinfo> ::iterator itListOfQueue;
	m_wcsMqFFormatName=L"";
	wstring wcsPName=L"";
	WCHAR wcsPrivateFName[70];
	DWORD dwLength = TABLE_SIZE(wcsPrivateFName);
	
	int i=0;

	for( itListOfQueue = m_QueueInfoList.begin(); 
		 itListOfQueue  != m_QueueInfoList.end();
		 itListOfQueue ++, i++ 
		)
	{
		if (i != 0)
		{
			m_wcsMqFFormatName += L",";
		} 
		switch (i)
		{
			case 0:
				//
				// the first formatname will be private=... 
				//
				wcsPName = ConvertDirectFormatNameToPathName(itListOfQueue->GetQFormatName());
				MQPathNameToFormatName(wcsPName.c_str(), wcsPrivateFName, &dwLength);
				m_wcsMqFFormatName += wcsPrivateFName;
				break;

			case 1:
			case 2:
				//
				// the second & third formatname will be direct=https://...
				//
				m_wcsMqFFormatName += ConvertDirectFormatNameToHTTPFormatName(m_wcsLocalMachineName,itListOfQueue->GetQFormatName(),true);
				break;

			case 3:
				//
				// the first format name of the remote machine will be direct=tcp:...
				//
				m_wcsMqFFormatName += ConvertDirectFormatNameToTCPFormatName(GetRemoteMachineIPAddresses(m_wcsRemoteMachineFullDNSName),itListOfQueue->GetQFormatName());
				break;
				
			default:
				//
				// the default formatname will be direct=http://
				//
				m_wcsMqFFormatName += ConvertDirectFormatNameToHTTPFormatName(m_wcsLocalMachineName,itListOfQueue->GetQFormatName(),false);
				break;
				
		}		
	}
}


void MixMqf::Description()
{
	MqLog("Thread %d : Send messages using mix mqf format name\n", m_testid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\mqdlimp.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: MqDLimp.cpp

Abstract:

	Contain a function that manipulate DL objects,
		
Author:

  Eitan klein (EitanK)  5-Sep-2000

Revision History:

--*/


#include "msmqbvt.h"
#include <iads.h>
#include <adshlp.h>
#include <comdef.h>
#include <mq.h>
using namespace std;
#include "mqdlrt.h"

#define MQ_DL_PREFIX L"DL="
#define MQ_ALIAS_OBJECT L"MSMQ-Custom-Recipient"
#define LDAP_GUID_FORMAT L"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
#define LDAP_GUID_STR_LEN (32)
#define LDAP_GUID_PREFIX L"LDAP://<GUID="
#define LDAP_PREFIX L"LDAP://"
#define LDAP_GUID_SUFFIX L">"
#define LDAP_PRINT_GUID_ELEMENTS(p)	\
	p[0],  p[1],  p[2],  p[3],	\
	p[4],  p[5],  p[6],  p[7],	\
	p[8],  p[9],  p[10], p[11],	\
	p[12], p[13], p[14], p[15]

#define LDAP_SCAN_GUID_ELEMENTS(p)	\
	p,		p + 1,	p + 2,	p + 3,	\
	p + 4,	p + 5,	p + 6,	p + 7,	\
	p + 8,	p + 9,	p + 10, p + 11,	\
	p + 12, p + 13, p + 14, p + 15


#define MQ_ERROR_OBJECT_NOT_FOUND 0xe00efff1



static GUID FnpString2Guid(LPCWSTR GuidStr)
{
    GUID Guid = {0};
	UINT Data[16];

    DWORD nFields = _snwscanf(
						GuidStr,
						LDAP_GUID_STR_LEN,
						LDAP_GUID_FORMAT,
						LDAP_SCAN_GUID_ELEMENTS(Data)
						);    
	if( nFields == 16 )
	{
	
		for(size_t i = 0; i < 16; i++)
		{
			((BYTE*)&Guid)[i] = (BYTE)(Data[i]);
		}
	}
	return Guid;
}

const wstring ConvertFromADGuidToMSMQGuidFormat(const WCHAR * pwcsAdGuid)
/*++ 
	Function Description:
		Convert from AD guid format to MSMQ guid format name  
	Arguments:
		 pwcsMSMQGuidFormat - pointer to string contain MSMQ guid Format name.
	Return code:
		  String that contain the DN format name.
		
--*/
{
	    wstring wcsQueueGuid=L"";
		GUID uuid = FnpString2Guid(pwcsAdGuid);
		WCHAR * pwcsTempBuffer=NULL;
		if ( UuidToStringW(&uuid,&pwcsTempBuffer) == RPC_S_OK )
		{
			wcsQueueGuid = pwcsTempBuffer;
			RpcStringFreeW(&pwcsTempBuffer);
		}
		return wcsQueueGuid;

}


const wstring ConvertFromMSMQGUIDFormatToAdGuidFormat(const WCHAR * pwcsMSMQGuidFormat )
/*++ 
	Function Description:
		Convert from MSMQ guid format to DS format name  
	Arguments:
		 pwcsMSMQGuidFormat - pointer to string contain MSMQ guid Format name.
	Return code:
		  String that contain the DN format name.
		
--*/
{

	UUID pGuid={0};
	HRESULT hr = UuidFromStringW(const_cast <WCHAR *>(pwcsMSMQGuidFormat),&pGuid);
	if( hr != RPC_S_OK )
	{
		SetLastError(hr);
		return L"";
	}
	WCHAR wcsADsQueuePath[MAX_PATH+1]={0};
	_snwprintf(	wcsADsQueuePath,MAX_PATH,LDAP_GUID_FORMAT,	LDAP_PRINT_GUID_ELEMENTS(((BYTE*)&pGuid)));
	wcsADsQueuePath[MAX_PATH] = L'\0';
	return wcsADsQueuePath;
}


const wstring ConvertFromDNNameToDotDomainName(LPCWSTR wcsFullDotDnName )

/*++ 
	Function Description:
	  
		Convert from microsoft.com to DC=Microsoft,DC=Com.
	  
	Arguments:
			
	Return code:
		string that contain the full DN name or an empty string.
		
--*/
{
	if(!wcsFullDotDnName)
	{
		return L"";
	}
	wstring wcsObjectDnName = wcsFullDotDnName;
	wstring wcsDomainDotName=L"";
	size_t iPos=0;
	do 
	{
		iPos = wcsObjectDnName.find(L"DC=");
		wcsObjectDnName = wcsObjectDnName.substr(iPos+3,wcsObjectDnName.length());
		iPos = wcsObjectDnName.find_first_of(L",");
		wcsDomainDotName += wcsObjectDnName.substr(0,iPos);
		if (iPos != -1 )
		{
			wcsDomainDotName += L".";
		}
	}
	while(iPos != -1);
	return wcsDomainDotName;
}

/*++ 
	Function Description:
	
	  MQCreateDistList - Create distribution list and return distribution list object GUID.
	
	Arguments:
		
	   pwcsContainerDnName - DL continer name.
	   pwcsDLName - New DL Name.
	   pSecurityDescriptor - pointer to SD.
	   lpwcsFormatNameDistList 
	   lpdwFormatNameLength
	
	Return code:
		
		 HRESULT 
		
--*/



HRESULT
APIENTRY
MQCreateDistList(
					IN LPCWSTR pwcsContainerDnName,
					IN LPCWSTR pwcsDLName,
					MQDlTypes eCreateFlag,
					IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
   					OUT LPWSTR lpwcsFormatNameDistList,
					IN OUT LPDWORD lpdwFormatNameLength
					)
{
	//
	// Currently is not implemented
	// 
	UNREFERENCED_PARAMETER(pSecurityDescriptor);
	assert(pSecurityDescriptor==NULL);
	if( !pwcsContainerDnName || ! pwcsDLName || !lpwcsFormatNameDistList )
	{
		return MQ_ERROR_INVALID_PARAMETER;
	}

	wstring wcsContainerPathName = LDAP_PREFIX;
	wcsContainerPathName += pwcsContainerDnName;

	IADsContainer * pContainer=NULL;
	HRESULT hr = ADsGetObject(const_cast <WCHAR *>(wcsContainerPathName.c_str()),IID_IADsContainer,(void **)&pContainer);
	if(FAILED(hr))
	{
		SetLastError(hr);
		return hr;
	}
	//
	// First, bind to the parent container
	//
	wstring wcsGroupDnName=L"CN=";
	wcsGroupDnName+=pwcsDLName;

	IADsGroup * pGroup = NULL;
	hr = pContainer->Create(L"group",const_cast <WCHAR *>(wcsGroupDnName.c_str()),(IDispatch **)&pGroup);
	pContainer->Release();
	if( FAILED (hr))
	{
		return hr;
	}
	_variant_t vGroupName(pwcsDLName);
	VARIANT  vGroupType;
	vGroupType.vt=VT_UI4;
	vGroupType.lVal = eCreateFlag;
	pGroup->Put( L"sAMAccountName",vGroupName );
	pGroup->Put( L"groupType",vGroupType );
	hr = pGroup->SetInfo ();
	if(FAILED(hr))
	{
		MqLog("pGroup->SetInfo failed in MQCreateDistList 0x%x\n",hr);
		return hr;
	}
	
	// 
	// Need to return the attribute 
	//
	BSTR bsObjectGuid=L"";
	hr = pGroup->get_GUID(&bsObjectGuid);
	pGroup->Release();
	if (FAILED(hr))
	{
		return hr;
	}
	wstring wcsFullObjectName = (wstring)LDAP_GUID_PREFIX + bsObjectGuid + LDAP_GUID_SUFFIX;
	hr = MQDnNameToFormatName(wcsFullObjectName.c_str(),lpwcsFormatNameDistList,lpdwFormatNameLength);
	if(FAILED(hr))
	{
		MqLog("MQADsPathToFormatName failed to retrive DL format name error 0x%x\n",hr);
		return hr;
	}
	if( g_bDebug )
	{
		wMqLog(L"DL format name is %s\n",lpwcsFormatNameDistList);
	}
	SysFreeString(bsObjectGuid);	
	
	return hr;
}




int ParseDLGuidString(	const wstring wcsDistListFormatName,
						wstring & wcsActiveDGuidFormat,
						wstring & wcsDomainScope
					  )
{
	
		wstring wcsTemp=L"";
		size_t iPos = wcsDistListFormatName.find_first_of(L"=");
		if( iPos == -1 )
		{
			return 1;
		}

		wcsTemp = wcsDistListFormatName.substr(iPos+1,wcsDistListFormatName.length());

		iPos = wcsTemp.find_first_of(L"@");
		if(iPos != -1)
		{
			wcsActiveDGuidFormat=wcsTemp.substr(0,iPos);
		}
		else
		{
			wcsActiveDGuidFormat=wcsTemp;
		}
		wcsDomainScope =L"";
		if(iPos != 0 )
		{
			wstring wcsp=wcsTemp.substr(iPos+1,wcsTemp.length());		
			do
			{
				wcsDomainScope += L"DC=";
				iPos = wcsp.find_first_of(L".");
				wcsDomainScope += wcsp.substr(0,iPos);
				wcsp = wcsp.substr(iPos+1,wcsp.length());
				if( iPos != -1 )
				{
					wcsDomainScope += L",";
				}			
			}
			while(iPos != -1 );
		}
		wcsActiveDGuidFormat = ConvertFromMSMQGUIDFormatToAdGuidFormat(wcsActiveDGuidFormat.c_str());
	return MQ_OK;	
}


HRESULT BindGuidAndReturnFullDnName( LPCWSTR pcwcsGuidPath, 
									 wstring & wcsFullDNPath )
{

	wstring wcsGuidDnPath = LDAP_GUID_PREFIX;
	wcsGuidDnPath += pcwcsGuidPath;
	wcsGuidDnPath += LDAP_GUID_SUFFIX;

	IADs * pIADS=NULL;
	HRESULT hr = ADsGetObject(const_cast <WCHAR *>(wcsGuidDnPath.c_str()),IID_IADs,(void **)&pIADS);
	if(FAILED(hr))
	{
		return hr;
	}
	
	VARIANT  vObjectDisName;
 	hr = pIADS->Get(L"distinguishedName",&vObjectDisName);
	pIADS->Release();
	if(FAILED(hr))
	{
		return hr;
	}
	wcsFullDNPath = vObjectDisName.bstrVal;
	VariantClear(&vObjectDisName);
	return MQ_OK;

}


HRESULT
APIENTRY
MQDeleteDistList(
					IN LPCWSTR lpwcsFormatNameElem
				)
{

	wstring wcsDomainPath=L"";
	wstring wcsDistListGuidPath=L"";
	if ( ParseDLGuidString(lpwcsFormatNameElem,wcsDistListGuidPath,wcsDomainPath) != 0 )
	{
		return MQ_ERROR_ILLEGAL_FORMATNAME;
	}
	//
	// Convert the GUID To AD format
	// 
	
	wstring wcsGuidDnPath = LDAP_GUID_PREFIX;
	wcsGuidDnPath += wcsDistListGuidPath;
	wcsGuidDnPath += LDAP_GUID_SUFFIX;
	IADs * pIADS=NULL;
	HRESULT hr = ADsGetObject(const_cast <WCHAR *>(wcsGuidDnPath.c_str()),IID_IADs,(void **)&pIADS);
	if(FAILED(hr))
	{
		return hr;
	}
	
	VARIANT  vObjectDisName;
 	hr = pIADS->Get(L"distinguishedName",&vObjectDisName);
	if(FAILED(hr))
	{
		pIADS->Release();
		return hr;
	}
	
	
	VARIANT  vObjectName;
	hr = pIADS->Get(L"Name",&vObjectName);
	pIADS->Release();
	if(FAILED(hr))
	{
		return hr;
	}
	
	wstring wcsTempObjectDN = vObjectDisName.bstrVal;
	wstring wcsToken = L",";
	VariantClear(&vObjectDisName);
	
	wstring wcsGroupCnName = L"CN=";
	wcsGroupCnName +=vObjectName.bstrVal;
	VariantClear(&vObjectName);

	size_t iPos = wcsTempObjectDN.find_first_of(wcsToken);
	if( iPos == 0 )
	{
		return MQ_ERROR_OBJECT_NOT_FOUND;
	}
	//
	// Bind to the parent container
	// 
	wcsTempObjectDN = wcsTempObjectDN.substr(iPos+1,wcsTempObjectDN.length());
	wstring wcsParentDnName = LDAP_PREFIX;
	wcsParentDnName += wcsTempObjectDN;
	IADsContainer * pContainer=NULL;
	hr = ADsGetObject(const_cast <WCHAR *>(wcsParentDnName.c_str()),IID_IADsContainer,(void **)&pContainer);
	if( FAILED(hr))
	{
		return hr;
	}
	//
	// Delete the container object.
	// 
	hr = pContainer->Delete(L"group",const_cast <WCHAR *>(wcsGroupCnName.c_str()));
	pContainer->Release();
	return hr;
}


HRESULT	 ConvertFromQueueGuidToDistList( IN LPCWSTR lpwcsFormatNameElem, 
									     wstring & wcsActiveDFormatName 
					  				   )
/*++ 
	Function Description:	
		ConvertFromQueueGuidToDistList - 
		Translate GUID from MSMQ format to AD format
	Arguments:
		lpwcsFormatNameElem - MSMQ style
		wcsActiveDFormatName - AD style
	Return code:
	    ERROR Code
--*/
{
	//
	// Remove public= 
	// 
	wstring wcsQueueFormatName = lpwcsFormatNameElem;
	size_t iPos = wcsQueueFormatName.find_first_of(L"=");
	if( iPos == 0 )
	{
		return MQ_ERROR_ILLEGAL_FORMATNAME;
	}

	wcsQueueFormatName = wcsQueueFormatName.substr(iPos+1,wcsQueueFormatName.length());
	wcsActiveDFormatName = ConvertFromMSMQGUIDFormatToAdGuidFormat(wcsQueueFormatName.c_str());
	return MQ_OK;
}
/*++ 
	Function Description:	
		MQAddElementToDistList - add queue guid to the DL object.
	Arguments:
		lpwcsFormatNameElem - DL GUID
		lpwcsFormatNameDistList - DL GUID
	Return code:
	    HRESULT 
--*/

HRESULT
APIENTRY
MQAddElementToDistList(
							IN LPCWSTR lpwcsFormatNameDistList,
							IN LPCWSTR lpwcsFormatNameElem
					  )
/*++ 
	Function Description:	
		MQAddElementToDistList - add queue guid to the DL object.
	Arguments:
		lpwcsFormatNameElem - DL GUID
		lpwcsFormatNameDistList - DL GUID
	Return code:
	    HRESULT 
--*/
{

	wstring wcsDomainPath=L"";
	wstring wcsDistListGuidPath=L"";
	if ( ParseDLGuidString(lpwcsFormatNameDistList,wcsDistListGuidPath,wcsDomainPath) != 0 )
	{
		return MQ_ERROR_ILLEGAL_FORMATNAME;
	}
	
	wstring wcsQueueFormatName=L"";
	if( ConvertFromQueueGuidToDistList(lpwcsFormatNameElem,wcsQueueFormatName) != 0 )
	{
		return MQ_ERROR_ILLEGAL_FORMATNAME;
	}
	
	wstring wcsTemp=L"";
	HRESULT hr = BindGuidAndReturnFullDnName(wcsQueueFormatName.c_str(),wcsTemp);
	if(FAILED(hr))
	{
		return hr;
	}
	wstring wcsQueueFullDnName = LDAP_PREFIX + wcsTemp;

	wstring wcsGroupGuidAdPath = LDAP_GUID_PREFIX + wcsDistListGuidPath + LDAP_GUID_SUFFIX;
	//
	// bind to the group element.
	//
	IADsGroup * pGroup = NULL;
	hr = ADsGetObject(const_cast <WCHAR *>(wcsGroupGuidAdPath.c_str()),IID_IADsGroup,(void**)&pGroup);
	if(FAILED(hr)) 
	{
		return hr;
	}
	hr = pGroup->Add(const_cast <WCHAR *>(wcsQueueFullDnName.c_str()));
	pGroup->Release();
	return hr;
}




HRESULT
APIENTRY
MQDnNameToFormatName(
								  IN LPCWSTR lpwcsPathNameDistList,  
								  OUT LPWSTR lpwcsFormatNameDistList,
								  IN OUT LPDWORD lpdwFormatNameLength
							  )

/*++ 
	Function Description:	
		MQDistListToFormatName convert ADSPath to MSMQ format name.
	Arguments:
		lpwcsPathNameDistList - DL in DN format name.
	Return code:
	    lpwcsFormatNameDistList contain the format name.
		lpdwFormatNameLength contains the formant name length.

--*/
{
	try 
	{
		AutoFreeLib cMqrt("Mqrt.dll");
		DefMQADsPathToFormatName pfMQADsPathToFormatName = (DefMQADsPathToFormatName) GetProcAddress( cMqrt.GetHandle() ,"MQADsPathToFormatName");
		if ( pfMQADsPathToFormatName == NULL )
		{
			MqLog("Mqbvt failed to GetProcAddress MQADsPathToFormatName proc address \n");
			return MQ_ERROR;
		}
		return pfMQADsPathToFormatName(lpwcsPathNameDistList,lpwcsFormatNameDistList,lpdwFormatNameLength);
	}
	catch( INIT_Error & err )
	{
		UNREFERENCED_PARAMETER(err);
		MqLog("Failed to load mqrt.dll error 0x%x\n",GetLastError());
		return MQ_ERROR;
	}
}


/*++ 
	Function Description:	
		MQRemoveElementFromDistList - add queue guid to the DL object.
	Arguments:
		lpwcsFormatNameElem - DL GUID
		lpwcsFormatNameDistList - DL GUID
	Return code:
	    HRESULT 
--*/
HRESULT
APIENTRY
MQRemoveElementFromDistList(
						  	  IN LPCWSTR lpwcsFormatNameDistList,
							  IN LPCWSTR lpwcsFormatNameElem
							 )
{
	wstring wcsDomainPath=L"";
	wstring wcsDistListGuidPath=L"";
	if ( ParseDLGuidString(lpwcsFormatNameDistList,wcsDistListGuidPath,wcsDomainPath) != 0 )
	{
		return MQ_ERROR_ILLEGAL_FORMATNAME;
	}
	
	wstring wcsQueueFormatName=L"";
	if( ConvertFromQueueGuidToDistList(lpwcsFormatNameElem,wcsQueueFormatName) != 0 )
	{
		return MQ_ERROR_ILLEGAL_FORMATNAME;
	}
	
	wstring wcsTemp=L"";
	HRESULT hr = BindGuidAndReturnFullDnName(wcsQueueFormatName.c_str(),wcsTemp);
	if(FAILED(hr))
	{
		return hr;
	}
	wstring wcsQueueFullDnName = LDAP_PREFIX + wcsTemp;

	//
	// bind to the group element.
	//
	wstring wcsGroupGuidAdPath = LDAP_GUID_PREFIX + wcsDistListGuidPath + LDAP_GUID_SUFFIX;
	IADsGroup * pGroup = NULL;
	hr = ADsGetObject(const_cast <WCHAR *>(wcsGroupGuidAdPath.c_str()),IID_IADsGroup,(void**)&pGroup);
	if(FAILED(hr)) 
	{
		return hr;
	}
	hr = pGroup->Remove(const_cast <WCHAR *>(wcsQueueFullDnName.c_str()));
	pGroup->Release();
	return hr;
}




HRESULT
APIENTRY
MQCreateAliasQueue (
					IN LPCWSTR pwcsContainerDnName,
					IN LPCWSTR pwcsAliasQueueName,
					IN LPCWSTR pwcsFormatName,
					std::wstring & wcsADsPath
					)

/*++ 
	Function Description:	
		MQCreateAliasQueue - create an alias queue in the AD
	Arguments:
		
	Return code:
	    HRESULT 
--*/
{

	if( !pwcsContainerDnName || ! pwcsAliasQueueName )
	{
		return MQ_ERROR_INVALID_PARAMETER;
	}
	wstring wcsContainerPathName = LDAP_PREFIX;
	wcsContainerPathName += pwcsContainerDnName;

	IADsContainer * pContainer=NULL;
	HRESULT hr = ADsGetObject(const_cast <WCHAR *>(wcsContainerPathName.c_str()),IID_IADsContainer,(void **)&pContainer);
	if(FAILED(hr))
	{
		return hr;
	}
	//
	// First, bind to the parent container
	//
	wstring wcsGroupDnName=L"CN=";
	wcsGroupDnName += pwcsAliasQueueName;

	IADs * pIAds = NULL;
	hr = pContainer->Create(MQ_ALIAS_OBJECT,const_cast <WCHAR *>(wcsGroupDnName.c_str()),(IDispatch **)&pIAds);				  
	pContainer->Release();
	if( FAILED (hr))
	{
		return hr;
	}

	_variant_t vAliasQueueMapTo(pwcsFormatName);
	pIAds->Put( L"MSMQ-Recipient-FormatName",vAliasQueueMapTo );		   
	hr = pIAds->SetInfo ();
	if(FAILED(hr))
	{
		if( g_bDebug )
		{
			MqLog("pIAds->SetInfo failed in MQCreateAliasQueue 0x%x\n",hr);
		}
		return hr;
	}


	BSTR bsObjectAdsPath=L"";
	hr = pIAds->get_ADsPath(&bsObjectAdsPath);
	pIAds->Release();
	if(FAILED(hr))
	{
		return hr;
	}
	wcsADsPath = bsObjectAdsPath;
	SysFreeString(bsObjectAdsPath);
	return hr;
}

HRESULT
APIENTRY
MQDeleteAliasQueue(	IN LPCWSTR lpwcsAdsPath )
/*++ 
	Function Description:	
		Delete queue alias from directory service
	Arguments:
		lpwcsAdsPath ADsPath
	Return code:
	    HRESULT 
--*/
{

	wstring wcsAliasQueueName = lpwcsAdsPath;
	size_t iPos = wcsAliasQueueName.find_first_of(L",");
	if( iPos == -1 )
	{
		return MQ_ERROR_INVALID_PARAMETER;
	}
	wstring wcsTemp = wcsAliasQueueName.substr(iPos+1,wcsAliasQueueName.length());
	wstring wcsContainerPath = LDAP_PREFIX;
	wcsContainerPath += wcsTemp;
	iPos = wcsAliasQueueName.find_first_of(L",");
	if( iPos == -1 )
	{
		return MQ_ERROR_INVALID_PARAMETER;
	}
	wcsTemp = wcsAliasQueueName.substr(0,iPos);
	//
	// remove LDAP://
	// 
	iPos = wcsTemp.find_last_of(L"/");
	if( iPos == -1 )
	{
		return MQ_ERROR_INVALID_PARAMETER;
	}
	wcsTemp = wcsTemp.substr(iPos+1,wcsTemp.length());
	IADsContainer * pContainer=NULL;
	HRESULT hr = ADsGetObject(const_cast <WCHAR *>(wcsContainerPath.c_str()),IID_IADsContainer,(void **)&pContainer);
	if( FAILED(hr))
	{
		return hr;
	}
	//
	// Delete the container object.
	// 
	hr = pContainer->Delete(MQ_ALIAS_OBJECT,const_cast <WCHAR *>(wcsTemp.c_str()));
	if( FAILED(hr))
	{
		return hr;
	}
	pContainer->Release();
	return hr;
}
HRESULT
APIENTRY
MQSetAliasQueueElem( 
					IN LPCWSTR pwcsAliasQueueName,
					IN LPCWSTR pwcsFormatName
					)
/*++ 
	Function Description:	
		
		  Update queue alias properites,

	Arguments:
		
	Return code:
	    HRESULT 
--*/
{

	IADs * pIAds=NULL;
	HRESULT hr = ADsGetObject(pwcsAliasQueueName,IID_IADs,(void **)&pIAds);
	if(FAILED(hr))
	{
		return hr;
	}
	_variant_t vAliasQueueMapTo(pwcsFormatName);
	pIAds->Put(L"MSMQ-Recipient-FormatName",vAliasQueueMapTo);
	hr = pIAds->SetInfo();
	if(FAILED(hr))
	{
		MqLog("pIAds->SetInfo  failed in MQSetAliasQueueElem 0x%x\n",hr);
		return hr;
	}

	pIAds->Release();
	return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\mqf.h ===
#ifndef __MQF

#include "msmqbvt.h"
/*
1. Tests scenarions.
2. Locate all the relevents formatnames.
3. Send messages using the mqf format name.

Result check
4. Recive ack reach queue for dest queue name.
5. Consume the messages and receive ack.
6. Check the jornal queue if the message are there.

All these need for transcotinal and re
*/
using namespace std;
typedef std::map<std::wstring,std::wstring> mTable;
typedef std::list<my_Qinfo> liQueues;
typedef std::list<my_Qinfo> ::iterator itliQueues;
#pragma warning(disable:4786)
#include "errorh.h"
#define MQBVTMULTICASTADDRESS L"255.255.0.1:1805"

typedef enum _PubType
{
	pub_DL = 0,
	pub_MqF,
	pub_multiCast
} PubType;

#define PGM_PORT L":1972"

class MqDl:public cTest
{
	public:	
		MqDl( const INT iIndex,
			  std::map<std::wstring,std::wstring> Tparms,
			  const list<wstring> &  ListOfMachine,
			  const InstallType eMachineConfiguration,
			  PubType ePubType 
			 );
		virtual ~MqDl() = 0;
		void Description();
		INT Start_test();
		INT CheckResult();
	protected:
		std::wstring m_wcsAdminQueueFormatName_toReceive;	// destination admin format name not in http format.
		std::wstring m_wcsAdminQueueFormatName; // destination admin format name.
		std::list<wstring> m_MachineList;		// machines list.
		liQueues m_QueueInfoList;
		void LocateDestinationQueues();
		void dbgSendMessage();
		virtual void CreateMqFormatName();
		std::wstring m_wcsMqFFormatName;
		std::wstring m_wcsGuidMessageLabel2;
		std::wstring m_wcsPublicAdminQueue;
	private:
		void operator = (const MqDl & Csrc );
		PubType m_ePubType;
		void LocateQueuesOnSpecificMachine(const std::wstring & wcsLookupInformation , bool bSearchInAD );
		InstallType m_eMachineCobfiguration;
		const int m_iNumberOfQueuesPerMachine;
		void dbgPrintListOfQueues( const liQueues & pList);
		bool m_bSearchForQueues;
};	
 
class MqF:public MqDl
{
	public:
		~MqF ();
		MqF ( const INT iIndex, 
			  const mTable & Tparms,
			  const list<wstring> &  ListOfMachine,
			  const InstallType eMachineConfiguration,
			  bool bWkg
			 );
		void Description();
		INT Start_test();
		INT CheckResult();
	private:
		void operator = ( MqF & cDRC );
		bool m_bWorkgroup;
		
};


class cSendUsingDLObject:public MqDl
{
	public:
		~cSendUsingDLObject ();
		 cSendUsingDLObject ( const INT iIndex, 
							  mTable & Tparms,
							  const list<wstring> &  ListOfMachine,
							  const InstallType eMachineConfiguration
							 );

		void Description();
		INT Start_test();
		INT CheckResult(); 
	private:
		void operator = (cSendUsingDLObject & );
		void AddMemberToDlObject();
		void GetCurrentDomainName();
		std::wstring m_wcsDistListFormatName;
		std::wstring m_wcsCurrentDomainName;
		std::wstring m_wcsAdminDestFormatName;
		std::wstring m_wcsQueueAliasFormatName;
		bool bCheckAliasQueue;
};


class CMultiCast:public MqDl
{
	public:
		~CMultiCast ();
		CMultiCast ( const INT iIndex, 
					 mTable & Tparms,
					 const list<wstring> &  ListOfMachine,
					 const InstallType eMachineConfiguration
				   );

		void Description();
		INT Start_test();
		INT CheckResult(); 
	private:	
		void operator = ( CMultiCast & );
		wstring CreateMultiCastFormatName();
		wstring m_wcsMultiCastAddress;
		wstring m_wcsMultiCastFormatName;
		
};


class MixMqf:public MqF
{
public:
	~MixMqf () {};

	MixMqf(
		const INT iIndex, 
		mTable & Tparms,
		const list<wstring> &  ListOfMachine,
		const InstallType eMachineConfiguration,
		bool bWkg
		);

	void CreateMqFormatName();
	void Description();

private:
	std::wstring m_wcsLocalMachineName;
	std::wstring m_wcsRemoteMachineFullDNSName;
		
};


#endif __MQF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\ntlog.h ===
/*---------------------------------------------------------------------------*\
| NTLOG OBJECT
|   This module defines the NTLOG object.  This header must be include in all
|   modules which make NTLOG calls, or utilizes the definitions.
|
|
| Copyright (C) 1990-1994 Microsoft Corp.
|
| created: 01-Oct-90
| history: 01-Oct-90 <chriswil> created.
|          05-Feb-91 <chriswil> added NOPROLOG style.
|          23-Feb-91 <chriswil> expanded log-flags to DWORD.
|          28-May-91 <chriswil> added per-thread variation tracking.
|          19-Mar-92 <chriswil> redefined struct for shared memory.
|          10-Oct-92 <martys>   added thread macros
|          05-Oct-93 <chriswil> unicode enabled.
|		   10-Oct-96 (darrenf)  fixed _FILE_ for unicode, added _NTLOG_LOGPATH handling
|
\*---------------------------------------------------------------------------*/

#ifndef _NTLOG_
#define _NTLOG_

// If doing C++ stuff, this needs to be here to
// prevent decorating of symbols.
//
#ifdef __cplusplus
extern "C" {
#endif

// **NEW** 10/26/96 Log path environment variable **NEW**
// if the environment variable _NTLOG_LOGPATH is set to a non-empty string
// the value of this variable will be prepended to the log name
// The path should NOT include a trailing backslash.

// No validation is performed on the path, however, if the value is invalid,
// the call to tlCreateLog will fail because CreateFile will fail.

// Basically should be used to force logfiles to a location other than the current directory
// without changing the source file.

// **NEW** 1/20/97 environment variable to force diffable files **NEW**
// if the environment variable _NTLOG_DIFFABLE is set, then log files
// will not contain process and thread specific data, and time and date data.
//


// NTLOG STYLES
//  The folowing are logging levels in which the Log Object can prejudice
//  itself.  These are used by the tlLogCreate() in initializing the
//  Log Object information.  A combination of characteristics is obtained
//  by bitwise OR'ing these identifiers together.
//
#define LOG_LEVELS    0x0000FFFFL    // These are used to mask out the
#define LOG_STYLES    0xFFFF0000L    // styles or levels from log object.

#define TLS_LOGALL    0x0000FFFFL    // Log output.  Logs all the time.
#define TLS_LOG       0x00000000L    // Log output.  Logs all the time.
#define TLS_INFO      0x00002000L    // Log information.
#define TLS_ABORT     0x00000001L    // Log Abort, then kill process.
#define TLS_SEV1      0x00000002L    // Log at Severity 1 level
#define TLS_SEV2      0x00000004L    // Log at Severity 2 level
#define TLS_SEV3      0x00000008L    // Log at Severity 3 level
#define TLS_WARN      0x00000010L    // Log at Warn level
#define TLS_PASS      0x00000020L    // Log at Pass level
#define TLS_BLOCK     0x00000400L    // Block the variation.
#define TLS_BREAK     0x00000800L    // Debugger break;
#define TLS_CALLTREE  0x00000040L    // Log call-tree (function tracking).
#define TLS_SYSTEM    0x00000080L    // Log System debug.
#define TLS_TESTDEBUG 0x00001000L    // Debug level.
#define TLS_TEST      0x00000100L    // Log Test information (user).
#define TLS_VARIATION 0x00000200L    // Log testcase level.

#define TLS_REFRESH   0x00010000L    // Create new file || trunc to zero.
#define TLS_SORT      0x00020000L    // Sort file output by instance.
#define TLS_DEBUG     0x00040000L    // Output to debug (com) monitor).
#define TLS_MONITOR   0x00080000L    // Output to 2nd screen.
#define TLS_VIDCOLOR  0x00100000L    // Use different colors for display output
#define TLS_PROLOG    0x00200000L    // Prolog line information.
#define TLS_WINDOW    0x00400000L    // Log to windows.
#define TLS_ACCESSON  0x00800000L    // Keep log-file open.
#define TLS_DIFFABLE  0x01000000L    // make log file windiff'able (no dates..)
#define TLS_NOHEADER  0x02000000L    // suppress headers so it is more diffable
#define TLS_TIMESTAMP 0x04000000L    // To print the timestamps
#define TLS_VIDEOLOG  0x08000000L    // convert ?.log to ?.bpp.log (color depth)
#define TLS_HTML      0x10000000L    // write log file as an html.
#define TLS_XML       0x20000000L    // write log file as an XML (eXtensible Markup Language).


// NTLOG tlLogOut() PARAMETERS
//   The following defines are used in the tlLogOut() function to output the
//   filename and line numbers associated with the caller.  This uses the
//   preprocessors capabilities for obtaining the file/line.
//
#define TL_LOG       TLS_LOG      ,TEXT(__FILE__),(int)__LINE__
#define TL_ABORT     TLS_ABORT    ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV1      TLS_SEV1     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV2      TLS_SEV2     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV3      TLS_SEV3     ,TEXT(__FILE__),(int)__LINE__
#define TL_WARN      TLS_WARN     ,TEXT(__FILE__),(int)__LINE__
#define TL_PASS      TLS_PASS     ,TEXT(__FILE__),(int)__LINE__
#define TL_BLOCK     TLS_BLOCK    ,TEXT(__FILE__),(int)__LINE__
#define TL_INFO      TLS_INFO     ,TEXT(__FILE__),(int)__LINE__
#define TL_BREAK     TLS_BREAK    ,TEXT(__FILE__),(int)__LINE__
#define TL_CALLTREE  TLS_CALLTREE ,TEXT(__FILE__),(int)__LINE__
#define TL_SYSTEM    TLS_SYSTEM   ,TEXT(__FILE__),(int)__LINE__
#define TL_TESTDEBUG TLS_TESTDEBUG,TEXT(__FILE__),(int)__LINE__
#define TL_TEST      TLS_TEST     ,TEXT(__FILE__),(int)__LINE__
#define TL_VARIATION TLS_VARIATION,TEXT(__FILE__),(int)__LINE__


//  Struct used by tlGet/SetVar/TestStats
//
typedef struct _NTLOGSTATS {
    int nAbort;
    int nBlock;
    int nSev1;
    int nSev2;
    int nSev3;
    int nWarn;
    int nPass;
}
NTLOGSTATS, *LPNTLOGSTATS;


//  Use enumerated indexes to access palette.
//  Colors are defined in wincon.h

typedef struct _VIDEOPALETTE {
    WORD  wINDEX_DEFAULT;
    WORD  wINDEX_INFO;
    WORD  wINDEX_SEV1;
    WORD  wINDEX_SEV2;
    WORD  wINDEX_SEV3;
    WORD  wINDEX_BLOCK;
    WORD  wINDEX_ABORT;
    WORD  wINDEX_WARN;
    WORD  wINDEX_PASS;
}
VIDEOPALETTE, *LPVIDEOPALETTE;


// NTLOG API (EXPORT METHODS)
//   These routines are exported from the library.  These should be the only
//   interface with the NTLOG object.
//
HANDLE APIENTRY  tlCreateLog_W(LPCWSTR,DWORD);
HANDLE APIENTRY  tlCreateLog_A(LPCSTR,DWORD);
HANDLE APIENTRY  tlCreateLogEx_W(LPCWSTR,DWORD,LPSECURITY_ATTRIBUTES);
HANDLE APIENTRY  tlCreateLogEx_A(LPCSTR,DWORD,LPSECURITY_ATTRIBUTES);
BOOL   APIENTRY  tlDestroyLog(HANDLE);
BOOL   APIENTRY  tlAddParticipant(HANDLE,DWORD,int);
BOOL   APIENTRY  tlRemoveParticipant(HANDLE);
DWORD  APIENTRY  tlParseCmdLine_W(LPCWSTR);
DWORD  APIENTRY  tlParseCmdLine_A(LPCSTR);
int    APIENTRY  tlGetLogFileName_W(HANDLE,LPWSTR);
int    APIENTRY  tlGetLogFileName_A(HANDLE,LPSTR);
BOOL   APIENTRY  tlSetLogFileName_W(HANDLE,LPCWSTR);
BOOL   APIENTRY  tlSetLogFileName_A(HANDLE,LPCSTR);
DWORD  APIENTRY  tlGetLogInfo(HANDLE);
DWORD  APIENTRY  tlSetLogInfo(HANDLE,DWORD);
HANDLE APIENTRY  tlPromptLog(HWND,HANDLE);
int    APIENTRY  tlGetTestStat(HANDLE,DWORD);
int    APIENTRY  tlGetVariationStat(HANDLE,DWORD);
VOID   APIENTRY  tlClearTestStats(HANDLE);
VOID   APIENTRY  tlClearVariationStats(HANDLE);
VOID   APIENTRY  tlSetTestStats(HANDLE,LPNTLOGSTATS);
VOID   APIENTRY  tlSetVariationStats(HANDLE,LPNTLOGSTATS);
BOOL   APIENTRY  tlStartVariation(HANDLE);
DWORD  APIENTRY  tlEndVariation(HANDLE);
VOID   APIENTRY  tlReportStats(HANDLE);
BOOL   APIENTRY  tlLogX_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR);
BOOL   APIENTRY  tlLogX_A(HANDLE,DWORD,LPCSTR,int,LPCSTR);
BOOL   FAR cdecl tlLog_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR,...);
BOOL   FAR cdecl tlLog_A(HANDLE,DWORD,LPCSTR,int,LPCSTR,...);
BOOL   APIENTRY  tlGetVideoPalette(HANDLE,LPVIDEOPALETTE);
BOOL   APIENTRY  tlSetVideoPalette(HANDLE,LPVIDEOPALETTE);
BOOL   APIENTRY  tlResetVideoPalette(HANDLE);
VOID   APIENTRY  tlAdjustFileName_W(HANDLE,LPWSTR,UINT);
VOID   APIENTRY  tlAdjustFileName_A(HANDLE,LPSTR,UINT);
BOOL   APIENTRY  tlIsTerminalServerSession();

#ifdef UNICODE
#define tlCreateLog         tlCreateLog_W
#define tlCreateLogEx       tlCreateLogEx_W
#define tlParseCmdLine      tlParseCmdLine_W
#define tlGetLogFileName    tlGetLogFileName_W
#define tlSetLogFileName    tlSetLogFileName_W
#define tlLogX              tlLogX_W
#define tlLog               tlLog_W
#define tlAdjustFileName    tlAdjustFileName_W
#else
#define tlCreateLog         tlCreateLog_A
#define tlCreateLogEx       tlCreateLogEx_A
#define tlParseCmdLine      tlParseCmdLine_A
#define tlGetLogFileName    tlGetLogFileName_A
#define tlSetLogFileName    tlSetLogFileName_A
#define tlLogX              tlLogX_A
#define tlLog               tlLog_A
#define tlAdjustFileName    tlAdjustFileName_A
#endif



// RATS MACROS
//   These macros are provided as a common logging interface which is
//   compatible with the RATS logging-macros.
//
#define TESTDATA                 HANDLE        hLog;
#define TESTOTHERDATA            extern HANDLE hLog;


//  These must be useless.  TL_* macros do not include TLS_TEST or
//  TLS_VARIATION, so they DO NOT count in the stats.  Leaving them around
//  for 'backwards compatibility, if anyone was actually using them...
//
#define L_PASS                   hLog,TL_PASS
#define L_WARN                   hLog,TL_WARN
#define L_DEBUG                  hLog,TL_TESTDEBUG
#define L_TRACE                  hLog,TL_SYSTEM
#define L_FAIL                   hLog,TL_SEV1
#define L_FAIL2                  hLog,TL_SEV2
#define L_FAIL3                  hLog,TL_SEV3
#define L_BLOCK                  hLog,TL_BLOCK


//  macros for incrementing test/variation counts for various log levels
//
#define L_TESTPASS                   hLog,TLS_TEST | TL_PASS
#define L_TESTWARN                   hLog,TLS_TEST | TL_WARN
#define L_TESTDEBUG                  hLog,TLS_TEST | TL_TESTDEBUG
#define L_TESTTRACE                  hLog,TLS_TEST | TL_SYSTEM
#define L_TESTFAIL                   hLog,TLS_TEST | TL_SEV1
#define L_TESTFAIL2                  hLog,TLS_TEST | TL_SEV2
#define L_TESTFAIL3                  hLog,TLS_TEST | TL_SEV3
#define L_TESTBLOCK                  hLog,TLS_TEST | TL_BLOCK
#define L_TESTABORT                  hLog,TLS_TEST | TL_ABORT

#define L_VARPASS                   hLog,TLS_VARIATION | TL_PASS
#define L_VARWARN                   hLog,TLS_VARIATION | TL_WARN
#define L_VARDEBUG                  hLog,TLS_VARIATION | TL_TESTDEBUG
#define L_VARTRACE                  hLog,TLS_VARIATION | TL_SYSTEM
#define L_VARFAIL                   hLog,TLS_VARIATION | TL_SEV1
#define L_VARFAIL2                  hLog,TLS_VARIATION | TL_SEV2
#define L_VARFAIL3                  hLog,TLS_VARIATION | TL_SEV3
#define L_VARBLOCK                  hLog,TLS_VARIATION | TL_BLOCK
#define L_VARABORT                  hLog,TLS_VARIATION | TL_ABORT


#define TESTBEGIN(cmd,logfilename){                                                       \
                                      DWORD __tlFlags;                                    \
                                      __tlFlags = tlParseCmdLine(cmd);                    \
                                      hLog      = tlCreateLog(logfilename,__tlFlags);     \
                                      tlAddParticipant(hLog,0l,0);

#define TESTEND                       tlRemoveParticipant(hLog);                          \
                                      tlDestroyLog(hLog);                                 \
                                  }

#define VARIATION(name,flags)    if(tlStartVariation(hLog))                                                  \
                                 {                                                                           \
                                     DWORD __dwResult;                                                       \
                                     tlLog(hLog,TL_VARIATION,TEXT("%s"),(LPTSTR)name);

#define ENDVARIATION                 __dwResult = tlEndVariation(hLog);                                      \
                                     tlLog(hLog,__dwResult | TL_VARIATION,TEXT("End Variation reported"));   \
                                 }


#define ENTERTHREAD(_hLG,_szNM)  {                                                                           \
                                    LPTSTR _lpFN = _szNM;                                                    \
                                    tlAddParticipant(_hLG,0,0);                                              \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVETHREAD(_hLG,_ret)                                                                               \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);             \
                                    tlRemoveParticipant(_hLG);                                               \
                                    return(_ret);                                                            \
                                 }

#define LEAVETHREADVOID(_hLG)                                                                                \
                                     tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);            \
                                     tlRemoveParticipant(_hLG);                                              \
                                     return;                                                                 \
                                 }


// Macro to report variation PASS/FAIL statistic (based on an expression)
//
#define THPRINTF                tlLog
#define TESTRESULT(expr,msg)    (expr) ? tlLog(L_TESTPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg)
#define TESTFAIL(msg)           TESTSEV2(msg)
#define TESTSEV1(msg)           tlLog(L_TESTFAIL ,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV2(msg)           tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV3(msg)           tlLog(L_TESTFAIL3,TEXT("%s"),(LPTSTR)msg);
#define TESTPASS(msg)           tlLog(L_TESTPASS ,TEXT("%s"),(LPTSTR)msg);
#define TESTABORT(msg)          tlLog(L_TESTABORT,TEXT("%s"),(LPTSTR)msg);
#define TESTWARN(expr,msg)      if(expr) tlLog(L_TESTWARN,TEXT("%s"),(LPTSTR)msg);
#define TESTBLOCK(expr,msg)     if(expr) tlLog(L_TESTBLOCK,TEXT("%s"),(LPTSTR)msg);

#define VARRESULT(expr,msg)    (expr) ? tlLog(L_VARPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg)
#define VARFAIL(msg)           VARSEV2(msg)
#define VARSEV1(msg)           tlLog(L_VARFAIL ,TEXT("%s"),(LPTSTR)msg);
#define VARSEV2(msg)           tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg);
#define VARSEV3(msg)           tlLog(L_VARFAIL3,TEXT("%s"),(LPTSTR)msg);
#define VARPASS(msg)           tlLog(L_VARPASS ,TEXT("%s"),(LPTSTR)msg);
#define VARABORT(msg)          tlLog(L_VARABORT,TEXT("%s"),(LPTSTR)msg);
#define VARWARN(expr,msg)      if(expr) tlLog(L_VARWARN,TEXT("%s"),(LPTSTR)msg);
#define VARBLOCK(expr,msg)     if(expr) tlLog(L_VARBLOCK,TEXT("%s"),(LPTSTR)msg);


#define VAR_SI          0x01                                 // Ship Issue
#define VAR_NSI         0x02                                 // Non-ship Issue
#define VAR_LI          0x03                                 // Less Important
#define VAR_ISSUE_MASK  0x03                                 // To get ship-issue bits only
#define VAR_TIMEABLE    0x04                                 // Var. used in timing suites
#define CORE_API        0x08                                 // API is in most used list
#define CORE_SI         (CORE_API | VAR_TIMEABLE | VAR_SI )  //
#define CORE_NSI        (CORE_API | VAR_TIMEABLE | VAR_NSI)  //
#define NONCORE_SI      (VAR_TIMEABLE | VAR_SI )             //
#define NONCORE_NSI     (VAR_TIMEABLE | VAR_NSI)             //



// CALLTREE Macros
//   These macros are useful for bracketing function-calls.
//
#define ENTER(_hLG,_szNM) {                                                                 \
                              LPTSTR _lpFN = _szNM;                                         \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVE(_hLG,_ret)                                                                    \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return(_ret);                                                 \
                          }

#define LEAVEVOID(_hLG)                                                                     \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return;                                                       \
                          }

#ifdef __cplusplus
}
#endif

#define LPSZ_KEY_EMPTY    TEXT("None")
#define LPSZ_TERM_SERVER  TEXT("Terminal Server")

#endif  // _NTLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\msmqbvt.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: msmqbvt.h

Abstract:

	Mqbvt header file

Author:
    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#pragma warning( disable : 4786 )
#ifndef _MSMQBVT
#define _MSMQBVT
#ifdef  __cplusplus
extern "C" {
#endif

void __cdecl _assert(void *, void *, unsigned);

#ifdef  __cplusplus
}
#endif
#include <winsock2.h>
#include <windows.h>


#include <assert.h>
#ifdef _DEBUG
	#define _DEBUGASSERT
	#undef _DEBUG
	#undef ASSERT
#endif
#define ASSERT(x)

#pragma warning( push, 3 )	
	//#include <iostream>
	#include <string>
	#include <tchar.h>
	#include <vector>
	#include <list>
	#include <map>
	#include <set>
	#include <clusapi.h>
	#include <sstream>
	#include <iostream>

#pragma warning( pop ) 	

	#include "mqparams.h"
	#include <stdio.h>
	#include <stdlib.h>
	#include <tchar.h>

	#include <transact.h>
	#include <xolehlp.h>
	#include "Cs.h"
	#include <process.h>
	#include "errorh.h"
	#include "mqoai.h"
    #import "mqoa.tlb"
	
	#include <mq.h>

    #include <autoptr.h>
	
    #pragma warning( disable : 4786)
	
    // Declare const value for BVT operation
	
	
	#define Win2K (5)
	#define NT4 (4)
	
	#define MQBVTMULTICASTADDRESS L"255.255.0.1:1805"

	#define BVT_RECEIVE_TIMEOUT (7000)
	#define BVT_MAX_FORMATNAME_LENGTH (255)
	#define MSMQ_BVT_SUCC (0)
	#define MSMQ_BVT_FAILED (S_FALSE)
	#define MSMQ_BVT_WARN (2)
	#define MAX_GUID 200
	#define MQBVT_MAX_TIME_TO_BE_RECEIVED		(3600)

	#define CREATEQ_AUTHENTICATE	        	(0x4000)
	#define CREATEQ_TRANSACTION					(0x8000)
	#define CREATEQ_PRIV_LEVEL                  (0x6000)
	#define	CREATEQ_DENYEVERYONE_SEND           (0x1000)
	#define CREATEQ_QUOTA                       (0x0010)
	#define MULTICAST_ADDRESS					(0x0100)


	#define C_API_ONLY 0x1
	#define COM_API 0x3


	extern BOOL g_bDebug;
	extern std::wstring wcsFileName;

	enum InstallType 
	{
		DepClient,
		DomainU,
		LocalU,
		DepClientLocalU,
		WKG
	};


	enum e_InstallationType
	{
		LocalUser,
		WorkGroup,
		DomainUser
	};
	enum SetupType 
	{
		ONLYSetup ,
		RunTimeSetup,
		ONLYUpdate,
		WorkWithStaticQueue,
		DeleteQueue
	};

	
	enum EncryptType 
	{ 
		No_Encrypt,
		Base_Encrypt,
		Enh_Encrypt
	};
const std::wstring g_cwcsDebugQueuePathName = L".\\Private$\\debug";
std::string My_WideTOmbString( std::wstring wcsString);
std::wstring My_mbToWideChar( std::string wcsString);
bool my_wcsicmp(LPCWSTR str1, LPCWSTR str2);
INT RetriveParmsFromINIFile ( std::wstring wcsSection, std::wstring wcsKey , std::wstring & wcsValue, std::wstring csFileName=L"MSMQbvt.INI" );
int iDetactEmbededConfiguration ();
void RegisterCertificate();
ULONG MSMQMajorVersion(const std::wstring & wcsComputerName );
HRESULT RetrieveMessageFromQueue (std::map < std::wstring, std::wstring> & mRetriveParms );
HRESULT RetrieveMessageFromQueueViaCom (std::map <std::wstring,std::wstring> & mRetriveParms );
INT ReturnGuidFormatName( std::wstring & wcsQueuePath , INT GuidType , BOOL bWithOutLocalString = FALSE );
extern const WCHAR* const g_wcsEmptyString;
std::wstring GetRemoteComputerNameForFormatName( std::wstring wcsFormatName );
DWORD __stdcall TimeOutThread(void * param);
std::wstring ConvertHTTPToDirectFormatName (const std::wstring cwcsFormatName);
class INIT_Error
{
	public:
		INIT_Error (const CHAR * wcsDescription);
		inline const char * GetErrorMessgae () const { return m_wcsErrorMessages.c_str() == NULL  ?  "":m_wcsErrorMessages.c_str(); };
		virtual ~INIT_Error() {};
	private:	
		std::string m_wcsErrorMessages;
}; 

//
// This class hold all queue params,
// All the releation operator need to use STL link list !
//
class my_Qinfo
{

	public:
		 my_Qinfo ();
		 my_Qinfo(std::wstring wcsPathName , std::wstring wcsFormatName , std::wstring wcsLabel );
		 my_Qinfo (const my_Qinfo & cObject);
		 inline std::wstring GetQPathName () { return wcsQpathName; }
		 inline std::wstring GetQLabelName () { return wcsQLabel; }
		 inline std::wstring GetQFormatName () { return wcsQFormatName; }
		 void PutFormatName (std::wstring wcsFormatName );
		 void dbg_printQueueProp ();
		 virtual ~my_Qinfo() {};
		 friend bool operator == (my_Qinfo objA, my_Qinfo B );
		 friend bool operator != (my_Qinfo objA, my_Qinfo B );
		 friend bool operator > (my_Qinfo objA, my_Qinfo B );
		 friend bool operator < (my_Qinfo objA, my_Qinfo B );
	private:
	     std::wstring wcsQpathName;
		 std::wstring wcsQFormatName;
		 std::wstring wcsQLabel;
};


//
// This class contain all the Queue in link list
//
class QueuesInfo
{
	public:	
		virtual ~QueuesInfo() {};
		INT UpdateQueue (std::wstring wcsQPathName,std::wstring wcsQFormatName,std::wstring wcsQueueLabel =L"Empty");
		void dbg_printAllQueueProp ();
		INT del_all_queue ();
		std::wstring ReturnQueueProp ( std::wstring QwcsPathName ,  int iValue = 1 );
	private:
		std::list <my_Qinfo> m_listofQueues;

};




	class cBvtUtil 
	{
	
	public:
		cBvtUtil ( std::wstring wcsRemoteComputerName , const std::list<std::wstring> & listOfRemoteMachine,const std::wstring & wcsMultiCastAddress ,
			       BOOL bUseFullDnsName , SetupType eSetupType, BOOL bTriggerInclude , BOOL bRemoteIsNT4 );
		INT Delete ();
		e_InstallationType GetInstallationType ();
		EncryptType GetEncryptionType (); // Return 128 / 40  Encryption Support.
		InstallType m_eMSMQConf;
		
		std::list<std::wstring> m_listOfRemoteMachine;
		std::wstring m_wcsRemoteComputerNetBiosName;
		std::wstring m_wcsRemoteMachineNameFullDNSName;
		

		std::wstring m_wcsLocalComputerNetBiosName;
		std::wstring m_wcsLocalComputerNameFullDNSName;
		
		// This hold The current MachineName Should be one of Full DNS NAME Machine Name
		std::wstring m_wcsCurrentLocalMachine;
		std::wstring m_wcsCurrentRemoteMachine;
		// String the contain the local machine guid
		std::wstring m_wcsMachineGuid;
		std::wstring m_wcsRemoteMachineGuid;
		std::wstring m_wcsLocateGuid;
		std::wstring m_wcsClusterNetBiosName;
		
		void UpdateQueueParams(std::wstring wcsQueuePathName,std::wstring wcsQueueFormatName , std::wstring wcsQueueLabel = L"Empty");
		std::wstring ReturnQueueFormatName( std::wstring wcsQueueLabel );
		std::wstring ReturnQueuePathName( std::wstring wcsQueueLabel );
		void dbg_PrintAllQueueInfo();
		virtual ~cBvtUtil() {};
		std::wstring GetMachineID( std::wstring wcsRemoteMachineName );
		bool bWin95 ;
		inline const std::wstring GetMultiCastAddress() { return m_MuliCastAddress; }
		inline BOOL GetTriggerStatus() { return m_bIncludeTrigger; }
		BOOL GetWorkingAgainstPEC();
		std::wstring CreateHTTPFormatNameFromPathName(const std::wstring & wcsPathName, bool bHTTPS );       
		inline bool IsCluster ()  { return m_bMachineIsCluster; }
	private:
		bool IsLocalUserSupportEnabled();
		BOOL iamWorkingAgainstPEC ();
		BOOL m_fAmWorkingAgainstPEC;
		EncryptType HasEnhancedEncryption( std::wstring wcsMachineName ); // Return 128 / 40  Encryption Support
		EncryptType DetectEnhancedEncrypt (); // Return 128 / 40  Encryption Support.
		INT iAmMSMQInWorkGroup ();
		BOOL iAmLocalUser ();
		bool iAmCluster();
		std::wstring GetFullDNSName(std::wstring wcsHostName);
		INT iAmDC (void);
		bool AmIWin9x ();
		bool CheckIfServiceRuning( std::wstring wcsMachineName , std::string csServiceName );
		bool IsMSMQInstallSucceded ();
		bool IsDnsHostNameExist (std::wstring wcsRemoteMachineFullDNSname );
		int DeleteAllQueues ();
		e_InstallationType m_InstallationType;
		EncryptType m_EncryptType;
		BOOL m_bUseOnlyDirectFormatName;
		bool m_bDeleteFullDNSQueue;
		QueuesInfo AllQueuesInTheTest;
		std::list<my_Qinfo> m_listQueuesFormatName;
		std::wstring m_MuliCastAddress;
		BOOL m_bIncludeTrigger;
		bool m_bMachineIsCluster;
		BOOL m_RemoteIsNT4;
	};

	class ThreadBase_t
	{

	public:
	  ThreadBase_t();
	  virtual ~ThreadBase_t();  
	  void StartThread();
	  virtual void Suspend();
	  virtual void Resume();
	  HANDLE GetHandle()const;
	  DWORD GetID()const; 
	private:
	   virtual INT ThreadMain()=0; 
	   static unsigned int __stdcall ThreadFunc(void* params);
	   HANDLE m_hThread;
	   DWORD m_Threadid;
	};

	typedef std::pair<std::wstring,std::wstring> OUT_GOING_QUEUE_OBJECT;

	class cTest :public ThreadBase_t
	{
	
	public:
		cTest( const INT iTestNumber ); 
		cTest() :m_testid(0) {};
		virtual ~cTest(){};
		inline INT Get_Testid() { return m_testid; } // Return Test Number
		//
		// Pure Virtual Member All tests need to implement those function
		//
		virtual void Description() = 0 ;  // Print Test Description
		virtual INT Start_test()  = 0 ;   // Start Test
		virtual INT CheckResult() = 0 ; // Check The Pass \ Fail
		std::wstring m_wcsGuidMessageLabel;
		INT m_testid;
		INT ThreadMain();
		void AutoInvestigate();
		void VerifySendSucceded( std::wstring wcsDestQueueFormatName, std::wstring wcsAdminQueueFormatName = g_wcsEmptyString);
	protected:
		std::wstring m_wcsDescription;
	private:
		void UpdateInvestigateOutingQueueState(std::wstring wcsFormatName,std::wstring wcsMachineName = g_wcsEmptyString);		
		bool IsLocalQueue(std::wstring wcsFormatName,std::wstring & wcsQueuePathName );
		void EnableInvestigate();
		HRESULT CheckOutGoingQueueState();
		std::wstring All_queue_type; // All the Queue must Create with the Same Type For Delete process
		GUID m_gTestguid; // Test has a guid per instance
		bool m_bInvestigate;
		std::vector<OUT_GOING_QUEUE_OBJECT> m_OutGoingQueueObjects;

	};

	//
	// Path To support NT4 Machines
	// MQRegisterCertificate Api.
	//

	typedef HRESULT  
	(APIENTRY * DefMQRegisterCertificate) 
	(
    IN DWORD   dwFlags,
    IN PVOID   lpCertBuffer,
    IN DWORD   dwCertBufferLength
	);

	

	typedef
	HRESULT
	(APIENTRY * DefMQADsPathToFormatName)
	(
		IN LPCWSTR lpwcsADsPath,
		OUT LPWSTR lpwcsFormatName,
		IN OUT LPDWORD lpdwFormatNameLength
	);





    
//
// bugbug - Default parmerter is for recive operation needs to know abot the buffers size
//

//
// class cPropVar 
// 
// This class provides methods for manipulating
// the PROPVARIANT structure and array.
//
// It is called by threads that create queues
// and threads that send or receive messages.
//
class cPropVar 
{
public:
	cPropVar ( INT iNumberOFProp ); 
	//cPropVar () : pQueuePropID(NULL),pPropVariant(NULL),hResultArray(NULL),iNumberOfProp(0) {};
	virtual ~cPropVar ();
	virtual INT AddProp( QUEUEPROPID cPropID , VARTYPE MQvt , const void *pValue , DWORD dwsize = 0 );
	int ReturnMSGValue ( QUEUEPROPID cPropID , VARTYPE MQvt  ,void * pValue );
	MQQUEUEPROPS * GetMQPROPVARIANT ();
	MQQUEUEPROPS m_QueueProps;
	MQMSGPROPS * GetMSGPRops ();
	MQPROPVARIANT ReturnOneProp( QUEUEPROPID aPropID) ;
	MQMSGPROPS m_myMessageProps;
	
	friend HRESULT APIENTRY MQCreateQueue(
					IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
					IN OUT MQQUEUEPROPS* pQueueProps,
					OUT LPWSTR lpwcsFormatName,
					IN OUT LPDWORD lpdwFormatNameLength    );

	friend HRESULT 	APIENTRY MQSendMessage(
											IN QUEUEHANDLE hDestinationQueue,
											IN MQMSGPROPS* pMessageProps,
											IN ITransaction *pTransaction  );
	friend HRESULT APIENTRY MQReceiveMessage(
												IN QUEUEHANDLE hSource,
												IN DWORD dwTimeout,
												IN DWORD dwAction,
												IN OUT MQMSGPROPS* pMessageProps,
												IN OUT LPOVERLAPPED lpOverlapped,
												IN PMQRECEIVECALLBACK fnReceiveCallback,
												IN HANDLE hCursor,
											    IN ITransaction* pTransaction
											);


	
private:
	INT iNumberOfProp;
	QUEUEPROPID *  pQueuePropID;
	MQPROPVARIANT *  pPropVariant;
	HRESULT *  hResultArray;
};



HRESULT CheckCertificate ( DWORD dwRegisterFlag );
INT cMQSetupStage ( SetupType eSetupType ,  cBvtUtil & CurrentTest  );


class cLevel8:public cTest
{
	public:
		cLevel8 (std::map <std::wstring,std::wstring> & Params);
		~cLevel8 ();
		virtual void Description();     // Print Test Description
		virtual INT Start_test();       // Start Test
		virtual INT CheckResult();    // Check The Pass \ Fail
		INT DebugIt();
	private:		
		std::wstring m_DestQueueFormatName;
		std::wstring m_wcsPassWord,m_wcsUserName,m_wcsDomainName;
		HANDLE m_hSeCtxt;
};

class cSendMessages :public cTest 
{
	public:
		
		cSendMessages (INT iTid, std::map <std::wstring,std::wstring> Params );
		virtual ~cSendMessages () {};
		void Description();   // Print Test Description
		INT Start_test();     // Start Test
		INT CheckResult();  // Check The Pass \ Fail
	
	private:
		HRESULT FindMessageInQueue (HANDLE hQueue , HANDLE & Cursor ,GUID );
		
		std::wstring wcsGuidMessageLabel;
		std::wstring m_wcsDestQueueFullPathName; // the Full Path name need to incluse the machine name
		std::wstring m_wcsDestQFormatName,m_wcsAdminQFormatName;
		std::wstring m_wcsDestDirectFormatName;
		std::wstring m_wcsAdminDirectFormatName;
		std::wstring m_wcsDestHTTPDirectFormatName;
		BOOL m_bUseHTTPDirectFormatName;
		BOOL m_bUseOnlyDirectFormatName; 
	
};


// Transaction test class






class StrManp 
{
public:
	StrManp (int size,std::wstring str);
	StrManp (int size);
	~StrManp();
	void SetStr(std::wstring str);
	inline std::wstring  GetStr(int Index) { return ((Index < Size) ? array[Index].c_str():NULL); }
	void print ();
	void Clear();
	friend int operator != (StrManp& s1,StrManp &s2);
	friend int operator == (StrManp& s1,StrManp &s2);
private:
	void operator = (StrManp Csrc);
	std::vector<std::wstring> array;
	const int Size;
};
int operator == (const StrManp& s1,const StrManp &s2);



class OrderTransaction 
{
	
public:
	OrderTransaction ( bool bUseExVersion );
	virtual ~OrderTransaction();
	INT OrderTransaction::xDTCBeginTransaction(ITransaction ** ppXact );
private:
	HINSTANCE m_hxolehlp;
};

class cTrans : public cTest
{
public:
	cTrans (INT index , std::map < std :: wstring , std:: wstring > Tparms,bool bTemp);
	virtual ~cTrans();
	void Description();
	virtual INT Start_test();
	virtual INT CheckResult();	
	virtual void CleanAfterTest () {};
private:
	void operator = (cTrans Csrc);
	StrManp * m_pSendBlock;
	std::wstring m_wcsFormatNameBufferQ1;
	std::wstring m_wcsFormatNameBufferQ2;
	const int m_ciNumberOfMessages;
	OrderTransaction cOrderTransaction;
	wchar_t m_wcsTempBuf[20];
	bool m_bRunOnDependetClient;
protected:
	DWORD m_ResualtVal; 
};




class SecCheackAuthMess : public cTest
{
protected:
	MSMQ::IMSMQQueueInfoPtr  m_Destqinfo; //Dest queue
	MSMQ::IMSMQQueueInfoPtr  m_Adminqinfo;// Admin queue
	std::wstring  m_DestqinfoFormatName;
	std::wstring  m_AdminqinfoFormatName;
	std::wstring  m_wcsGuidMessageLabel2;
	std::wstring  m_DestQueueInfoPathName;
	DWORD m_ResualtVal;
	MSMQ::IMSMQMessagePtr m_msg;
	const int cNumerOfMessages;
public:
	void operator = (SecCheackAuthMess Csrc);
	SecCheackAuthMess (int Tnumber ,  std :: map <std::wstring,std::wstring> TestParms );
	virtual ~SecCheackAuthMess();
	void Description();
	virtual INT Start_test();
	virtual INT CheckResult();	
	virtual void CleanAfterTest () {};
	bool m_bTryToRefreshLater;
	BOOL m_bUseHttpFormatName;
	bool m_bNeedToRefresh;
};

//
// Check Get machine name 
//
class MachineName : public cTest
{
public:
	MachineName (int iTestIndex , std::map < std::wstring , std :: wstring > Tparmes );
	int Start_test ();
	inline int CheckResult (){ return MSMQ_BVT_SUCC; };
	void Description();   // Print Test Description
private:
	std::wstring wcsLocalMachineName,wcsLocalMachineFullDns,wcsRemoteMachine,wcsRemoteMachineFullDns;
	bool m_bWorkWithFullDNSName;
	bool m_IsCluster;
};

class xToFormatName  : public cTest
{
public:
	xToFormatName (int iTestIndex , std::map < std::wstring , std :: wstring > Tparmes );
	
	int Start_test ();
	int CheckResult ();
	void Description() ;   // Print Test Description

private:
	bool m_bWorkGroupInstall;
	bool m_bCanWorksOnlyWithMqAD;
	int m_iEmbedded;
	std::wstring m_wcsFormatNameArray[2];
	std::wstring m_wcsPathNameArray[2];
	
};


class PrivateMessage :public cTest
{
public:
	PrivateMessage (INT index, std :: map <std::wstring, std::wstring >);
	virtual ~PrivateMessage();
	void Description();
	INT CommonMsgProperty();
	virtual INT Start_test();
	virtual INT CheckResult();
	virtual void CleanAfterTest () {} ;
private:
	DWORD Private_level;
	WCHAR m_DestqinfoFormatName[BVT_MAX_FORMATNAME_LENGTH];
	WCHAR m_AdminqinfoFormatName[BVT_MAX_FORMATNAME_LENGTH];
	BOOL m_bUseEnhEncrypt;
	wchar_t wcszMlabel[30]; // Message Label for 128 bit encrypt
	std::wstring wcsNACKMessageGuid;
	std::wstring m_wcsAdminQFormatName;
protected:
	MSMQ::IMSMQQueueInfoPtr m_Destqinfo;
	MSMQ::IMSMQQueueInfoPtr m_Adminqinfo;
	DWORD m_ResualtVal;
	MSMQ::IMSMQMessagePtr m_msg;
};

/*
	Send transaction message using DTC to remote queue.
	using com interface.

*/
class xActViaCom : public cTest
{
public:
	xActViaCom (INT index , std::map < std :: wstring , std:: wstring > Tparms );
	virtual ~xActViaCom();
	void Description();
	virtual INT Start_test();
	virtual INT CheckResult();	
	void operator = (xActViaCom Csrc);
protected:
	std::wstring m_wcsDestQueueFormatName;
	std::wstring m_SeCTransactionGuid;
	BOOL m_bNT4WithSp6;
	MSMQ::IMSMQQueueInfoPtr  m_Destqinfo;
	INT m_ixActIndex;
	StrManp * m_pSendBlock;
	const INT m_iMessageInTransaction;
};

class xActUsingCapi: public xActViaCom
{
	public:
		xActUsingCapi (INT index , std::map < std :: wstring , std:: wstring > Tparms );
		virtual INT CheckResult();
	private:
		void operator = (xActUsingCapi Csrc);
		
};


/*
	This class check authenticate messages with NOT authenticate queue !
	The tests is to send authenticate and see if the message reach to the queue
	This check by Admin queue ACK/NACK


  */


class CheckNotAuthQueueWITHAuthMessage :public SecCheackAuthMess 
{
public:
	CheckNotAuthQueueWITHAuthMessage(int i , std::map < std::wstring , std::wstring > & Tparms );
	virtual ~CheckNotAuthQueueWITHAuthMessage()	{};
	void Description();
};

class CheackAuthQueueWithOutAuthMessgae:public SecCheackAuthMess 
{
public:
	CheackAuthQueueWithOutAuthMessgae(int i , std :: map < std ::  wstring  ,std :: wstring> & Tparms);
    int Start_test();
};

//
// 
//

class COpenQueues :public cTest
{
public:
	COpenQueues ( INT Index,  std::map<std::wstring,std::wstring>  & Tparms );
	~COpenQueues () {};
	INT Start_test ();
	INT CheckResult();
	void Description();
private:
	INT iWorkGroupFlag;
	void dbg_printAllQueue();
	int m_iEmbedded;
	std::wstring m_wcsLocalMachineName;
	std::vector <std::wstring> m_MachineName;
	std::vector <std::wstring> m_IPaddress;
	std::vector <std::wstring> m_MachineGuid;
	std::vector <std::wstring> m_vSpeceilFormatNames;
};


//
// This class check if mqoa register, 
// this check the IDispatch machnizem.
//
class isOARegistered : public cTest
{
public:
	isOARegistered (int Tnumber ): cTest( Tnumber ) {};
	virtual ~isOARegistered() {};
	void Description();
	virtual INT Start_test();
	inline virtual INT CheckResult() { return MSMQ_BVT_SUCC;	}
	virtual void CleanAfterTest () {};
};

INT CatchComErrorHandle ( _com_error & ComErr , int  ITestID);
void ErrorHandleFunction (std::wstring Message,HRESULT hRc,const CHAR * File,const INT Line);
#define ErrHandle(hRc,ExpectedResualt,Message) if (hRc != ExpectedResualt) { ErrorHandleFunction (Message,hRc,__FILE__,__LINE__); return MSMQ_BVT_FAILED; }

std::wstring ToLower(std::wstring wcsLowwer);


class cLocateTest : public cTest
{
public:
	cLocateTest (INT index , std::map < std :: wstring , std:: wstring > Tparms );
	virtual ~cLocateTest() {};
	void Description();
	virtual INT Start_test();
	virtual INT CheckResult();	
private:
	std::wstring wcsLocateForLabel;
	INT icNumberOfQueues;
	std::wstring m_wcsLocalMachineName;
	std::wstring m_wcsLocalMachineComputerName;
	std::wstring m_wcsLocalMachineFullDNSName;
	int m_iEmbedded;
	bool m_bUseStaticQueue;
	bool m_bWorkAgainstNT4;
};


class cSetQueueProp : public cTest
{
public:
	cSetQueueProp (int iTestIndex,std::map < std :: wstring , std:: wstring > Tparms );
	~cSetQueueProp();
	int Start_test ();
	int CheckResult ();
	void Description() ;   // Print Test Description

private:
	std::wstring m_destQueueFormatName;
	std::wstring m_QueuePathName;
	std::wstring m_RandQueueLabel;
	std::wstring m_publicQueueFormatName;
	BOOL VerifyQueueHasOwner (SECURITY_DESCRIPTOR *pSD);
	BOOL GetOnerID( PSID pSid );

};

//
// This class tests the Triggers functionality.
// It uses the hack in the Triggers service that sends a MSMQ message to queue
// .\private$\TriggerTestQueue containing information about invoked action.
// This hack works only if "TriggerTest" REG_SZ with empty string  is defined in registry in path:
// HKLM MSMQ\Triggers. In order to get the messages from the Triggers service, after defining the key, 
// it is requiered to stop and start the service
// 

class CMqTrig:public cTest
{
	public:
		CMqTrig():iNumberOfTestMesssges(2){ assert(0); }
	    CMqTrig( const INT iIndex, cBvtUtil & cTestParms);
		CMqTrig( CMqTrig & );
		void Description();
		INT Start_test();
		INT CheckResult(); 
	private:
		const int iNumberOfTestMesssges;
		std::wstring m_wcsResultQueueFormatName;
		void operator = (const CMqTrig & Csrc );
		std::set < std::wstring > m_MessagesGUIDS; 
		std::vector<std::wstring> m_vecQueuesFormatName;
};		


class CMqAdminApi:public cTest
{
	public:
		CMqAdminApi( const INT iIndex , std::wstring m_wcsLocalComputerNetBiosName);
		~CMqAdminApi();
		void Description();
		INT Start_test();
		INT CheckResult(); 
	private:
		MQMGMTPROPS mqProps;
		PROPVARIANT propVar[11];
		PROPID propId[11];
		std::wstring m_wcsLocalComputerNetBiosName;
		std::wstring m_wcsFormatName;
		std::wstring m_wcsLabel;

        HRESULT CleanQueue();

};		

class CSRMP:public cTest
{
	public:
		CSRMP( const INT iIndex , std::wstring m_publicQueueFormatName);
		~CSRMP();
		void Description();
		INT Start_test();
		INT CheckResult(); 
	private:
		LPWSTR m_pEnvelope;
		HANDLE m_hCursor;
		HANDLE m_hQueue;
		std::wstring m_publicQueueFormatName;

};			

class CRemotePeek:public cTest 
{
	public:
		CRemotePeek();
		CRemotePeek (INT iTid, std::map <std::wstring,std::wstring> Params );
		virtual ~CRemotePeek () {};
		void Description();   // Print Test Description
		INT Start_test();     // Start Test
		INT CheckResult();  // Check The Pass \ Fail
 	private:
         INT Prepare();
		 bool m_bDepenetClient;
		 std::wstring m_cwcsPeekBody; 
		 std::wstring m_cwcsPeekLabel;
		 std::wstring m_cwcsFormatName;
		 std::wstring m_cwcsQueueName;
		 std::wstring m_RemoteMachineName;
};

class Log 
{
public:
	Log(std::wstring wcsLogFileName);
	~Log();
		
	int WriteToFile ( std::wstring wcsLine );
private:
	CCriticalSection m_Cs;
	HANDLE hLogFileHandle;
	bool m_bCanWriteToFile;
};

//
// Bvt global log file
// 
#define DebugMqLog(params)\
	if (g_bDebug)     \
	{                 \
		MqLog(params);\
	}                 

#define DebugwMqLog(params)\
	if (g_bDebug)     \
	{                 \
		wMqLog(params);\
	}    
extern P<Log> pGlobalLog;
#define MAXCOMMENT 400
void MqLog(LPCSTR lpszFormat, ...);
void wMqLog(LPWSTR lpszFormat, ...);
void wMqLogErr(LPWSTR lpszFormat, ...);
void MqLogErr(LPCSTR lpszFormat, ...);
#define MqBvt_SleepBeforeWait (5000) // time in Sec sleep before test.
#define Total_Tests 34

//bugbug
#define g_cwcsDlSupportCommonQueueName L"DLQueues"

/*
	ThreadBase_t class function implementation.
*/

//constructor
inline ThreadBase_t::ThreadBase_t():m_hThread(NULL),m_Threadid(0)
{
  
}


//destructor
inline ThreadBase_t::~ThreadBase_t()
{
	if(m_hThread != NULL)
	{
		CloseHandle(m_hThread);
	}
}


//return the thread handle
inline HANDLE ThreadBase_t::GetHandle ()const
{
  return m_hThread;
}
 
//return the thread id
inline DWORD ThreadBase_t::GetID()const
{
  return m_Threadid;
}

//create the actual thread-must be called first
inline void ThreadBase_t::StartThread()
/*++
	Create Thread and duplicate handle
--*/
{

  
 HANDLE h=(HANDLE)_beginthreadex(NULL,
	                              8192,
								  ThreadBase_t::ThreadFunc,
								  this,
								  CREATE_SUSPENDED,
								  reinterpret_cast<unsigned int *>(&m_Threadid));
  if(h == NULL)
  {
	 INIT_Error("Failed to create thread \n");  
  }

  BOOL b=DuplicateHandle(GetCurrentProcess(),
	              h,
				  GetCurrentProcess(),
				  &m_hThread,
				  0,
				  FALSE,
				  DUPLICATE_SAME_ACCESS);

  if(b != TRUE)
  {
	INIT_Error("Falied to duplicate handle");
  }
  ResumeThread(h);
  b=CloseHandle(h);
  assert(b);

}

//thread function - calls to the drived class Run method
inline  unsigned int __stdcall ThreadBase_t::ThreadFunc(void* params)
{
  // 
  // Casting this pointer to the drived class ThreadMain
  //
  ThreadBase_t* thread = static_cast<ThreadBase_t*>(params);
  unsigned int ret=thread->ThreadMain();
  return ret;
}


//suspend the thread
inline void ThreadBase_t::Suspend()
{
  SuspendThread(m_hThread);
}


//resume the thread
inline void ThreadBase_t::Resume()
{
  ResumeThread(m_hThread);
}


//
// Auto class for free library
//


class AutoFreeLib
{
public:
	AutoFreeLib(const CHAR * csLibName ):
	m_hModule(NULL)
	{
		m_hModule = LoadLibrary( csLibName );
		if( !m_hModule )
		{
			throw INIT_Error("Failed to load DLL\n");
		}
		
	}
	virtual ~AutoFreeLib () { if(m_hModule!= NULL) 
								FreeLibrary(m_hModule);
							}
	inline HMODULE GetHandle() { return m_hModule; }

private:
	
	HMODULE m_hModule;
	
};


class cMqNTLog
{
public:
	cMqNTLog( const std::string & csFileName  );
	~cMqNTLog();
	cMqNTLog( const cMqNTLog & CCopy);
	void ReportResult(bool bRes , CHAR * pcsString);
	void LogIt( const std::string & csLine );
	BOOL VLog( DWORD dwFlags, char* fmt, va_list arglist );
	BOOL CreateLog( char *szLogFile );
	BOOL __cdecl Info( char* fmt, ... );
    BOOL __cdecl Sev1( char* fmt, ... );
    BOOL __cdecl Warn( char* fmt, ... );
    BOOL __cdecl Pass( char* fmt, ... );
	void Report();
	BOOL BeginCase( char* szVariation );
	BOOL EndCase ();

private:
	void operator = ( const cMqNTLog & CLog);
	P<AutoFreeLib>m_NTLog;
	HANDLE m_hLog;
	char * m_szVariation;
//
// HANDLE APIENTRY  tlCreateLog_W(LPCWSTR,DWORD);
//
	typedef HANDLE 
	(APIENTRY * tlCreateLog_A) 
	(LPCSTR,DWORD);
//
// BOOL   APIENTRY  tlAddParticipant(HANDLE,DWORD,int);	
//
	typedef BOOL  
	(APIENTRY * tlAddParticipant)
	(HANDLE,DWORD,int);
//
// DWORD  APIENTRY  tlEndVariation(HANDLE);
//
	typedef DWORD
	(APIENTRY * tlEndVariation)
	(HANDLE);

//
// DWORD  APIENTRY  tlEndVariation(HANDLE);
//
	typedef DWORD
	(APIENTRY * tlEndVariation)
	(HANDLE);
	
//
// BOOL FAR cdecl tlLog_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR,...);
//
	typedef BOOL
	(FAR cdecl * tlLog_A)
	(HANDLE,DWORD,LPCSTR,int,LPCSTR,...);
//
// VOID   APIENTRY  tlReportStats(HANDLE);
//
	typedef VOID
	(APIENTRY * tlReportStats)
	(HANDLE);
//
//  BOOL   APIENTRY  tlStartVariation(HANDLE);
//
	typedef BOOL
	(APIENTRY * tlStartVariation)
	(HANDLE);
//
//  BOOL	tlDestroyLog(HANDLE)
//
	typedef BOOL
	(APIENTRY * tlDestroyLog)
	(HANDLE);

	tlCreateLog_A m_pCreateLog_A;
	tlAddParticipant m_ptlAddParticipant;
	tlEndVariation m_ptlEndVariation;
	tlLog_A m_ptlLog_A;
	tlReportStats m_ptlReportStats;
	tlStartVariation m_ptlStartVariation;
	tlDestroyLog m_ptlDestroyLog;
};

void SetThreadName ( int dwThreadId , LPCSTR szThreadName );

long GetADSchemaVersion();

class cDCom :public cTest 
{
	public:	
		cDCom (INT iTid, std::map <std::wstring,std::wstring> & mParams , bool bWkg);
		virtual ~cDCom ();
		void Description();   // Print Test Description
		INT Start_test();     // Start Test
		INT CheckResult();  // Check The Pass \ Fail
	private:
		IMSMQQueueInfo * m_pIQueueInfoInterface;
		IMSMQQueue * m_pIQueueHandle;
		IMSMQMessage * m_pIMsg;
		std::wstring m_wcsRemoteComputerName;
		std::wstring m_PublicQueueFormatName;
		std::wstring m_PublicQueuePathName;
		std::wstring m_wcsRemoteMachieName;
		bool m_bWkg;
};


#ifdef _DEBUGASSERT
//	#undef ASSERT
//	#define ASSERT(f)          _assert(f)
#endif // !_DEBUG

#endif _MSMQBVT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\randstr.h ===
#ifndef _MyLang 
#define _MyLang 

	INT GetRandomStringUsingSystemLocale(
										DWORD lcid,
										WCHAR * pBuffer,
										INT dwBufferLen 
										);
													

	DWORD LocalSystemID (void);


#endif _MyLang
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\mqparams.h ===
/*++

Class Description:
    This class takes the arguments from the command line
    and puts them into a container. You can get each
    argument by calling GetPrm. You can find if argument 
    exists by calling	.

Written By:
    Ofer Gigi.

Version:
	1.01  - 16/11/2000

--*/
        
#ifndef PARAMINPUT_H
#define PARAMINPUT_H

#pragma warning(disable :4786)

#include "msmqbvt.h"
std::string ToStrLower(std::string csLowwer);

class CInput     
{    
public:  
    CInput(int argc, char *argv[]);
	CInput(const CInput& in);
    CInput(const std::string& str);
    virtual ~CInput(){};
    bool IsExists(const std::string& str)const;
    std::string operator[](const std::string& str)const ;
	long CInput::GetNumber(const std::string& str)const ;
	CInput& operator=( const CInput& in);
    std::map<std::string,std::string> GetMap()const;
    
private:
    mutable std::map<std::string,std::string> m;
    void ParseToken(const std::string& str,
                    std::string::size_type tokenstart,std::string::size_type tokenfinish);
};    

inline std::map<std::string,std::string> CInput::GetMap()const
{
  return m;
}

inline CInput& CInput::operator=(const CInput& in)
{
  if( static_cast<const void*>(this) != static_cast<const void*>(&in))
  {
    m=in.m;
  }
  return *this;
}

 

inline CInput::CInput(const CInput& in):m(in.m)
{


}

/*++
Routine Description:
    This routine takes the arguments from the command line
    and puts them into a container. Each token 
    ("/command:value") is already apart from the other tokens.

Arguments:
    argc(IN) - number of arguments in the command line.
    argv(IN) - the arguments in the command line.
        
Return Value:
    none.

Note:
    When you are creating this object using THIS constructor
    the first argument is THE NAME OF THE PROGRAM so this 
    argument is not included in the container. 
--*/

inline CInput::CInput(int argc, char *argv[])
{
    int i;
    for (i=1;i<argc;i++)
    {
        ParseToken(argv[i],0,std::string::npos);
    }
}


/*++
Routine Description:
    This routine takes the string from the command line,
    then takes the tokens ("/command:value") from it and
    puts them into a container. 

Arguments:
    str (IN) - all the arguments contained in one string.

Return Value:
    none.
--*/

inline CInput::CInput(const std::string& str)
{
    std::string::size_type tokenstart=0;
    std::string::size_type tokenfinish=0;
    while ((tokenstart!=std::string::npos) && (tokenfinish!=std::string::npos))
    {
        tokenstart=str.find_first_not_of(' ',tokenfinish);
        if (tokenstart!=std::string::npos)
        {
            tokenfinish=str.find_first_of(' ',tokenstart);     
            if (tokenfinish==std::string::npos)
            {
                ParseToken(str,tokenstart,tokenfinish);
            }
            else
            {
                ParseToken(str,tokenstart,tokenfinish-1);
            }
        }
    }
}

/*++
Routine Description:
    This routine takes the token apart to two parts
    command and value and puts them into the container.

Arguments:
    str (IN) - the string from the command-line.
    tokenstart (IN) - where the token begins in the string.
    tokenfinish (IN) - where the token ends in the string.

Return Value:
    none.
--*/

inline void CInput::ParseToken(const std::string& str,
                               std::string::size_type tokenstart,
                               std::string::size_type tokenfinish)
{
    std::string command;
    std::string value;
    std::string::size_type commandstart;
    std::string::size_type valuestart;
    commandstart=str.find("-",tokenstart)+1;
    valuestart=str.find(":",tokenstart)+1;
    if ((commandstart!=std::string::npos) &&
        (valuestart!=std::string::npos) &&
        (commandstart<valuestart) &&
        (commandstart>=tokenstart) &&
        (commandstart<=tokenfinish) &&
        (valuestart>=tokenstart) &&
        (valuestart<=tokenfinish))
    {
        command=str.substr(commandstart,valuestart-1-commandstart);
		command = (std::string)ToStrLower( command );
        if (tokenfinish!=std::string::npos)
        {
            value=str.substr(valuestart,tokenfinish+1-valuestart);
        }
        else
        { 
            value=str.substr(valuestart);
        }
        m[command]=value;
		return;
    }

    if ((commandstart!=std::string::npos) &&
        ((valuestart==std::string::npos) || (valuestart>tokenfinish) || (valuestart==0)) &&
        (commandstart>=tokenstart) &&
        (commandstart<=tokenfinish))
    {
        if (tokenfinish!=std::string::npos)
        {
            command=str.substr(commandstart,tokenfinish+1-commandstart);
        }
        else 
        {
            command=str.substr(commandstart);
        }
		command = (std::string)ToStrLower( command );
        m[command]="";
    }
}

/*++
Routine Description:
    This routine takes a string and checks if the string 
    is a key in the container.

Arguments:
    str (IN) - the key that we are checking.

Return Value:
    (OUT) - returns true if the key exists in the container.
--*/

inline bool CInput::IsExists(const std::string& str)const
{
    std::map<std::string,std::string>::const_iterator p=m.find(str);
    if (p==m.end())
    { 
        return false;
    }
    else
    {
        return true;
    }
}

/*++
Routine Description:
    This routine takes a string - a key in the container
    and if the key exists returns its value, else
    returns empty string.

Arguments:
    str (IN) - the key.

Return Value:
    (OUT) - returns the value of the key if the key exists
    in the container else returns empty string.
--*/

inline std::string CInput::operator[](const std::string& str)const
{
   if (IsExists(str))
    {
      return m[str];
    }
    else
    {    
       return "";
    }
}
 

/*++
Routine Description:
  return numeric value for given
  key

Arguments:
    str (IN) - the key.


--*/

inline long CInput::GetNumber(const std::string& str)const
{
	std::string s=operator[](str);
	return atol(s.c_str());
}


 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\randstr.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: randstr.cpp

Abstract:
	
Author:
    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#include "msmqbvt.h"
#include <time.h>
bool g_bInitRand = false;
int StrGen(
		   LCID lcid,           //Locale ID               
		   int nStyle,			//0 for ansi 
							    //1 for DBCS and 2 for Mixed
		   int length,			//the lenght of string 
								//0 for random MAX Limit is 255,
								//-1  for random MAX Limit is 65535,
		   int nFormat,			//0: ANSI 1:UNICODE
		   void **pStr
		   );

//
// This function retrieves the default system locale for the machine.
// Return value:
// Succ - DWORD lcid; 
// Failed - 0;
//



DWORD LocalSystemID ( void )
{
	CHAR csSystemLocaleBuffer[10];
	DWORD dwSystemLocaleBufferSize = 10;
	
	int ret = GetLocaleInfo( 
							 LOCALE_SYSTEM_DEFAULT, 
							 LOCALE_IDEFAULTLANGUAGE,
							 csSystemLocaleBuffer,
							 dwSystemLocaleBufferSize
							);
	if ( ret == 0 )
	{
		return GetLastError();
	}
	LCID currentSystemlcid;
	//
	// Convert to dword format
	// 
	int iElemtSuccededToConvert = sscanf(csSystemLocaleBuffer,"%x",&currentSystemlcid);
	if( iElemtSuccededToConvert != 1 )
	{
		throw INIT_Error("sscanf failed \n");
	}
	return currentSystemlcid;
}
//
// GetRandomStringUsingSystemLocale
// Function return string that contain Alpha char from the default system locale
// input paramters:
// DWORD lcid - system locale.
// WCHAR * pBuffer - buffer to contain.
// DWORD dwBufferLen - buffer size.
//
//

BOOL GetRandomStringUsingSystemLocale (DWORD lcid, WCHAR * pBuffer , INT iBufferLen )
{	

   USHORT * uCurType;
   void * vp=NULL;
   int index = 0;
   do
   {
		StrGen( lcid ,1, (iBufferLen * 20) ,1,&vp);
		if (vp == NULL)
		{
			return FALSE;
		}
		if(! wcscmp((WCHAR * )vp,L"") )
		{
			free (vp);
			continue;
		}
		uCurType = (USHORT * ) calloc ( sizeof( USHORT ) * (iBufferLen * 21) , sizeof ( USHORT ) );
		
		if( uCurType == NULL )
		{
			return FALSE;
		}

		WCHAR * pwcsRandomstring=NULL;
		pwcsRandomstring = (WCHAR * ) malloc ( sizeof (WCHAR * ) *  ( wcslen ((WCHAR *) vp) + 1 ));
		if( pwcsRandomstring == NULL )
		{
			return FALSE;
		}
		wcscpy (pwcsRandomstring ,  (WCHAR * ) vp);
		BOOL bHr = GetStringTypeExW( LOCALE_SYSTEM_DEFAULT,
									 CT_CTYPE3,  
	     			  			     pwcsRandomstring,  
								     -1,
								     uCurType
								    );
		if ( bHr == FALSE )
		{
			DWORD dwHr = GetLastError ();
			MqLog( "GetStringTypeExW failed %d\n" , dwHr );
			return FALSE;
		}
		for ( int i = 0 ; i < ( iBufferLen * 20 ) ; i ++ )
		{	
			if( uCurType[i] & C3_ALPHA  )
			{
				pBuffer[index]=pwcsRandomstring[i];
				index ++;
			}
			if ( index == ( iBufferLen ) )
			{
				break;
			}
		}
		free(pwcsRandomstring);
		free (vp);
		free (uCurType);		
		if ( index == ( iBufferLen ) )
		{
			break;
		}
   }
   while ( index < iBufferLen );
   pBuffer[index-1] = L'\0';

   return TRUE;
}




int StrGen(    LCID lcid,           //Locale ID               
		       int nStyle,			//0 for ansi 
								    //1 for DBCS and 2 for Mixed
		       int length,			//the lenght of string 
									//0 for random MAX Limit is 255,
									//-1  for random MAX Limit is 65535,
		       int nFormat,			//0: ANSI 1:UNICODE
		       void **pStr
		  )
{
	WCHAR *awString = NULL;
    WORD UnicodeRangeUpper=0x7f,UnicodeRangeLower=0;
    int i=0;
	
	//for jpn character (Test!)
	BOOL fJpn = FALSE;													//added
	WORD wKanji[6] = {0x4fff,0x5000,0x9F9E,0x7aef,0x7d6d,0x6c5f};		//added

    if ( (0 !=nFormat) && (1 !=nFormat) )
	{
		assert(0 && "unsupported format");
		nFormat = 0;
	}
    if (nFormat)
    {
        awString = (WCHAR *) malloc(sizeof(WCHAR)*(length+1));
        if (awString == NULL)
		{
		    return 2;
		}
        if  (LANG_ARABIC == LOBYTE(lcid)) 
        {
            UnicodeRangeUpper=0x06FF;
            UnicodeRangeLower=0x0600;
        }
        else if (0x040D == lcid)  //Hebrew
        {
            UnicodeRangeUpper=0x05FF;
            UnicodeRangeLower=0x0590;
        }
		else if (0x0409 == lcid) // Latin
		{
            UnicodeRangeUpper = 0x007F;
            UnicodeRangeLower = 0x0001;
		}
		else if (0x0411 == lcid) // Those are real JPN chrcater 
		{
			fJpn = TRUE;
			// use Hiragana & KATAKANA charcter legal 
			UnicodeRangeUpper = 0x30ff;
		    UnicodeRangeLower = 0x3040;
		}
		else // Fix bug in whistler.
		{
			  UnicodeRangeUpper = 0x00FF;
              UnicodeRangeLower = 0x0001; 
		}

        /*else  // Latin-1 supplement.
        {
              UnicodeRangeUpper = 0x00FF;
              UnicodeRangeLower = 0x0000; 
			awString[0]=L'\0';
			nStyle = 0;
        } */
		
    }
	if ( g_bInitRand == false )
	{
		srand( (unsigned)time( NULL ) );
		g_bInitRand = true;
	}
	//
	// Pure locale string
	// 
	if( 1 == nStyle )
	{
		if ( 1 == length) 
		{
			length++;
		}
       
		if (fJpn)	//added
		{
			for (i=0;i<length;i++)
			{
				if (i<sizeof(wKanji)/sizeof(WCHAR))
				{
					awString[i] = (WCHAR)wKanji[i];
				}
				else
				{
					awString[i] = (WCHAR)(rand() % (UnicodeRangeUpper-UnicodeRangeLower+1)+UnicodeRangeLower); 
				}
			}
		}
		else
		{
			for (i=0;i<length;i++)
			{
			     awString[i] = (WCHAR)(rand() % (UnicodeRangeUpper-UnicodeRangeLower+1)+UnicodeRangeLower); 
			}
        }

        awString[length]=L'\0';
        
	}

	*pStr = awString;
return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\mqtrig.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: MqTrig.cpp

Abstract:
	
	1.	Creates the key "TriggerTest" in registry in order to enable the Triggers service test hook.
	1.	Creates 3 triggers, one of each type
	2.	Attaches 2 rules to each 1 rule with COM action and one with EXE action
	3.	Sends two messages to each queue
	4.	Waits for the results

	The results are checked by using the Triggers service hook for testing.
	By defining the key "TriggerTest" in registry, the service sends messages with infomation about invoked action.

	Between initialization phase and functionality test phase, "net stop msmqtriggers" and "net start msmqtriggers"
	are required.
		
Author:
    
	Tal Kariv (t-talik) 1-1-2001
	
Revision History:

--*/
#include "msmqbvt.h"
#include <vector>
using namespace std;
using namespace MSMQ;
#import "mqtrig.tlb" no_namespace 

#define TRIGGER_SERIALIZED 1
#define TRIGGER_ENABLED 1

#define EXE_ACTION L"EXE\tnet.exe"
#define COM_ACTION L"COM\tMSMQ.MSMQManagement\tInit"


extern DWORD  g_dwRxTimeOut ;


void CMqTrig::Description()
{
	wMqLog(L"Thread %d : Trigger Thread\n", m_testid);
}

HRESULT 
TrigSetRegKeyParams()
/*++  
	Function Description:
		Set the key "TriggerTest" in registry (under the key Triggers as REG_SZ)	
	Arguments:
		none
	Return code:
		Success or failure
--*/
{
	HKEY hKey = NULL;
	HRESULT hr =  RegOpenKeyExW(
								HKEY_LOCAL_MACHINE,         
								L"SOFTWARE\\Microsoft\\MSMQ\\Triggers", 
								0,   
								KEY_WRITE,
								&hKey
							  );

	ErrHandle(hr,ERROR_SUCCESS,L"Triggers not installed");
	
	//
	//	set the key "TriggerTest" to NULL
	//
	hr = RegSetValueExW(
		  				hKey,
						L"TriggerTest" ,
						NULL ,
						REG_SZ ,
						(unsigned char*)"" ,
						2
					  );

	ErrHandle(hr,ERROR_SUCCESS,L"RegSetValueEx failed");
	RegCloseKey(hKey);
	return hr;

}

BOOL 
TrigCheckRegKeyParams()
/*++  
	Function Description:
		verifies that the key "TriggerTest" in registry (under the key Triggers as REG_SZ)	
	Arguments:
		none
	Return code:
		Success or failure
--*/
{
	HKEY hKey = NULL;
	LONG hr =  RegOpenKeyExW(
								HKEY_LOCAL_MACHINE,         
								L"SOFTWARE\\Microsoft\\MSMQ\\Triggers", 
								0,   
								KEY_QUERY_VALUE,
								&hKey
							  );

	if (hr != ERROR_SUCCESS)
	{
		MqLog("Triggers Reg key missing. Is Triggers installed????\n");
		return FALSE;
	}

	//
	// check if "TriggersTest" is registered in registry
	//
	hr = RegQueryValueExW(
		hKey ,				
		L"TriggerTest" ,	
		NULL ,			
		NULL ,
		NULL ,				
		NULL	
		);
	
	if (hr != ERROR_SUCCESS)
	{
		MqLog("Triggers test Reg key missing. Did you run mqtrig -i -trig????\n");
		return FALSE;
	}
	RegCloseKey(hKey);
	return TRUE;
}

VOID 
FillQueueArray(
		cBvtUtil & cTestParms, 
		std::vector<std::wstring>& vecQueuesFormatName
		)
/*++  
	Function Description:
		Fills a vestor with all triggers test queues.	
	Arguments:
		cBvtUtil & cTestParms							 - to return queue format names						  
		std::vector<std::wstring>& vecQueuesFormatName	 - vector to fill
	Return code:
		None.
--*/
{
	if (vecQueuesFormatName.size() == 0)
	{
		vecQueuesFormatName.push_back(cTestParms.ReturnQueueFormatName(L"PeekTrigger"));
		vecQueuesFormatName.push_back(cTestParms.ReturnQueueFormatName(L"RetrievalTrigger"));
		vecQueuesFormatName.push_back(cTestParms.ReturnQueueFormatName(L"TxRetrievalTrigger"));
	}
}

HRESULT 
TrigInit(
	cBvtUtil & cTestParms, 
	std::wstring wcsLocalComputerName
	)
/*++  
	Function Description:
		Creates the triggers and rules and attaches them.
		If a trigger or a rule already exists, it skips the creation.
	Arguments:
		cBvtUtil & cTestParms			  - to get queues format names
		std::wstring wcsLocalComputerName - needed to invoke the COM action
	Return code:
		Success or failure
--*/
{	
	std::vector<std::wstring> vecQueuesFormatName;
	FillQueueArray(cTestParms, vecQueuesFormatName);
	
	if( g_bDebug )
	{	
		MqLog ("Purge trigger queues\n");
	}
	for(unsigned int i=0;i<vecQueuesFormatName.size();i++)
	{
		HANDLE hQueue = NULL;
		if( g_bDebug )
		{
			wMqLog(L"TrigInit - Try to open trigger queue %s\n",vecQueuesFormatName[i].c_str());
		}
		HRESULT hr = MQOpenQueue(vecQueuesFormatName[i].c_str(),MQ_RECEIVE_ACCESS,MQ_DENY_NONE, &hQueue);
		if(FAILED(hr))
		{
			wMqLog(L"TrigInit - Failed to open queue %s error 0x%x \n",vecQueuesFormatName[i].c_str(),hr);
			throw INIT_Error("Failed to open queue");
		}
		hr = MQPurgeQueue(hQueue);
		MQCloseQueue(hQueue);
		if(FAILED(hr))
		{
			wMqLog(L"TrigInit - Failed to purge queue %s error 0x%x \n",vecQueuesFormatName[i].c_str(),hr);
			throw INIT_Error("Failed to purge queue");
		}
	}
	HANDLE hRecQueue = NULL;
	HRESULT hr = MQOpenQueue(cTestParms.ReturnQueueFormatName(L"TriggerTest").c_str(),MQ_RECEIVE_ACCESS,MQ_DENY_NONE, &hRecQueue);
	if(FAILED(hr))
	{
		wMqLog(L"TrigInit - Failed to open queue %s error 0x%x \n",cTestParms.ReturnQueueFormatName(L"TriggerTest").c_str(),hr);
		throw INIT_Error("Failed to open queue");
	}
	hr = MQPurgeQueue(hRecQueue);
	MQCloseQueue(hRecQueue);
	if(FAILED(hr))
	{
		wMqLog(L"TrigInit - Failed to purge queue %s error 0x%x \n",cTestParms.ReturnQueueFormatName(L"TriggerTest").c_str(),hr);
		throw INIT_Error("Failed to purge queue");
	}

	try
	{
		//
		//	add new triggers
		//
		IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet");
		

		HRESULT hr = TriggerSet->Init((LPWSTR)NULL);
		if( g_bDebug )
		{	
			MqLog ("Init trigger set\n");
		}
		ErrHandle(hr,MQ_OK,L"TriggerSet init trigger failed");
		
		//
		// Update data to registry
		// 
		if( g_bDebug )
		{	
			MqLog ("Refreshing trigger set\n");
		}
		hr = TriggerSet->Refresh();
		ErrHandle(hr,MQ_OK,L"TriggerSet refresh failed");

		
		bool bTriggerExistsFlag[3] = {0};
		BSTR bstrTriggerGUIDs[3] = {NULL};
		BSTR bstrTempTriggerGUID = NULL;
		DWORD dwNumOfTriggers = TriggerSet->GetCount();
		BSTR bstrTriggerName = NULL;
		if( g_bDebug )
		{	
			MqLog ("Checking if triggers exist\n");
		}
		for (DWORD i=0 ; i<dwNumOfTriggers ; i++)
		{
			
			TriggerSet->GetTriggerDetailsByIndex(i , &bstrTempTriggerGUID , &bstrTriggerName , NULL , NULL , NULL , NULL , NULL , NULL);
			if (!wcscmp(bstrTriggerName , L"bvt-PeekTrigger"))
			{
				bTriggerExistsFlag[0] = true;
				bstrTriggerGUIDs[0] = bstrTempTriggerGUID;
			}
			else if (!wcscmp(bstrTriggerName , L"bvt-RetrievalTrigger"))
			{
				bTriggerExistsFlag[1] = true;
				bstrTriggerGUIDs[1] = bstrTempTriggerGUID;

			}
			else if (!wcscmp(bstrTriggerName , L"bvt-TransactionalRetrievalTrigger"))
			{
				bTriggerExistsFlag[2] = true;
				bstrTriggerGUIDs[2] = bstrTempTriggerGUID;
			}
			else
			{
				SysFreeString(bstrTempTriggerGUID);
				SysFreeString(bstrTriggerName);
			}
			bstrTempTriggerGUID = NULL;
			bstrTriggerName = NULL;
		}

		
		//
		//	create the peek trigger
		//
		if( !bTriggerExistsFlag[0] )
		{
			if( g_bDebug )
			{	
				MqLog ("creating a new peek trigger\n");
			}
			hr = TriggerSet->AddTrigger(L"bvt-PeekTrigger" , cTestParms.ReturnQueuePathName(L"PeekTrigger").c_str() , SYSTEM_QUEUE_NONE,
				TRIGGER_ENABLED , TRIGGER_SERIALIZED , PEEK_MESSAGE , &bstrTriggerGUIDs[0]);
			ErrHandle(hr,MQ_OK,L"Add peek trigger failed");	
		}
		
		//
		//	create the retrieval trigger
		//
		if( !bTriggerExistsFlag[1] )
		{
			if( g_bDebug )
			{	
				MqLog ("creating a new retrieval trigger\n");
			}

			hr = TriggerSet->AddTrigger(L"bvt-RetrievalTrigger" , cTestParms.ReturnQueuePathName(L"RetrievalTrigger").c_str() , SYSTEM_QUEUE_NONE,
					TRIGGER_ENABLED , TRIGGER_SERIALIZED , RECEIVE_MESSAGE , &bstrTriggerGUIDs[1]);
			ErrHandle(hr,MQ_OK,L"Add retrieval trigger failed");
		}
		//
		//	create the retrieval transaction trigger
		//
		if( !bTriggerExistsFlag[2] )
		{
			if( g_bDebug )
			{	
				MqLog ("creating a new transactional retrieval trigger\n");
			}

			hr = TriggerSet->AddTrigger(L"bvt-TransactionalRetrievalTrigger" , cTestParms.ReturnQueuePathName(L"TxRetrievalTrigger").c_str() , SYSTEM_QUEUE_NONE,
					TRIGGER_ENABLED , TRIGGER_SERIALIZED , RECEIVE_MESSAGE_XACT , &bstrTriggerGUIDs[2]);
			ErrHandle(hr,MQ_OK,L"Add transactional retrieval trigger failed");
		}

		if( g_bDebug )
		{	
			MqLog ("Detaching all rules from all triggers\n");
		}
		TriggerSet->DetachAllRules(bstrTriggerGUIDs[0]);
		TriggerSet->DetachAllRules(bstrTriggerGUIDs[1]);
		TriggerSet->DetachAllRules(bstrTriggerGUIDs[2]);

		//
		//	add new rules
		//
		IMSMQRuleSetPtr RuleSet(L"MSMQTriggerObjects.MSMQRuleSet");
		if( g_bDebug )
		{	
			MqLog ("Init the rule set\n");
		}
		hr = RuleSet->Init((LPWSTR)NULL);
		ErrHandle(hr,MQ_OK,L"Init rule failed");
		
		if( g_bDebug )
		{	
			MqLog ("Refreshing the rule set\n");
		}
		hr = RuleSet->Refresh();
		ErrHandle(hr,MQ_OK,L"Rule refresh Failed");
		
		bool bRuleExistsFlag[2] = {false};
		BSTR bstrRuleGUIDs[2] = {NULL};
		DWORD dwNumOfRules = RuleSet->GetCount();
		BSTR bstrRuleName = NULL;
		BSTR bstrTempRuleGUID = NULL;
		if( g_bDebug )
		{	
			MqLog ("Checking if rules exist\n");
		}
		for (i=0; i < dwNumOfRules ; i++)
		{
			bstrTempRuleGUID = NULL;
			bstrRuleName = NULL;
			RuleSet->GetRuleDetailsByIndex(i , &bstrTempRuleGUID , &bstrRuleName , NULL , NULL , NULL , NULL , NULL);
			if (!wcscmp(bstrRuleName , L"bvt-EXERule"))
			{
				bRuleExistsFlag[0] = true;
				bstrRuleGUIDs[0] = bstrTempRuleGUID;
			}
			else if (!wcscmp(bstrRuleName , L"bvt-COMRule"))
			{
				bRuleExistsFlag[1] = true;
				bstrRuleGUIDs[1] = bstrTempRuleGUID;
			}
			else
			{
				SysFreeString(bstrTempRuleGUID);
				SysFreeString(bstrRuleName);
			}
			bstrTempRuleGUID = NULL;
			bstrRuleName = NULL;

		}
			
		//
		//	create EXE action rule
		//
		if( !bRuleExistsFlag[0] )
		{
			if( g_bDebug )
			{	
				MqLog ("Creating a new EXE action rule\n");
			}
			hr = RuleSet->Add(L"bvt-EXERule" , L"" , L"" , EXE_ACTION , L"" , FALSE , &bstrRuleGUIDs[0]);
			ErrHandle(hr,MQ_OK,L" AddRule Failed(for exe)");
		}
		
		//
		//	create COM action rule
		//
		if( !bRuleExistsFlag[1] )
		{
			if( g_bDebug )
			{	
				MqLog ("Creating a new COM action rule\n");
			}
			std::wstring ComAction = COM_ACTION;
			ComAction += L"\t";
			
			ComAction += L"\"";
			ComAction += wcsLocalComputerName;
			ComAction += L"\"";
			ComAction += L"\t";
			
			ComAction += L"\"";
			ComAction += cTestParms.ReturnQueuePathName(L"RetrievalTrigger").c_str();
			ComAction += L"\"";
			ComAction += L"\t";
			
			hr = RuleSet->Add(L"bvt-COMRule" , L"" , L"" , ComAction.c_str() , L"" , FALSE , &bstrRuleGUIDs[1]);
			ErrHandle(hr,MQ_OK,L" AddRule Failed(for com)");
		}

		//
		//	 now , attach the rules to the triggers
		//
		if( g_bDebug )
		{	
			MqLog ("Attaching the two rules to each \n");
		}
		hr = TriggerSet->AttachRule(bstrTriggerGUIDs[0] , bstrRuleGUIDs[0] , 0);
		ErrHandle(hr,MQ_OK,L"Attach Failed for EXE rule and peek Trigger");
		
		hr = TriggerSet->AttachRule(bstrTriggerGUIDs[1] , bstrRuleGUIDs[0] , 0);
		ErrHandle(hr,MQ_OK,L"Attach Failed for EXE rule and retrieval Trigger");
		
		hr = TriggerSet->AttachRule(bstrTriggerGUIDs[2] , bstrRuleGUIDs[0] , 0);
		ErrHandle(hr,MQ_OK,L"Attach Failed for EXE rule and transactional retrieval Trigger");

		hr = TriggerSet->AttachRule(bstrTriggerGUIDs[0] , bstrRuleGUIDs[1] , 0);
		ErrHandle(hr,MQ_OK,L"Attach Failed for COM rule and peek Trigger");
		
		hr = TriggerSet->AttachRule(bstrTriggerGUIDs[1] , bstrRuleGUIDs[1] , 0);
		ErrHandle(hr,MQ_OK,L"Attach Failed for COM rule and retrieval Trigger");
		
		hr = TriggerSet->AttachRule(bstrTriggerGUIDs[2] , bstrRuleGUIDs[1] , 0);
		ErrHandle(hr,MQ_OK,L"Attach Failed for COM rule and transactional retrieval Trigger");
		
		
		SysFreeString(bstrTriggerGUIDs[0]);
		SysFreeString(bstrTriggerGUIDs[1]);
		SysFreeString(bstrTriggerGUIDs[2]);
		SysFreeString(bstrRuleGUIDs[0]);
		SysFreeString(bstrRuleGUIDs[1]);

	}
	catch (_com_error & comerr) 
	{
		if (comerr.Error() == REGDB_E_CLASSNOTREG)
		{
			MqLog ("CMqTrig - Trigger DLL - MqTrig.dll not registered. This is OK only if you're running 32bit BVT on IA64 machine\n");
		}
		else
		{
			MqLog ("CMqTrig - Got Error: 0x%x\n" , comerr.Error());	
		}
		return MSMQ_BVT_FAILED;
		
	}
	return MSMQ_BVT_SUCC;
}


CMqTrig::CMqTrig(
	const INT iIndex, 
	cBvtUtil & cTestParms
	) :
	iNumberOfTestMesssges(2),
	cTest(iIndex),
	m_wcsResultQueueFormatName(cTestParms.ReturnQueueFormatName(L"TriggerTest").c_str())
{
	FillQueueArray(cTestParms, m_vecQueuesFormatName);
}


CMqTrig::Start_test()
/*++  
	Function Description:
		sends two messages, one for each queue
	Arguments:
		none
	Return code:
		none
--*/
{
	try
	{
		if (!TrigCheckRegKeyParams())
		{
			return MSMQ_BVT_FAILED;
		}
		//
		//	open the queue to which the messages will be sent to
		//
		IMSMQQueueInfo3Ptr qinfo("MSMQ.MSMQQueueInfo");
		IMSMQQueue3Ptr qSend;
		IMSMQMessage3Ptr m("MSMQ.MSMQMessage");
		_variant_t bTransaction((LONG_PTR)MQ_SINGLE_MESSAGE);     
		
		//
		//	send 2 messages to each queue
		//
		if( g_bDebug )
		{	
			MqLog ("Sending two messages to each queue\n");
		}
		for( unsigned int i=0; i < m_vecQueuesFormatName.size(); i++)
		{
			qinfo->FormatName = m_vecQueuesFormatName[i].c_str();
			qSend = qinfo->Open(MQ_SEND_ACCESS,MQ_DENY_NONE);
			for(int j=0; j <iNumberOfTestMesssges; j++) 
			{
				m->Label = m_vecQueuesFormatName[i].c_str();
				_variant_t vID;
				if( i == 2 )
				{
					m->Send(qSend , &bTransaction);
					vID = m->Id;
				}
				else
				{
					m->Send(qSend);
					vID = m->Id;
				}

				_variant_t vConvertedArg;
				HRESULT hr = VariantChangeType(&vConvertedArg, &vID, NULL, VT_BSTR);
				if (FAILED(hr))
				{
					MqLog("VariantChangeType failed. Error: 0x%x\n", hr);
					return MSMQ_BVT_FAILED;
				}

				OBJECTID* pObj = (OBJECTID*)(vConvertedArg.pbVal);
				WCHAR strId[256];
				StringFromGUID2(pObj->Lineage, strId, 256);

				WCHAR szI4[12];
				
				_ltow(pObj->Uniquifier, szI4, 10);
				wcscat(strId, L"\\") ;
				wcscat(strId, szI4) ;

				if (g_bDebug)
				{
					MqLog("Adding GUID %S to set\n", strId);
				}

				m_MessagesGUIDS.insert(strId);
			}
		}
			qSend->Close();
	}
	catch( _com_error & cErr )
	{
		MqLog("CMqTrig::Start_test failed with error 0x%x",cErr.Error());
		return MSMQ_BVT_FAILED;
	}
	return MSMQ_BVT_SUCC;
}

LPWSTR 
GetNextBodySection(
			LPWSTR Body
			)
/*++  
	Function Description:
		Returns a pointer to the message GUID.
	Arguments:
		Body
	Return code:
		pointer to the GUID
--*/
{
	LPWSTR Place = wcschr(Body, '\'');
	if (Place == NULL)
	{
		MqLog("Got an invalid message body. This should not happen!\n");
		return NULL;
	}
	//
	// Return the next section.
	//
	return (Place+1);
}

LPWSTR 
GetMessageGUID(LPWSTR Body)
/*++  
	Function Description:
		Returns a pointer to the message GUID. The message fomat is:
		'trigger GUID' 'rule GUID' 'message GIUD'...
	Arguments:
		Body
	Return code:
		pointer to the GUID
--*/
{
	LPWSTR Place = Body;
	for (DWORD i=0; i<5; i++)
	{
		Place = GetNextBodySection(Place);
		if (Place == NULL)
		{
			return NULL;
		}
	}
	return Place;
}


CMqTrig::CheckResult()
/*++  
	Function Description:
		trying to receive 13 messages - 6 that were send as a result of an EXE invocation.
		6 that were sent as a result of a COM invocation. and the retrieval of the last message
		should fail. The message retrieval from the queue is based on the message GIUD. Only message that
		belongs to this this will be retrieved.
	Arguments:
		none
	Return code:
		none
--*/
{
	try
	{
		if( g_bDebug )
		{	
			MqLog ("checking the results\n");
		}
		IMSMQQueueInfo3Ptr qRinfo("MSMQ.MSMQQueueInfo");
		IMSMQQueue3Ptr qRSend;
		IMSMQMessage3Ptr mR("MSMQ.MSMQMessage");
		_variant_t bReceiveTimeout((long)g_dwRxTimeOut);
		_variant_t bWantBody((bool)true);   
		DWORD dwArrOfInvocations[2] = {0,0};
		qRinfo->FormatName = m_wcsResultQueueFormatName.c_str();
		qRSend = qRinfo->Open( MQ_RECEIVE_ACCESS , MQ_DENY_NONE);

		DWORD NumOfInvocationExpetcted = (static_cast<DWORD>(m_vecQueuesFormatName.size()) * iNumberOfTestMesssges*2);
		DWORD NumOfInvocations = 0;

		mR = qRSend->PeekCurrent(&vtMissing, &bWantBody, &bReceiveTimeout);		
		for(;;)
		{
			if ((mR == NULL) && (NumOfInvocations < NumOfInvocationExpetcted))
			{
				MqLog("MqTrig - %d actions did not invoke\n" , NumOfInvocationExpetcted- NumOfInvocations);
				MqLog("MqTrig - %d actions with COM action invoked\n" , dwArrOfInvocations[0]);
				MqLog("MqTrig - %d actions with EXE action invoked\n" , dwArrOfInvocations[1]);
				qRSend->Close();
				return MSMQ_BVT_FAILED;
			}
			
			if (mR == NULL)
			{
				ASSERT(NumOfInvocations == NumOfInvocationExpetcted);
				qRSend->Close();
				return MSMQ_BVT_SUCC;
			}
			
			if ((mR != NULL))
			{
				//
				// Get the messages GUID, it is the third argument in the messages body, seperated by ''.
				//

				_bstr_t bstrMessageBody = mR->Body;
				LPWSTR Place = GetMessageGUID((LPWSTR)bstrMessageBody);
				if (Place == NULL)
				{
					// 
					// Got an invalid message body. i.e. message is not in test format.
					//
					mR = qRSend->PeekNext(&vtMissing, &bWantBody, &bReceiveTimeout);
					continue;
				}
				
				size_t MessageGUIDLength = wcscspn(Place, L"'");
				ASSERT(MessageGUIDLength != 0)
				
				LPWSTR MessageGUID = new WCHAR[static_cast<DWORD>(MessageGUIDLength+1)];
				wcsncpy(MessageGUID, Place, MessageGUIDLength);
				MessageGUID[MessageGUIDLength] = L'\0';
				_wcsupr(MessageGUID);
				if( g_bDebug )
				{	
					MqLog("Got messages GUID: %S\n", MessageGUID);
				}
				
				std::set < std::wstring >::const_iterator  Found = m_MessagesGUIDS.find(MessageGUID);
				if (Found == m_MessagesGUIDS.end())
				{
					//
					// This is a valid test message but from another instance of mqbvt.
					//
					if( g_bDebug )
					{	
						MqLog("Skipping message with GUID - %S\n", MessageGUID);
					}
					mR = qRSend->PeekNext(&vtMissing, &bWantBody, &bReceiveTimeout);
					continue;
				}

				//
				// The message belongs to this test - continue
				//
				NumOfInvocations++;
				
				if (NumOfInvocations <= NumOfInvocationExpetcted)
				{
					_bstr_t bstrMessageLabel = mR->Label;
					
					if (wcsstr((LPWSTR)bstrMessageBody , L"COM") != NULL)
					{
						if( g_bDebug )
						{	
							MqLog ("COM action number %d has invoked\n" , dwArrOfInvocations[0]+1);
						}
						dwArrOfInvocations[0]++;
					}
					if (wcsstr((LPWSTR)bstrMessageBody , L"EXE") != NULL)
					{
						if( g_bDebug )
						{	
							MqLog ("EXE action number %d has invoked\n" , dwArrOfInvocations[1]+1);
						}
						dwArrOfInvocations[1]++;
					}
				}
				else
				{
					MqLog("too many actions invoked\n");
					qRSend->Close();
					return MSMQ_BVT_FAILED;
				}

				mR = qRSend->ReceiveCurrent();
				mR = qRSend->PeekCurrent(&vtMissing, &bWantBody, &bReceiveTimeout);
			}	
		}
		
	}
	catch( _com_error & cErr )
	{
		MqLog("CMqTrig::CheckResult failed with error 0x%x",cErr.Error());		
		return MSMQ_BVT_FAILED;
	}
}

HRESULT 
DeleteAllTriggersAndRules()
/*++  
	Function Description:
		Deletes all triggers and rules
	Arguments:
		none
	Return code:
		none
--*/
{
	//
	//	initialize TriggerSet
	//
	IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet");
	HRESULT hr = TriggerSet->Init((LPWSTR)NULL);
	ErrHandle(hr,MQ_OK,L"TriggerSet init failed");
	
	hr = TriggerSet->Refresh();
	ErrHandle(hr,MQ_OK,L"TriggerSet refresh failed");

	if( g_bDebug )
	{	
		MqLog ("deleting all triggers\n");
	}

	DWORD dwNumOfExistingTriggers = TriggerSet->Count;
	DWORD nLoopIndex = 0;
	BSTR bstrTempTriggerGUID = NULL;
	BSTR bstrTriggerName = NULL;
	DWORD dwNumOfDeletedTriggers = 0;
	for (nLoopIndex = 0 ; nLoopIndex < dwNumOfExistingTriggers ; nLoopIndex++)
	{
		bstrTempTriggerGUID = NULL;
		bstrTriggerName = NULL;
		TriggerSet->GetTriggerDetailsByIndex(nLoopIndex-dwNumOfDeletedTriggers , &bstrTempTriggerGUID , &bstrTriggerName,NULL,NULL,NULL,NULL,NULL,NULL); 
		if (wcscmp(bstrTriggerName , L"bvt-PeekTrigger") || 
			wcscmp(bstrTriggerName , L"bvt-RetrievalTrigger") ||
			wcscmp(bstrTriggerName , L"bvt-TransactionalRetrievalTrigger"))
		{
			hr = TriggerSet->DeleteTrigger(bstrTempTriggerGUID);
			ErrHandle(hr,MQ_OK,L"DeleteTrigger failed");
			dwNumOfDeletedTriggers++;

		}
		SysFreeString(bstrTempTriggerGUID);
		SysFreeString(bstrTriggerName);
		bstrTempTriggerGUID = NULL;
		bstrTriggerName = NULL;
	}

	if( g_bDebug )
	{	
		MqLog ("Successfully deleted all triggers\n");
	}

	//
	//	initialize RuleSet
	//

	IMSMQRuleSetPtr RuleSet(L"MSMQTriggerObjects.MSMQRuleSet");
	hr = RuleSet->Init((LPWSTR)NULL);
	ErrHandle(hr,MQ_OK,L"RuleSet init failed");
	hr = RuleSet->Refresh();
	ErrHandle(hr,MQ_OK,L"RuleSet refresh failed");

	if( g_bDebug )
	{	
		MqLog ("deleting all Rules\n");
	}

	DWORD dwNumOfExistingRules = RuleSet->Count;
	BSTR bstrTempRuleGUID = NULL;
	BSTR bstrRuleName = NULL;
	DWORD dwNumOfDeletedRules = 0;
	for (nLoopIndex = 0 ; nLoopIndex < dwNumOfExistingRules ; nLoopIndex++)
	{
		RuleSet->GetRuleDetailsByIndex(nLoopIndex-dwNumOfDeletedRules , &bstrTempRuleGUID , &bstrRuleName,NULL,NULL,NULL,NULL,NULL); 
		if (wcscmp(bstrRuleName , L"bvt-EXERule") || wcscmp(bstrRuleName , L"bvt-COMRule"))
		{
			hr = RuleSet->Delete(bstrTempRuleGUID);
			ErrHandle(hr,MQ_OK,L"Delete (Rule) failed");
			dwNumOfDeletedRules++;
		}
		SysFreeString(bstrTempRuleGUID);
		SysFreeString(bstrRuleName);
		bstrTempRuleGUID = NULL;
		bstrRuleName = NULL;
	}

	if( g_bDebug )
	{	
		MqLog ("Successfully deleted all rules\n");
	}

	return MSMQ_BVT_SUCC;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\qsetget.cpp ===
#include "msmqbvt.h"
#include "randstr.h"


//+---------------------------
//
//  BOOL  ShowOGandSID()
//
//+---------------------------

#define NUMBEROFPROPERTIES 3

BOOL cSetQueueProp::GetOnerID( PSID pSid)
{
    if (!pSid)
    {
        MqLog("pSid is not available\n");
		return FALSE;
    }
	const int NameBufferSize = 500;
	CHAR NameBuffer[ NameBufferSize ];
    CHAR DomainBuffer[ NameBufferSize ];
    ULONG NameLength = NameBufferSize;
    ULONG DomainLength = NameBufferSize;
    SID_NAME_USE SidUse;
    DWORD dwErrorValue;
    DWORD dwSize = GetLengthSid(pSid) ;

    if (!LookupAccountSid( NULL,
                           pSid,
                           NameBuffer,
                           &NameLength,
                           DomainBuffer,
                           &DomainLength,
                           &SidUse))
    {
        dwErrorValue = GetLastError();
        MqLog ("LookupAccountSid() failed, LastErr- %lut\n",dwErrorValue) ;
		return FALSE;
    }
    else
    {
		if(g_bDebug)
		{
			MqLog (TEXT("QSetGet.cpp - LookupAccountSid succeded to Get queue owner size- %lut, %lxh, %s\\%s\n"),
                        dwSize, dwSize, DomainBuffer, NameBuffer);
		}
    }

    return TRUE ;
}

//+-----------------------------------------------------------
//
//   HRESULT  ShowNT5SecurityDescriptor()
//
//+-----------------------------------------------------------

BOOL cSetQueueProp::VerifyQueueHasOwner (SECURITY_DESCRIPTOR *pSD)
{
	PSID pSid = NULL;
	BOOL bDefualt;
    if (!GetSecurityDescriptorOwner(pSD, &pSid, &bDefualt))
    {
        MqLog("ERROR - couldn't get Security Descriptor Owner\n");
        return FALSE;
    }
    return GetOnerID( pSid );
}



cSetQueueProp::~cSetQueueProp()
{

}

cSetQueueProp::cSetQueueProp (int iTestIndex,std::map < std :: wstring , std:: wstring > Tparms )
:cTest(iTestIndex),m_destQueueFormatName(L""),m_QueuePathName(L""),m_RandQueueLabel(L""),m_publicQueueFormatName(L"")
{
	DWORD lcid = LocalSystemID ();
	WCHAR wcsTemp[60];
	int iBuffer = 60 ;
	if (GetRandomStringUsingSystemLocale(lcid,wcsTemp,iBuffer))
	{
		m_RandQueueLabel = wcsTemp;
	}
	else
	{
		m_RandQueueLabel = L"Label Test";
	}
	ReturnGuidFormatName(m_QueuePathName,1);
	if ( Tparms[L"Wkg"] != L"Wkg")
	{
		m_publicQueueFormatName =Tparms[L"FormatName"];
	}
}

void cSetQueueProp::Description()
{
	wMqLog(L"Thread %d : cSetQueueProp Set and Get Queue props\n", m_testid);
}

int cSetQueueProp::Start_test()
/*++
  
	Function Description:

		Start_test -
		This function create an new private queue on the local computer and call to MQSetQueueProperties
		to update information about the queue.

	Arguments:
		None
	Return code:
		
		MSMQ_BVT_SUCC
		MSMQ_BVT_FAILED

	
--*/

{
	//
	// Need to Create a temp queue
	//
	
	
	cPropVar QueueProps(1);
	WCHAR wcsFormatName[BVT_MAX_FORMATNAME_LENGTH+1]={0};
	ULONG ulFormatNameLength = BVT_MAX_FORMATNAME_LENGTH ;
	QueueProps.AddProp (PROPID_Q_PATHNAME,VT_LPWSTR,m_QueuePathName.c_str());
	HRESULT rc = MQCreateQueue(NULL,QueueProps.GetMQPROPVARIANT() , wcsFormatName , &ulFormatNameLength );
	ErrHandle(rc,MQ_OK,L"MQCreateQueue failed to create private queue ");
	m_destQueueFormatName = wcsFormatName;

	//
	// Set Queue 
	//
	 
	cPropVar SetQueueProp(NUMBEROFPROPERTIES);
	SetQueueProp.AddProp(PROPID_Q_LABEL,VT_LPWSTR,m_RandQueueLabel.c_str());
	DWORD dwTemp = MQ_PRIV_LEVEL_BODY;
	SetQueueProp.AddProp(PROPID_Q_PRIV_LEVEL,VT_UI4,&dwTemp);
	bool bTemp = MQ_JOURNAL;
	SetQueueProp.AddProp(PROPID_Q_JOURNAL,VT_UI1,&bTemp);
	if( g_bDebug )
	{
		wMqLog(L"QSetGet.cpp - modify default values of PROPID_Q_LABEL,PROPID_Q_PRIV_LEVEL, PROPID_Q_JOURNAL \n for queue %s\n",m_QueuePathName.c_str());
	}
	rc = MQSetQueueProperties(m_destQueueFormatName.c_str(),SetQueueProp.GetMQPROPVARIANT());
	ErrHandle(rc,MQ_OK,L"MQSetQueueProperties failed");
	return MSMQ_BVT_SUCC;
}

int cSetQueueProp::CheckResult()
/*++
  
	Function Description:

		CheckResult -
		Call to MQGetQueueProperties and verify that MQSetQueueProperties succeded to set queue props

	Arguments:
		None
	Return code:
		MSMQ_BVT_SUCC
		MSMQ_BVT_FAILED

	
--*/
{
	
	DWORD cPropId = 0;
	MQQUEUEPROPS qprops;
	PROPVARIANT aQueuePropVar[NUMBEROFPROPERTIES];
	QUEUEPROPID aQueuePropId[NUMBEROFPROPERTIES];
	HRESULT aQueueStatus[NUMBEROFPROPERTIES];
  
	aQueuePropId[cPropId] = PROPID_Q_LABEL;
	aQueuePropVar[cPropId].vt=VT_NULL;
	cPropId++;
	
	aQueuePropId[cPropId] = PROPID_Q_PRIV_LEVEL;
	aQueuePropVar[cPropId].vt=VT_UI4;
	cPropId++;
	
	aQueuePropId[cPropId] = PROPID_Q_JOURNAL;
	aQueuePropVar[cPropId].vt=VT_UI1;
	cPropId++;

	
	qprops.cProp = cPropId;           // Number of properties
	qprops.aPropID = aQueuePropId;        // Ids of properties
	qprops.aPropVar = aQueuePropVar;      // Values of properties
	qprops.aStatus = aQueueStatus;        // Error reports
  
	
	HRESULT rc = MQGetQueueProperties(m_destQueueFormatName.c_str(),&qprops);
	ErrHandle(rc,MQ_OK,L"MQGetQueueProperties failed");

	
	//
	//  Compare the results
	// 
	if(aQueuePropVar[1].ulVal != MQ_PRIV_LEVEL_BODY )
	{
		wMqLog(L"QSetGet.cpp - Expected PROPID_Q_PRIV_LEVEL found %d\n",aQueuePropVar[1].ulVal);
		MQFreeMemory(aQueuePropVar[0].pwszVal);
		return MSMQ_BVT_FAILED;
	}
	if( g_bDebug )
	{
		MqLog("QSetGet.cpp - Succeeded to verify priv_level \n"); 
	}
	if(aQueuePropVar[2].bVal != MQ_JOURNAL )
	{
		wMqLog(L"QSetGet.cpp - Expected MQ_JOURNAL found %d\n",aQueuePropVar[2].iVal);
		MQFreeMemory(aQueuePropVar[0].pwszVal);
		return MSMQ_BVT_FAILED;
	}
	if( g_bDebug )
	{
		MqLog("QSetGet.cpp - Succeeded to verify journal \n"); 
	}
	if(wcscmp(m_RandQueueLabel.c_str(),aQueuePropVar[0].pwszVal) )
	{
		__debugbreak();
		wMqLog(L"QSetGet.cpp failed to compare queue label\nFound:%s\n Expected:%s\n",aQueuePropVar[0].pwszVal,m_RandQueueLabel.c_str());
		MQFreeMemory(aQueuePropVar[0].pwszVal);
		return MSMQ_BVT_FAILED;
	}
	if( g_bDebug )
	{
		MqLog("QSetGet.cpp - Succeeded to verify queue label \n"); 
	}


	MQFreeMemory(aQueuePropVar[0].pwszVal);

	DWORD dwSize = 1;
	DWORD dwReqLen = 0;
	SECURITY_DESCRIPTOR * pSd = (SECURITY_DESCRIPTOR *) malloc (dwSize *sizeof(BYTE));
	rc = MQGetQueueSecurity(m_destQueueFormatName.c_str(),OWNER_SECURITY_INFORMATION,pSd,dwSize,&dwReqLen);
	if( rc == MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL )
	{
		free(pSd);
		pSd = (SECURITY_DESCRIPTOR *) malloc (dwReqLen *sizeof(BYTE));
		dwSize = dwReqLen ;
		rc = MQGetQueueSecurity(m_destQueueFormatName.c_str(),OWNER_SECURITY_INFORMATION,pSd,dwSize,&dwReqLen);
		ErrHandle(rc,MQ_OK,L"MQGetQueueSecurity failed");		
		if (!VerifyQueueHasOwner(pSd))
		{
			MqLog("cSetQueueProp:failed to verify queue owner\n");
			return MSMQ_BVT_FAILED;
		}
		free(pSd);
	}
	else
	{
		wMqLog(L"Failed to call MQGetQueueSecurity expected:%d found %d\n",MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL,rc);
		return MSMQ_BVT_FAILED;
	}
	rc = MQDeleteQueue(m_destQueueFormatName.c_str());
	ErrHandle(rc,MQ_OK,L"MQDeleteQueue failed");

	if(m_publicQueueFormatName != L"")
	{
		dwSize = 1;
		dwReqLen = 0;
		pSd = (SECURITY_DESCRIPTOR *) malloc (dwSize *sizeof(BYTE));
		rc = MQGetQueueSecurity(m_publicQueueFormatName.c_str(),OWNER_SECURITY_INFORMATION,pSd,dwSize,&dwReqLen);
		if( rc == MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL )
		{
			delete pSd;
			pSd = (SECURITY_DESCRIPTOR *) new BYTE[ dwReqLen ] ;
			dwSize = dwReqLen ;
			rc = MQGetQueueSecurity(m_publicQueueFormatName.c_str(),OWNER_SECURITY_INFORMATION,pSd,dwSize,&dwReqLen);
			ErrHandle(rc,MQ_OK,L"MQGetQueueSecurity failed");		
			if (!VerifyQueueHasOwner(pSd))
			{
				MqLog("cSetQueueProp:failed to verify public queue owner\n");
				return MSMQ_BVT_FAILED;
			}
			delete pSd;
		}
		else
		{
			wMqLog(L"Failed to call MQGetQueueSecurity expected:%d found %d\n",MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL,rc);
			return MSMQ_BVT_FAILED;
		}
	}
	return MSMQ_BVT_SUCC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\ptrs.h ===
// -*-Mode:c++;-*-
#ifndef __PTRS_H
#define __PTRS_H

#include <windows.h>

#pragma warning( disable: 4284)

/*
 * Pointers classes
 *
 * Counter - A thread safe counter class
 * SPTR - Smart pointer with, a pointer class with reference count
 * aptr - Auto pointer
 * aaptr - Array Auto pointer
 */

/*
 * A thread safe counter class
 */
class Counter
{
public:
  typedef LONG value_type;
  
  Counter(value_type v = 0) : value(v) {};
  
  operator value_type() const {return value;}

  value_type operator++() { return InterlockedIncrement(&value); }
  value_type operator++(int) { return InterlockedIncrement(&value)-1;}
  value_type operator--() { return InterlockedDecrement(&value);}
  value_type operator--(int)  { return InterlockedDecrement(&value)+1;} 
  value_type operator=(value_type v) {return InterlockedExchange(&value, v);}

private:
  value_type value;
};

/*
 * Smart pointer - pointer with reference count.
 *                 When the reference count reaches 0, the pointer is deleted.
 *
 * Usage directions:
 * SPTR<C> pi(new int);
 * SPTR<C> p2 = pi;
...
 * NOTES:
 *   - operator=(T*) is not supported on purpose.
 */

class SPTR_ANY;

/*
 * Base class for Smart Pointer, so I can implement SPTR_ANY.
 */
class SPTR_base
{
public:
  virtual ~SPTR_base() {}
  bool operator==(const SPTR_base& ptr) { return eq(ptr); }
  bool operator< (const SPTR_base& ptr) { return lt(ptr); }

protected:
  virtual bool eq(const SPTR_base& ptr) const = 0;
   virtual bool lt(const SPTR_base& ptr) const = 0;
  virtual SPTR_base* clone() const = 0;

  friend class SPTR_ANY;
};

template<class T>
class SPTR : public SPTR_base
{
public:
  explicit SPTR(T* ptr = NULL) : p(ptr) { new_counter(); }

  template<class T2> SPTR(const SPTR<T2>& ptr) :
    counter(ptr.get_counter()),
    /*
     * If you want to be able to copy a base class to a
     * derived class, you should change the following line
     * to something line:
     *    p(dynamic_cast<T*>(ptr.get()))
     * NOTES: dynamic_cast returns 0 if the cast had failed.
     */
    p(ptr.get())
  {
    ++*counter;
  }

  SPTR(const SPTR& ptr) : 
    counter(ptr.counter),
    p(ptr.p)
  {
    ++*counter;
  }

  ~SPTR() { unlink(); }

  bool operator==(const SPTR& ptr) const { return p == ptr.p; }
  bool operator< (const SPTR& ptr) const { return p < ptr.p; }

  template <class T2> SPTR& operator=(const SPTR<T2>& ptr)
  {
    if (static_cast<const SPTR_base*>(this) != static_cast<const SPTR_base*>(&ptr))
    {
      unlink();
    /*
     * If you want to be able to copy a base class to a
     * derived class, you should change the following line
     * to something line:
     *    p = dynamic_cast<T*>(ptr.get());
     * NOTE: dynamic_cast returns 0 if the cast had failed.
     */
      p = ptr.get();
      counter = ptr.get_counter();
      ++*counter;
    }
    return *this;
  }

  SPTR& operator=(const SPTR& ptr)
  {
    if (this != &ptr)
    {
      unlink();
      p = ptr.p;
      counter = ptr.counter;
      ++*counter;
    }
    return *this;
  }

  T* get() const  {return p;}
  T* release()
  {
    if (!--(*counter)) {
      delete counter;
    }
    T* retval = p;
    p = NULL;
    return retval;
  }
    
  T* operator-> () {return get();}
  T& operator*() { return *get(); }
//  T** operator&(); // Don't remember why I don't like this operator.
  operator T*() { return get(); }

  Counter* get_counter() const {return counter;}

protected:

  void unlink()
  {
    if (!--(*counter)) {
      delete p;
      delete counter;
    }
  }

  bool eq(const SPTR_base& ptr) const
  {
    const SPTR& sptr_ptr = static_cast<const SPTR&>(ptr);
    return *this == sptr_ptr;
  }

  bool lt(const SPTR_base& ptr) const
  {
    const SPTR& sptr_ptr = static_cast<const SPTR&>(ptr);
    return *this < sptr_ptr;
  }

  SPTR_base* clone() const { return new SPTR(*this); }

  void new_counter() { counter = new Counter(1); }

  T* p;
  Counter *counter;
};

/*
 * SPTR_ANY: A class that can hold any type of smart pointer.
 */
class SPTR_ANY
{
public:
  SPTR_ANY(const SPTR_base& ptr) { p = ptr.clone(); }
  SPTR_ANY(const SPTR_ANY& ptr) { p = ptr.p->clone(); }
  ~SPTR_ANY() { delete p; }
  SPTR_ANY& operator=(const SPTR_ANY& ptr) {delete p; p = ptr.p->clone(); return *this;}
  bool operator==(const SPTR_ANY& ptr) { return *p == *ptr.p; }
  bool operator< (const SPTR_ANY& ptr) { return *p < *ptr.p; }

protected:
  SPTR_base* p;
};

/*
 * Smart pointer for storage of data in STL sets, etc
 * The difference is in the < and == operators, so that find will work
 * on the value and no on the pointers.
 *
 * Never tested, probably does not work....
 */
template<class T>
class SPSTL : public SPTR<T>
{
  SPSTL(T* ptr = NULL) : SPTR<T>(ptr) {}
  SPSTL(const SPSTL& ptr) : SPTR<T>(ptr) {}
  bool operator==(const SPSTL& a2) {return *this == *a2;}
  bool operator<(const SPSTL& a2) {return *this < *a2;}
};

/*------------------------- Auto pointer class -------------------------*/

template<class T>
class aptr
{
protected:
  T* p;
  void cleanup() { delete p; }
public:
  aptr(T* value = NULL) : p(value) {}
  ~aptr() { cleanup(); }
  T* operator=(T* value) { cleanup(); p = value; return p; }
  T* operator->() { return p; }
  T& operator*() { return *p; }
  T** operator&() { return &p; }
  operator T*() { return p;}
  T* get() {return p;}
  T* release() { T* t = p; p = NULL; return t; }
};

/*----------------------- Array Auto pointer class ---------------------*/

template<class T>
class aaptr
{
protected:
  T* p;
  void cleanup() { delete[] p; }
public:
  aaptr(T* value = NULL) : p(value) {}
  ~aaptr() { cleanup(); }
  T* operator=(T* value) { cleanup(); p = value; return p; }
  T* operator->() { return p; }
  T& operator*() { return *p; }
  T** operator&() { return &p; }
  operator T*() { return p;}
  T* get() {return p;}
  T* release() { T* t = p; p = NULL; return t; }
};
#endif // __PTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\service.cpp ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1997  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   service.cpp
//
//  PURPOSE:  Implements functions required by all services
//            windows.
//
//  FUNCTIONS:
//    service_ctrl(DWORD dwCtrlCode);
//    service_main(DWORD dwArgc, LPTSTR *lpszArgv);
//    CmdInstallService();
//    CmdRemoveService();
//    CmdDebugService(int argc, char **argv);
//    ControlHandler ( DWORD dwCtrlType );
//    GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );
//
//  COMMENTS:
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//  Changed by:Eitank for Mqbvt
//

#include "msmqbvt.h"
#include "service.h"



// internal variables
SERVICE_STATUS          ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   sshStatusHandle;
DWORD                   dwErr = 0;
BOOL                    bDebug = FALSE;
TCHAR                   szErr[256];

// internal function prototypes
VOID WINAPI service_ctrl(DWORD dwCtrlCode);
VOID WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv);
VOID CmdInstallService();
VOID CmdRemoveService();
VOID CmdDebugService(int argc, char **argv);
BOOL WINAPI ControlHandler ( DWORD dwCtrlType );
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );


//
//  FUNCTION: service_main
//
//  PURPOSE: To perform actual initialization of the service
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This routine performs the service initialization and then calls
//    the user defined ServiceStart() routine to perform majority
//    of the work.
//
void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv)
{

    // register our service control handler:
    //
    sshStatusHandle = RegisterServiceCtrlHandler( TEXT(SZSERVICENAME), service_ctrl);

    if (!sshStatusHandle)
        goto cleanup;

    // SERVICE_STATUS members that don't change in example
    //
    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;


    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        goto cleanup;


    ServiceStart( dwArgc, lpszArgv );

cleanup:

    // try to report the stopped status to the service control manager.
    //
    if (sshStatusHandle)
        (VOID)ReportStatusToSCMgr(
                            SERVICE_STOPPED,
                            dwErr,
                            0);

    return;
}



//
//  FUNCTION: service_ctrl
//
//  PURPOSE: This function is called by the SCM whenever
//           ControlService() is called on this service.
//
//  PARAMETERS:
//    dwCtrlCode - type of control requested
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID WINAPI service_ctrl(DWORD dwCtrlCode)
{
    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {
        // Stop the service.
        //
        // SERVICE_STOP_PENDING should be reported before
        // setting the Stop Event - hServerStopEvent - in
        // ServiceStop().  This avoids a race condition
        // which may result in a 1053 - The Service did not respond...
        // error.
        case SERVICE_CONTROL_STOP:
            ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 0);
            ServiceStop();
            return;

        // Update the service status.
        //
        case SERVICE_CONTROL_INTERROGATE:
            break;

        // invalid control code
        //
        default:
            break;

    }

    ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);
}



//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
//  COMMENTS:
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                         DWORD dwWin32ExitCode,
                         DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;


    if ( !bDebug ) // when debugging we don't report to the SCM
    {
        if (dwCurrentState == SERVICE_START_PENDING)
            ssStatus.dwControlsAccepted = 0;
        else
            ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

        ssStatus.dwCurrentState = dwCurrentState;
        ssStatus.dwWin32ExitCode = dwWin32ExitCode;
        ssStatus.dwWaitHint = dwWaitHint;

        if ( ( dwCurrentState == SERVICE_RUNNING ) ||
             ( dwCurrentState == SERVICE_STOPPED ) )
            ssStatus.dwCheckPoint = 0;
        else
            ssStatus.dwCheckPoint = dwCheckPoint++;


        // Report the status of the service to the service control manager.
        //
        fResult = SetServiceStatus( sshStatusHandle, &ssStatus);
		if( !fResult )
		{
            AddToMessageLog(TEXT("SetServiceStatus"));
        }
    }
    return fResult;
}



//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID AddToMessageLog(LPTSTR lpszMsg)
{
    TCHAR   szMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[2];


    if ( !bDebug )
    {
        dwErr = GetLastError();

        // Use event logging to log the error.
        //
        hEventSource = RegisterEventSource(NULL, TEXT(SZSERVICENAME));

        _stprintf(szMsg, TEXT("%s error: %d"), TEXT(SZSERVICENAME), dwErr);
        lpszStrings[0] = szMsg;
        lpszStrings[1] = lpszMsg;

        if (hEventSource != NULL) 
		{
			// Need to  
        }
    }
}




///////////////////////////////////////////////////////////////////
//
//  The following code handles service installation and removal
//


//
//  FUNCTION: CmdInstallService()
//
//  PURPOSE: Installs the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
	//
//  COMMENTS:
//
void CmdInstallService()
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    TCHAR szPath[512];

    if ( GetModuleFileName( NULL, szPath, 512 ) == 0 )
    {
        _tprintf(TEXT("Unable to install %s - %s\n"), TEXT(SZSERVICEDISPLAYNAME), GetLastErrorText(szErr, 256));
        return;
    }

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = CreateService(
            schSCManager,               // SCManager database
            TEXT(SZSERVICENAME),        // name of service
            TEXT(SZSERVICEDISPLAYNAME), // name to display
            SERVICE_ALL_ACCESS,         // desired access
            SERVICE_WIN32_OWN_PROCESS,  // service type
            SERVICE_DEMAND_START,       // start type
            SERVICE_ERROR_NORMAL,       // error control type
            szPath,                     // service's binary
            NULL,                       // no load ordering group
            NULL,                       // no tag identifier
            TEXT(SZDEPENDENCIES),       // dependencies
            NULL,                       // LocalSystem account
            NULL);                      // no password

        if ( schService )
        {
            _tprintf(TEXT("%s installed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
            CloseServiceHandle(schService);
        }
        else
        {
            _tprintf(TEXT("CreateService failed - %s\n"), GetLastErrorText(szErr, 256));
        }

        CloseServiceHandle(schSCManager);
    }
    else
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
}




//
//  FUNCTION: CmdRemoveService()
//
//  PURPOSE: Stops and removes the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdRemoveService()
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, TEXT(SZSERVICENAME), SERVICE_ALL_ACCESS);

        if (schService)
        {
            // try to stop the service
            if ( ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )
            {
                _tprintf(TEXT("Stopping %s."), TEXT(SZSERVICEDISPLAYNAME));
                Sleep( 1000 );

                while( QueryServiceStatus( schService, &ssStatus ) )
                {
                    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
                    {
                        _tprintf(TEXT("."));
                        Sleep( 1000 );
                    }
                    else
                        break;
                }

                if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
                    _tprintf(TEXT("\n%s stopped.\n"), TEXT(SZSERVICEDISPLAYNAME) );
                else
                    _tprintf(TEXT("\n%s failed to stop.\n"), TEXT(SZSERVICEDISPLAYNAME) );

            }

            // now remove the service
            if( DeleteService(schService) )
                _tprintf(TEXT("%s removed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
            else
                _tprintf(TEXT("DeleteService failed - %s\n"), GetLastErrorText(szErr,256));


            CloseServiceHandle(schService);
        }
        else
            _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256));

        CloseServiceHandle(schSCManager);
    }
    else
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
}




///////////////////////////////////////////////////////////////////
//
//  The following code is for running the service as a console app
//


//
//  FUNCTION: CmdDebugService(int argc, char ** argv)
//
//  PURPOSE: Runs the service as a console application
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdDebugService(int argc, char ** argv)
{
    DWORD dwArgc;
    LPTSTR *lpszArgv;

#ifdef UNICODE
    lpszArgv = CommandLineToArgvW(GetCommandLineW(), &(dwArgc) );
#else
    dwArgc   = (DWORD) argc;
    lpszArgv = argv;
#endif

    _tprintf(TEXT("Debugging %s.\n"), TEXT(SZSERVICEDISPLAYNAME));

    SetConsoleCtrlHandler( ControlHandler, TRUE );

    ServiceStart( dwArgc, lpszArgv );
}


//
//  FUNCTION: ControlHandler ( DWORD dwCtrlType )
//
//  PURPOSE: Handled console control events
//
//  PARAMETERS:
//    dwCtrlType - type of control event
//
//  RETURN VALUE:
//    True - handled
//    False - unhandled
//
//  COMMENTS:
//
BOOL WINAPI ControlHandler ( DWORD dwCtrlType )
{
    switch( dwCtrlType )
    {
        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
            _tprintf(TEXT("Stopping %s.\n"), TEXT(SZSERVICEDISPLAYNAME));
            ServiceStop();
            return TRUE;
            break;

    }
    return FALSE;
}

//
//  FUNCTION: GetLastErrorText
//
//  PURPOSE: copies error message text to string
//
//  PARAMETERS:
//    lpszBuf - destination buffer
//    dwSize - size of buffer
//
//  RETURN VALUE:
//    destination buffer
//
//  COMMENTS:
//
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize )
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           NULL,
                           GetLastError(),
                           LANG_NEUTRAL,
                           (LPTSTR)&lpszTemp,
                           0,
                           NULL );

    // supplied buffer is not long enough
    if ( !dwRet || ( (long)dwSize < (long)dwRet+14 ) )
        lpszBuf[0] = TEXT('\0');
    else
    {
        lpszTemp[lstrlen(lpszTemp)-2] = TEXT('\0');  //remove cr and newline character
        _stprintf( lpszBuf, TEXT("%s (0x%x)"), lpszTemp, GetLastError() );
    }

    if ( lpszTemp )
        LocalFree((HLOCAL) lpszTemp );

    return lpszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\string.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: String.cpp

Abstract:
	
	  This build the message that sent from transaction tests.
	  This code check the message order.
	  		
Author:

    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#pragma warning(disable :4786)

#include "msmqbvt.h"
using namespace std;

int operator != (StrManp& s1,StrManp &s2)
{
	return ! (s1==s2);
}
int operator == ( StrManp& s1, StrManp &s2)
{
	if (s1.array.size() != s2.array.size()) 
	{
		return 0;
	}
	vector<wstring> ::iterator p = s1.array.begin();
	vector<wstring> ::iterator s = s2.array.begin();
	while( p != s1.array.end())
	{
		if ( *p != *s )
		{
			return 0;
		}
		p++;
		s++;
	}
	return 1;
}

StrManp::~StrManp()
{

}
void StrManp::Clear()
{
	array.clear();
}
void StrManp::SetStr( wstring str)
{
	array.push_back(str);
}

void StrManp::print()
{
	for(vector <wstring> ::iterator it = array.begin();
		it != array.end();
		it++
	   )
	{
		wcout << *it <<endl;
	}
}

StrManp::StrManp( INT iSize ) : Size(iSize)
{
	array.clear();
}

StrManp::StrManp( INT iSize , wstring str) : Size( iSize )
{
	
	WCHAR csIndexAswstring[10];
	array.clear();
	for( int Index=0 ; Index <iSize ; Index ++ )
	{
		_itow( Index,csIndexAswstring, 9 );
		array.push_back( str + csIndexAswstring );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\srmp.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: SRMP.cpp

Abstract:
	Send / receive SRMP envelope
Author:
    
	Tal Kariv (talk) 12-7-2001
	
Revision History:

--*/
#include "msmqbvt.h"
using namespace std;
using namespace MSMQ;
static const wstring xSoapHeader = L"<BVT_Header>BVT - SRMP soap header</BVT_Header>";
static const wstring xSoapBody = L"<BVT_Body>BVT - SRMP soap body</BVT_Body>";

void CSRMP::Description()
{
	wMqLog(L"Thread %d : SRMP Thread\n", m_testid);
}

CSRMP::CSRMP(const INT iIndex , wstring wcsPublicQueueFormatName ):
cTest(iIndex),m_pEnvelope (NULL),m_hQueue(NULL),m_hCursor(NULL),m_publicQueueFormatName(L"")
{
	m_publicQueueFormatName = wcsPublicQueueFormatName;
}
CSRMP::~CSRMP()
{
	delete[] m_pEnvelope;
	if (m_hCursor != NULL)
	{
		MQCloseCursor(m_hCursor);
	}
	if (m_hQueue != NULL)
	{
		MQCloseQueue(m_hQueue);
	}
	

}

CSRMP::Start_test()
/*++  
	Function Description:
		send a SRMP message to a queue
	Arguments:
		none
	Return code:
		none
--*/
{
	HRESULT hr = MQ_OK;
	if(g_bDebug)
	{
		wMqLog(L"Opening queue %s\n" , m_publicQueueFormatName.c_str());
	}
	hr = MQOpenQueue(m_publicQueueFormatName.c_str(), MQ_SEND_ACCESS , MQ_DENY_NONE , &m_hQueue);
	ErrHandle(hr,MQ_OK,L"MQOpenQueue Failed");

	// message props
	cPropVar SRMPProps(3);
	SRMPProps.AddProp( PROPID_M_SOAP_HEADER , VT_LPWSTR , xSoapHeader.c_str() );
	SRMPProps.AddProp( PROPID_M_SOAP_BODY , VT_LPWSTR , xSoapBody.c_str() );
	SRMPProps.AddProp( PROPID_M_LABEL , VT_LPWSTR , m_wcsGuidMessageLabel.c_str());

	if(g_bDebug)
	{
		MqLog("Sending SRMP message (header + body)\n");
	}
	hr = MQSendMessage(m_hQueue , SRMPProps.GetMSGPRops(), NULL); 
	ErrHandle(hr,MQ_OK,L"MQSendMessage Failed");	
	VerifySendSucceded(m_publicQueueFormatName,g_wcsEmptyString);	
	hr = MQCloseQueue(m_hQueue);
	ErrHandle(hr,MQ_OK,L"MQCloseQueue Failed");
	m_hQueue = NULL;
	
	return MSMQ_BVT_SUCC;
}


CSRMP::CheckResult()
/*++  
	Function Description:
		receive the message that was sent from queue and check its envelope
	Arguments:
		none
	Return code:
		none
--*/
{
	wstring wcsReceiveFormatName =  ConvertHTTPToDirectFormatName(m_publicQueueFormatName);
	if(g_bDebug)
	{
		wMqLog(L"Opening queue %s\n" , wcsReceiveFormatName.c_str());
	}
	HRESULT hr = MQOpenQueue(wcsReceiveFormatName.c_str(), MQ_RECEIVE_ACCESS , MQ_DENY_NONE , &m_hQueue);
	ErrHandle(hr,MQ_OK,L"MQOpenQueue Failed");
	
	WCHAR wcsLabel[MQ_MAX_MSG_LABEL_LEN+1] = L"";
	ULONG ulMessageLabelLength = MQ_MAX_MSG_LABEL_LEN + 1;
	
	// message props
	cPropVar SRMPPropsPeek(3);
	SRMPPropsPeek.AddProp( PROPID_M_SOAP_ENVELOPE_LEN , VT_UI4 , 0 );
	SRMPPropsPeek.AddProp( PROPID_M_LABEL , VT_LPWSTR , wcsLabel  , MAX_GUID+1);
	SRMPPropsPeek.AddProp( PROPID_M_LABEL_LEN , VT_UI4 , &ulMessageLabelLength);
	
	hr = MQCreateCursor(m_hQueue , &m_hCursor);
	ErrHandle(hr,MQ_OK,L"MQCreateCursor Failed");

	if(g_bDebug)
	{
		MqLog("Peeking SRMP envelope\n");
	}
	hr = MQReceiveMessage(m_hQueue, 7000 , MQ_ACTION_PEEK_CURRENT , SRMPPropsPeek.GetMSGPRops() , NULL , NULL , m_hCursor , NULL);
	ErrHandle(hr,MQ_OK,L"MQReceiveMessage (MQ_ACTION_PEEK_CURRENT) Failed");
	for (;;)
	{
		if( m_wcsGuidMessageLabel == wcsLabel )
		{
			// found message
			if(g_bDebug)
			{
				MqLog("Message found in queue\n");
			}
			break;
		}
	    SRMPPropsPeek.AddProp( PROPID_M_LABEL_LEN , VT_UI4 , &ulMessageLabelLength);
		hr = MQReceiveMessage(m_hQueue, 7000 , MQ_ACTION_PEEK_NEXT , SRMPPropsPeek.GetMSGPRops() , NULL , NULL , m_hCursor , NULL);
		ErrHandle(hr,MQ_OK,L"MQReceiveMessage (MQ_ACTION_PEEK_NEXT) Failed");
		if(g_bDebug)
		{
			MqLog("Try next message\n");
		}

	}

	ULONG ulEnvelopeLength =0;
	SRMPPropsPeek.ReturnMSGValue( PROPID_M_SOAP_ENVELOPE_LEN , VT_UI4 , &ulEnvelopeLength);
	if(g_bDebug)
	{
		MqLog("Envelope length %d\n" , ulEnvelopeLength);
	}
	
	m_pEnvelope = new WCHAR[ulEnvelopeLength+1];
	if (m_pEnvelope == NULL)
	{
		MqLog("New failed\n");
		return (MSMQ_BVT_FAILED);
	}	
	// message props
	cPropVar SRMPPropsReceive(2);
	SRMPPropsReceive.AddProp( PROPID_M_SOAP_ENVELOPE , VT_LPWSTR , m_pEnvelope , ulEnvelopeLength);
	SRMPPropsReceive.AddProp( PROPID_M_SOAP_ENVELOPE_LEN , VT_UI4 , &ulEnvelopeLength );
	
	if(g_bDebug)
	{
		MqLog("Receiving SRMP envelope\n");
	}
	hr = MQReceiveMessage(m_hQueue, 7000 , MQ_ACTION_RECEIVE , SRMPPropsReceive.GetMSGPRops() , NULL , NULL , m_hCursor , NULL);
	ErrHandle(hr,MQ_OK,L"MQReceiveMessage (MQ_ACTION_RECEIVE) Failed");
	if(g_bDebug)
	{
		MqLog("Verifying header\n");
	}
	if (!wcsstr(m_pEnvelope , xSoapHeader.c_str()))
	{
		MqLog("Cannot find SRMP header\n");
		return (MSMQ_BVT_FAILED);
	}
	if(g_bDebug)
	{
		MqLog("Header - OK\nVerifying body\n");
	}
	if (!wcsstr(m_pEnvelope , xSoapBody.c_str()))
	{
		MqLog("Cannot find SRMP body\n");
		return (MSMQ_BVT_FAILED);
	}
	if(g_bDebug)
	{
		MqLog("Body - OK\n");
	}

	hr = MQCloseCursor(m_hCursor);
	ErrHandle(hr,MQ_OK,L"MQCloseQueue Failed");
	m_hCursor = NULL;
	hr = MQCloseQueue(m_hQueue);
	ErrHandle(hr,MQ_OK,L"MQCloseQueue Failed");
	m_hQueue = NULL;
	

	return MSMQ_BVT_SUCC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\sec.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Sec.h

Abstract:
	This is the Test that checks authenticate messages with or without authenticate queue
	This is part of the Security Test that add to the BVT after W2L beta 2.
		
Author:
    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#include <windows.h>


#ifndef MQBVT_SEC
#define FALBVT_SEC 1


class Handle_t 
{
public:
  Handle_t(HANDLE handle);
  HANDLE get();
  virtual ~Handle_t();

private:
  HANDLE m_handle;
};


class Impersonate_t
{
public:
	Impersonate_t(const std::string& user,const std::string& domain,const std::string& password);
	Impersonate_t(HANDLE hToken);
	void ImpersonateUser ();
	virtual ~Impersonate_t();

private:
	bool m_impersonated;
	HANDLE	m_hToken; 
};

inline void Impersonate_t::ImpersonateUser ()
{
	bool  bResult;
    bResult=(ImpersonateLoggedOnUser(m_hToken)==TRUE);
	CloseHandle(m_hToken);
	if(bResult == FALSE)
    {
	  throw INIT_Error("could not impersonate"); 
    }
}

inline  Impersonate_t::Impersonate_t(const std::string& user,const std::string& domain,const std::string& password):m_impersonated(true)
{
  	
    bool  bResult;

    if(user == "")
    {
      m_impersonated=FALSE;
      return;  
    }
	
	if (domain == "")
    { 
      bResult=(LogonUserA(const_cast<char*>(user.c_str()),
		                 NULL,
					   const_cast<char*>(password.c_str()),
					   LOGON32_LOGON_INTERACTIVE,
					   LOGON32_PROVIDER_DEFAULT,
					   &m_hToken)==TRUE);
	 
    } 
    else
    {
      bResult=(LogonUserA(const_cast<char*>(user.c_str()),
		                 const_cast<char*>(domain.c_str()),
					   const_cast<char*>(password.c_str()),
					   LOGON32_LOGON_INTERACTIVE,
					   LOGON32_PROVIDER_DEFAULT,
					   &m_hToken)==TRUE);  
       

    }

    if(bResult == FALSE )
    {
       throw INIT_Error("could not logon as the user");     
    }
/*
    bResult=(ImpersonateLoggedOnUser(hToken)==TRUE);
	BOOL b=CloseHandle(hToken);
	assert(b);
    if(bResult == false)
    {
	  throw INIT_Error("could not impersonate"); 
    }
	*/
}


inline Impersonate_t::~Impersonate_t()
{
 if(m_impersonated)
 {
   RevertToSelf();
 } 
}


inline std::basic_string<unsigned char> GetCurrentThreadSid( std::wstring & wcsAccountName );
inline void LoadHiveForSid(const std::basic_string<unsigned char>& sid);
inline std::string GetTextualSid(PSID pSid);
inline void SetSpecificPrivilegeInThreadAccessToken(LPCTSTR lpwcsPrivType, BOOL bEnabled);
inline void SetSpecificPrivilegeInAccessToken( HANDLE  hAccessToken,
											   LPCTSTR lpwcsPrivType,
											   BOOL    bEnabled );

HANDLE FAL_GetThreadSecurityContext(Impersonate_t  & user,std::wstring & szAccoutName);

#endif // Mqbvt_SEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\service.h ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1997  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE: service.h
//
//  AUTHOR: Craig Link
//
//
//  Comments:  The use of this header file and the accompanying service.c
//  file simplifies the process of writting a service.  You as a developer
//  simply need to follow the TODO's outlined in this header file, and 
//  implement the ServiceStart() and ServiceStop() functions.
//  
//  There is no need to modify the code in service.c.  Just add service.c
//  to your project and link with the following libraries...
//
//  libcmt.lib kernel32.lib advapi.lib shell32.lib
//
//  This code also supports unicode.  Be sure to compile both service.c and
//  and code #include "service.h" with the same Unicode setting.
//
//  Upon completion, your code will have the following command line interface
//
//  <service exe> -?                to display this list
//  <service exe> -install          to install the service
//  <service exe> -remove           to remove the service
//  <service exe> -debug <params>   to run as a console app for debugging
//
//  Note: This code also implements Ctrl+C and Ctrl+Break handlers
//        when using the debug option.  These console events cause
//        your ServiceStop routine to be called
//
//        Also, this code only handles the OWN_SERVICE service type
//        running in the LOCAL_SYSTEM security context.
//
//        To control your service ( start, stop, etc ) you may use the
//        Services control panel applet or the NET.EXE program.
//
//        To aid in writing/debugging service, the
//        SDK contains a utility (MSTOOLS\BIN\SC.EXE) that
//        can be used to control, configure, or obtain service status.
//        SC displays complete status for any service/driver
//        in the service database, and allows any of the configuration
//        parameters to be easily changed at the command line.
//        For more information on SC.EXE, type SC at the command line.
//

#ifndef _SERVICE_H
#define _SERVICE_H


#ifdef __cplusplus
extern "C" {
#endif

void CmdRemoveService();
VOID CmdInstallService();
//////////////////////////////////////////////////////////////////////////////
//// todo: change to desired strings
////
// name of the executable
#define SZAPPNAME            "Mqbvt"
// internal name of the service
#define SZSERVICENAME        "Mqbvtsrv"
// displayed name of the service
#define SZSERVICEDISPLAYNAME "Mqbvt Service"
// list of service dependencies - "dep1\0dep2\0\0"
#define SZDEPENDENCIES       ""
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// todo: ServiceStart()must be defined by in your code.
////       The service should use ReportStatusToSCMgr to indicate
////       progress.  This routine must also be used by StartService()
////       to report to the SCM when the service is running.
////
////       If a ServiceStop procedure is going to take longer than
////       3 seconds to execute, it should spawn a thread to
////       execute the stop code, and return.  Otherwise, the
////       ServiceControlManager will believe that the service has
////       stopped responding
////
VOID ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
VOID ServiceStop();
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// The following are procedures which
//// may be useful to call within the above procedures,
//// but require no implementation by the user.
//// They are implemented in service.c

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success 
//    FALSE - failure
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);


//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
void AddToMessageLog(LPTSTR lpszMsg);
//////////////////////////////////////////////////////////////////////////////


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\trans.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Trans.cpp

Abstract:

  1. Contain Send transaction messages to remote queue and read 
     it using transaction baoundery.
  2. Open system queue using direct format name NT5 only
  

Author:

    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#include "msmqbvt.h"
using namespace MSMQ;
#include "errorh.h"
#include <time.h>
using namespace std;
extern BOOL g_bRunOnWhistler;
#pragma warning(disable:4786)

//------------------------------------------------------------
// xActViaCom::Description Print test description
//

void xActViaCom::Description()
{
	wMqLog(L"Thread %d : Send xAct messages to %s queues %s\n", m_testid,m_wcsDescription.c_str(),(m_testid==24) ? L"(HTTP)":L"");
}

//------------------------------------------------------------
// 
// xActViaCom::xActViaCom constructor receive the queue format name.
//

xActViaCom::xActViaCom (INT index , map< wstring , wstring > Tparms )
:cTest(index), m_Destqinfo("MSMQ.MSMQQueueInfo"),m_ixActIndex(0),m_iMessageInTransaction(3),m_pSendBlock(NULL)
{
   m_wcsDestQueueFormatName = Tparms[L"FormatName"];
   ReturnGuidFormatName( m_SeCTransactionGuid , 2 , true );
   m_wcsDescription = Tparms[L"Desc"];
   m_bNT4WithSp6=FALSE;
   if ( Tparms[L"Sp6"] == L"YES")
   {
	   m_bNT4WithSp6=TRUE;
   }
   
   m_pSendBlock= new StrManp( m_iMessageInTransaction,L"RemoteTrans" );
   if( !m_pSendBlock )
   {
			MqLog("xActViaCom::Start_test Failed to allocate memory for StrManp \n");
			throw INIT_Error("xActViaCom::Start_test Failed to allocate memory for StrManp \n");
   }
}

xActViaCom::~xActViaCom ()
{
   delete m_pSendBlock;
}

//-----------------------------------------------
// xActViaCom::Start_test
// Send transacted message to remote queue using DTC transaction.
// 
// Return value:
// MSMQ_BVT_SUCC - Pass// MSMQ_BVT_FAILED - Fail
//

INT xActViaCom::Start_test()
{

	SetThreadName(-1,"xActViaCom - Start_test ");	
	try 
	{
		m_Destqinfo->FormatName = m_wcsDestQueueFormatName.c_str();
		wstring wcsToken=L"DIRECT=";
		size_t iDirectExist = m_wcsDestQueueFormatName.find_first_of(wcsToken);
		
		if ( iDirectExist != 0 )
		{ // Can do refresh on direct format name on remote machine
			m_Destqinfo->Refresh();
		}

		MSMQ::IMSMQQueuePtr m_DestqinfoHandle;
		MSMQ::IMSMQMessagePtr m_msg("MSMQ.MSMQMessage");
		
		
		//
		// Print Debug information
		//
		
		if( g_bDebug )
		{
			wMqLog (L"xActViaCom::Start_test, Send message to queue PathName:%s \n QueueFormatName: %s\n",m_Destqinfo->PathName,m_Destqinfo->FormatName);
		}

		m_DestqinfoHandle=m_Destqinfo->Open (MQ_SEND_ACCESS,MQ_DENY_NONE);	
		
		MSMQ::IMSMQTransactionDispenserPtr xdispenser ("MSMQ.MSMQTransactionDispenser");
		MSMQ::IMSMQTransactionPtr xact("MSMQ.MSMQTransaction");
		
		xact = xdispenser->BeginTransaction ();

		_variant_t vTrans(static_cast<IDispatch*>(xact));
		
		m_msg->MaxTimeToReceive = MQBVT_MAX_TIME_TO_BE_RECEIVED;
		m_msg->Label = m_wcsGuidMessageLabel.c_str();
		//
		// Send three messages 
		//
		
		for( INT Index=0 ; Index<m_iMessageInTransaction ; Index++)
		{
			if ( g_bDebug )
			{
				wMqLog (L"xActViaCom::Start_test, Send message label %s Body %s\n",m_wcsGuidMessageLabel.c_str(),(m_pSendBlock->GetStr( Index )).c_str());
			}
			m_msg->Body = (m_pSendBlock->GetStr( Index )).c_str();
			m_msg->Send( m_DestqinfoHandle , &vTrans );	
		}
		VerifySendSucceded(m_wcsDestQueueFormatName);
		xact->Commit();
		m_ixActIndex++;
	
		xact = xdispenser->BeginTransaction ();
		_variant_t vTrans2(static_cast<IDispatch*>(xact));
		m_msg->Label = m_SeCTransactionGuid.c_str();
		
		for( Index=0 ; Index<m_iMessageInTransaction ; Index++)
		{
			if ( g_bDebug )
			{
				wcout << L"xActViaCom::Start_test, Send message label:"<<m_SeCTransactionGuid.c_str()<< L"body" << m_pSendBlock->GetStr( Index ).c_str() <<endl;
			}
			m_msg->Body = (m_pSendBlock->GetStr( Index )).c_str();
			m_msg->Send( m_DestqinfoHandle , &vTrans2 );	
		}
		xact->Commit();
		m_ixActIndex++;
		
		if( g_bDebug )
		{
			wMqLog (L"xActViaCom::Start_test, Send message using DTC transaction");
		}
	}
	catch (_com_error & ComErr)
	{
		
		return CatchComErrorHandle( ComErr , m_testid );
	}
	return MSMQ_BVT_SUCC;
}

//--------------------------------------------------------
// Receive message from dest queue without transaction.
// 
// Return value:
// MSMQ_BVT_SUCC - Pass
// MSMQ_BVT_FAILED - Fail
//

INT xActViaCom::CheckResult()
{
		
	HRESULT rc;
	if ( g_bDebug )
	{	
		wMqLog (L"Try to receive from QFN:%s\n",m_wcsDestQueueFormatName.c_str());
	}
	
	INT iNumberOfTransaction=0;
	INT iMessageInTrans = 0;
	map < wstring,wstring > map_ReceiveFromQueue;
	map_ReceiveFromQueue[L"DestFormatName"] = ConvertHTTPToDirectFormatName(m_wcsDestQueueFormatName);
	map_ReceiveFromQueue[L"mLabel"] = m_wcsGuidMessageLabel;
	StrManp pwcsMessgeBody(m_iMessageInTransaction);				
	do
	{
		if ( _winmajor >= Win2K )
		{	
			map_ReceiveFromQueue[L"mBody"] = g_wcsEmptyString;
			map_ReceiveFromQueue[L"TransBoundary"] = g_wcsEmptyString;
		}
		if( g_bDebug )
		{
			wcout <<L"Try to receive message with guid:" << m_wcsGuidMessageLabel <<endl;
		}
		rc = RetrieveMessageFromQueueViaCom( map_ReceiveFromQueue );
		if( rc != MSMQ_BVT_SUCC )
		{
			MqLog("Message not found in the destination queue. (1)\n");
			wMqLog(L"Transaction: %d (out of %d), Message:%d  Not found in dest queue \n", iNumberOfTransaction+1, m_ixActIndex, iMessageInTrans+1);
			return MSMQ_BVT_FAILED;
		}
		if( g_bDebug )
		{
			wcout <<L"Receive Messages" << map_ReceiveFromQueue[L"mBody"] <<endl;
		}
		//
		// bugbug delete all meessage in the queue.
		// 
		if( _winmajor ==  NT4 && m_bNT4WithSp6 == FALSE )
		{
			break;
		}
		
		if( map_ReceiveFromQueue[L"TransBoundary"] == L"First")
		{
			iMessageInTrans=0;
		}
		pwcsMessgeBody.SetStr(map_ReceiveFromQueue[L"mBody"]);
		iMessageInTrans ++;
		
		if( g_bDebug )
		{
				wMqLog(L"Found message %s\n",(map_ReceiveFromQueue[L"mBody"]).c_str());
		}	

		if( map_ReceiveFromQueue[L"TransBoundary"] == L"Last")
		{
		
			iNumberOfTransaction ++;
			if( iMessageInTrans != m_iMessageInTransaction )
			{
				wMqLog (L"xActViaCom::CheckResult Can't find the last message Found %d messages \n Sent %d messages \n", 
					iMessageInTrans , m_iMessageInTransaction );
				wMqLog(L"Message body %s\n",(map_ReceiveFromQueue[L"mBody"]).c_str());
				return MSMQ_BVT_FAILED;
			}
			if( *m_pSendBlock != pwcsMessgeBody )
			{
				wMqLog (L"Error message are not in expected order\n");
				return MSMQ_BVT_FAILED;
			}
			pwcsMessgeBody.Clear();
			map_ReceiveFromQueue[L"mLabel"]=m_SeCTransactionGuid;
		}
		else
		{
			if ( iMessageInTrans >= m_iMessageInTransaction )
			{
				MqLog("xActViaCom::CheckResult - Excepted message boundary 'last' and found expected message without any transaction boundary\n");
				return MSMQ_BVT_FAILED;
			}
		}
		
	} while ( iNumberOfTransaction != m_ixActIndex );
	
	if( rc != MSMQ_BVT_SUCC )
	{
		MqLog( "Message not found in the destination queue. (1)");
		return MSMQ_BVT_FAILED;
	}
	if ( g_bDebug )
	{	
		wcout<<L"xActViaCom::CheckResult - message found in the queue" <<endl;
	}
	return MSMQ_BVT_SUCC;
}

// Add to check trnsaction baounder 
// Need to ask in the return value 


//-------------------------------------------------------------------
// COpenQueues::COpenQueues
// This test try to open system queues with differnt format names
// 
// 
//


COpenQueues::COpenQueues( int Index,  map<wstring,wstring> & Tparms ) : cTest(Index),m_wcsLocalMachineName(L""),
	m_iEmbedded(COM_API)
{
	m_wcsLocalMachineName =  Tparms[L"LocalMachineName"];
	m_MachineName.push_back( Tparms[L"LocalMachineName"] );
	m_MachineName.push_back( Tparms[L"RemoteMachineName"] );
	m_MachineGuid.push_back( Tparms[L"LocalMachineNameGuid"] );
	m_MachineGuid.push_back( Tparms[L"RemoteMachineNameGuid"] );
	iWorkGroupFlag = 0;
	if ( Tparms[L"Wkg"] == L"Wkg" )
	{
		iWorkGroupFlag = 1;
	}
	if (Tparms[L"SkipOnComApi"] == L"Yes" )
	{
		m_iEmbedded = C_API_ONLY;
	}

}



//-------------------------------------------------------------
// COpenQueues::Start_test
// Prepare all queue direct format names
// Example direct=os:machinename\\System$;jornal / deadletter / deadxact
// return values:
// Pass - MSMQ_BVT_SUCC	
// Fail - MSMQ_BVT_FAILED

INT COpenQueues::Start_test()
{
	SetThreadName(-1,"COpenQueues - Start_test ");	

	WSADATA WSAData;
	if ( WSAStartup(MAKEWORD(1,1), &WSAData) != 0 )
	{
		MqLog("WSAStartup failed with error 0x%x\n",GetLastError());
		return MSMQ_BVT_FAILED;
	}
	
	vector <wstring> vSpeceilQueueName(3),vGuidName(3);
	vector <wstring> vOpenQueuMode(3);
	//
	// Direct format name 
	// 
	const int iJORNAL=0;
	const int iDADLATER=1;
	const int iDADXACT=2;
	vSpeceilQueueName[iJORNAL]=L"\\SYSTEM$;JOURNAL";
	vSpeceilQueueName[iDADLATER]=L"\\SYSTEM$;DEADLETTER";
	vSpeceilQueueName[iDADXACT]=L"\\SYSTEM$;DEADXACT";
	
	vGuidName[iJORNAL]=L";JOURNAL";
	vGuidName[iDADLATER]=L";DEADLETTER";
	vGuidName[iDADXACT]=L";DEADXACT";

	vOpenQueuMode[0]=L"Direct=os:";
	vOpenQueuMode[1]=L"Direct=tcp:";
	vOpenQueuMode[2]=L"machine=";
	
	//
	// Init the local & Remote machine IP address
	// 

	string Temp = My_WideTOmbString( m_MachineName.front());
	for ( int Index = 0 ; Index < 2 ; Index ++ )
	{
	
		struct hostent* pHost = gethostbyname( Temp.c_str() );
		if ( pHost && pHost->h_length == 4)
		{
			in_addr Address;
			Address.S_un.S_addr = *(u_long*)(pHost->h_addr);
			char* pszAddress = inet_ntoa(Address);
			if ( pszAddress != NULL)
			{
				m_IPaddress.push_back( My_mbToWideChar (pszAddress) );
			}
			else
			{
				m_IPaddress.push_back( g_wcsEmptyString );
			}

		}
		else
		{
			wMqLog (L"Can't retrieve local machine IP address\n");
			m_IPaddress.push_back( g_wcsEmptyString );
			WSACleanup();
			return MSMQ_BVT_FAILED;
		}
		Temp = My_WideTOmbString( m_MachineName.back());
	}

	WSACleanup();
	
	//
	// Create all format name permoation.
	// 

	vector <wstring>::iterator pIpAddress = m_IPaddress.begin();
	vector <wstring>::iterator pMachineGuid = m_MachineGuid.begin();
    for	( vector <wstring>::iterator p= m_MachineName.begin(); p != m_MachineName.end(); 
		p++ , pIpAddress ++ , pMachineGuid ++ )
	{
		vector <wstring>::iterator pGuidQueueName = vGuidName.begin();
		for	( vector <wstring>::iterator pQueueName = vSpeceilQueueName.begin(); pQueueName != vSpeceilQueueName.end(); 
		pQueueName ++ , pGuidQueueName ++)
		{
			m_vSpeceilFormatNames.push_back( vOpenQueuMode[0]+ *p + *pQueueName );

			if (*pIpAddress != g_wcsEmptyString )
			{
				m_vSpeceilFormatNames.push_back( vOpenQueuMode[1]+ *pIpAddress+ *pQueueName );	
			}
		
			if (*pIpAddress != g_wcsEmptyString)
			{
				m_vSpeceilFormatNames.push_back( vOpenQueuMode[2]+ *pMachineGuid+ *pGuidQueueName );	
			}		
		}
	}

	if ( g_bDebug )
	{
		MqLog("---------------------------\n");
		dbg_printAllQueue();
	}
	//
	// Send Tx messages and expected TTL = 0;
	// 
	if(g_bRunOnWhistler && m_iEmbedded != C_API_ONLY )
	{
		if(g_bDebug)
		{
			MqLog("Send xACT Message to non existing destination with MaxTimeToReachQueue=0\n" \
				  "Expected result messages should be in XACT-Dead Letter queue\n");
		}
		try
		{
			IMSMQQueueInfoPtr m_Destqinfo("MSMQ.MSMQQueueInfo");
			IMSMQQueuePtr m_DestqinfoHandle;
			IMSMQMessagePtr m_msg("MSMQ.MSMQMessage");
			m_Destqinfo->FormatName = "direct=os:UnKnownComp\\private$\\Nothing";
			m_DestqinfoHandle=m_Destqinfo->Open (MQ_SEND_ACCESS,MQ_DENY_NONE);	
			IMSMQTransactionDispenserPtr xdispenser ("MSMQ.MSMQTransactionDispenser");
			IMSMQTransactionPtr xact("MSMQ.MSMQTransaction");	
			xact = xdispenser->BeginTransaction ();
			_variant_t vTrans(static_cast<IDispatch*>(xact));
			m_msg->Label = m_wcsGuidMessageLabel.c_str();
			m_msg->Body = m_wcsGuidMessageLabel.c_str();
			m_msg->MaxTimeToReachQueue = 0;
			m_msg->Journal = MQMSG_JOURNAL | MQMSG_DEADLETTER;
			m_msg->MaxTimeToReceive = MQBVT_MAX_TIME_TO_BE_RECEIVED;
			m_msg->Send( m_DestqinfoHandle , &vTrans );	
			xact->Commit();
		}
		catch (_com_error & ComErr)
		{	
			return CatchComErrorHandle( ComErr , m_testid );
		}
	}


return MSMQ_BVT_SUCC;	
}

//----------------------------------------------------
// COpenQueues::dbg_printAllQueue
// Use for debug print all queue formatnames
// 

void COpenQueues::dbg_printAllQueue() 
{
	for	( vector <wstring>::iterator p= m_vSpeceilFormatNames.begin(); p != m_vSpeceilFormatNames.end(); 
		p++)
		{
			wcout << *p <<endl;
		}
}

//----------------------------------------------------
// Try to open queue format name 
//

INT COpenQueues::CheckResult()  
{
	bool bUserCanOpenSystemQueues = true;
	for	( vector <wstring>::iterator p= m_vSpeceilFormatNames.begin(); p != m_vSpeceilFormatNames.end(); 
	p++)
	{
		
		
		
		//
		// Need this because workgroup could not open queue using machine=GUID...
		// 
		if ( iWorkGroupFlag == 1 )
		{
			wstring wcsToken=L"machine=";
			size_t iPos = p->find_last_of (wcsToken);	
			if ( iPos != 0 )	
			{
				continue;
			}
		}


		if( g_bDebug )
		{
			wMqLog(L"Try to open queue with Special format name: %s\n",p->c_str());
		}
		
		HANDLE hQueue;
		HRESULT rc = MQOpenQueue( p->c_str() , MQ_RECEIVE_ACCESS , MQ_DENY_NONE, & hQueue );
		if( rc != MQ_OK )
		{
			if ( rc != MQ_ERROR_ACCESS_DENIED )
			{
				wMqLog( L"Failed to open queue Path:%s with error rc=%x\n", p->c_str() , rc);
				ErrHandle( rc , MQ_OK , L"MQOpenQeueue failed" );
				return MSMQ_BVT_FAILED; 
			}
			else
			{ // MQ_ERROR_ACCESS_DENIED 
				//
				// Need to check if you are Administrator on the localmachine.
				// 
				bUserCanOpenSystemQueues = false;
			}
		}
		else
		{ // MQ_OK
			bUserCanOpenSystemQueues = true;
			rc = MQCloseQueue( hQueue );
			ErrHandle( rc , MQ_OK , L"MQCloseQueue failed\n");
		}
	}

	if(g_bRunOnWhistler && bUserCanOpenSystemQueues && m_iEmbedded != C_API_ONLY )
	{
		if(g_bDebug)
		{
			MqLog("Receive message from XACT-Dead Letter queue\n");
		}
		map < wstring,wstring > map_ReceiveFromQueue;
		wstring wcsFormatName =  L"DIRECT=OS:";
		wcsFormatName += m_wcsLocalMachineName;
		wcsFormatName += L"\\SYSTEM$;DEADXACT";
		map_ReceiveFromQueue[L"FormatName"] = wcsFormatName;
		map_ReceiveFromQueue[L"M_Label"] = m_wcsGuidMessageLabel;
		map_ReceiveFromQueue[L"mBody"] = m_wcsGuidMessageLabel;
		map_ReceiveFromQueue[L"DebugInformation"] = L"Look for NACK timeout message";
		WCHAR wstrMclass[10]={0};
		swprintf(wstrMclass,L"%d\n",MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT);
		map_ReceiveFromQueue[L"MClass"] = wstrMclass;
		HRESULT rc = RetrieveMessageFromQueue ( map_ReceiveFromQueue );
		if(rc!=MSMQ_BVT_SUCC)
		{
			wMqLog(L"Message not found in the destination queue. (1)");
			return MSMQ_BVT_FAILED;
		}
	}
		
return MSMQ_BVT_SUCC;
}
//----------------------------------------------------------
//
//

void COpenQueues::Description(void)
{
	wMqLog(L"Thread %d : Try open system queues\n", m_testid);
}
//----------------------------------------------------------
// Transaction Boundaries tests for Service pack 6
// check those using the C API,
//
//

xActUsingCapi::xActUsingCapi (INT index , std::map < std :: wstring , std:: wstring > Tparms ) : xActViaCom( index , Tparms )
{
 /* Empty */
}

//--------------------------------------------------
// xActUsingCapi::CheckResult
// Transaction Boundaries CheckeResult using C-API
//
INT xActUsingCapi::CheckResult()
{

	HRESULT rc;
	if ( g_bDebug )
	{	
		wMqLog (L"Try to receive from QFN:%s\n",m_wcsDestQueueFormatName.c_str());
	}

	INT iNumberOfTransaction=0;
	INT iMessageInTrans=0;
	map < wstring,wstring > map_ReceiveFromQueue;
	map_ReceiveFromQueue[L"FormatName"] = m_wcsDestQueueFormatName;
	map_ReceiveFromQueue[L"M_Label"] = xActViaCom::m_wcsGuidMessageLabel;
	map_ReceiveFromQueue[L"DebugInformation"] = L"Receive message from queue";
	StrManp pwcsMessgeBody(m_iMessageInTransaction); 
	do
	{
		map_ReceiveFromQueue[L"mBody"] = g_wcsEmptyString;
		map_ReceiveFromQueue[L"TransBaoundery"] = g_wcsEmptyString;
		
		rc = RetrieveMessageFromQueueViaCom ( map_ReceiveFromQueue );
		if( rc != MSMQ_BVT_SUCC )
		{
			wMqLog(L"Message not found in the destination queue. (1)");
			return MSMQ_BVT_FAILED;
		}
	
		if( map_ReceiveFromQueue[L"TransBoundary"] == L"First")
		{
			iMessageInTrans=0;
		}
		pwcsMessgeBody.SetStr(map_ReceiveFromQueue[L"mBody"]);
		iMessageInTrans ++;
		if( g_bDebug )
		{
				wMqLog(L"Found message %s\n",(map_ReceiveFromQueue[L"mBody"]).c_str());
		}	

		if( map_ReceiveFromQueue[L"TransBoundary"] == L"Last")
		{
		
			iNumberOfTransaction ++;
			if( iMessageInTrans != m_iMessageInTransaction )
			{
				wMqLog (L"xActViaCom::CheckResult Can't find the last message Found %d messages \n Sent %d messages \n", 
					iMessageInTrans , m_iMessageInTransaction );
				return MSMQ_BVT_FAILED;
			}
			if( *m_pSendBlock != pwcsMessgeBody )
			{
				wMqLog (L"Error message are not in expected order\n");
				return MSMQ_BVT_FAILED;
			}
			pwcsMessgeBody.Clear();
			map_ReceiveFromQueue[L"M_Label"]=xActViaCom::m_SeCTransactionGuid;
		}
		
	} while ( iNumberOfTransaction != m_ixActIndex );

	if( rc != MSMQ_BVT_SUCC )
	{
		MqLog("Message not found in the destination queue. (1)\n");
		return MSMQ_BVT_FAILED;
	}

	if ( g_bDebug )
	{	
		wcout<<L"xActViaCom::CheckResult - message found in the queue" <<endl;
	}
	return MSMQ_BVT_SUCC;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\sendrcv.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Sendrcv.cpp

Abstract:

	     Use this class for send receive messages:
		 a. Private local queues.
		 b. Public local queues.
		 c. Public remote queue.
		 Those tests try to Send & receive messages from destination queue.
		
Author:
    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#pragma warning(disable :4786)


//
// cAllSentMessageProp
// All message that sent written in array
// need to enhanced to check if all the propety recive in the messgae block
//


#include "msmqbvt.h"
using namespace std;



extern BOOL g_bRunOnWhistler;
HRESULT RetrieveMessageFromQueue(map <wstring,wstring> & mRetriveParms );


extern DWORD  g_dwRxTimeOut ;
extern BOOL g_bRunOnWhistler;

void cSendMessages::Description()
{
	wMqLog(L"Thread %d : Send receive message", m_testid);

	switch (m_testid)
	{
		case 1:
				wMqLog (L" from local private queue\n");
				break;
		case 2:
				wMqLog (L" ,local public Q\n");
				break;
		case 3:
				wMqLog (L" ,remote public Q(RemoteRead)\n");
				break;
		case 10:
				wMqLog (L" ,remote private Q using direct=os(RemoteRead)\n");
				break;
		case 18:
				wMqLog (L" ,local private Q (HTTP)\n");
				break;
		case 19:
				wMqLog (L" ,local public Q (HTTP)\n");
				break;
		case 20:
				wMqLog (L" ,remote public Q (HTTP)(RemoteRead)\n");
				break;
		case 21:
				wMqLog (L" ,remote private Q (HTTP)(RemoteRead)\n");
				break;

		default:
				MqLog (" \n");

	}
	
}

//------------------------------------------------------------------------------
// cSendMessages
//
// Contructor for this test's class.
//
//
// This Tests Get FormatName To:
// a. Dest Queue - strote in the map as DESTQFN.
// b. Admin Queue - map <wstring,wstring> ADMINFN.
//
//

cSendMessages::cSendMessages( INT iTid , map <wstring,wstring> Params ): 
	cTest( iTid ),
	m_bUseHTTPDirectFormatName(FALSE),
	m_bUseOnlyDirectFormatName(FALSE)
{

	if( Params[L"UseOnlyDirectFN"] == L"TRUE" )
	{
		m_bUseOnlyDirectFormatName = TRUE;
	}
	if( Params[L"UseDirectHTTP"] == L"TRUE" )
	{
		m_bUseHTTPDirectFormatName = TRUE;
	}
	// Retrive all the parmeters from the Map
	m_wcsDestQFormatName = Params[L"DESTQFN"];
	m_wcsAdminQFormatName = Params[L"ADMINFN"];
	//
	// check if get not empty strings
	//
	if( m_wcsDestQFormatName == L"Empty" || m_wcsAdminQFormatName == L"Empty" )
	{
	  if(g_bDebug)
	  {
		 wcout <<L"Q1 FN:"<< m_wcsDestQFormatName<<endl<<L"Q2 FN:" << m_wcsAdminQFormatName << endl;
	  }
	    throw INIT_Error("Can't Use this Queues");
	}
	
	//
	// Create Messgae Guid
	//
	wcsGuidMessageLabel = m_wcsGuidMessageLabel;
	//
	// Build the direct formatName "direct = os: machine name \ Qname "
	//
	wstring QueueName = Params[L"DestQName"];	
	const wstring Token=L"\\";
	size_t iPos = QueueName.find_first_of(Token);	
	m_wcsDestDirectFormatName = ( m_bUseHTTPDirectFormatName ) ? L"Direct=htTP://":L"Direct=os:";
	m_wcsDestDirectFormatName += Params[L"MachName"];
	if( m_bUseHTTPDirectFormatName )
	{
		m_wcsDestDirectFormatName += L"\\MsMq";
	}
	m_wcsDestDirectFormatName += QueueName.substr( iPos );
	//
	// DIRECT=HTTP://mycomputer.microsoft.com/msmq/mypublicq
	//
	wstring wcsIISNameSpace =  L"\\msmq";
	if( m_bUseHTTPDirectFormatName == TRUE )
	{
		m_wcsDestHTTPDirectFormatName = L"Direct=HtTp://";
		m_wcsDestHTTPDirectFormatName += Params[L"MachName"];
		m_wcsDestHTTPDirectFormatName += wcsIISNameSpace;
		m_wcsDestHTTPDirectFormatName += QueueName.substr( iPos );

		wstring wcsQueueName = Params[L"AdminQueuePathName"];	
		iPos = wcsQueueName.find_first_of(Token);	
		
		if( iPos != -1 )
		{
			wstring wcsTempString;		
			wcsTempString = L"Direct=hTtP://";
			wcsTempString += Params[L"LocalMachName"];
			wcsTempString += wcsIISNameSpace;
			wcsTempString += wcsQueueName.substr( iPos );
			m_wcsAdminQFormatName = wcsTempString;
		}
		
		
	}


	if( g_bDebug )
	{	
		wMqLog(L"Send Receive messages tests will use these queues\n" );
		wMqLog(L"DestQ  guid:%s\n",m_wcsDestQFormatName.c_str());
		wMqLog(L"DestQ  direct fn:%s \n",m_wcsDestDirectFormatName.c_str());
		wMqLog(L"AdminQ direct fn:%s \n",m_wcsAdminQFormatName.c_str());
	}
}

HRESULT RetrieveMessageFromQueueById(map <wstring,wstring> & mRetriveParms );
//
// This tests recive messages from queue those steps:
// 1. regular format name.
// 2. Direct format name.
// 3. Admin Queue message
//

cSendMessages::CheckResult()
{

	map <wstring,wstring> mPrepareBeforeRecive;
	mPrepareBeforeRecive[L"M_Label"] = m_wcsGuidMessageLabel;
	
	//
	// Check the admin messages for Ack/Nack.
	//
	if (m_bUseOnlyDirectFormatName)
	{
		WCHAR wstrMclass[10]={0};
		swprintf(wstrMclass,L"%d\n",MQMSG_CLASS_ACK_REACH_QUEUE);
		mPrepareBeforeRecive[L"FormatName"]=ConvertHTTPToDirectFormatName(m_wcsAdminQFormatName);
		mPrepareBeforeRecive[L"DebugInformation"]=L"Recieve ACK from admin queue";
		mPrepareBeforeRecive[L"MClass"]= wstrMclass;
		
		if( g_bDebug)
		{
			wMqLog (L"Try to receive ACK / NACK from admin queue: %s\n",m_wcsAdminQFormatName.c_str());
			wMqLog (L"Expected result is MQMSG_CLASS_ACK_REACH_QUEUE \n");
		}
		HRESULT rc = RetrieveMessageFromQueue(  mPrepareBeforeRecive );
		if( rc !=  MSMQ_BVT_SUCC )
		{
			return MSMQ_BVT_FAILED;	
		}
	}

	//
	// Look for and receive a message with a specific GUID label
	// Other tests will have messages in the queue with different
	// GUID labels.
	//	
	if( ! m_bUseOnlyDirectFormatName )
	{	
		if( g_bDebug)
		{
			wMqLog (L"Try to receive from queue :%s\n",m_wcsDestQFormatName.c_str());
		}
		mPrepareBeforeRecive[L"FormatName"] = ConvertHTTPToDirectFormatName(m_wcsDestQFormatName);
		mPrepareBeforeRecive[L"DebugInfromation"]=L"Receive message from dest queue";
		HRESULT rc = RetrieveMessageFromQueue( mPrepareBeforeRecive );
		if( rc != MSMQ_BVT_SUCC  )
		{
			return MSMQ_BVT_FAILED;		
		}
	}

	if( _winmajor >= Win2K && ( m_bUseOnlyDirectFormatName  ) )
	{
		//
		// Try to receive with direct format name.
		//
		if( g_bDebug)
		{
			wMqLog (L"Try to receive from queue :%s\n",m_wcsDestDirectFormatName.c_str());
		}
		mPrepareBeforeRecive[L"FormatName"]=ConvertHTTPToDirectFormatName(m_wcsDestDirectFormatName);
		mPrepareBeforeRecive[L"DebugInformation"]=L"Receive message from dest queue using direct format name";
		HRESULT rc = RetrieveMessageFromQueue(  mPrepareBeforeRecive );
		if( rc !=  MSMQ_BVT_SUCC )
		{
			MqLog("Information:Receive with direct failed , Please check ping \n");
			return MSMQ_BVT_FAILED;	
		}

	}

	if( m_bUseHTTPDirectFormatName )
	{
		if( g_bDebug )
		{
			MqLog("Try to receive message from queue using MQReceiveMessageByLookupId API \n");
		}
		mPrepareBeforeRecive[L"DebugInfromation"]=L"Receive message from dest queue using MQReceiveMessageByLookupId";
		HRESULT rc = RetrieveMessageFromQueueById( mPrepareBeforeRecive );
		if(rc != MSMQ_BVT_SUCC )
		{
			wMqLog(L"Failed to locate messages by using lookup ID\n");
			return MSMQ_BVT_FAILED;
		}
	}

	return MSMQ_BVT_SUCC;
}

//-----------------------------------------------------------------------------
// cSendMessages::Start_test()
//
// This is the Send-receive messages test
// There are four tests -- Send to and receive from:
//		1. Local private
//		2. Local public
//		3. Remote public
//		4. Remote private
//

INT cSendMessages::Start_test()
{
	
	HRESULT rc=MQ_OK;
	HANDLE QueueuHandle = NULL;
	cPropVar T13MessageProps(8);
	SetThreadName(-1,"cSendMessages - Start_test ");
	wstring Label(L"T1-3");
	//
	// Open the queue for send
	//
	//
	// Send express message with GUID format name.
	//
	T13MessageProps.AddProp( PROPID_M_BODY , VT_UI1|VT_VECTOR , m_wcsGuidMessageLabel.c_str() );
	T13MessageProps.AddProp( PROPID_M_LABEL , VT_LPWSTR , m_wcsGuidMessageLabel.c_str() );
	T13MessageProps.AddProp( PROPID_M_ADMIN_QUEUE , VT_LPWSTR , m_wcsAdminQFormatName.c_str() );
	UCHAR tempValue=MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL;
	T13MessageProps.AddProp(PROPID_M_ACKNOWLEDGE ,VT_UI1,&tempValue);
	ULONG ulTemp = MQBVT_MAX_TIME_TO_BE_RECEIVED; 
	T13MessageProps.AddProp( PROPID_M_TIME_TO_BE_RECEIVED , VT_UI4, &ulTemp );

	//
	// Send message using GUID FormatName
	//
	wstring wcsTempFormatName = m_wcsDestQFormatName;
	if( m_bUseOnlyDirectFormatName )
	{
		wcsTempFormatName = m_wcsDestDirectFormatName;
	}
	else if (m_bUseHTTPDirectFormatName)
	{
		wcsTempFormatName = m_wcsDestHTTPDirectFormatName;
	}
	if( g_bDebug )
	{
		wcout << L"DestQ FN: " << wcsTempFormatName.c_str() <<endl;
		wMqLog(L"Call->MQOpenQueue(%s,MQ_SEND_ACCESS , MQ_DENY_NONE ,,)\n",wcsTempFormatName.c_str());
	}
	rc=MQOpenQueue( wcsTempFormatName.c_str() , MQ_SEND_ACCESS , MQ_DENY_NONE , &QueueuHandle );
	ErrHandle(rc,MQ_OK,L"MQOpenQueue Failed");
	if(g_bDebug)
	{
		MqLog("Send message to queue with properties PROPID_M_BODY,PROPID_M_LABEL,PROPID_M_ADMIN_QUEUE,MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL\n");
		wMqLog(L"Admin queue %s\n",m_wcsAdminQFormatName.c_str());
	}
	rc = MQSendMessage( QueueuHandle , T13MessageProps.GetMSGPRops() , NULL);
	ErrHandle(rc,MQ_OK,L"MQSendMessage (1) Failed");

	VerifySendSucceded(wcsTempFormatName,m_wcsAdminQFormatName);	
	//
	// Send recoverable message with direct format name
	//
	if( g_bDebug )
	{
		MqLog("Add prop MQMSG_DELIVERY_RECOVERABLE\n");
	}
	tempValue=MQMSG_DELIVERY_RECOVERABLE;
	T13MessageProps.AddProp( PROPID_M_DELIVERY , VT_UI1 , &tempValue );
	rc = MQSendMessage( QueueuHandle , T13MessageProps.GetMSGPRops() , NULL);
	ErrHandle(rc,MQ_OK,L"MQSendMessage (2) Failed");
	rc=MQCloseQueue(QueueuHandle);
	ErrHandle(rc,MQ_OK,L"MQCloseQueue Failed");
	return MSMQ_BVT_SUCC;
}


VOID InvetigateTimeOut(CONST WCHAR * pLabel, CONST WCHAR * pBody )
/*++
	Function Description:
		This function sends messages to local .\private$\debug queue with destination format name and Msg body properties
	 Arguments:
		 pLabel -
		 pBody - 
	Return code:
		None.
--*/

{
	try
	{
		MSMQ::IMSMQQueueInfoPtr qinfo("MSMQ.MSMQQueueInfo");
		qinfo->FormatName = "direct=os:.\\private$\\Debug";
		
		MSMQ::IMSMQQueuePtr DestqinfoHandle;
		DestqinfoHandle  = qinfo->Open( MQ_SEND_ACCESS,MQ_DENY_NONE );
		MSMQ::IMSMQMessagePtr msg("MSMQ.MSMQMessage");
		msg->Body = pBody;
		msg->Label = pLabel;
		msg->Send (DestqinfoHandle);
	}
	catch(_com_error & ComErr)
	{
		UNREFERENCED_PARAMETER(ComErr);
		MqLog("failed to send InvetigateTimeOut messages \n");
	}
		
}
//----------------------------------------------------------------------------------
// This function search for specific message in the queue with C-API function
// If the message found the function receive the message from the queue
// Input parameters:
// MRetriveParms map that expect those keys:
// mRetriveParms[L"M_Label"] - Message label to search.
// mRetriveParms[L"FormatName"] - Queue format name.
// mRetriveParms[L"CheckForDuplicate"] - this paramter check for duplicate messages
//

	

HRESULT RetrieveMessageFromQueue(map <wstring,wstring> & mRetriveParms )
{
	wstring wcsGuidBody=L"";
	wstring wcsQueueFormatName=L"";

	bool bEnableLookupID = (mRetriveParms[L"DependentClient"] == L"Yes");
	// ULONG uAccessMode;
	cPropVar Rprop(7);

	//
	// Create structure to receive body, label, and message class
	//
	WCHAR wcsBody[MAX_GUID+1]={0},Label[MAX_GUID+1]={0};
	USHORT uiMsgClass=9;
	wcscpy( wcsBody , L"Copy");
	Rprop.AddProp( PROPID_M_LABEL, VT_LPWSTR, Label , MAX_GUID );
	ULONG uTemp=MAX_GUID;
	Rprop.AddProp( PROPID_M_LABEL_LEN , VT_UI4,&uTemp );
	Rprop.AddProp( PROPID_M_CLASS , VT_UI2,&uiMsgClass );
	Rprop.AddProp( PROPID_M_BODY_SIZE , VT_UI4, &uiMsgClass );
	if( mRetriveParms[L"TransBaoundery"] != L"" )
	{
		Rprop.AddProp( PROPID_M_FIRST_IN_XACT , VT_UI1, &uiMsgClass );
		Rprop.AddProp( PROPID_M_LAST_IN_XACT , VT_UI1, &uiMsgClass );
	}
	if( bEnableLookupID == false && mRetriveParms[L"MessageID"] != L"" )
	{
		ULONGLONG ululTemp;
		Rprop.AddProp( PROPID_M_LOOKUPID , VT_UI8, &ululTemp );
	}
	if( g_bDebug )
	{
		//
		// Print Debug Information with all the input paramters
		//
		wcout << L"RetrieveMessageFromQueue gets these parameters:"
		<< mRetriveParms[L"FormatName"] <<endl << L"message label = " << mRetriveParms[L"M_Label"] <<endl;
	}

	//
	// Retrieve expected results from the map ..
	//

	//
	// Which message are we looking for? We need to resolve the
	// format name of the message to GUID it's label will hold.
	//
	wcsGuidBody=mRetriveParms[L"M_Label"];
	wcsQueueFormatName=mRetriveParms[L"FormatName"];


	//
	// If ack requested, what is expected? ACK or NACK?
	//
	USHORT uTemp1=0;
	USHORT uExpectedMessageClass=0;
	if (mRetriveParms[L"MClass"] != L"" )
	{
		wstring wcsTemp = mRetriveParms [L"MClass"];
		if ( _snwscanf (wcsTemp.c_str(), wcsTemp.length(), L"%d", &uExpectedMessageClass ) == EOF  )
		{
			MqLog("RetrieveMessageFromQueue: Internal error -  ACK type not found\n");
			return MQ_ERROR;
		}
		Rprop.AddProp( PROPID_M_CLASS , VT_UI2 , &uTemp1 );
	}

	//
	// if this is an admin queue set appropriate access
	//
	DWORD dwAccess = MQ_RECEIVE_ACCESS | MQ_PEEK_ACCESS;
	if (mRetriveParms[L"Access"] == L"admin" )
		dwAccess |= MQ_ADMIN_ACCESS;

	//
	// Peek through all the queue message. Look for message
	// with desired GUID label
	//

	HANDLE hQueue = NULL;
	HRESULT rc=MQOpenQueue( wcsQueueFormatName.c_str(), dwAccess, MQ_DENY_NONE, &hQueue );
	if( g_bDebug || hQueue == NULL )
	{
		if (hQueue == NULL)
		{
			wMqLog(L"\n%s - MqOpenQueue failed on queue:%s\n",mRetriveParms[L"DebugInformation"].c_str(),wcsQueueFormatName.c_str());
		}
		wMqLog(L"\nCall-> MQOpenQueue( %s, MQ_RECEIVE_ACCESS , MQ_DENY_NONE)\n",wcsQueueFormatName.c_str());
	}
	ErrHandle(rc,MQ_OK,L"MQOpenQueue Failed");
	
	HANDLE hCursor=NULL;
	rc = MQCreateCursor( hQueue,&hCursor );
	if( g_bDebug || hQueue == NULL )
	{
		if (hQueue == NULL)
		{
			wMqLog(L"%s - MqCreateCursor failed on queue:%s\n",mRetriveParms[L"DebugInformation"].c_str(),wcsQueueFormatName.c_str());
		}
		MqLog("Call->MQCreateCursor( hQueue,&hCursor )\n");
	}
	ErrHandle(rc,MQ_OK,L"MQCreateCursor Failed");
	
	DWORD dwReceiveTimeOut = g_dwRxTimeOut;
	BOOL bCheckForDuplicate=FALSE;
	if( mRetriveParms[L"CheckForDuplicate"] == L"CheckForDuplicate" )
	{
		bCheckForDuplicate=TRUE;
		dwReceiveTimeOut = 0;
	}
	bool bMessageFound = FALSE;
	DWORD  dwAction=MQ_ACTION_PEEK_CURRENT;
	if( g_bDebug )
	{
		MqLog("Search for message in queue using Cursor and Peek operation \n");
	}


	while( rc != MQ_ERROR_IO_TIMEOUT )
	{
		rc = MQReceiveMessage( hQueue , dwReceiveTimeOut , dwAction , Rprop.GetMSGPRops() , NULL , NULL , hCursor  ,NULL);
		if( !bCheckForDuplicate  )
		{
			if (FAILED(rc))
			{
				wMqLog(L"%s - Peek operation failed on queue:%s.\n",mRetriveParms[L"DebugInformation"].c_str(),wcsQueueFormatName.c_str());
				wMqLog(L"Looking for Message label:%s \n",wcsGuidBody.c_str());
			}

			if( rc == MQ_ERROR_IO_TIMEOUT )
			{
				InvetigateTimeOut(wcsQueueFormatName.c_str(),wcsGuidBody.c_str());
			}
			ErrHandle(rc,MQ_OK,L"MQReceiveMessage failed with peek operation ");			
		}
		else // bCheckForDuplicate == TRUE
		{
			//
			// Expected MQ_ERROR_IO_TIMEOUT because all the messages has been received.
			// 
			if( rc != MQ_ERROR_IO_TIMEOUT ) 
			{
				if( rc == MQ_OK && ! wcscmp( Label , wcsGuidBody.c_str()))
				{
					wMqLog(L"%s - Found duplicate message when peeking queue:%s.\nMessage label:%s\n",mRetriveParms[L"DebugInformation"].c_str(),wcsQueueFormatName.c_str());
					wMqLog(L"Message label:%s\n",wcsGuidBody.c_str());
					wMqLog (L"Found duplicate message. test failed \n");
					return MSMQ_BVT_FAILED;
				}
				else if( FAILED(rc) )
				{
					wMqLog(L"%s - Error when peeking queue:%s.\n",mRetriveParms[L"DebugInformation"].c_str(),wcsQueueFormatName.c_str());
					wMqLog(L"Looking for message label:%s\n",wcsGuidBody.c_str());
					wMqLog(L"RetrieveMessageFromQueue: Unexpected error code 0x%x\n", rc);
				}
				dwAction = MQ_ACTION_PEEK_NEXT;
				uTemp = MAX_GUID;
				Rprop.AddProp(PROPID_M_LABEL_LEN,VT_UI4,&uTemp);
				continue;
			}
			else // rc == MQ_ERROR_IO_TIMEOUT 
			{
				return MSMQ_BVT_SUCC;
			}
		}

		uTemp = MAX_GUID;
		Rprop.AddProp(PROPID_M_LABEL_LEN,VT_UI4,&uTemp );
		dwAction=MQ_ACTION_PEEK_NEXT;
		Rprop.AddProp( PROPID_M_BODY , VT_UI1|VT_VECTOR , wcsBody , MAX_GUID);		
		if(!wcscmp( Label , wcsGuidBody.c_str()))
		{
			bMessageFound = TRUE;
			//
			// Found it. Receive the message (destructively) from the queue.
			//
			dwAction=MQ_ACTION_RECEIVE;
			if (mRetriveParms[L"MessageID"] != L"")
			{
				dwAction=MQ_ACTION_PEEK_CURRENT;
			}
			if(g_bDebug)
			{
				MqLog("Found message in queue call to MQReceiveMessage to remove the message\n");
			}
			rc = MQReceiveMessage( hQueue , dwReceiveTimeOut , dwAction, Rprop.GetMSGPRops() , NULL , NULL , hCursor , NULL);
			if (FAILED(rc))
			{
				wMqLog(L"%s - Error when receiving message from queue:%s.\n",mRetriveParms[L"DebugInformation"].c_str(),wcsQueueFormatName.c_str());
				wMqLog(L"Message label:%s\n",wcsGuidBody.c_str());
			}

			if( rc == MQ_ERROR_IO_TIMEOUT )
			{
				InvetigateTimeOut(wcsQueueFormatName.c_str(),wcsGuidBody.c_str());
			}
			ErrHandle(rc,MQ_OK,L"MQReceiveMessage failed with peek ");
			
			break;
		}

	}
	wstring wcsBodyAsString=L"";
	if( bMessageFound == TRUE )
	{
		ULONG ulBodyLength = 0;
		Rprop.ReturnMSGValue( PROPID_M_BODY_SIZE , VT_UI4 , &ulBodyLength);
		wcsBody[ulBodyLength/sizeof(WCHAR)]= '\0';
		//
		// Check the message class. If it is a regular message,
		// then confirm that the body is equal to the label.
		//
		Rprop.ReturnMSGValue( PROPID_M_CLASS , VT_UI2 , &uiMsgClass );
		wcsBodyAsString = wcsBody;	
	}
	
	//
	// Check Message body for regular messages
	//
	if( bMessageFound == TRUE && uiMsgClass  == MQMSG_CLASS_NORMAL && mRetriveParms[L"TransBaoundery"] == L"" )
	{
		if(  wcsBodyAsString != wcsGuidBody )
		{
			wMqLog(L"%s - Error when receiving message from queue:%s.\n",mRetriveParms[L"DebugInformation"].c_str(),wcsQueueFormatName.c_str());
			wMqLog(L"Message label:%s\n",wcsGuidBody.c_str());
			MqLog("Message found without expected body ");
			wMqLog(L"Found:%s slen:%d\n",wcsBodyAsString.c_str(),wcsBodyAsString.length());
			wMqLog(L"Expected: %s slen:%d\n",wcsGuidBody.c_str(),wcsGuidBody.length());
			bMessageFound = FALSE; 		
		}
	}
	else if ( uiMsgClass  != MQMSG_CLASS_NORMAL )
			{
				if ( uiMsgClass != uExpectedMessageClass )
				{
					wMqLog(L"%s - Error when receiving message from queue:%s.\n",mRetriveParms[L"DebugInformation"].c_str(),wcsQueueFormatName.c_str());
					wMqLog(L"Message label:%s\n",wcsGuidBody.c_str());
					wMqLog (L"Expected to find class %x , found %x \n", uExpectedMessageClass , uiMsgClass );
					bMessageFound = FALSE; 		
				}
					
			}
	//
	// Translate message ID to String
	//
	
	if ( bEnableLookupID == false && mRetriveParms[L"MessageID"] != L"" )
	{
		ULONGLONG ulLookupID;
		Rprop.ReturnMSGValue( PROPID_M_LOOKUPID , VT_UI8 , &ulLookupID );
		WCHAR buffer[100];
		swprintf(buffer,L"%I64d",ulLookupID);
		mRetriveParms[L"MessageID"] = buffer;
	}
	//
	// Add Transaction baundery tests
	//

	if( mRetriveParms[L"TransBaoundery"] != L"" )
	{
		// 1. Need to check if this is the first message
		UCHAR ucFirstMessage , ucLastMessage;
		Rprop.ReturnMSGValue( PROPID_M_FIRST_IN_XACT , VT_UI1 , &ucFirstMessage );
		Rprop.ReturnMSGValue( PROPID_M_LAST_IN_XACT , VT_UI1 , &ucLastMessage );
		if( ucFirstMessage != 0 )
		{
			mRetriveParms[L"TransBoundary"] = L"First";
		}
		else if( ucLastMessage != 0)
		{
			mRetriveParms[L"TransBoundary"] = L"Last";
		}
		else
		{
			mRetriveParms[L"TransBoundary"]=g_wcsEmptyString;
		}
		mRetriveParms[L"mBody"]=wcsBodyAsString;
	}
	rc = MQCloseCursor( hCursor );
	ErrHandle(rc,MQ_OK,L"MQCloseCursor Failed");
	rc=MQCloseQueue( hQueue );
	ErrHandle( rc , MQ_OK , L"MQCloseQueue Failed");
	return( bMessageFound ==  TRUE ) ? MSMQ_BVT_SUCC : MSMQ_BVT_FAILED;
	
}



void CRemotePeek::Description()
/*++
	Function Description:
	Arguments:
		
	Return code:
		MSMQ_BVT_FAILED / MSMQ_BVT_SUCC
--*/

{
	wMqLog(L"Thread %d : Peek http message remotly\n", m_testid);
}


CRemotePeek::CRemotePeek():
 m_cwcsPeekBody(L"--Bom--"),
 m_cwcsPeekLabel(L"=~-Tic"),
 m_cwcsFormatName(L"direct=https://MightBeBuginNT4\\MSMQ\\Private$\\qaqq"),
 m_cwcsQueueName(L"-PeekMe-PeekMe-Remotly")
 /*++
	Function Description: 
		This class verifies the scenario of sending HTTP messages and retrieves them remotely using direct=os: format name, currently disabled due bug # 579380	
		
	Arguments:
		None
	Return code:
		None
--*/

{
	if ( Prepare() != MQ_OK )
	{
		throw INIT_Error("CRemotePeek::CRemotePeek failed to prepare message in queue\n");
	}
}

CRemotePeek::CRemotePeek (INT iTid , map <wstring,wstring> Params )
/*++
	Function Description:
	   Constructor for init const members
	Arguments:
		none
	Return code:
		none
--*/
:cTest( iTid ),
 m_cwcsPeekBody(L"--Bom--"),
 m_cwcsPeekLabel(L"=~-Tic"),
 m_cwcsFormatName(L"direct=https://MightBeBuginNT4\\MSMQ\\Private$\\qaqq"),
 m_cwcsQueueName(L"-PeekMe-PeekMe-Remotly"),
 m_bDepenetClient(false)
{

	m_RemoteMachineName = Params[L"RemoteMachineName"];
	if ( Params[L"DependentClient"] == L"Yes" )
	{
		m_bDepenetClient = true;
	}
}

INT CRemotePeek::Prepare()
/*++
	Function Description:
		Send message to local queue using http format name.
	Arguments:
		None
	Return code:
		MSMQ_BVT_FAILED / MSMQ_BVT_SUCC
--*/

{
	wstring wcsTempFormatName = L"direct=https://localhost\\msmq\\private$\\-PeekMe-PeekMe-Remotly";

	cPropVar cMsgProp(12);
	cMsgProp.AddProp( PROPID_M_BODY , VT_UI1|VT_VECTOR , m_cwcsPeekLabel.c_str());
	cMsgProp.AddProp( PROPID_M_LABEL , VT_LPWSTR ,m_cwcsPeekLabel.c_str() );
	
	UCHAR tempValue = MQMSG_DELIVERY_RECOVERABLE;
	cMsgProp.AddProp( PROPID_M_DELIVERY , VT_UI1 , &tempValue );
	
	UCHAR uCh = 1;
	cMsgProp.AddProp( PROPID_M_PRIORITY , VT_UI1 ,&uCh );
	
	UCHAR uCh1 = 1;
	cMsgProp.AddProp( PROPID_M_JOURNAL , VT_UI1 , &uCh1 );
	
	ULONG ulVal=0xffffff;
	cMsgProp.AddProp( PROPID_M_APPSPECIFIC , VT_UI4  ,&ulVal );
	
	cMsgProp.AddProp( PROPID_M_ADMIN_QUEUE , VT_LPWSTR , m_cwcsFormatName.c_str() );
	cMsgProp.AddProp( PROPID_M_RESP_QUEUE , VT_LPWSTR , m_cwcsFormatName.c_str() );
	
	UCHAR uCh2 = 1;
	cMsgProp.AddProp( PROPID_M_TRACE  , VT_UI1 ,  &uCh2 );
	
	HANDLE QueueuHandle=NULL;
	HRESULT hr = MQOpenQueue( wcsTempFormatName.c_str() , MQ_SEND_ACCESS , MQ_DENY_NONE , &QueueuHandle );
	ErrHandle(hr,MQ_OK,L"CRemotePeek::Prepare - MQOpenQueue Failed");
	if( g_bDebug )
	{
		wMqLog(L"CRemotePeek - MQOpenQueue succeded to open %s\n", wcsTempFormatName.c_str());
	}
	hr = MQSendMessage( QueueuHandle , cMsgProp.GetMSGPRops() , NULL);
	ErrHandle(hr,MQ_OK,L"CRemotePeek::Prepare - MQSendMessage (1) Failed");
	if( g_bDebug )
	{
		wMqLog(L"CRemotePeek::Prepare - MQSendMessage succeded to open %s\n", wcsTempFormatName.c_str());
	}
	hr = MQCloseQueue(QueueuHandle);
	ErrHandle(hr,MQ_OK,L"CRemotePeek::Prepare - MQCloseQueue  Failed");
	return MQ_OK;
}



INT CRemotePeek::Start_test()
/*++
	Function Description:
		
	Arguments:
		None
	Return code:
		return MQ_OK;
--*/
{

	return MSMQ_BVT_SUCC;
}

INT CRemotePeek::CheckResult()
/*++
	Function Description:
		This function retrive the message from the remote queue.
	Arguments:
		
	Return code:
		MSMQ_BVT_FAILED / MSMQ_BVT_SUCC
--*/

{

	map <wstring,wstring> mPrepareBeforeRecive;
	mPrepareBeforeRecive[L"M_Label"] = m_cwcsPeekLabel;
	
	//
	// Check the admin messages for Ack/Nack.
	//
	
	wstring wcsDestQueueFormatName = L"direct=os:";
	wcsDestQueueFormatName += m_RemoteMachineName;
	wcsDestQueueFormatName += L"\\private$\\";
	wcsDestQueueFormatName += m_cwcsQueueName;

	mPrepareBeforeRecive[L"FormatName"] = wcsDestQueueFormatName;
	mPrepareBeforeRecive[L"DebugInformation"] = L"CRemotePeek::CheckResult peek message from remote queue";
	mPrepareBeforeRecive[L"MessageID"] = L"LeaveMsgInQueue";
	if( g_bDebug)
	{
		MqLog("CRemotePeek::CheckResult try to peek message from remote queue\n");
	}
	if( m_bDepenetClient == true )
	{
		mPrepareBeforeRecive[L"DependentClient"] = L"Yes";
	}
	HRESULT rc = RetrieveMessageFromQueue(  mPrepareBeforeRecive );
	if( rc !=  MSMQ_BVT_SUCC )
	{
		return MSMQ_BVT_FAILED;	
	}
		
	return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\util.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: Util.cpp

Abstract:
	
	  Common function for msmq tests.
	  
Author:

    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/


#include "msmqbvt.h"
#include "ntlog.h"
#include <iads.h>
#include <adshlp.h>
#ifdef _MSMQ3ONLY
#include "util.tmh"
#endif // _MSMQ3ONLY
#pragma warning(disable:4786)
using namespace std;
const DWORD g_dwDefaultLogFlags = TLS_INFO | TLS_SEV1 | TLS_SEV2 | TLS_SEV3 | TLS_WARN | TLS_PASS | TLS_VARIATION | TLS_REFRESH | TLS_TEST;
extern P<cMqNTLog> pNTLogFile;

static CCriticalSection g_pCs;
//-----------------------------------------------------------------------------------
// TimeOutThread - Kill the Test after time out period.
// This thread kill the test there is no need to return value from the tests.
//


DWORD __stdcall TimeOutThread(void * iTimeOut)
{	
	INT SleepTime = PtrToInt(iTimeOut);
    Sleep( SleepTime );
	MqLog("Test cancelled by time restriction after %d sec.\n", SleepTime );
    abort();  // Return error code = 3 
}



//------------------------------------------------------------------
// QueuesInfo::del_all_queue
// Delete all the in the list
//
// return value:
// pass - MSMQ_BVT_SUCC.
// fail - MSMQ_BVT_FAILED.
//


INT QueuesInfo::del_all_queue()
{
	std::list <my_Qinfo> :: iterator itQp;
	wstring wcsDeleteQueueFormatName;
	for ( itQp = m_listofQueues.begin(); itQp != m_listofQueues.end(); itQp ++ )
	{
		wcsDeleteQueueFormatName  = itQp->GetQFormatName();
		if ( g_bDebug )
		{
			wcout << L"Delete queue pathname:" << itQp->GetQPathName() <<endl;
		}
		if( itQp->GetQPathName () == g_cwcsDebugQueuePathName)
		{
			continue;
		}
		HRESULT rc = MQDeleteQueue( wcsDeleteQueueFormatName.c_str() );
		if ( rc != MQ_OK && rc != MQ_ERROR_QUEUE_NOT_FOUND )
		{
			ErrHandle ( rc,MQ_OK,L"MQDelete queue failed");
		}
		
	}

 return MSMQ_BVT_SUCC;
}
//------------------------------------------------------------------------------
// QueuesInfo::ReturnQueueProp 
// This function return specific prorperty form the queues list
//
// input parmeters:
// 
// return value:
//

wstring QueuesInfo::ReturnQueueProp( wstring wcsQLabel , int iValue  )
{
	
	BOOL bFound=FALSE;
	
	for ( list <my_Qinfo> :: iterator itQp = m_listofQueues.begin() ; itQp != m_listofQueues.end() ;	itQp ++ )
	{
		if (itQp->GetQLabelName() == wcsQLabel )
		{
			bFound=TRUE;
			break;
		}
	}

	if ( bFound && iValue == 1 )
	{
		return itQp->GetQFormatName();
	}
	else if ( bFound && iValue == 2 )
	{
		return itQp->GetQPathName();
	}
	//
	// Not found the return empty string 
	//
	return g_wcsEmptyString;
}



bool operator == (my_Qinfo objA, my_Qinfo objB )
{
	return  objA.wcsQpathName == objB.wcsQpathName  ? TRUE : FALSE;
}

bool operator != (my_Qinfo objA, my_Qinfo objB )
{
	return !( objA==objB);
}


//
// Declare the operator no current need to declare only because list ask that
// use for sort, is not relevant to queues parameters
//
 
bool operator < (my_Qinfo objA, my_Qinfo objB )
{
	return TRUE;
}

bool operator > (my_Qinfo objA, my_Qinfo objB )
{
	return ! (objA < objB);
}



int QueuesInfo::UpdateQueue (wstring wcsQPathName,wstring wcsQFormatName,wstring wcsQueueLabel)
{
	// Serech if this queue exist in the list
	list <my_Qinfo> :: iterator itp;
	bool bFound = FALSE ; 
	for (itp=m_listofQueues.begin ();itp != m_listofQueues.end () && ! bFound ; itp ++)
	{
		wstring wcsTempQname =(*itp).GetQPathName();
		if ( wcsTempQname == wcsQPathName )
			bFound = TRUE;
	}
	
	if (! bFound )
	{ // Update list queue not found in the list
		my_Qinfo Temp (wcsQPathName,wcsQFormatName,wcsQueueLabel);
		m_listofQueues.push_back(Temp);
	}
	
	 // Does not need to update Queue is exist in the 
	return MSMQ_BVT_SUCC; 
}

void QueuesInfo::dbg_printAllQueueProp ()
{
	std::list <my_Qinfo> ::iterator itp;
	for (itp= m_listofQueues.begin(); itp != m_listofQueues.end(); itp ++)
	{
		itp ->dbg_printQueueProp();
	}

}

my_Qinfo::my_Qinfo(const my_Qinfo & cObject):
wcsQpathName(cObject.wcsQpathName), wcsQFormatName(cObject.wcsQFormatName),wcsQLabel(cObject.wcsQLabel)
{}

my_Qinfo::my_Qinfo(std::wstring wcsPathName , std::wstring wcsFormatName , std::wstring wcsLabel ):
wcsQpathName(wcsPathName), wcsQFormatName(wcsFormatName),wcsQLabel(wcsLabel)
{}

void my_Qinfo::dbg_printQueueProp ()
{
	wcout<< L"PathL:" << wcsQpathName << L"\n" << L"FName:" << wcsQFormatName <<endl;
}

//----------------------------------------------------------------------
// Check if MQOA is registered use Idispatch interface for interface.
// If mqoa exist and not registered ( regsvr32 ) this function will failed
//


void isOARegistered::Description()
{
  MqLog("Thread %d : Check if MQOA is registered \n",m_testid);
}

HRESULT CheckIfMQOARegister()
/*++
	Function Description:
		function check if mqoa.dll is register on the machine by trying to get IDispInterface 
	Arguments:
		None.
	Return code:	
		HRESULT;  
--*/
{
	try
	{
		IDispatchPtr QueueInfoID("MSMQ.MSMQQueueInfo");
		OLECHAR FAR* szMember = L"PathName";
		DISPID dispid = 0;
		return	QueueInfoID->GetIDsOfNames(IID_NULL,
										   &szMember,
										   1, 
										   LOCALE_SYSTEM_DEFAULT,
										   &dispid
										  );
	}
	catch(_com_error & comerr) 
	{
		return  comerr.Error();
	}
}
INT isOARegistered :: Start_test()
{
		 //
		 // In VB user can do those thinks.
		 // Dim x as Object
		 // x = new MSMQQueueInfo
		 // This is the IDispatch Interface 
		 // Check this interface exist ask the number of method example PathName
		 //
		SetThreadName(-1,"isOARegistered - Start_test ");			

		if ( g_bDebug )
		{
			MqLog ("Check Idispatch pointer for msmq com objects\n");
		}
		HRESULT hr = CheckIfMQOARegister();
		if ( hr != S_OK )
		{
			MqLog("Mqoa.dll is not registered !\n");
			return MSMQ_BVT_FAILED;
		}

	return MSMQ_BVT_SUCC;
}


//------------------------------------------------------------------------
// Log file class use to log tests information to file 
//
 


std::string GetLogDirectory()
/*++
	Function Description:
		GetLogDirectory - Retrive %windir%\debug path.
	Arguments:
		None
	Return code:
		Directory name.
--*/
{
	CHAR csSystemDir[MAX_PATH+1];
	UINT dwSysteDirBefferLen=MAX_PATH;
	string csLogPathName="";
	
	DWORD hr = GetSystemDirectory( csSystemDir,dwSysteDirBefferLen);
	if ( hr > 0 )
	{
		csLogPathName = csSystemDir;
		string csToken = "\\";
		size_t iPos = csLogPathName.find_last_of (csToken);	
		csLogPathName = csLogPathName.substr(0,iPos);
		csLogPathName +="\\Debug";
	}
	return csLogPathName;
}
	
Log::~Log()
{
		if(m_bCanWriteToFile)
		{
			CloseHandle( hLogFileHandle);
		}
}

Log::Log( wstring wcsLogFileName ) : hLogFileHandle(NULL) 
{
	
		m_bCanWriteToFile = FALSE;
		
		// 
		// Retrive syetem directroy 
		//

		WCHAR wcsSystemDir[MAX_PATH+1];
		UINT dwSysteDirBefferLen=MAX_PATH;
		wstring wcsLogPathName;
		
		DWORD hr = GetSystemDirectoryW( wcsSystemDir,dwSysteDirBefferLen);
		if ( hr > 0 )
		{
			wcsLogPathName = wcsSystemDir;
			wstring wcsToken=L"\\";
			size_t iPos = wcsLogPathName.find_last_of (wcsToken);	
			wcsLogPathName = wcsLogPathName.substr(0,iPos);
			wcsLogPathName+=L"\\Debug";
		}
		
		
		// change drive to %widir%\debug\. 
		
		

		BOOL fSucc = SetCurrentDirectoryW(wcsLogPathName.c_str());
		
		if ( ! fSucc )
		{
			// Retrive the temp directory 
			WCHAR wcsEnvName[]=L"Temp";
			WCHAR wcsTempDir[MAX_PATH + 1];
			DWORD dwTempDirBufLen = MAX_PATH;
			GetEnvironmentVariableW( wcsEnvName, wcsTempDir , dwTempDirBufLen );
			wcsLogPathName=wcsTempDir;
			fSucc = SetCurrentDirectoryW( wcsLogPathName.c_str() );
			if ( ! fSucc )
			{
				MqLog("Mqbvt will create the log in the current directory\n");
			}
			
		}
		
		//
		// Create the log file 
		//
		
		// wstring wcsLogFileName = L"Mqbvt.log";
		
		hLogFileHandle = CreateFileW(wcsLogFileName.c_str(),GENERIC_WRITE,FILE_SHARE_READ,NULL,
			CREATE_ALWAYS,FILE_ATTRIBUTE_ARCHIVE,NULL);

		if (hLogFileHandle != INVALID_HANDLE_VALUE )
		{
			m_bCanWriteToFile = TRUE;	

			//
			// Write to file tests title
			//

			wstring Title = L"Mqbvtlog file start at:";
			WriteToFile ( Title );
		}
		//
		// Else is not need because log file is optional.
		// 
		
		
}

Log::WriteToFile ( wstring wcsLine )
{
	if ( m_bCanWriteToFile ) 
	{
		CS Lock(m_Cs);
		string csLine;
		// Need to convert wstring to string ..
		csLine = My_WideTOmbString (wcsLine);
		
		DWORD dwWrittenSize = 0;
		char cNewline[]= { 0xD , 0xA , 0 };
		/*cNewline[1]=10;
		cNewline[2]=0; */
		WriteFile( hLogFileHandle , csLine.c_str() , (DWORD)(strlen(csLine.c_str())), &dwWrittenSize , NULL);
		WriteFile( hLogFileHandle , cNewline , (DWORD)(strlen (cNewline)) , &dwWrittenSize,NULL);
		FlushFileBuffers( hLogFileHandle ); 

	}
	return MSMQ_BVT_SUCC;	
}



//#define MAXCOMMENT 200
void
MqLog(LPCSTR lpszFormat, ...)
{
    CHAR  szLogStr[MAXCOMMENT] = "";
    va_list  pArgs;
	int nCount = 0;
	wstring wcsTemp;

    va_start(pArgs, lpszFormat);
    nCount = _vsnprintf(szLogStr, MAXCOMMENT, lpszFormat, pArgs);
	szLogStr[MAXCOMMENT-1] = 0;
    va_end(pArgs);
	if( pNTLogFile )
	{
		pNTLogFile->LogIt(szLogStr);
	}
	wcsTemp = My_mbToWideChar( szLogStr );
	if( pGlobalLog != NULL )
	{
		pGlobalLog->WriteToFile( wcsTemp.c_str() );
	}
	CS Lock(g_pCs);
	printf ("%s",szLogStr);

}

void
MqLogErr(LPCSTR lpszFormat, ...)
{
    CHAR  szLogStr[MAXCOMMENT] = "";
    va_list  pArgs;
	int nCount = 0;
	wstring wcsTemp;

    va_start(pArgs, lpszFormat);
    nCount = _vsnprintf(szLogStr, MAXCOMMENT, lpszFormat, pArgs);
	szLogStr[MAXCOMMENT-1] = 0;
    va_end(pArgs);
	if( pNTLogFile )
	{
		pNTLogFile->LogIt(szLogStr);
	}
	wcsTemp = My_mbToWideChar( szLogStr );
	if( pGlobalLog != NULL )
	{
		pGlobalLog->WriteToFile( wcsTemp.c_str() );
	}
	CS Lock(g_pCs);
	fprintf (stderr,"%s",szLogStr);
#ifdef _MSMQ3ONLY
	TrERROR(GENERAL, "%s",szLogStr);
#endif //_MSMQ3ONLY
}

void
wMqLog(LPWSTR lpszFormat, ...)
{
    WCHAR  wszLogStr[MAXCOMMENT] = L"";
    va_list  pArgs;
	int nCount =0;
	
	std::string csTemp="";

    va_start(pArgs, lpszFormat);
    nCount = _vsnwprintf(wszLogStr, MAXCOMMENT, lpszFormat, pArgs);
	wszLogStr[MAXCOMMENT-1] = 0;
    va_end(pArgs);
	pGlobalLog->WriteToFile( wszLogStr );
	csTemp = My_WideTOmbString(wszLogStr);
	if( pNTLogFile )
	{
		pNTLogFile->LogIt(csTemp);
	}
	CS Lock(g_pCs);
	wprintf (L"%s",wszLogStr);

}

void
wMqLogErr(LPWSTR lpszFormat, ...)
{
    WCHAR  wszLogStr[MAXCOMMENT] = L"";
    va_list  pArgs;
	int nCount =0;
	
	std::string csTemp="";

    va_start(pArgs, lpszFormat);
    nCount = _vsnwprintf(wszLogStr, MAXCOMMENT, lpszFormat, pArgs);
	wszLogStr[MAXCOMMENT-1] = 0;
    va_end(pArgs);
	pGlobalLog->WriteToFile( wszLogStr );
	csTemp = My_WideTOmbString(wszLogStr);
	if( pNTLogFile )
	{
		pNTLogFile->LogIt(csTemp);
	}

	//
	// Added this line so that we can see it in the UT runner logs.
	// This should be removed after Danny fixes the synchronization
	//
	wMqLog (L"%s\n",wszLogStr);


	fwprintf (stderr,L"%s",wszLogStr);

}

/**************************************************************
	this code was copied from mpllib 
 **************************************************************/

cMqNTLog::cMqNTLog( const string & csFileName )
:m_NTLog(NULL),
 m_ptlEndVariation(NULL),
 m_pCreateLog_A(NULL),
 m_ptlLog_A(NULL),
 m_ptlReportStats(NULL),
 m_ptlAddParticipant(NULL),
 m_ptlDestroyLog(NULL)
 
/*++
	Function Description:
		cMqNTLog constructor load NT Log DLL and GetProcAddress
	Arguments:
		csFileName file name
	Return code:
		throw INIT_ERROR when failed

--*/
{
	
	//
	// Load NTLOG.DLL
	//
	m_NTLog = new AutoFreeLib("NTLog.dll");
	if( m_NTLog == NULL )
	{
		throw INIT_Error("MqBVT: Failed to initilize NTLOG.DLL !\n BVT will continue to run and log to stdout");
	}
	//
	// Init function pointers
	//

	m_pCreateLog_A =(tlCreateLog_A) GetProcAddress( m_NTLog->GetHandle() ,"tlCreateLog_A");
	m_ptlAddParticipant = (tlAddParticipant) GetProcAddress(m_NTLog->GetHandle() ,"tlAddParticipant");
	m_ptlEndVariation = (tlEndVariation) GetProcAddress(m_NTLog->GetHandle() ,"tlEndVariation");
	m_ptlLog_A = (tlLog_A) GetProcAddress(m_NTLog->GetHandle() ,"tlLog_A");
	m_ptlReportStats = (tlReportStats)GetProcAddress(m_NTLog->GetHandle() ,"tlReportStats");
	m_ptlStartVariation = (tlStartVariation)GetProcAddress(m_NTLog->GetHandle() ,"tlStartVariation");
	m_ptlDestroyLog=(tlDestroyLog)GetProcAddress(m_NTLog->GetHandle() ,"tlDestroyLog");
	
	if( !( m_pCreateLog_A && m_ptlAddParticipant && m_ptlEndVariation && m_ptlLog_A && 
		   m_ptlReportStats &&	m_ptlStartVariation && m_ptlDestroyLog ) )
	{
		throw INIT_Error("MqBVT: Failed to initilize NTLOG.DLL !\n BVT will continue to run and log to stdout");
	}
	
	if ( !CreateLog(const_cast<char*> (csFileName.c_str())) )
	{
		throw INIT_Error("Mqbvt:Can't create new log file\n");
	}
	Info("%s", GetCommandLineA());	
	BeginCase("run Mqbvt ");

}


BOOL
cMqNTLog::BeginCase( char* szVariation )
/*++
	Function Description:
		Begin NTLog case
	Arguments:
		szVariation - Case name
	Return code:
		TRUE/FALSE
--*/

{
       
    if( m_ptlStartVariation( m_hLog ) )
    {
		m_szVariation = szVariation;
        return TRUE;
    }
    return FALSE;
}




BOOL
cMqNTLog::EndCase( )
/*++
	Function Description:
		Close NTLog case test
	Arguments:
		None
	Return code:
		TRUE/FALSE
--*/

{
    DWORD dwVariation;
    BOOL fResult;

    dwVariation = m_ptlEndVariation( m_hLog );

    fResult = m_ptlLog_A(
							m_hLog,
							dwVariation | TL_VARIATION,
							"End variation %s",
							m_szVariation
							);

    return fResult;
}

BOOL cMqNTLog::CreateLog( char *szLogFile )
/*++
	Function Description:
		Create Log file in NTLog format
	Arguments:
		szLogFile - log file name.
	Return code:
		True/false
--*/

{

    int nMachineId = 33; // BUGBUG - should be calculated
    m_hLog = m_pCreateLog_A( szLogFile, g_dwDefaultLogFlags );
    if( m_hLog == NULL )
	{
        return FALSE;
	}
	return m_ptlAddParticipant( m_hLog, NULL, nMachineId );
}


#define LOGFUNC(name,dw)                                        \
BOOL __cdecl cMqNTLog::name( char* fmt, ... ) {                 \
    BOOL fResult;                                               \
    va_list arglist;                                            \
                                                                \
    va_start( arglist, fmt );                                   \
    fResult = VLog( dw | TLS_VARIATION, fmt, arglist );         \
    va_end( arglist );                                          \
    return fResult;                                             \
}

char g_String[ MAXCOMMENT + 1  ];
static char* l_szSource = "n/a";
BOOL
cMqNTLog::VLog( DWORD dwFlags, char* fmt, va_list arglist )
/*++
	Function Description:

	Arguments:
		
	Return code:
		TRUE/FALSE

--*/

{

    
	_vsnprintf( g_String, MAXCOMMENT ,fmt, arglist );
	g_String[MAXCOMMENT-1] = 0;
    return m_ptlLog_A(
						m_hLog,
						dwFlags, 
						l_szSource,
						0,
						"%s",
						g_String
					  );
}

void
cMqNTLog::Report( )
/*++
	Function Description:
		Report 
	Arguments:
		None
	Return code:

--*/
{
    m_ptlReportStats( m_hLog );
}



LOGFUNC(Info,TLS_INFO)
LOGFUNC(Warn,TLS_WARN)
LOGFUNC(Sev1,TLS_SEV1)
LOGFUNC(Pass,TLS_PASS)



void cMqNTLog::LogIt( const std::string & csLine )
/*++
	Function Description:
		print a LogIt to the file
	Arguments:
		None
	Return code:

--*/

{
	Info("%s",csLine.c_str());
}
cMqNTLog::~cMqNTLog () 
/*++
	Function Description:

	Arguments:
		None
	Return code:

--*/

{
	EndCase();
	Report();
	m_ptlDestroyLog(m_hLog);
} 

void cMqNTLog::ReportResult(bool bRes ,CHAR * pcsString )
/*++
	Function Description:
		ReportResult - Report if Mqbvt pass or failed
	Arguments:
		None
	Return code:

--*/
{
	if( pNTLogFile )
	{
		if ( bRes )
		{
			Pass(pcsString);
		}
		else
		{
			Sev1(pcsString);
		}
	}
}



typedef struct tagTHREADNAME_INFO
{
	DWORD dwType;
	LPCSTR szName;
	DWORD dwThreadId;
	DWORD dwFlags;
} THREADNAME_INFO;

void SetThreadName ( int dwThreadId , LPCSTR szThreadName )
/*++
	Function Description:
		SetThreadName - 
		Report the Thread name to the debugger
		This exception si undocumented.
	Arguments:
		None
	Return code:

--*/
{
#ifndef _WIN64
	THREADNAME_INFO info;
	info.dwType = 0x1000;
	info.szName = szThreadName;
	info.dwThreadId = dwThreadId;
	info.dwFlags = 0;
	__try
	{	

		RaiseException( 0x406d1388 , 0 , sizeof(info) / sizeof (DWORD) ,(DWORD*) &info);
	}
	__except(EXCEPTION_CONTINUE_EXECUTION)
	{

	}
#else
	THREADNAME_INFO info;
	UNREFERENCED_PARAMETER(info);
	UNREFERENCED_PARAMETER(dwThreadId);
	UNREFERENCED_PARAMETER(szThreadName);
#endif
}


std::wstring cBvtUtil::CreateHTTPFormatNameFromPathName(const std::wstring & wcsPathName, bool bHTTPS )
/*++	  

	Function Description:

	  CreateHTTPFormatNameFromPathName convert queue path name to HTTP direct direct format name

	Arguments:

		 wcsPathName - Queue PathName
		 bool HTTPS - true return direct=hTTPS://
	Return code:

		wstring contain a queue format name or an empty string if there is an error during parsing
	
--*/

{
	
	//
	// Build DIRECT=HTTP://MachineName\MsMq\QueuePath from Path Name
	//

	std::wstring wcsMachineName = wcsPathName;
	size_t iPos = wcsMachineName.find_first_of(L"\\");
	if(iPos == -1)
	{
		return g_wcsEmptyString;
	}
	wcsMachineName = wcsMachineName.substr(0,iPos);
	std::wstring wcsHTTPFormatName = bHTTPS ?  L"DIRECT=hTTpS://":L"DIRECT=hTTp://";
	if( wcsMachineName != L".")
	{
		wcsHTTPFormatName += wcsMachineName;
	}
	else
	{
	    wcsHTTPFormatName += m_wcsLocalComputerNameFullDNSName;
	}
	wcsHTTPFormatName += (std::wstring)L"/mSmQ/";
	wcsHTTPFormatName += (std::wstring) wcsPathName.substr(iPos+1,wcsPathName.length());
	return wcsHTTPFormatName;
}




HRESULT GetSpecificAttribute(
						  CONST WCHAR * pwcsDsPath,
						  WCHAR * pwcsAttributeName,
						  VARIANT * val
						)
/*++

	Function Description:
		Return attribute of specific DN.
	Arguments:
		None
	Return code:
		None

	
--*/
{

	IADs *pObject=NULL; 

	HRESULT hr = ADsGetObject(pwcsDsPath, IID_IADs, (void**)&pObject);
	if(FAILED(hr))
	{
		return hr;
	}
	hr = pObject->Get(pwcsAttributeName,val);
	pObject->Release();
 	if (FAILED(hr)) 
	{
		val->vt=VT_EMPTY;
	}
	return hr;
}


long GetADSchemaVersion()
{
    IADs * pRoot = NULL;
    HRESULT hr=ADsGetObject( L"LDAP://RootDSE",
							 IID_IADs,
							 (void**) &pRoot
						   );
    if(FAILED(hr)) 
	{ 
		return 0;
	}
	
	VARIANT varDSRoot;
	hr = pRoot->Get(L"schemaNamingContext",&varDSRoot);
	pRoot->Release();
	if ( FAILED(hr))
	{
		return 0;
	}
	wstring m_wcsCurrentDomainName = L"LDAP://";
	m_wcsCurrentDomainName += varDSRoot.bstrVal;
	VariantClear(&varDSRoot);
	GetSpecificAttribute(m_wcsCurrentDomainName.c_str(),L"ObjectVersion",&varDSRoot);
	long dwSchemaVersion = varDSRoot.lVal;
	VariantClear(&varDSRoot);
	return dwSchemaVersion;
}



std::wstring ToLower(std::wstring wcsLowwer)
{

	WCHAR * wcsLocalMachineName = (WCHAR * )malloc (sizeof(WCHAR) * (wcsLowwer.length() + 1 ));
	if( ! wcsLocalMachineName )
	{
		MqLog("Thread 4: Failed to allocate memory\n");
		throw INIT_Error("Thread 4 - failed to allocate memory");
	}
	const WCHAR * p = wcsLowwer.c_str();
	int i=0;
	while( *p )
	{	
		wcsLocalMachineName[i++] = towlower( *p );
		p++;
	}
	
	wcsLocalMachineName[i]=L'\0';
	wstring temp=wcsLocalMachineName;
	free(wcsLocalMachineName);
	return temp;
}


int iDetactEmbededConfiguration ()
/*++
	Function Description:
		Deteact embeded components.
	Arguments:
		None
	Return code:
		int
--*/
{
	if ( CheckIfMQOARegister() == S_OK )
	{
		return COM_API;
	}
	return C_API_ONLY;
}

void RegisterCertificate()
/*++
	Function Description:
		Register certificate if not exist.
		call with -cert or when bvt running under service account.
	Arguments:
		None
	Return code:
		None

	
--*/

{
	HRESULT hr = MQRegisterCertificate(MQCERT_REGISTER_IF_NOT_EXIST,NULL,0);
	if( hr != MQ_INFORMATION_INTERNAL_USER_CERT_EXIST && hr != MQ_OK )
	{
		MqLog("MQRegisterCertificate certificate failed with error 0x%x\n",hr);
		throw INIT_Error("MQRegisterCertificate certificate failed\n");
	}
}


std::string ToStrLower(std::string csMixedChar)
{

	char * csLowerChar = (char*) malloc ( sizeof(char) * (csMixedChar.length() + 1));
	if( ! csLowerChar )
	{
		printf("Failed to allocate memory\n");
		return "";
	}
	
	const char * p = csMixedChar.c_str();
	int i=0;
	while( *p )
	{	
		csLowerChar[i++] = (char) tolower(*p);
		p++;
	}
	csLowerChar[i]='\0';
	std::string temp = csLowerChar;
	free(csLowerChar);
	return temp;
}



HRESULT EnableDCOM()
/*++  
	Function Description:
		Set the key "Interactive User" in registry to enable dcom testing.
	Arguments:
		none
	Return code:
		Success or failure
--*/
{
	HKEY hKey = NULL;
	HRESULT hr =  RegOpenKeyExW(
								HKEY_CLASSES_ROOT,         
								L"AppID\\{DCBCADF5-DB1b-4764-9320-9a5082af1581}", 
								0,   
								KEY_WRITE,
								&hKey
							  );

	ErrHandle(hr,ERROR_SUCCESS,L"DCOM is not configured on the machines");
	
	//
	//	set the key "RunAs" to  "Interactive User"
	//
	char csval[]="Interactive User";
	hr = RegSetValueExA(
		  				hKey,
						"RunAs" ,
						NULL ,
						REG_SZ ,
						(unsigned char*)csval ,
						(int)strlen(csval)
					  );

	ErrHandle(hr,ERROR_SUCCESS,L"RegSetValueEx failed");
	RegCloseKey(hKey);
	return hr;

}


bool RestartService( wstring wcsMachineName , string csServiceName )
/*++  
	Function Description:
		Stop and start any service, To be able and perform this operation 
		user need to have local administrator permession.
	Arguments:
		none
	Return code:
		Success or failure
--*/

{
		if (g_bDebug)
		{
			MqLog ("Restart %s service on local computer\n",csServiceName.c_str());
		}
		SC_HANDLE hSCManager = OpenSCManagerW( wcsMachineName.c_str() , NULL, SC_MANAGER_ALL_ACCESS );
		if ( hSCManager == NULL )
		{
			MqLog("RestartService - failed to open service control maneger \n"); 
			return false;
		}
		SC_HANDLE hService = OpenService( hSCManager, csServiceName.c_str() ,SERVICE_ALL_ACCESS);
		if ( hService == NULL )
		{
			MqLog("RestartService - OpenService failed error=0x%x \n",GetLastError());
			MqLog("RestartService - This error might happened when user is not local administrator \n");
			CloseServiceHandle(hSCManager);
			return false;	
		}
		
		
		//
		// Stop service
		//
		SERVICE_STATUS  ssServiceStatus;
		BOOL bControlState = FALSE;
		int iCounter = 0;
		do 
		{
			bControlState = ControlService( hService, SERVICE_CONTROL_STOP, &ssServiceStatus );
		
			if( iCounter != 0 )
			{
				Sleep(3000);
			}
			iCounter ++;

		} while ( ssServiceStatus.dwCurrentState != SERVICE_STOPPED && iCounter < 5 );
		if ( iCounter >= 5 || ssServiceStatus.dwCurrentState != SERVICE_STOPPED )
		{
			MqLog("Failed to stop %s service \n",csServiceName.c_str());
			CloseServiceHandle(hService);
			CloseServiceHandle(hSCManager);
			return false;
		}
		bool bRetVal = true;
		//
		// Start service
		// 		
		bControlState = StartService( hService, 0,NULL);
		if( bControlState == FALSE )
		{
			MqLog("Control service failed to start 0x%x\n",GetLastError());
			bRetVal=false;
		}
		
		CloseServiceHandle(hService);
		CloseServiceHandle(hSCManager);
		return bRetVal;
}

wstring ConvertHTTPToDirectFormatName (const wstring cwcsFormatName) 
/*++  
	Function Description:
		Convert direct=http(s) formatname to direct=os format name
	Arguments:
		wstring - any valid msmq formatname
	Return code:
		wstring - direct=os formant name
--*/

{
     
	 wstring wcsFormatName = ToLower(cwcsFormatName);
	 size_t iPos = wcsFormatName.find(L"http");
     if( iPos == -1 )
     { 
          // return the orginal string.
          return cwcsFormatName;
	 }
     //
     // Parse URL find the end of the token direct=http:// or direct=https://
     //
     const wstring wcsURLToken = L"://";
     iPos = wcsFormatName.find(wcsURLToken);
     if( iPos == -1)
     {
          return cwcsFormatName;
     }
     //
     // Search for virtual directory (msmq)
     //
     const wstring cwcsVirDir = L"msmq";
     size_t iTmp = wcsFormatName.find(cwcsVirDir);
     if (iPos == -1)
     {
          return cwcsFormatName;
     }
     //
     // Rebuild Direct=os:machine\queue format name
     // 
     wstring wcsDirectFn = L"DIRECT=oS:";
     size_t iMachienNameLen = iTmp - (iPos+wcsURLToken.length ());
	 // 
	 // Concat machine name
	 // 
     wcsDirectFn += wcsFormatName.substr(size_t(iPos+wcsURLToken.length()),iMachienNameLen-1);
	 wcsDirectFn += L"\\";

     size_t iSep = iTmp + cwcsVirDir.length()+1;
     wcsDirectFn += wcsFormatName.substr(iSep,(wcsFormatName.length()-iSep));
	 //
	 // Return direct=os:machine\queue format name
	 // 
	 
	 return wcsDirectFn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\xact.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: xact.cpp

Abstract:
	
	  
    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/



#include "msmqbvt.h"
#define INITGUID

static ITransactionDispenser* g_pDispenser=NULL;
// 
// Define DtcGetTransactionManagerEx 
// 
VOID InvetigateTimeOut(CONST WCHAR * pLabel, CONST WCHAR * pBody );
typedef     ( * my_DtcGetTransactionManagerEx)(
									/* in */ char * i_pszHost,
									/* in */ char * i_pszTmName,
									/* in */ REFIID i_riid,
									/* in */ DWORD i_grfOptions,
									/* in */ void * i_pvConfigParams,
									/* out */ void ** o_ppvObject
									);


// 
// This number define the number of transaction in the test
//

const int ciNumberTransaction=5;

using namespace std;

void cTrans::Description ()
{
	wMqLog(L"Thread %d : Send transacted messages using DTC to local machine\n", m_testid);
}


#define NofQueueProp (9)
//
// Create Transactional Queue 
//

cTrans::cTrans (INT index , std::map < std :: wstring , std:: wstring > Tparms ,bool bTemp) :cTest (index),
 cOrderTransaction(bTemp),m_pSendBlock(NULL),m_ciNumberOfMessages(5)
{	
	m_wcsFormatNameBufferQ1 = Tparms[L"DestQFormatName1"];
	m_wcsFormatNameBufferQ2 = Tparms[L"DestQFormatName2"];
	m_bRunOnDependetClient=FALSE;
	if ( Tparms[L"DepClient"] == L"true")
		m_bRunOnDependetClient=TRUE;

	m_pSendBlock= new StrManp( ciNumberTransaction,L"TRANSACTION" );
	if( !m_pSendBlock )
	{
			MqLog("cTrans::Start_test Failed to allocate memory for StrManp \n");
			throw INIT_Error("cTrans::Start_test Failed to allocate memory for StrManp \n");
	}
}

cTrans::~cTrans()
{
	delete m_pSendBlock;
}

//
// Send Transacation messgaes to the queue
//

#define NofMessageProp (10)
INT cTrans::Start_test()
{

	SetThreadName(-1,"cTrans - Start_test ");			
	HRESULT rc;
	MSGPROPID aMsgPropId[NofMessageProp]={0};
	MQPROPVARIANT aMsgPropVar[NofMessageProp]={0};
	HRESULT aMsgStatus[NofMessageProp]={0};
	MQMSGPROPS MsgProps={0};
	DWORD dCountMProps=0;

	ITransaction *pXact=NULL;
	HANDLE WriteHandle,hReadHandle;
		
	rc = MQOpenQueue( m_wcsFormatNameBufferQ1.c_str() , MQ_SEND_ACCESS , MQ_DENY_NONE , &WriteHandle );
	ErrHandle( rc , MQ_OK , L"MQopenQueue failed with error" );
	if ( g_bDebug )
	{
		MqLog("xact.cpp Succeeded to open queue1 \n");
	}

	
	aMsgPropId[dCountMProps] = PROPID_M_LABEL;            //PropId
	aMsgPropVar[dCountMProps].vt = VT_LPWSTR;             //Type
	aMsgPropVar[dCountMProps].pwszVal =(USHORT * ) m_wcsGuidMessageLabel.c_str(); // send with guid label
	dCountMProps++;    	

	DWORD dM_BodyIndex=dCountMProps;
	aMsgPropId[dCountMProps] = PROPID_M_BODY;             //PropId
	aMsgPropVar[dCountMProps].vt = VT_VECTOR | VT_UI1;
	dCountMProps++;

	aMsgPropId[dCountMProps] = PROPID_M_TIME_TO_BE_RECEIVED; 
	aMsgPropVar[dCountMProps].vt = VT_UI4;
	aMsgPropVar[dCountMProps].ulVal = MQBVT_MAX_TIME_TO_BE_RECEIVED;
	dCountMProps++;

	
    	
	//Set the MQMSGPROPS structure.
	MsgProps.cProp = dCountMProps;       //Number of properties.
	MsgProps.aPropID = aMsgPropId;      //Id of properties.
	MsgProps.aPropVar= aMsgPropVar;    //Value of properties.
	MsgProps.aStatus = aMsgStatus;     //Error report.
	
	rc = cOrderTransaction.xDTCBeginTransaction(&pXact); // begin DTC transaction
	if ( FAILED(rc) )
	{
		MqLog ("DTCBeginTransaction failed, Check MSDTC service\n");
		return MSMQ_BVT_FAILED;
	}
	
	if ( g_bDebug )
	{
		MqLog("xact.cpp Succeeded to order transaction \n");
	}
	for (int index = 0; index < m_ciNumberOfMessages ;index ++)  
	{
			WCHAR wcsTempstring[100];
			wstring wcsTemp=m_pSendBlock->GetStr(index);
			wcscpy(wcsTempstring,wcsTemp.c_str());
			aMsgPropVar[dM_BodyIndex].caub.pElems =(UCHAR *)wcsTempstring;
			aMsgPropVar[dM_BodyIndex].caub.cElems = ((ULONG)(wcslen((WCHAR *) wcsTempstring)) + 1) * sizeof(WCHAR);
			rc= MQSendMessage(WriteHandle, &MsgProps,pXact);
			ErrHandle( rc , MQ_OK , L"MQSendMessage failed during send transactional messages:" );

	}	
	
	if ( g_bDebug )
	{
		MqLog("xact.cpp finish to send transactions \n");
	}
	
	rc=MQCloseQueue(WriteHandle);
	ErrHandle( rc , MQ_OK , L"MQCloseQueue close queue" );
	rc = pXact->Commit(0,0,0);
	pXact->Release();
	
	wcscpy (m_wcsTempBuf,L"Eitan");
	aMsgPropVar[dM_BodyIndex].caub.pElems = (UCHAR * )m_wcsTempBuf;
	aMsgPropVar[dM_BodyIndex].caub.cElems = sizeof (m_wcsTempBuf);
	
	HANDLE hQ2Send;
	rc=cOrderTransaction.xDTCBeginTransaction(&pXact ); // begin DTC transaction
	
	if ( FAILED(rc) )
	{
		MqLog ("DTCBeginTransaction (2) failed\n");
		return MSMQ_BVT_FAILED;
	}

	rc= MQOpenQueue(m_wcsFormatNameBufferQ2.c_str(),MQ_SEND_ACCESS,MQ_DENY_NONE,&hQ2Send);
	
	ErrHandle( rc , MQ_OK , L"MQOpenQueue failed");	
	
	rc= MQSendMessage(hQ2Send, &MsgProps,pXact);
	ErrHandle( rc , MQ_OK , L"MQSendMessage failed");	
	
	rc = pXact->Commit(0,0,0);
	pXact->Release();
	
	rc=MQCloseQueue(hQ2Send);
	ErrHandle( rc , MQ_OK , L"MQCloseQueue failed");
	
	if ( g_bDebug )
	{
		MqLog("xact.cpp finish to send to the other queue \n");
	}
	
	WCHAR Label[MQ_MAX_Q_LABEL_LEN+1]; 
	cPropVar Rprop(4);
	Rprop.AddProp(PROPID_M_LABEL,VT_LPWSTR,Label,MQ_MAX_Q_LABEL_LEN );
	ULONG uTemp=MAX_GUID;
	Rprop.AddProp(PROPID_M_LABEL_LEN,VT_UI4,&uTemp );

	
	rc= MQOpenQueue(m_wcsFormatNameBufferQ2.c_str(),MQ_RECEIVE_ACCESS,MQ_DENY_NONE,&hReadHandle);
	
	ErrHandle( rc , MQ_OK , L"MQOpenQueue failed");	

	rc=cOrderTransaction.xDTCBeginTransaction(&pXact ); // begin DTC transaction

	if ( FAILED(rc) )
	{
		MqLog ("DTCBeginTransaction (2) failed\n");
		return MSMQ_BVT_FAILED;
	}

	rc=MQReceiveMessage( hReadHandle , 3000, MQ_ACTION_RECEIVE ,Rprop.GetMSGPRops(),NULL,NULL,NULL, pXact );
	ErrHandle( rc , MQ_OK , L"MQReceiveMessgaes failed during receive using transaction");	

	pXact->Abort(0,0,0);
		
	// Bug bug in the Relase Operation need to preform release
	// and try catch for the error

	//pXact->Release () ;


	
 
	HANDLE hCursor;
	rc=MQCreateCursor(hReadHandle ,& hCursor);
	
	ErrHandle( rc , MQ_OK , L"MQCreateCursor failed");	
	//
	// Need to prefrom Peek until find the current message 
	// 
	BOOL bMessageNotFound = false;
	DWORD dwAction = MQ_ACTION_PEEK_CURRENT;
	do 
	{
		Rprop.AddProp(PROPID_M_LABEL_LEN,VT_UI4,&uTemp );
		
		rc=MQReceiveMessage( hReadHandle , 3000, dwAction ,Rprop.GetMSGPRops(),NULL,NULL,hCursor,NULL);
		ErrHandle( rc , MQ_OK , L"MQReceiveMessage failed to search message in the queue ");	

		if( dwAction == MQ_ACTION_PEEK_CURRENT )
		{
			dwAction = MQ_ACTION_PEEK_NEXT;
		}
		if ( ! wcscmp( Label, m_wcsGuidMessageLabel.c_str()) )
		{
			bMessageNotFound = TRUE;
		}
	
	} while( rc !=  MQ_ERROR_IO_TIMEOUT && ! bMessageNotFound );

	if( rc ==  MQ_ERROR_IO_TIMEOUT && ! bMessageNotFound )
	{
		MqLog("Erorr while trying to find the message in the queue\n");
		return MSMQ_BVT_FAILED;
	}
	

	rc=MQCloseQueue(hReadHandle);
	ErrHandle( rc , MQ_OK , L"MQCloseQueue failed");	
		
	return MSMQ_BVT_SUCC;
}


INT cTrans::CheckResult()
{

	
	ITransaction *pXact = NULL;
	HANDLE hCursor = NULL; 
	QUEUEHANDLE hRecQueue = NULL;
	HRESULT rc = MQOpenQueue(m_wcsFormatNameBufferQ1.c_str(),MQ_RECEIVE_ACCESS,MQ_DENY_NONE, &hRecQueue);
	ErrHandle( rc , MQ_OK , L"MQCloseQueue failed");	
	
		

	rc = MQCreateCursor( hRecQueue,&hCursor );
	ErrHandle( rc , MQ_OK , L"MQCreateCursor failed");	

/*	MQMSGPROPS MsgProps;
	MQPROPVARIANT aVariant[10];
	MSGPROPID aMessPropId[10];
	DWORD dwPropIdCount = 0;
	WCHAR wcsMsgBody[20];

	//DWORD dwAppspecificIndex;
	
	// Set the PROPID_M_BODY property.
	aMessPropId[dwPropIdCount] = PROPID_M_BODY;               //PropId
	aVariant[dwPropIdCount].vt = VT_VECTOR|VT_UI1;        //Type
	aVariant[dwPropIdCount].caub.cElems = 20 * sizeof(WCHAR);   //Value
	aVariant[dwPropIdCount].caub.pElems = (UCHAR *)wcsMsgBody;
	dwPropIdCount++;
	

	/// BUG BUG need to check Why i need this code pass !!!

	//Set the PROPID_M_APPSPECIFIC property.

	//Set the MQMSGPROPS structure.
	MsgProps.cProp = dwPropIdCount;       //Number of properties.
	MsgProps.aPropID = aMessPropId;         //Ids of properties.
	MsgProps.aPropVar = aVariant;       //Values of properties.
	MsgProps.aStatus  = NULL;           //No Error report.


*/
	cPropVar Rprop(4);	
	//
	// Body and label are equel.
	//
	WCHAR wcsBody[MQ_MAX_Q_LABEL_LEN + 1 ]={0},Label[MQ_MAX_Q_LABEL_LEN+1 ]={0};

	Rprop.AddProp(PROPID_M_BODY,VT_UI1|VT_VECTOR,wcsBody,MQ_MAX_Q_LABEL_LEN);
	Rprop.AddProp(PROPID_M_LABEL,VT_LPWSTR,Label,MQ_MAX_Q_LABEL_LEN);
	ULONG uTemp=MAX_GUID;
	Rprop.AddProp(PROPID_M_LABEL_LEN,VT_UI4,&uTemp );


	StrManp pwcsMessgeBody(ciNumberTransaction-1);    
	
	rc = cOrderTransaction.xDTCBeginTransaction( &pXact );
	
	if ( FAILED(rc) )
	{
		MqLog ("DTCBeginTransaction failed, Check MSDTC service\n");
		return MSMQ_BVT_FAILED;
	}


	//might be bugbug DWORD dwAction = MQ_ACTION_RECEIVE;  //Peek at first msg.

	for (int index=0;index < m_ciNumberOfMessages;index++) 
	{

		BOOL bMessageNotFound = FALSE;
		DWORD dwAction = MQ_ACTION_PEEK_CURRENT;


		do 
		{
			Rprop.AddProp(PROPID_M_LABEL_LEN,VT_UI4,&uTemp );
			rc = MQReceiveMessage( hRecQueue , 3000, dwAction ,Rprop.GetMSGPRops(),NULL,NULL,hCursor,NULL);
			if( rc == MQ_ERROR_IO_TIMEOUT )
			{
				InvetigateTimeOut(m_wcsFormatNameBufferQ1.c_str(),wcsBody);
			}
			ErrHandle( rc , MQ_OK , L"MQReceiveMessage failed to peek the messgaes ");	
			dwAction = MQ_ACTION_PEEK_NEXT;
			
			if (rc != MQ_OK) 	
			{
				MqLog("MQReceiveMessage failed when trying to receive message from transactional queue 0x%x\n",rc);
				return MSMQ_BVT_FAILED;
			}	
		
			if ( ! wcscmp( Label, m_wcsGuidMessageLabel.c_str()) )
			{
				bMessageNotFound = TRUE;
				rc=MQReceiveMessage( hRecQueue , 3000, MQ_ACTION_PEEK_CURRENT ,Rprop.GetMSGPRops(),NULL,NULL,hCursor,NULL);
				ErrHandle( rc , MQ_OK , L"MQReceiveMessage failed to receive the message");	
			}
		}	
		while (rc !=  MQ_ERROR_IO_TIMEOUT && ! bMessageNotFound );

		if (rc ==  MQ_ERROR_IO_TIMEOUT && ! bMessageNotFound )
		{
			MqLog ("Erorr while trying to find the message in the queue\n");
			return MSMQ_BVT_FAILED;
		}
		
			
		pwcsMessgeBody.SetStr(wcsBody);

	}
	//
	// BUGBug Need to check the recive messgaes
	// release the comoboject 

	rc = pXact->Commit(0,0,0);    
	ErrHandle( rc , MQ_OK , L"Commit failed");	
	rc = MQCloseCursor( hCursor);
	ErrHandle( rc , MQ_OK , L"MQCloseCursor failed ");	
	
	rc= MQCloseQueue(hRecQueue);
	ErrHandle( rc , MQ_OK , L"MQCloseQueue failed");
	return	(*m_pSendBlock==pwcsMessgeBody);
 
}


OrderTransaction::~OrderTransaction()
{
	//g_pDispenser->Release();
	if( m_hxolehlp != NULL )
	{
		FreeLibrary (m_hxolehlp);
	}
}


OrderTransaction::OrderTransaction( bool bUseExVersion )
:m_hxolehlp(NULL)
{

	HRESULT hr=MQ_OK;
	if( g_pDispenser == NULL )
	{
		if(! bUseExVersion )
		{
			hr = DtcGetTransactionManager ( 
											NULL,						//Host Name
											NULL,						//TmName
											IID_ITransactionDispenser,
											0,							//reserved
											0,							//reserved
											0,							//reserved
											(LPVOID*)&g_pDispenser
										  );
			if (hr != S_OK)
			{
				MqLog ("DtcGetTransactionManager Failed with Error %x\n Please check MSDTC service\n",hr);
				throw INIT_Error("DtcGetTransactionManager Failed");
			}
		}
		else
		{
			m_hxolehlp=LoadLibrary("xolehlp.dll"); 
 			
			if ( ! m_hxolehlp )
			{
				MqLog ("Error can't load X0lehlp.dll to memory\n");
			}

			my_DtcGetTransactionManagerEx My_DTCBeginTransEx=NULL;
			My_DTCBeginTransEx = (my_DtcGetTransactionManagerEx) GetProcAddress( m_hxolehlp , "DtcGetTransactionManagerEx");
			if( My_DTCBeginTransEx == NULL )
			{
				MqLog ("Error can't get DtcGetTransactionManagerEx pointer from xolehlp.dll\n");
				throw INIT_Error("DtcGetTransactionManager Failed");
			}

			hr = My_DTCBeginTransEx( 
							NULL,						//Host Name
							NULL,						//TmName
							IID_ITransactionDispenser,
							0,							//reserved
							0,							//reserved
							(LPVOID*)&g_pDispenser
							);
		
		}

		if (hr != S_OK)
		{
				MqLog ("DtcGetTransactionManager Failed with Error %x\nPlease check MSDTC service\n",hr);
				throw INIT_Error("DtcGetTransactionManager Failed");
		}
	}
	
	//
	// bugbug neet to release the pointer
	//
}

INT OrderTransaction::xDTCBeginTransaction(ITransaction ** ppXact )
{

	try
	{
		return g_pDispenser->BeginTransaction (
											   NULL,                       // IUnknown __RPC_FAR *punkOuter,
											   ISOLATIONLEVEL_ISOLATED,    // ISOLEVEL isoLevel,
											   ISOFLAG_RETAIN_DONTCARE,    // ULONG isoFlags,
											   NULL,                       // ITransactionOptions *pOptions
											   ppXact
											   );
	}
	catch ( ... )
	{
		MqLog ("BeginTransaction Failed Please check the MSDTC service\n");
		return MSMQ_BVT_FAILED;		
	}
	
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\bvt\mqbvt\xtofn.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: xTofn.cpp

Abstract:

  Contain xxxToFormatName & MQMachineName information		

Author:

    Eitan klein (EitanK)  25-May-1999

Revision History:

--*/

#include "msmqbvt.h"
#include "mqdlrt.h"
#include "mqmacro.h"
#include <ntdsapi.h>
using namespace std;

extern BOOL g_bRunOnWhistler;
extern bool g_bRemoteWorkgroup ;

void MachineName::Description()
{
	wMqLog(L"Thread %d : Get machine prop\n", m_testid);
	
}


bool my_wcsicmp(LPCWSTR str1, LPCWSTR str2) 
/*++


  
	Function Description:
		This function replace the wcsicmp to support compare strings from differnt local function
		example:
			 	ff5a : small letter for Z (DBCS)
				ff3a : capital letter for Z (DBCS)
				007a : normal small letter for Z (SBCS)
				005a : capital letter for Z (SBCS)

	Arguments:
		str1 - string.
		str2 - string.
	Return code:
		bool

	
--*/

{
	int ret = CompareStringW(
							DS_DEFAULT_LOCALE,
							DS_DEFAULT_LOCALE_COMPARE_FLAGS,
							str1,
							-1,
							str2,
							-1
							);
	
	return (ret != CSTR_EQUAL);
}


//
// bugbug MachineName - not supported in workgroup installation need to check it.
//

// -------------------------------------------------------------------------
// MachineName:: MachineName
// Constructor retrive the local & remote machine name.
// Need to decide if use full dns Yes / No.


MachineName:: MachineName(int iTestIndex , map < wstring , wstring > Tparmes )
: cTest(iTestIndex),m_IsCluster(false)
{

	wcsLocalMachineName = Tparmes [L"LMachine"] ;
	wcsLocalMachineFullDns = Tparmes [L"LMachineFDNS"];
	wcsRemoteMachine = Tparmes [L"RMachine"];
	wcsRemoteMachineFullDns = Tparmes [L"RMachineFDNS"];
	m_bWorkWithFullDNSName = TRUE;
	if( Tparmes[L"MSMQ1Limit"] == L"true" )
	{
		m_bWorkWithFullDNSName = FALSE;
	}
	if( Tparmes[L"IsCluster"] == L"true" )
	{
		m_IsCluster = true;
	}

}

// ----------------------------------------------------------------
// MachineName::Start_test
// retrive machine name for queue.
//
int MachineName::Start_test()
{

	SetThreadName(-1,"MachineName - Start_test ");			
    GUID guidMachineId;
	const int iNumberOfPropId = 4;
	QMPROPID QMPropId[iNumberOfPropId];
	MQPROPVARIANT QMPropVar[iNumberOfPropId];
	HRESULT hResult[iNumberOfPropId]={NULL};
	MQQMPROPS QMProps = {iNumberOfPropId,QMPropId,QMPropVar,hResult};
	HRESULT rc = MQ_OK;
	wstring lpMachineName=L"";
	for( int i = 0 ; i < 2 ; i++)
	{
		if (i == 0)
		{
			 lpMachineName = wcsLocalMachineName;
		}
		else
		{
		 	 lpMachineName = wcsRemoteMachine;
		}
		int iIndex = 0;
		QMPropId[iIndex] = PROPID_QM_SITE_ID;
		QMPropVar[iIndex].vt = VT_CLSID;
		QMPropVar[iIndex].puuid = new GUID;
		iIndex ++ ;
		
		GUID MachineIDGuid;
		QMPropId[iIndex] = PROPID_QM_MACHINE_ID;
		QMPropVar[iIndex].vt = VT_CLSID;
		QMPropVar[iIndex].puuid = &MachineIDGuid;
		iIndex ++ ;
		
		QMPropId[iIndex] = PROPID_QM_SITE_ID;
		QMPropVar[iIndex].vt = VT_CLSID;
		QMPropVar[iIndex].puuid = new GUID;
		iIndex ++ ;

		QMPropId[iIndex] = PROPID_QM_PATHNAME;
		QMPropVar[iIndex].vt = VT_LPWSTR;
		QMPropVar[iIndex].vt = VT_NULL;
		iIndex ++ ;
		
		QMProps.cProp = iIndex;
		if( g_bDebug )
		{
			wMqLog(L"Call->MQGetMachineProperties and with 4 params PROPID_QM_SITE_ID,PROPID_QM_MACHINE_ID,PROPID_QM_SITE_ID,PROPID_QM_PATHNAME\n");
			wMqLog(L"Expected result is MQ_INFORMATION_PROPERTY because asked twice for PROPID_QM_SITE_ID\n");
		}
		rc = MQGetMachineProperties(lpMachineName.c_str(), NULL, &QMProps);
		ErrHandle(rc,MQ_INFORMATION_PROPERTY,L"MQGetMachineProperties(1)");
		//
		// Verify parameters
		//
		if( QMProps.aPropVar[3].vt != VT_NULL && my_wcsicmp(lpMachineName.c_str(),QMProps.aPropVar[3].pwszVal) != 0 )
		{
			MqLog("MQGetMachineProperties failed to retrive the PROPID_QM_PATHNAME\nFound:%s,Expected:%s\n",
				   QMProps.aPropVar[3].pwszVal,lpMachineName);
			return MSMQ_BVT_FAILED;
		}
		//
		// Release params.
		// 
		ErrHandle(QMProps.aPropVar[3].vt,VT_LPWSTR,L"MQGetMachineProperties failed to retrieve the PROPID_QM_PATHNAME");
		MQFreeMemory(QMPropVar[3].pwszVal);
		delete QMPropVar[2].puuid;
		delete QMPropVar[0].puuid;
		iIndex = 0;

		QMPropId[iIndex] = PROPID_QM_BASE;
		QMPropVar[iIndex].vt = VT_NULL;
		iIndex ++;
		
		QMPropId[iIndex] = PROPID_QM_PATHNAME;
		QMPropVar[iIndex].vt = VT_LPWSTR;
		QMPropVar[iIndex].vt = VT_NULL;
		iIndex ++;
		QMProps.cProp = iIndex;
		if( g_bDebug )
		{
			MqLog("Call-> MQGetMachineProperties with PROPID_QM_BASE that is an invalid property\n");
		}
		rc = MQGetMachineProperties(NULL, &MachineIDGuid, &QMProps);
		ErrHandle(rc,MQ_INFORMATION_PROPERTY,L"MQGetMachineProperties (2)");
		ErrHandle(QMProps.aPropVar[1].vt,VT_LPWSTR,L"MQGetMachineProperties failed to retrieve the PROPID_QM_PATHNAME");
		MQFreeMemory(QMPropVar[1].pwszVal);
		
				
		//
		// Try to retrive full DNS name as computer name
		// Works only at W2K machine in W2K domain only !
		//
		if ( _winmajor >=  Win2K && m_bWorkWithFullDNSName )
		{
			
			QMPropId[0] = PROPID_QM_PATHNAME_DNS;
			QMPropVar[0].vt = VT_NULL;
			QMProps.cProp = 1;
			if( g_bDebug )
			{	
				MqLog ("MQGetMachineProperties - Try to retrieve full dns name\n");
			}
			rc = MQGetMachineProperties(NULL, NULL, &QMProps);
			ErrHandle(rc,MQ_OK,L"MQGetMachineProperties(3)");
			ErrHandle(QMPropVar[0].vt ,VT_LPWSTR ,L"Can not get machine DNS name");		
			
			wstring wcsFullDnsName = ToLower(QMPropVar[0].pwszVal);
			wstring wcsExpectedResultFullDnsName = ToLower(wcsLocalMachineFullDns);
			size_t iPos = wcsFullDnsName.find_first_of(wcsExpectedResultFullDnsName);
			bool bCheckExpectedResults = true;
			if( m_IsCluster == true && iPos == 0 )
			{
				bCheckExpectedResults = false;
			}
			// QMPropVar[0].pwszVal contain full DNS name.
			if ( bCheckExpectedResults == true && QMPropVar[0].pwszVal && my_wcsicmp (QMPropVar[0].pwszVal ,wcsLocalMachineFullDns.c_str ()))
			{
				MqLog ("MachineName - MQGetMachineProperties failed to retrieve full DNS name\n");
				MqLog ("MachineName - Check from MMC if active directory contains the full DNS name \n");
				wMqLog (L"MQGetMachineProperties Found: %s \n expected %s \n", QMPropVar[0].pwszVal,wcsExpectedResultFullDnsName.c_str());
				MQFreeMemory(QMPropVar[0].pwszVal);
				return MSMQ_BVT_FAILED;	
			}
			

			if ( QMPropVar[0].vt == VT_LPWSTR )
			{
				MQFreeMemory(QMPropVar[0].pwszVal);
			}
			else
			{
				MqLog("MQGetMachineProperties return value that doesn't match with the expected result\n Expected.vt=%d, Found.vt %d\n",VT_LPWSTR,QMPropVar[0].vt);
			    return MSMQ_BVT_FAILED;				  
			}
		}

		iIndex = 0;
		QMPropId[iIndex] = PROPID_QM_CONNECTION;
		QMPropVar[iIndex].vt = VT_NULL;
		iIndex ++;
		QMPropId[iIndex] = PROPID_QM_ENCRYPTION_PK;
		QMPropVar[iIndex].vt = VT_NULL;
		iIndex ++;
		QMProps.cProp = iIndex;		  // Should be 2, but 1 until bug is fixed
 		rc = MQGetMachineProperties(lpMachineName.c_str(), NULL, &QMProps);
		ErrHandle(rc,MQ_OK,L"MQGetMachineProperties(4)");
		
	}

	rc = MQGetMachineProperties(lpMachineName.c_str(), &guidMachineId, &QMProps);
	ErrHandle(rc,MQ_ERROR_INVALID_PARAMETER,L"MQGetMachineProperties(5)");
	QMPropId[0] = PROPID_QM_CONNECTION;
	QMPropVar[0].vt = VT_NULL;
	QMProps.cProp = 2;		  // Should be 2, but 1 until bug is fixed
	
	rc = MQGetMachineProperties(L"NoName", NULL, &QMProps);
	ErrHandle(rc,MQ_ERROR_MACHINE_NOT_FOUND,L"MQGetMachineProperties(6)");

	return MSMQ_BVT_SUCC;
}

void xToFormatName::Description()
{
	wMqLog(L"Thread %d : xxxToFormatName tests\n", m_testid);
}

// ------------------------------------------------------------------------------------
// xToFormatName :: xToFormatName
// Constructor retrieve test parameters
// Machines name, Workgroup Yes now
//

xToFormatName :: xToFormatName (INT iTestIndex , map < wstring , wstring > Tparms )
: cTest(iTestIndex),m_bCanWorksOnlyWithMqAD(true),m_iEmbedded(COM_API)
{
	
	m_wcsFormatNameArray[0] = Tparms [L"PrivateDestFormatName"];
	m_wcsPathNameArray[0] = Tparms [L"PrivateDestPathName"];
	m_wcsFormatNameArray[1] = Tparms [L"DestFormatName"];
	m_wcsPathNameArray[1]  = Tparms [L"DestPathName"];
	m_bWorkGroupInstall = FALSE;

	if ( Tparms [L"Wkg"]== L"Wkg" )
	{
		m_bWorkGroupInstall = TRUE;
	}
	if ( g_bRunOnWhistler && Tparms [L"WorkingAgainstPEC"] == L"Yes" )
	{
		m_bCanWorksOnlyWithMqAD = false;
	}

	if (Tparms[L"SkipOnComApi"] == L"Yes" )
	{
		m_iEmbedded = C_API_ONLY;
	}
}

//------------------------------------------------------------------------------------
// xToFormatName::Start_test
// This method check the api : MQPathNameToFormatName , MQHandleToFormatName
//

int xToFormatName::Start_test ()
{
	SetThreadName(-1,"xToFormatName - Start_test ");			
	DWORD  dwFormatNameLength=0;
	WCHAR  * lpwcsFormatName=NULL;

	// Need to run this on private / Publib queue
	//	1. Private Queue.
	//	2. Public Queue.

	wstring wcsQueueFormatName = m_wcsFormatNameArray[0];
	wstring wcsQueuePathName =  m_wcsPathNameArray[0] ;
	int iNumberOfIteration = m_bWorkGroupInstall ? 1:2;
	do
	{
		if(g_bDebug)
		{
			wMqLog(L"-- Verify MQPathNameToFormatName and MQHandleToFormatName for queue %s\n",wcsQueuePathName.c_str());
			wMqLog(L"Call->MQPathNameToFormatName(PathName=%s,buffer,Size=%d) \n",wcsQueuePathName.c_str(),dwFormatNameLength);
		}
		HRESULT rc = MQPathNameToFormatName( wcsQueuePathName.c_str(), lpwcsFormatName, &dwFormatNameLength);
		if ( rc != MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL && dwFormatNameLength == 0 )
		{
			wMqLog(L"MQPathNametoFormatName failed to retrieve the buffer size for format name \n");
			return MSMQ_BVT_FAILED;
		}
		lpwcsFormatName = (WCHAR*) malloc( sizeof (WCHAR) * dwFormatNameLength );
		if ( ! lpwcsFormatName )
		{
			wMqLog(L"malloc failed to allocate memory format name buffer \n");
			return MSMQ_BVT_FAILED;
		}	
		if(g_bDebug)
		{
			wMqLog(L"Call->MQPathNameToFormatName(PathName=%s,buffer,Size=%d) \n",wcsQueuePathName.c_str(),dwFormatNameLength);
		}
		rc = MQPathNameToFormatName( wcsQueuePathName.c_str() , lpwcsFormatName, &dwFormatNameLength);
		ErrHandle(rc,MQ_OK,L"MQPathNameToFormatName failed");
		if ( my_wcsicmp( wcsQueueFormatName.c_str() , lpwcsFormatName ))
		{
            if (!g_bRemoteWorkgroup)
            {
                //
                // this is ok if we're in domain and running against remote
                // comptuer that is in workgroup.
                //
			    wMqLog(L"MQPathNameToFormatName failed during compare expected result to return value\n");
			    wMqLog(L"Expected resualt: %s\n MQPathNameToFormatName return:%s \n",wcsQueueFormatName.c_str (),lpwcsFormatName);
			    return MSMQ_BVT_FAILED;
            }
		}
		
		if(g_bDebug)
		{
			wMqLog(L"Call->MQOpenQueue(%s,MQ_SEND_ACCESS , MQ_DENY_NONE,&hQueue)\n",wcsQueueFormatName.c_str());
		}
		HANDLE hQueue=NULL;
		rc = MQOpenQueue( wcsQueueFormatName.c_str() , MQ_SEND_ACCESS , MQ_DENY_NONE , &hQueue );
		ErrHandle(rc,MQ_OK,L"MQOpenQueue failed");
		if(g_bDebug)
		{
			wMqLog(L"Call->MQHandleToFormatName(hQueue , lpwcsFormatName ,%d) \n",dwFormatNameLength);
		}
		rc = MQHandleToFormatName( hQueue , lpwcsFormatName , &dwFormatNameLength );
		if( m_bWorkGroupInstall && rc == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL )
		{
            LPWSTR pNewFormatName = (WCHAR *) realloc(lpwcsFormatName,dwFormatNameLength * sizeof(WCHAR));
			if( pNewFormatName == NULL )
			{
				wMqLog(L"malloc failed to allocate memory format name buffer \n");
				return MSMQ_BVT_FAILED;
			}

            lpwcsFormatName = pNewFormatName; 
			rc = MQHandleToFormatName( hQueue , lpwcsFormatName , &dwFormatNameLength );
		}
		ErrHandle(rc,MQ_OK,L"MQHandleToFormatName failed");
		//
		// close queue handle this is not related if MQHandleToFormatName Pass / Fail.
		//
		rc = MQCloseQueue ( hQueue );
		ErrHandle(rc,MQ_OK,L"MQCloseQueue failed");
     	//
		// Check MQHandleToFormatName return value == expected value.
		//
		if(! m_bWorkGroupInstall && my_wcsicmp( wcsQueueFormatName.c_str(), lpwcsFormatName ) )
		{
            if( !g_bRemoteWorkgroup )
            {
			    wMqLog(L"MQHandleToFormatName failed during compare expected result to return value\n");
			    wMqLog(L"Expected resualt: %s \nMQHandleToFormatName return: %s \n" ,wcsQueueFormatName.c_str (),lpwcsFormatName);
			    return MSMQ_BVT_FAILED;
            }
		}
		else if ( m_bWorkGroupInstall )
		{
			//
			// Search for the private$ in the orginal queue.
			//
			wcsQueueFormatName = ToLower(wcsQueueFormatName);
			wstring wcsToken = L"\\";
			size_t iPos = wcsQueueFormatName.find_first_of(wcsToken);
			if( iPos == -1 )
			{
				wMqLog(L"MQHandleToFormatName return invalid format name %s\n",wcsQueueFormatName.c_str());
				return MSMQ_BVT_FAILED;
			}
			wstring wcspTemp = wcsQueueFormatName.substr(iPos,wcsQueuePathName.length());
			if ( wcsstr(lpwcsFormatName,wcspTemp.c_str()) == NULL )
			{
				if( !g_bRemoteWorkgroup )
				{
					wMqLog(L"MQHandleToFormatName failed during compare expected result to return value\n");
					wMqLog(L"Expected resualt: %s \nMQHandleToFormatName return: %s \n" ,wcsQueueFormatName.c_str (),lpwcsFormatName);
					return MSMQ_BVT_FAILED;
				}
            }

		}

		//
		// try to create a queue with existing pathname, expecting to get MQ_ERROR_QUEUE_EXISTS
		//
		if(g_bDebug)
		{
			wMqLog(L"Call-> MQCreateQueue with an existing pathname\n");
		}
		WCHAR wszFormatNameBuffer[100];
		DWORD dwFormatNameBufferLength=TABLE_SIZE(wszFormatNameBuffer);
		cPropVar QueueProps(1);
		QueueProps.AddProp( PROPID_Q_PATHNAME , VT_LPWSTR , wcsQueuePathName.c_str());
		HRESULT hr = MQCreateQueue( NULL, QueueProps.GetMQPROPVARIANT(), wszFormatNameBuffer, &dwFormatNameBufferLength);
		if (hr != MQ_ERROR_QUEUE_EXISTS)
		{
			if (FAILED(hr))
			{
				wMqLog(L"MQCreateQueue: failed with error %!hresult! when trying to create an exiting queue, queue pathname is %ls\n",hr,wcsQueuePathName.c_str());
			}
			else
			{
				wMqLog(L"MQCreateQueue: existing queue created again, queue pathname is %ls\n",wcsQueuePathName.c_str());
			}
			return MSMQ_BVT_FAILED;
		}
		//
		// Run again with Public queue.
		//
		wcsQueueFormatName = m_wcsFormatNameArray[1];
		wcsQueuePathName =  m_wcsPathNameArray[1] ;
		free( lpwcsFormatName );
		dwFormatNameLength=0;
	}
	while(--iNumberOfIteration);
	return MSMQ_BVT_SUCC;
}

//---------------------------------------------------------------
// xToFormatName::CheckResult
// This method check Illegal value that pass to the API.
// Return value: MSMQ_BVT_SUCC / MSMQ_BVT_FAILED.
//

int xToFormatName::CheckResult()
{
	//
	// Check MQADsPathToFormatName only in whistler
	//
	if( g_bRunOnWhistler && m_bCanWorksOnlyWithMqAD && ! m_bWorkGroupInstall && m_iEmbedded != C_API_ONLY )
	{
		MSMQ::IMSMQQueueInfo3Ptr qinfo("MSMQ.MSMQQueueInfo");
		qinfo->FormatName = m_wcsFormatNameArray[1].c_str();
		qinfo->Refresh();
		DWORD dwFormatNameLen = 0;
		if( g_bDebug )
		{
			wMqLog(L"Qinfo->AdsPath=%s",qinfo->ADsPath);
		}
		HRESULT hr = MQDnNameToFormatName(qinfo->ADsPath,NULL,& dwFormatNameLen );
		if ( hr != MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL && dwFormatNameLen == 0 )
		{
			wMqLog(L"MQADsPathToFormatName failed to retrieve the buffer size for format name \n");
			return MSMQ_BVT_FAILED;
		}
		WCHAR * lpwcsFormatName = (WCHAR*) malloc( sizeof (WCHAR) * dwFormatNameLen );
		if ( ! lpwcsFormatName )
		{
			wMqLog(L"malloc failed to allocate memory format name buffer \n");
			return MSMQ_BVT_FAILED;
		}
		if( g_bDebug )
		{
			wMqLog(L"Call to MQDnNameToFormatName(%s,lpwcsFormatName,& dwFormatNameLen ) \n",qinfo->ADsPath);
		}
		hr = MQDnNameToFormatName(qinfo->ADsPath,lpwcsFormatName,& dwFormatNameLen );
		if( FAILED(hr) || m_wcsFormatNameArray[1] != lpwcsFormatName )
		{
			wMqLog(L"MQADsPathToFormatName failed to retrive format name hr=0x%x\nFound:%s\n",hr,lpwcsFormatName);
			free( lpwcsFormatName );
			return MSMQ_BVT_FAILED;
		}
		free( lpwcsFormatName );
	}

	DWORD dwFormatNameLength = BVT_MAX_FORMATNAME_LENGTH;
	WCHAR lpwcsFormatName [BVT_MAX_FORMATNAME_LENGTH+1] = {0};
	if(g_bDebug)
	{
		wMqLog(L"Call-> MQPathNameToFormatName with Illegal value\n");
	}
	wstring TmpBuf = L".\\private$\\F41ED5B2-1C81-11d2-B1F4-00E02C067C8BEitan";
	HRESULT rc = MQPathNameToFormatName( TmpBuf.c_str(), lpwcsFormatName, &dwFormatNameLength);
	ErrHandle(rc,MQ_ERROR_QUEUE_NOT_FOUND,L"MQPathNameToFormatName Illegal return value" );
	return MSMQ_BVT_SUCC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\mqforgn\forgnkey.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation. All rights reserved

Module Name:
    forgnkey.cpp

Abstract:
    dll that set public key in forign machine object.

Author:
    DoronJ

Environment:
	Win2k only.

--*/

#pragma warning(disable: 4201)
#pragma warning(disable: 4514)

#include "_stdafx.h"

#include <string.h>
#include <stdio.h>
#include <assert.h>

#include "cmnquery.h"
#include "dsquery.h"

#include "mqsymbls.h"
#include "mqprops.h"
#include "mqtypes.h"
#include "mqcrypt.h"
#include "mqsec.h"
#include "_propvar.h"
#include "_rstrct.h"
#include "ds.h"
#include "_mqdef.h"
#include <_mqreg.h>
#include <_mqini.h>

//+---------------------------
//
//  MySetFalconKeyValue()
//
//+---------------------------

LONG
MySetFalconKeyValue(
    LPCTSTR pszValueName,
    PDWORD  pdwType,
    const VOID * pData,
    PDWORD  pdwSize
    )
{
    ASSERT(pData != NULL);
    ASSERT(pdwSize != NULL);

    DWORD dwType = *pdwType;
    DWORD cbData = *pdwSize;
    HKEY hKey = NULL ;

    TCHAR *pszRegKey = FALCON_REG_KEY_ROOT
                       MSMQ_DEFAULT_REGISTRY
                       FALCON_REG_KEY_PARAM
                       TEXT("\\Security") ;

    LONG rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            pszRegKey,
                            0,
                            KEY_ALL_ACCESS,
                            &hKey ) ;
    if ( rc != ERROR_SUCCESS)
    {
        return rc;
    }

    rc =  RegSetValueEx( hKey,
                         pszValueName,
                         0,
                         dwType,
                         reinterpret_cast<const BYTE*>(pData),
                         cbData);
    RegCloseKey(hKey) ;
    return(rc);
}

//-------------------------------
//
// StorePbkeyOnForeignMachine()
//	
//-------------------------------

HRESULT APIENTRY
MQFrgn_StorePubKeysInDS( IN LPWSTR pwszMachineName,
                         IN LPWSTR pwszKeyName,
                         IN BOOL   fRegenerate )
{
    //
    // verify that key name is not msmq.
    // this would overwrite the key used by msmq itself.
    //
    if (wcsicmp(pwszKeyName, L"MSMQ") == 0)
    {
        return  MQ_ERROR_ILLEGAL_PROPERTY_VALUE ;
    }

    //
    // First verify that computer is indeed foreign.
    //
    PROPID      aProp[] = { PROPID_QM_FOREIGN } ;
    PROPVARIANT apVar[sizeof(aProp) / sizeof(aProp[0])] ;
	UINT uiPropIndex = 0;

    apVar[uiPropIndex].vt = VT_NULL;
    UINT  uiForeignIndex = uiPropIndex ;
    uiPropIndex++;

    HRESULT hr = DSGetObjectProperties( MQDS_MACHINE,
                                        pwszMachineName,
                                        uiPropIndex,
                                        aProp,
                                        apVar );

	if (FAILED(hr))
    {
        return hr ;
    }
    else if (apVar[ uiForeignIndex ].bVal != FOREIGN_MACHINE)
    {
		return MQ_ERROR_ILLEGAL_OPERATION ;
    }

    if (pwszKeyName[0] == 0)
    {
        printf("Using default key names %S, %S...\n",
                                     MSMQ_FORGN_BASE_DEFAULT_CONTAINER,
                                     MSMQ_FORGN_ENH_DEFAULT_CONTAINER) ;
    }
    else
    {
        DWORD dwType = REG_SZ ;
        DWORD dwKeyNameLen = 1 + wcslen(pwszKeyName) ;
        DWORD dwSize = dwKeyNameLen * sizeof(WCHAR) ;

        LONG rc = MySetFalconKeyValue( MSMQ_FORGN_BASE_VALUE_REGNAME,
                                      &dwType,
                                       pwszKeyName,
                                      &dwSize) ;
        if (rc != ERROR_SUCCESS)
        {
            return HRESULT_FROM_WIN32(rc) ;
        }

        P<WCHAR> pszEnhKeyName = new WCHAR[ dwKeyNameLen + 4 ] ;
        wcscpy(pszEnhKeyName, pwszKeyName) ;
        wcscat(pszEnhKeyName, L"_ENH") ;

        dwSize = (dwKeyNameLen + 4) * sizeof(WCHAR) ;
        rc = MySetFalconKeyValue( MSMQ_FORGN_ENH_VALUE_REGNAME,
                                 &dwType,
                                  pszEnhKeyName,
                                 &dwSize) ;
        if (rc != ERROR_SUCCESS)
        {
            return HRESULT_FROM_WIN32(rc) ;
        }

        printf("Using key names %S, %S...\n", pwszKeyName, pszEnhKeyName) ;
    }

    HINSTANCE hSecLib = LoadLibrary(TEXT("mqsec.dll")) ;
    if (!hSecLib)
    {
        DWORD dwErr = GetLastError() ;
        return (HRESULT_FROM_WIN32(dwErr)) ;
    }

    MQSec_StorePubKeysInDS_ROUTINE pfnStore =
         (MQSec_StorePubKeysInDS_ROUTINE)
                    GetProcAddress( hSecLib, "MQSec_StorePubKeysInDS") ;
    if (!pfnStore)
    {
        DWORD dwErr = GetLastError() ;
        return (HRESULT_FROM_WIN32(dwErr)) ;
    }

    hr = (*pfnStore) ( fRegenerate,
                       pwszMachineName,
                       MQDS_FOREIGN_MACHINE) ;

    FreeLibrary(hSecLib) ;

    return hr ;
}

/*====================================================

BOOL WINAPI DllMain (HMODULE hMod, DWORD dwReason, LPVOID lpvReserved)

 Initialization and cleanup when DLL is loaded, attached and detached.

=====================================================*/

BOOL WINAPI DllMain (HMODULE hMod, DWORD dwReason, LPVOID lpvReserved)
{
    switch(dwReason)
    {

    case DLL_PROCESS_ATTACH :
        break;

    case DLL_PROCESS_DETACH :
        break;

    default:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\mqbench\mqbench.cpp ===
/*++

Copyright (c) 1995-98 Microsoft Corporation. All rights reserved

Module Name:
    mqbench.cpp

Abstract:
    Benchmark MSMQ message performance

Author:
    Microsoft Message Queue Team

Environment:
	Platform-independent.

--*/

#pragma warning (disable:	4201) 
#pragma warning (disable:	4514)
#define INITGUID

#include <string.h>
#include <stdio.h>
#include <limits.h>
#include <windows.h>
#include <assert.h>

#include <transact.h>
#include <xolehlp.h>
#include <mq.h>



enum OPERATION			{ SEND, RECEIVE };
enum TRANSACTIONTYPE	{ NO_TRANSACTION, INTERNAL, COORDINATED, SINGLE };		

struct _params {
	UCHAR MsgType;
	OPERATION Operation;
	TRANSACTIONTYPE TransactionType;
	ULONG ulMsgNumber;
	ULONG ulTransactionNum;
	ULONG ulThreadNum;
	ULONG ulMsgSize;
	ULONG ulTimeLimit;
	ULONG ulTotalMessages;
	ULONG ulTotalTransactions;
	WCHAR wcsQueuePathName[MQ_MAX_Q_NAME_LEN];
	BOOL fWaitForReceivedMsg;
	BOOL fOperationSpecified;
	BOOL fOneLineFormat;
	BOOL fFormatName;
    DWORD dwCommitFlags;
};
typedef _params PARAMS;
//
// Command line parsed parameters
//
PARAMS g_Params;

// Traget queue handle used by the benchmark
//
QUEUEHANDLE g_hQueue;

//
// Timer start interlocked, used to messure receive start time
// after waiting to first message
//
BOOL g_fTimerStarted = FALSE;

//
// Synchronization Events. These events synchronize orchestrated start of all
// test threads.
//
HANDLE g_hStart;
HANDLE g_hEnd;

//
// Thread counter used to indentify the last thread in the bunch
//
LONG g_ThreadCounter;

//
// Stop execution. Used by time limit to indicate thread termination.
//
BOOL g_fStop;

//
// Benchmarck start and end time.
//
LONGLONG g_StartTime;
LONGLONG g_EndTime;

//
// Transaction Dispenser DTC's interface
//
ITransactionDispenser* g_pDispenser = NULL;

#ifdef PERF_TIMESTAMP
void TimeStamp(char *s) {
	static LARGE_INTEGER o;
	static DWORD od = 0;
	LARGE_INTEGER l;
	
	if(QueryPerformanceCounter(&l)) {
		printf("%s: %u:%u", s, l.HighPart, l.LowPart / 100000);
		if(l.HighPart == o.HighPart)
			printf(" delta %u\n", (l.LowPart - o.LowPart) / 100000);
		else
			printf(" delta %u:%u\n", l.HighPart - o.HighPart, l.LowPart - o.LowPart);
		o = l;
	} else {
		DWORD dw = GetTickCount();
		printf("%s: %d delta %d\n", s, dw, od - dw);
		od = dw;
	}
}
#else
#define TimeStamp(s)
#endif


void Usage()
{
    printf("Microsoft (R) Message Queue Benchmark Version 1.00\n");
    printf("Copyright (C) Microsoft 1985-1998. All rights reserved.\n\n");

	printf("Usage:\tmqbench [-s[e|r] count size] [-r count size] [-p[f] queue] [-l seconds]\n");
    printf("\t[-x[i|c|s] count] [-t count] [-w] [-o filename worksheet cell] [-f] [-?]\n\n");

    printf("Arguments:\n");
	printf("-se\tsend 'count' express messages of length 'size' (in bytes)\n");
	printf("-sr\tsend 'count' recoverable messages of length 'size' (in bytes)\n");
	printf("-r \treceive 'count' messages of length 'size' (in bytes)\n");
	printf("-xi\tuse 'count' internal transactions\n");
	printf("-xc\tuse 'count' coordinated (DTC) transactions\n");
	printf("-xs\tuse single message transaction\n");
    printf("-a \tasynchronous commit\n");
	printf("-t \trun benchmark using 'count' threads\n");
	printf("-p \tpath name of an existing queue\n");
	printf("-pf\tformat name of an existing queue\n");
	printf("-l \tlimit processing time to 'seconds'\n");
	printf("-w \tstart benchmark at first received message\n");
	printf("-f \toutput resutls to stdout in 1 line format\n");
	printf("-? \tprint this help\n\n");

	printf("e.g., mqbench -sr 100 10  -t 5  -xi 3  -p .\\q1  -o c:\\bench.xls Express C4 \n");
	printf("benchmarks 1500 recoverable messages sent locally using 5 threads and 15 internal transactions and saves it to 'bench.xls' worksheet 'Express' cell 'C4'.\n");
	exit(-1);
}

void ErrorExit(char *pszErrorMsg, HRESULT hr)
{
	printf ("ERROR: %s (0x%x).\n", pszErrorMsg, hr);

    HINSTANCE hLib = LoadLibrary("MQUTIL.DLL");
    if(hLib == NULL)
    {
        exit(-1);
    }

    char* pText;
    DWORD rc;
    rc = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE |
				FORMAT_MESSAGE_FROM_SYSTEM |
				FORMAT_MESSAGE_IGNORE_INSERTS |
				FORMAT_MESSAGE_ALLOCATE_BUFFER |
				FORMAT_MESSAGE_MAX_WIDTH_MASK,
            hLib,
            hr,
            0,
            reinterpret_cast<char*>(&pText),
            0,
            NULL
            );

    if(rc == 0)
    {
        exit(-1);
    }

    printf("%s\n", pText);

	exit(-1);
}

void InitParams()
{
	g_Params.MsgType = MQMSG_DELIVERY_EXPRESS;
	g_Params.Operation = SEND;
	g_Params.TransactionType = NO_TRANSACTION;
	g_Params.ulMsgNumber = 0;
	g_Params.ulTransactionNum = 1;
	g_Params.ulThreadNum = 1;
	g_Params.ulTotalMessages = 0;
	g_Params.ulTotalTransactions = 0;
	g_Params.ulTimeLimit = 0;
	g_Params.wcsQueuePathName[0] = '\0';
	g_Params.ulMsgSize = 0;
	g_Params.fWaitForReceivedMsg = FALSE;
	g_Params.fOperationSpecified = FALSE;
	g_Params.fOneLineFormat = FALSE;
	g_Params.fFormatName = FALSE;
    g_Params.dwCommitFlags = 0;
}

BOOL IsValidParam (int Cur, int ParamNum, char *pszParams[])
{
	if (Cur+1 == ParamNum)
		return FALSE;

    if(*pszParams[Cur+1] == '-')
        return FALSE;

	return TRUE;
}

void GetMsgType(char chMsgType)
{
	switch (chMsgType)
	{
	    case 'e':
		    g_Params.MsgType = MQMSG_DELIVERY_EXPRESS;
		    break;

	    case 'r':
		    g_Params.MsgType = MQMSG_DELIVERY_RECOVERABLE;
		    break;

	    default:
            printf("Invalid message type '%c'.\n\n", chMsgType);
            Usage();
	}
}

void GetMessageParams(int Cur, int ParamNum, char *pszParams[])
{
	//
	// Get number of messages
	//
	if (!IsValidParam (Cur, ParamNum, pszParams))
	{
		printf("Missing number of messages.\n\n");
        Usage();
	}

	g_Params.ulMsgNumber = atol(pszParams[Cur+1]);
	if (g_Params.ulMsgNumber == 0) 
	{
		printf("Invalid number of messages.\n\n");
        Usage();
	}
	
	//
	// Get size of body
	//
	if (!IsValidParam (Cur+1, ParamNum, pszParams))
	{
		printf("Missing message body size.\n\n");
        Usage();
	}

	g_Params.ulMsgSize = atol(pszParams[Cur+2]);
	if (g_Params.ulMsgSize == 0) 
	{
		printf("Invalid message body size.\n\n");
        Usage();
	}
}

int ParseSendParams (int Cur, int ParamNum, char *pszParams[])
{
	if (g_Params.fOperationSpecified)
	{
		printf("Invalid operation. Specify either send or receive.\n\n");
        Usage();
	}
	
	g_Params.Operation = SEND;
	g_Params.fOperationSpecified = TRUE;
	
	//
	// Get message type
	//
	char *pszMsgType = pszParams[Cur];
	GetMsgType ((char)tolower(pszMsgType[1]));
	GetMessageParams (Cur, ParamNum, pszParams);
	
	return Cur + 3;
}

int ParseReceiveParams (int Cur, int ParamNum, char *pszParams[])
{
	if (g_Params.fOperationSpecified)
	{
		printf("Invalid operation. Specify either send or receive.\n\n");
        Usage();
	}
	
	g_Params.Operation = RECEIVE;
	g_Params.fOperationSpecified = TRUE;
	
	GetMessageParams (Cur, ParamNum, pszParams);

	return Cur + 3;
}

int ParsePathParams(int Cur, int ParamNum, char *pszParams[])
{
	if (!IsValidParam(Cur, ParamNum, pszParams))
	{
		printf("Missing queue path name.\n\n");
        Usage();
	}		
	
	if ((strlen(pszParams[Cur]) > 1) &&
		(pszParams[Cur][1] == 'f')) 
	{
		g_Params.fFormatName = TRUE;
	}
	mbstowcs(g_Params.wcsQueuePathName, pszParams[Cur+1], MQ_MAX_Q_NAME_LEN);
	
	return Cur + 2;
}

void GetTransactionType(char chTransactionType)
{
	switch (chTransactionType)
	{
	    case 'i':
		    g_Params.TransactionType = INTERNAL;
		    break;

	    case 'c':
		    g_Params.TransactionType = COORDINATED;
		    break;

	    case 's':
		    g_Params.TransactionType = SINGLE;
		    break;

	    default:
		    printf("Invalid transaction type '%c'.\n\n", chTransactionType);
            Usage();
	}
}

int ParseTransactionParams(int Cur, int ParamNum, char *pszParams[])
{
	//
	// Get transaction type
	//
	char *pszTransactionType = pszParams[Cur];
	GetTransactionType ((char)tolower(pszTransactionType[1]));
	
	//
	// Get number of transaction
	// 
	if(g_Params.TransactionType == SINGLE)
	{
		return Cur + 1;
	}

	if (!IsValidParam (Cur, ParamNum, pszParams))
	{
		printf("Missing number of transactions.\n\n");
        Usage();
	}

	g_Params.ulTransactionNum = atol(pszParams[Cur+1]);
	if (g_Params.ulTransactionNum == 0)
	{
		printf("Invalid number of transactions.\n\n");
        Usage();
	}

	return Cur + 2;
}

int ParseThreadParams(int Cur, int ParamNum, char *pszParams[])
{
	if (!IsValidParam(Cur, ParamNum, pszParams))
	{
		printf("Missing number of threads.\n\n");
        Usage();
	}

	g_Params.ulThreadNum = atol(pszParams[Cur+1]);
	if (g_Params.ulThreadNum == 0)  
	{
		printf("Invalid number of threads.\n\n");
        Usage();
	}

	return Cur + 2;
}

int ParseWaitParams(int Cur)
{
	g_Params.fWaitForReceivedMsg = TRUE;
	return Cur + 1;
}

int ParseFormatParams(int Cur)
{
	g_Params.fOneLineFormat = TRUE;
	return Cur + 1;
}

int ParseAsyncParams(int Cur)
{
	g_Params.dwCommitFlags = XACTTC_ASYNC;
	return Cur + 1;
}


int ParseTimeLimitParams(int Cur, int ParamNum, char *pszParams[])
{
	if (!IsValidParam(Cur, ParamNum, pszParams))
	{
		printf("Missing time limit.\n\n");
        Usage();
	}

	g_Params.ulTimeLimit = atol(pszParams[Cur+1]);
	if (g_Params.ulTimeLimit == 0)  
	{
		printf("Invalid time limit.\n\n");
        Usage();
	}

	return Cur + 2;
}
	
void ParseParams (int ParamNum, char *pszParams[])
{
	if (ParamNum < 6)
	{
		Usage();
	}

	int i = 1;

	while (i < ParamNum)
	{
		if (*pszParams[i] != '-')
		{
			printf("Invalid parameter '%s'.\n\n", pszParams[i]);
            Usage();
		}

		switch (tolower(*(++pszParams[i])))
		{
		    case 's':
			    i = ParseSendParams(i, ParamNum, pszParams);
			    break;

		    case 'r':
			    i = ParseReceiveParams(i, ParamNum, pszParams);
			    break;
		    
		    case 'p':
			    i = ParsePathParams(i, ParamNum, pszParams);
			    break;

		    case 'x':
			    i = ParseTransactionParams(i, ParamNum, pszParams);
			    break;

		    case 't':
			    i = ParseThreadParams(i, ParamNum, pszParams);
			    break;
			    
		    case 'w':
			    i = ParseWaitParams(i);
			    break;

            case 'a':
                i = ParseAsyncParams(i);
                break;

			case 'l':
				i = ParseTimeLimitParams(i, ParamNum, pszParams);
				break;

			case 'f':
				i = ParseFormatParams(i);
				break;

		    case '?':
			    Usage();
			    break;

		    default:
			    printf("Unknown switch '%s'.\n\n", pszParams[i]);
                Usage();
			    break;
		}
	}

	//
	// check parameters
	//
	if (!g_Params.fOperationSpecified)
	{
		printf("Invalid operation. Specify either send or receive.\n\n");
        Usage();
	}

	if (g_Params.wcsQueuePathName[0] == L'\0')
	{
		printf("Missing queue path name.\n\n");
        Usage();
	}
	
	//
	// if time limit is set, then update number of transactions/messages to send to MAX
	//
	if (g_Params.ulTimeLimit > 0) 
	{
		if (g_Params.TransactionType != NO_TRANSACTION) 
		{
			g_Params.ulTransactionNum = LONG_MAX;
		}
		else 
		{
			g_Params.ulMsgNumber = LONG_MAX;
		}
	}
	
#ifdef _DEBUG
	printf("Operation: %d\n", g_Params.Operation);
	printf("Message type: %d\n", g_Params.MsgType);
	printf("Number of messages %lu\n", g_Params.ulMsgNumber);
	printf("Size of message %lu\n", g_Params.ulMsgSize);							
	printf("Queue Path Name: %ls\n", g_Params.wcsQueuePathName);
	printf("Transaction type: %d\n", g_Params.TransactionType);
	printf("Number of transactions: %d\n", g_Params.ulTransactionNum);
	printf("Number of threads: %d\n", g_Params.ulThreadNum);
	printf("Time limit (seconds): %lu\n", g_Params.ulTimeLimit);
#endif
}

void CreateTheQueue()
{
    MQQUEUEPROPS QueueProps;
    MQPROPVARIANT aVariant[10];
    QUEUEPROPID aPropId[10];
    DWORD PropIdCount = 0;
    HRESULT hr;

    PSECURITY_DESCRIPTOR pSecurityDescriptor;


    //
    // Set the PROPID_Q_PATHNAME property
    //
    aPropId[PropIdCount] = PROPID_Q_PATHNAME;
    aVariant[PropIdCount].vt = VT_LPWSTR;
    aVariant[PropIdCount].pwszVal = new WCHAR[MAX_PATH];
    wcscpy(aVariant[PropIdCount].pwszVal, g_Params.wcsQueuePathName);

    PropIdCount++;

    //
    // Set the PROPID_Q_TRANSACTION property
    //
    aPropId[PropIdCount] = PROPID_Q_TRANSACTION;    //PropId
    aVariant[PropIdCount].vt = VT_UI1;     //Type
    aVariant[PropIdCount].bVal = g_Params.TransactionType != NO_TRANSACTION;

    PropIdCount++;

    //
    // Set the PROPID_Q_LABEL property
    //
    aPropId[PropIdCount] = PROPID_Q_LABEL;    //PropId
    aVariant[PropIdCount].vt = VT_LPWSTR;     //Type
    aVariant[PropIdCount].pwszVal = new WCHAR[MAX_PATH];
    wcscpy(aVariant[PropIdCount].pwszVal, L"mqbench test queue"); //Value

    PropIdCount++;

    //
    // Set the MQEUEUPROPS structure
    //
    QueueProps.cProp = PropIdCount;           //No of properties
    QueueProps.aPropID = aPropId;             //Id of properties
    QueueProps.aPropVar = aVariant;           //Value of properties
    QueueProps.aStatus = NULL;                //No error reports

    //
    // No security (default)
    //
    pSecurityDescriptor = NULL;

    //
    // Create the queue
    //	
    WCHAR szFormatNameBuffer[MAX_PATH];
    DWORD dwFormatNameBufferLength = MAX_PATH;
    hr = MQCreateQueue(
            pSecurityDescriptor,            //Security
            &QueueProps,                    //Queue properties
            szFormatNameBuffer,             //Output: Format Name
            &dwFormatNameBufferLength       //Output: Format Name len
            );

    if(FAILED(hr))
    {
        ErrorExit("MQCreateQueue failed", hr);
    }
}


void GetQueueHandle()
{
	HRESULT hr;
	
	DWORD dwFormatNameLength = MAX_PATH;
	WCHAR wcsFormatName[MAX_PATH];

	if (!g_Params.fFormatName) 
	{
		hr= MQPathNameToFormatName(
				g_Params.wcsQueuePathName, 
				wcsFormatName, 
				&dwFormatNameLength
				);

		if (FAILED(hr)) 
		{
			if(hr == MQ_ERROR_QUEUE_NOT_FOUND)
			{
				CreateTheQueue();
				GetQueueHandle();
				return;
			}


			ErrorExit("MQPathNameToFormatName failed", hr);
		}
	}
	else 
	{
		wcscpy(wcsFormatName, g_Params.wcsQueuePathName);
	}

	DWORD dwAccess;
	if (g_Params.Operation == SEND)
	{
		dwAccess = MQ_SEND_ACCESS;
	}
	else
	{
		dwAccess = MQ_RECEIVE_ACCESS;
	}

	hr = MQOpenQueue(
			wcsFormatName,
			dwAccess,
			MQ_DENY_NONE,
			&g_hQueue
			);

	if (FAILED(hr)) 
	{
		ErrorExit("MQOpenQueue failed", hr);
	}
}


void SetMessageProps(MQMSGPROPS *pMessageProps)
{
	assert(pMessageProps->cProp == 3);
	//
	// Set the message body buffer
	//
	assert(pMessageProps->aPropID[0] == PROPID_M_BODY);

	pMessageProps->aPropVar[0].caub.cElems = g_Params.ulMsgSize;
	pMessageProps->aPropVar[0].caub.pElems = new unsigned char[g_Params.ulMsgSize];
	
	if (g_Params.Operation == SEND)
	{
		//
		// Build message body
		//
		memset(pMessageProps->aPropVar[0].caub.pElems, 'a', g_Params.ulMsgSize);
	}

	//
	// Set message body size
	//
	assert(pMessageProps->aPropID[1] == PROPID_M_BODY_SIZE);
	pMessageProps->aPropVar[1].ulVal = g_Params.ulMsgSize;

	//
	// Set message delivery
	//
	assert(pMessageProps->aPropID[2] == PROPID_M_DELIVERY);
	pMessageProps->aPropVar[2].bVal = g_Params.MsgType;

}

void TransactionInit()
{
	HRESULT hr;
	hr = DtcGetTransactionManager ( 
			NULL,						//Host Name
			NULL,						//TmName
			IID_ITransactionDispenser,
			0,							//reserved
			0,							//reserved
			0,							//reserved
			(LPVOID*)&g_pDispenser
			);

	if (FAILED(hr))
	{
		ErrorExit("DtcGetTransactionManager failed", hr);
	}
}

void CreateEvents()
{
	g_hStart = CreateEvent(  
				0,			// no security attributes
				TRUE,		// use manual-reset event
				FALSE,		// event is reset initally
				NULL		// unnamed event
				);

	if (g_hStart == NULL)
	{
		ErrorExit("CreateEvent failed", GetLastError());
	}

	g_hEnd  = CreateEvent(  
				0,			// no security attributes
				TRUE,		// use manual-reset event
				FALSE,		// event is reset initally
				NULL		// unnamed event
				);
	if (g_hEnd == NULL)
	{
		ErrorExit("CreateEvent failed", GetLastError());
	}
}

void GetTime(LONGLONG* pFT)
{
	GetSystemTimeAsFileTime((FILETIME*)pFT);
}


static
HRESULT
DTCBeginTransaction(
	ITransaction** ppXact
	)
{
	return g_pDispenser->BeginTransaction (
						    NULL,                       // IUnknown __RPC_FAR *punkOuter,
						    ISOLATIONLEVEL_ISOLATED,    // ISOLEVEL isoLevel,
						    ISOFLAG_RETAIN_DONTCARE,    // ULONG isoFlags,
						    NULL,                       // ITransactionOptions *pOptions
						    ppXact
						    );
}

ITransaction*
GetTransactionPointer(
	void
	)
{
	ITransaction *pXact;
	HRESULT hr = MQ_OK;
	switch (g_Params.TransactionType)
	{
		case INTERNAL:
			hr = MQBeginTransaction (&pXact);
			break;

		case COORDINATED:
			hr = DTCBeginTransaction(&pXact);
			break;

		case SINGLE:
			pXact = MQ_SINGLE_MESSAGE;
			break;

		case NO_TRANSACTION:
			pXact = MQ_NO_TRANSACTION;
			break;

		default:
			assert(0);
	}

	if (FAILED(hr)) 
	{
		ErrorExit("Can not create transaction", hr);
	}

	return pXact;
}


static
DWORD
APIENTRY
TestThread(
	PVOID /*pv*/
	)
{
	//
	// Properties passed to MQSendMessage or MQReceiveMessage
	//
	const int x_PropCount = 3;

	MSGPROPID MessagePropId[x_PropCount] = {
		PROPID_M_BODY,
		PROPID_M_BODY_SIZE,
		PROPID_M_DELIVERY
	};

	MQPROPVARIANT MessagePropVar[x_PropCount] = {
		{VT_VECTOR | VT_UI1, 0, 0, 0},
		{VT_UI4, 0, 0, 0},
		{VT_UI1, 0, 0, 0}
	};

	MQMSGPROPS MessageProperties = {
		x_PropCount,
		MessagePropId,
		MessagePropVar,
		0
	};
	
	SetMessageProps( &MessageProperties);

	if(InterlockedDecrement(&g_ThreadCounter) == 0)
	{
		//
		// Last test thread sample start time, and enable all test
		// threads to run.
		//
		GetTime(&g_StartTime);
		g_ThreadCounter = g_Params.ulThreadNum;
		SetEvent(g_hStart);
	}

	//
	// Synchronize all threads to wait for a start signal
	//
	WaitForSingleObject(g_hStart, INFINITE);

	HRESULT hr;
	BOOL fBreak = FALSE;
	ULONG ulTotalMsgCount = 0;
	ULONG ulTotalTransCount = 0;
	ULONG ulTransCount = 0;
	ULONG ulMsgCount = 0;

	for (	ulTransCount = 0; 
			ulTransCount < g_Params.ulTransactionNum; 
			ulTransCount++ )
	{
		//
		//BeginTransaction
		//
		ITransaction* pXact = GetTransactionPointer();

		//
		// Send/Receive Messages
		//
		for (	ulMsgCount=0; 
				ulMsgCount < g_Params.ulMsgNumber; 
				ulMsgCount++)
		{
			if (g_Params.Operation == SEND)
			{
				hr = MQSendMessage(	
						g_hQueue,
						&MessageProperties,
						pXact
						);

				if (FAILED(hr)) 
				{
					ErrorExit("MQSendMessage failed", hr);
				}

				if (g_fStop && !fBreak)
				{
					fBreak = TRUE;
					memset(MessageProperties.aPropVar[0].caub.pElems, 's', g_Params.ulMsgSize);
					ulMsgCount = g_Params.ulMsgNumber - 2;
				}
			}
			else
			{
				hr = MQReceiveMessage(
						g_hQueue,
						INFINITE,			//dwTimeout
						MQ_ACTION_RECEIVE,  //dwAction,
						&MessageProperties,
						NULL,				//IN OUT LPOVERLAPPED lpOverlapped,
						NULL,				//IN PMQRECEIVECALLBACK fnReceiveCallback,
						NULL,				//IN HANDLE hCursor,
						pXact
						);

				if (FAILED(hr)) 
				{
					ErrorExit("MQReceiveMessage failed", hr);
				}

				if(g_Params.fWaitForReceivedMsg && !g_fTimerStarted)
				{
					//
					//	Start time is sampled after first receive, only by the
					//  first thread.
					//
					if(InterlockedExchange((LONG *)&g_fTimerStarted, TRUE) == FALSE)
					{
						GetTime(&g_StartTime);
					}
				}

				if (MessageProperties.aPropVar[0].caub.pElems[0] == 's')
				{
					ulMsgCount = g_Params.ulMsgNumber - 1;
					fBreak = TRUE;
				}
			}

			ulTotalMsgCount++;
		}
		
		if (g_Params.TransactionType == INTERNAL || 
			g_Params.TransactionType == COORDINATED ) 
		{
			hr = pXact->Commit(0, g_Params.dwCommitFlags, 0);
			if (FAILED(hr))
			{
				ErrorExit("Commit failed", hr);
			}
			pXact->Release();

			ulTotalTransCount++;
		}
		if (fBreak)
		{
			break;
		}
	}

	InterlockedExchangeAdd( (PLONG)&g_Params.ulTotalMessages, ulTotalMsgCount);
	InterlockedExchangeAdd( (PLONG)&g_Params.ulTotalTransactions, ulTotalTransCount);

	//
	// Last thread sample end time and signal main thread to continue.
	//
	if(InterlockedDecrement(&g_ThreadCounter) == 0)
	{
		GetTime(&g_EndTime);
		SetEvent(g_hEnd);
	}

	return 0;
}


void RunTest()
{
	//
	// Set thread counter to control TestThread.
	//
	g_ThreadCounter = g_Params.ulThreadNum;
	g_fStop = FALSE;

	for(UINT i = 0; i < g_Params.ulThreadNum; i++)
	{
		HANDLE hThread;
		DWORD dwThreadId;
		hThread = CreateThread(
					NULL,		// no thread security attributes
					0,			// use default thread stack size
					TestThread, // the thread function
					0,			// no arguments for the new thread
					0,			// creation flags, create running thread
					&dwThreadId	// thread identifier
					);
		if (hThread == NULL)
		{
			ErrorExit("Create Thread failed", GetLastError());
		}
 
		CloseHandle(hThread);
	}

	//
	// Wait for all test threads to complete
	//
	if (g_Params.ulTimeLimit > 0 && g_Params.Operation == SEND)
	{
		if (WaitForSingleObject(g_hEnd, g_Params.ulTimeLimit * 1000) == WAIT_TIMEOUT) 
		{
			g_fStop = TRUE;
			WaitForSingleObject(g_hEnd, INFINITE);
		}
	}
	else
	{
		WaitForSingleObject(g_hEnd, INFINITE);
	}
}

void ResultOutput()
{
	//
	// convert to seconds
	//
	float Time = ((float)(g_EndTime - g_StartTime)) / 10000000;
	float Benchmark = g_Params.ulTotalMessages / Time;
	float Throughput = g_Params.ulTotalMessages * g_Params.ulMsgSize / Time;
	
	if (g_Params.fOneLineFormat) 
	{
		char cXactType;
		switch(g_Params.TransactionType) 
		{
			case NO_TRANSACTION: 
				cXactType = 'N';
				break;	
			case INTERNAL: 
				cXactType = 'I';
				break;
			case COORDINATED:
				cXactType = 'C';
				break;
			case SINGLE:
				cXactType = 'S';
				break;
		}

		printf( "%s %c %c%7lu%7lu%7lu%7lu%7lu\t%.3f\t%.0f\t%.0f\n",
				(g_Params.Operation == SEND) ? "Send" : "Recv",
				(g_Params.MsgType == MQMSG_DELIVERY_EXPRESS) ? 'E' : 'R',
				cXactType,
				g_Params.ulTotalMessages,
				g_Params.ulTotalTransactions,
				g_Params.ulMsgSize,
				(g_Params.TransactionType != NO_TRANSACTION) ? g_Params.ulMsgNumber : 0,
				g_Params.ulThreadNum,
				Time,
				Benchmark,
				Throughput);
	}
	else 
	{
		printf("\nTotal messages:\t%lu %s\n", g_Params.ulTotalMessages, 
				(g_Params.Operation == SEND) ? "Sent" : "Received");
		printf("Test time:\t%.3f seconds\n", Time);
		printf("Benchmark:\t%.0f messages per second\n", Benchmark);
		printf("Throughput:\t%.0f bytes per second\n", Throughput);
	}

}

void InitTest()
{
	GetQueueHandle();
	if (g_Params.TransactionType == COORDINATED)
	{
		TransactionInit();
	}

	CreateEvents();
}

void FinitTest()
{
	MQCloseQueue(g_hQueue);
	CloseHandle(g_hStart);
	CloseHandle(g_hEnd);
	if(g_pDispenser != NULL)
	{
		g_pDispenser->Release();
	}
}

void main(int argc, char *argv[])
{
	InitParams();
	ParseParams(argc, argv);
	InitTest();
	RunTest();
	FinitTest();
	ResultOutput();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\mqforgn\mqforgn.cpp ===
/*++

Copyright (c) 1995-99 Microsoft Corporation. All rights reserved

Module Name:
    mqforgn.cpp

Abstract:
    Command line utility to create a foreign computer and foreign CN (Site)

Author:
    RaphiR

Environment:
	Platform-independent.

--*/

#define  FORGN_EXPIRATION_MONTH  10

#pragma warning(disable: 4201)
#pragma warning(disable: 4514)
#include "_stdafx.h"

//#define INITGUID

#include <string.h>
#include <stdio.h>
#include <windows.h>
#include <assert.h>

#include "cmnquery.h"
#include "dsquery.h"

#include "mqsymbls.h"
#include "mqprops.h"
#include "mqtypes.h"
#include "mqcrypt.h"
#include "mqsec.h"
#include "_propvar.h"
#include "_rstrct.h"
#include "ds.h"
#include "_mqdef.h"
#include "rt.h"
#include "_guid.h"
#include "admcomnd.h"
#include "mqfrgnky.h"
#include "..\..\inc\version.h"

HRESULT  CreateEveryoneSD( PSECURITY_DESCRIPTOR  *ppSD ) ;

/*=================================================

              T I M E     B O M B

 ==================================================*/

#include <time.h>
void TimeBomb()
{

     //
     // Get Current time
     //
     time_t utcTime = time( NULL );

     struct tm BetaRTM =      { 0, 0, 0, 15,  2 -1, 99 };  // Feb. 15, 1999
     struct tm BetaExp =      { 0, 0, 0, 15,  FORGN_EXPIRATION_MONTH -1, 99 };  // oct 15, 1999
     struct tm Warning =      { 0, 0, 0,  1,  FORGN_EXPIRATION_MONTH -1, 99 };  // Oct  1, 1999


     time_t utcBetaRTM =   mktime(&BetaRTM);
     time_t utcBetaExp =   mktime(&BetaExp);
     time_t utcWarning =   mktime(&Warning);


     if(utcTime > utcBetaExp)
     {
		 printf("This demo program has expired\n");
		 exit(0);
     }

     else if(utcTime > utcWarning)
     {
         printf("*** Warning - This demo program will expire on Oct 15, 1999 ***\n\n");
     }

}


//-------------------------------
//
//CheckNT4Enterprise()
//
//	Check that we run in an NT4 enterprise.
//  Exit if fail.
//
//-------------------------------
void CheckNT4Enterprise()
{
    HANDLE hQuery;
    HRESULT rc;
    PROPVARIANT result[2];
    DWORD dwPropCount = 2;

    CColumns AttributeColumns;

    AttributeColumns.Add(PROPID_E_NAME);
	AttributeColumns.Add(PROPID_E_VERSION);

    rc = DSLookupBegin(0, NULL, AttributeColumns.CastToStruct(), 0, &hQuery);

    if (SUCCEEDED(rc))
    {
        rc = DSLookupNext( hQuery, &dwPropCount, result);

        if (SUCCEEDED(rc))
        {
			DWORD version = result[1].uiVal;

			if(version != 3)
			{
				printf("Error - this utility can be run only in a Windows NT4 MSMQ environment.\n");
				exit(0);
			}
        }

        DSLookupEnd(hQuery);
    }

}

//-------------------------------
//
//Usage()
//
//-------------------------------

void Usage()
{
	printf(
    "Usage:\n  mqforgn [ -crcn | -opce | -rmcn | -addcn | -crcomp | -rmcomp | -pbkey ]\n\n");
	
    printf("Arguments:\n");
	
	printf("-crcn <CN Name>\tCreate a foreign CN (connected netword)\n");
	printf("-opce <CN Name>\n\tGrant everyone the permission to open the connector queue.\n");
	printf("-rmcn <CN Name>\tRemove a foreign CN \n");
	printf("-addcn  <CompName> <CN Name>\n") ;
    printf("\tAdd a foreign CN to a computer (Routing Server or foreign computer)\n");
	printf("-delcn  <CompName> <CN Name> \tRemove the foreign CN from the computer\n");
	printf("-crcomp <CompName> <SiteName> <CN Name>\tAdd a foreign computer\n");
	printf("-rmcomp <CompName>\tRemove the foreign computer\n");
	printf("-pbkey  <Machine Name> <Key Name>\n") ;
    printf("\tInsert public key in msmqConfiguration object of a foreign machine.\n");

	printf("-? \tprint this help\n\n");

	printf("e.g., mqforgn -crcomp MyComp ThisSite ForCN\n");
	printf("Creates a foreign computer named \"MyComp\" in the site \"ThisSite\", and connected to the foreign CN \"ForCN\"\n");
	printf("...or: mqforgn -crcomp MyComp {Site-Guid} {CN-Guid}\n");
	exit(-1);
}

//-------------------------------
//
//CheckArgNo()
//	
//	Exits if wrong number of arguments
//
//-------------------------------
void CheckArgNo(DWORD argno, DWORD dwRequiredArg)
{
	if(argno != dwRequiredArg + 2)
	{
		printf("*** Error: Wrong number of arguments\n\n");
		exit(-1);
	}

}

//-------------------------------
//
//ErrorExit()
//	
//	Display a user-readable error and exit
//
//-------------------------------
void ErrorExit(char *pszErrorMsg, HRESULT hr)
{

  HINSTANCE hLib = LoadLibrary(L"MQUTIL.DLL");
    if(hLib == NULL)
    {
        exit(-1);
    }

    WCHAR * pText;
    DWORD rc;
    rc = FormatMessage(
                FORMAT_MESSAGE_FROM_HMODULE    |
                FORMAT_MESSAGE_FROM_SYSTEM     |
                FORMAT_MESSAGE_IGNORE_INSERTS  |
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_MAX_WIDTH_MASK,
                hLib,
                hr,
                0,
                reinterpret_cast<WCHAR *>(&pText),
                0,
                NULL
                );
    if(rc == 0)
    {
        printf ("Error (0x%x)\n", hr) ;
        exit(-1);
    }

    printf ("Error (0x%x): %S\n", hr, pText);
	exit(hr);
}





//-------------------------------
//
//GetSiteGuid()
//	
// Retrieve a Site Guid based on its name
//
//-------------------------------
HRESULT GetSiteGuid(LPWSTR pwszSiteName, GUID * * ppGuid)
{
	
    PROPID aProp[] = {PROPID_S_PATHNAME,
					  PROPID_S_SITEID};
					
    PROPVARIANT apVar[sizeof(aProp) / sizeof(aProp[0])];

    UINT uiPropIndex = 0;

    //
    // PROPID_S_PATHNAME
    //
    ASSERT(aProp[uiPropIndex] == PROPID_S_PATHNAME);
    apVar[uiPropIndex].vt = VT_NULL;

    uiPropIndex++;


    //
    // PROPID_S_SITEID
    //
    ASSERT(aProp[uiPropIndex] == PROPID_S_SITEID);
    apVar[uiPropIndex].vt = VT_NULL;

    uiPropIndex++;

	
	HRESULT hr = DSGetObjectProperties(MQDS_SITE, pwszSiteName, uiPropIndex,aProp,apVar);

	if(FAILED(hr))
		return(hr);



    ASSERT(aProp[1] == PROPID_S_SITEID);
	*ppGuid = apVar[1].puuid;

	return hr;


}

//-------------------------------
//
//GetCNGuid()
//	
// Retrieve a CN Foreign Guid based on its NAME
//
//-------------------------------
HRESULT GetCNGuid(LPWSTR pwszCNName, GUID * * ppGuid)
{
    PROPID aProp[] = { PROPID_CN_NAME,
					   PROPID_CN_GUID,
                       PROPID_CN_PROTOCOLID } ;

    PROPVARIANT apVar[sizeof(aProp) / sizeof(aProp[0])];

    UINT uiPropIndex = 0;

    //
    // PROPID_CN_NAME
    //
    ASSERT(aProp[uiPropIndex] == PROPID_CN_NAME);
    apVar[uiPropIndex].vt = VT_NULL;

    uiPropIndex++;

	
    //
    // PROPID_CN_GUID
    //
    ASSERT(aProp[uiPropIndex] == PROPID_CN_GUID);
    apVar[uiPropIndex].vt = VT_NULL;
    UINT uiGuidIndex = uiPropIndex ;

    uiPropIndex++;

    //
    // PROPID_CN_PROTOCOLID
    //
    ASSERT(aProp[uiPropIndex] == PROPID_CN_PROTOCOLID);
    apVar[uiPropIndex].vt = VT_NULL;
    UINT uiProtocolIdIndex = uiPropIndex ;

    uiPropIndex++;

	HRESULT hr = DSGetObjectProperties(MQDS_CN,pwszCNName, uiPropIndex,aProp,apVar);

	if (FAILED(hr))
    {
		return(hr);
    }

	//
	// Check if foreign GUID
	//
    ASSERT(aProp[ uiProtocolIdIndex ] == PROPID_CN_PROTOCOLID);
	if (apVar[ uiProtocolIdIndex ].bVal != FOREIGN_ADDRESS_TYPE)
    {
		return(MQ_ERROR_ILLEGAL_OPERATION);
    }

    ASSERT( aProp[uiGuidIndex ] == PROPID_CN_GUID);
	*ppGuid = apVar[ uiGuidIndex ].puuid;

	return hr;
}

//-------------------------------
//
//  OpenConnectorToEveryone()
//	
//-------------------------------

HRESULT OpenConnectorToEveryone( IN LPWSTR  pwszForeignCN )
{
   PSECURITY_DESCRIPTOR pSD = NULL ;

   HRESULT hr = CreateEveryoneSD( &pSD ) ;

   if (FAILED(hr))
   {
       return hr ;
   }

   hr = DSSetObjectSecurity( MQDS_CN,
                             pwszForeignCN,
                             DACL_SECURITY_INFORMATION,
                             pSD ) ;
   return hr ;
}

//-------------------------------
//
//CreateForeignCN()
//	
//-------------------------------

HRESULT CreateForeignCN( IN LPWSTR  pwszForeignCN )
{
    PROPID  aProp[] = {PROPID_CN_GUID, PROPID_CN_NAME, PROPID_CN_PROTOCOLID};

    PROPVARIANT apVar[sizeof(aProp) / sizeof(aProp[0])];

    HRESULT hr = MQ_OK;
    UINT    uiCurVar = 0;

    //
    // PROPID_CN_GUID
    //
    GUID guidInstance;
    apVar[uiCurVar].vt = VT_CLSID;
    UuidCreate(&guidInstance);
    apVar[uiCurVar++].puuid = &guidInstance;

    //
    // PROPID_CN_NAME
    //
    apVar[uiCurVar].vt = VT_LPWSTR;
    apVar[uiCurVar++].pwszVal = pwszForeignCN;

    //
    // PROPID_CN_PROTOCOLID
    //
    apVar[uiCurVar].vt = VT_UI1;
    apVar[uiCurVar++].uiVal = FOREIGN_ADDRESS_TYPE;

    hr = DSCreateObject( MQDS_CN,
                         pwszForeignCN,
                         NULL,
                         sizeof(aProp) / sizeof(aProp[0]),
                         aProp,
                         apVar,
                         NULL ) ;
    return hr;
}

//-------------------------------
//
//AddForeignCN()
//	
//-------------------------------

HRESULT AddForeignCN(LPWSTR pwszCompName, LPWSTR pwszCNName)
{
    PROPID  aProp[] = {PROPID_QM_PATHNAME, PROPID_QM_MACHINE_ID,
					   PROPID_QM_SERVICE, PROPID_QM_CNS, PROPID_QM_ADDRESS,
                       PROPID_QM_FOREIGN, PROPID_QM_OS};

    PROPVARIANT apVar[sizeof(aProp) / sizeof(aProp[0])];
	UINT uiPropIndex = 0;

    HRESULT hr = MQ_OK;

	GUID *pguidCN;

	hr = GetCNGuid(pwszCNName, &pguidCN);
	if(FAILED(hr))
		return(hr);

    //
    // PROPID_QM_PATHNAME
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_MACHINE_ID
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;


    //
    // PROPID_QM_SERVICE
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_CNS
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_ADDRESS
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_FOREIGN
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_OS
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;


	hr = DSGetObjectProperties(MQDS_MACHINE,pwszCompName, uiPropIndex,aProp,apVar);

	//
	// Check foreign machine of FRS
	//
    ASSERT(aProp[5] == PROPID_QM_FOREIGN);
	ASSERT(aProp[2] == PROPID_QM_SERVICE);
	if(apVar[5].bVal != 1 && apVar[2].ulVal < SERVICE_SRV)
		return(MQ_ERROR_ILLEGAL_OPERATION);

	//
	// Add the CN to list of existing CN
	//
    ASSERT(aProp[4] == PROPID_QM_ADDRESS);
	ASSERT(aProp[3] == PROPID_QM_CNS);

	DWORD dwCnCount = apVar[3].cauuid.cElems + 1;
	GUID  * aguidCns = new GUID[dwCnCount];

	for(DWORD i = 0; i < dwCnCount - 1; i++)
	{
		aguidCns[i] = apVar[3].cauuid.pElems[i];
	}
	aguidCns[i] = *pguidCN;

	//
	// Add address to list of existing addresses
	//
	DWORD dwAddressSize = apVar[4].blob.cbSize + (TA_ADDRESS_SIZE + FOREIGN_ADDRESS_LEN);
	BYTE * blobAddress = new BYTE[dwAddressSize];

	memcpy(blobAddress, apVar[4].blob.pBlobData, apVar[4].blob.cbSize);
	BYTE * pAddress = blobAddress + apVar[4].blob.cbSize;
    ((TA_ADDRESS *)pAddress)->AddressLength = FOREIGN_ADDRESS_LEN;
    ((TA_ADDRESS *)pAddress)->AddressType = FOREIGN_ADDRESS_TYPE;
    *(GUID *)&((TA_ADDRESS *)pAddress)->Address = *pguidCN;


	//
	// Set the new CN/Address properties
	//
    PROPID  aPropSet[] = {PROPID_QM_CNS, PROPID_QM_ADDRESS};

    PROPVARIANT apVarSet[sizeof(aPropSet) / sizeof(aPropSet[0])];
	
	uiPropIndex = 0;

    //
    // PROPID_QM_CNS
    //
    apVarSet[uiPropIndex].vt = VT_CLSID|VT_VECTOR;
    apVarSet[uiPropIndex].cauuid.cElems = dwCnCount;
    apVarSet[uiPropIndex].cauuid.pElems = aguidCns;

    uiPropIndex++;

    //
    // PROPID_QM_ADDRESS - Updated only in case of foreign,
    // and then contains the foreign CN guids.
    //
    apVarSet[uiPropIndex].vt = VT_BLOB;
    apVarSet[uiPropIndex].blob.cbSize = dwAddressSize;
    apVarSet[uiPropIndex].blob.pBlobData = blobAddress;

    uiPropIndex++;


	hr = DSSetObjectProperties(MQDS_MACHINE, pwszCompName, uiPropIndex, aPropSet,apVarSet);

    return hr;
}


//-------------------------------
//
//DelForeignCN()
//	
//-------------------------------
HRESULT DelForeignCN(LPWSTR pwszCompName, LPWSTR pwszCNName)
{
    PROPID  aProp[] = {PROPID_QM_PATHNAME, PROPID_QM_MACHINE_ID,
					   PROPID_QM_SERVICE, PROPID_QM_CNS, PROPID_QM_ADDRESS,
                       PROPID_QM_FOREIGN, PROPID_QM_OS};

    PROPVARIANT apVar[sizeof(aProp) / sizeof(aProp[0])];
	UINT uiPropIndex = 0;

    HRESULT hr = MQ_OK;

	GUID *pguidCN;

	hr = GetCNGuid(pwszCNName, &pguidCN);
	if(FAILED(hr))
		return(hr);

    //
    // PROPID_QM_PATHNAME
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_MACHINE_ID
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_SERVICE
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_CNS
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_ADDRESS
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_FOREIGN
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_OS
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;


	hr = DSGetObjectProperties(MQDS_MACHINE,pwszCompName, uiPropIndex,aProp,apVar);

	//
	// Check foreign machine or FRS
	//
    ASSERT(aProp[5] == PROPID_QM_FOREIGN);
	ASSERT(aProp[2] == PROPID_QM_SERVICE);
	if(apVar[5].bVal != 1 && apVar[2].ulVal < SERVICE_SRV)
		return(MQ_ERROR_ILLEGAL_OPERATION);

	//
	// If last CN refuse the operation
	//
	ASSERT(aProp[3] == PROPID_QM_CNS);
	if(apVar[3].cauuid.cElems <= 1)
		return(MQ_ERROR);


	//
	// Delete the CN to list of existing CN and addresses
	//
    ASSERT(aProp[4] == PROPID_QM_ADDRESS);
	ASSERT(aProp[3] == PROPID_QM_CNS);

	GUID  * aguidCns = new GUID[apVar[3].cauuid.cElems];

	BYTE * blobAddress = new BYTE[apVar[4].blob.cbSize];
	BYTE * pSrcAddress = apVar[4].blob.pBlobData;
	BYTE * pDstAddress = blobAddress;

	for(DWORD i = 0, j = 0; i < apVar[3].cauuid.cElems; i++)
	{
		DWORD dwAddrSize = TA_ADDRESS_SIZE + ((TA_ADDRESS *)pSrcAddress)->AddressLength;

		if(apVar[3].cauuid.pElems[i] == *pguidCN)
		{
			pSrcAddress += dwAddrSize;
			continue;
		}

		aguidCns[j] = apVar[3].cauuid.pElems[i];
		j++;
	
		memcpy(pDstAddress, pSrcAddress, dwAddrSize);
		pDstAddress += dwAddrSize;
		pSrcAddress += dwAddrSize;

	}

	if(i == j)
	{
		//
		// The CN is not in the list
		//
		return(MQ_ERROR_ILLEGAL_OPERATION);
	}

	DWORD dwCnCount = j;
	DWORD dwAddressSize = pDstAddress - blobAddress;

	//
	// Set the new CN/Address properties
	//
    PROPID  aPropSet[] = {PROPID_QM_CNS, PROPID_QM_ADDRESS};

    PROPVARIANT apVarSet[sizeof(aPropSet) / sizeof(aPropSet[0])];
	
	uiPropIndex = 0;

    //
    // PROPID_QM_CNS
    //
    apVarSet[uiPropIndex].vt = VT_CLSID|VT_VECTOR;
    apVarSet[uiPropIndex].cauuid.cElems = dwCnCount;
    apVarSet[uiPropIndex].cauuid.pElems = aguidCns;

    uiPropIndex++;

    //
    // PROPID_QM_ADDRESS - Updated only in case of foreign,
    // and then contains the foreign CN guids.
    //
    apVarSet[uiPropIndex].vt = VT_BLOB;
    apVarSet[uiPropIndex].blob.cbSize = dwAddressSize;
    apVarSet[uiPropIndex].blob.pBlobData = blobAddress;

    uiPropIndex++;


	hr = DSSetObjectProperties(MQDS_MACHINE, pwszCompName, uiPropIndex, aPropSet,apVarSet);

    return hr;
}


//-------------------------------
//
//CreateForeignComputer()
//	
//-------------------------------
HRESULT CreateForeignComputer( LPWSTR pwszCompName,
                               LPWSTR pwszSiteName,
                               LPWSTR pwszCNName )
{
    PROPID  aProp[] = { PROPID_QM_PATHNAME,
                        PROPID_QM_MACHINE_ID,
                        PROPID_QM_SITE_ID,
                        PROPID_QM_SERVICE,
                        PROPID_QM_CNS,
                        PROPID_QM_ADDRESS,
                        PROPID_QM_INFRS,
                        PROPID_QM_OUTFRS,
                        PROPID_QM_FOREIGN,
                        PROPID_QM_OS };

    PROPVARIANT apVar[sizeof(aProp) / sizeof(aProp[0])];
	UINT uiPropIndex = 0;

    HRESULT hr = MQ_OK;

    WCHAR  wszGuid[ 128 ] ;
    GUID SiteGuid ;
	GUID *pguidSite;
    GUID CNGuid ;
	GUID *pguidCN;

	BYTE  Address[TA_ADDRESS_SIZE + FOREIGN_ADDRESS_LEN];

    if ((pwszSiteName[0] == L'{') && (wcslen(pwszSiteName) < 100))
    {
        wcscpy( wszGuid, &pwszSiteName[1] ) ;
        ULONG ul = wcslen(wszGuid) ;
        wszGuid[ ul-1 ] = 0 ;

        RPC_STATUS status = UuidFromString( wszGuid, &SiteGuid ) ;
        if (status != RPC_S_OK)
        {
            return HRESULT_FROM_WIN32(status) ;
        }

        pguidSite = &SiteGuid ;
    }
    else
    {
    	hr = GetSiteGuid(pwszSiteName, &pguidSite);
	    if(FAILED(hr))
		    return(hr);
    }

    if ((pwszCNName[0] == L'{') && (wcslen(pwszCNName) < 100))
    {
        wcscpy( wszGuid, &pwszCNName[1] ) ;
        ULONG ul = wcslen(wszGuid) ;
        wszGuid[ ul-1 ] = 0 ;

        RPC_STATUS status = UuidFromString( wszGuid, &CNGuid ) ;
        if (status != RPC_S_OK)
        {
            return HRESULT_FROM_WIN32(status) ;
        }

        pguidCN = &CNGuid ;
    }
    else
    {
    	hr = GetCNGuid(pwszCNName, &pguidCN);
	    if(FAILED(hr))
		    return(hr);
    }

    ((TA_ADDRESS *)Address)->AddressLength = FOREIGN_ADDRESS_LEN;
    ((TA_ADDRESS *)Address)->AddressType = FOREIGN_ADDRESS_TYPE;
    *(GUID *)&((TA_ADDRESS *)Address)->Address = *pguidCN;

    //
    // PROPID_QM_PATHNAME
    //
    apVar[uiPropIndex].vt = VT_LPWSTR;
    apVar[uiPropIndex].pwszVal = pwszCompName;

    uiPropIndex++;

    //
    // PROPID_QM_MACHINE_ID
    //
    GUID guidInstance;
    apVar[uiPropIndex].vt = VT_CLSID;
    UuidCreate(&guidInstance);
    apVar[uiPropIndex].puuid = &guidInstance;

    uiPropIndex++;

    //
    // PROPID_QM_SITE_ID
    //
    apVar[uiPropIndex].vt = VT_CLSID;
    apVar[uiPropIndex].puuid = pguidSite;

    uiPropIndex++;

    //
    // PROPID_QM_SERVICE
    //
    apVar[uiPropIndex].vt = VT_UI4;
    apVar[uiPropIndex].ulVal = SERVICE_NONE;

    uiPropIndex++;

    //
    // PROPID_QM_CNS - has value only for foreign machine
    //
    apVar[uiPropIndex].vt = VT_CLSID|VT_VECTOR;
    apVar[uiPropIndex].cauuid.cElems = 1;
    apVar[uiPropIndex].cauuid.pElems = pguidCN;

    uiPropIndex++;

    //
    // PROPID_QM_ADDRESS - Updated only in case of foreign,
    // and then contains the foreign CN guids. Update of "real" machine
    // is done only by changing the machine's properties.
    //
    apVar[uiPropIndex].vt = VT_BLOB;
    apVar[uiPropIndex].blob.cbSize = sizeof(Address);
    apVar[uiPropIndex].blob.pBlobData = &Address[0];

    uiPropIndex++;

    //
    // PROPID_QM_INFRS
    //
    apVar[uiPropIndex].vt = VT_CLSID | VT_VECTOR;
    apVar[uiPropIndex].cauuid.cElems = 0;
    apVar[uiPropIndex].cauuid.pElems = NULL;

    uiPropIndex++;

    //
    // PROPID_QM_OUTFRS
    //
    apVar[uiPropIndex].vt = VT_CLSID | VT_VECTOR;
    apVar[uiPropIndex].cauuid.cElems = 0;
    apVar[uiPropIndex].cauuid.pElems = NULL;

    uiPropIndex++;

    //
    // PROPID_QM_FOREIGN
    //
    apVar[uiPropIndex].vt = VT_UI1;
    apVar[uiPropIndex].bVal = TRUE;

    uiPropIndex++;

    //
    // PROPID_QM_OS
    //
    apVar[uiPropIndex].vt = VT_UI4;
    apVar[uiPropIndex].ulVal = MSMQ_OS_FOREIGN;

    uiPropIndex++;

    hr = DSCreateObject( MQDS_MACHINE,
                         pwszCompName,
                         0,
                         sizeof(aProp) / sizeof(aProp[0]),
                         aProp,
                         apVar,
                         NULL );

    return hr;
}

//-------------------------------
//
//DeleteForeignCN()
//	
//-------------------------------
HRESULT DeleteForeignCN(LPWSTR pwszCNName)
{
	HRESULT hr;

	hr = DSDeleteObject(MQDS_CN,pwszCNName);

	return(hr);

}


//-------------------------------
//
//DeleteForeignComputer()
//	
//-------------------------------
HRESULT DeleteForeignComputer(LPWSTR pwszSiteName)
{
	HRESULT hr;

	hr = DSDeleteObject(MQDS_MACHINE, pwszSiteName);

	return(hr);
}

//+-----------------------------------------------------
//
//  HRESULT  StorePbkeyOnForeignMachine()
//
//+-----------------------------------------------------

HRESULT  StorePbkeyOnForeignMachine( WCHAR *pwszMachineName,
                                     WCHAR *pwszKeyName )
{
    HINSTANCE hLib = LoadLibrary(TEXT("mqfrgnky.dll")) ;
    if (!hLib)
    {
        DWORD dwErr = GetLastError() ;
        return HRESULT_FROM_WIN32(dwErr) ;
    }

    MQFrgn_StorePubKeysInDS_ROUTINE pfnStore =
         (MQFrgn_StorePubKeysInDS_ROUTINE)
                        GetProcAddress(hLib, "MQFrgn_StorePubKeysInDS") ;
    if (!pfnStore)
    {
        FreeLibrary(hLib) ;
        DWORD dwErr = GetLastError() ;
        return HRESULT_FROM_WIN32(dwErr) ;
    }

    HRESULT hr = (*pfnStore) ( pwszMachineName,
                               pwszKeyName,
                               TRUE ) ;
    FreeLibrary(hLib) ;
    return hr ;
}

#define CREATE_CN	              1
#define REMOVE_CN	              2
#define	ADD_CN		              3
#define DEL_CN		              4
#define CREATE_COMP	              5
#define REMOVE_COMP	              6
#define STORE_FORGN_PBKEY         7
#define OPEN_CONNECOTR_EVERYONE   8

//-------------------------------
//
//main()
//	
//-------------------------------

void main(int argc, char * * argv)
{
    DWORD   gAction = 0;
    WCHAR   szCNName[100], szMachineName[100], szSiteName[100];
    WCHAR   wszKeyName[ 100 ] ;
    HRESULT hr = 0;
    BOOL    fCheckNt4Ver = TRUE ;

    //
    // Print Title
    //
    printf("MSMQ Foreign objects utility. Release Version, 1.0.%u\n\n", rup);

    //
    // Check Time Bomb
    //
    // TimeBomb();


   //
   // Parse parameters
   //
   for(int i=1; i < argc; i++)
   {

      if(_stricmp(argv[i], "-crcn") == 0)
      {
		 CheckArgNo(argc, 1);
         gAction = CREATE_CN;
		 i++;
	     swprintf(szCNName, L"%S", argv[i]);

         fCheckNt4Ver = FALSE ;
         continue;
      }

      if(_stricmp(argv[i], "-opce") == 0)
      {
		 CheckArgNo(argc, 1);
         gAction = OPEN_CONNECOTR_EVERYONE ;
		 i++;
	     swprintf(szCNName, L"%S", argv[i]);

         fCheckNt4Ver = FALSE ;
         continue;
      }

      if(_stricmp(argv[i], "-rmcn") == 0)
      {
		 CheckArgNo(argc, 1);
         gAction = REMOVE_CN;
		 i++;
	     swprintf(szCNName, L"%S", argv[i]);

         continue;
      }

      if(_stricmp(argv[i], "-addcn") == 0)
      {
		 CheckArgNo(argc, 2);
		 gAction = ADD_CN;
         i++;
	     swprintf(szMachineName, L"%S", argv[i]);

		 i++;
	     swprintf(szCNName, L"%S", argv[i]);

         continue;
      }

	  if(_stricmp(argv[i], "-delcn") == 0)
      {
		 CheckArgNo(argc, 2);
    	 gAction = DEL_CN;
         i++;
	     swprintf(szMachineName, L"%S", argv[i]);

		 i++;
	     swprintf(szCNName, L"%S", argv[i]);

         continue;
      }

      if(_stricmp(argv[i], "-rmcomp") == 0)
      {
		 CheckArgNo(argc, 1);
		 gAction = REMOVE_COMP;
		 i++;
	     swprintf(szMachineName, L"%S", argv[i]);
         continue;
      }

      if(_stricmp(argv[i], "-crcomp") == 0)
      {
		 CheckArgNo(argc, 3);
		 gAction = CREATE_COMP;
         i++;
	     swprintf(szMachineName, L"%S", argv[i]);

		 i++;
	     swprintf(szSiteName, L"%S", argv[i]);

		 i++;
	     swprintf(szCNName, L"%S", argv[i]);

         fCheckNt4Ver = FALSE ;
         continue;
      }

	  if(_stricmp(argv[i], "-pbkey") == 0)
      {
		 CheckArgNo(argc, 2);
    	 gAction = STORE_FORGN_PBKEY ;
         i++;
	     swprintf(szMachineName, L"%S", argv[i]);

		 i++;
	     swprintf(wszKeyName, L"%S", argv[i]);

         fCheckNt4Ver = FALSE ;
         continue;
      }

      if(_stricmp(argv[i], "-?") == 0)
      {
         Usage();
         continue;
      }

	  if(_stricmp(argv[i], "/?") == 0)
      {
         Usage();
         continue;
      }

      printf("\n*** Error - Unknown switch: %s\n\n", argv[i]);
 	  exit(-1);

   }

   if(gAction == 0)
   {
	  printf("\n*** Error - no action specified\n\n");
	  exit(-1);
   }

   //
   // Run this utility on NT4 enterprise only
   //
   if (fCheckNt4Ver)
   {
       CheckNT4Enterprise();
   }

   //
   // Perform the action according to params
   //
   switch(gAction)
   {
   case CREATE_CN:
   	   printf("Creating foreign CN %S...\n", szCNName);
	   hr = CreateForeignCN(szCNName) ;
	   break;

   case OPEN_CONNECOTR_EVERYONE:
   	   printf("Opening connector queue %S to everyone...\n", szCNName);
       hr = OpenConnectorToEveryone( szCNName ) ;
       break ;

   case REMOVE_CN:
   	   printf("Removing foreign CN %S...\n", szCNName);
	   hr = DeleteForeignCN(szCNName);
	   break;

   case ADD_CN:
	   printf("Adding foreign CN %S to computer %S....\n", szCNName, szMachineName);
	   hr = AddForeignCN(szMachineName, szCNName);
	   break;

   case DEL_CN:
	   printf("Deleting foreign CN %S from computer %S....\n", szCNName, szMachineName);
	   hr = DelForeignCN(szMachineName, szCNName);
	   break;

   case CREATE_COMP:
   	   printf("Creating foreign computer %S - Site: %S - CN: %S...\n",szMachineName,szSiteName,szCNName);
	   hr = CreateForeignComputer(szMachineName, szSiteName, szCNName);
	   break;

   case REMOVE_COMP:
   	   printf("Removing foreign computer %S...\n", szMachineName);
	   hr = DeleteForeignComputer(szMachineName);
	   break;

    case STORE_FORGN_PBKEY:
   	    printf("Storing Public Key for computer %S...\n", szMachineName) ;
        hr = StorePbkeyOnForeignMachine( szMachineName, wszKeyName ) ;
        break ;

    default:
	    Usage();
	    break;
   }


   if(FAILED(hr))
	   ErrorExit("",hr);


   printf("Done.\n");
   exit(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\mqforgn\forgnsec.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation. All rights reserved

Module Name:
    forgnsec.cpp

Abstract:
    Security code, for foreign objects.

Author:
    DoronJ

Environment:
	Platform-independent.

--*/

#pragma warning(disable: 4201)
#pragma warning(disable: 4514)

#include "_stdafx.h"

#include <string.h>
#include <stdio.h>
#include <assert.h>

#include "mqsymbls.h"
#include "autorel.h"

#include <wincrypt.h>
#include "mqsec.h"

//+----------------------------------------------------------------------
//
//  BOOL  CreateEveryoneSD()
//
//  Create a security descriptor that grant everyone the permisison to
//  open the connector queue.
//
//+----------------------------------------------------------------------

HRESULT  CreateEveryoneSD( PSECURITY_DESCRIPTOR  *ppSD )
{
    CAutoCloseHandle hToken;

    if (!OpenProcessToken( GetCurrentProcess(),
                           TOKEN_READ,
                           &hToken ))
    {
        return HRESULT_FROM_WIN32(GetLastError()) ;
    }

    BYTE rgbBuf[128];
    DWORD dwSize = 0;
    P<BYTE> pBuf;
    TOKEN_USER * pTokenUser = NULL;

    if (GetTokenInformation( hToken,
                             TokenUser,
                             rgbBuf,
                             sizeof(rgbBuf),
                             &dwSize))
    {
        pTokenUser = (TOKEN_USER *) rgbBuf;
    }
    else if (dwSize > sizeof(rgbBuf))
    {
        pBuf = new BYTE [dwSize];
        if (GetTokenInformation( hToken,
                                 TokenUser,
                                 (BYTE *)pBuf,
                                 dwSize,
                                 &dwSize))
        {
            pTokenUser = (TOKEN_USER *)((BYTE *)pBuf);
        }
        else
        {
            return HRESULT_FROM_WIN32(GetLastError()) ;
        }
    }
    else
    {
        return HRESULT_FROM_WIN32(GetLastError()) ;
    }

    SID *pSid = (SID*) pTokenUser->User.Sid ;
    ASSERT(IsValidSid(pSid));

    SECURITY_DESCRIPTOR  sd ;
    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);

    //
    // Initialize World (everyone) SID
    //
    PSID   pWorldSid = NULL ;
    SID_IDENTIFIER_AUTHORITY WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
    BOOL bRet = AllocateAndInitializeSid( &WorldAuth,
                                          1,
                                          SECURITY_WORLD_RID,
                                          0,
                                          0,
                                          0,
                                          0,
                                          0,
                                          0,
                                          0,
                                         &pWorldSid );
    ASSERT(bRet) ;

    DWORD dwAclRevision = ACL_REVISION ;

    DWORD dwWorldAccess = (MQSEC_CN_GENERIC_READ | MQSEC_CN_OPEN_CONNECTOR) ;
    DWORD dwOwnerAccess = MQSEC_CN_GENERIC_ALL ;

    DWORD dwAclSize = sizeof(ACL)                                +
              (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD))) +
              GetLengthSid(pWorldSid)                            +
              GetLengthSid(pSid) ;

    AP<char> DACL_buff;
    DACL_buff = new char[ dwAclSize ];
    PACL pDacl = (PACL)(char*)DACL_buff;

    InitializeAcl(pDacl, dwAclSize, dwAclRevision);

    bRet = AddAccessAllowedAce( pDacl,
                                dwAclRevision,
                                dwWorldAccess,
                                pWorldSid );
    ASSERT(bRet) ;

    bRet = AddAccessAllowedAce( pDacl,
                                dwAclRevision,
                                dwOwnerAccess,
                                pSid);
    ASSERT(bRet) ;

    //
	// dacl should not be defaulted !
    // Otherwise, calling IDirectoryObject->CreateDSObject() will ignore
    // the dacl we provide and will insert some default.
    //
    bRet = SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE);
    ASSERT(bRet);

    //
    // Convert the descriptor to a self relative format.
    //
    DWORD dwLen = 0;
    bRet = MakeSelfRelativeSD( &sd,
                                NULL,
                               &dwLen) ;

    DWORD dwErr = GetLastError() ;
    if (dwErr == ERROR_INSUFFICIENT_BUFFER)
    {
        *ppSD = (PSECURITY_DESCRIPTOR) new char[ dwLen ];
        bRet = MakeSelfRelativeSD( &sd, *ppSD, &dwLen);

        ASSERT(bRet);
        dwErr = 0 ;
        if (!bRet)
        {
            dwErr = GetLastError() ;
        }
    }

    return HRESULT_FROM_WIN32(dwErr) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\mqforgn\mqfrgnky.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mqfrgnky.h

Abstract:

    header file for the mqfrgnky.dll.
    Used to insert public keys into msmqConfiguration objects of foreign
    computers.

Author:

    Doron Juster  (DoronJ)   21-June-1999  Created

--*/

#ifndef __MQFRGNKY_H_
#define __MQFRGNKY_H_

HRESULT APIENTRY
MQFrgn_StorePubKeysInDS( IN LPWSTR pwszMachineName,
                         IN LPWSTR pwszKeyName,
                         IN BOOL   fRegenerate ) ;

typedef HRESULT
(APIENTRY *MQFrgn_StorePubKeysInDS_ROUTINE) ( IN LPWSTR pwszMachineName,
                                              IN LPWSTR pwszKeyName,
                                              IN BOOL   fRegenerate ) ;

#endif //  __MQFRGNKY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\xacttest\common.cpp ===
// Because we are compiling in UNICODE, here is a problem with DTC...
//#include	<xolehlp.h>
extern HRESULT DtcGetTransactionManager(
									LPSTR  pszHost,
									LPSTR	pszTmName,
									REFIID rid,
								    DWORD	dwReserved1,
								    WORD	wcbReserved2,
								    void FAR * pvReserved2,
									void** ppvObject )	;


// Transaction Dispenser DTC's interface
ITransactionDispenser	*g_pITxDispenser;

// Database connection entities
DBPROCESS	    *g_dbproc[]   = {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
LOGINREC		*g_login[]   = {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
LPCSTR	        g_pszDbLibVer;
RETCODE	        g_rc;
DBINT           g_counter;

ULONG           g_cEnlistFailures = 0;
ULONG           g_cBeginFailures = 0;
ULONG           g_cDbEnlistFailures = 0;

/* Message and error handling functions. */
int msg_handler(DBPROCESS *dbproc, DBINT msgno, int msgstate, int severity, char *msgtext)
{
	/*	Msg 5701 is just a USE DATABASE message, so skip it.	*/
	if (msgno == 5701)
		return (0);

	/*	Print any severity 0 message as is, without extra stuff.	*/
	if (severity == 0)
	{
		printf ("%s\n",msgtext);
		return (0);
	}

	printf("SQL Server message %ld, severity %d:\n\t%s\n",
		msgno, severity, msgtext);

	if (severity >>= 16)
	{
		printf("Program Terminated! Fatal SQL Server error.\n");
		exit(ERREXIT);
	}
	return (0);
}


int err_handler(DBPROCESS *dbproc, int severity, int dberr, int oserr, char *dberrstr, char *oserrstr)
{
	if ((dbproc == NULL) || (DBDEAD(dbproc)))
		return (INT_EXIT);
	else
	{
		printf ("DB-LIBRARY error: \n\t%s\n", dberrstr);

		if (oserr != DBNOERR)
			printf ("Operating system error:\n\t%s\n", oserrstr);
	}
	return (INT_CANCEL);
}

HRESULT BeginTransaction(ITransaction **ppTrans, ULONG nSync)
{
	HRESULT hr = XACT_E_CONNECTION_DOWN;

    while (1)
    {
        hr = g_pITxDispenser->BeginTransaction (
			NULL,						// IUnknown __RPC_FAR *punkOuter,
			ISOLATIONLEVEL_ISOLATED,	// ISOLEVEL isoLevel,
			ISOFLAG_RETAIN_DONTCARE,	// ULONG isoFlags,
			NULL,						// ITransactionOptions *pOptions
			// 0, ISOLATIONLEVEL_UNSPECIFIED, 0,0,
			ppTrans);
        
        if (hr != XACT_E_CONNECTION_DOWN)
            break;

        g_cBeginFailures++;
        printf("BeginTrans failed: Sleeping\n");
		Sleep(RECOVERY_TIME);
    }

    if (nSync==0)
    {
        COutcome *pOutcome = new COutcome();

        ITransaction *pTrans = *ppTrans;
        IConnectionPointContainer *pCont;

        HRESULT hr = pTrans->QueryInterface (IID_IConnectionPointContainer,(void **)(&pCont));
        if (SUCCEEDED(hr) && pCont)
        {
            IConnectionPoint *pCpoint;

            hr = pCont->FindConnectionPoint(IID_ITransactionOutcomeEvents, &pCpoint);
            if (SUCCEEDED(hr) && pCpoint)
            {
                pOutcome->SetConnectionPoint(pCpoint);

                DWORD dwCookie;
                hr = pCpoint->Advise(pOutcome, &dwCookie);
                if (SUCCEEDED(hr))
                {
                    pOutcome->SetCookie(dwCookie);
                }
                else
                {
                    printf("Advise : hr=%x\n", hr);
                }
            }
            else
            {
                printf("QueryInterface ICon.P.Cnt.: hr=%x\n", hr);
            }
            pCont->Release();
        }
    }

    return hr;
}

HRESULT Send(HANDLE hQueue, ITransaction *pTrans, MQMSGPROPS *pMsgProps)
{
    HRESULT hr = MQ_ERROR_TRANSACTION_ENLIST;

    while (1)
    {
        hr = MQSendMessage(
                hQueue,
                pMsgProps,
                pTrans);
        if (hr != MQ_ERROR_TRANSACTION_ENLIST)
        {
            break;
        }
   		printf("Enlist Failed, Sleeping\n");
        g_cEnlistFailures++;
        Sleep(RECOVERY_TIME);
    }

    return hr;
}

HRESULT Receive(HANDLE hQueue, ITransaction *pTrans, MQMSGPROPS *pMsgProps, BOOL fImmediate)
{
    HRESULT hr = MQ_ERROR_TRANSACTION_ENLIST;

    while (1)
    {
		hr = MQReceiveMessage(
			hQueue, 
            (fImmediate ? 0 : INFINITE),
			MQ_ACTION_RECEIVE,
			pMsgProps,
			NULL,
			NULL,
			NULL,
			pTrans);
        if (hr != MQ_ERROR_TRANSACTION_ENLIST)
        {
            break;
        }
   		printf("Enlist Failed, Sleeping\n");
        g_cEnlistFailures++;
        Sleep(RECOVERY_TIME);
    }

    return hr;
}

HRESULT Commit(ITransaction *pTrans, BOOL fAsync)
{
    HRESULT hr = pTrans->Commit(FALSE, 
                                (fAsync ? XACTTC_ASYNC : 0), 
                                0);
    return (hr == XACT_S_ASYNC ? S_OK : hr);
}

HRESULT Abort(ITransaction *pTrans, BOOL fAsync)
{
	HRESULT hr = pTrans->Abort(NULL, FALSE, fAsync);
    return (hr == XACT_S_ASYNC ? S_OK : hr);
}

ULONG Release(ITransaction *pTrans)
{
	return pTrans->Release();
}

void DbLogin(ULONG ulLogin, LPSTR pszUser, LPSTR pszPassword)
{
    // set error/msg handlers for this program
	dbmsghandle((DBMSGHANDLE_PROC)msg_handler);
	dberrhandle((DBERRHANDLE_PROC)err_handler);

    // Initialize DB-Library.
	g_pszDbLibVer = dbinit();
    if (!g_pszDbLibVer)
    {
        printf("dbinit failed: %x\n", g_pszDbLibVer);
        exit(1);
    }

    // Get a LOGINREC.
    g_login[ulLogin] = dblogin ();
    if (!g_login[ulLogin])
    {
        printf("dblogin fauled: %x\n", g_login[ulLogin]);
        exit(1);
    }

    DBSETLUSER (g_login[ulLogin], pszUser);   // username, "user1"
    DBSETLPWD  (g_login[ulLogin], pszPassword);   // password, "user1"
    DBSETLAPP  (g_login[ulLogin], "SeqTest");    // application

    printf("Login OK, version=%s\n",  g_pszDbLibVer);
}

void DbUse(ULONG ulDbproc, ULONG ulLogin, LPSTR pszDatabase, LPSTR pszServer)
{
    // Get a DBPROCESS structure for communication with SQL Server.
    g_dbproc[ulDbproc] = dbopen (g_login[ulLogin], pszServer);
    if (!g_dbproc[ulDbproc])
    {
        printf("dbopen failed: %x\n", g_dbproc[ulDbproc]);
        exit(1);
    }

    // Set current database
	RETCODE	 rc = dbuse(g_dbproc[ulDbproc], pszDatabase);   // database, "test"
    if (rc != SUCCEED)
    {
        printf("dbuse failed: %x\n", rc); 
        exit(1);
    }
	
	printf("DbUse OK\n");
}

BOOL DbEnlist(ULONG ulDbproc, ITransaction *pTrans)
{
    while (1)
    {
        RETCODE rc = dbenlisttrans (g_dbproc[ulDbproc], pTrans);
        if (rc == SUCCEED)
        {
            return TRUE;
        }
   		printf("DbEnlist Failed, Sleeping\n");
        g_cDbEnlistFailures++;
        Sleep(RECOVERY_TIME);
    }

    return TRUE;
}

BOOL DbSql(ULONG ulDbproc, LPSTR pszCommand)
{
    // Put the command into the command buffer.
    dbcmd (g_dbproc[ulDbproc], pszCommand);

    // Send the command to SQL Server and start execution.
    RETCODE rc = dbsqlexec (g_dbproc[ulDbproc]);
    if (rc != SUCCEED)
    {
	    printf("dbsqlexec failed: rc=%x\n", rc);
    }
    else
    {
        rc = dbresults(g_dbproc[ulDbproc]);
        if (rc != SUCCEED)
        {
	        printf("Dbresults: rc=%x\n", rc);
        }
    }
    return TRUE;
}

void DbClose()
{
    dbexit();
}

#ifdef RT_XACT_STUB
extern HRESULT MQStubRM(ITransaction *pTrans);
#endif

BOOL StubEnlist(ITransaction *pTrans)
{
    HRESULT hr = MQ_OK;
    #ifdef RT_XACT_STUB
    hr = MQStubRM(pTrans);  // to uncomment for stub checks
    #endif
    return (SUCCEEDED(hr));
}

void Sleeping(ULONG nSilent, ULONG nMaxSleep)
{
    int is = rand() * nMaxSleep / RAND_MAX;
	if (nSilent)
		printf("Sleep %d\n", is);
	Sleep(is);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\xacttest\xtest\async.cpp ===
// Asynchronous event sync implementation
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <transact.h>
#include <olectl.h>
#include "async.h"

static LONG g_lCommited    = 0;
static LONG g_lAborted     = 0;
static LONG g_lHeuristic   = 0;
static LONG g_lInDoubt     = 0;

static LONG   g_lTotal       = 0;
static HANDLE g_hFinishEvent = NULL;

void SetAnticipatedOutcomes(LONG ul)
{
    g_lTotal = ul;
    g_hFinishEvent =  CreateEvent(NULL, TRUE, FALSE, NULL);
}

void WaitForAllOutcomes(void)
{
    if (g_lTotal && g_hFinishEvent)
    {
        WaitForSingleObject(g_hFinishEvent, INFINITE);
    }
}

void PrintAsyncResults(void)
{
    printf("\nAsync results: %d committed, %d aborted, %d heuristic, %d indoubt\n",
            g_lCommited, g_lAborted, g_lHeuristic, g_lInDoubt );
}

//---------------------------------------------------------------------
// COutcome::COutcome
//---------------------------------------------------------------------

COutcome::COutcome(void)
{
	m_cRefs = 0;
    m_pCpoint = NULL;
}


//---------------------------------------------------------------------
// COutcome::~COutcome
//---------------------------------------------------------------------
COutcome::~COutcome(void)
{
}



//---------------------------------------------------------------------
// COutcome::QueryInterface
//---------------------------------------------------------------------
STDMETHODIMP COutcome::QueryInterface(REFIID i_iid, LPVOID *ppv)
{
	*ppv = 0;						// Initialize interface pointer.

    if (IID_IUnknown == i_iid || IID_ITransactionOutcomeEvents == i_iid)
	{								// IID supported return interface.
		*ppv = this;
	}

	
	if (0 == *ppv)					// Check for null interface pointer.
	{										
		return ResultFromScode (E_NOINTERFACE);
									// Neither IUnknown nor IResourceManagerSink supported--
									// so return no interface.
	}

	((LPUNKNOWN) *ppv)->AddRef();	// Interface is supported. Increment its usage count.
	
	return S_OK;
}


//---------------------------------------------------------------------
// COutcome::AddRef
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) COutcome::AddRef(void)
{
    return ++m_cRefs;				// Increment interface usage count.
}


//---------------------------------------------------------------------
// COutcome::Release
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) COutcome::Release(void)
{

	--m_cRefs;						// Decrement usage reference count.

	if (0 != m_cRefs)				// Is anyone using the interface?
	{								// The interface is in use.
		return m_cRefs;				// Return the number of references.
	}

	delete this;					// Interface not in use -- delete!

	return 0;						// Zero references returned.
}


//---------------------------------------------------------------------
// COutcome::Committed
//---------------------------------------------------------------------
STDMETHODIMP COutcome::Committed( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr)
{
    InterlockedIncrement(&g_lCommited);
    CheckFinish();
    Release();
    return S_OK;
}
        
//---------------------------------------------------------------------
// COutcome::Aborted
//---------------------------------------------------------------------
STDMETHODIMP COutcome::Aborted( 
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr)
{
    InterlockedIncrement(&g_lAborted);
    CheckFinish();
    Release();
    return S_OK;
}
        
//---------------------------------------------------------------------
// COutcome::HeuristicDecision
//---------------------------------------------------------------------
STDMETHODIMP COutcome::HeuristicDecision( 
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr)
{
    InterlockedIncrement(&g_lHeuristic);
    CheckFinish();
    Release();
    return S_OK;
}

//---------------------------------------------------------------------
// COutcome::Indoubt
//---------------------------------------------------------------------
STDMETHODIMP COutcome::Indoubt( void)
{
    InterlockedIncrement(&g_lInDoubt);
    CheckFinish();
    Release();
    return S_OK;
}

//---------------------------------------------------------------------
// COutcome::SetCookie
//---------------------------------------------------------------------
STDMETHODIMP COutcome::SetCookie(DWORD dwCookie)
{
    m_dwCookie = dwCookie;
    return S_OK;
}


//---------------------------------------------------------------------
// COutcome::SetConnectionPoint
//---------------------------------------------------------------------
STDMETHODIMP COutcome::SetConnectionPoint(IConnectionPoint *pCpoint)
{
    m_pCpoint = pCpoint;
    return S_OK;
}

//---------------------------------------------------------------------
// COutcome::CheckFinish
//---------------------------------------------------------------------
void COutcome::CheckFinish(void)
{
    if (m_pCpoint)
    {
        m_pCpoint->Unadvise(m_dwCookie);
        m_pCpoint->Release();
    }
    if (g_lTotal <= g_lCommited + g_lAborted + g_lHeuristic + g_lInDoubt)
    {
         SetEvent(g_hFinishEvent);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\xacttest\xtest\async.h ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    Async.h

Abstract:
    This module defines COutcome object

Author:
    Alexander Dadiomov (AlexDad)

--*/

extern void SetAnticipatedOutcomes(LONG ul);
extern void WaitForAllOutcomes(void);
extern void PrintAsyncResults(void);

//---------------------------------------------------------------------
// COutcome:
//---------------------------------------------------------------------

class COutcome: public ITransactionOutcomeEvents
{
public:
	
	COutcome(void);
	~COutcome(void);

    STDMETHODIMP			QueryInterface(REFIID i_iid, LPVOID FAR* ppv);
	STDMETHODIMP_ (ULONG)	AddRef(void);
	STDMETHODIMP_ (ULONG)	Release(void);

    STDMETHODIMP Committed( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
    STDMETHODIMP Aborted( 
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
    STDMETHODIMP HeuristicDecision( 
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr);
        
    STDMETHODIMP Indoubt( void);

    STDMETHODIMP SetCookie(DWORD dwCookie);

    STDMETHODIMP SetConnectionPoint(IConnectionPoint *pCpoint);
	
private:
	ULONG	m_cRefs;
    DWORD   m_dwCookie;
    IConnectionPoint *m_pCpoint;
    
    void CheckFinish(void);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\cluster\mqclus\mqclus.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    mqclus.cpp

Abstract:

    Resource DLL for MSMQ

Author:

    Shai Kariv (shaik) Jan 12, 1999

Revision History:

--*/


#include "stdh.h"
#include <uniansi.h>

#include "clusres.h"
#include "mqclusp.h"
#include "_mqres.h"

//
// Get the handle to the resource only DLL first, i.e. mqutil.dll
//
HMODULE	g_hResourceMod = MQGetResourceHandle();


// Cluster Event Logging routine.

PLOG_EVENT_ROUTINE g_pfLogClusterEvent = NULL;

// Resource Status routine for pending Online and Offline calls.

PSET_RESOURCE_STATUS_ROUTINE g_pfSetResourceStatus = NULL;

const WCHAR x_szMSMQResourceTypeName[]=L"MSMQ";








//
// MSMQ resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
MqclusResourcePrivateProperties[] = 
{
    { 0 }
};


BOOLEAN
WINAPI
DllMain(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       /*Reserved*/
    )

/*++

Routine Description:

    Main DLL entry point.

Arguments:

    DllHandle - DLL instance handle.

    Reason - Reason for being called.

    Reserved - Reserved argument.

Return Value:

    TRUE - Success.

    FALSE - Failure.

--*/

{
    switch( Reason ) 
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls( DllHandle );
            break;
            
        case DLL_PROCESS_DETACH:
            break;
    }

	return TRUE;


} // DllMain


DWORD
WINAPI
Startup(
    IN LPCWSTR pwzResourceType,
    IN DWORD dwMinVersionSupported,
    IN DWORD dwMaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE pfSetResourceStatus,
    IN PLOG_EVENT_ROUTINE pfLogClusterEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Startup the resource DLL. This routine verifies that at least one
    currently supported version of the resource DLL is between
    MinVersionSupported and MaxVersionSupported. If not, then the resource
    DLL should return ERROR_REVISION_MISMATCH.

    If more than one version of the resource DLL interface is supported by
    the resource DLL, then the highest version (up to MaxVersionSupported)
    should be returned as the resource DLL's interface. If the returned
    version is not within range, then startup fails.

    The ResourceType is passed in so that if the resource DLL supports more
    than one ResourceType, it can pass back the correct function table
    associated with the ResourceType.

Arguments:

    pwzResourceType - The type of resource requesting a function table.

    dwMinVersionSupported - The minimum resource DLL interface version 
        supported by the cluster software.

    dwMaxVersionSupported - The maximum resource DLL interface version
        supported by the cluster software.

    pfSetResourceStatus - Pointer to a routine that the resource DLL should 
        call to update the state of a resource after the Online or Offline 
        routine returns a status of ERROR_IO_PENDING.

    pfLogClusterEvent - Pointer to a routine that handles the reporting of events 
        from the resource DLL. 

    FunctionTable - Returns a pointer to the function table defined for the
        version of the resource DLL interface returned by the resource DLL.

Return Value:

    ERROR_SUCCESS - The operation was successful.

    ERROR_MOD_NOT_FOUND - The resource type is unknown by this DLL.

    ERROR_REVISION_MISMATCH - The version of the cluster service doesn't
        match the versrion of the DLL.

    Win32 error code - The operation failed.

--*/

{
    if ( (dwMinVersionSupported > CLRES_VERSION_V1_00) ||
         (dwMaxVersionSupported < CLRES_VERSION_V1_00) ) 
    {
        return(ERROR_REVISION_MISMATCH);
    }

    if ( 0 != _wcsicmp( pwzResourceType, x_szMSMQResourceTypeName ) ) 
    {
        return(ERROR_MOD_NOT_FOUND);
    }

    if ( g_pfLogClusterEvent == NULL) 
    {
        g_pfLogClusterEvent = pfLogClusterEvent;
        g_pfSetResourceStatus = pfSetResourceStatus;
    }

    *FunctionTable = &g_MqclusFunctionTable;

    return MqcluspStartup();

} // Startup


RESID
WINAPI
MqclusOpen(
    IN LPCWSTR pwzResourceName,
    IN HKEY hResourceKey,
    IN RESOURCE_HANDLE hResourceHandle
    )

/*++

Routine Description:

    Open routine for MSMQ resources.

    Open the specified resource (create an instance of the resource). 
    Allocate all structures necessary to bring the specified resource 
    online.

Arguments:

    pwzResourceName - Supplies the name of the resource to open.

    hResourceKey - Supplies handle to the resource's cluster configuration 
        database key.

    hResourceHandle - A handle that is passed back to the resource monitor 
        when the SetResourceStatus or LogClusterEvent method is called. See the 
        description of the SetResourceStatus and LogClusterEvent methods on the
        MqclusStatup routine. This handle should never be closed or used
        for any purpose other than passing it as an argument back to the
        Resource Monitor in the SetResourceStatus or LogClusterEvent callback.

Return Value:

    RESID of created resource.

    NULL on failure.

--*/

{
    return MqcluspOpen(pwzResourceName, hResourceKey, hResourceHandle);

} // MqclusOpen



VOID
WINAPI
MqclusClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for MSMQ resources.

    Close the specified resource and deallocate all structures, etc.,
    allocated in the Open call. If the resource is not in the offline state,
    then the resource should be taken offline (by calling Terminate) before
    the close operation is performed.

Arguments:

    ResourceId - Supplies the RESID of the resource to close.

Return Value:

    None.

--*/

{
    CQmResource * pqm = static_cast<CQmResource*>(ResourceId);

    if ( pqm == NULL ) 
    {
        return;
    }

    if ( ResourceId != pqm->GetResId() )
    {
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, 
                              L"Close sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return;
    }

    //
    // Deallocate resource entry
    //
    MqcluspClose(pqm);

} // MqclusClose



DWORD
WINAPI
MqclusOnlineThread(
    PCLUS_WORKER /*WorkerPtr*/,
    IN CQmResource * pqm
    )

/*++

Routine Description:

    Worker function which brings a resource from the resource table online.
    This function is executed in a separate thread.

Arguments:

    WorkerPtr - Supplies the worker structure

    pqm - A pointer to the MQCLUS_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS - The operation completed successfully.
    
    Win32 error code - The operation failed.

--*/

{
    return MqcluspOnlineThread(pqm);

} // MqclusOnlineThread



DWORD
WINAPI
MqclusOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE /*phEventHandle*/
    )

/*++

Routine Description:

    Online routine for MSMQ resources.

    Bring the specified resource online (available for use). The resource
    DLL should attempt to arbitrate for the resource if it is present on a
    shared medium, like a shared SCSI bus.

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        online (available for use).

    phEventHandle - Returns a signalable handle that is signaled when the 
        resource DLL detects a failure on the resource. This argument is 
        NULL on input, and the resource DLL returns NULL if asynchronous 
        notification of failures is not supported, otherwise this must be 
        the address of a handle that is signaled on resource failures.

Return Value:

    ERROR_SUCCESS - The operation was successful, and the resource is now 
        online.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_RESOURCE_NOT_AVAILABLE - If the resource was arbitrated with some 
        other systems and one of the other systems won the arbitration.

    ERROR_IO_PENDING - The request is pending, a thread has been activated 
        to process the online request. The thread that is processing the 
        online request will periodically report status by calling the 
        SetResourceStatus callback method, until the resource is placed into 
        the ClusterResourceOnline state (or the resource monitor decides to 
        timeout the online request and Terminate the resource. This pending 
        timeout value is settable and has a default value of 3 minutes.).

    Win32 error code - The operation failed.

--*/

{
    CQmResource * pqm = static_cast<CQmResource*>(ResourceId);

    if ( pqm == NULL ) 
    {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( ResourceId != pqm->GetResId()) 
    {
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, 
                              L"Online sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    pqm->SetState(ClusterResourceFailed);
    ClusWorkerTerminate( &pqm->m_OnlineThread );
    DWORD status = ClusWorkerCreate( 
                       &pqm->m_OnlineThread,
                       reinterpret_cast<PWORKER_START_ROUTINE>(MqclusOnlineThread),
                       pqm
                       );
    if ( status != ERROR_SUCCESS ) 
    {
        pqm->SetState(ClusterResourceFailed);
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, 
                              L"Failed to create the online thread. Error 0x%1!x!.\n", status);
    } 
    else 
    {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // MqclusOnline



VOID
WINAPI
MqclusTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for MSMQ resources.

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        offline.

Return Value:

    None.

--*/

{
    CQmResource * pqm = static_cast<CQmResource*>(ResourceId);

    if ( pqm == NULL ) 
    {
        return;
    }

    if ( ResourceId != pqm->GetResId() ) 
    {
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, 
                              L"Terminate sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return;
    }

    //
    // Terminate the resource.
    //
    // Kill off any pending threads.
    //
    ClusWorkerTerminate( &pqm->m_OnlineThread );

    //
    // SCM does not provide any way to kill a service immediately.
    // Even trying to query the service for its process ID and then 
    // terminating the process will fail with access denied.
    // So we will stop the service gracefully by calling Offline.
    //
    MqcluspOffline(pqm);
    pqm->SetState(ClusterResourceOffline);

} // MqclusTerminate



DWORD
WINAPI
MqclusOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for MSMQ resources.

    Take the specified resource offline gracefully (unavailable for use).  
    Wait for any cleanup operations to complete before returning.

Arguments:

    ResourceId - Supplies the resource id for the resource to be shutdown 
        gracefully.

Return Value:

    ERROR_SUCCESS - The request completed successfully and the resource is 
        offline.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_IO_PENDING - The request is still pending, a thread has been 
        activated to process the offline request. The thread that is 
        processing the offline will periodically report status by calling 
        the SetResourceStatus callback method, until the resource is placed 
        into the ClusterResourceOffline state (or the resource monitor decides 
        to timeout the offline request and Terminate the resource).
    
    Win32 error code - Will cause the resource monitor to log an event and 
        call the Terminate routine.

--*/

{
    CQmResource * pqm = static_cast<CQmResource*>(ResourceId);

    if ( pqm == NULL ) 
    {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( ResourceId != pqm->GetResId() ) 
    {
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, 
                              L"Offline sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    return MqcluspOffline(pqm);

} // MqclusOffline



BOOL
MqclusCheckIsAlive(
    IN CQmResource * pqm
    )

/*++

Routine Description:

    Check to see if the resource is alive for MSMQ resources.

Arguments:

    pqm - Supplies the resource entry for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{
    //
    // Check to see if the resource is alive.
    //
    // TODO: Add code to determine if your resource is alive.
    //
    return MqcluspCheckIsAlive(pqm);

} // MqclusCheckIsAlive



BOOL
WINAPI
MqclusIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for MSMQ resources.

    Perform a thorough check to determine if the specified resource is online
    (available for use). This call should not block for more than 400 ms,
    preferably less than 100 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{
    CQmResource * pqm = static_cast<CQmResource*>(ResourceId);

    if ( pqm == NULL ) 
    {
        return(FALSE);
    }

    if ( ResourceId != pqm->GetResId() ) 
    {
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, 
                              L"IsAlive sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return(FALSE);
    }

    return(MqclusCheckIsAlive( pqm ));

} // MqclusIsAlive



BOOL
WINAPI
MqclusLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for MSMQ resources.

    Perform a quick check to determine if the specified resource is probably
    online (available for use).  This call should not block for more than
    300 ms, preferably less than 50 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is probably online and available for use.

    FALSE - The specified resource is not functioning normally.

--*/

{
    CQmResource * pqm = static_cast<CQmResource*>(ResourceId);

    if ( pqm == NULL ) 
    {
        return(FALSE);
    }

    if ( ResourceId != pqm->GetResId() ) 
    {
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, 
                              L"LooksAlive sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return(FALSE);
    }

    // TODO: LooksAlive code

    // NOTE: LooksAlive should be a quick check to see if the resource is
    // available or not, whereas IsAlive should be a thorough check.  If
    // there are no differences between a quick check and a thorough check,
    // IsAlive can be called for LooksAlive, as it is below.  However, if there
    // are differences, replace the call to IsAlive below with your quick
    // check code.

    return MqclusCheckIsAlive(pqm);

} // MqclusLooksAlive



DWORD
WINAPI
MqclusResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID /*InBuffer*/,
    IN DWORD /*InBufferSize*/,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for MSMQ resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    CQmResource * pqm = static_cast<CQmResource*>(ResourceId);

    if ( pqm == NULL ) 
    {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( ResourceId != pqm->GetResId() ) 
    {
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, 
                              L"ResourceControl sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }


    DWORD status = ERROR_SUCCESS;
    *BytesReturned = 0;

    ZeroMemory(OutBuffer, OutBufferSize);

    switch ( ControlCode ) 
    {

        case CLUSCTL_RESOURCE_UNKNOWN:
        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            status = MqcluspClusctlResourceGetRequiredDependencies(OutBuffer, OutBufferSize, 
                                                                   BytesReturned);
            break;

        case CLUSCTL_RESOURCE_SET_NAME:
            status = MqcluspClusctlResourceSetName();
            break;

        case CLUSCTL_RESOURCE_DELETE:
            status = MqcluspClusctlResourceDelete(pqm);
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // MqclusResourceControl


DWORD
WINAPI
MqclusResourceTypeControl(
    IN LPCWSTR  pResourceTypeName,
    IN DWORD    ControlCode,
    IN PVOID    /*InBuffer*/,
    IN DWORD    /*InBufferSize*/,
    OUT PVOID   OutBuffer,
    IN DWORD    OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for MSMQ resources.

    Perform the control request specified by ControlCode on the specified
    resource type.

Arguments:

    pResourceTypeName - Supplies the type name of the specific resource type.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_RESOURCE_TYPE_NOT_FOUND - pResourceTypeName is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    if (0 != _wcsicmp(pResourceTypeName, x_szMSMQResourceTypeName)) 
    {
        return ERROR_RESOURCE_TYPE_NOT_FOUND;
    }

    

    DWORD status = ERROR_SUCCESS;
    *BytesReturned = 0;

    ZeroMemory(OutBuffer, OutBufferSize);

    switch ( ControlCode ) 
    {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_TYPE_VALIDATE_PRIVATE_PROPERTIES:
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            status = MqcluspClusctlResourceGetRequiredDependencies(OutBuffer, OutBufferSize, 
                                                                   BytesReturned);
            break;

        case CLUSCTL_RESOURCE_TYPE_STARTING_PHASE2:
            status = MqcluspClusctlResourceTypeStartingPhase2();
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // MqclusResourceTypeControl


//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( g_MqclusFunctionTable,     // Name
                         CLRES_VERSION_V1_00,         // Version
                         Mqclus,                    // Prefix
                         NULL,                        // Arbitrate
                         NULL,                        // Release
                         MqclusResourceControl,     // ResControl
                         MqclusResourceTypeControl);// ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\cluster\mqclus\mqclusp.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    mqclusp.cpp

Abstract:

    Implementation for my internal routines

Author:

    Shai Kariv (shaik) Jan 12, 1999

Revision History:

--*/

#include "stdh.h"
#include "clusres.h"
#include <_mqini.h>
#include <autorel.h>
#include <autorel2.h>
#include <autorel3.h>
#include <uniansi.h>
#include "mqclusp.h"
#include <mqtypes.h>
#include <_mqdef.h>
#include <mqprops.h>
#include <mqsymbls.h>
#include <xolehlp.h>
#include <ad.h>
#include <mqsec.h>
#include <mqutil.h>
#include <mqupgrd.h>
#include <mqnames.h>
#include <cancel.h>
#include <rtcert.h>
#include "strsafe.h"
#include <autohandle.h>
#include <version.h>

//
// Synchronize processwide changes to Falcon registry section
// pointed by masec.dll (calls to SetFalconServiceName).
//
CCriticalSection s_csReg;

//
// Handle to Win32 event logging source
//
CEventSource     s_hEventSource;


//
// Handles to MSMQ common DLLs
//
CAutoFreeLibrary s_hMqsec;


//
// Pointers to MSMQ DLLs common routines
//
MQSec_GetDefaultSecDescriptor_ROUTINE pfMQSec_GetDefaultSecDescriptor = NULL;
MQSec_StorePubKeysInDS_ROUTINE        pfMQSec_StorePubKeysInDS        = NULL;
MSMQGetOperatingSystem_ROUTINE        pfMSMQGetOperatingSystem        = NULL;
SetFalconServiceName_ROUTINE          pfSetFalconServiceName          = NULL;
SetFalconKeyValue_ROUTINE             pfSetFalconKeyValue             = NULL;
GetFalconKeyValue_ROUTINE             pfGetFalconKeyValue             = NULL;


bool
MqcluspLoadMsmqDlls(
    VOID
    )

/*++

Routine Description:

    Load msmq DLLs that are needed by this DLL, and initialize
    pointers to their exported routines.

    This DLL is installed as part of the cluster product and
    should load w/o depending on msmq DLLs. Load of msmq DLLs
    is done on request to open a resource.

Arguments:

    None.

Return Value:

    true - Operation was successfull.

    false - Operation failed.

--*/

{
    s_hMqsec = LoadLibrary(MQSEC_DLL_NAME);
    if (s_hMqsec == NULL)
    {
        return false;
    }


    pfMQSec_GetDefaultSecDescriptor = (MQSec_GetDefaultSecDescriptor_ROUTINE)GetProcAddress(s_hMqsec, "MQSec_GetDefaultSecDescriptor");
    ASSERT(pfMQSec_GetDefaultSecDescriptor != NULL);

    pfMQSec_StorePubKeysInDS = (MQSec_StorePubKeysInDS_ROUTINE)GetProcAddress(s_hMqsec, "MQSec_StorePubKeysInDS");
    ASSERT(pfMQSec_StorePubKeysInDS != NULL);

    pfMSMQGetOperatingSystem = (MSMQGetOperatingSystem_ROUTINE)GetProcAddress(s_hMqsec, "MSMQGetOperatingSystem");
    ASSERT(pfMSMQGetOperatingSystem != NULL);

    pfSetFalconServiceName = (SetFalconServiceName_ROUTINE)GetProcAddress(s_hMqsec, "SetFalconServiceName");
    ASSERT(pfSetFalconServiceName != NULL);

    pfSetFalconKeyValue = (SetFalconKeyValue_ROUTINE)GetProcAddress(s_hMqsec, "SetFalconKeyValue");
    ASSERT(pfSetFalconKeyValue != NULL);

    pfGetFalconKeyValue = (GetFalconKeyValue_ROUTINE)GetProcAddress(s_hMqsec, "GetFalconKeyValue");
    ASSERT(pfGetFalconKeyValue != NULL);

    return true;

} //MqcluspLoadMsmqDlls


static
bool
MqcluspCreateEventSourceRegistry(
    LPCWSTR pFileName,
    LPCWSTR pSourceName
    )

/*++

Routine Description:

    Create the registry values to support event source registration.

Arguments:

    pFileName   - Name of event source module.

    pSourceName - Descriptive name of the event source.

Return Value:

    true - The operation was successful.
    false - The operation failed.

--*/

{
    //
    // REG_MAX_KEY_NAME_LENGTH is defined in ntregapi.h as follow:
    //    #define REG_MAX_KEY_NAME_LENGTH         512       // allow for 256 unicode, as promise
    //
    WCHAR buffer[REG_MAX_KEY_NAME_LENGTH/sizeof(WCHAR)] = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\";
    HRESULT hr = StringCchCat(buffer, TABLE_SIZE(buffer), pSourceName);
    if(FAILED(hr))
	    return false;

    CAutoCloseRegHandle hKey;
    DWORD dwDisposition;
    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE, 
                                        buffer,
                                        NULL,
                                        TEXT(""),
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_SET_VALUE,
                                        NULL,
                                        &hKey,
                                        &dwDisposition))
    {
        return false;
    }

    if ( ERROR_SUCCESS != RegSetValueEx(hKey,
                                        L"EventMessageFile",
                                        0,
                                        REG_EXPAND_SZ,
                                        reinterpret_cast<const BYTE*>(pFileName),
                                        (wcslen(pFileName) + 1) * sizeof(WCHAR)) )
    {
        return false;
    }

    DWORD dwTypes = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
    if (ERROR_SUCCESS != RegSetValueEx(hKey, L"TypesSupported", 0, REG_DWORD, reinterpret_cast<BYTE*>(&dwTypes), sizeof(DWORD)))
    {
        return false;
    }

    return true;

} //MqcluspCreateEventSourceRegistry

 
VOID
MqcluspRegisterEventSource(
    VOID
    )

/*++

Routine Description:

    Register event source so that this DLL can log events
    in the Windows Event Log.

    We do not use the routines in mqutil.dll to do that,
    since this DLL is installed as part of the cluster
    product and should not assume that MSMQ is installed.

Arguments:

    None

Return Value:

    None.

--*/

{
    if (s_hEventSource != NULL)
    {
        //
        // Already registered
        //
        return;
    }

    WCHAR wzFilename[MAX_PATH+1] = L"";
    DWORD  cbSize;
    cbSize = GetModuleFileName(g_hResourceMod, wzFilename, TABLE_SIZE(wzFilename)-1);
    if (cbSize == 0)
    {
        return;
    }
    wzFilename[cbSize]=L'\0';

    LPCWSTR x_EVENT_SOURCE = L"MSMQ Cluster Resource DLL";
    if (!MqcluspCreateEventSourceRegistry(wzFilename, x_EVENT_SOURCE))
    {
        return;
    }

    s_hEventSource = RegisterEventSource(NULL, x_EVENT_SOURCE);

} //MqcluspRegisterEventSource


VOID
MqcluspReportEvent(
    WORD      wType,
    DWORD     dwEventId,
    WORD      wNumStrings,
    ...
    )

/*++

Routine Description:

    Wrapper for ReportEvent Win32 API.

Arguments:

    wType - Event type to log.

    dwEventId - Event identifier.

    wNumStrings - Number of strings to merge with message. This 
                  number must be less than 20.

    ... - Array of strings to merge with message.

Return Value:

    None.

--*/

{
    if (s_hEventSource == NULL)
    {
        return;
    }

    const DWORD x_MAX_STRINGS = 20;
    ASSERT(wNumStrings < x_MAX_STRINGS);
    va_list Args;
    LPWSTR ppStrings[x_MAX_STRINGS] = {NULL};
    LPWSTR pStrVal = NULL;

    va_start(Args, wNumStrings);
    pStrVal = va_arg(Args, LPWSTR);

    for (UINT i=0; i < wNumStrings; ++i)
    {
        ppStrings[i]=pStrVal;
        pStrVal = va_arg(Args, LPWSTR);
    }

    ::ReportEvent(s_hEventSource, wType, 0, dwEventId, NULL, wNumStrings, 0, (LPCWSTR*)&ppStrings[0], NULL);

} //MqcluspReportEvent


CQmResource::CQmResourceRegistry::CQmResourceRegistry(LPCWSTR pwzService):m_lock(s_csReg)
{
    pfSetFalconServiceName(pwzService);

} //CQmResource::CQmResourceRegistry::CQmResourceRegistry


CQmResource::CQmResourceRegistry::~CQmResourceRegistry()
{
    pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

} //CQmResource::CQmResourceRegistry::CQmResourceRegistry


CQmResource::CQmResource(
    LPCWSTR pwzResourceName,
    HKEY /*hResourceKey*/,
    RESOURCE_HANDLE hReportHandle
    ):
#pragma warning(disable: 4355) // 'this' : used in base member initializer list
    m_ResId(this),
#pragma warning(default: 4355) // 'this' : used in base member initializer list
    m_hReport(hReportHandle),
    m_guidQm(GUID_NULL),
    m_pSd(NULL),
    m_cbSdSize(0),
    m_wDiskDrive(0),
    m_fServerIsMsmq1(false),
    m_dwWorkgroup(0),
    m_nSites(0),
    m_dwMqsRouting(0),
    m_dwMqsDepClients(1),
    m_hScm(OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS)),
    m_hCluster(OpenCluster(NULL)),
    m_hResource(OpenClusterResource(m_hCluster, pwzResourceName))

/*++

Routine Description:

    Constructor.
    Called by Open entry point function.

    All operations must be idempotent !!

Arguments:

    pwzResourceName - Supplies the name of the resource to open.

    hResourceKey - Supplies handle to the resource's cluster configuration 
        database key.

    hReportHandle - A handle that is passed back to the resource monitor
        when the SetResourceStatus or LogClusterEvent method is called. See the
        description of the SetResourceStatus and LogClusterEvent methods on the
        MqclusStatup routine. This handle should never be closed or used
        for any purpose other than passing it as an argument back to the
        Resource Monitor in the SetResourceStatus or LogClusterEvent callback.

Return Value:

    None.
    Throws CMqclusException, bad_alloc.

--*/

{
    DWORD error = GetLastError();

    if (!MqcluspLoadMsmqDlls())
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, MSMQ_NOT_INSTALLED_ERR, 0);
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"MSMQ is not installed on this node.\n");
        throw CMqclusException();
    }

    SetLastError(error);

    if (m_hScm == NULL)
    {
        ReportLastError(OPEN_SCM_ERR, L"Failed to OpenSCManager.", NULL);
        throw CMqclusException();
    }
    if (m_hCluster == NULL)
    {
        ReportLastError(OPEN_CLUSTER_ERR, L"Failed to OpenCluster.", NULL);
        throw CMqclusException();
    }
    if (m_hResource == NULL)
    {
        ReportLastError(OPEN_RESOURCE_ERR, L"Failed to OpenClusterResource to '%1'.", m_pwzResourceName);
        throw CMqclusException();
    }


    ResUtilInitializeResourceStatus(&m_ResourceStatus);
    SetState(ClusterResourceOffline);

    WCHAR wzRemoteQm[MAX_PATH] = L"";
    DWORD dwType = REG_SZ;
    DWORD dwSize = sizeof(wzRemoteQm);
    {
        CS lock(s_csReg);
        pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

        if (ERROR_SUCCESS == pfGetFalconKeyValue(RPC_REMOTE_QM_REGNAME, &dwType, wzRemoteQm, &dwSize, NULL))
        {
            MqcluspReportEvent(EVENTLOG_ERROR_TYPE, DEP_CLIENT_INSTALLED_ERR, 0);
            (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"MSMQ cluster resources are not supported on this node because MSMQ is installed as a Dependent Client.\n");
            throw CMqclusException();
        }
    }


    //
    // Dont assume any limit to the resource name.
    // It is defined by client and could be very long.
    // The good thing with resource names is that Cluster
    // guarantees their uniqueness.
    //
    DWORD    cbSize=wcslen(pwzResourceName) + 1;
    m_pwzResourceName = new WCHAR[cbSize];
    HRESULT hr = StringCchCopy(m_pwzResourceName, cbSize, pwzResourceName);
    if(FAILED(hr))
        throw CMqclusException();


    //
    // Service name is based on the resource name.
    // Long resource name is truncated.
    //
    LPCWSTR x_SERVICE_PREFIX = L"MSMQ$";
    hr = StringCchCopy(m_wzServiceName, TABLE_SIZE(m_wzServiceName), x_SERVICE_PREFIX);
    if(FAILED(hr))
        throw CMqclusException();

    hr = StringCchCat(m_wzServiceName, TABLE_SIZE(m_wzServiceName), m_pwzResourceName);
    if(FAILED(hr))
        throw CMqclusException();

    //
    // Driver name is based on the resource name.
    // Long resource name is truncated.
    //
    LPCWSTR x_DRIVER_PREFIX = L"MQAC$";
    hr = StringCchCopy(m_wzDriverName, TABLE_SIZE(m_wzDriverName), x_DRIVER_PREFIX);
    if(FAILED(hr))
        throw CMqclusException();
    
    hr = StringCchCat(m_wzDriverName, TABLE_SIZE(m_wzDriverName), m_pwzResourceName);
    if(FAILED(hr))
        throw CMqclusException();

    cbSize = GetSystemDirectory(m_wzDriverPath, TABLE_SIZE(m_wzDriverPath));
    if( cbSize == 0 )throw CMqclusException();
    if( cbSize >= TABLE_SIZE(m_wzDriverPath) )throw CMqclusException();
    m_wzDriverPath[cbSize]=L'\0';

    hr = StringCchCat(m_wzDriverPath, TABLE_SIZE(m_wzDriverPath), L"\\drivers\\");
    if(FAILED(hr))
        throw CMqclusException();
    hr = StringCchCat(m_wzDriverPath, TABLE_SIZE(m_wzDriverPath), m_wzDriverName);
    if(FAILED(hr))
        throw CMqclusException();
    hr = StringCchCat(m_wzDriverPath, TABLE_SIZE(m_wzDriverPath), L".sys");
    if(FAILED(hr))
        throw CMqclusException();


    //
    // Names for Crypto keys are based on the resource name
    // Long resource name is truncated.
    //

    LPCWSTR x_40 = L"_40";
    LPCWSTR x_Provider40 = L"1\\Microsoft Base Cryptographic Provider v1.0\\";

    //
    // Generate a container name, i.e. MSMQ$MSMQ_40
    //
    hr = StringCchCopyN(m_wzCrypto40Container, 
                        TABLE_SIZE(m_wzCrypto40Container), 
                        m_wzServiceName,
                        TABLE_SIZE(m_wzCrypto40Container) - wcslen(x_40) - wcslen(x_Provider40)
                        );
    if(FAILED(hr))
        throw CMqclusException();
    hr = StringCchCat(m_wzCrypto40Container, TABLE_SIZE(m_wzCrypto40Container), x_40);
    if(FAILED(hr))
        throw CMqclusException();    


    //
    // m_wzCrypto40FullKey = 1\\Microsoft Base Cryptographic Provider v1.0\\MSMQ$MSMQ_40
    //
    //
    hr = StringCchCopy(m_wzCrypto40FullKey, TABLE_SIZE(m_wzCrypto40FullKey), x_Provider40);
    if(FAILED(hr))
        throw CMqclusException();
    hr = StringCchCat(m_wzCrypto40FullKey, TABLE_SIZE(m_wzCrypto40FullKey), m_wzCrypto40Container);
    if(FAILED(hr))
    {
        ASSERT(("m_wzCrypto40FullKey does not have enough space for the operation!",0));
        throw CMqclusException();
    }

    LPCWSTR x_128 = L"_128";
    LPCWSTR x_Provider128 = L"1\\Microsoft Enhanced Cryptographic Provider v1.0\\";

    //
    // Generate a container name, i.e. MSMQ$MSMQ_128
    //
    hr = StringCchCopyN(m_wzCrypto128Container, 
                        TABLE_SIZE(m_wzCrypto128Container), 
                        m_wzServiceName,
                        TABLE_SIZE(m_wzCrypto128Container) - wcslen(x_128) - wcslen(x_Provider128)
                        );
    if(FAILED(hr))
        throw CMqclusException();
    hr = StringCchCat(m_wzCrypto128Container, TABLE_SIZE(m_wzCrypto128Container), x_128);
    if(FAILED(hr))
        throw CMqclusException();

    //
    // m_wzCrypto128FullKey = 1\\Microsoft Enhanced Cryptographic Provider v1.0\\MSMQ$MSMQ_128
    //
    //
    hr = StringCchCopy(m_wzCrypto128FullKey, TABLE_SIZE(m_wzCrypto128FullKey), x_Provider128);
    if(FAILED(hr))
		throw CMqclusException();
    hr = StringCchCat(m_wzCrypto128FullKey, TABLE_SIZE(m_wzCrypto128FullKey), m_wzCrypto128Container);
    if(FAILED(hr))
    {
        ASSERT(("m_wzCrypto128FullKey does not have enough space for the operation!",0));
        throw CMqclusException();
    }
	//
	// Initialize Event Log data
	//
	CreateEventSourceRegistry();

	//
    // Initialize registry section - idempotent
    //
    // The registry section name of this QM resource MUST be
    // identical to the service name. The registry routines
    // in mqutil.dll are based on that.
    //

    ASSERT(("copying to non allocated memory!",
            TABLE_SIZE(m_wzFalconRegSection) > wcslen(FALCON_CLUSTERED_QMS_REG_KEY) +
                                               wcslen(m_wzServiceName)              +
                                               wcslen(FALCON_REG_KEY_PARAM)));
    C_ASSERT(TABLE_SIZE(m_wzFalconRegSection)> TABLE_SIZE(FALCON_CLUSTERED_QMS_REG_KEY) +
                                               TABLE_SIZE(m_wzServiceName)              +
                                               TABLE_SIZE(FALCON_REG_KEY_PARAM));

    hr = StringCchCopy(m_wzFalconRegSection, TABLE_SIZE(m_wzFalconRegSection), FALCON_CLUSTERED_QMS_REG_KEY);
    if(FAILED(hr))
        throw CMqclusException();
    hr = StringCchCat(m_wzFalconRegSection, TABLE_SIZE(m_wzFalconRegSection), m_wzServiceName);
    if(FAILED(hr))
        throw CMqclusException();
    hr = StringCchCat(m_wzFalconRegSection, TABLE_SIZE(m_wzFalconRegSection), FALCON_REG_KEY_PARAM);
    if(FAILED(hr))
        throw CMqclusException();
	//
	// Delete possible leftovers from a resource with the same name.
	// This is possible when a resource with the same name was created on one
	// node, but failed over, and was deleted on another node.
	// Note that Open() can be called not only on resource creation (eg. clussvc startup).
	// But if the registry section belongs to an existing resource, it is checkpointed,
	// so the data will not be lost and will be restored when resource comes online.
	//
    RegDeleteTree(FALCON_REG_POS, m_wzFalconRegSection);

    CAutoCloseRegHandle hKey;
    DWORD dwDisposition = 0;
    LONG rc = RegCreateKeyEx(FALCON_REG_POS,
                             m_wzFalconRegSection,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_SET_VALUE | KEY_QUERY_VALUE,
                             NULL,
                             &hKey,
                             &dwDisposition
                             );
    if (ERROR_SUCCESS != rc)
    {
        ASSERT(("Failed to create registry section!", 0));

        SetLastError(rc);
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"Failed to create MSMQ registy. Error 0x%1!x!\n", rc);

        throw CMqclusException();
    }

    SetFalconKeyValue(FALCON_RM_CLIENT_NAME_REGNAME, REG_SZ, m_wzServiceName,
                      (wcslen(m_wzServiceName) + 1) * sizeof(WCHAR));

    SetFalconKeyValue(MSMQ_DRIVER_REGNAME, REG_SZ, m_wzDriverName,
                      (wcslen(m_wzDriverName) + 1) * sizeof(WCHAR));

    const DWORD xDwSize = sizeof(DWORD);
    const DWORD xGuidSize = sizeof(GUID);

    //
    // In the case of migrated QM (QM that was upgraded from the old
    // msmq resource type), setup status is "upgraded from NT4" or
    // "upgraded from win2k beta3".
    //
    DWORD dwSetupStatus = MSMQ_SETUP_FRESH_INSTALL;
    dwSize = sizeof(DWORD);
    if (!GetFalconKeyValue(MSMQ_SETUP_STATUS_REGNAME, &dwSetupStatus, &dwSize))
    {
        SetFalconKeyValue(MSMQ_SETUP_STATUS_REGNAME, REG_DWORD, &dwSetupStatus, xDwSize);
    }

    DWORD dwOldMqs = 0;
    SetFalconKeyValue(MSMQ_MQS_REGNAME, REG_DWORD, &dwOldMqs, xDwSize);

    DWORD dwMqsDsServer = 0;
    SetFalconKeyValue(MSMQ_MQS_DSSERVER_REGNAME, REG_DWORD, &dwMqsDsServer, xDwSize);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    {
        CS lock(s_csReg);
        pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

        pfGetFalconKeyValue(MSMQ_MQS_ROUTING_REGNAME, &dwType, &m_dwMqsRouting, &dwSize, NULL);
    }
    SetFalconKeyValue(MSMQ_MQS_ROUTING_REGNAME, REG_DWORD, &m_dwMqsRouting, xDwSize);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    {
        CS lock(s_csReg);
        pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

        pfGetFalconKeyValue(MSMQ_MQS_DEPCLINTS_REGNAME, &dwType, &m_dwMqsDepClients, &dwSize, NULL);
    }
    SetFalconKeyValue(MSMQ_MQS_DEPCLINTS_REGNAME, REG_DWORD, &m_dwMqsDepClients, xDwSize);

	dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    DWORD dwMqsLockdown = MSMQ_LOCKDOWN_DEFAULT;
    {
        CS lock(s_csReg);
        pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

        pfGetFalconKeyValue(MSMQ_LOCKDOWN_REGNAME, &dwType, &dwMqsLockdown, &dwSize, NULL);
    }
    if (dwMqsLockdown != MSMQ_LOCKDOWN_DEFAULT)
    {
    	SetFalconKeyValue(MSMQ_LOCKDOWN_REGNAME, REG_DWORD, &dwMqsLockdown, xDwSize);
    }

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    DWORD dwMqsDenyOldRemoteRead = MSMQ_DENY_OLD_REMOTE_READ_DEFAULT;
    {
        CS lock(s_csReg);
        pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

        pfGetFalconKeyValue(MSMQ_DENY_OLD_REMOTE_READ_REGNAME, &dwType, &dwMqsDenyOldRemoteRead, &dwSize, NULL);
    }
    if (dwMqsLockdown != MSMQ_DENY_OLD_REMOTE_READ_DEFAULT)
    {
    	SetFalconKeyValue(MSMQ_DENY_OLD_REMOTE_READ_REGNAME, REG_DWORD, &dwMqsDenyOldRemoteRead, xDwSize);
    }

    dwType = REG_SZ;
	WCHAR wzBuild[MAX_REG_DEFAULT_LEN] = L"";
	dwSize = sizeof(wzBuild);
	{
        CS lock(s_csReg);
        pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

        pfGetFalconKeyValue(MSMQ_CURRENT_BUILD_REGNAME, &dwType, wzBuild, &dwSize, NULL);
    }
	if (wcscmp(wzBuild, L"") != 0)
	{
	    SetFalconKeyValue(MSMQ_CURRENT_BUILD_REGNAME, REG_SZ, wzBuild, (wcslen(wzBuild) + 1) * sizeof(WCHAR));
	}

    

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    {
        CS lock(s_csReg);
        pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

        pfGetFalconKeyValue(MSMQ_WORKGROUP_REGNAME, &dwType, &m_dwWorkgroup, &dwSize, NULL);
    }

    if (m_dwWorkgroup != 0)
    {
        SetFalconKeyValue(MSMQ_WORKGROUP_REGNAME, REG_DWORD, &m_dwWorkgroup, xDwSize);
    }
    else
    {
        dwType = REG_BINARY;
        dwSize = sizeof(GUID);
        GUID guidEnterprise = GUID_NULL;
        {
            CS lock(s_csReg);
            pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

            if (ERROR_SUCCESS != pfGetFalconKeyValue(MSMQ_ENTERPRISEID_REGNAME, &dwType, &guidEnterprise, &dwSize, NULL))
            {
                ReportLastError(READ_REGISTRY_ERR, L"Failed to read Enterprise ID from MSMQ registry", NULL);
                throw CMqclusException();
            }
        }
        SetFalconKeyValue(MSMQ_ENTERPRISEID_REGNAME, REG_BINARY, &guidEnterprise,xGuidSize);

        dwType = REG_BINARY;
        dwSize = sizeof(GUID);
        GUID guidSite = GUID_NULL;
        {
            CS lock(s_csReg);
            pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

            if (ERROR_SUCCESS != pfGetFalconKeyValue(MSMQ_SITEID_REGNAME, &dwType, &guidSite, &dwSize, NULL))
            {
                ReportLastError(READ_REGISTRY_ERR, L"Failed to read Site ID from MSMQ registry", NULL);
                throw CMqclusException();
            }
        }
        SetFalconKeyValue(MSMQ_SITEID_REGNAME, REG_BINARY, &guidSite, xGuidSize);

		//
		// Handle DsServer registry only for MQIS environment
		//
		dwType = REG_DWORD;
		dwSize = sizeof(DWORD);
		DWORD DsEnvironment;
		{
			CS lock(s_csReg);
			pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

            if (ERROR_SUCCESS != pfGetFalconKeyValue(MSMQ_DS_ENVIRONMENT_REGNAME, &dwType, &DsEnvironment, &dwSize, NULL))
            {
                ReportLastError(READ_REGISTRY_ERR, L"Failed to read Ds Environment from MSMQ registry", NULL);
                throw CMqclusException();
            }
		}

		ASSERT(DsEnvironment != MSMQ_DS_ENVIRONMENT_UNKNOWN);
		if(DsEnvironment == MSMQ_DS_ENVIRONMENT_MQIS)
		{
	        m_fServerIsMsmq1 = true;
			
			dwType = REG_SZ;
			WCHAR wzServer[MAX_REG_DSSERVER_LEN] = L"";
			dwSize = sizeof(wzServer);
			{
                CS lock(s_csReg);
                pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);
                if (ERROR_SUCCESS != pfGetFalconKeyValue(MSMQ_DS_SERVER_REGNAME, &dwType, wzServer, &dwSize, NULL))
                {
                    ReportLastError(READ_REGISTRY_ERR, L"Failed to read server list from MSMQ registry", NULL);
                    throw CMqclusException();
                }
            }
            SetFalconKeyValue(MSMQ_DS_SERVER_REGNAME, REG_SZ, wzServer, (wcslen(wzServer) + 1) * sizeof(WCHAR));

            dwType = REG_SZ;
            dwSize = sizeof(m_wzCurrentDsServer);
            {
                CS lock(s_csReg);
                pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

                if (ERROR_SUCCESS != pfGetFalconKeyValue(MSMQ_DS_CURRENT_SERVER_REGNAME, &dwType, m_wzCurrentDsServer, &dwSize, NULL))
                {
                    ReportLastError(READ_REGISTRY_ERR, L"Failed to read current server from MSMQ registry", NULL);
                    throw CMqclusException();
                }
            }
            if (wcslen(m_wzCurrentDsServer) < 1)
            {
                //
                // Current MQIS server is blank. Take the first server from the server list.
                //
                ASSERT(("must have server list in registry", wcslen(wzServer) > 0));
                WCHAR wzBuffer[MAX_REG_DSSERVER_LEN] = L"";
                hr = StringCchCopy(wzBuffer, TABLE_SIZE(wzBuffer), wzServer);
                if(FAILED(hr))throw CMqclusException();

				WCHAR * pwz = wcschr(wzBuffer, L',');
                if (pwz != NULL)
                {
                    (*pwz) = L'\0';
                }
                hr = StringCchCopy(m_wzCurrentDsServer, TABLE_SIZE(m_wzCurrentDsServer), wzBuffer);
            }
            SetFalconKeyValue(MSMQ_DS_CURRENT_SERVER_REGNAME, 
                              REG_SZ, 
                              m_wzCurrentDsServer, 
                              (wcslen(m_wzCurrentDsServer) + 1) * sizeof(WCHAR)
                              );
        }

        SetFalconKeyValue(MSMQ_CRYPTO40_CONTAINER_REG_NAME, REG_SZ, m_wzCrypto40Container,
                          (wcslen(m_wzCrypto40Container) + 1) * sizeof(WCHAR));

        SetFalconKeyValue(MSMQ_CRYPTO128_CONTAINER_REG_NAME, REG_SZ, m_wzCrypto128Container,
                          (wcslen(m_wzCrypto128Container) + 1) * sizeof(WCHAR));
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"resource constructed OK.\n");

} //CQmResource::CQmResource


DWORD
CQmResource::ReportLastError(
    DWORD ErrId,
    LPCWSTR pwzDebugLogMsg,
    LPCWSTR pwzArg
    ) const

/*++

Routine Description:

    Report error messages based on last error.
    Most error messages are reported using this routine.
    The report goes to MSMQ debug output and to cluster
    log file.

Arguments:

    ErrId - ID of the error string in mqsymbls.mc

    pwzDebugLogMsg - Non localized string for MSMQ debug output.

    pwzArg - Additional string argument.

Return Value:

    Last error.

--*/

{
    DWORD err = GetLastError();
    ASSERT(err != ERROR_SUCCESS);

    WCHAR wzErr[10];
    _ultow(err, wzErr, 16);

    WCHAR DebugMsg[255] = L"";
    HRESULT hr = StringCchCopy(DebugMsg, TABLE_SIZE(DebugMsg), pwzDebugLogMsg);
    if(FAILED(hr))return HRESULT_CODE(hr);

    if (pwzArg == NULL)
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, ErrId, 1, wzErr);

        hr = StringCchCat(DebugMsg, TABLE_SIZE(DebugMsg), L" Error 0x%1!x!.\n");
        if(FAILED(hr))return HRESULT_CODE(hr);
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, DebugMsg, err);
    }
    else
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, ErrId, 2, pwzArg, wzErr);

        hr = StringCchCat(DebugMsg, TABLE_SIZE(DebugMsg), L" Error 0x%2!x!.\n");
        if(FAILED(hr))return HRESULT_CODE(hr);
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, DebugMsg, pwzArg, err);
    }

    return err;

} //CQmResource::ReportLastError


inline
VOID
CQmResource::ReportState(
    VOID
    ) const

/*++

Routine Description:

    Report status of the resource to resource monitor.
    This routine is called to report progress when the
    resource is online pending, and to report final status
    when the resource is online or offline.

Arguments:

    None

Return Value:

    None

--*/

{
    ++m_ResourceStatus.CheckPoint;
    g_pfSetResourceStatus(m_hReport, &m_ResourceStatus);

} //CQmResource::ReportState


VOID
CQmResource::RegDeleteTree(
    HKEY hRootKey,
    LPCWSTR pwzKey
    ) const

/*++

Routine Description:

    Recursively delete registry key and all its subkeys - idempotent.

Arguments:

    hRootKey - Handle to the root key of the key to be deleted

    pwzKey   - Key to be deleted

Return Value:

    None

--*/

{
    HKEY hKey = 0;
    if (ERROR_SUCCESS != RegOpenKeyEx(hRootKey, pwzKey, 0, KEY_ENUMERATE_SUB_KEYS | KEY_WRITE, &hKey))
    {
        return;
    }

    for (;;)
    {
        //
        // REG_MAX_KEY_NAME_LENGTH is defined in ntregapi.h as follow:
        //    #define REG_MAX_KEY_NAME_LENGTH         512       // allow for 256 unicode, as promise
        //
        WCHAR wzSubkey[REG_MAX_KEY_NAME_LENGTH/sizeof(WCHAR)]={0};
        DWORD cbSubkey = 0;

        cbSubkey = TABLE_SIZE(wzSubkey);
        if (ERROR_SUCCESS != RegEnumKeyEx(hKey, 0, wzSubkey, &cbSubkey, NULL, NULL, NULL, NULL))
        {
            break;
        }

        RegDeleteTree(hKey, wzSubkey);
    }

    RegCloseKey(hKey);

    RegDeleteKey(hRootKey, pwzKey);

} //CQmResource::RegDeleteTree


VOID
CQmResource::DeleteFalconRegSection(
    VOID
    )
{
    //
    // Idempotent deletion
    //

    if (wcslen(m_wzFalconRegSection) < 1)
    {
        return;
    }

    WCHAR wzFalconRegistry[TABLE_SIZE(m_wzFalconRegSection)] = L"";
    HRESULT hr = StringCchCopy(wzFalconRegistry, TABLE_SIZE(wzFalconRegistry), FALCON_CLUSTERED_QMS_REG_KEY);
    if(FAILED(hr))return;

    hr = StringCchCatN(wzFalconRegistry, 
                      TABLE_SIZE(wzFalconRegistry), 
                      m_wzServiceName,
                      TABLE_SIZE(wzFalconRegistry) - wcslen(FALCON_CLUSTERED_QMS_REG_KEY) - wcslen(FALCON_REG_KEY_PARAM));

    if(FAILED(hr))return;
    

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Deleting registry section '%1'.\n", wzFalconRegistry);

    RegDeleteTree(FALCON_REG_POS, wzFalconRegistry);

    m_wzFalconRegSection[0] = L'\0';

} //CQmResource::DeleteFalconRegSection


bool
CQmResource::GetFalconKeyValue(
    LPCWSTR pwzValueName,
    VOID  * pData,
    DWORD * pcbSize
    ) const

/*++

Routine Description:

    Read a registry value from this clustered QM registry section

Arguments:

    pwzValueName - Name of the value to read.

    pData - Points to buffer to receive the value.

    pcbSize - Points to size of value data, in bytes.

Return Value:

    true - Value was read and placed in buffer.

    false - Failed to read the value.

--*/

{
    CQmResourceRegistry lock(m_wzServiceName);

    //
    // Don't log errors. Let caller implement failure policy.
    //
    return (ERROR_SUCCESS == pfGetFalconKeyValue(pwzValueName, NULL, pData, pcbSize, NULL));

} //CQmResource::GetFalconKeyValue


bool
CQmResource::SetFalconKeyValue(
    LPCWSTR pwzValueName,
    DWORD   dwType,
    const VOID * pData,
    DWORD   cbSize
    ) const

/*++

Routine Description:

    Set a registry value in this clustered QM registry section

Arguments:

    pwzValueName - Name of the value to set.

    dwType - Type of value to be set

    pData - Points to buffer with the value to be set

    cbSize - Size of value data, in bytes.

Return Value:

    true - Value was set successfully.

    false - Failed to set the value.

--*/

{
    CQmResourceRegistry lock(m_wzServiceName);

    LONG rc = pfSetFalconKeyValue(pwzValueName, &dwType, pData, &cbSize);

    if (ERROR_SUCCESS != rc)
    {
        SetLastError(rc);
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"Failed to set registry value '%1'. Error 0x%2!x!.\n",
                              pwzValueName, rc);

        return false;
    }

    switch (dwType)
    {
        case REG_DWORD:
        {
            DWORD dwValueData = *(static_cast<const DWORD*>(pData));
            (g_pfLogClusterEvent)(
                m_hReport,
                LOG_INFORMATION,
                L"Successfully set registry DWORD value '%1'. Value data: '0x%2!x!'.\n",
                pwzValueName,
                dwValueData
                );
            break;
        }
        case REG_SZ:
        {
            (g_pfLogClusterEvent)(
                m_hReport,
                LOG_INFORMATION,
                L"Successfully set registry STRING value '%1'. Value data: '%2'.\n",
                pwzValueName,
                pData
                );
            break;
        }
        default:
        {
            (g_pfLogClusterEvent)(
                m_hReport,
                LOG_INFORMATION,
                L"Successfully set registry value '%1'.\n",
                pwzValueName
                );
            break;
        }
    }

    return true;

} //CQmResource::SetFalconKeyValue


bool
CQmResource::IsFirstOnline(
    DWORD * pdwSetupStatus
    ) const

/*++

Routine Description:

    Checks in registry if this QM was ever running.
    If the case of migrated QM (QM that was upgraded
    from the old msmq resource type), this routine
    will return true iff this is first online of
    the QM as the new resource type.

Arguments:

    pdwSetupStatus - On output points to this QM setup status.

Return Value:

    true - This QM has never been up and running (or in
      the case of migrated QM: never been up as the new
      resource type).

    false - This QM was up and running.

--*/

{
	//
    // This reg value is deleted by QM on first successful startup
    //
    // In the case of migrated QM (QM that was upgraded from the old
    // msmq resource type), setup status is "upgraded from NT4" or
    // "upgraded from win2k beta3".
    // In the normal case, setup status is "fresh install".
    //

    (*pdwSetupStatus) = MSMQ_SETUP_DONE;
    DWORD dwSize = sizeof(DWORD);
    return (GetFalconKeyValue(MSMQ_SETUP_STATUS_REGNAME, pdwSetupStatus, &dwSize) &&
            MSMQ_SETUP_DONE != *pdwSetupStatus);
	
} //CQmResource::IsFirstOnline


DWORD
CQmResource::ClusterResourceControl(
    LPCWSTR pwzResourceName,
    DWORD dwControlCode,
    LPBYTE * ppBuffer,
    DWORD * pcbSize
    ) const

/*++

Routine Description:

    Wrapper for ClusterResourceControl.
    We want to control resources such as network name and disk.

    Note that most of the control code functions should not be called
    by resource DLLs, unless from within the online/offline threads.

Arguments:

    pwzResourceName - Name of resource to control.

    dwControlCode - Operation to perform on the resource.

    ppBuffer - Pointer to pointer to output buffer to be allocated.

    pcbSize - Pointer to allocated size of buffer, in bytes.

Return Value:

    Win32 error code.

--*/

{
    ASSERT(("must have a valid handle to cluster", m_hCluster != NULL));

    CClusterResource hResource(OpenClusterResource(
                                   m_hCluster,
                                   pwzResourceName
                                   ));
    if (hResource == NULL)
    {
        return ReportLastError(OPEN_RESOURCE_ERR, L"OpenClusterResource for '%1' failed.", pwzResourceName);
    }

    DWORD dwReturnSize = 0;
    DWORD dwStatus = ::ClusterResourceControl(
                           hResource,
                           0,
                           dwControlCode,
                           0,
                           0,
                           0,
                           0,
                           &dwReturnSize
                           );
    if (dwStatus != ERROR_SUCCESS)
    {
        return dwStatus;
    }
    ASSERT(("failed to get buffer size for a resource", 0 != dwReturnSize));

    *ppBuffer = new BYTE[dwReturnSize];

    dwStatus = ::ClusterResourceControl(
                     hResource,
                     0,
                     dwControlCode,
                     0,
                     0,
                     *ppBuffer,
                     dwReturnSize,
                     &dwReturnSize
                     );

    if (pcbSize != NULL)
    {
        *pcbSize = dwReturnSize;
    }

    return dwStatus;

} //CQmResource::ClusterResourceControl


DWORD
CQmResource::GetVirtualServerToken(
	HANDLE* phVSToken
    ) const
/*++

Routine Description:
    Get Virtual server token.
    The calling function is responsible for closing this handle.

Arguments:
    phVSToken - pointer to Virtual server token to be returned.

Return Value:
    Win32 error code.

--*/
{
    ASSERT(("must have a valid handle to cluster", m_hCluster != NULL));

    CClusterResource hResource(OpenClusterResource(
                                   m_hCluster,
                                   m_pwzNetworkResourceName
                                   ));
    if (hResource == NULL)
    {
        return ReportLastError(OPEN_RESOURCE_ERR, L"OpenClusterResource for '%1' failed.", m_pwzNetworkResourceName);
    }

    struct CLUS_NETNAME_VS_TOKEN_INFO VsTokenInfo;
	VsTokenInfo.ProcessID = GetCurrentProcessId();
	VsTokenInfo.DesiredAccess = 0;
	VsTokenInfo.InheritHandle = FALSE;

    DWORD dwReturnSize = 0;
    DWORD dwStatus = ::ClusterResourceControl(
                           hResource,
                           0,
                           CLUSCTL_RESOURCE_NETNAME_GET_VIRTUAL_SERVER_TOKEN,
                           &VsTokenInfo,
                           sizeof(CLUS_NETNAME_VS_TOKEN_INFO),
                           phVSToken,
                           sizeof(HANDLE),
                           &dwReturnSize
                           );
    
    if (dwStatus != ERROR_SUCCESS)
    {
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"ClusterResourceControl for control GET_VIRTUAL_SERVER_TOKEN Failed. Error 0x%1!x!.\n", dwStatus);
    }
	return dwStatus;

} //CQmResource::GetVirtualServerToken


bool CQmResource::IsNetworkNameRequireKerberosEnabled() const
/*++

Routine Description:
    Check if NetworkName RequireKerberos (RK) property is enabled.
    the code of the netname resource create the
    computer object in active directory. 
	This is done if netname property "RequireKerberos" is 1. 

Arguments:
    None.

Return Value:
	true - RK is enabled, false otherwise.

--*/
{
    if (m_fServerIsMsmq1 || m_dwWorkgroup)
    {
    	return false;
    }

    //
    // domain mode in AD domain.
    // The computer object is created by the netname
    // resource, if RequireKerberos is set to 1.
    // Check that the flag is indeed 1. 
	// If not, we will latter (when failing to create MSMQ configuration object)
	// we will issue an event and print an error event in cluster.log.
    //
    AP<BYTE> pBufferRK;
    DWORD cbSize = 0;

    DWORD dwStatus = ClusterResourceControl(
                         m_pwzNetworkResourceName,
                         CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,
                         &pBufferRK,
                         &cbSize 
						 );


	if ((dwStatus != ERROR_SUCCESS) || (pBufferRK == NULL)) 
	{
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR,
                  L"Failed to control resource (GET_PRIVATE). Error 0x%1!x!, pBuffer- 0x%2!x!.\n",
                  dwStatus, pBufferRK);
		return false;
	}
    
    DWORD requireKerberos = 0;
    dwStatus = ResUtilFindDwordProperty( 
					pBufferRK,
					cbSize,
					L"RequireKerberos",
					&requireKerberos 
					);

    if (dwStatus != ERROR_SUCCESS)
    {
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"Failed to get value of RequireKerberos. Error 0x%1!x!.\n", dwStatus);
		return false;
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Network name RequireKerberos = %1!x!.\n", requireKerberos);
	return (requireKerberos != 0);
}


bool
CQmResource::IsResourceNetworkName(
    LPCWSTR pwzResourceName
    )

/*++

Routine Description:

    Check if a resource is of type Network Name.

Arguments:

    pwzResourceName - Name of resource to check upon.

Return Value:

    true - Resource is of type Network Name

    false - Resource is not of type Network Name

--*/

{
    LPCWSTR x_NETWORK_NAME_TYPE = L"Network Name";
    AP<BYTE> pType;
    DWORD status = ClusterResourceControl(
                       pwzResourceName,
                       CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                       &pType,
                       NULL
                       );
    if (status != ERROR_SUCCESS ||
        0 != CompareStringsNoCase(reinterpret_cast<LPWSTR>(pType.get()), x_NETWORK_NAME_TYPE))
    {
        return false;
    }

    AP<BYTE> pBuffer;
    DWORD dwStatus = ClusterResourceControl(
                         pwzResourceName,
                         CLUSCTL_RESOURCE_GET_NETWORK_NAME,
                         &pBuffer,
                         NULL
                         );


    ReportState();

    if (dwStatus != ERROR_SUCCESS)
    {
        ASSERT(("ClusterResourceControl failed for network name resource!", 0));

        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR,
                              L"Failed to control resource. Control Code 0x%1!x!. Error 0x%2!x!.\n",
                              CLUSCTL_RESOURCE_GET_NETWORK_NAME, dwStatus);

        return false;
    }

    LPCWSTR x_pwzNetworkName = reinterpret_cast<LPCWSTR>(pBuffer.get());

    m_pwzNetworkName.free();
    DWORD cbSize = wcslen(x_pwzNetworkName) + 1;
    m_pwzNetworkName = new WCHAR[cbSize];
    HRESULT hr = StringCchCopy(m_pwzNetworkName, cbSize, x_pwzNetworkName);

    if(FAILED(hr))return false;
    
    m_pwzNetworkResourceName.free();
    cbSize = wcslen(pwzResourceName) + 1;
    m_pwzNetworkResourceName = new WCHAR[cbSize];
    hr = StringCchCopy(m_pwzNetworkResourceName, cbSize, pwzResourceName);
    if(FAILED(hr))return false;
    
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Network name is '%1'.\n", m_pwzNetworkName);

    return true;

}//CQmResource::IsResourceNetworkName


bool
CQmResource::IsResourceDiskDrive(
    LPCWSTR pwzResourceName
    )

/*++

Routine Description:

    Check if a resource is a disk drive.

Arguments:

    pwzResourceName - Name of resource to check upon.

Return Value:

    true - Resource is a disk drive.

    false - Resource is not a disk drive.

--*/

{
    CClusterResource hResource(OpenClusterResource(m_hCluster, pwzResourceName));
    if (hResource == NULL)
    {
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, 
            L"OpenClusterResource for '%1' failed. Error 0x%2!x!.\n", pwzResourceName, GetLastError());
        return false;
    }

    ReportState();

    CLUS_RESOURCE_CLASS_INFO  crciClassInfo;
	crciClassInfo.rc = CLUS_RESCLASS_UNKNOWN;

    DWORD dwSize = 0;
    DWORD status = ::ClusterResourceControl(
					    hResource, 							// Resource to send control to
					    NULL,								// hNode -> NULL == any node
					    CLUSCTL_RESOURCE_GET_CLASS_INFO,	// Want res type
					    NULL,								// Ptr to In buffer
					    0,									// Size of In buffer
					    (LPVOID) &crciClassInfo,			// Ptr to Out buffer
					    (DWORD)  sizeof(crciClassInfo),		// Size of Out buffer
					    &dwSize
                        );

    ReportState();

    ASSERT(dwSize == (DWORD)sizeof(crciClassInfo));

    if (status != ERROR_SUCCESS ||
        CLUS_RESCLASS_STORAGE != crciClassInfo.rc || 
 	    CLUS_RESSUBCLASS_SHARED != crciClassInfo.SubClass
       )
    {
        //
        // Not a storage type resource. Return
        //
        return false;
    }

    AP<BYTE> pBuffer = 0;
    dwSize = 0;
    DWORD dwStatus = ClusterResourceControl(
                         pwzResourceName,
                         CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                         &pBuffer,
                         &dwSize
                         );

    ReportState();

    if (dwStatus != ERROR_SUCCESS)
    {
        ASSERT(("ClusterResourceControl failed for disk resource!", 0));

        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR,
                              L"Failed to control resource. Control Code 0x%1!x!. Error 0x%2!x!.\n",
                              CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO, dwStatus);
        return false;
    }

    //
    // Look for the drive letter
    //
    CLUSPROP_VALUE *pheader;

    DWORD dwCurrentLocation = 0;
    while(dwCurrentLocation < dwSize)
    {
        pheader = (CLUSPROP_VALUE *)(pBuffer + dwCurrentLocation);
        if (CLUSPROP_TYPE_ENDMARK == pheader->Syntax.wType)
        {
            break;
        }
        if (CLUSPROP_TYPE_PARTITION_INFO == pheader->Syntax.wType)
        {
            PCLUSPROP_PARTITION_INFO pPartitionInfo =
                (PCLUSPROP_PARTITION_INFO) pheader;

            m_wDiskDrive = pPartitionInfo->szDeviceName[0];

            (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"disk drive is '%1!c!'.\n", m_wDiskDrive);

            return true;
        }
        dwCurrentLocation += ALIGN_CLUSPROP(pheader->cbLength) + sizeof(*pheader);
    }


    ASSERT(("failed to find disk drive letter for a disk resource", 0));
    (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"drive letter not found.\n");

    return false;

} //CQmResource::IsResourceDiskDrive


DWORD
CQmResource::QueryResourceDependencies(
    VOID
    )

/*++

Routine Description:

    Get and store the first disk and network name resources
    we're depended on.
    Keep this routine idempotent.

Arguments:

    None

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    DWORD dwResourceType = CLUSTER_RESOURCE_ENUM_DEPENDS;
    CResourceEnum hResEnum(ClusterResourceOpenEnum(
                               m_hResource,
                               dwResourceType
                               ));
    if (hResEnum == NULL)
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, REQUIRED_DEPENDENCIES_ERR, 0);

        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR,L"Failed to enum dependencies. Error 0x%1!x!.\n",
                              GetLastError());

        return GetLastError();
    }

    DWORD dwIndex = 0;
    WCHAR wzResourceName[260] = {0};
    DWORD status = ERROR_SUCCESS;

    for (;;)
    {
        if (m_wDiskDrive != 0            &&
            m_pwzNetworkName != NULL     &&
            wcslen(m_pwzNetworkName) != 0)
        {
            return ERROR_SUCCESS;
        }

        DWORD cchResourceName = STRLEN(wzResourceName);
        status = ClusterResourceEnum(
                     hResEnum,
                     dwIndex++,
                     &dwResourceType,
                     wzResourceName,
                     &cchResourceName
                     );

        if (ERROR_SUCCESS != status)
        {
            break;
        }


        ReportState();


        if (IsResourceNetworkName(wzResourceName) ||
            IsResourceDiskDrive(wzResourceName))
        {
            continue;
        }
    }

    MqcluspReportEvent(EVENTLOG_ERROR_TYPE, REQUIRED_DEPENDENCIES_ERR, 0);

    return status;

} //CQmResource::QueryResourceDependencies


DWORD
CQmResource::QueryMsmq1ServerForSite(
    VOID
    )

/*++

Routine Description:

    Query the MSMQ1 server for site.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/
{
    PROPID propIdSiteGuid = PROPID_QM_SITE_ID;
    PROPVARIANT propVarSiteGuid;
    propVarSiteGuid.vt = VT_NULL;

    WCHAR wzServer[MAX_REG_DSSERVER_LEN] = {L""};
    WCHAR wzBuffer[MAX_REG_DSSERVER_LEN] = {L""};
    HRESULT hr = StringCchCopy(wzBuffer, TABLE_SIZE(wzBuffer), m_wzCurrentDsServer);
    if(FAILED(hr))return HRESULT_CODE(hr);

    ASSERT(wcslen(wzBuffer) > 2);
    hr = StringCchCopy(wzServer, TABLE_SIZE(wzServer), &wzBuffer[2]);

    if(FAILED(hr))return HRESULT_CODE(hr);

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Querying Message Queuing Server '%1'...\n", wzServer);

    hr = ADGetObjectProperties(eMACHINE,
                               NULL,	// pwcsDomainController
                               false,	// fServerName
                               wzServer,
                               1,
                               &propIdSiteGuid,
                               &propVarSiteGuid
						       );

    ReportState();

    if (FAILED(hr))
    {
        SetLastError(hr);
        return ReportLastError(ADS_QUERY_SERVER_ERR, L"Querying MSMQ server '%1' for Sites failed", wzServer);
    }

    m_pguidSites = propVarSiteGuid.puuid;
    m_nSites = 1;

    MqcluspReportEvent(EVENTLOG_INFORMATION_TYPE, CONNECT_SERVER_OK, 1, wzServer);
    return ERROR_SUCCESS;
}


DWORD
CQmResource::AdsInit(
    VOID
    )

/*++

Routine Description:

    Initialize calls from this DLL to ADS.
    Query the MSMQ server and decide if it's MSMQ 1.0 or 2.0.
    Get main QM's ADS sites.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    if (m_dwWorkgroup != 0)
    {
        return ERROR_SUCCESS;
    }

    //
    // No need to reinitialize
    //
    if (0 < m_nSites)
    {
        return ERROR_SUCCESS;
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Initializing access to Active Directory...\n");
    HRESULT hr = ADInit(
					NULL,
					NULL,
					true,
					false,
					false,
					true    //fDisableDownlevelNotifications
					);

    ReportState();

    if (FAILED(hr))
    {
        SetLastError(hr);
        return ReportLastError(ADS_INIT_ERR, L"ADInit failed.", NULL);
    }
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Access to Active Directory is initialized!\n");

	if(m_fServerIsMsmq1 && (ADGetEnterprise() == eAD))
	{
		//
		// ADInit updated the DS Environment to AD env.
		// This can happened in NT4 cluster upgrade 
		// when this is the first time we call ADInit after upgrade.
		//
		m_fServerIsMsmq1 = false;
		(g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Ds Environment was updated to Active Directory.\n");
	}
	
	if(m_fServerIsMsmq1)
	{
        (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Server is MSMQ 1.0.\n");
		return QueryMsmq1ServerForSite();
	}

	(g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"MSMQ is in Active Directory environment.\n");

    WCHAR wzNodeName[MAX_COMPUTERNAME_LENGTH + 1] = {0};
    DWORD dwLen = TABLE_SIZE(wzNodeName);
    GetComputerName(wzNodeName, &dwLen);

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Getting Sites of '%1'...\n", wzNodeName);
    hr = ADGetComputerSites(wzNodeName, &m_nSites, &m_pguidSites);

    ReportState();

    if (FAILED(hr))
    {
        SetLastError(hr);
        return ReportLastError(ADS_QUERY_SERVER_ERR, L"Querying MSMQ server '%1' for Sites failed", L"");
    }
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Successfully got sites of '%1'!\n", wzNodeName);

    MqcluspReportEvent(EVENTLOG_INFORMATION_TYPE, CONNECT_SERVER_OK, 1, L"");
    return ERROR_SUCCESS;

} //CQmResource::AdsInit


DWORD
CQmResource::AdsDeleteQmObject(
    VOID
    ) const

/*++

Routine Description:

    Delete the MSMQ objects from Active Directory
    (or from MQIS in the case of MSMQ 1.0 enterprise).

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    if (m_dwWorkgroup != 0)
    {
        return ERROR_SUCCESS;
    }

    //
    // Idempotent deletion.
    // There are scenarios inwhich the QM ADS object was not created,
    // e.g. when resource is created and deleted w/o attempt to bring
    // it online.
    //

    GUID guidQm = m_guidQm;
    if (guidQm == GUID_NULL)
    {
        DWORD dwSize = sizeof(GUID);
        if (!GetFalconKeyValue(MSMQ_QMID_REGNAME, &guidQm, &dwSize))
        {
            (g_pfLogClusterEvent)(m_hReport, LOG_WARNING, L"Can not delete QM ADS object (fail to obtain GUID).\n");
            return ERROR_SUCCESS;
        }
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Deleting Active Directory objects...\n");
    HRESULT hr = ADDeleteObjectGuid(
						eMACHINE,
						NULL,       // pwcsDomainController
						false,	    // fServerName
						&guidQm
						);

    if (FAILED(hr) &&
        MQDS_OBJECT_NOT_FOUND != hr)
    {
        (g_pfLogClusterEvent)(m_hReport, LOG_WARNING, L"Failed to delete MSMQ ADS object. Error 0x%1!x!.\n", hr);

        return hr;
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Successfully deleted Active Directory objects!\n");
    return ERROR_SUCCESS;

} //CQmResource::AdsDeleteQmObject


HRESULT
CQmResource::AdsCreateQmObjectInternal(
    BYTE* pClusterServiceSid
    ) const

/*++

Routine Description:

    Create the MSMQ objects in Active Directory for this QM.

Arguments:

    pClusterServiceSid - CSA (cluster service account) sid.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
	ASSERT(m_dwWorkgroup == 0);
    ASSERT(("no network name", m_pwzNetworkName != NULL && wcslen(m_pwzNetworkName) > 0));

    const DWORD x_MAX_PROPS = 16;
    PROPID propIds[x_MAX_PROPS];
    PROPVARIANT propVars[x_MAX_PROPS];
    DWORD ixProp = 0;

    propIds[ixProp] = PROPID_QM_MACHINE_TYPE;
    propVars[ixProp].vt = VT_LPWSTR;
    propVars[ixProp].pwszVal = L"";
    ++ixProp;

    propIds[ixProp] = PROPID_QM_OS;
    propVars[ixProp].vt = VT_UI4;
    propVars[ixProp].ulVal = pfMSMQGetOperatingSystem();
    ++ixProp;

    DWORD ixPropidMsmqGroupInCluster = 0;
    if (!m_fServerIsMsmq1)
    {
        propIds[ixProp] = PROPID_QM_SERVICE_DSSERVER;
        propVars[ixProp].vt = VT_UI1;
        propVars[ixProp].bVal = static_cast<UCHAR>(0);
        ++ixProp;

        propIds[ixProp] = PROPID_QM_SERVICE_ROUTING;
        propVars[ixProp].vt = VT_UI1;
        propVars[ixProp].bVal = static_cast<UCHAR>(m_dwMqsRouting);
        ++ixProp;

        propIds[ixProp] = PROPID_QM_SERVICE_DEPCLIENTS;
        propVars[ixProp].vt = VT_UI1;
        propVars[ixProp].bVal = static_cast<UCHAR>(m_dwMqsDepClients);
        ++ixProp;

        propIds[ixProp] = PROPID_QM_SITE_IDS;
        propVars[ixProp].vt = VT_CLSID|VT_VECTOR;
        propVars[ixProp].cauuid.pElems = m_pguidSites;
        propVars[ixProp].cauuid.cElems = m_nSites;
        ++ixProp;

		if(pClusterServiceSid != NULL)
		{
	        //
	        // We have the ClusterServiceSid (CSA).
	        // Add PROPID_QM_OWNER_SID so we will grant CSA permissions on msmq config object
	        //
	        propIds[ixProp] = PROPID_QM_OWNER_SID;
	        propVars[ixProp].vt = VT_BLOB;
	        propVars[ixProp].blob.pBlobData = pClusterServiceSid;
	        propVars[ixProp].blob.cbSize = GetLengthSid(pClusterServiceSid);
	        ++ixProp;
		}
		
        //
        // This PROPID is not supported by win2k beta3 servers.
        // Make sure it is the last one.
        //
        propIds[ixProp] = PROPID_QM_GROUP_IN_CLUSTER;
        propVars[ixProp].vt = VT_UI1;
        propVars[ixProp].bVal = MSMQ_GROUP_IN_CLUSTER;
        ixPropidMsmqGroupInCluster = ixProp;
        ++ixProp;
    }
    else
    {
        propIds[ixProp] = PROPID_QM_SERVICE;
        propVars[ixProp].vt = VT_UI4;
        propVars[ixProp].ulVal = SERVICE_NONE;
        if (0 != m_dwMqsRouting)
        {
            propVars[ixProp].ulVal = SERVICE_SRV;
        }
        ++ixProp;

        propIds[ixProp] = PROPID_QM_SITE_ID;
        propVars[ixProp].vt = VT_CLSID;
        propVars[ixProp].puuid = m_pguidSites;
        ++ixProp;

        propIds[ixProp] = PROPID_QM_PATHNAME;
        propVars[ixProp].vt = VT_LPWSTR;
        propVars[ixProp].pwszVal = m_pwzNetworkName;
        ixProp++;

        propIds[ixProp] = PROPID_QM_MACHINE_ID;
        propVars[ixProp].vt = VT_CLSID;
        GUID guidQm = GUID_NULL;
        RPC_STATUS rc = UuidCreate(&guidQm);
        DBG_USED(rc);;
        ASSERT(("Failed to generate a guid for QM", rc == RPC_S_OK));
        propVars[ixProp].puuid = &guidQm;
        ixProp++;

        propIds[ixProp] = PROPID_QM_CNS;
        propVars[ixProp].vt = VT_CLSID|VT_VECTOR;
        propVars[ixProp].cauuid.cElems = 1;
        GUID guidCns = MQ_SETUP_CN;
        propVars[ixProp].cauuid.pElems = &guidCns;
        ixProp++;

        BYTE Address[TA_ADDRESS_SIZE + IP_ADDRESS_LEN];
        TA_ADDRESS * pBuffer = reinterpret_cast<TA_ADDRESS *>(Address);
        pBuffer->AddressType = IP_ADDRESS_TYPE;
        pBuffer->AddressLength = IP_ADDRESS_LEN;
        ZeroMemory(pBuffer->Address, IP_ADDRESS_LEN);

        propIds[ixProp] = PROPID_QM_ADDRESS;
        propVars[ixProp].vt = VT_BLOB;
        propVars[ixProp].blob.cbSize = sizeof(Address);
        propVars[ixProp].blob.pBlobData = reinterpret_cast<BYTE*>(pBuffer);
        ixProp++;
    }

    if (!m_fServerIsMsmq1)
    {
        //
        // PROPID_QM_GROUP_IN_CLUSTER is not supported by win2k beta3 servers.
        // Make sure it is the last one.
        //
        ASSERT(("PROPID_QM_GROUP_IN_CLUSTER must be last one!", ixPropidMsmqGroupInCluster == (ixProp - 1)));
    }

	//
    // Idempotent creation
    //
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Creating MSMQ Object '%1' in Active Directory...\n",
                          m_pwzNetworkName);
    HRESULT hr = ADCreateObject(
						eMACHINE,
						NULL,       // pwcsDomainController
						false,	    // fServerName
						m_pwzNetworkName,
						NULL,
						ixProp,
						propIds,
						propVars,
						NULL
						);

    ReportState();

    if (hr == MQ_ERROR)
    {
        //
        // Try again w/o PROPID_QM_GROUP_IN_CLUSTER (which is not supported by win2k beta3 servers)
        //
        (g_pfLogClusterEvent)(m_hReport, LOG_WARNING, L"First chance fail to create MSMQ ADS object.\n");

        hr = ADCreateObject(
				eMACHINE, 
				NULL,       // pwcsDomainController
				false,	    // fServerName
				m_pwzNetworkName, 
				NULL, 
				--ixProp, 
				propIds, 
				propVars, 
				NULL
				);

        ReportState();
    }

    return hr;

} //CQmResource::AdsCreateQmObjectInternal


DWORD
CQmResource::AdsCreateQmObject(
    VOID
    ) const

/*++

Routine Description:

    Create the MSMQ objects in Active Directory for this QM.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    if (m_dwWorkgroup != 0)
    {
        return ERROR_SUCCESS;
    }

	HRESULT hr = AdsCreateQmObjectInternal(NULL);

	if(SUCCEEDED(hr))
	{
	    MqcluspReportEvent(EVENTLOG_INFORMATION_TYPE, ADS_CREATE_MSMQ_OK, 1, m_pwzNetworkName);
	    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Successfully created MSMQ ADS object.\n");

	    return ERROR_SUCCESS;
	}

    if (hr == MQ_ERROR_MACHINE_EXISTS)
    {
        (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"MSMQ ADS Object Already Exists !\n");
        return ERROR_SUCCESS;
    }

	//
	// Get RequireKerberos properties of NetworkName
	// NetworkName RequireKerberos property might changed so we must query its value here.
	//
    if (!IsNetworkNameRequireKerberosEnabled() && !m_fServerIsMsmq1)
    {
		//
		// Failed to create MSMQ configuration object in AD
		// because computer object doesn't exist. 
		// The reason is that netname RequireKerberos is not set.
		// issue an event and print an error event in cluster.log.
		//
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR,
            L"Verify that 'RequireKerberos' property of network name \"%1\" (%2) is set.\n",
            m_pwzNetworkResourceName, m_pwzNetworkName);

        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR,
            L"To correct, set 'RequireKerberos' property on \"%1\" resource.\n", m_pwzNetworkResourceName);
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR,
			L"   1. take \"%1\" offline.\n",  m_pwzNetworkResourceName);
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR,
			L"   2. On \"%1\", right click properties, Parameters tab, set Enable Kerberos Authentication.\n",  m_pwzNetworkResourceName);
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR,
			L"   3. bring \"%1\" online. \n", m_pwzNetworkResourceName);

		MqcluspReportEvent(EVENTLOG_ERROR_TYPE, EVENT_ERROR_NETNAME_REQUIRE_KERBEROS, 1, m_pwzNetworkResourceName);
		return hr;
    }

	if (m_fServerIsMsmq1)
	{
	    SetLastError(hr);
	    DWORD rc = ReportLastError(ADS_CREATE_MSMQ_ERR, L"Failed to create MSMQ ADS object.", NULL);
	    return rc;
	}

	//
	// Retry with Virtual Server Token
	//

	(g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Failed to create MSMQ ADS object (Error 0x%1!x!). will retry with virtual server credentials.\n", hr);

    //
    // We need to supply ClusterServiceSid (CSA) in order for this account to have permission on the created object.
    // By default MSMQ add permission to the user who create the object.
    // But in this case we will impersonate virtual server in order to create msmq config object
    // But still wants CSA permission on the created object.
    // This way CSA will be able to create public keys, delete the object etc.
    //
    AP<BYTE> pClusterServiceSid;
    DWORD    dwSidLen = 0;
    HRESULT hr1 = MQSec_GetProcessUserSid(
					(PSID*)&pClusterServiceSid,
					&dwSidLen
					);

	if(FAILED(hr1))
	{
		(g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"Failed to get process sid, Error 0x%1!x!.\n", hr1);

	    SetLastError(hr);
	    DWORD rc = ReportLastError(ADS_CREATE_MSMQ_ERR, L"Failed to create MSMQ ADS object.", NULL);
	    return rc;
	}

	ASSERT(dwSidLen != 0);
	ASSERT((pClusterServiceSid != NULL) && IsValidSid(pClusterServiceSid));
	
	(g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Succesfully got process sid.\n");

	//
	// Get virtual server token
	//
	CHandle hVSToken;
	DWORD rc = GetVirtualServerToken(&hVSToken);
	if(rc != ERROR_SUCCESS)
	{
		(g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"Failed to get virtual server token, Error 0x%1!x!.\n", rc);

	    SetLastError(hr);
	    DWORD rc = ReportLastError(ADS_CREATE_MSMQ_ERR, L"Failed to create MSMQ ADS object.", NULL);
	    return rc;
	}

	(g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Succesfully got Virtual Server Token.\n");

	//
	// Duplicate token
	//
	CHandle hImpToken;
	if(!DuplicateTokenEx(
			hVSToken,
			MAXIMUM_ALLOWED,
			NULL,
			SecurityImpersonation,
			TokenImpersonation,
			&hImpToken
			))
	{
		rc = GetLastError();
		(g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"DuplicateTokenEx failed, Error 0x%1!x!.\n", rc);

	    SetLastError(hr);
	    DWORD rc = ReportLastError(ADS_CREATE_MSMQ_ERR, L"Failed to create MSMQ ADS object.", NULL);
	    return rc;
	}

	(g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Succesfully Duplicate Virtual Server Token.\n");

	//
	// Impersonate virtual server
	//
	if(!ImpersonateLoggedOnUser(hImpToken))
	{
		DWORD gle = GetLastError();
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"Failed to ImpersonateLoggedOnUser, Error 0x%1!x!.\n", gle);

	    SetLastError(hr);
	    DWORD rc = ReportLastError(ADS_CREATE_MSMQ_ERR, L"Failed to create MSMQ ADS object.", NULL);
	    return rc;
	}

	(g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Succesfully impersonate Virtual Server Token.\n");

	//
	// Create msmq object Impersonating virtual server and grant ClusterService sid permissions on the msmq object
	//
	hr = AdsCreateQmObjectInternal(pClusterServiceSid);

	//
	// Stop Impersonating
	//
	RevertToSelf();

	if(FAILED(hr))
	{
	    SetLastError(hr);
	    DWORD rc = ReportLastError(ADS_CREATE_MSMQ_ERR, L"Failed to create MSMQ ADS object.", NULL);
	    return rc;
	}
	
    MqcluspReportEvent(EVENTLOG_INFORMATION_TYPE, ADS_CREATE_MSMQ_OK, 1, m_pwzNetworkName);
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Successfully created MSMQ ADS object.\n");
    ReportState();

    return ERROR_SUCCESS;

} //CQmResource::AdsCreateQmObject


DWORD
CQmResource::AdsCreateQmPublicKeys(
    VOID
    ) const

/*++

Routine Description:

    Create the public keys of this QM in Active Directory.
Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    //
    // Keep this routine idempotent
    //

    if (m_dwWorkgroup != 0)
    {
        return ERROR_SUCCESS;
    }

    {
        CQmResourceRegistry lock(m_wzServiceName);

        (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Storing Public Keys in Active Directory...\n");
        HRESULT hr = pfMQSec_StorePubKeysInDS(FALSE, m_pwzNetworkName, MQDS_MACHINE, false);
        if (FAILED(hr))
        {
            SetLastError(hr);
            ReportLastError(ADS_STORE_KEYS_ERR, L"Failed to store public keys.", NULL);
            //
            // Ignore the failure and continue.
            // Encryption will be broken.
            //
        }
    }


    ReportState();

    return ERROR_SUCCESS;

} //CQmResource::AdsCreateQmPublicKeys


DWORD
CQmResource::AdsReadQmSecurityDescriptor(
    VOID
    )

/*++

Routine Description:

    Read the security descriptor of this QM from Active Directory.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    //
    // Keep this routine idempotent
    //

    SECURITY_INFORMATION RequestedInformation =
        OWNER_SECURITY_INFORMATION |
        GROUP_SECURITY_INFORMATION |
        DACL_SECURITY_INFORMATION;

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Reading Security from Active Directory...\n");
    
    MQPROPVARIANT propVar;
    propVar.vt = VT_NULL;

    HRESULT hr;
    hr = ADGetObjectSecurityGuid(
				eMACHINE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
				&m_guidQm,
				RequestedInformation,
				PROPID_QM_SECURITY,
				&propVar
				);
    
    
    ReportState();
    
    
    if (FAILED(hr))
    {
        SetLastError(hr);
        return ReportLastError(ADS_READ_ERR, L"Failed to read security descriptor.", NULL);
    }
    
    ASSERT(propVar.vt == VT_BLOB);

    m_pSd = propVar.blob.pBlobData;
    m_cbSdSize = propVar.blob.cbSize;

    return ERROR_SUCCESS;

} //CQmResource::AdsReadQmSecurityDescriptor


DWORD
CQmResource::AdsReadQmProperties(
    VOID
    )

/*++

Routine Description:

    Read properties of this QM from Active Directory.
    The properties we read in this routine are computed
    when the MSMQ objects of this QM are created in AD.
    Thus we must create the objects in AD and then read
    these properties.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    //
    // Keep this routine idempotent
    //

    if (m_dwWorkgroup != 0)
    {
        return ERROR_SUCCESS;
    }

    const DWORD x_MAX_PROPS = 16;
    PROPID propIds[x_MAX_PROPS];
    PROPVARIANT propVars[x_MAX_PROPS];
    DWORD ixProp = 0;

    propIds[ixProp] = PROPID_QM_MACHINE_ID;
    propVars[ixProp].vt = VT_CLSID;
    propVars[ixProp].puuid = &m_guidQm;
    ++ixProp;

    ASSERT(("too many properties", ixProp <= x_MAX_PROPS));
    ASSERT(("no network name", (m_pwzNetworkName != NULL) && wcslen(m_pwzNetworkName) > 0));

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Reading '%1' Properties from Active Directory...\n",
                          m_pwzNetworkName);
    HRESULT hr = ADGetObjectProperties(
						eMACHINE,
						NULL,       // pwcsDomainController
						false,	    // fServerName
						m_pwzNetworkName,
						ixProp,
						propIds,
						propVars
						);
    if (FAILED(hr))
    {
        SetLastError(hr);
        return ReportLastError(ADS_READ_ERR, L"Failed to read QM ADS properties.", NULL);
    }
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Successfully read properties from Active Directory!\n");


    ReportState();

    return AdsReadQmSecurityDescriptor();

} //CQmResource::AdsReadQmProperties


bool
CQmResource::AddRemoveRegistryCheckpoint(
    DWORD dwControlCode
    ) const

/*++

Routine Description:

    Add or remove registry checkpoint for this QM.
    Convenient wrapper for ClusterResourceControl,
    which does the real work.

Arguments:

    dwControlCode - specifies ADD or REMOVE

Return Value:

    true - The operation was successfull.

    false - The operation failed.

--*/

{
    ASSERT(("must have a valid resource handle", m_hResource != NULL));

    DWORD dwBytesReturned = 0;
    DWORD status = ::ClusterResourceControl(
                         m_hResource,
                         NULL,
                         dwControlCode,
                         const_cast<LPWSTR>(m_wzFalconRegSection),
                         (wcslen(m_wzFalconRegSection) + 1)* sizeof(WCHAR),
                         NULL,
                         0,
                         &dwBytesReturned
                         );

    ReportState();


    if (ERROR_SUCCESS == status)
    {
        return true;
    }
    if (CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT == dwControlCode &&
        ERROR_ALREADY_EXISTS == status)
    {
        return true;
    }

    if (CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT == dwControlCode &&
        ERROR_FILE_NOT_FOUND == status)
    {
        return true;
    }

    SetLastError(status);
    ReportLastError(REGISTRY_CP_ERR, L"Failed to add/remove registry CP", NULL);
    return false;

} //CQmResource::AddRemoveRegistryCheckpoint


bool
CQmResource::AddRemoveCryptoCheckpointsInternal(
    DWORD dwControlCode,
    bool  f128bit
    ) const

/*++

Routine Description:

    Add or remove Crypto checkpoints for this QM.
    We have 2 checkpoints - 40 bit and 128 bit.

Arguments:

    dwControlCode - specifies ADD or REMOVE.

    f128bit - specifies true for 128 bit, false for 40 bit.

Return Value:

    true - The operation was successfull.

    false - The operation failed.

--*/

{
    ASSERT(("must have a valid resource handle", m_hResource != NULL));

    DWORD dwBytesReturned = 0;
    LPCWSTR pwzFullKey = f128bit ? m_wzCrypto128FullKey : m_wzCrypto40FullKey;

    DWORD status = ::ClusterResourceControl(
                         m_hResource,
                         NULL,
                         dwControlCode,
                         const_cast<LPWSTR>(pwzFullKey),
                         (wcslen(pwzFullKey) + 1) * sizeof(WCHAR),
                         NULL,
                         0,
                         &dwBytesReturned
                         );


    ReportState();


    if (status == ERROR_SUCCESS)
    {
        return true;
    }

    if (f128bit)
    {
        if(status == NTE_KEYSET_NOT_DEF || status == NTE_BAD_KEYSET)
        {
            return true;
        }
    }

    if (CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT == dwControlCode &&
        ERROR_ALREADY_EXISTS == status)
    {
        return true;
    }

    if (CLUSCTL_RESOURCE_DELETE_CRYPTO_CHECKPOINT == dwControlCode &&
        ERROR_FILE_NOT_FOUND == status)
    {
        return true;
    }

    SetLastError(status);
    ReportLastError(CRYPTO_CP_ERR, L"Failed to add/remove Crypto CP.", NULL);
    return false;

} //CQmResource::AddRemoveCryptoCheckpointsInternal


bool
CQmResource::AddRemoveCryptoCheckpoints(
    DWORD dwControlCode
    ) const

/*++

Routine Description:

    Add or remove Crypto checkpoints for this QM.
    We have 2 checkpoints - 40 bit and 128 bit.

Arguments:

    dwControlCode - specifies ADD or REMOVE.

Return Value:

    true - The operation was successfull.

    false - The operation failed.

--*/

{
    if (m_dwWorkgroup != 0)
    {
        return true;
    }

    if (!AddRemoveCryptoCheckpointsInternal(dwControlCode, /* f128bit = */false))
    {
        return false;
    }

    return AddRemoveCryptoCheckpointsInternal(dwControlCode, /* f128bit = */true);

} //CQmResource::AddRemoveCryptoCheckpoints


VOID
CQmResource::OnlineRegisterCertificate(
	VOID
	) const

/*++

Routine Description:

    Register user certificate if doesn't exist.
	This code runs on every online.
	It will register certicate for CSA (Cluster service account) user
	on the physical node if the certificate doesn't already exist.

Arguments:

	None.

Return Value:

	None.
	
--*/

{
    //
    // We should dynamicly load mqrt.dll
    // The reason is that mqrt DllInit will fail when msmq is not installed on the node.
    // So if mqrt is staticly link it will cause mqclus.dll DllInit failure.
    //

    CAutoFreeLibrary hMqrt = LoadLibrary(MQRT_DLL_NAME);
    if (hMqrt == NULL)
    {
        DWORD gle = GetLastError();
		(g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"failed to load mqrt.dll, error 0x%2!x!.\n", gle);
        return;
    }

    RTLogOnRegisterCert_ROUTINE pfRTLogOnRegisterCert = (RTLogOnRegisterCert_ROUTINE)GetProcAddress(hMqrt, "RTLogOnRegisterCert");
    if (pfRTLogOnRegisterCert == NULL)
    {
        DWORD gle = GetLastError();
        (g_pfLogClusterEvent)(m_hReport, 
                              LOG_INFORMATION, 
                              L"Failed to get RTLogOnRegisterCert function address from mqrt.dll, error 0x%2!x!.\n", 
                              gle);
        return;
    }

	//
	// Call RT logon register certificate code
	// Don't retry DS in case DS is offline.
	//
	HRESULT hr = pfRTLogOnRegisterCert(
                                        false	// fRetryDs
					                  );
    if (FAILED(hr))
    {
        (g_pfLogClusterEvent)(m_hReport, 
                              LOG_INFORMATION, 
                              L"failed to register user certificate, error 0x%2!x!.\n", 
                              hr);
    }

} //CQmResource::OnlineRegisterCertificate


extern MQUTIL_EXPORT CCancelRpc  g_CancelRpc;

DWORD
CQmResource::BringOnlineFirstTime(
    VOID
    )

/*++

Routine Description:

    Handle operations to perform only on first online
    of this QM resource:
    * create the MSMQ objects in Active Directory
    * query what is the disk drive we depend upon
    * add registry checkpoint

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Bringing online first time.\n");

    //
    // Keep this routine idempotent!
    // Anything could fail and this routine can be called
    // again later. E.g. QM could fail to start.
    //

    //
    // Must be called before any COM & ADSI calls
    //
    g_CancelRpc.Init();

    DWORD status = ERROR_SUCCESS;

    if (ERROR_SUCCESS != (status = QueryResourceDependencies())  ||

        ERROR_SUCCESS != (status = AdsInit())                    ||

        ERROR_SUCCESS != (status = AdsCreateQmObject())          ||

        ERROR_SUCCESS != (status = AdsCreateQmPublicKeys())      ||

        ERROR_SUCCESS != (status = AdsReadQmProperties()) )
    {
		ShutDownDebugWindow();
        return status;
    }

	ShutDownDebugWindow();

    if (!AddRemoveRegistryCheckpoint(CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT))
    {
        return GetLastError();
    }

    //
    // In the case of migrated QM (QM that was upgraded from the old
    // msmq resource type), msmq root path is not necessarily under
    // the root. The correct path should be already in registry.
    //
    WCHAR wzMsmqDir[MAX_PATH+1] = L"";
    DWORD cbSize = sizeof(wzMsmqDir);
    if (!GetFalconKeyValue(MSMQ_ROOT_PATH, wzMsmqDir, &cbSize))
    {
        ZeroMemory(wzMsmqDir, sizeof(wzMsmqDir));
        wzMsmqDir[0] = m_wDiskDrive;
        HRESULT hr = StringCchCat(wzMsmqDir, TABLE_SIZE(wzMsmqDir), L":\\msmq");

        if(FAILED(hr))return HRESULT_CODE(hr);

        SetFalconKeyValue(MSMQ_ROOT_PATH, REG_SZ, wzMsmqDir,
                          (wcslen(wzMsmqDir) + 1) * sizeof(WCHAR));
    }

    if (m_dwWorkgroup != 0)
    {
        if (m_guidQm == GUID_NULL)
        {
            RPC_STATUS rc = UuidCreate(&m_guidQm);
            DBG_USED(rc);
            ASSERT(("Failed to generate a guid for QM", rc == RPC_S_OK));
        }

        AP<VOID> pDescriptor = 0;
        //
        // Caution:
        // If you change implementatation of MQSec_GetDefaultSecDescriptor
        // to use mqutil's registry routines, you need to lock registry
        // here using CQmResourceRegistry .
        //
        status = pfMQSec_GetDefaultSecDescriptor(
                     MQDS_MACHINE,
                     &pDescriptor,
                     FALSE,  //fImpersonate
                     NULL,
                     0,   // seinfoToRemove
                     e_GrantFullControlToEveryone,
                     NULL) ;
        ASSERT(MQSec_OK == status);
		if (status == MQSec_OK)
		{
			SetFalconKeyValue(MSMQ_DS_SECURITY_CACHE_REGNAME, REG_BINARY, pDescriptor, GetSecurityDescriptorLength(pDescriptor));
		}
    }
    else
    {
        SetFalconKeyValue(MSMQ_DS_SECURITY_CACHE_REGNAME, REG_BINARY, m_pSd, m_cbSdSize);
    }


    SetFalconKeyValue(MSMQ_QMID_REGNAME, REG_BINARY, &m_guidQm, sizeof(GUID));


    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"All first-online operations completed.\n");

    return ERROR_SUCCESS;

} //CQmResource::BringOnlineFirstTime


VOID
CQmResource::DeleteDirectoryFiles(
    LPCWSTR pwzDir
    ) const

/*++

Routine Description:

    Delete files from a given directory.
    Ignore errors (such as directory not exist,
    read only files, no security to delete).
    Will not delete subdirectories.

Arguments:

    pwzDir - Directory path to delete files from.

Return Value:

    None.

--*/

{
    WCHAR wzFileName[MAX_PATH+1] = {0};
    HRESULT hr = StringCchCopy(wzFileName, TABLE_SIZE(wzFileName), pwzDir);
    if(FAILED(hr))return;

    hr = StringCchCat(wzFileName, TABLE_SIZE(wzFileName), L"*");

    WIN32_FIND_DATA FindData;
    CFindHandle hEnum(FindFirstFile(
                          wzFileName,
                          &FindData
                          ));

    if(INVALID_HANDLE_VALUE == hEnum.operator HANDLE())
    {
        return;
    }

    do
    {
        if (0 == CompareStringsNoCase(FindData.cFileName, L".") ||
            0 == CompareStringsNoCase(FindData.cFileName, L".."))
        {
            continue;
        }

        hr = StringCchCopy(wzFileName, TABLE_SIZE(wzFileName), pwzDir);
        if(FAILED(hr))return;
        hr = StringCchCat(wzFileName, TABLE_SIZE(wzFileName), FindData.cFileName);
        if(FAILED(hr))return;

        BOOL success = DeleteFile(wzFileName);

        if (success)
        {
            (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"successfully deleted file '%1'.\n", wzFileName);
        }
        else
        {
            DWORD err = GetLastError();
            (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"failed to delete file '%1', error 0x%2!x!.\n",
                                  wzFileName, err);
        }

    } while(FindNextFile(hEnum, &FindData));

} //CQmResource::DeleteDirectoryFiles


VOID
CQmResource::DeleteMsmqDir(
    VOID
    ) const

/*++

Routine Description:

    Delete LQS and Storage directories.
    Ignore errors. It could be that these
    directories do not exist (QM was never up)
    or user has no security to delete, etc.
    It is not that important, so don't report failure.

Arguments:

    None

Return Value:

    None

--*/

{
    //
    // There are scenarios where it's expected to not find in
    // registry the MSMQ_ROOT_PATH value, e.g. when QM resource
    // is created and then deleted w/o attempt to bring it online
    // (this value is written to registry when bringing the resource
    // online, because only then we query dependencies and find the disk).
    //

    WCHAR wzMsmqDir[MAX_PATH+1] = {L""};
    WCHAR wzDir[MAX_PATH+1] = {L""};
    DWORD cbSize = sizeof(wzMsmqDir);
    HRESULT hr;

    if (GetFalconKeyValue(MSMQ_ROOT_PATH, wzMsmqDir, &cbSize))
    {
        hr = StringCchCopy(wzDir, TABLE_SIZE(wzDir), wzMsmqDir);
        if(FAILED(hr))return;

        hr = StringCchCat(wzDir, TABLE_SIZE(wzDir), L"\\STORAGE\\LQS\\");
        if(FAILED(hr))return;

        (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Deleting folder '%1'...\n", wzDir);
        DeleteDirectoryFiles(wzDir);
        RemoveDirectory(wzDir);
    }

    cbSize = sizeof(wzDir);
    if (GetFalconKeyValue(MSMQ_STORE_RELIABLE_PATH_REGNAME, wzDir, &cbSize))
    {
        hr = StringCchCat(wzDir, TABLE_SIZE(wzDir), L"\\");
        if(FAILED(hr))return;
        DeleteDirectoryFiles(wzDir);
        RemoveDirectory(wzDir);
    }

    cbSize = sizeof(wzDir);
    if (GetFalconKeyValue(MSMQ_STORE_PERSISTENT_PATH_REGNAME, wzDir, &cbSize))
    {
        hr = StringCchCat(wzDir, TABLE_SIZE(wzDir), L"\\");
        if(FAILED(hr))return;
        DeleteDirectoryFiles(wzDir);
        RemoveDirectory(wzDir);
    }

    cbSize = sizeof(wzDir);
    if (GetFalconKeyValue(MSMQ_STORE_JOURNAL_PATH_REGNAME, wzDir, &cbSize))
    {
        hr = StringCchCat(wzDir, TABLE_SIZE(wzDir), L"\\");
        if(FAILED(hr))return;
        DeleteDirectoryFiles(wzDir);
        RemoveDirectory(wzDir);
    }

    cbSize = sizeof(wzDir);
    if (GetFalconKeyValue(MSMQ_STORE_LOG_PATH_REGNAME, wzDir, &cbSize))
    {
        hr = StringCchCat(wzDir, TABLE_SIZE(wzDir), L"\\");
        if(FAILED(hr))return;
        DeleteDirectoryFiles(wzDir);
        RemoveDirectory(wzDir);
    }

	//
	// Mapping directory
	//
    cbSize = sizeof(wzDir);
    if (!GetFalconKeyValue(MSMQ_MAPPING_PATH_REGNAME, wzDir, &cbSize))
    {
		//
		// If the registry doesn't exist use the default
		//
        hr = StringCchCopy(wzDir, TABLE_SIZE(wzDir), wzMsmqDir);
        if(FAILED(hr))return;
        hr = StringCchCat(wzDir, TABLE_SIZE(wzDir), DIR_MSMQ_MAPPING);
        if(FAILED(hr))return;
    }
    hr = StringCchCat(wzDir, TABLE_SIZE(wzDir), L"\\");
    if(FAILED(hr))return;
    DeleteDirectoryFiles(wzDir);
    RemoveDirectory(wzDir);

    if (wcslen(wzMsmqDir) > 0)
    {
        hr = StringCchCopy(wzDir, TABLE_SIZE(wzDir), wzMsmqDir);
        if(FAILED(hr))return;
        hr = StringCchCat(wzDir, TABLE_SIZE(wzDir), L"\\STORAGE\\");
        if(FAILED(hr))return;
        (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Deleting folder '%1'...\n", wzDir);
        DeleteDirectoryFiles(wzDir);
        RemoveDirectory(wzDir);

        hr = StringCchCopy(wzDir, TABLE_SIZE(wzDir), wzMsmqDir);
        if(FAILED(hr))return;
        hr = StringCchCat(wzDir, TABLE_SIZE(wzDir), L"\\");
        if(FAILED(hr))return;
        (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Deleting folder '%1'...\n", wzDir);
        RemoveDirectory(wzDir);
    }

} //CQmResource::DeleteMsmqDir


VOID
CQmResource::DeleteMqacFile(
    VOID
    ) const

/*++

Routine Description:

    Delete the binary for this QM's device driver.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (wcslen(m_wzDriverPath) < 1)
    {
        return;
    }

    //
    // Idempotent deletion.
    // There are scenarios inwhich it's expected to fail here, e.g.when
    // resource is created and deleted w/o attempt to bring it online.
    //
    DeleteFile(m_wzDriverPath);

} //CQmResource::DeleteMqacFile


DWORD
CQmResource::CloneMqacFile(
    VOID
    ) const

/*++

Routine Description:

    Create the binary for this QM's device driver.
    We copy mqac.sys (of main QM) to a dedicated file, since
    mqac.sys can not host more than one device driver.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    WCHAR wzMainDriverPath[MAX_PATH+1] = {0};
    DWORD  cbSize = GetSystemDirectory(wzMainDriverPath, TABLE_SIZE(wzMainDriverPath));
    if( cbSize == 0 )return GetLastError();
    if( cbSize >= TABLE_SIZE(wzMainDriverPath))return ERROR_INSUFFICIENT_BUFFER;
    wzMainDriverPath[cbSize]=L'\0';

    HRESULT hr = StringCchCat(wzMainDriverPath, TABLE_SIZE(wzMainDriverPath), L"\\drivers\\mqac.sys");
    if(FAILED(hr))HRESULT_CODE(hr);


    //
    // Idempotent copy
    //
    if (!CopyFile(wzMainDriverPath, m_wzDriverPath, /*bFailIfExists*/FALSE))
    {
        ASSERT(("copy file failed!", 0));

        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"Failed to copy '%1' to '%2'. Error 0x%3!x!.\n",
                              wzMainDriverPath, m_wzDriverPath, GetLastError());

        return GetLastError();
    }

    //
    // Set the file to be read/write.
    // Necessary for later delete/idempotent copy.
    //
    if (!SetFileAttributes(m_wzDriverPath, FILE_ATTRIBUTE_NORMAL))
    {
        ASSERT(("set file attribute failed!", 0));

        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, 
            L"Failed to set attributes of file '%1'. Error 0x%2!x!.\n", m_wzDriverPath, GetLastError());

        return GetLastError();
    }

    ReportState();


    return ERROR_SUCCESS;

} //CQmResource::CloneMqacFile


DWORD
CQmResource::RegisterDriver(
    VOID
    ) const

/*++

Routine Description:

    Create the device driver for this QM.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    //
    // Keep this routine idempotent
    //

    ASSERT(("must have valid handle to SCM", m_hScm != NULL));

    WCHAR buffer[256] = L"";
    LoadString(g_hResourceMod, IDS_DRIVER_DISPLAY_NAME, buffer, TABLE_SIZE(buffer));

    WCHAR wzDisplayName[256] = L"";
    HRESULT hr = StringCchCopy(wzDisplayName, TABLE_SIZE(wzDisplayName), buffer);
    if(FAILED(hr))return HRESULT_CODE(hr);
    hr = StringCchCat(wzDisplayName, TABLE_SIZE(wzDisplayName), L" (");
    if(FAILED(hr))return HRESULT_CODE(hr);
    hr = StringCchCatN(wzDisplayName, 
                       TABLE_SIZE(wzDisplayName), 
                       m_pwzResourceName,
                       TABLE_SIZE(wzDisplayName) - wcslen(buffer) - 5
                       );

    if(FAILED(hr))return HRESULT_CODE(hr);
    hr = StringCchCat(wzDisplayName, TABLE_SIZE(wzDisplayName), L")");
    if(FAILED(hr))return HRESULT_CODE(hr);

    CServiceHandle hDriver(CreateService(
                               m_hScm,
                               m_wzDriverName,
                               wzDisplayName,
                               SERVICE_ALL_ACCESS,
                               SERVICE_KERNEL_DRIVER,
                               SERVICE_DEMAND_START,
                               SERVICE_ERROR_NORMAL,
                               m_wzDriverPath,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL
                               ));
    if (hDriver == NULL &&
        ERROR_SERVICE_EXISTS != GetLastError())
    {
        return ReportLastError(CREATE_SERVICE_ERR, L"Failed to register driver '%1'.", m_wzDriverName);
    }


    ReportState();


    return ERROR_SUCCESS;

} //CQmResource::RegisterDriver


DWORD
CQmResource::RegisterService(
    VOID
    ) const

/*++

Routine Description:

    Create the msmq service for this QM.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    //
    // Register service (idempotent)
    //

    WCHAR buffer[256] = L"";
    LoadString(g_hResourceMod, IDS_SERVICE_DISPLAY_NAME, buffer, TABLE_SIZE(buffer));

    WCHAR wzDisplayName[256] = L"";
    HRESULT hr = StringCchCopy(wzDisplayName, TABLE_SIZE(wzDisplayName), buffer);
    if(FAILED(hr))return HRESULT_CODE(hr);

    hr = StringCchCat(wzDisplayName, TABLE_SIZE(wzDisplayName), L" (");
    if(FAILED(hr))return HRESULT_CODE(hr);

    hr = StringCchCatN(wzDisplayName, 
                       TABLE_SIZE(wzDisplayName), 
                       m_pwzResourceName,
                       TABLE_SIZE(wzDisplayName) - wcslen(buffer) - 5
                      );
    if(FAILED(hr))return HRESULT_CODE(hr);

    hr = StringCchCat(wzDisplayName, TABLE_SIZE(wzDisplayName), L")");
    if(FAILED(hr))return HRESULT_CODE(hr);

    WCHAR wzPath[MAX_PATH+1] = {0};
    DWORD cbSize = GetSystemDirectory(wzPath, TABLE_SIZE(wzPath));
    if( cbSize == 0 )return GetLastError();
    if( cbSize >= TABLE_SIZE(wzPath) )return ERROR_INSUFFICIENT_BUFFER;
    wzPath[cbSize]=L'\0';

    hr = StringCchCat(wzPath, TABLE_SIZE(wzPath), L"\\MQSVC.EXE");

    LPCWSTR x_LANMAN_SECURITY_SUPPORT_PROVIDER = L"NtLmSsp";
    LPCWSTR x_RPC_SERVICE                      = L"RPCSS";
    LPCWSTR x_SECURITY_ACCOUNTS_MANAGER        = L"SamSs";
    LPCWSTR x_RM_CAST					       = L"RMCAST";

    WCHAR wzDependencies[1024] = {0};
    LPWSTR pDependencies = &wzDependencies[0];
    cbSize = TABLE_SIZE(wzDependencies);

    hr = StringCchCopy(pDependencies, cbSize, m_wzDriverName);
    if(FAILED(hr))HRESULT_CODE(hr);
    WORD cbTemp=wcslen(m_wzDriverName) + 1;
    pDependencies += cbTemp;
    cbSize        -= cbTemp;

    hr = StringCchCopy(pDependencies, cbSize, x_LANMAN_SECURITY_SUPPORT_PROVIDER);
    if(FAILED(hr))HRESULT_CODE(hr);
    cbTemp=wcslen(x_LANMAN_SECURITY_SUPPORT_PROVIDER) + 1;
    pDependencies += cbTemp;
    cbSize        -= cbTemp;

    hr = StringCchCopy(pDependencies, cbSize, x_RPC_SERVICE);
    if(FAILED(hr))HRESULT_CODE(hr);
    cbTemp=wcslen(x_RPC_SERVICE) + 1;
    pDependencies += cbTemp;
    cbSize        -= cbTemp;

    hr = StringCchCopy(pDependencies, cbSize, x_SECURITY_ACCOUNTS_MANAGER);
    if(FAILED(hr))HRESULT_CODE(hr);
    cbTemp = wcslen(x_SECURITY_ACCOUNTS_MANAGER) + 1;
    pDependencies += cbTemp;
    cbSize        -= cbTemp;

    hr = StringCchCopy(pDependencies, cbSize, x_RM_CAST);
    if(FAILED(hr))HRESULT_CODE(hr);
    cbTemp=wcslen(x_RM_CAST) + 1;
    pDependencies += cbTemp;
    cbSize        -= cbTemp;

    hr = StringCchCopy(pDependencies, cbSize, L"");
    if(FAILED(hr))HRESULT_CODE(hr);

    DWORD dwType = SERVICE_WIN32_OWN_PROCESS;
#ifdef _DEBUG
    dwType |= SERVICE_INTERACTIVE_PROCESS;
#endif

    ASSERT(("must have a valid handle to SCM", m_hScm != NULL));

    CServiceHandle hService(CreateService(
                                m_hScm,
                                m_wzServiceName,
                                wzDisplayName,
                                SERVICE_ALL_ACCESS,
                                dwType,
                                SERVICE_DEMAND_START,
                                SERVICE_ERROR_NORMAL,
                                wzPath,
                                NULL,
                                NULL,
                                wzDependencies,
                                NULL,
                                NULL
                                ));
    if (hService == NULL &&
        ERROR_SERVICE_EXISTS != GetLastError())
    {
        return ReportLastError(CREATE_SERVICE_ERR, L"Failed to register service '%1'.", m_wzServiceName);
    }


    ReportState();


    LoadString(g_hResourceMod, IDS_SERVICE_DESCRIPTION, buffer, TABLE_SIZE(buffer));
    SERVICE_DESCRIPTION sd;
    sd.lpDescription = buffer;
    ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION, &sd);

    return ERROR_SUCCESS;

} //CQmResource::RegisterService


DWORD
CQmResource::CreateEventSourceRegistry(
    VOID
    ) const

/*++

Routine Description:

    Create the registry values to support event logging by this QM.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    WCHAR Filename[MAX_PATH+1];
    DWORD cbSize = GetSystemDirectory(Filename, TABLE_SIZE(Filename));
    if( cbSize == 0 )return GetLastError();
    if( cbSize >= TABLE_SIZE(Filename) )return ERROR_INSUFFICIENT_BUFFER;
    Filename[cbSize]=L'\0';
    HRESULT hr = StringCchCat(Filename, TABLE_SIZE(Filename), TEXT("\\"));
    hr = StringCchCat(Filename, TABLE_SIZE(Filename), MQUTIL_DLL_NAME);

    if (!MqcluspCreateEventSourceRegistry(Filename, m_wzServiceName))
    {
        return GetLastError();
    }

    return ERROR_SUCCESS;

} //CQmResource::CreateEventSourceRegistry


VOID
CQmResource::DeleteEventSourceRegistry(
    VOID
    ) const

/*++

Routine Description:

    Delete the registry values to support event logging by this QM.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // REG_MAX_KEY_NAME_LENGTH is defined in ntregapi.h as follow:
    //    #define REG_MAX_KEY_NAME_LENGTH         512       // allow for 256 unicode, as promise
    //
    WCHAR buffer[REG_MAX_KEY_NAME_LENGTH/sizeof(WCHAR)] = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\";
    HRESULT hr = StringCchCat(buffer, TABLE_SIZE(buffer), m_wzServiceName);
    if(FAILED(hr))return;

    RegDeleteKey(HKEY_LOCAL_MACHINE, buffer);

} //CQmResource::DeleteEventSourceRegistry


DWORD
CQmResource::StopService(
    LPCWSTR pwzServiceName
    ) const

/*++

Routine Description:

    Stop a service and block until it's stopped (or timeout).

Arguments:

    pwzServiceName - The service to stop.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    ASSERT(("must have a valid handle to SCM", m_hScm != NULL));

    CServiceHandle hService(OpenService(
                                m_hScm,
                                pwzServiceName,
                                SERVICE_ALL_ACCESS
                                ));
    if (hService == NULL)
    {
        if (ERROR_SERVICE_DOES_NOT_EXIST == GetLastError())
        {
            return ERROR_SUCCESS;
        }

        return ReportLastError(STOP_SERVICE_ERR, L"Failed to open service '%1'.", pwzServiceName);
    }

    SERVICE_STATUS ServiceStatus;
    if (!ControlService(hService, SERVICE_CONTROL_STOP, &ServiceStatus) &&
        ERROR_SERVICE_NOT_ACTIVE != GetLastError() &&
        ERROR_SERVICE_CANNOT_ACCEPT_CTRL != GetLastError() &&
        ERROR_BROKEN_PIPE != GetLastError())
    {
        return ReportLastError(STOP_SERVICE_ERR, L"Failed to stop service '%1'.", pwzServiceName);
    }

    //
    // Wait until service is down (or timeout 5 seconds)
    //
    const DWORD x_TIMEOUT = 1000 * 5;

    DWORD dwWaitTime = 0;
    while (dwWaitTime < x_TIMEOUT)
    {
        if (!QueryServiceStatus(hService, &ServiceStatus))
        {
            return ReportLastError(STOP_SERVICE_ERR, L"Failed to query service '%1'.", pwzServiceName);
        }

        if (ServiceStatus.dwCurrentState == SERVICE_START_PENDING)
        {
            //
            // Service is still start pending from a previous call
            // to start it. So it cannot be stopped. We can do
            // nothing about it. Trying to terminate the process
            // of the service will fail with access denied.
            //
            (g_pfLogClusterEvent)(m_hReport, LOG_ERROR,
                              L"Service '%1' can not be stopped because it is start pending.\n", pwzServiceName);

            return SERVICE_START_PENDING;
        }

        if (ServiceStatus.dwCurrentState != SERVICE_STOP_PENDING)
        {
            break;
        }

        const DWORD x_INTERVAL = 50;
        Sleep(x_INTERVAL);
        dwWaitTime += x_INTERVAL;
    }

    if (SERVICE_STOPPED != ServiceStatus.dwCurrentState)
    {
        //
        // Service failed to stop.
        //
        SetLastError(ServiceStatus.dwCurrentState);
        ReportLastError(STOP_SERVICE_ERR, L"TIMEOUT: Failed to stop service '%1'.", pwzServiceName);
        return ServiceStatus.dwCurrentState;
    }

    return ERROR_SUCCESS;

} //CQmResource::StopService


DWORD
CQmResource::RemoveService(
    LPCWSTR pwzServiceName
    ) const

/*++

Routine Description:

    Stop and delete a service.

Arguments:

    pwzServiceName - The service to stop and delete.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    ASSERT(("must have a valid handle to SCM", m_hScm != NULL));

    //
    // First check if service exists
    //
    CServiceHandle hService(OpenService(
                                m_hScm,
                                pwzServiceName,
                                SERVICE_ALL_ACCESS
                                ));
    if (hService == NULL)
    {
        if (ERROR_SERVICE_DOES_NOT_EXIST == GetLastError())
        {
            return ERROR_SUCCESS;
        }

        return ReportLastError(DELETE_SERVICE_ERR, L"Failed to open service '%1'", pwzServiceName);
    }

    //
    // Service exists. Make sure it is not running.
    //
    DWORD status = StopService(pwzServiceName);
    if (ERROR_SUCCESS != status)
    {
        return status;
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Deleting service '%1'.\n", pwzServiceName);

    if (!DeleteService(hService) &&
        ERROR_SERVICE_MARKED_FOR_DELETE != GetLastError())
    {
        return ReportLastError(DELETE_SERVICE_ERR, L"Failed to delete service '%1'", pwzServiceName);
    }

    return ERROR_SUCCESS;

} //CQmResource::RemoveService


DWORD
CQmResource::SetServiceEnvironment(
    VOID
    ) const

/*++

Routine Description:

    Configure the environment for the msmq service of this QM,
    such that code inside the QM that calls GetComputerName will
    get the name of the cluster virtual server (the network name).

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    //
    // Set MSMQ service environment
    //
    DWORD status = ResUtilSetResourceServiceEnvironment(
                       m_wzServiceName,
                       m_hResource,
                       g_pfLogClusterEvent,
                       m_hReport
                       );

    //
    // If fail, write to cluster log and create an event log
    //
    if (ERROR_SUCCESS != status)
    {
        SetLastError(status);
        return ReportLastError(START_SERVICE_ERR, L"Faild to set MSMQ service environment for service name '%1'", m_wzServiceName);
    }

    //
    // write to cluster log indicating that we set the MSMQ service environment successfully
    //
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Set MSMQ service '%1' environment successfully.\n", m_wzServiceName);

    return ERROR_SUCCESS;

} //CQmResource::SetServiceEnvironment


DWORD
CQmResource::StartService(
    VOID
    ) const

/*++

Routine Description:

    Configure environment for the msmq service of this QM,
    start the service and block until it's up and running.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    ASSERT(("must have a valid handle to SCM", m_hScm != NULL));

    CServiceHandle hService(OpenService(
                                m_hScm,
                                m_wzServiceName,
                                SERVICE_ALL_ACCESS
                                ));
    if (hService == NULL)
    {
        return ReportLastError(START_SERVICE_ERR, L"Failed to open service '%1'.", m_wzServiceName);
    }

    DWORD status = SetServiceEnvironment();
    if (ERROR_SUCCESS != status)
    {
        return status;
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Starting the '%1' service.\n", m_wzServiceName);
    BOOL rc = ::StartService(hService, 0, NULL);


    ReportState();


    //
    // Could take a long time for QM to start.
    // This routine can be called more than once.
    //
    if (!rc &&
        ERROR_SERVICE_ALREADY_RUNNING != GetLastError() &&
        ERROR_SERVICE_CANNOT_ACCEPT_CTRL != GetLastError())
    {
        return ReportLastError(START_SERVICE_ERR, L"Failed to start service '%1'.", m_wzServiceName);
    }

    //
    // Wait until service is up
    //
    MqcluspReportEvent(EVENTLOG_INFORMATION_TYPE, START_SERVICE_OK, 1, m_wzServiceName);
    SERVICE_STATUS ServiceStatus;
    for (;;)
    {
        if (!QueryServiceStatus(hService, &ServiceStatus))
        {
            return ReportLastError(START_SERVICE_ERR, L"Failed to query service '%1'.", m_wzServiceName);
        }


        ReportState();


        if (ServiceStatus.dwCurrentState == SERVICE_START_PENDING)
        {
            Sleep(100);
            continue;
        }

        break;
    }

    if (SERVICE_RUNNING != ServiceStatus.dwCurrentState)
    {
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"Service '%1' failed to start.\n", m_wzServiceName);

        return ERROR_SERVICE_SPECIFIC_ERROR;
    }

    return ERROR_SUCCESS;

} //CQmResource::StartService


DWORD 
GetBuildNumber(
	LPWSTR BuildNumberString
	)
{
	LPWSTR ptr = wcsrchr(BuildNumberString, L'.');
	if (ptr == NULL)
	{
		return 0;
	}

	DWORD BuildNumber = 0;
	if (swscanf(++ptr , L"%d", &BuildNumber) != 1)
    {
		return 0;
    }

	return BuildNumber;
}


VOID
CQmResource::SetSetupStatusKey(
	VOID
	)
/*++

Routine Description:

    Configure the SetupStatus key to it's correct value.
    When upgrading OS>W2K, this key isn't updated. In NT4 it does work because it was performed in the post upgrade
    tasks. In newer OS we have to update it manually according to the build numbers.
	Note that this routine will set the SetupStatus key every time the current version reg key is less than our
	current version. This means that also SPs will be considered as upgrades.

Arguments:

    None.

Return Value:

    None.

--*/

{
	DWORD dwSetupStatus = MSMQ_SETUP_DONE;
    DWORD dwSize = sizeof(DWORD);
	GetFalconKeyValue(MSMQ_SETUP_STATUS_REGNAME, &dwSetupStatus, &dwSize);

	//
	// MSMQ_SETUP_FRESH_INSTALL - Only when the reasource is created.
	// MSMQ_SETUP_UPGRADE_FROM_NT - Only when upgrading from NT4 to .NET since this value is cloned only in 
	// welcome wizard after upgrading from NT4.
	// MSMQ_SETUP_UPGRADE_FROM_WIN9X - cannot be because cluster have to run on NT.
	//
	ASSERT(dwSetupStatus != MSMQ_SETUP_UPGRADE_FROM_WIN9X);
	
	if (dwSetupStatus == MSMQ_SETUP_FRESH_INSTALL)
	{
		return;
	}

	//
	// dwSetupStatus was equal to MSMQ_SETUP_DONE:
	// This can happen in one of two cases:
	// 1. This is not the first time the resource starts on a new OS.
	// 2. This is the first time the resource is up after upgrading from W2K or later OS versions.
	//
	// or - dwSetupStatus was equal to MSMQ_SETUP_UPGRADE_FROM_NT
	// This can happen because of upgrade cluster NT4. In this case we also need to update the current build 
	// reg key so that next startup we'll know that the QM already performed the post upgrade operations.
	//
	WCHAR OldBuildString[MAX_REG_DEFAULT_LEN] = L"";
	dwSize = sizeof(OldBuildString);
	GetFalconKeyValue(MSMQ_CURRENT_BUILD_REGNAME, OldBuildString, &dwSize);

	DWORD OldBuildNumber = GetBuildNumber(OldBuildString);
	
	DWORD NewBuildNumber = rup;

	//
	// We already ran on this build (or earlier build) so we already performed the required setup operations.
	//
	if (NewBuildNumber <= OldBuildNumber)
	{
		return;
	}

	
	//
	// Generate new build number string
	//
	WCHAR NewBuildString[MAX_REG_DEFAULT_LEN] = L"";
	HRESULT hr = StringCchPrintf(NewBuildString, TABLE_SIZE(NewBuildString), L"%d.%d.%d", rmj, rmm, rup);
	ASSERT(SUCCEEDED(hr));
	DBG_USED(hr);
	
	//
	// Set a new build number in cluster regsitry for next time we'll enter this function.
	//
	DWORD dwType = REG_SZ;
    dwSize = (wcslen(NewBuildString)+1)*sizeof(WCHAR);
    SetFalconKeyValue(MSMQ_CURRENT_BUILD_REGNAME, dwType, NewBuildString, dwSize);

	if (dwSetupStatus == MSMQ_SETUP_UPGRADE_FROM_NT)
	{
		//
		// Upgrade from NT4 - no need to update the SetupStatus key.
		//
		return;
	}
	
	//
	// This is a virtual QM - must be on NT.
	//
	dwSetupStatus = MSMQ_SETUP_UPGRADE_FROM_NT;
	
	//
	// Set a new setup status so that the virtual QM will know it has to perform setup operations.
	//
	dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    SetFalconKeyValue(MSMQ_SETUP_STATUS_REGNAME, dwType, &dwSetupStatus, dwSize);
}


DWORD
CQmResource::BringOnline(
    VOID
    )

/*++

Routine Description:

    Handle operations for bringing this QM resource online:
    * create the binary for the device driver for this QM
    * create device driver and msmq service
    * bring MSDTC resource online
    * start the msmq service for this QM and verify it's up

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Bringing online.\n");


	//
	// Bug 735360 NTRAID - W2K cluster upgrade is broken - qm doesn't run upgrade code.
	// In W2K cluster upgrade we don't copy the SetupStatus key from the QM regsitry and just copy the
	// value we saved in the last checkpoint which means SetupStatus will always be equal to 0.
	// Here we verify if the cluster was upgraded and set the key if needed so that the virtual QM when it starts,
	// will know to perform post upgrade operations.
	//
	SetSetupStatusKey();

    //
    // Keep this routine idempotent!
    // Anything could fail and this routine can be called
    // again later. E.g. QM could fail to start.
    //

	//
	// Call "msmq logon" code that register user certificate if doesn't exist on every online.
	// This will register certicate for CSA (Cluster service account) user
	// on the physical node if the certificate doesn't already exist
	//
	OnlineRegisterCertificate();

    DWORD status = ERROR_SUCCESS;

    if (ERROR_SUCCESS != (status = CloneMqacFile())   ||

        ERROR_SUCCESS != (status = RegisterDriver())  ||

        ERROR_SUCCESS != (status = RegisterService()) ||

        ERROR_SUCCESS != (status = StartService()) )
    {
        (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Failed to bring online. Error 0x%1!x!.\n",
                              status);

        return status;
    }

    //
    // Adding Crypto checkpoints can be done only after QM is up and
    // running, because the QM creates its Crypto keys.
    //
    if (!AddRemoveCryptoCheckpoints(CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT))
    {
        return GetLastError();
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"resource is online!.\n");

    return ERROR_SUCCESS;

} //CQmResource::BringOnline


BOOL
CQmResource::CheckIsAlive(
    VOID
    ) const

/*++

Routine Description:

    Checks is the QM is up and running.

Arguments:

    None.

Return Value:

    TRUE - The QM is up and running.

    FALSE - The QM is not up and running.

--*/

{

    ASSERT(("must have a valid handle to SCM", m_hScm != NULL));

    CServiceHandle hService(OpenService(
                                m_hScm,
                                m_wzServiceName,
                                SERVICE_ALL_ACCESS
                                ));

    SERVICE_STATUS ServiceStatus;
    BOOL fIsAlive = QueryServiceStatus(hService, &ServiceStatus) &&
                    SERVICE_RUNNING == ServiceStatus.dwCurrentState;

    return fIsAlive;

} //CQmResource::CheckIsAlive


VOID
CQmResource::DeleteNt4Files(
    VOID
    ) const

/*++

Routine Description:

    Delete MSMQ 1.0 (NT4) files from shared disk.
    This routine is called for QM that was upgraded from NT4.

    Ignore errors.

Arguments:

    None

Return Value:

    None.
--*/

{
    CAutoFreeLibrary hLib(LoadLibrary(MQUPGRD_DLL_NAME));
    if (hLib == NULL)
    {
        return;
    }

    CleanupOnCluster_ROUTINE pfCleanupOnCluster = 
        (CleanupOnCluster_ROUTINE)GetProcAddress(hLib, "CleanupOnCluster");

    if (pfCleanupOnCluster == NULL)
    {
        return;
    }

    WCHAR wzMsmqDir[MAX_PATH] = {L""};
    DWORD cbSize = sizeof(wzMsmqDir);
    if (GetFalconKeyValue(MSMQ_ROOT_PATH, wzMsmqDir, &cbSize))
    {
        pfCleanupOnCluster(wzMsmqDir);
    }

} //CQmResource::DeleteNt4Files


DWORD
MqcluspStartup(
    VOID
    )

/*++

Routine Description:

    This routine is called when DLL is registered or loaded.
    Could be called by many threads.
    Do not put complex stuff here (eg calling ADS).
    Do not assume that MSMQ is installed on the node here.

Arguments:

    None

Return Value:

    ERROR_SUCCESS - The operation was successful

    Win32 error code - The operation failed.

--*/

{
    try
    {
        MqcluspRegisterEventSource();
    }
    catch (const CMqclusException&)
    {
        return ERROR_NOT_READY;
    }
    catch (const bad_alloc&)
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, NO_MEMORY_ERR, 0);
        return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;

} //MqcluspStartup


RESID
MqcluspOpen(
    LPCWSTR pwzResourceName,
    HKEY hResourceKey,
    RESOURCE_HANDLE hResourceHandle
    )

/*++

Routine Description:

    Create an object to represent a new QM resource and
    return a handle to that object.

Arguments:

    pwzResourceName - Name of this QM resource.

    hResourceKey - Supplies handle to the resource's cluster configuration 
        database key.

    hResourceHandle - report handle for this QM resource.

Return Value:

    NULL - The operation failed.

    Some valid address - the memory offset of this QM object.

--*/

{
    (g_pfLogClusterEvent)(hResourceHandle, LOG_INFORMATION, L"opening resource.\n");

    CQmResource * pqm = NULL;
    try
    {
        pqm = new CQmResource(pwzResourceName, hResourceKey, hResourceHandle);
    }
    catch(const bad_alloc&)
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, NO_MEMORY_ERR, 0);

        (g_pfLogClusterEvent)(hResourceHandle, LOG_ERROR, L"No memory (CQmResource construction).\n");
        SetLastError(ERROR_NOT_READY);
        return NULL;
    }
    catch (const CMqclusException&)
    {
        SetLastError(ERROR_NOT_READY);
        return NULL;
    }

    (g_pfLogClusterEvent)(hResourceHandle, LOG_INFORMATION, L"resource was opened successfully.\n");

    return static_cast<RESID>(pqm);

} //MqcluspOpen


DWORD
MqcluspOffline(
    CQmResource * pqm
    )

/*++

Routine Description:

    Brings down this QM resource:
    * stop and remove device driver and msmq service
    * delete the binary for the device driver

    We not only stop the QM, but also undo most of the
    operations done in BringOnline. This way we clean
    the local node before failover to remote node, and
    Delete on the remote node will not leave "garbage"
    on this node.

Arguments:

    pqm - pointer to the CQmResource object

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    try
    {
        pqm->RemoveService(pqm->GetServiceName());

        pqm->RemoveService(pqm->GetDriverName());

        pqm->DeleteMqacFile();
    }
    catch (const bad_alloc&)
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, NO_MEMORY_ERR, 0);

        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, L"No memory (Offline).\n");

        return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;

} //MqcluspOffline


VOID
MqcluspClose(
    CQmResource * pqm
    )

/*++

Routine Description:

    Delete the QM object. Undo MqcluspOpen.

Arguments:

    pqm - pointer to the CQmResource object

Return Value:

    None.

--*/

{
    (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_INFORMATION, L"Closing resource.\n");

    delete pqm;

} //MqcluspClose


DWORD
MqcluspOnlineThread(
    CQmResource * pqm
    )

/*++

Routine Description:

    This is the thread where stuff happens: bringing
    the resource online.

Arguments:

    pqm - pointer to the CQmResource object

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_INFORMATION, L"Starting online thread.\n");

    try
    {
        pqm->SetState(ClusterResourceOnlinePending);
        pqm->ReportState();

        DWORD status = ERROR_SUCCESS;
        DWORD dwSetupStatus = MSMQ_SETUP_DONE;

        
        if (pqm->IsFirstOnline(&dwSetupStatus))
        {
        	//
	        // First online - NT4 upgraded cluster or fresh install.
	        //
            status = pqm->BringOnlineFirstTime();
            if (ERROR_SUCCESS != status)
            {
                pqm->SetState(ClusterResourceFailed);
                pqm->ReportState();

                (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_INFORMATION,
                                      L"Failed to bring online first time. Error 0x%1!x!.\n", status);

                return status;
            }

            if (dwSetupStatus == MSMQ_SETUP_UPGRADE_FROM_NT)
            {
                pqm->DeleteNt4Files();
            }
        }

        status = pqm->BringOnline();
        if (ERROR_SUCCESS != status)
        {
            //
            // We report the resource as failed, so make sure
            // the service and driver are indeed down.
            //
            pqm->StopService(pqm->GetServiceName());
            pqm->StopService(pqm->GetDriverName());

            pqm->SetState(ClusterResourceFailed);
            pqm->ReportState();

            (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_INFORMATION,
                                  L"Failed to bring online. Error 0x%1!x!.\n", status);

            return status;
        }


        pqm->SetState(ClusterResourceOnline);
        pqm->ReportState();
    }
    catch (const bad_alloc&)
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, NO_MEMORY_ERR, 0);

        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, L"No memory (online thread).\n");

        return ERROR_OUTOFMEMORY;
    }

    return(ERROR_SUCCESS);

} //MqcluspOnlineThread


BOOL
MqcluspCheckIsAlive(
    CQmResource * pqm
    )

/*++

Routine Description:

    Verify that the msmq service of this QM is up and running.

Arguments:

    pqm - pointer to the CQmResource object

Return Value:

    TRUE - The msmq service for this QM is up and running.

    FALSE - The msmq service for this QM is not up and running.

--*/

{
    try
    {
        return pqm->CheckIsAlive();
    }
    catch (const bad_alloc&)
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, NO_MEMORY_ERR, 0);
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, L"No memory (check is alive).\n");
    }

    return false;

} //MqcluspCheckIsAlive


DWORD
MqcluspClusctlResourceGetRequiredDependencies(
    PVOID OutBuffer,
    DWORD OutBufferSize,
    LPDWORD BytesReturned
    )
{
    //
    // MSMQ resource depends on a disk and network name.
    // This is common to many resources and the code is
    // taken from cluster tree.
    //

typedef struct _COMMON_DEPEND_DATA {
    CLUSPROP_RESOURCE_CLASS storageEntry;
    CLUSPROP_SZ_DECLARE( networkEntry, sizeof(L"Network Name") / sizeof(WCHAR) );
    CLUSPROP_SYNTAX endmark;
} COMMON_DEPEND_DATA, *PCOMMON_DEPEND_DATA;

typedef struct _COMMON_DEPEND_SETUP {
    DWORD               Offset;
    CLUSPROP_SYNTAX     Syntax;
    DWORD               Length;
    PVOID               Value;
} COMMON_DEPEND_SETUP, * PCOMMON_DEPEND_SETUP;

static COMMON_DEPEND_SETUP CommonDependSetup[] = {
    { FIELD_OFFSET(COMMON_DEPEND_DATA, storageEntry), CLUSPROP_SYNTAX_RESCLASS, sizeof(CLUSTER_RESOURCE_CLASS), (PVOID)CLUS_RESCLASS_STORAGE },
    { FIELD_OFFSET(COMMON_DEPEND_DATA, networkEntry), CLUSPROP_SYNTAX_NAME, sizeof(L"Network Name"), L"Network Name" },
    { 0, 0 }
};

    try
    {
        PCOMMON_DEPEND_SETUP pdepsetup = CommonDependSetup;
        PCOMMON_DEPEND_DATA pdepdata = (PCOMMON_DEPEND_DATA)OutBuffer;
        CLUSPROP_BUFFER_HELPER value;

        *BytesReturned = sizeof(COMMON_DEPEND_DATA);
        if ( OutBufferSize < sizeof(COMMON_DEPEND_DATA) )
        {
            if ( OutBuffer == NULL )
            {
                return ERROR_SUCCESS;
            }

            return ERROR_MORE_DATA;
        }

        ZeroMemory( OutBuffer, sizeof(COMMON_DEPEND_DATA) );

        while ( pdepsetup->Syntax.dw != 0 )
        {
            value.pb = (PUCHAR)OutBuffer + pdepsetup->Offset;
            value.pValue->Syntax.dw = pdepsetup->Syntax.dw;
            value.pValue->cbLength = pdepsetup->Length;

            switch ( pdepsetup->Syntax.wFormat )
            {
            case CLUSPROP_FORMAT_DWORD:
                value.pDwordValue->dw = (DWORD) DWORD_PTR_TO_DWORD(pdepsetup->Value); //safe cast, the value is known to be a DWORD constant
                break;

            case CLUSPROP_FORMAT_SZ:
                memcpy( value.pBinaryValue->rgb, pdepsetup->Value, pdepsetup->Length );
                break;

            default:
                break;
            }
            pdepsetup++;
        }
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;
    }
    catch (const bad_alloc&)
    {
        return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;

} //MqcluspClusctlResourceGetRequiredDependencies


DWORD
MqcluspClusctlResourceSetName(
    VOID
    )
{
    //
    // Refuse to rename the resource
    //
    return ERROR_CALL_NOT_IMPLEMENTED;

} //MqcluspClusctlResourceSetName


DWORD
MqcluspClusctlResourceDelete(
    CQmResource * pqm
    )
{
    (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_INFORMATION, L"Deleting resource.\n");


    try
    {
	    g_CancelRpc.Init();

        pqm->RemoveService(pqm->GetServiceName());

        pqm->RemoveService(pqm->GetDriverName());

        pqm->DeleteMqacFile();

        pqm->DeleteMsmqDir();

        pqm->AdsDeleteQmObject();

        pqm->AddRemoveRegistryCheckpoint(CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT);

        pqm->AddRemoveCryptoCheckpoints(CLUSCTL_RESOURCE_DELETE_CRYPTO_CHECKPOINT);

        pqm->DeleteFalconRegSection();

		pqm->DeleteEventSourceRegistry();
    }
    catch (const bad_alloc&)
    {
		ShutDownDebugWindow();
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, NO_MEMORY_ERR, 0);
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, L"No memory (resource delete).\n");

        return ERROR_OUTOFMEMORY;
    }

	ShutDownDebugWindow();
    return ERROR_SUCCESS;

} //MqcluspClusctlResourceDelete


DWORD
MqcluspClusctlResourceTypeStartingPhase2(
    VOID
    )
{
    HCLUSTER hCluster = OpenCluster(NULL);
    if (hCluster == NULL)
    {
        return GetLastError();
    }

    //
    // Delete old msmq resource type. Ignore failures. 
    // This call will fail if there is a resource of this type, this is handled elsewhere.
    //
    DeleteClusterResourceType(hCluster, L"Microsoft Message Queue Server");

    return ERROR_SUCCESS;

} // MqcluspClusctlResourceTypeStartingPhase2


void LogMsgHR(HRESULT, LPWSTR, USHORT)
{
    //
    // Temporary. Null implementation for this callback so that we can link
    // with ad.lib. (ShaiK, 15-Jun-2000)
    //
    NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\cluster\mqclus\stdh.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    stdh.cpp

Abstract:

    Creates the PCH

Author:

    Shai Kariv (shaik) Jan 12, 1999

Revision History:

--*/

#include "stdh.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\cluster\mqclus\mqclusp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    mqclusp.h

Abstract:

    Header for my internal routines

Author:

    Shai Kariv (shaik) Jan 12, 1999

Revision History:

--*/

#ifndef _MQCLUSP_H_
#define _MQCLUSP_H_

#include "stdh.h"
#include <cs.h>
#include <_mqini.h>
#include <autorel2.h>
#include <autorel3.h>

extern HMODULE	g_hResourceMod;
extern PLOG_EVENT_ROUTINE           g_pfLogClusterEvent;
extern PSET_RESOURCE_STATUS_ROUTINE g_pfSetResourceStatus;
extern CLRES_FUNCTION_TABLE         g_MqclusFunctionTable;
    

class CMqclusException
{
};


class CQmResource
{
    //
    // CQmResource - holds information of a QM resource.
    //

public:                   
    CQmResource(LPCWSTR, HKEY, RESOURCE_HANDLE);
    ~CQmResource() {};

    RESID GetResId(VOID) const { return m_ResId; };
    RESOURCE_HANDLE GetReportHandle(VOID) const { return m_hReport; };
    LPCWSTR GetResourceName(VOID) const { return m_pwzResourceName; };
    LPCWSTR GetServiceName(VOID) const { return m_wzServiceName; }; 
    LPCWSTR GetDriverName(VOID) const  { return m_wzDriverName; };
    LPCWSTR GetFalconRegSection(VOID) const { return m_wzFalconRegSection; };
    LPCWSTR GetCrypto40FullKey(VOID) const  { return m_wzCrypto40FullKey; };
    LPCWSTR GetCrypto128FullKey(VOID) const { return m_wzCrypto128FullKey; };

    BOOL CheckIsAlive(VOID) const;
    VOID DeleteFalconRegSection(VOID);
    VOID DeleteMsmqDir(VOID) const;
    VOID DeleteMqacFile(VOID) const;

    bool SetFalconKeyValue(LPCWSTR, DWORD, const VOID*, DWORD) const;
    bool GetFalconKeyValue(LPCWSTR, VOID*, DWORD*) const;
                            
    bool  IsFirstOnline(DWORD*) const;
    DWORD BringOnlineFirstTime();
    DWORD BringOnline();

    VOID    SetState(CLUSTER_RESOURCE_STATE s) { m_ResourceStatus.ResourceState = s; };
    inline VOID    ReportState(VOID) const;

    DWORD   ClusterResourceControl(LPCWSTR, DWORD, LPBYTE*, DWORD*) const;

    bool    AddRemoveRegistryCheckpoint(DWORD) const;
    bool    AddRemoveCryptoCheckpoints(DWORD) const;

    DWORD   AdsDeleteQmObject(VOID) const;

    DWORD   CreateEventSourceRegistry(VOID) const;
    VOID    DeleteEventSourceRegistry(VOID) const;

    DWORD   StopService(LPCWSTR) const;
    DWORD   RemoveService(LPCWSTR) const;

    VOID   DeleteNt4Files(VOID) const;

    VOID SetSetupStatusKey(VOID);

    CLUS_WORKER m_OnlineThread;
                            
private:                  

    class CQmResourceRegistry
    {
    public:
        explicit CQmResourceRegistry(LPCWSTR pwzService);
        ~CQmResourceRegistry();

    private:
        CS m_lock;
    }; 

    VOID   RegDeleteTree(HKEY, LPCWSTR) const;
    VOID   DeleteDirectoryFiles(LPCWSTR) const;

    DWORD  WaitForDtc(VOID) const;
	bool   IsNetworkNameRequireKerberosEnabled() const;
    bool   IsResourceNetworkName(LPCWSTR);
    bool   IsResourceDiskDrive(LPCWSTR);
    DWORD  QueryResourceDependencies(VOID);

	DWORD  QueryMsmq1ServerForSite(VOID);
    DWORD  AdsInit(VOID);
    HRESULT AdsCreateQmObjectInternal(BYTE* pClusterServiceSid) const;
	DWORD  GetVirtualServerToken(HANDLE* phVSToken) const;
    DWORD  AdsCreateQmObject(VOID) const;
    DWORD  AdsCreateQmPublicKeys(VOID) const;
    DWORD  AdsReadQmProperties(VOID);
    DWORD  AdsReadQmSecurityDescriptor(VOID);

	VOID   OnlineRegisterCertificate(VOID) const;

    DWORD  CloneMqacFile(VOID) const;
    bool   AddRemoveCryptoCheckpointsInternal(DWORD, bool) const;

    DWORD  RegisterDriver(VOID) const;
    DWORD  RegisterService(VOID) const;
    DWORD  StartService(VOID) const;
    DWORD  SetServiceEnvironment(VOID) const;

    DWORD  ReportLastError(DWORD, LPCWSTR, LPCWSTR) const;

private:
    RESID                     m_ResId;
    RESOURCE_HANDLE           m_hReport;
    AP<WCHAR>                 m_pwzResourceName; 
    mutable RESOURCE_STATUS   m_ResourceStatus;

    GUID                      m_guidQm;
    CSecDescPointer           m_pSd;
    DWORD                     m_cbSdSize;
    WCHAR                     m_wDiskDrive;
    CServiceHandle            m_hScm;
    CAutoCluster              m_hCluster;
    CClusterResource          m_hResource;
    bool                      m_fServerIsMsmq1;

    DWORD                     m_dwWorkgroup;
    DWORD                     m_nSites;
    AP<GUID>                  m_pguidSites;
    DWORD                     m_dwMqsRouting;
    DWORD                     m_dwMqsDepClients;
    WCHAR                     m_wzCurrentDsServer[MAX_REG_DSSERVER_LEN];

    AP<WCHAR>                 m_pwzNetworkName; 
    AP<WCHAR>                 m_pwzNetworkResourceName;
    WCHAR                     m_wzFalconRegSection[200 + 100];
    WCHAR                     m_wzServiceName[200];
    WCHAR                     m_wzDriverName[200];
    WCHAR                     m_wzDriverPath[MAX_PATH+1];
    WCHAR                     m_wzCrypto40Container[200];
    WCHAR                     m_wzCrypto40FullKey[200];
    WCHAR                     m_wzCrypto128Container[200];
    WCHAR                     m_wzCrypto128FullKey[200];

}; //class CQmResource


DWORD
MqcluspStartup(
    VOID
    );

RESID
MqcluspOpen(
    LPCWSTR pwzResourceName,
    HKEY hResourceKey,
    RESOURCE_HANDLE hResourceHandle
    );

VOID
MqcluspClose(
    CQmResource * pqm
    );

DWORD 
MqcluspOnlineThread(
    CQmResource * pqm
    );

DWORD
MqcluspOffline(
    CQmResource * pqm
    );

BOOL
MqcluspCheckIsAlive(
    CQmResource * pqm
    );

DWORD
MqcluspClusctlResourceGetRegistryCheckpoints(
    CQmResource * pqm,
    PVOID OutBuffer,
    DWORD OutBufferSize,
    LPDWORD BytesReturned
    );

DWORD
MqcluspClusctlResourceGetCryptoCheckpoints(
    CQmResource * pqm,
    PVOID OutBuffer,
    DWORD OutBufferSize,
    LPDWORD BytesReturned
    );

DWORD
MqcluspClusctlResourceGetRequiredDependencies(
    PVOID OutBuffer,
    DWORD OutBufferSize,
    LPDWORD BytesReturned
    );

DWORD
MqcluspClusctlResourceSetName(
    VOID
    );

DWORD
MqcluspClusctlResourceDelete(
    CQmResource * pqm
    );

DWORD
MqcluspClusctlResourceTypeStartingPhase2(
    VOID
    );

#endif //_MQCLUSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\cluster\mqclus\stdh.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    Main header file

Author:

    Shai Kariv (shaik) Jan 12, 1999

Revision History:

--*/

#ifndef _MQCLUS_STDH_H_
#define _MQCLUS_STDH_H_

#include <_stdh.h>
#include <autoptr.h>

#include <clusapi.h>
#include <resapi.h>
#include <stdio.h>

#endif //_MQCLUS_STDH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\apps\xacttest\xtest\xtest.cpp ===
// General sequential test for Falcon/SQL Transactions

#define DBNTWIN32
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <time.h>

#define INITGUID
#include <txdtc.h>
#include <xolehlp.h>
#include "initguid.h"
//#include <OLECTLID.H>
#include <olectl.h>

#include <sqlfront.h>
#include <sqldb.h>

#include <mq.h>
#include "async.h"

#define RECOVERY_TIME 3000

#include "..\common.cpp"

#define ENTER(t)  t -= GetTickCount()
#define LEAVE(t)  t += GetTickCount()
#define PRINT(n,t) printf("%10s %10d %3d\n", n, t,  t*100/ulTimeTotal)

#define MSDTC_PROXY_DLL_NAME   TEXT("xolehlp.dll")    // Name of the DTC helper proxy DLL

//This API should be used to obtain an IUnknown or a ITransactionDispenser
//interface from the Microsoft Distributed Transaction Coordinator's proxy.
//Typically, a NULL is passed for the host name and the TM Name. In which
//case the MS DTC on the same host is contacted and the interface provided
//for it.
typedef HRESULT (STDAPIVCALLTYPE * LPFNDtcGetTransactionManager) (
                                             LPSTR  pszHost,
                                             LPSTR  pszTmName,
                                    /* in */ REFIID rid,
                                    /* in */ DWORD  i_grfOptions,
                                    /* in */ void FAR * i_pvConfigParams,
                                    /*out */ void** ppvObject ) ;

// In order to use InProc RT Stub RM one must add RT_XACT_STUB to preprocessor definitions

//-------------------------------------
// Global data - read only from threads
//-------------------------------------

ULONG      seed = 0, 
           ulPrevious = 0, 
           nTries = 1000, 
           nBurst = 1,
           nThreads = 1,
           nMaxSleep = 20, 
           nMaxTimeQueue = 0,
           nMaxTimeLive = 0, 
           nAbortChances = 50,  
           nAcking = 0, 
           nSync = 1, 
           nSize = 100,
           nListing = 0;
LPSTR      pszQueue = "alexdad3\\q1", 
           pszAdminQueue = "alexdad3\\q1admin", 
           pszTable = "table6",
           pszMode = "ts",
           pszServer = "";
BOOL       fTransactions,  fSend, fReceive, fEnlist, fUpdate,  fGlobalCommit, fDeadLetter, fJournal,
           fUncoordinated, fStub, fExpress, fInternal, fViper, fXA, fImmediate, fDirect,
           fAuthenticate, fBoundaries;
HANDLE     hQueueR, hQueueS;

DWORD      dwFormatNameLength = 100;
WCHAR      wszPathName[100];
WCHAR      wszFmtName[100];

ULONG	         nActiveThreads = 0; // counter of live ones
CRITICAL_SECTION crCounter;          // pr