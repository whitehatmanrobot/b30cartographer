  ..\icwdebug.cpp	   \
        ..\fdi.cpp         \
        ..\appwnd.cpp      \
        ..\button.cpp      \
        ..\icwsupr.cpp


PRECOMPILED_INCLUDE = ..\pre.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\dialerr.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  DIALERR.CPP - Functions for final Wizard pages
//

//  HISTORY:
//  
//  05/28/98    donaldm     created
//
//*********************************************************************

#include "pre.h"
#include "htmlhelp.h"

void FillModemList(HWND hDlg)
{
    long lNumModems;
    long lCurrModem;
    long lIndex;
    HWND hWndMdmCmb = GetDlgItem(hDlg, IDC_DIALERR_MODEM);

    ComboBox_ResetContent(hWndMdmCmb);


    // Fill the list with the current set of installed modems
    gpWizardState->pRefDial->get_ModemEnum_NumDevices( &lNumModems );

    //RefDialSignup.ModemEnum_Reset();
    gpWizardState->pRefDial->ModemEnum_Reset( );
    for (lIndex=0; lIndex < lNumModems; lIndex++)
    {
        BSTR bstr = NULL;
        gpWizardState->pRefDial->ModemEnum_Next(&bstr);
        ComboBox_InsertString(hWndMdmCmb, lIndex, W2A(bstr));
        SysFreeString(bstr);
    }

    gpWizardState->pRefDial->get_CurrentModem(&lCurrModem);

    if (lCurrModem != -1)
    {
        ComboBox_SetCurSel(hWndMdmCmb, lCurrModem);
    }
    else
    {
        ComboBox_SetCurSel(hWndMdmCmb, 0);
    }

}

void GetSupportNumber(HWND hDlg)
{
    HWND hwndSupport         = GetDlgItem(hDlg, IDC_SERVERR_HELP);
    BSTR bstrSupportPhoneNum = NULL; 
    TCHAR szFmt [MAX_MESSAGE_LEN*3];

    // Fill in the support number
    gpWizardState->pRefDial->get_SupportNumber(&bstrSupportPhoneNum);
    
    //If no support number could be found this will
    //be null, in which case we don't want to display the
    //support number string
    if(bstrSupportPhoneNum)
    {
        LoadString(g_hInstance, IDS_DIALERR_HELP, szFmt, ARRAYSIZE(szFmt));
        lstrcat(szFmt, W2A(bstrSupportPhoneNum));
        SetWindowText(hwndSupport, szFmt);
        SysFreeString(bstrSupportPhoneNum);
        ShowWindow(hwndSupport, SW_SHOW);
    }
    else
        ShowWindow(hwndSupport, SW_HIDE);
}

/*******************************************************************

  NAME:    DialErrorInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
            fFirstInit - TRUE if this is the first time the dialog
            is initialized, FALSE if this InitProc has been called
            before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK DialErrorInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    if (!fFirstInit)
    {
        // Show the phone Number
        BSTR  bstrPhoneNum = NULL; 
        BSTR  bstrErrMsg   = NULL;
        
        gpWizardState->pRefDial->get_DialPhoneNumber(&bstrPhoneNum);      
        SetWindowLongPtr(GetDlgItem(hDlg, IDC_DIALERR_PHONENUMBER), GWLP_USERDATA, TRUE);
        SetWindowText(GetDlgItem(hDlg, IDC_DIALERR_PHONENUMBER), W2A(bstrPhoneNum));
        SysFreeString(bstrPhoneNum);
        EnableWindow(GetDlgItem(hDlg, IDC_DIALING_PROPERTIES), TRUE);

        // Display the error text message
        gpWizardState->pRefDial->get_DialErrorMsg(&bstrErrMsg);
        SetWindowText(GetDlgItem(hDlg, IDC_DIALERR_TEXT), W2A(bstrErrMsg));
        SysFreeString(bstrErrMsg);

        // Enum Modems, and fill in list.
        FillModemList(hDlg);   

        //Get the support number for the current dlg
        // Currently this is removed from BETA 2
        // GetSupportNumber(hDlg);

        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_REFDIALERROR;
    }

    return TRUE;
}


/*******************************************************************

  NAME:    DialErrorOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
            fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
            puNextPage - if 'Next' was pressed,
            proc can fill this in with next page to go to.  This
            parameter is ingored if 'Back' was pressed.
            pfKeepHistory - page will not be kept in history if
            proc fills this in with FALSE.

  EXIT:     returns TRUE to allow page to be turned, FALSE
            to keep the same page.

********************************************************************/
BOOL CALLBACK DialErrorOKProc
(
    HWND hMdmCmb,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    // Initialze status before connecting
    gpWizardState->lRefDialTerminateStatus = ERROR_SUCCESS;
    gpWizardState->bDoneRefServDownload    = FALSE;
    gpWizardState->bDoneRefServRAS         = FALSE;
    gpWizardState->bStartRefServDownload   = FALSE;

    // Assume the user has selected a number on this page
    // So we will not do SetupForDialing again next time
    gpWizardState->bDoUserPick          = TRUE;

    if (fForward)
    {
        *pfKeepHistory = FALSE;
        *puNextPage = ORD_PAGE_REFSERVDIAL;

        // Set the new phone Number
        TCHAR    szPhone[MAX_RES_LEN];
        GetWindowText(GetDlgItem(hMdmCmb, IDC_DIALERR_PHONENUMBER), szPhone, ARRAYSIZE(szPhone));
        gpWizardState->pRefDial->put_DialPhoneNumber(A2W(szPhone));

        // Set the current modem 
        long lCurrModem = ComboBox_GetCurSel(GetDlgItem(hMdmCmb, IDC_DIALERR_MODEM));
        gpWizardState->pRefDial->put_CurrentModem(lCurrModem);
    }
    else
    {
        BOOL bRetVal;
        // Set userpick to FALSE to regenerate connectoid
        gpWizardState->bDoUserPick = FALSE;
        gpWizardState->pRefDial->RemoveConnectoid(&bRetVal);
    }
    return TRUE;
}






/*******************************************************************

  NAME:    DialErrorCmdProc

  SYNOPSIS:  Called when a command is generated from  page

  ENTRY:    hDlg - dialog window
            wParam - wParam
            lParam - lParam
          
  EXIT: returns TRUE 

********************************************************************/

BOOL g_bNotChildDlgUpdate = TRUE;

BOOL CALLBACK DialErrorCmdProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{

    switch(GET_WM_COMMAND_CMD(wParam, lParam))
    {
        case BN_CLICKED:
        {          
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            { 
                case IDC_CHANGE_NUMBER: 
                {
                    BOOL bRetVal;
                    
                    g_bNotChildDlgUpdate = FALSE;
                    // Pass current modem, because if ISDN modem we need to show different content
                    gpWizardState->pRefDial->ShowPhoneBook(gpWizardState->cmnStateData.dwCountryCode,
                                                           ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_DIALERR_MODEM)),
                                                           &bRetVal);
                    if (bRetVal)
                    {
                        // Show the phone Number as it may be changed after the popup
                        BSTR bstrPhoneNum = NULL; 
                        gpWizardState->pRefDial->get_DialPhoneNumber(&bstrPhoneNum);
                        SetWindowText(GetDlgItem(hDlg, IDC_DIALERR_PHONENUMBER), W2A(bstrPhoneNum));
                        SysFreeString(bstrPhoneNum);

                        // 10/6/98 vyung 
                        // We decided to remove this support number for beta 2
                        // Get the support number for the current dlg
                        // GetSupportNumber(hDlg);
                        
                        g_bNotChildDlgUpdate = TRUE;
                   }

                    break;
                }
                
                case IDC_DIALING_PROPERTIES:   
                {
                    BOOL bRetVal;

                    g_bNotChildDlgUpdate = FALSE;
                    
                    gpWizardState->pRefDial->ShowDialingProperties(&bRetVal);
                    if (bRetVal)
                    {
                        // Show the phone Number as it may be changed after the popup
                        BSTR    bstrPhoneNum = NULL; 
                        gpWizardState->pRefDial->get_DialPhoneNumber(&bstrPhoneNum);
                        SetWindowText(GetDlgItem(hDlg, IDC_DIALERR_PHONENUMBER), W2A(bstrPhoneNum));
                        SysFreeString(bstrPhoneNum);

                        // Show the modem as it may be changed after the popup
                        LONG    lCurrModem = 0;
                        gpWizardState->pRefDial->get_CurrentModem(&lCurrModem);
                        if (lCurrModem == -1l)
                        {
                            lCurrModem = 0;
                        }
                        ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_DIALERR_MODEM), lCurrModem);
                        if (gpWizardState->pTapiLocationInfo)
                        {
                            BOOL    bRetVal;
                            BSTR    bstrAreaCode = NULL;
                            DWORD   dwCountryCode;
                            gpWizardState->pTapiLocationInfo->GetTapiLocationInfo(&bRetVal);
                            gpWizardState->pTapiLocationInfo->get_lCountryCode((long *)&dwCountryCode);
                            gpWizardState->pTapiLocationInfo->get_bstrAreaCode(&bstrAreaCode);
                            gpWizardState->cmnStateData.dwCountryCode = dwCountryCode;
                            if (bstrAreaCode)
                            {
                                lstrcpy(gpWizardState->cmnStateData.szAreaCode, W2A(bstrAreaCode));
                                SysFreeString(bstrAreaCode);
                            }
                            else
                            {
                                gpWizardState->cmnStateData.szAreaCode[0] = TEXT('\0');
                            }
                        }
                        g_bNotChildDlgUpdate = TRUE;
                    }
                    break;
                }
                case IDC_DIAL_HELP:
                {
                    HtmlHelp(NULL, ICW_HTML_HELP_TROUBLE_TOPIC, HH_DISPLAY_TOPIC, NULL);
                    break;
                }
                default:
                    break;
            }
            break;
        } 
        case EN_UPDATE:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            { 
                case IDC_DIALERR_PHONENUMBER:
                {
                    if (!GetWindowLongPtr(GetDlgItem(hDlg, IDC_DIALERR_PHONENUMBER), GWLP_USERDATA))
                    {
                        //Since when the other popups set this text this event will fire we 
                        //don't disable wanna disable the button when it's them.
                        //more so because a race condition and caos ensues causing a lack of input
                        //while windows figures out what the heck is going on
                        if(g_bNotChildDlgUpdate)
                            EnableWindow(GetDlgItem(hDlg, IDC_DIALING_PROPERTIES), FALSE);
                    }
                    SetWindowLongPtr(GetDlgItem(hDlg, IDC_DIALERR_PHONENUMBER), GWLP_USERDATA, FALSE);
                }
            }
        }     
        default:
            break;
    } // End of switch

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\icwhelp.cpp ===
#include "pre.h"


// Include the interface file for the ICWHELP Dll
#include "..\inc\icwhelp_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\gendlg.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#include "pre.h"

#ifndef ICWDEBUG
#include "tutor.h"

extern CICWTutorApp* g_pICWTutorApp; 

#endif

#define BITMAP_WIDTH  164
#define BITMAP_HEIGHT 458
/*******************************************************************

  NAME:    GetDlgIDFromIndex

  SYNOPSIS:  For a given zero-based page index, returns the
        corresponding dialog ID for the page

  4/24/97    jmazner    When dealing with apprentice pages, we may call
                    this function with dialog IDs (IDD_PAGE_*), rather
                    than an index (ORD_PAGE*).  Added code to check
                    whether the number passed in is an index or dlgID.

********************************************************************/
UINT GetDlgIDFromIndex(UINT uPageIndex)
{
    if( uPageIndex <= EXE_MAX_PAGE_INDEX )
    {
        ASSERT(uPageIndex < EXE_NUM_WIZARD_PAGES);

        return PageInfo[uPageIndex].uDlgID;
    }
    else
    {
        return(uPageIndex);
    }
}

//
//  GENDLG.C - 
//  Generic DLG proc for common wizard functions
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//


// ############################################################################
HRESULT MakeWizard97Title (HWND hwnd)
{
    HRESULT     hr = ERROR_SUCCESS;
    HFONT       hfont = NULL;
    HFONT       hnewfont = NULL;
    LOGFONT     *plogfont = NULL;
    HDC         hDC;
    
    if (!hwnd) goto MakeWizard97TitleExit;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (!hfont)
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeWizard97TitleExit;
    }

    plogfont = (LOGFONT*)malloc(sizeof(LOGFONT));
    if (!plogfont)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto MakeWizard97TitleExit;
    }

    if (!GetObject(hfont,sizeof(LOGFONT),(LPVOID)plogfont))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeWizard97TitleExit;
    }

    // We want 12 PT Veranda for Wizard 97.
    hDC = GetDC(NULL);
    if(hDC)
    {
        plogfont->lfHeight = -MulDiv(WIZ97_TITLE_FONT_PTS, GetDeviceCaps(hDC, LOGPIXELSY), 72); 
        ReleaseDC(NULL, hDC);
    }        
    plogfont->lfWeight = (int) FW_BOLD;

    if (!LoadString(g_hInstance, IDS_WIZ97_TITLE_FONT_FACE, plogfont->lfFaceName, LF_FACESIZE))
        lstrcpy(plogfont->lfFaceName, TEXT("Verdana"));

    if (!(hnewfont = CreateFontIndirect(plogfont)))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeWizard97TitleExit;
    }

    SendMessage(hwnd,WM_SETFONT,(WPARAM)hnewfont,MAKELPARAM(TRUE,0));
    
    free(plogfont);
    
MakeWizard97TitleExit:
    //if (hfont) DeleteObject(hfont);
    // BUG:? Do I need to delete hnewfont at some time?
    // The answer is Yes. ChrisK 7/1/96
    return hr;
}

// ############################################################################
HRESULT ReleaseBold(HWND hwnd)
{
    HFONT hfont = NULL;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (hfont) DeleteObject(hfont);
    return ERROR_SUCCESS;
}

//-----------------------------------------------------------------------------
//  Function    MiscInitProc
//
//    Synopsis    Our generic dialog proc calls this in case any of the wizard
//                dialogs have to do any sneaky stuff.
//
//    Arguments:    hDlg - dialog window
//                fFirstInit - TRUE if this is the first time the dialog
//                    is initialized, FALSE if this InitProc has been called
//                    before (e.g. went past this page and backed up)
//
//    Returns:    TRUE
// 
//    History:    10/28/96    ValdonB    Created
//                11/25/96    Jmazner    copied from icwconn1\psheet.cpp
//                            Normandy #10586
//
//-----------------------------------------------------------------------------
BOOL CALLBACK MiscInitProc
(
    HWND hDlg, 
    BOOL fFirstInit, 
    UINT uDlgID
)
{
//    switch( uDlgID )
//    {
//    }
    return TRUE;
}


INT_PTR CALLBACK CancelCmdProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // put the dialog in the center of the screen
            RECT rc;
            GetWindowRect(hDlg, &rc);
            SetWindowPos(hDlg,
                        NULL,
                        ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
                        ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
                        0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
            break;
            
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    if (Button_GetCheck(GetDlgItem(hDlg, IDC_CHECK_HIDE_ICW)))
                    {
                        // Set the welcome state
                        UpdateWelcomeRegSetting(TRUE);
    
                        // Restore the desktop
                        UndoDesktopChanges(g_hInstance);
    
                        // Mark the ICW as being complete
                        SetICWComplete();

                        gfQuitWizard = TRUE;
                    }
                    EndDialog(hDlg,TRUE);
                    break;

                case IDCANCEL:
                   EndDialog(hDlg,FALSE);
                    break;                  
            }
            break;
    }

    return FALSE;
}


//This is a dummy winproc needed for a dummy child window
//which will be used by dlls etc to get the hwnd for this app.
//**************************************************
//***REMOVING THIS CODE WILL CAUSE OTHER CODE    ***
//***IN ICWHELP AND POSSIBLY OTHER PACES TO FAIL ***
//**************************************************
LRESULT CALLBACK InvisibleChildDummyWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    return DefWindowProc (hWnd, message, wParam, lParam);
}

/*******************************************************************
//
//    Function:    PaintWithPaletteBitmap
//
//    Arguments:   lprc is the target rectangle.
//                 cy is the putative dimensions of hbmpPaint.
//                 If the target rectangle is taller than cy, then 
//                 fill the rest with the pixel in the upper left 
//                 corner of the hbmpPaint.
//
//    Returns:     void
//
//    History:      10-29-98    Vyung    -  Stole from prsht.c
//
********************************************************************/
void PaintWithPaletteBitmap(HDC hdc, LPRECT lprc, int cy, HBITMAP hbmpPaint)
{
    HDC hdcBmp;

    hdcBmp = CreateCompatibleDC(hdc);
    SelectObject(hdcBmp, hbmpPaint);
    BitBlt(hdc, lprc->left, lprc->top, RECTWIDTH(*lprc), cy, hdcBmp, 0, 0, SRCCOPY);

    // StretchBlt does mirroring if you pass a negative height,
    // so do the stretch only if there actually is unpainted space
    if (RECTHEIGHT(*lprc) - cy > 0)
        StretchBlt(hdc, lprc->left, cy,
                   RECTWIDTH(*lprc), RECTHEIGHT(*lprc) - cy,
                   hdcBmp, 0, 0, 1, 1, SRCCOPY);

    DeleteDC(hdcBmp);
}

/*******************************************************************
//
//    Function:    Prsht_EraseWizBkgnd
//
//    Arguments:   Draw the background for wizard pages.
//                 hDlg is dialog handle.
//                 hdc is device context
//
//    Returns:     void
//
//    History:     10-29-98    Vyung   - Stole from prsht.c
//
********************************************************************/
LRESULT Prsht_EraseWizBkgnd(HWND hDlg, HDC hdc)
{
    
    HBRUSH hbrWindow = GetSysColorBrush(COLOR_WINDOW);
    RECT rc;
    GetClientRect(hDlg, &rc);
    FillRect(hdc, &rc, hbrWindow);

    rc.right = BITMAP_WIDTH;
    rc.left = 0;

    PaintWithPaletteBitmap(hdc, &rc, BITMAP_HEIGHT, gpWizardState->cmnStateData.hbmWatermark);

    return TRUE;
}
/*******************************************************************

  NAME:    GenDlgProc

  SYNOPSIS:  Generic dialog proc for all wizard pages

  NOTES:    This dialog proc provides the following default behavior:
          init:         back and next buttons enabled
          next btn:     switches to page following current page
          back btn:     switches to previous page
          cancel btn:   prompts user to confirm, and cancels the wizard
          dlg ctrl:     does nothing (in response to WM_COMMANDs)
          
        Wizard pages can specify their own handler functions
        (in the PageInfo table) to override default behavior for
        any of the above actions.

********************************************************************/
INT_PTR CALLBACK GenDlgProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    static HCURSOR  hcurOld = NULL;
    static BOOL     bKilledSysmenu = FALSE;
    PAGEINFO        *pPageInfo = (PAGEINFO *) GetWindowLongPtr(hDlg,DWLP_USER);

    switch (uMsg) 
    {

        case WM_ERASEBKGND:
        {
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                FillWindowWithAppBackground(hDlg, (HDC)wParam);
                return TRUE;
            }
            else
            {
                // Only paint the external page 
                if ((!pPageInfo->nIdTitle) && (IDD_PAGE_BRANDEDINTRO != pPageInfo->uDlgID))
                {
                    Prsht_EraseWizBkgnd(hDlg, (HDC) wParam);
                    return TRUE;
                }
            }                
            break;
        }
        
        GENDLG_CTLCOLOR:
        case WM_CTLCOLOR:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORSCROLLBAR:
        {
            // Only paint the external page and except the ISP sel page
            if ((!pPageInfo->nIdTitle) && (IDD_PAGE_BRANDEDINTRO != pPageInfo->uDlgID))
            {

                HBRUSH hbrWindow = GetSysColorBrush(COLOR_WINDOW);
                DefWindowProc(hDlg, uMsg, wParam, lParam);
                SetBkMode((HDC)wParam, TRANSPARENT);
                return (LRESULT)hbrWindow;
            }
            break;
        }
        

        // We need to make sure static controls draw transparently
        // on the background bitmap.  This is done by painting in
        // the appropriate portion of the background, and then 
        // returning a NULL brush so the control just draws the text    
        case WM_CTLCOLORSTATIC:
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                SetTextColor((HDC)wParam, gpWizardState->cmnStateData.clrText);
                // See if the control is an ES_READONLY style edit box, and if
                // so then don't make it transparent
                if (!(GetWindowLong((HWND)lParam, GWL_STYLE) & ES_READONLY))
                {
                    SetBkMode((HDC)wParam, TRANSPARENT);
                    return (INT_PTR) GetStockObject(NULL_BRUSH);    
                }   
                
                break;             
            }                
            else
            {
                // Not in modeless opperation so just do the default cltcolor
                // handling
                goto GENDLG_CTLCOLOR;
            }

#ifndef ICWDEBUG
        case WM_RUNICWTUTORAPP:    
        {
            g_pICWTutorApp->LaunchTutorApp();
            break;
        }
#endif
        case WM_INITDIALOG:
        {
            // get propsheet page struct passed in
            LPPROPSHEETPAGE lpsp = (LPPROPSHEETPAGE) lParam;
            ASSERT(lpsp);
        
            // fetch our private page info from propsheet struct
            pPageInfo = (PAGEINFO *)lpsp->lParam;

            // store pointer to private page info in window data for later
            SetWindowLongPtr(hDlg,DWLP_USER,(LPARAM) pPageInfo);
        
            if(!gpWizardState->cmnStateData.bOEMCustom)
            {
                if (!bKilledSysmenu )
                {
                    HWND hWnd = GetParent(hDlg);
                    RECT rect;
                    
                    //Get our current pos and width etc.
                    GetWindowRect(hWnd, &rect);
                    
                    //Let's get centred
                    MoveWindow(hWnd,
                               (GetSystemMetrics(SM_CXSCREEN) - (rect.right  - rect.left )) / 2, //int X,
                               (GetSystemMetrics(SM_CYSCREEN) - (rect.bottom - rect.top  )) / 2, //int Y,
                               rect.right  - rect.left,                                          //width 
                               rect.bottom - rect.top,                                           // height
                               TRUE);
        
                    // Get the main frame window's style
                    LONG window_style = GetWindowLong(GetParent(hDlg), GWL_EXSTYLE);

                    //Remove the system menu from the window's style
                    window_style &= ~WS_EX_CONTEXTHELP;

                    //set the style attribute of the main frame window
                    SetWindowLong(GetParent(hDlg), GWL_EXSTYLE, window_style);

                    bKilledSysmenu = TRUE;
                }
            }
            else
            {
                 // Parent should control us, so the user can tab out of our property sheet
                DWORD dwStyle = GetWindowLong(hDlg, GWL_EXSTYLE);
                dwStyle = dwStyle | WS_EX_CONTROLPARENT;
                SetWindowLong(hDlg, GWL_EXSTYLE, dwStyle);
            }
            
            // initialize 'back' and 'next' wizard buttons, if
            // page wants something different it can fix in init proc below
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);

            // Make the title text bold
            MakeWizard97Title(GetDlgItem(hDlg,IDC_LBLTITLE));

            // call init proc for this page if one is specified
            if (pPageInfo->InitProc)
            {
                if (!( pPageInfo->InitProc(hDlg,TRUE, NULL)))
                {
                    // If a fatal error occured, quit the wizard.
                    // Note: gfQuitWizard is also used to terminate the wizard
                    // for non-error reasons, but in that case TRUE is returned
                    // from the OK proc and the case is handled below.
                    if (gfQuitWizard)
                    {
                        // Don't reboot if error occured.
                        gpWizardState->fNeedReboot = FALSE;

                        // send a 'cancel' message to ourselves (to keep the prop.
                        // page mgr happy)
                        //
                        // ...Unless we're serving as an Apprentice.  In which case, let
                        // the Wizard decide how to deal with this.

                        PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                    }                      
                }
            }

            // 11/25/96    jmazner Normandy #10586 (copied from icwconn1)
            // Before we return, lets send another message to ourself so
            // we have a second chance of initializing stuff that the 
            // property sheet wizard doesn't normally let us do.
            PostMessage(hDlg, WM_MYINITDIALOG, 1, lParam);


            return TRUE;
        }
        break;  // WM_INITDIALOG

        // 11/25/96    jmazner Normandy #10586 (copied from icwconn1)
        case WM_MYINITDIALOG:
        {
            PAGEINFO * pPageInfo = (PAGEINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
            ASSERT(pPageInfo);
            
            if (pPageInfo->PostInitProc)
            {
                if (!( pPageInfo->PostInitProc(hDlg, (BOOL)wParam, NULL)))
                {
                    // If a fatal error occured, quit the wizard.
                    // Note: gfQuitWizard is also used to terminate the wizard
                    // for non-error reasons, but in that case TRUE is returned
                    // from the OK proc and the case is handled below.
                    if (gfQuitWizard)
                    {
                        // Don't reboot if error occured.
                        gpWizardState->fNeedReboot = FALSE;

                        // send a 'cancel' message to ourselves (to keep the prop.
                        // page mgr happy)
                        //
                        // ...Unless we're serving as an Apprentice.  In which case, let
                        // the Wizard decide how to deal with this.

                        PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                    }                      
                }
            }
            
            // wParam tells whether this is the first initialization or not
            MiscInitProc(hDlg, (BOOL)wParam, pPageInfo->uDlgID);
            return TRUE;
        }


        case WM_DESTROY:
            ReleaseBold(GetDlgItem(hDlg,IDC_LBLTITLE));
            // 12/18/96 jmazner Normandy #12923
            // bKilledSysmenu is static, so even if the window is killed and reopened later
            // (as happens when user starts in conn1, goes into man path, backs up
            //  to conn1, and then returns to man path), the value of bKilledSysmenu is preserved.
            // So when the window is about to die, set it to FALSE, so that on the next window
            // init we go through and kill the sysmenu again.
            bKilledSysmenu = FALSE;
            break;

#ifdef HAS_HELP
        case WM_HELP:
        {
            DWORD dwData = 1000;

            WinHelp(hDlg,"connect.hlp>proc4",HELP_CONTEXT, dwData);
            break;
        }
#endif
        
        case WM_NOTIFY:
        {
            BOOL fRet,fKeepHistory=TRUE;
            NMHDR * lpnm = (NMHDR *) lParam;
#define NEXTPAGEUNITIALIZED -1
            int iNextPage = NEXTPAGEUNITIALIZED;
            switch (lpnm->code) 
            {
                case PSN_TRANSLATEACCELERATOR:    
                {
                    if (pPageInfo->bIsHostingWebOC)
                    {                    
                        //SUCEEDED macro will not work here cuz ret maybe S_FALSE
                        if (S_OK == gpWizardState->pICWWebView->HandleKey((LPMSG)((PSHNOTIFY*)lParam)->lParam)) 
                             SetWindowLongPtr(hDlg,DWLP_MSGRESULT, PSNRET_MESSAGEHANDLED);
                        else
                             SetWindowLongPtr(hDlg,DWLP_MSGRESULT, PSNRET_NOERROR);
                    }
                    else if (((IDD_PAGE_END == pPageInfo->uDlgID) ||
                              (IDD_PAGE_ENDOEMCUSTOM == pPageInfo->uDlgID))
                               && !g_bAllowCancel)
                    {
                        //needed to disable Alt-F4 
                        LPMSG lpMsg = (LPMSG)((PSHNOTIFY*)lParam)->lParam;

                        if ((WM_SYSKEYDOWN == lpMsg->message) && (lpMsg->wParam == VK_F4))
                        {
                            SetWindowLongPtr(hDlg,DWLP_MSGRESULT, PSNRET_MESSAGEHANDLED);
                        }
                    }
                    return TRUE;
                }    
                case PSN_SETACTIVE:
                    // If a fatal error occured in first call to init proc
                    // from WM_INITDIALOG, don't call init proc again.
                    if (FALSE == gfQuitWizard)
                    {
                        // For modeless operation, we are suppressing the painting
                        // of the wizard page background to get the effect of
                        // transparency, so we need to for an update of the 
                        // app's client area after hiding the current page.
                        if(gpWizardState->cmnStateData.bOEMCustom)
                        {
                            // Set the position of the page that is being activated
                            SetWindowPos(hDlg, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
                            
                            // Set the page title
                            if (pPageInfo->nIdTitle)
                            {
                                SendMessage(gpWizardState->cmnStateData.hWndApp, WUM_SETTITLE, (WPARAM)g_hInstance, MAKELONG(pPageInfo->nIdTitle, 0));
                            }
                        }    
                    
                        // initialize 'back' and 'next' wizard buttons, if
                        // page wants something different it can fix in init proc below
                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);

                        // call init proc for this page if one is specified
                        if (pPageInfo->InitProc)
                        {
                            pPageInfo->InitProc(hDlg,FALSE, (UINT*)&iNextPage);
                            // See if the init proc want to skip this step
                            if (NEXTPAGEUNITIALIZED != iNextPage)
                            {
                                // Skipping
                                SetPropSheetResult(hDlg,GetDlgIDFromIndex(iNextPage));
                                return (iNextPage);
                            }
                        }
                    }

                    // If we set the wait cursor, set the cursor back
                    if (hcurOld)
                    {
                        SetCursor(hcurOld);
                        hcurOld = NULL;
                    }

                    PostMessage(hDlg, WM_MYINITDIALOG, 0, lParam);


                    return TRUE;
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:

                    if(lpnm->code == PSN_WIZFINISH)
                    {
                         // Set the welcome state
                        UpdateWelcomeRegSetting(TRUE);
            
                        // Restore the desktop
                        UndoDesktopChanges(g_hInstance);            
                    }
                    
                    // Change cursor to an hour glass
                    hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

                    // call OK proc for this page if one is specified
                    if (pPageInfo->OKProc) 
                    {
                        if (!pPageInfo->OKProc(hDlg,(lpnm->code != PSN_WIZBACK), (UINT*)&iNextPage,&fKeepHistory))
                        {
                            // If a fatal error occured, quit the wizard.
                            // Note: gfQuitWizard is also used to terminate the wizard
                            // for non-error reasons, but in that case TRUE is returned
                            // from the OK proc and the case is handled below.
                            if (gfQuitWizard)
                            {
                                // Don't reboot if error occured.
                                gpWizardState->fNeedReboot = FALSE;
                
                                // send a 'cancel' message to ourselves (to keep the prop.
                                // page mgr happy)
                                //
                                // ...Unless we're serving as an Apprentice.  In which case, let
                                // the Wizard decide how to deal with this.

                                PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                            }
                            
                            // stay on this page
                            SetPropSheetResult(hDlg,-1);
                            return TRUE;
                        }
                    }
                    
                    if (lpnm->code != PSN_WIZBACK) 
                    {
                        // 'next' pressed
                        ASSERT(gpWizardState->uPagesCompleted < EXE_NUM_WIZARD_PAGES);

                        // save the current page index in the page history,
                        // unless this page told us not to when we called
                        // its OK proc above
                        if (fKeepHistory) 
                        {
                            gpWizardState->uPageHistory[gpWizardState->uPagesCompleted] = gpWizardState->uCurrentPage;
                            TraceMsg(TF_GENDLG, TEXT("GENDLG: added page %d (IDD %d) to history list"),
                                    gpWizardState->uCurrentPage, GetDlgIDFromIndex(gpWizardState->uCurrentPage));
                            gpWizardState->uPagesCompleted++;
                        }
                        else
                        {
                            TraceMsg(TF_GENDLG, TEXT("GENDLG: not adding %d (IDD: %d) to the history list"),
                            gpWizardState->uCurrentPage, GetDlgIDFromIndex(gpWizardState->uCurrentPage));
                        }


                        // if no next page specified or no OK proc,
                        // advance page by one
                        if (0 > iNextPage)
                            iNextPage = gpWizardState->uCurrentPage + 1;

                    }
                    else
                    {
                        // 'back' pressed
//                        switch( gpWizardState->uCurrentPage )
//                        {
//                        }

                        if( NEXTPAGEUNITIALIZED == iNextPage )
                        {
                            if (gpWizardState->uPagesCompleted > 0)
                            {
                                // get the last page from the history list
                                gpWizardState->uPagesCompleted --;
                                iNextPage = gpWizardState->uPageHistory[gpWizardState->uPagesCompleted];
                                TraceMsg(TF_GENDLG, TEXT("GENDLG:  extracting page %d (IDD %d) from history list"),iNextPage, GetDlgIDFromIndex(iNextPage));
                            }
                            else
                            {
                                ASSERT(0);
                                // This is bad, the history list position pointer indicates that
                                // there are no pages in the history, so we should probably
                                // just stay right were we are.
                                iNextPage = gpWizardState->uCurrentPage;
                                
                            }                                
                        }
#if 0  // We shouldn't be depend on this piece of code, as we should always use History.      
                        else
                        {
                            // The OK proc has specified a specific page to goto so lets see if it
                            // is in the history stack, otherwise we we want to back the stack up
                            // anyways
                            while (gpWizardState->uPagesCompleted  > 0)
                            {
                                --gpWizardState->uPagesCompleted;
                                if (iNextPage == (int)gpWizardState->uPageHistory[gpWizardState->uPagesCompleted])
                                    break;
                            }                                    
                        }
#endif
                    }

                    // if we need to exit the wizard now (e.g. launching
                    // signup app and want to terminate the wizard), send
                    // a 'cancel' message to ourselves (to keep the prop.
                    // page mgr happy)
                    if (gfQuitWizard) 
                    {
       
                        //
                        // if we are going from manual to conn1 then
                        // then do not show the  REBOOT dialog but
                        // still preserve the gpWizardState -MKarki Bug #404
                        //
                        if (lpnm->code ==  PSN_WIZBACK)
                        {
                            gfBackedUp = TRUE;
                            gfReboot = gpWizardState->fNeedReboot;
                        }

                        // send a 'cancel' message to ourselves (to keep the prop.
                        // page mgr happy)
                        //
                        // ...Unless we're serving as an Apprentice.  In which case, let
                        // the Wizard decide how to deal with this.

                        PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                        SetPropSheetResult(hDlg,-1);
                        return TRUE;
                    }

                    // set next page, only if 'next' or 'back' button
                    // was pressed
                    if (lpnm->code != PSN_WIZFINISH) 
                    {

                        // set the next current page index
                        gpWizardState->uCurrentPage = iNextPage;
                        TraceMsg(TF_GENDLG, TEXT("GENDLG: going to page %d (IDD %d)"), iNextPage, GetDlgIDFromIndex(iNextPage));

                        // tell the prop sheet mgr what the next page to
                        // display is
                        SetPropSheetResult(hDlg,GetDlgIDFromIndex(iNextPage));
                        return TRUE;
                    }
                    break;

                case PSN_QUERYCANCEL:
                {
                    // if global flag to exit is set, then this cancel
                    // is us pretending to push 'cancel' so prop page mgr
                    // will kill the wizard.  Let this through...
                    if (gfQuitWizard) 
                    {
                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT,FALSE);
                        return TRUE;
                    }
#ifndef ICWDEBUG 
                    //Dialing is a super special case cuz we wanna skip all the UI and 
                    //go striaght to a dialing error page
                    if (gpWizardState->uCurrentPage == ORD_PAGE_REFSERVDIAL)
                    {
                        // if this page has a special cancel proc, call it
                        if (pPageInfo->CancelProc)
                            SetWindowLongPtr(hDlg,DWLP_MSGRESULT,pPageInfo->CancelProc(hDlg));
                    }
                    else
                    {
#endif  //ICWDEBUG
                        // default behavior: pop up a message box confirming
                        // the cancel...
                        // ... unless we're serving as an Apprentice, in which case
                        // we should let the Wizard handle things
                        // Display a dialog and allow the user to select modem

#ifndef ICWDEBUG 
                        
                        if ((gpWizardState->uCurrentPage == ORD_PAGE_INTRO) && !GetCompletedBit())
                        {
                            fRet=(BOOL)DialogBoxParam(g_hInstance,MAKEINTRESOURCE(IDD_QUIT),hDlg, CancelCmdProc,0);
                        }
                        else
#endif  //ICWDEBUG
                        fRet = (MsgBox(hDlg,IDS_QUERYCANCEL,
                                           MB_ICONQUESTION,MB_YESNO |
                                           MB_DEFBUTTON2) == IDYES);                       
                        gfUserCancelled = fRet;
                        if(gfUserCancelled)
                        {
                            // if this page has a special cancel proc, call it
                            if (pPageInfo->CancelProc)
                                fRet = pPageInfo->CancelProc(hDlg);
                            if (gpWizardState->pTapiLocationInfo && (gpWizardState->lLocationID != gpWizardState->lDefaultLocationID))
                            {
                                gpWizardState->pTapiLocationInfo->put_LocationId(gpWizardState->lDefaultLocationID);
                            }
                        }

                        // don't reboot if cancelling
                        gpWizardState->fNeedReboot = FALSE;

                        // return the value thru window data
                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT,!fRet);
#ifndef ICWDEBUG   
                    }
#endif  //ICWDEBUG
                 
                    return TRUE;
                    break;
                }
                default:
                {
                    // See if the page has a notify proc
                    if (pPageInfo->NotifyProc) 
                    {
                        pPageInfo->NotifyProc(hDlg,wParam,lParam);
                    }
                    break; 
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            // if this page has a command handler proc, call it
            if (pPageInfo->CmdProc) 
            {
                pPageInfo->CmdProc(hDlg, wParam, lParam);
            }
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\icwextsn.h ===
#include "icwconn.h"
#include "icwacct.h"

extern  UINT                g_uICWCONNUIFirst, g_uICWCONNUILast;

#ifndef EXTERNAL_DIALOGID_MAXIMUM
#define EXTERNAL_DIALOGID_MAXIMUM 3000
#endif
#ifndef EXTERNAL_DIALOGID_MINIMUM
#define EXTERNAL_DIALOGID_MINIMUM 2000
#endif

class CICWExtension : public IICW50Extension
{
    public:
        virtual BOOL    STDMETHODCALLTYPE AddExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID);
        virtual BOOL    STDMETHODCALLTYPE RemoveExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID);
        virtual BOOL    STDMETHODCALLTYPE ExternalCancel(CANCELTYPE type);
        virtual BOOL    STDMETHODCALLTYPE SetFirstLastPage(UINT uFirstPageDlgID, UINT uLastPageDlgID);
        virtual HWND    STDMETHODCALLTYPE GetWizardHwnd(void)
        {
            return m_hWizardHWND;
        };            
        
        virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID theGUID, void** retPtr );
        virtual ULONG   STDMETHODCALLTYPE AddRef( void );
        virtual ULONG   STDMETHODCALLTYPE Release( void );

        CICWExtension( void );
        ~CICWExtension( void );

        HWND m_hWizardHWND;

    private:
        LONG    m_lRefCount;
};

// This _has_ to be a pointer -- if you just instantiate directly, the compiler doesn't
// correctly fill in the vtable, and thus it can't be treated as an IICWExtension pointer.
extern CICWExtension        *g_pCICWExtension;
extern CICWExtension        *g_pCINETCFGExtension;
extern IICW50Apprentice     *gpICWCONNApprentice;
extern IICWApprenticeEx     *gpINETCFGApprentice;

extern BOOL LoadICWCONNUI( HWND hWizHWND, UINT uPrevDlgID, UINT uNextDlgID, DWORD dwFlags );
extern BOOL LoadInetCfgUI( HWND hWizHWND, UINT uPrevDlgID, UINT uNextDlgID, DWORD dwFlags );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\icwconn1.cpp ===
//**********************************************************************
// File name: connwiz.cpp
//
//      Main source file for the Internet Connection Wizard '98
//
// Functions:
//
//      WinMain         - Program entry point
//
// Copyright (c) 1992 - 1998 Microsoft Corporation. All rights reserved.
//**********************************************************************
 
#include "pre.h"
#include "icwextsn.h"
#ifndef ICWDEBUG
#include "tutor.h"
#endif //ICWDEBUG
#include "iimgctx.h"
#include "icwcfg.h"
#include <stdio.h>
#include "tchar.h"
#include <netcon.h>

// External functions
#ifdef DEBUG
extern void DoDesktopChanges(HINSTANCE hAppInst);
#endif //DEBUG

extern void UpdateDesktop(HINSTANCE hAppInst);
extern void UpdateWelcomeRegSetting(BOOL bSetBit);
extern void UndoDesktopChanges(HINSTANCE   hAppInst);
extern BOOL WasNotUpgrade();
extern INT_PTR CALLBACK GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

extern BOOL SuperClassICWControls(void);
extern BOOL RemoveICWControlsSuperClass(void);
extern BOOL IsNT5();
extern BOOL IsNT();
extern BOOL IsWhistler();

// local function prototypes
BOOL AllocDialogIDList( void );
BOOL DialogIDAlreadyInUse( UINT uDlgID );
BOOL SetDialogIDInUse( UINT uDlgID, BOOL fInUse );

static BOOL 
CheckOobeInfo(
    OUT    LPTSTR pszOobeSwitch,
    OUT    LPTSTR pszISPApp);

static LONG
MakeBold (
    IN HWND hwnd,
    IN BOOL fSize,
    IN LONG lfWeight);

static LONG
ReleaseBold(
    IN HWND hwnd);

static VOID 
StartNCW(
    IN LPTSTR szShellNext,
    IN LPTSTR szShellNextParams);

static VOID 
StartOOBE(
    IN LPTSTR pszCmdLine,
    IN LPTSTR pszOOBESwitch);

static VOID 
StartISPApp(
    IN LPTSTR pszISPPath,
    IN LPTSTR pszCmdLine);

static BOOL
MyExecute(
    IN LPTSTR pszCmdLine);

INT_PTR CALLBACK 
ChooseWizardDlgProc(
    IN HWND hwnd,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam);


// Return values of ChooseWizardDlgProc
#define RUNWIZARD_CANCEL      0
#define RUNWIZARD_NCW         1
#define RUNWIZARD_OOBE        2

#define ICW_CFGFLAGS_NONCW    (ICW_CFGFLAG_IEAKMODE |\
                               ICW_CFGFLAG_BRANDED |\
                               ICW_CFGFLAG_SBS |\
                               ICW_CFGFLAG_PRODCODE_FROM_CMDLINE |\
                               ICW_CFGFLAG_OEMCODE_FROM_CMDLINE |\
                               ICW_CFGFLAG_DO_NOT_OVERRIDE_ALLOFFERS)

//Branding file default names
#define BRANDING_DEFAULT_HTML                  TEXT("BRANDED.HTM")
#define BRANDING_DEFAULT_HEADER_BMP            TEXT("BRANDHDR.BMP")
#define BRANDING_DEFAULT_WATERMARK_BMP         TEXT("BRANDWTR.BMP")
#define ICW_NO_APP_TITLE                       TEXT("-1")

// Definitions for command line parameters

#define OOBE_CMD                               TEXT("/oobe")

#define PRECONFIG_CMD                          TEXT("/preconfig")
#define OFFLINE_CMD                            TEXT("/offline")
#define LOCAL_CMD                              TEXT("/local")
#define MSN_CMD                                TEXT("/xicw")

#define ICW_OOBE_TITLE                         TEXT("icwoobe.exe")
#define ICW_APP_TITLE                          TEXT("icwconn1.exe")
#define OOBE_APP_TITLE                         TEXT("msoobe.exe")
#define OOBE_MSOBMAINDLL                       TEXT("msobmain.dll")

static const TCHAR cszSignup[]                 = TEXT("Signup");
static const TCHAR cszISPSignup[]              = TEXT("ISPSignup");
static const TCHAR cszISPSignupApp[]           = TEXT("ISPSignupApp");

static const TCHAR cszOOBEINFOINI[]            = TEXT("oobeinfo.ini");
static const TCHAR cszNone[]                   = TEXT("None");
static const TCHAR cszMSN[]                    = TEXT("MSN");
static const TCHAR cszOffline[]                = TEXT("Offline");
static const TCHAR cszPreconfig[]              = TEXT("preconfig");
static const TCHAR cszLocal[]                  = TEXT("local");

//static const TCHAR cszMSNIconKey[]             = TEXT("CLSID\\{88667D10-10F0-11D0-8150-00AA00BF8457}");
static const TCHAR cszMSNIconKey[]               = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\explorer\\Desktop\\NameSpace\\{88667D10-10F0-11D0-8150-00AA00BF8457}");


#pragma data_seg(".data")

// Global state vars

#ifndef ICWDEBUG
CICWTutorApp*   g_pICWTutorApp; 
#endif  //ICWDEBUG

INT             _convert;               // For string conversion
HINSTANCE       g_hInstance;
UINT            g_uICWCONNUIFirst;
UINT            g_uICWCONNUILast; 

BOOL g_bUserIsAdmin          = FALSE;
BOOL g_bUserIsIEAKRestricted = FALSE;
BOOL g_bRetProcessCmdLine    = FALSE;
BOOL g_OEMOOBE               = FALSE;

const TCHAR c_szOEMCustomizationDir[]  = TEXT("ICW");
const TCHAR c_szOEMCustomizationFile[] = TEXT("OEMCUST.INI");
CICWApp         *g_pICWApp = NULL;
WNDPROC         g_lpfnOldWndProc = NULL;

WIZARDSTATE*    gpWizardState        = NULL;   // pointer to global wizard state struct
CICWExtension*  g_pCICWExtension     = NULL;
CICWExtension*  g_pCINETCFGExtension = NULL;       
DWORD*          g_pdwDialogIDList    = NULL;
HANDLE          g_hMapping           = NULL;
DWORD           g_dwDialogIDListSize = 0;
BOOL            g_bRunDefaultHtm     = FALSE;  //BOOL the will force IE to launch even though shell next is NULL
BOOL            g_fICWCONNUILoaded   = FALSE;
BOOL            g_fINETCFGLoaded     = FALSE;
BOOL            g_bHelpShown         = FALSE;
BOOL            gfQuitWizard         = FALSE;  // global flag used to signal that we want to terminate the wizard ourselves
BOOL            gfUserCancelled      = FALSE;  // global flag used to signal that the user cancelled
BOOL            gfUserBackedOut      = FALSE;  // global flag used to signal that the user pressed Back on the first page
BOOL            gfUserFinished       = FALSE;  // global flag used to signal that the user pressed Finish on the final page
BOOL            gfBackedUp           = FALSE;  // Added to preserve the REBOOT state from conn1 -> manual and manual -> conn1 - MKarki
BOOL            gfReboot             = FALSE;  // DJM BUGBUG:  We should only need 1 of these
BOOL            g_bReboot            = FALSE;
BOOL            g_bRunOnce           = FALSE;
BOOL            g_bShortcutEntry     = FALSE;
BOOL            g_bNewIspPath        = TRUE;
BOOL            g_bSkipIntro         = FALSE;
BOOL            g_bAutoConfigPath    = FALSE;
BOOL            g_bManualPath        = FALSE;
BOOL            g_bLanPath           = FALSE;
BOOL            g_bAllowCancel       = FALSE;
TCHAR*          g_pszCmdLine         = NULL;
BOOL            g_bDebugOEMCustomization = FALSE;

//
// Table of data for each wizard page
//
// This includes the dialog template ID and pointers to functions for
// each page.  Pages need only provide pointers to functions when they
// want non-default behavior for a certain action (init,next/back,cancel,
// dlg ctrl).
//

#ifdef ICWDEBUG 
PAGEINFO PageInfo[EXE_NUM_WIZARD_PAGES] =
{
    { IDD_ICWDEBUG_OFFER,    FALSE, DebugOfferInitProc,    NULL, DebugOfferOKProc,    DebugOfferCmdProc,    NULL, DebugOfferNotifyProc, IDS_ICWDEBUG_OFFER_TITLE,    0, 0, NULL, NULL},
    { IDD_ICWDEBUG_SETTINGS, FALSE, DebugSettingsInitProc, NULL, DebugSettingsOKProc, DebugSettingsCmdProc, NULL, NULL,                 IDS_ICWDEBUG_SETTINGS_TITLE, 0, 0, NULL, NULL},
    { IDD_PAGE_END,          FALSE, EndInitProc,           NULL, EndOKProc,           NULL,                 NULL, NULL,                 0,                           0, 0, NULL, NULL}
};
#else //!def ICWDEBUG
PAGEINFO PageInfo[EXE_NUM_WIZARD_PAGES] =
{
    { IDD_PAGE_INTRO,         FALSE,   IntroInitProc,          NULL,                       IntroOKProc,            IntroCmdProc,        NULL,                    NULL, 0,                         0, 0, NULL, NULL },
    { IDD_PAGE_MANUALOPTIONS, FALSE,   ManualOptionsInitProc,  NULL,                       ManualOptionsOKProc,    ManualOptionsCmdProc,NULL,                    NULL, IDS_MANUALOPTS_TITLE,      0, 0, NULL, NULL  },
    { IDD_PAGE_AREACODE,      FALSE,   AreaCodeInitProc,       NULL,                       AreaCodeOKProc,         AreaCodeCmdProc,     NULL,                    NULL, IDS_STEP1_TITLE,           0, IDA_AREACODE, NULL, NULL  },
    { IDD_PAGE_REFSERVDIAL,   FALSE,   RefServDialInitProc,    RefServDialPostInitProc,    RefServDialOKProc,      NULL,                RefServDialCancelProc,   NULL, IDS_STEP1_TITLE,           0, 0, NULL, NULL  },
    { IDD_PAGE_END,           FALSE,   EndInitProc,            NULL,                       EndOKProc,              NULL,                NULL,                    NULL, 0,                         0, 0, NULL, NULL  },
    { IDD_PAGE_ENDOEMCUSTOM,  FALSE,   EndInitProc,            NULL,                       EndOKProc,              NULL,                NULL,                    NULL, IDS_OEMCUST_END_TITLE,     0, IDA_ENDOEMCUSTOM, NULL, NULL  },
    { IDD_PAGE_ENDOLS,        FALSE,   EndOlsInitProc,         NULL,                       NULL,                   NULL,                NULL,                    NULL, IDS_ENDOLS_TITLE,          0, 0, NULL, NULL  },
    { IDD_PAGE_DIALERROR,     FALSE,   DialErrorInitProc,      NULL,                       DialErrorOKProc,        DialErrorCmdProc,    NULL,                    NULL, IDS_DIALING_ERROR_TITLE,   0, IDA_DIALERROR, NULL, NULL  },
    { IDD_PAGE_MULTINUMBER,   FALSE,   MultiNumberInitProc,    NULL,                       MultiNumberOKProc,      NULL,                NULL,                    NULL, IDS_STEP1_TITLE,           0, 0, NULL, NULL  },
    { IDD_PAGE_SERVERROR,     FALSE,   ServErrorInitProc,      NULL,                       ServErrorOKProc,        ServErrorCmdProc,    NULL,                    NULL, IDS_SERVER_ERROR_TITLE,    0, 0, NULL, NULL  },
    { IDD_PAGE_BRANDEDINTRO,  TRUE,    BrandedIntroInitProc,   BrandedIntroPostInitProc,   BrandedIntroOKProc,     NULL,                NULL,                    NULL, 0,                         0, 0, NULL, NULL  },
    { IDD_PAGE_INTRO2,        FALSE,   IntroInitProc,          NULL,                       IntroOKProc,            NULL,                NULL,                    NULL, IDS_STEP1_TITLE,           0, IDA_INTRO2, NULL, NULL  },
    { IDD_PAGE_DEFAULT,       FALSE,   ISPErrorInitProc,       NULL,                       NULL,                   NULL,                NULL,                    NULL, NULL,                      0, 0, NULL, NULL  },
    { IDD_PAGE_SBSINTRO,      FALSE,   SbsInitProc,            NULL,                       SbsIntroOKProc,         NULL,                NULL,                    NULL, 0,                         0, 0, NULL, NULL  }
};
#endif //ICWDEBUG

// Global Command Line Parameters
TCHAR g_szOemCode         [MAX_PATH+1]              = TEXT("");
TCHAR g_szProductCode     [MAX_PATH+1]              = TEXT("");
TCHAR g_szPromoCode       [MAX_PROMO]               = TEXT("");
TCHAR g_szShellNext       [MAX_PATH+1]              = TEXT("\0nogood");
TCHAR g_szShellNextParams [MAX_PATH+1]              = TEXT("\0nogood");

// File names used for branded operation
TCHAR g_szBrandedHTML         [MAX_PATH] = TEXT("\0");
TCHAR g_szBrandedHeaderBMP    [MAX_PATH] = TEXT("\0");
TCHAR g_szBrandedWatermarkBMP [MAX_PATH] = TEXT("\0");

#pragma data_seg()

//+----------------------------------------------------------------------------
//
//    Function:    IsOemVer
//
//    Synopsis:    This function will determine if the machine is an OEM system.
//                
//    Arguments:   None
//
//    Returns:     TRUE - OEM system; FALSE - Retail Win 98 OSR
//
//    History:     3/26/99    JCohen    Created
//
//-----------------------------------------------------------------------------
typedef BOOL (WINAPI * ISOEMVER)();

BOOL IsOemVer()
{
    BOOL bOEMVer = FALSE;
    TCHAR       szOOBEPath [MAX_PATH]       = TEXT("\0");
    TCHAR       szOOBEDir [MAX_PATH]        = TEXT("\0");
    ISOEMVER    lpfnIsOEMVer                = NULL;
    HINSTANCE   hMsobMainDLL                = NULL;


    //Try and get the path from the OEM file
    GetSystemDirectory(szOOBEPath, MAX_PATH);
    lstrcat(szOOBEPath, TEXT("\\oobe"));

    lstrcat(szOOBEPath, TEXT("\\"));

    lstrcat(szOOBEPath, OOBE_MSOBMAINDLL);

    hMsobMainDLL = LoadLibrary(szOOBEPath);

    if (hMsobMainDLL)
    {
        lpfnIsOEMVer = (ISOEMVER)GetProcAddress(hMsobMainDLL, "IsOemVer");
        if (NULL != lpfnIsOEMVer)
        {
            bOEMVer = lpfnIsOEMVer();
        }
        FreeLibrary(hMsobMainDLL);
    }

    return (bOEMVer);
}

//+----------------------------------------------------------------------------
//
//    Function:    CheckOobeInfo
//
//    Synopsis:    This function determines if the OOBE/ISP App should be run by
//                 checking %windir%\system32\oobe\oobeinfo.ini.
//                
//    Arguments:   pszOobeSwitch  - OOBE additional command line arguments
//                                  assume size is at least MAX_PATH characters
//
//                 pszISPApp      - output empty string unless ISP App is found;
//                                  assume size is at least MAX_PATH characters
//
//    Returns:     TRUE - OOBE/ISP App should run; FALSE - otherwise
//
//    History:     25/11/99    Vyung    Created
//
//-----------------------------------------------------------------------------
BOOL
CheckOobeInfo(
    OUT    LPTSTR pszOobeSwitch,
    OUT    LPTSTR pszISPApp)
{
    BOOL  bLaunchOOBE = TRUE;
    TCHAR szOOBEInfoINIFile[MAX_PATH] = TEXT("\0");
    TCHAR szISPSignup[MAX_PATH] = TEXT("\0");
    TCHAR szOOBEPath [MAX_PATH] = TEXT("\0");

    pszISPApp[0] = TEXT('\0');
    pszOobeSwitch[0] = TEXT('\0');
    
    GetSystemDirectory(szOOBEPath, MAX_PATH);
    lstrcat(szOOBEPath, TEXT("\\oobe"));
    SearchPath(szOOBEPath, cszOOBEINFOINI, NULL, MAX_PATH, szOOBEInfoINIFile, NULL);  
    GetPrivateProfileString(cszSignup,
                            cszISPSignup,
                            TEXT(""),
                            szISPSignup,
                            MAX_PATH,
                            szOOBEInfoINIFile);

    if (0 == lstrcmpi(szISPSignup, cszNone))
    {
        bLaunchOOBE = FALSE;
    }
    else if (0 == lstrcmpi(szISPSignup, cszMSN))
    {
        if (IsWhistler())
        {            
            GetPrivateProfileString(cszSignup,
                                    cszISPSignupApp,
                                    TEXT(""),
                                    pszISPApp,
                                    MAX_PATH,
                                    szOOBEInfoINIFile);

            if (pszISPApp[0] == TEXT('\0'))
            {
                lstrcpy(pszOobeSwitch, MSN_CMD);
            }
        }
        else
        {
            HKEY hKey = 0;
            RegOpenKey(HKEY_LOCAL_MACHINE,cszMSNIconKey,&hKey);
            if (hKey)
            {
                RegCloseKey(hKey);
            }
            else
            {
                bLaunchOOBE = FALSE;
            }
        }
    }
    else if (0 == lstrcmpi(szISPSignup, cszOffline))
    {
        lstrcpy(pszOobeSwitch, OFFLINE_CMD);
    }
    else if (0 == lstrcmpi(szISPSignup, cszPreconfig))
    {
        bLaunchOOBE = FALSE;
    }
    else if (0 == lstrcmpi(szISPSignup, cszLocal))
    {
        lstrcpy(pszOobeSwitch, LOCAL_CMD);
    }

    return bLaunchOOBE;    
}        


// ############################################################################
//
// 5/23/97 jmazner Olympus #4157
// Spaces are returned as a token
// modified to consider anything between paired double quotes to be a single token
// For example, the following consists of 9 tokens (4 spaces and 5 cmds)
//
//        first second "this is the third token" fourth "fifth"
//
// The quote marks are included in the returned string (pszOut)
void GetCmdLineToken(LPTSTR *ppszCmd, LPTSTR pszOut)
{
    LPTSTR  c;
    int     i = 0;
    BOOL    fInQuote = FALSE;
    
    c = *ppszCmd;

    pszOut[0] = *c;
    if (!*c) 
        return;
    if (*c == ' ') 
    {
        pszOut[1] = '\0';
        *ppszCmd = c+1;
        return;
    }
    else if( '"' == *c )
    {
        fInQuote = TRUE;
    }

NextChar:
    i++;
    c++;
    if( !*c || (!fInQuote && (*c == ' ')) )
    {
        pszOut[i] = '\0';
        *ppszCmd = c;
        return;
    }
    else if( fInQuote && (*c == '"') )
    {
        fInQuote = FALSE;
        pszOut[i] = *c;
        
        i++;
        c++;
        pszOut[i] = '\0';
        *ppszCmd = c;
        return;
    }
    else
    {
        pszOut[i] = *c;
        goto NextChar;
    }   
}

BOOL GetFilteredCmdLineToken(LPTSTR *ppszCmd, LPTSTR pszOut)
{
    if(**ppszCmd != '/')
    {
        GetCmdLineToken(ppszCmd, pszOut);
        return TRUE;
    }
    return FALSE;
}

#define INETCFG_ISSMARTSTART "IsSmartStart"
#define INETCFG_ISSMARTSTARTEX "IsSmartStartEx"
#define SMART_RUNICW TRUE
#define SMART_QUITICW FALSE


//+----------------------------------------------------------------------------
//
//    Function:    MyIsSmartStartEx
//
//    Synopsis:    This function will determine if the ICW should be run.  The
//                decision is made based on the current state of the user's machine.
//                
//    Arguments:    none
//
//    Returns:    TRUE - run ICW; FALSE - quit now
//
//    History:    25/11/97    Vyung    Created
//
//-----------------------------------------------------------------------------
BOOL MyIsSmartStartEx(LPTSTR lpszConnectionName, DWORD dwBufLen)
{
    BOOL                bRC = SMART_RUNICW;
    PFNIsSmartStart     fp = NULL;
    HINSTANCE           hInetCfg;
    
    // Load DLL and API
    hInetCfg = LoadLibrary(TEXT("inetcfg.dll"));
    if (hInetCfg)
    {
        if (NULL == lpszConnectionName)
        {
            PFNIsSmartStart   fp = NULL;
            if (fp = (PFNIsSmartStart) GetProcAddress(hInetCfg,INETCFG_ISSMARTSTART))
            {
                // Call smart start 
                bRC = (BOOL)fp();

            }
        }
        else
        {
            PFNIsSmartStartEx   fp = NULL;
            if (fp = (PFNIsSmartStartEx) GetProcAddress(hInetCfg,INETCFG_ISSMARTSTARTEX))
            {
                // Call smart start 
                bRC = (BOOL)fp(lpszConnectionName, dwBufLen);

            }
        }
        FreeLibrary(hInetCfg);    
    }
            
    return bRC;
}

// Used below to load a bitmap file
void CALLBACK ImgCtx_Callback(void* pIImgCtx,void* pfDone)
{
    ASSERT(pfDone);

    *(BOOL*)pfDone = TRUE;
    return;
}

//+----------------------------------------------------------------------------
//
// This function will load a specified branded bitmap
//
//-----------------------------------------------------------------------------

#define BRANDED_WATERMARK   1
#define BRANDED_HEADER      2

HBITMAP LoadBrandedBitmap
(
    int   iType
)
{
    HRESULT     hr;
    IImgCtx     *pIImgCtx;
    BSTR        bstrFile;
    TCHAR       szURL[INTERNET_MAX_URL_LENGTH];
    HBITMAP     hbm = NULL;
        
    // Create an ImgCtx object to load/convert the bitmap
    hr = CoCreateInstance(CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER,
                          IID_IImgCtx, (void**)&pIImgCtx);

    if (FAILED(hr))
        return NULL;

    ASSERT(pIImgCtx);

    if (iType == BRANDED_WATERMARK)
        wsprintf (szURL, TEXT("FILE://%s"), g_szBrandedWatermarkBMP);        
    else
        wsprintf (szURL, TEXT("FILE://%s"), g_szBrandedHeaderBMP);        
    
    // "Download" the image
    bstrFile = A2W(szURL);
    hr = pIImgCtx->Load(bstrFile, 0);
    if (SUCCEEDED(hr))
    {
        ULONG fState;
        SIZE  sz;

        pIImgCtx->GetStateInfo(&fState, &sz, TRUE);

        // If we are not complete, then wait for the download to complete
        if (!(fState & (IMGLOAD_COMPLETE | IMGLOAD_ERROR)))
        {
            BOOL fDone = FALSE;

            hr = pIImgCtx->SetCallback(ImgCtx_Callback, &fDone);
            if (SUCCEEDED(hr))
            {
                hr = pIImgCtx->SelectChanges(IMGCHG_COMPLETE, 0, TRUE);
                if (SUCCEEDED(hr))
                {
                    MSG msg;
                    BOOL fMsg;

                    // HACK: restrict the message pump to those messages we know that URLMON and
                    // HACK: the imageCtx stuff needs, otherwise we will be pumping messages for
                    // HACK: windows we shouldn't be pumping right now...
                    while(!fDone )
                    {
                        fMsg = PeekMessage(&msg, NULL, WM_USER + 1, WM_USER + 4, PM_REMOVE );

                        if (!fMsg)
                            fMsg = PeekMessage( &msg, NULL, WM_APP + 2, WM_APP + 2, PM_REMOVE );
                        if (!fMsg)
                        {
                            // go to sleep until we get a new message....
                            WaitMessage();
                            continue;
                        }
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }
            }
            pIImgCtx->Disconnect();
        }
        
        // Get the Final state info, incase we just had to loop above
        hr = pIImgCtx->GetStateInfo(&fState, &sz, TRUE);
        if (SUCCEEDED(hr) && (fState & IMGLOAD_COMPLETE))
        {
            // OK, create our compatible bitmap, and blt in the one just loaded
            
            HDC hdcScreen = GetDC(NULL);
            if (hdcScreen)
            {
                if (NULL != (hbm = CreateCompatibleBitmap(hdcScreen, sz.cx, sz.cy)))
                {
                    HDC hdcImgDst = CreateCompatibleDC(NULL);
                    if (hdcImgDst)
                    {
                        HGDIOBJ hbmOld = SelectObject(hdcImgDst, hbm);
                
                        hr = pIImgCtx->StretchBlt(hdcImgDst, 
                                                  0, 
                                                  0, 
                                                  sz.cx, 
                                                  sz.cy, 
                                                  0, 
                                                  0,
                                                  sz.cx, 
                                                  sz.cy, 
                                                  SRCCOPY);
                        SelectObject(hdcImgDst, hbmOld);
                        DeleteDC(hdcImgDst);
                        
                        if (FAILED(hr))
                        {
                            DeleteObject(hbm);
                            hbm = NULL;
                        }
                    }
                    else
                    {
                        DeleteObject(hbm);
                        hbm = NULL;
                    }                                                  
                }
                
                DeleteDC(hdcScreen);
            }                
        }
    }    

    pIImgCtx->Release();

    return (hbm);
}

//+----------------------------------------------------------------------------
//
// This function will check to see if OEM branding is allowed, and if so, then did the OEM provide
// the necessary branding pieces
// TRUE means the OEM wants branding AND is allowed to brand
// FALSE means no OEM branding will be done
//
//-----------------------------------------------------------------------------
BOOL bCheckForOEMBranding
(
    void
)
{
    BOOL    bRet = FALSE;
    HANDLE  hFile;
        
    // Check for required branding files.  To brand an OEM needs to supply a first
    // page HTML file, and optionally, a header bitmap, and a final page graphic (watermark)

    hFile = CreateFile((LPCTSTR)g_szBrandedHTML,
                        GENERIC_READ, 
                        FILE_SHARE_READ,
                        0, 
                        OPEN_EXISTING, 
                        0, 
                        0);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        bRet = TRUE;
        CloseHandle(hFile);
    }            
    return  bRet;
}

BOOL ValidateFile(TCHAR* pszFile)
{
    ASSERT(pszFile);
  
    DWORD dwFileType = GetFileAttributes(pszFile);

    if ((dwFileType == 0xFFFFFFFF) || (dwFileType == FILE_ATTRIBUTE_DIRECTORY))
        return FALSE;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//    Function:    SetDefaultProductCode
//
//    Arguments:    pszBuffer - buffer that will contain the default product code
//                 dwLen - size of pszBuffer
//
//    Returns:    ERROR_SUCCESS if it succeded
//
//    History:    1-20-96    ChrisK    Created
//
//-----------------------------------------------------------------------------
DWORD SetDefaultProductCode (LPTSTR pszBuffer, DWORD dwLen)
{
    DWORD dwRet = ERROR_SUCCESS, dwType = 0;
    HKEY hkey = NULL;
    Assert(pszBuffer);

    // Open key
    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE,
        TEXT("Software\\Microsoft\\Internet Connection Wizard"),&hkey);
    if (ERROR_SUCCESS != dwRet)
        goto SetDefaultProductCodeExit;

    // Read key
    dwRet = RegQueryValueEx(hkey,TEXT("Default Product Code"),NULL,
        &dwType,(LPBYTE)pszBuffer,&dwLen);
    if (ERROR_SUCCESS != dwRet)
        goto SetDefaultProductCodeExit;

SetDefaultProductCodeExit:
    if (NULL != hkey)
        RegCloseKey(hkey);
    if (ERROR_SUCCESS != dwRet)
        pszBuffer[0] = '\0';
        
    return dwRet;
}

//GetShellNext
//
// 5/21/97    jmazner    Olympus #4157
// usage: /shellnext c:\path\executeable [parameters]
// the token following nextapp will be shellExec'd at the
// end of the "current" path.  It can be anything that the shell
// knows how to handle -- an .exe, a URL, etc..  If executable
// name contains white space (eg: c:\program files\foo.exe), it
// should be wrapped in double quotes, "c:\program files\foo.exe"
// This will cause us to treat it as a single token.
//
// all consecutive subsequent tokens will
// be passed to ShellExec as the parameters until a token is
// encountered of the form /<non-slash character>.  That is to say,
// the TCHARacter combination // will be treated as an escape character
//
// this is easiest to explain by way of examples.
//
// examples of usage:
//
//    icwconn1.exe /shellnext "C:\prog files\wordpad.exe" file.txt
//    icwconn1.exe /prod IE /shellnext msimn.exe /promo MCI
//  icwconn1.exe /shellnext msimn.exe //START_MAIL /promo MCI
//
// the executeable string and parameter string are limited to
// a length of MAX_PATH
//
void GetShellNextToken(LPTSTR szOut, LPTSTR szCmdLine)
{
    if (lstrcmpi(szOut,SHELLNEXT_CMD)==0)
    {
        // next token is expected to be white space
        GetCmdLineToken(&szCmdLine,szOut);

        if (szOut[0])
        {
            ZeroMemory(g_szShellNext,sizeof(g_szShellNext));
            ZeroMemory(g_szShellNextParams,sizeof(g_szShellNextParams));

            //this should be the thing to ShellExec
            if(GetFilteredCmdLineToken(&szCmdLine,szOut))
            {
                // watch closely, this gets a bit tricky
                //
                // if this command begins with a double quote, assume it ends
                // in a matching quote.  We do _not_ want to store the
                // quotes, however, since ShellExec doesn't parse them out.
                if( '"' != szOut[0] )
                {
                    // no need to worry about any of this quote business
                    lstrcpy( g_szShellNext, szOut );
                }
                else
                {
                    lstrcpy( g_szShellNext, &szOut[1] );
                    g_szShellNext[lstrlen(g_szShellNext) - 1] = '\0';
                }

                // now read in everything up to the next command line switch
                // and consider it to be the parameter.  Treat the sequence
                // "//" as an escape sequence, and allow it through.
                // Example:
                //        the token /whatever is considered to be a switch to
                //        icwconn1, and thus will break us out of the whle loop.
                //
                //        the token //something is should be interpreted as a
                //        command line /something to the the ShellNext app, and
                //        should not break us out of the while loop.
                GetCmdLineToken(&szCmdLine,szOut);
                while( szOut[0] )
                {
                    if( '/' == szOut[0] )
                    {
                        if( '/' != szOut[1] )
                        {
                            // it's not an escape sequence, so we're done
                            break;
                        }
                        else
                        {
                            // it is an escape sequence, so store it in
                            // the parameter list, but remove the first /
                            lstrcat( g_szShellNextParams, &szOut[1] );
                        }
                    }
                    else
                    {
                        lstrcat( g_szShellNextParams, szOut );
                    }
    
                    GetCmdLineToken(&szCmdLine,szOut);
                }
            }
        }
    }
}

// Process the incomming command line
BOOL  ProcessCommandLine
(
    HINSTANCE   hInstance,
    LPTSTR       szCmdLine
)
{
    TCHAR szOut[MAX_PATH];    
    BOOL  bOOBESwitch = FALSE;
    
    // Get the first token
    GetCmdLineToken(&szCmdLine,szOut);
    while (szOut[0])
    {
        if (g_OEMOOBE)
        {
            if((0 == lstrcmpi(szOut, OOBE_CMD)) ||
               (0 == lstrcmpi(szOut, SHELLNEXT_CMD)))
            {
                bOOBESwitch = TRUE;
                break; // Stop processing command line, launch oobe
            }
        }

        if (lstrcmpi(&szOut[0],OEMCODE_CMD)==0)
        {
            GetCmdLineToken(&szCmdLine,szOut);
            if (szOut[0])
            {
                ZeroMemory(g_szOemCode,sizeof(g_szOemCode));
                if(GetFilteredCmdLineToken(&szCmdLine,g_szOemCode))
                    gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_OEMCODE_FROM_CMDLINE;
            }
        }

        if (lstrcmpi(&szOut[0],PRODCODE_CMD)==0)
        {
            GetCmdLineToken(&szCmdLine,szOut);
            if (szOut[0])
            {
                ZeroMemory(g_szProductCode,sizeof(g_szProductCode));
                if(GetFilteredCmdLineToken(&szCmdLine,g_szProductCode))
                {
                    gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_PRODCODE_FROM_CMDLINE;

                    //Is it for sbs???
                    if (!lstrcmpi(g_szProductCode, PRODCODE_SBS))
                        gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_SBS;
                }
            }
        }

        if (0 == lstrcmpi(szOut,PROMO_CMD))
        {
            GetCmdLineToken(&szCmdLine,szOut);
            if (szOut[0])
            {
                ZeroMemory(g_szPromoCode,sizeof(g_szPromoCode));
                if(GetFilteredCmdLineToken(&szCmdLine,g_szPromoCode))
                    gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_PROMOCODE_FROM_CMDLINE;
            }
        }

        if (0 == lstrcmpi(szOut,SKIPINTRO_CMD))
        {
            g_bSkipIntro = TRUE;
        }

        if (0 == lstrcmpi(szOut,SMARTREBOOT_CMD))
        {
            GetCmdLineToken(&szCmdLine,szOut);
            if (GetFilteredCmdLineToken(&szCmdLine,szOut))
            {            
                g_bNewIspPath = FALSE;
            
                if (0 == lstrcmpi(szOut, NEWISP_SR))
                    g_bNewIspPath = TRUE;
            
                if (0 == lstrcmpi(szOut, AUTO_SR))
                    g_bAutoConfigPath = TRUE;
            
                if (0 == lstrcmpi(szOut, MANUAL_SR))
                    g_bManualPath = TRUE;

                if (0 == lstrcmpi(szOut, LAN_SR))
                    g_bLanPath = TRUE;
            }
        }

        //
        // Check for the smart start command line switch
        //
        if (0 == lstrcmpi(szOut,SMARTSTART_CMD))
        {
            //
            // If we shouldn't be running, quit.
            //
            if (SMART_QUITICW == MyIsSmartStartEx(NULL, 0))
            {
                // Set completed key if SmartStart is already configured
                SetICWComplete();
                // Set the welcome show bit
                UpdateWelcomeRegSetting(TRUE);
                
                return FALSE;       // Bail out of ICWCONN1.EXE
            }
        }

        //
        // 5/21/97    jmazner    Olympus #4157
        // usage: /shellnext c:\path\executeable [parameters]
        // the token following nextapp will be shellExec'd at the
        // end of the "current" path.  It can be anything that the shell
        // knows how to handle -- an .exe, a URL, etc..  If executable
        // name contains white space (eg: c:\program files\foo.exe), it
        // should be wrapped in double quotes, "c:\program files\foo.exe"
        // This will cause us to treat it as a single token.
        //
        // all consecutive subsequent tokens will
        // be passed to ShellExec as the parameters until a token is
        // encountered of the form /<non-slash character>.  That is to say,
        // the TCHARacter combination // will be treated as an escape character
        //
        // this is easiest to explain by way of examples.
        //
        // examples of usage:
        //
        //    icwconn1.exe /shellnext "C:\prog files\wordpad.exe" file.txt
        //    icwconn1.exe /prod IE /shellnext msimn.exe /promo MCI
        //  icwconn1.exe /shellnext msimn.exe //START_MAIL /promo MCI
        //
        // the executeable string and parameter string are limited to
        // a length of MAX_PATH
        //
        GetShellNextToken(szOut, szCmdLine);

#ifdef DEBUG
        if (lstrcmpi(szOut, ICON_CMD)==0)
        {
            DoDesktopChanges(hInstance);
            return(FALSE);
        }
#endif //DEBUG

        // If there is a /desktop command line arg, then do the
        // processing and bail
        if (lstrcmpi(szOut, UPDATEDESKTOP_CMD)==0)
        {
            if(g_bUserIsAdmin && !g_bUserIsIEAKRestricted)
               UpdateDesktop(hInstance);
           
            return(FALSE);
        }
       
        // If there is a /restoredesktop command line arg, then do the
        // processing and bail
        if (lstrcmpi(szOut, RESTOREDESKTOP_CMD)==0)
        {
            UndoDesktopChanges(hInstance);
            return(FALSE);
        }

        //Do we need to go into IEAK mode?        
        if (lstrcmpi(szOut, ICW_IEAK_CMD)==0)
        {   
            TCHAR szIEAKFlag      [2]          = TEXT("\0");
            TCHAR szIEAKStr       [MAX_PATH*2] = TEXT("\0");
            TCHAR szBrandHTML     [MAX_PATH*2] = TEXT("\0");
            TCHAR szBrandHeadBMP  [MAX_PATH*2] = TEXT("\0");
            TCHAR szBrandWaterBMP [MAX_PATH*2] = TEXT("\0");
            TCHAR szIEAKBillHtm   [MAX_PATH*2] = TEXT("\0");
            TCHAR szIEAKPayCsv    [MAX_PATH*2] = TEXT("\0");
            TCHAR szDefIspName    [MAX_PATH]   = TEXT("\0");
            TCHAR szDrive         [_MAX_DRIVE] = TEXT("\0");
            TCHAR szDir           [_MAX_DIR]   = TEXT("\0");
            TCHAR szDefaultTitle  [MAX_PATH*2] = TEXT("\0");

            gpWizardState->cmnStateData.lpfnConfigSys = &ConfigureSystem;

            GetCmdLineToken(&szCmdLine,szOut); //get rid of the space
            if(GetFilteredCmdLineToken(&szCmdLine,szOut))
            {
                //Get the path to the isp file
                lstrcpyn(gpWizardState->cmnStateData.ispInfo.szISPFile,
                         szOut + 1, 
                         lstrlen(szOut) -1);
                
                 //get the branding settings as well...
                 //The HTML page
                 GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_HTML,
                                         TEXT(""), szBrandHTML,
                                         ARRAYSIZE(szBrandHTML), 
                                         gpWizardState->cmnStateData.ispInfo.szISPFile);

                 //The wizard title
                 lstrcpy(szDefaultTitle, gpWizardState->cmnStateData.szWizTitle);

                 GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_TITLE, szDefaultTitle, 
                                         gpWizardState->cmnStateData.szWizTitle, ARRAYSIZE(gpWizardState->cmnStateData.szWizTitle), 
                                         gpWizardState->cmnStateData.ispInfo.szISPFile);

                 //The header bitmap
                 GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_HEADER_BMP, TEXT(""), 
                                         szBrandHeadBMP, ARRAYSIZE(szBrandHeadBMP), 
                                         gpWizardState->cmnStateData.ispInfo.szISPFile);
                 //The watermark bitmap
                 GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_WATERMARK_BMP, TEXT(""), 
                                         szBrandWaterBMP, ARRAYSIZE(szBrandWaterBMP), 
                                         gpWizardState->cmnStateData.ispInfo.szISPFile);


                _tsplitpath(gpWizardState->cmnStateData.ispInfo.szISPFile,
                           szDrive,
                           szDir, 
                           NULL, 
                           NULL);
               
                _tmakepath(g_szBrandedHTML,         szDrive, szDir, szBrandHTML,     NULL);
                _tmakepath(g_szBrandedHeaderBMP,    szDrive, szDir, szBrandHeadBMP,  NULL);
                _tmakepath(g_szBrandedWatermarkBMP, szDrive, szDir, szBrandWaterBMP, NULL);

                 //make sure file is valid if not bail
                 if (ValidateFile(g_szBrandedHTML))
                 {
                     //evertyething is cool.. let's set the right flags.
                     gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_IEAKMODE | ICW_CFGFLAG_BRANDED;
            
                    //Look in the isp file and see if they provided an ISP name to display 
                    //for dialing and whatnot
                    //If we can't find this section we'll just use a resource which says
                    //"an Internet service provider"

                    LoadString(hInstance, IDS_DEFAULT_ISPNAME, szDefIspName, ARRAYSIZE(szDefIspName));

                    GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_ISPNAME, szDefIspName, 
                                            szIEAKStr, ARRAYSIZE(szIEAKStr), 
                                            gpWizardState->cmnStateData.ispInfo.szISPFile);
            
                    if (lstrlen(szIEAKStr) == 0)
                        lstrcpy(szIEAKStr, szDefIspName);

                    lstrcpy(gpWizardState->cmnStateData.ispInfo.szISPName, szIEAKStr);

                    //Look in the isp file and see if they want UserInfo
                    //If we can't find this section it the isp file we'll assume "no". 
                    GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_USERINFO, TEXT("0"), 
                                            szIEAKFlag, ARRAYSIZE(szIEAKFlag), 
                                            gpWizardState->cmnStateData.ispInfo.szISPFile);
    
                    if ((BOOL)_ttoi(szIEAKFlag))
                    {
                        // Since we are showing the user info page, we may need to
                        // show or hide the company name
                        gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_USERINFO;
                
                       if (GetPrivateProfileInt(ICW_IEAK_SECTION, 
                                             ICW_IEAK_USECOMPANYNAME, 
                                             0, 
                                             gpWizardState->cmnStateData.ispInfo.szISPFile))
                            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_USE_COMPANYNAME;
                                     
                
                    }
                    //Look in the isp file and see if they want billing stuff
                    //If we can't find this section it the isp file we'll assume "no". 
                    GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_BILLING, TEXT("0"), 
                                            szIEAKFlag, ARRAYSIZE(szIEAKFlag), 
                                            gpWizardState->cmnStateData.ispInfo.szISPFile);

                     if ((BOOL)_ttoi(szIEAKFlag))
                     {
                         //try and get the billing page, if it's not there don't bother
                         //setting the bit.
                         GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_BILLINGHTM, NULL, 
                                                 szIEAKBillHtm, ARRAYSIZE(szIEAKBillHtm), 
                                                 gpWizardState->cmnStateData.ispInfo.szISPFile);
                
                         if(lstrlen(szIEAKBillHtm) != 0)             
                         {
                             gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_BILL;
                             lstrcpy(gpWizardState->cmnStateData.ispInfo.szBillHtm, szIEAKBillHtm);
                         }
                     }

                    //Look in the isp file and see if they want payment stuff
                    //If we can't find this section it the isp file we'll assume "no". 
                    GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_PAYMENT, NULL, 
                                            szIEAKFlag, ARRAYSIZE(szIEAKFlag), 
                                            gpWizardState->cmnStateData.ispInfo.szISPFile);

                     if ((BOOL)_ttoi(szIEAKFlag))
                     {   
                         //try and get the payment csv, if it's not there don't bother
                         //setting the bit.
                         GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_PAYMENTCSV, NULL, 
                                                 szIEAKPayCsv, ARRAYSIZE(szIEAKPayCsv), 
                                                 gpWizardState->cmnStateData.ispInfo.szISPFile);
         
                         if (lstrlen(szIEAKPayCsv) != 0)
                         {
                            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_PAYMENT;
                            lstrcpy(gpWizardState->cmnStateData.ispInfo.szPayCsv, szIEAKPayCsv);
                         }
                     }
             
                    //Get validation flags from the ISP file
                    gpWizardState->cmnStateData.ispInfo.dwValidationFlags = GetPrivateProfileInt(ICW_IEAK_SECTION, 
                                                                        ICW_IEAK_VALIDATEFLAGS, 
                                                                        0xFFFFFFFF, 
                                                                        gpWizardState->cmnStateData.ispInfo.szISPFile);
                 }
            }
        }
        
        // Check to see if we are running in Branded mode.  In this mode, we will allow special
        // OEM tweaks.
        if (lstrcmpi(szOut, BRANDED_CMD)==0)
        {
            TCHAR       szCurrentDir[MAX_PATH] = TEXT("\0");

            //whether or not the ICW "fails" to run in branding mode we do not wan to overide the alloffers value
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_DO_NOT_OVERRIDE_ALLOFFERS;

            GetCurrentDirectory(ARRAYSIZE(szCurrentDir), szCurrentDir);

            wsprintf (g_szBrandedHTML, TEXT("%s\\%s"), szCurrentDir, BRANDING_DEFAULT_HTML);        
            wsprintf (g_szBrandedHeaderBMP, TEXT("%s\\%s"), szCurrentDir, BRANDING_DEFAULT_HEADER_BMP);        
            wsprintf (g_szBrandedWatermarkBMP, TEXT("%s\\%s"), szCurrentDir, BRANDING_DEFAULT_WATERMARK_BMP);        

            // We are in OEM mode, so see if we allow branding
            if (bCheckForOEMBranding())
            {
                gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_BRANDED;
            }
        }

        // Check to see if we are running in run once mode.  In this mode, we will disallow IE check box
        if (0 == lstrcmpi(szOut, RUNONCE_CMD))
        {
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_DO_NOT_OVERRIDE_ALLOFFERS;
            g_bRunOnce = TRUE;
        }
        
        // Check to see if we were run from a shortcut on the desktop
        if (0 == lstrcmpi(szOut, SHORTCUTENTRY_CMD))
        {
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_DO_NOT_OVERRIDE_ALLOFFERS;
            g_bShortcutEntry = TRUE;
        }
        
        // Check to see if we should debug the OEMCUST.INI file
        if (0 == lstrcmpi(szOut, DEBUG_OEMCUSTOM))
        {
            g_bDebugOEMCustomization = TRUE;
        }
        
        // Eat the next token, it will be null if we are at the end
        GetCmdLineToken(&szCmdLine,szOut);
    }

    g_OEMOOBE = g_OEMOOBE && bOOBESwitch;
    gpWizardState->cmnStateData.bOEMEntryPt = g_bShortcutEntry || g_bRunOnce;
    return(TRUE);    
}

//+----------------------------------------------------------------------------
//
//    Function:    RemoveShellNextFromReg
//
//    Synopsis:    deletes the ShellNext reg key if present. This key is set by
//                SetShellNext in inetcfg.dll in conjunction with
//                CheckConnectionWizard.
//
//    Arguments:    none
//
//    Returns:    none
//
//    History:    jmazner 7/9/97 Olympus #9170
//
//-----------------------------------------------------------------------------
void RemoveShellNextFromReg( void )
{
    HKEY    hkey;
    
    if ((RegOpenKey(HKEY_CURRENT_USER, ICWSETTINGSPATH, &hkey)) == ERROR_SUCCESS)
    {
        RegDeleteValue(hkey, TEXT("ShellNext"));
        RegCloseKey(hkey);
    }        
}

//+----------------------------------------------------------------------------
//
//    Function:    GetShellNextFromReg
//
//    Synopsis:    Reads the ShellNext key from the registry, and then parses it
//                into a command and parameter.  This key is set by
//                SetShellNext in inetcfg.dll in conjunction with
//                CheckConnectionWizard.
//
//    Arguments:    none
//
//    Returns:    none
//
//    History:    jmazner 7/9/97 Olympus #9170
//
//-----------------------------------------------------------------------------
BOOL GetShellNextFromReg
( 
    LPTSTR lpszCommand, 
    LPTSTR lpszParams
)
{
    BOOL    fRet                      = TRUE;
    TCHAR   szShellNextCmd [MAX_PATH] = TEXT("\0");
    DWORD   dwShellNextSize           = sizeof(szShellNextCmd);
    LPTSTR  lpszTemp                  = NULL;
    HKEY    hkey                      = NULL;
    
    if( !lpszCommand || !lpszParams )
    {
        return FALSE;
    }

    if ((RegOpenKey(HKEY_CURRENT_USER, ICWSETTINGSPATH, &hkey)) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hkey, 
                            TEXT("ShellNext"), 
                            NULL, 
                            NULL, 
                            (BYTE *)szShellNextCmd, 
                            (DWORD *)&dwShellNextSize) != ERROR_SUCCESS)
        {
            fRet = FALSE;
            goto GetShellNextFromRegExit;
        }
    }
    else
    {
        fRet = FALSE;
        goto GetShellNextFromRegExit;
    }

    //
    // This call will parse the first token into lpszCommand, and set szShellNextCmd
    // to point to the remaining tokens (these will be the parameters).  Need to use
    // the pszTemp var because GetCmdLineToken changes the pointer's value, and we
    // need to preserve lpszShellNextCmd's value so that we can GlobalFree it later.
    //
    lpszTemp = szShellNextCmd;
    GetCmdLineToken( &lpszTemp, lpszCommand );

    lstrcpy( lpszParams, lpszTemp );

    //
    // it's possible that the shellNext command was wrapped in quotes for
    // parsing purposes.  But since ShellExec doesn't understand quotes,
    // we now need to remove them.
    //
    if( '"' == lpszCommand[0] )
    {
        //
        // get rid of the first quote
        // note that we're shifting the entire string beyond the first quote
        // plus the terminating NULL down by one byte.
        //
        memmove( lpszCommand, &(lpszCommand[1]), lstrlen(lpszCommand) );

        //
        // now get rid of the last quote
        //
        lpszCommand[lstrlen(lpszCommand) - 1] = '\0';
    }

GetShellNextFromRegExit:
    if (hkey)
        RegCloseKey(hkey);
    return fRet;
}

void StartIE
(
    LPTSTR   lpszURL
)
{
    TCHAR    szIEPath[MAX_PATH];
    HKEY    hkey;
    
    // first get the app path
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REGSTR_PATH_APPPATHS,
                     0,
                     KEY_READ,
                     &hkey) == ERROR_SUCCESS)
    {
                        
        DWORD dwTmp = sizeof(szIEPath);
        if(RegQueryValue(hkey, TEXT("iexplore.exe"), szIEPath, (PLONG)&dwTmp) != ERROR_SUCCESS)
        {
            ShellExecute(NULL,TEXT("open"),szIEPath,lpszURL,NULL,SW_NORMAL);
        }
        else
        {
            ShellExecute(NULL,TEXT("open"),TEXT("iexplore.exe"),lpszURL,NULL,SW_NORMAL);
            
        }
        RegCloseKey(hkey);
    }
    else
    {
        ShellExecute(NULL,TEXT("open"),TEXT("iexplore.exe"),lpszURL,NULL,SW_NORMAL);
    }
    
}        

void HandleShellNext
(
    void
)
{
    DWORD dwVal  = 0;
    DWORD dwSize = sizeof(dwVal);
    HKEY  hKey   = NULL;

    if(RegOpenKeyEx(HKEY_CURRENT_USER, 
                    ICWSETTINGSPATH,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey) == ERROR_SUCCESS)
    {
        RegQueryValueEx(hKey,
                    ICW_REGKEYCOMPLETED,
                    0,
                    NULL,
                    (LPBYTE)&dwVal,
                    &dwSize);

        RegCloseKey(hKey);
    }
    
    if (dwVal)
    {
        if (PathIsURL(g_szShellNext) || g_bRunDefaultHtm)
            StartIE(g_szShellNext);        
        else if(g_szShellNext[0] != '\0')
            // Let the shell deal with it
            ShellExecute(NULL,TEXT("open"),g_szShellNext,g_szShellNextParams,NULL,SW_NORMAL); 
    }
}

extern "C" void _stdcall ModuleEntry (void)
{
    int         i;
    
    g_hMapping = CreateFileMapping( INVALID_HANDLE_VALUE,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    32,
#ifdef ICWDEBUG
                                    TEXT("ICWDEBUG") );
#else
                                    TEXT("ICWCONN1") );
#endif //ICWDEBUG

    if(g_hMapping)
    {
        // See if there is allready a mapping file, if so, we have an instance 
        // already running
        if( GetLastError() == ERROR_ALREADY_EXISTS )
        {
            // Front the existing instance, and exit
            HWND  hWnd               = NULL;
            HWND  FirstChildhWnd     = NULL; 
            TCHAR szTitle[MAX_TITLE] = TEXT("\0");
    
            if (!LoadString(g_hInstance, IDS_APPNAME, szTitle, ARRAYSIZE(szTitle)))
                lstrcpy(szTitle, TEXT("Internet Connection Wizard"));

            if (hWnd = FindWindow(TEXT("#32770"), szTitle)) 
            { 
                FirstChildhWnd = GetLastActivePopup(hWnd);
                SetForegroundWindow(hWnd);         // bring main window to top

                // is a pop-up window active
                if (hWnd != FirstChildhWnd)
                    BringWindowToTop(FirstChildhWnd); 

            }
            CloseHandle(g_hMapping);
            ExitProcess(1);
        }
        else
        {
            LPTSTR      pszCmdLine = GetCommandLine();

            // We don't want the "No disk in drive X:" requesters, so we set
            // the critical error mask such that calls will just silently fail
            SetErrorMode(SEM_FAILCRITICALERRORS);

            if ( *pszCmdLine == TEXT('\"') ) 
            {
                /*
                 * Scan, and skip over, subsequent characters until
                 * another double-quote or a null is encountered.
                 */
                while ( *++pszCmdLine && (*pszCmdLine != TEXT('\"')) )
                    ;
                /*
                 * If we stopped on a double-quote (usual case), skip
                 * over it.
                 */
                if ( *pszCmdLine == TEXT('\"') )
                    pszCmdLine++;
            }
            else 
            {
                while (*pszCmdLine > TEXT(' '))
                pszCmdLine++;
            }

            /*
             * Skip past any white space preceeding the second token.
             */
            while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) 
            {
                pszCmdLine++;
            }

            // Set the current directory.
            HKEY    hkey = NULL;
            TCHAR    szAppPathKey[MAX_PATH];
            TCHAR    szICWPath[MAX_PATH];
            DWORD   dwcbPath = sizeof(szICWPath);
                    
            lstrcpy (szAppPathKey, REGSTR_PATH_APPPATHS);
            lstrcat (szAppPathKey, TEXT("\\"));
            lstrcat (szAppPathKey, TEXT("ICWCONN1.EXE"));

            if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,szAppPathKey, 0, KEY_QUERY_VALUE, &hkey)) == ERROR_SUCCESS)
            {
                if (RegQueryValueEx(hkey, TEXT("Path"), NULL, NULL, (BYTE *)szICWPath, (DWORD *)&dwcbPath) == ERROR_SUCCESS)
                {
                    // The Apppaths' have a trailing semicolon that we need to get rid of
                    // dwcbPath is the lenght of the string including the NULL terminator
                    int nSize = lstrlen(szICWPath);
                    szICWPath[nSize-1] = TEXT('\0');
                    SetCurrentDirectory(szICWPath);
                }            
            }        
            if (hkey) 
                RegCloseKey(hkey);

            i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine, SW_SHOWDEFAULT);

            // see if we need to exectute any /ShellNext dudes
            HandleShellNext();
            
            CloseHandle(g_hMapping);
       
            ExitProcess(i); // Were outa here....
        }            
    }    
    else
    {
        ExitProcess(1); 
    }
    
}   /*  ModuleEntry() */


/*******************************************************************

  NAME:    InitWizardState

  SYNOPSIS:  Initializes wizard state structure

********************************************************************/
BOOL InitWizardState(WIZARDSTATE * pWizardState)
{
    HRESULT        hr;
    
    ASSERT(pWizardState);

    // set starting page
#ifdef ICWDEBUG
	pWizardState->uCurrentPage = ORD_PAGE_ICWDEBUG_OFFER;
#else  //!def ICWDEBUG
	pWizardState->uCurrentPage = ORD_PAGE_INTRO;
#endif //ICWDEBUG
    
    pWizardState->fNeedReboot = FALSE;
    pWizardState->bDoUserPick = FALSE;
    gpWizardState->lSelectedPhoneNumber = -1;
    gpWizardState->lDefaultLocationID = -1;
    gpWizardState->lLocationID = -1;
    
#ifndef ICWDEBUG
    //init the tutor app class
    g_pICWTutorApp = new CICWTutorApp;
#endif //ICWDEBUG

    // Instansiate ICWHELP objects
    hr = CoCreateInstance(CLSID_TapiLocationInfo,NULL,CLSCTX_INPROC_SERVER,
                          IID_ITapiLocationInfo,(LPVOID *)&pWizardState->pTapiLocationInfo);
    if (FAILED(hr))
       return FALSE;                          
    hr = CoCreateInstance(CLSID_RefDial,NULL,CLSCTX_INPROC_SERVER,
                          IID_IRefDial,(LPVOID *)&pWizardState->pRefDial);
    if (FAILED(hr))
        return FALSE;                          
    hr = CoCreateInstance(CLSID_ICWSystemConfig,NULL,CLSCTX_INPROC_SERVER,
                          IID_IICWSystemConfig,(LPVOID *)&pWizardState->cmnStateData.pICWSystemConfig);
    if (FAILED(hr))
        return FALSE;                          
   
    hr = CoCreateInstance(CLSID_INSHandler,NULL,CLSCTX_INPROC_SERVER,
                          IID_IINSHandler,(LPVOID *)&pWizardState->pINSHandler);
    if (FAILED(hr))
        return FALSE;                          
   
    if ( !(SUCCEEDED(hr)                              || 
         !pWizardState->pTapiLocationInfo             ||
         !pWizardState->cmnStateData.pICWSystemConfig ||
         !pWizardState->pRefDial                      ||
         !pWizardState->pINSHandler ))
    {
        return FALSE;
    }
    
    // Need to load the UTIL lib, to register the WEBOC window class
    pWizardState->hInstUtilDLL = LoadLibrary(ICW_UTIL);

    gpWizardState->cmnStateData.lpfnCompleteOLS = &OlsFinish;
    gpWizardState->cmnStateData.bOEMOffline = FALSE;
    gpWizardState->cmnStateData.lpfnFillWindowWithAppBackground = &FillWindowWithAppBackground;
    gpWizardState->cmnStateData.ispInfo.bFailedIns = FALSE;
    
    return TRUE;
}

/*******************************************************************

  NAME:    InitWizardState

  SYNOPSIS:  Initializes wizard state structure

********************************************************************/
BOOL CleanupWizardState(WIZARDSTATE * pWizardState)
{
    ASSERT(pWizardState);
  
#ifndef ICWDEBUG    
    ASSERT(g_pICWTutorApp);

    delete g_pICWTutorApp;
#endif //ICWDEBUG

    // Clean up allocated bitmaps that might exist from the branding case
    if (gpWizardState->cmnStateData.hbmWatermark)
        DeleteObject(gpWizardState->cmnStateData.hbmWatermark);
    gpWizardState->cmnStateData.hbmWatermark = NULL;

    if (pWizardState->pTapiLocationInfo)
    {
        pWizardState->pTapiLocationInfo->Release();
        pWizardState->pTapiLocationInfo = NULL;
        
    }
    
    if (pWizardState->pRefDial)
    {
        pWizardState->pRefDial->Release();
        pWizardState->pRefDial = NULL;
    
    }

    if (pWizardState->pINSHandler)
    {
        pWizardState->pINSHandler->Release();
        pWizardState->pINSHandler = NULL;
    
    }
    
    if (pWizardState->cmnStateData.pICWSystemConfig)
    {
        pWizardState->cmnStateData.pICWSystemConfig->Release();
        pWizardState->cmnStateData.pICWSystemConfig = NULL;
    }

    if(pWizardState->pHTMLWalker)
    {
        pWizardState->pHTMLWalker->Release();
        pWizardState->pHTMLWalker = NULL;
    }

    if(pWizardState->pICWWebView)
    {
        pWizardState->pICWWebView->Release();
        pWizardState->pICWWebView = NULL;
    }
    
    if (pWizardState->hInstUtilDLL)
        FreeLibrary(pWizardState->hInstUtilDLL);
    
    //Now's a good a time as any, let's clean up the
    //download directory
    RemoveDownloadDirectory();

#ifdef ICWDEBUG
    RemoveTempOfferDirectory();
#endif

    return TRUE;
}

LRESULT FAR PASCAL WndSubClassFunc
(   
    HWND hWnd,
    WORD uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    switch (uMsg)
    {
        case WM_ERASEBKGND:
            return 1;

        case PSM_SETWIZBUTTONS:
            g_pICWApp->SetWizButtons(hWnd, lParam);
            break;
        
        case PSM_CANCELTOCLOSE:
            // Disable the cancel button.
            g_pICWApp->m_BtnCancel.Enable(FALSE);
            break;
            
            
        case PSM_SETHEADERTITLE:
            SendMessage(g_pICWApp->m_hWndApp, WUM_SETTITLE, 0, lParam);
            break;
            
        default:
            return CallWindowProc(g_lpfnOldWndProc, hWnd, uMsg, wParam, lParam);
    }   
    return TRUE;         
}

/**************************************************************************

   PropSheetCallback()

**************************************************************************/

void CALLBACK PropSheetCallback(HWND hwndPropSheet, UINT uMsg, LPARAM lParam)
{
    switch(uMsg)
    {
        //called before the dialog is created, hwndPropSheet = NULL, lParam points to dialog resource
        case PSCB_PRECREATE:
        {
            LPDLGTEMPLATE  lpTemplate = (LPDLGTEMPLATE)lParam;
            // THIS is the STYLE used for Wizards.
            // We want to nuke all of these styles to remove the border, caption,
            // etc., and make the wizard a child of the parent. We also make the
            // wizard not visible initially.  It will be make visable after
            // we get the wizard modeless handle back and do some resizing.
            //STYLE DS_MODALFRAME | DS_3DLOOK | DS_CONTEXTHELP | WS_POPUP | WS_CAPTION | WS_SYSMENU

            lpTemplate->style &= ~(WS_SYSMENU | WS_CAPTION | DS_CONTEXTHELP | DS_3DLOOK | DS_MODALFRAME | WS_POPUP | WS_VISIBLE);
            lpTemplate->style |= WS_CHILD;
    
            break;
        }

        //called after the dialog is created
        case PSCB_INITIALIZED:
            //
            // Now subclass the Wizard window AND the DLG class so all of our
            // dialog pages can be transparent
            //      
            g_lpfnOldWndProc = (WNDPROC)SetWindowLongPtr(hwndPropSheet, GWLP_WNDPROC, (DWORD_PTR)&WndSubClassFunc);
            break;
    }
}


// General ICW cleanup to be done before existing
void ICWCleanup (void)
{            
    if (gpICWCONNApprentice)
    {
        gpICWCONNApprentice->Release();
        gpICWCONNApprentice = NULL;
    }

    if (gpINETCFGApprentice)
    {
        gpINETCFGApprentice->Release();
        gpINETCFGApprentice = NULL;
    }

    if( g_pdwDialogIDList )
    {
        GlobalFree(g_pdwDialogIDList);
        g_pdwDialogIDList = NULL;
    }

    if( g_pCICWExtension )
    {
        g_pCICWExtension->Release();
        g_pCICWExtension = NULL;
    }

    if( g_pCINETCFGExtension )
    {
        g_pCINETCFGExtension->Release();
        g_pCINETCFGExtension = NULL;
    }

    CleanupWizardState(gpWizardState);
}
/*******************************************************************

  NAME:    RunSignupWizard

  SYNOPSIS:  Creates property sheet pages, initializes wizard property sheet and runs wizard

  ENTRY:    

  EXIT:     returns TRUE if user runs wizard to completion,
            FALSE if user cancels or an error occurs

  NOTES:    Wizard pages all use one dialog proc (GenDlgProc).
        They may specify their own handler procs to get called
        at init time or in response to Next, Cancel or a dialog
        control, or use the default behavior of GenDlgProc.

********************************************************************/
HWND RunSignupWizard(HWND hWndOwner)
{
    HPROPSHEETPAGE  hWizPage[EXE_NUM_WIZARD_PAGES];  // array to hold handles to pages
    PROPSHEETPAGE   psPage;    // struct used to create prop sheet pages
    PROPSHEETHEADER psHeader;  // struct used to run wizard property sheet
    UINT            nPageIndex;
    INT_PTR         iRet;
    BOOL            bUse256ColorBmp = FALSE;
    HBITMAP         hbmHeader = NULL;
    
    ASSERT(gpWizardState);   // assert that global structs have been allocated

    AllocDialogIDList();

    // Compute the color depth we are running in
    HDC hdc = GetDC(NULL);
    if(hdc)
    {
        if(GetDeviceCaps(hdc,BITSPIXEL) >= 8)
            bUse256ColorBmp = TRUE;
        ReleaseDC(NULL, hdc);
    }

    // zero out structures
    ZeroMemory(&hWizPage,sizeof(hWizPage));   // hWizPage is an array
    ZeroMemory(&psPage,sizeof(PROPSHEETPAGE));
    ZeroMemory(&psHeader,sizeof(PROPSHEETHEADER));

    // fill out common data property sheet page struct
    psPage.dwSize    = sizeof(PROPSHEETPAGE);
    psPage.hInstance = g_hInstance;
    psPage.pfnDlgProc = GenDlgProc;
    
    // create a property sheet page for each page in the wizard
    for (nPageIndex = 0;nPageIndex < EXE_NUM_WIZARD_PAGES;nPageIndex++) 
    {
        psPage.dwFlags     = PSP_DEFAULT | PSP_USETITLE;
        psPage.pszTitle    = gpWizardState->cmnStateData.szWizTitle;
        psPage.pszTemplate = MAKEINTRESOURCE(PageInfo[nPageIndex].uDlgID);
        
        // set a pointer to the PAGEINFO struct as the private data for this page
        psPage.lParam = (LPARAM) &PageInfo[nPageIndex];
        if (!gpWizardState->cmnStateData.bOEMCustom)
        {
            if (PageInfo[nPageIndex].nIdTitle)
            {
                psPage.dwFlags |= PSP_USEHEADERTITLE | (PageInfo[nPageIndex].nIdSubTitle ? PSP_USEHEADERSUBTITLE : 0);
                psPage.pszHeaderTitle = MAKEINTRESOURCE(PageInfo[nPageIndex].nIdTitle);
                psPage.pszHeaderSubTitle = MAKEINTRESOURCE(PageInfo[nPageIndex].nIdSubTitle);
            }
            else
            {
                psPage.dwFlags |= PSP_HIDEHEADER;
            }
        }
                
        hWizPage[nPageIndex] = CreatePropertySheetPage(&psPage);
        if (!hWizPage[nPageIndex]) 
        {
            ASSERT(0);

            // creating page failed, free any pages already created and bail
            MsgBox(NULL,IDS_ERR_OUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
            UINT nFreeIndex;
            for (nFreeIndex=0;nFreeIndex<nPageIndex;nFreeIndex++)
                DestroyPropertySheetPage(hWizPage[nFreeIndex]);

            iRet = 0;
            goto RunSignupWizardExit;
        }
        
        // Load the accelerator table for this page if necessary
        if (PageInfo[nPageIndex].idAccel)
            PageInfo[nPageIndex].hAccel = LoadAccelerators(g_hInstance, 
                                          MAKEINTRESOURCE(PageInfo[nPageIndex].idAccel));      
    }

    // fill out property sheet header struct
    psHeader.dwSize = sizeof(psHeader);
    if (!gpWizardState->cmnStateData.bOEMCustom)
    {
        psHeader.dwFlags = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER | PSH_STRETCHWATERMARK;
    }        
    else
    {
        psHeader.dwFlags = PSH_WIZARD | PSH_MODELESS | PSH_USECALLBACK;
        psHeader.pfnCallback = (PFNPROPSHEETCALLBACK)PropSheetCallback;
    }
    psHeader.hwndParent = hWndOwner;
    psHeader.hInstance = g_hInstance;
    psHeader.nPages = EXE_NUM_WIZARD_PAGES;
    psHeader.phpage = hWizPage;

#ifndef ICWDEBUG
    // If we are running in Modal mode, then we want to setup for
    // wizard 97 style with appropriate bitmaps
    if (!gpWizardState->cmnStateData.bOEMCustom)
    {
        if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_BRANDED)
        {
            psHeader.nStartPage = ORD_PAGE_BRANDEDINTRO;
                    
            if (NULL == (gpWizardState->cmnStateData.hbmWatermark = LoadBrandedBitmap(BRANDED_WATERMARK)))
            {
                // Use our default Watermark
                gpWizardState->cmnStateData.hbmWatermark = (HBITMAP)LoadImage(g_hInstance,
                                bUse256ColorBmp ? MAKEINTRESOURCE(IDB_WATERMARK256):MAKEINTRESOURCE(IDB_WATERMARK16),
                                IMAGE_BITMAP,
                                0,
                                0,
                                LR_CREATEDIBSECTION);
            }            
            
            if(NULL != (hbmHeader = LoadBrandedBitmap(BRANDED_HEADER)))
            {
                psHeader.hbmHeader = hbmHeader;
                psHeader.dwFlags |= PSH_USEHBMHEADER;
            }
            else
            {
                // Use our default header
                psHeader.pszbmHeader = bUse256ColorBmp?
                                     MAKEINTRESOURCE(IDB_BANNER256):
                                     MAKEINTRESOURCE(IDB_BANNER16);
            }            
            
        }            
        else // NORMAL
        {
            if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_SBS)
                psHeader.nStartPage = ORD_PAGE_SBSINTRO;
            else
                psHeader.nStartPage = ORD_PAGE_INTRO;

            // Specify wizard left graphic
            gpWizardState->cmnStateData.hbmWatermark = (HBITMAP)LoadImage(g_hInstance,
                            bUse256ColorBmp ? MAKEINTRESOURCE(IDB_WATERMARK256):MAKEINTRESOURCE(IDB_WATERMARK16),
                            IMAGE_BITMAP,
                            0,
                            0,
                            LR_CREATEDIBSECTION);

            // Specify wizard header
            psHeader.pszbmHeader = bUse256ColorBmp?MAKEINTRESOURCE(IDB_BANNER256):MAKEINTRESOURCE(IDB_BANNER16);
        }
    }    
    else
    {
        // Start page for modeless is INTRO2
        psHeader.nStartPage = ORD_PAGE_INTRO2;
    }    
    
#else  //ifdef ICWDEBUG

        psHeader.nStartPage = ORD_PAGE_ICWDEBUG_OFFER;

        // Specify wizard left graphic
        gpWizardState->cmnStateData.hbmWatermark = (HBITMAP)LoadImage(g_hInstance,
                        bUse256ColorBmp ? MAKEINTRESOURCE(IDB_WATERMARK256):MAKEINTRESOURCE(IDB_WATERMARK16),
                        IMAGE_BITMAP,
                        0,
                        0,
                        LR_CREATEDIBSECTION);
        psHeader.pszbmHeader    = bUse256ColorBmp?MAKEINTRESOURCE(IDB_BANNER256)   :MAKEINTRESOURCE(IDB_BANNER16);

#endif // ICWDEBUG
    
    
    //
    // set state of gpWizardState->fNeedReboot and
    // reset the state of Backup Flag here - MKarki Bug #404
    // 
    if (gfBackedUp == TRUE)
    {
        gpWizardState->fNeedReboot = gfReboot;
        gfBackedUp = FALSE;
    }
    
    //register the Native font control so the dialog won't fail
    INITCOMMONCONTROLSEX iccex;
    iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    iccex.dwICC  = ICC_NATIVEFNTCTL_CLASS;
    if (!InitCommonControlsEx(&iccex))
        return FALSE;

    // run the Wizard
    iRet = PropertySheet(&psHeader);
    
    // If we are doing a modless wizard, then PropertySheet will return
    // immediatly with the property sheet window handle
    if (gpWizardState->cmnStateData.bOEMCustom)
        return (HWND)iRet;
        
    if (iRet < 0) 
    {
        // property sheet failed, most likely due to lack of memory
        MsgBox(NULL,IDS_ERR_OUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
    }

RunSignupWizardExit:

    // Clean up allocated bitmaps that might exist from the branding case
    if (gpWizardState->cmnStateData.hbmWatermark)
        DeleteObject(gpWizardState->cmnStateData.hbmWatermark);
    gpWizardState->cmnStateData.hbmWatermark = NULL;
        
    if (hbmHeader)
        DeleteObject(hbmHeader);
        
    return (HWND)(iRet > 0);
}

// Convert a string color in HTML format (#RRGGBB) into a COLORREF 
COLORREF  ColorToRGB
(
    LPTSTR   lpszColor
)
{
    int r,g,b;
    
    Assert(lpszColor);
    if (lpszColor && '#' == lpszColor[0])
    {
        _stscanf(lpszColor, TEXT("#%2x%2x%2x"), &r,&g,&b);
        return RGB(r,g,b);
    }
    return RGB(0,0,0);
}

const TCHAR cszSectionGeneral[] = TEXT("General");
const TCHAR cszSectionHeader[] = TEXT("Header");
const TCHAR cszSectionDialog[] = TEXT("Dialog");
const TCHAR cszSectionBusy[] = TEXT("Busy");
const TCHAR cszSectionBack[] = TEXT("Back");
const TCHAR cszSectionNext[] = TEXT("Next");
const TCHAR cszSectionFinish[] = TEXT("Finish");
const TCHAR cszSectionCancel[] = TEXT("Cancel");
const TCHAR cszSectionTutorial[] = TEXT("Tutorial");

const TCHAR cszTitleBar[] = TEXT("TitleBar");
const TCHAR cszBackgroundBmp[] = TEXT("background");
const TCHAR cszFirstPageHTML[] = TEXT("FirstPageHTML");
const TCHAR cszFirstPageBackground[] = TEXT("FirstPageBackground");
const TCHAR cszTop[] = TEXT("Top");
const TCHAR cszLeft[] = TEXT("Left");
const TCHAR cszBackgroundColor[] = TEXT("BackgroundColor");
const TCHAR cszAnimation[] = TEXT("Animation");

const TCHAR cszFontFace[] = TEXT("FontFace");
const TCHAR cszFontSize[] = TEXT("FontSize");
const TCHAR cszFontWeight[] = TEXT("FontWeight");
const TCHAR cszFontColor[] = TEXT("FontColor");

const TCHAR cszPressedBmp[] = TEXT("PressedBmp");
const TCHAR cszUnpressedBmp[] = TEXT("UnpressedBmp");
const TCHAR cszTransparentColor[] = TEXT("TransparentColor");
const TCHAR cszDisabledColor[] = TEXT("DisabledColor");
const TCHAR cszvalign[] = TEXT("valign");
const TCHAR cszTutorialExe[] = TEXT("TutorialExe");
const TCHAR cszTutorialHTML[] = TEXT("TutorialHTML");

#define DEFAULT_HEADER_FONT TEXT("MS Shell Dlg")
#define DEFAULT_HEADER_SIZE 8
#define DEFAULT_HEADER_WEIGHT FW_BOLD


void DisplayOEMCustomizationErrorMsg
(
    int iErrorCode
)
{
    TCHAR   szMsg[MAX_RES_LEN];
    TCHAR   szFmt[MAX_RES_LEN];
    TCHAR   szMsgText[MAX_RES_LEN];
    TCHAR   szTitle[MAX_RES_LEN];
        
    LoadString(g_hInstance, OEMCUSTOM_ERR_MSGFMT, szFmt, ARRAYSIZE(szFmt));
    LoadString(g_hInstance, iErrorCode, szMsgText, ARRAYSIZE(szMsgText));
    LoadString(g_hInstance, IDS_APPNAME, szTitle, ARRAYSIZE(szTitle));
    
    wsprintf (szMsg, szFmt, szMsgText);
    MessageBox(NULL, szMsg, szTitle, MB_OK | MB_ICONSTOP);
}

// Check for, and load OEM custom settings.
BOOL bCheckOEMCustomization
(
    void
)
{
    int             iErrorCode = 0;
    TCHAR           szTemp[MAX_PATH];
    TCHAR           szOEMCustPath[MAX_PATH];
    TCHAR           szOEMCustFile[MAX_PATH];
    TCHAR           szHTMLFile[MAX_PATH];
    TCHAR           szCurrentDir[MAX_PATH];
    TCHAR           szPressedBmp[MAX_PATH];
    TCHAR           szUnpressedBmp[MAX_PATH];
    TCHAR           szFontFace[MAX_PATH];
    TCHAR           szColor[MAX_COLOR_NAME];
    TCHAR           szTransparentColor[MAX_COLOR_NAME];
    TCHAR           szDisabledColor[MAX_COLOR_NAME];
    TCHAR           szBusyFile[MAX_PATH];
    COLORREF        clrDisabled;
    long            lFontSize;
    long            lFontWeight;
    long            xPos;
    int             i;
    int             iVal;
    int             iTitleTop, iTitleLeft;
    long            vAlign;
    const LPTSTR    cszBtnSections[4] = { (LPTSTR)cszSectionBack, 
                                         (LPTSTR)cszSectionNext, 
                                         (LPTSTR)cszSectionFinish, 
                                         (LPTSTR)cszSectionCancel};
    CICWButton      *Btnids[4] = { &g_pICWApp->m_BtnBack, 
                                   &g_pICWApp->m_BtnNext, 
                                   &g_pICWApp->m_BtnFinish, 
                                   &g_pICWApp->m_BtnCancel};
    
     
    Assert(g_pICWApp);
     
    // We only allow OEM customization when running from Runonce or
    // a desktop shortcut
    if (!g_bRunOnce && !g_bShortcutEntry)
    {
        iErrorCode = OEMCUSTOM_ERR_NOTOEMENTRY;
        goto CheckOEMCustomizationExit2;
    }   
    // Get the current working directory so we can restore it later
    if (!GetCurrentDirectory(ARRAYSIZE(szCurrentDir), szCurrentDir))
    {
        iErrorCode = OEMCUSTOM_ERR_WINAPI;
        goto CheckOEMCustomizationExit2;
    }
    szCurrentDir[MAX_PATH-1] = TEXT('\0');
    
    // Get the Windows Directory. That is the root where the OEM customization
    // files will be places
    if (!GetWindowsDirectory(szOEMCustPath, ARRAYSIZE(szOEMCustPath)))
    {
        iErrorCode = OEMCUSTOM_ERR_WINAPI;
        goto CheckOEMCustomizationExit2;
    }
    szOEMCustPath[MAX_PATH-1] = TEXT('\0');
    
    // Make sure we can append the backslash and oem customization file name            
    if ((int)(sizeof(szOEMCustFile) - lstrlen(szOEMCustPath)) < 
           (int) (3 + lstrlen(c_szOEMCustomizationDir) + lstrlen(c_szOEMCustomizationFile)))
    {
        iErrorCode = OEMCUSTOM_ERR_NOMEM;
        goto CheckOEMCustomizationExit2;
    }   
        
    // Append the customization file name        
    lstrcat(szOEMCustPath, TEXT("\\"));
    lstrcat(szOEMCustPath, c_szOEMCustomizationDir);        
    
    // Change the working directory to the OEM one
    SetCurrentDirectory(szOEMCustPath);
    
    lstrcpy(szOEMCustFile, szOEMCustPath);
    lstrcat(szOEMCustFile, TEXT("\\"));
    lstrcat(szOEMCustFile, c_szOEMCustomizationFile);        
        
    // See if the customization file exists.
    if (0xFFFFFFFF == GetFileAttributes(szOEMCustFile))
    {
        iErrorCode = OEMCUSTOM_ERR_CANNOTFINDOEMCUSTINI;
        goto CheckOEMCustomizationExit;
    }
    
    // Background bitmap
    GetPrivateProfileString(cszSectionGeneral, 
                            cszBackgroundBmp, 
                            TEXT(""), 
                            szTemp, 
                            ARRAYSIZE(szTemp), 
                            szOEMCustFile);
    if (FAILED(g_pICWApp->SetBackgroundBitmap(szTemp)))
    {
        iErrorCode = OEMCUSTOM_ERR_BACKGROUND;
        goto CheckOEMCustomizationExit;
    }
    
    // solid background color for some HTML pages
    GetPrivateProfileString(cszSectionDialog, 
                            cszBackgroundColor, 
                            TEXT(""), 
                            gpWizardState->cmnStateData.szHTMLBackgroundColor, 
                            ARRAYSIZE(gpWizardState->cmnStateData.szHTMLBackgroundColor), 
                            szOEMCustFile);
    // App Title
    if (!GetPrivateProfileString(cszSectionGeneral, 
                            cszTitleBar, 
                            TEXT(""), 
                            g_pICWApp->m_szAppTitle, 
                            ARRAYSIZE(g_pICWApp->m_szAppTitle), 
                            szOEMCustFile))
    {                            
        // Default Title    
        LoadString(g_hInstance, IDS_APPNAME, g_pICWApp->m_szAppTitle, ARRAYSIZE(g_pICWApp->m_szAppTitle));
    }                        
    else
    {
        if (0 == lstrcmpi(g_pICWApp->m_szAppTitle, ICW_NO_APP_TITLE))
            LoadString(g_hInstance, IDS_APPNAME, g_pICWApp->m_szAppTitle, ARRAYSIZE(g_pICWApp->m_szAppTitle));
    }
    
    // Initial HTML page. REQUIRED
    if (!GetPrivateProfileString(cszSectionGeneral, 
                            cszFirstPageHTML, 
                            TEXT(""), 
                            szHTMLFile, 
                            ARRAYSIZE(szHTMLFile), 
                            szOEMCustFile))
    {
        iErrorCode = OEMCUSTOM_ERR_FIRSTHTML;
        goto CheckOEMCustomizationExit;
    }        
    
    // Make sure the file exists
    if (0xFFFFFFFF == GetFileAttributes(szHTMLFile))
    {
        iErrorCode = OEMCUSTOM_ERR_FIRSTHTML;
        goto CheckOEMCustomizationExit;
    }   
    
    // Form the URL for the OEM first page HTML
    wsprintf(g_pICWApp->m_szOEMHTML, TEXT("FILE://%s\\%s"), szOEMCustPath, szHTMLFile);

    // Initial page. BMP (OPTIONAL). NOTE this bitmap must be loaded after
    // the main background bitmap
    if (GetPrivateProfileString(cszSectionGeneral, 
                            cszFirstPageBackground, 
                            TEXT(""), 
                            szTemp, 
                            ARRAYSIZE(szTemp), 
                            szOEMCustFile))
    {
        if (FAILED(g_pICWApp->SetFirstPageBackgroundBitmap(szTemp)))
        {
            iErrorCode = OEMCUSTOM_ERR_BACKGROUND;
            goto CheckOEMCustomizationExit;
        }            
    }        

    // Position, and AVI file for busy animation
    if (GetPrivateProfileString(cszSectionBusy, 
                            cszAnimation, 
                            TEXT(""), 
                            szBusyFile, 
                            ARRAYSIZE(szBusyFile), 
                            szOEMCustFile))
    {
        if (0 != lstrcmpi(szBusyFile, TEXT("off")))
        {        
            // A file is specified, so quality the path
            if (!GetCurrentDirectory(ARRAYSIZE(gpWizardState->cmnStateData.szBusyAnimationFile), 
                                     gpWizardState->cmnStateData.szBusyAnimationFile))
            {
                iErrorCode = OEMCUSTOM_ERR_WINAPI;
                goto CheckOEMCustomizationExit;
            }
            gpWizardState->cmnStateData.szBusyAnimationFile[MAX_PATH-1] = TEXT('\0');
            // Make sure we can append the backslash and 8.3 file name            
            if ((int)(sizeof(gpWizardState->cmnStateData.szBusyAnimationFile) - 
                        lstrlen(gpWizardState->cmnStateData.szBusyAnimationFile)) < 
                   (int) (2 + lstrlen(gpWizardState->cmnStateData.szBusyAnimationFile)))
            {               
                iErrorCode = OEMCUSTOM_ERR_NOMEM;
                goto CheckOEMCustomizationExit;
            }
            // Append the customization file name        
            lstrcat(gpWizardState->cmnStateData.szBusyAnimationFile, TEXT("\\"));
            lstrcat(gpWizardState->cmnStateData.szBusyAnimationFile, szBusyFile);        
        }
        else
        {
            // Hide the animation
            gpWizardState->cmnStateData.bHideProgressAnime = TRUE;
        }            
    }                        
    gpWizardState->cmnStateData.xPosBusy = GetPrivateProfileInt(cszSectionBusy,
                                                                cszLeft,
                                                                -1,
                                                                szOEMCustFile);                            
    // Get the background color for the Animation file
    if (GetPrivateProfileString(cszSectionBusy, 
                            cszBackgroundColor, 
                            TEXT(""), 
                            szColor, 
                            ARRAYSIZE(szColor), 
                            szOEMCustFile))
    {
        g_pICWApp->m_clrBusyBkGnd = ColorToRGB(szColor);
    }   
    
    // Get the font to be used for the Titles. Note this must be done
    // after the background bitmap is set, since the title position
    // is dependant on the overall window size
    GetPrivateProfileString(cszSectionHeader, 
                            cszFontFace, 
                            DEFAULT_HEADER_FONT, 
                            szFontFace, 
                            ARRAYSIZE(szFontFace), 
                            szOEMCustFile);
    GetPrivateProfileString(cszSectionHeader, 
                            cszFontColor, 
                            TEXT(""), 
                            szColor, 
                            ARRAYSIZE(szColor), 
                            szOEMCustFile);
                            
    lFontSize = (long)GetPrivateProfileInt(cszSectionHeader,
                                          cszFontSize,
                                          DEFAULT_HEADER_SIZE,
                                          szOEMCustFile);
    lFontWeight = (long)GetPrivateProfileInt(cszSectionHeader,
                                             cszFontWeight,
                                             DEFAULT_HEADER_WEIGHT,
                                             szOEMCustFile);
    iTitleTop = GetPrivateProfileInt(cszSectionHeader,
                                     cszTop,
                                     -1,
                                     szOEMCustFile);                            
    iTitleLeft = GetPrivateProfileInt(cszSectionHeader,
                                     cszLeft,
                                     -1,
                                     szOEMCustFile);                            
    if (FAILED(g_pICWApp->SetTitleParams(iTitleTop,
                                         iTitleLeft,
                                         szFontFace,
                                         lFontSize,
                                         lFontWeight,
                                         ColorToRGB(szColor))))
    {
        iErrorCode = OEMCUSTOM_ERR_HEADERPARAMS;
        goto CheckOEMCustomizationExit;
    }                                                      
    
    // Get the Button Params
    for (i = 0; i < ARRAYSIZE(cszBtnSections); i++) 
    {
        
        GetPrivateProfileString(cszBtnSections[i], 
                                cszPressedBmp, 
                                TEXT(""), 
                                szPressedBmp, 
                                ARRAYSIZE(szPressedBmp), 
                                szOEMCustFile);
        GetPrivateProfileString(cszBtnSections[i], 
                                cszUnpressedBmp, 
                                TEXT(""), 
                                szUnpressedBmp, 
                                ARRAYSIZE(szUnpressedBmp), 
                                szOEMCustFile);
        if (!GetPrivateProfileString(cszBtnSections[i], 
                                cszFontFace, 
                                TEXT(""), 
                                szFontFace, 
                                ARRAYSIZE(szFontFace), 
                                szOEMCustFile))
        {
            iErrorCode = OEMCUSTOM_ERR_NOBUTTONFONTFACE;
            goto CheckOEMCustomizationExit;
        }   
                                     
        xPos = (long)GetPrivateProfileInt(cszBtnSections[i],
                                          cszLeft,
                                          -1,
                                          szOEMCustFile);                            
        if (-1 == xPos)
        {
            iErrorCode = OEMCUSTOM_ERR_NOBUTTONLEFT;
            goto CheckOEMCustomizationExit;
        }                                          
        
        lFontSize = (long)GetPrivateProfileInt(cszBtnSections[i],
                                              cszFontSize,
                                              -1,
                                              szOEMCustFile);
        if (-1 == lFontSize)                    
        {
            iErrorCode = OEMCUSTOM_ERR_NOBUTTONFONTSIZE;
            goto CheckOEMCustomizationExit;
        }
                                  
        lFontWeight = (long)GetPrivateProfileInt(cszBtnSections[i],
                                                 cszFontWeight,
                                                 0,
                                                 szOEMCustFile);
        GetPrivateProfileString(cszBtnSections[i], 
                                cszFontColor, 
                                TEXT(""), 
                                szColor, 
                                ARRAYSIZE(szColor), 
                                szOEMCustFile);
        if (!GetPrivateProfileString(cszBtnSections[i], 
                                cszTransparentColor, 
                                TEXT(""), 
                                szTransparentColor, 
                                ARRAYSIZE(szTransparentColor), 
                                szOEMCustFile))
        {
            iErrorCode = OEMCUSTOM_ERR_NOBUTTONTRANSPARENTCOLOR;
            goto CheckOEMCustomizationExit;
        }                                
        if (GetPrivateProfileString(cszBtnSections[i], 
                                cszDisabledColor, 
                                TEXT(""), 
                                szDisabledColor, 
                                ARRAYSIZE(szDisabledColor), 
                                szOEMCustFile))
            clrDisabled = ColorToRGB(szDisabledColor);                
        else
            clrDisabled = GetSysColor(COLOR_GRAYTEXT);
        
        // Vertical alignment for the text
        if (GetPrivateProfileString(cszBtnSections[i], 
                                    cszvalign, 
                                    TEXT(""), 
                                    szTemp, 
                                    ARRAYSIZE(szTemp), 
                                    szOEMCustFile))
        {
            if (0 == lstrcmpi(szTemp, TEXT("top")))
                vAlign = DT_TOP;
            else if (0 == lstrcmpi(szTemp, TEXT("center")))
                vAlign = DT_VCENTER;
            else if (0 == lstrcmpi(szTemp, TEXT("bottom")))
                vAlign = DT_BOTTOM;
            else
                vAlign = -1;
        }
        else
        {
            vAlign = -1;
        }                                                
                                              
                                                         
        if (FAILED(Btnids[i]->SetButtonParams(xPos,
                                              szPressedBmp,
                                              szUnpressedBmp,
                                              szFontFace,
                                              lFontSize,
                                              lFontWeight,
                                              ColorToRGB(szColor),
                                              ColorToRGB(szTransparentColor),
                                              clrDisabled,
                                              vAlign)))
        {
            iErrorCode = OEMCUSTOM_ERR_BUTTONPARAMS;
            goto CheckOEMCustomizationExit;
        }                                                      
    }
    // Handle the Tutorial button seperatly, because they might 
    // not want one
    if (GetPrivateProfileString(cszSectionTutorial, 
                            cszPressedBmp, 
                            TEXT(""), 
                            szPressedBmp, 
                            ARRAYSIZE(szPressedBmp), 
                            szOEMCustFile))
    {                            
        GetPrivateProfileString(cszSectionTutorial, 
                                cszUnpressedBmp, 
                                TEXT(""), 
                                szUnpressedBmp, 
                                ARRAYSIZE(szUnpressedBmp), 
                                szOEMCustFile);
        if (!GetPrivateProfileString(cszSectionTutorial, 
                                cszFontFace, 
                                TEXT(""), 
                                szFontFace, 
                                ARRAYSIZE(szFontFace), 
                                szOEMCustFile))
        {
            iErrorCode = OEMCUSTOM_ERR_NOBUTTONFONTFACE;
            goto CheckOEMCustomizationExit;
        }   
                                     
        xPos = (long)GetPrivateProfileInt(cszSectionTutorial,
                                          cszLeft,
                                          -1,
                                          szOEMCustFile);                            
        if (-1 == xPos)
        {
            iErrorCode = OEMCUSTOM_ERR_NOBUTTONLEFT;
            goto CheckOEMCustomizationExit;
        }                                          
        
        lFontSize = (long)GetPrivateProfileInt(cszSectionTutorial,
                                              cszFontSize,
                                              -1,
                                              szOEMCustFile);
        if (-1 == lFontSize)                    
        {
            iErrorCode = OEMCUSTOM_ERR_NOBUTTONFONTSIZE;
            goto CheckOEMCustomizationExit;
        }
                                  
        lFontWeight = (long)GetPrivateProfileInt(cszSectionTutorial,
                                                 cszFontWeight,
                                                 0,
                                                 szOEMCustFile);
        GetPrivateProfileString(cszSectionTutorial, 
                                cszFontColor, 
                                TEXT(""), 
                                szColor, 
                                ARRAYSIZE(szColor), 
                                szOEMCustFile);
        if (!GetPrivateProfileString(cszSectionTutorial, 
                                cszTransparentColor, 
                                TEXT(""), 
                                szTransparentColor, 
                                ARRAYSIZE(szTransparentColor), 
                                szOEMCustFile))
        {
            iErrorCode = OEMCUSTOM_ERR_NOBUTTONTRANSPARENTCOLOR;
            goto CheckOEMCustomizationExit;
        }                                
        if (GetPrivateProfileString(cszSectionTutorial, 
                                cszDisabledColor, 
                                TEXT(""),
                                szDisabledColor, 
                                ARRAYSIZE(szDisabledColor), 
                                szOEMCustFile))
            clrDisabled = ColorToRGB(szDisabledColor);                
        else
            clrDisabled = GetSysColor(COLOR_GRAYTEXT);
        
        // Vertical alignment for the text
        if (GetPrivateProfileString(cszSectionTutorial, 
                                    cszvalign, 
                                    TEXT(""),
                                    szTemp, 
                                    ARRAYSIZE(szTemp), 
                                    szOEMCustFile))
        {
            if (0 == lstrcmpi(szTemp, TEXT("top")))
                vAlign = DT_TOP;
            else if (0 == lstrcmpi(szTemp, TEXT("center")))
                vAlign = DT_VCENTER;
            else if (0 == lstrcmpi(szTemp, TEXT("bottom")))
                vAlign = DT_BOTTOM;
            else
                vAlign = -1;
        }
        else
        {
            vAlign = -1;
        }                                                
                                              
        if (FAILED(g_pICWApp->m_BtnTutorial.SetButtonParams(xPos,
                                                              szPressedBmp,
                                                              szUnpressedBmp,
                                                              szFontFace,
                                                              lFontSize,
                                                              lFontWeight,
                                                              ColorToRGB(szColor),
                                                              ColorToRGB(szTransparentColor),
                                                              clrDisabled,
                                                              vAlign)))
        {
            iErrorCode = OEMCUSTOM_ERR_BUTTONPARAMS;
            goto CheckOEMCustomizationExit;
        }                                                      
        
#ifndef ICWDEBUG    
        // See if the OEM wants to replace the Tutor executable
        if (GetPrivateProfileString(cszSectionTutorial, 
                                cszTutorialExe, 
                                TEXT(""), 
                                szTemp, 
                                ARRAYSIZE(szTemp), 
                                szOEMCustFile))
        {
            // Checkt to see if the provided name is fully qualified or not. If it
            // is not fully qualified, then make szTemp a fully qualified path using
            // the OEM custom file dir as the base path
            if (PathIsFileSpec(szTemp))
            {
                TCHAR szDrive         [_MAX_DRIVE] = TEXT("\0");
                TCHAR szDir           [_MAX_DIR]   = TEXT("\0");
                TCHAR szFile          [MAX_PATH]   = TEXT("\0");       // Large because there might be cmd line params
                
                // Breakdown the current OEM custom file path
                _tsplitpath(szOEMCustFile,
                           szDrive,
                           szDir, 
                           NULL, 
                           NULL);
                           
                // The name specified in the OEMCUST.INI file is the file name
                lstrcpyn(szFile, szTemp, ARRAYSIZE(szFile));
                
                // Form the fill path into szTemp                
                _tmakepath(szTemp, szDrive, szDir, szFile, NULL);
            }
            g_pICWTutorApp->ReplaceTutorAppCmdLine(szTemp);
        }                                
        // See if the OEM wants to replace the Tutor HTML
        else if (GetPrivateProfileString(cszSectionTutorial, 
                                cszTutorialHTML, 
                                TEXT(""), 
                                szTemp, 
                                ARRAYSIZE(szTemp), 
                                szOEMCustFile))
        {
            TCHAR   szCmdLine[MAX_PATH];
            
            wsprintf(szCmdLine, TEXT("icwtutor %s\\%s"), szOEMCustPath, szTemp);
            g_pICWTutorApp->ReplaceTutorAppCmdLine(szCmdLine);
        }                                
#endif        
    }    
    else
    {
        // Don't show the tutorial button    
        g_pICWApp->m_BtnTutorial.SetButtonDisplay(FALSE);
    }
    
    // This makes sure things will fit. This function will compute the button
    // area height based on overall window size, set by the background bitmap
    if (-1 == g_pICWApp->GetButtonAreaHeight())
    {
        iErrorCode = OEMCUSTOM_ERR_SIZE;
        goto CheckOEMCustomizationExit;
    }
    // Get the Top Left corner of the ICW wizard page frame. Note this has be be
    // done after the button area is calculated
    iVal = GetPrivateProfileInt(cszSectionDialog,
                                cszTop,
                                -1,
                                szOEMCustFile);                            
    if (FAILED(g_pICWApp->SetWizardWindowTop(iVal)))
    {
        iErrorCode = OEMCUSTOM_ERR_WIZARDTOP;
        goto CheckOEMCustomizationExit;
    }    
    iVal = GetPrivateProfileInt(cszSectionDialog,
                                cszLeft,
                                -1,
                                szOEMCustFile);                            
    if (FAILED(g_pICWApp->SetWizardWindowLeft(iVal)))
    {
        iErrorCode = OEMCUSTOM_ERR_WIZARDLEFT;
        goto CheckOEMCustomizationExit;
    }    
            
    if (GetPrivateProfileString(cszSectionDialog, 
                            cszFontColor, 
                            TEXT(""), 
                            szColor, 
                            ARRAYSIZE(szColor), 
                            szOEMCustFile))
    {
        lstrcpy(gpWizardState->cmnStateData.szclrHTMLText, szColor);                                
        gpWizardState->cmnStateData.clrText = ColorToRGB(szColor);
    }        
    else
    {
        lstrcpy(gpWizardState->cmnStateData.szclrHTMLText, TEXT("WINDOWTEXT"));                                
        gpWizardState->cmnStateData.clrText = GetSysColor(COLOR_WINDOWTEXT);
    }
    
CheckOEMCustomizationExit:
    // Change the working directory back, and perform any other cleanup
    SetCurrentDirectory(szCurrentDir);
    
CheckOEMCustomizationExit2:

    // if there was an error see if we should show the reason
    if (iErrorCode)
    {
        if (g_bDebugOEMCustomization)
            DisplayOEMCustomizationErrorMsg(iErrorCode);
            
        return FALSE;
    }
    else
    {
        return TRUE;
    }        
}

BOOL TranslateWizardPageAccelerator
(
    HWND    hWndWizPage,
    LPMSG   lpMsg
)
{
    // Locate the accelerator table for the current page
    PAGEINFO    *pPageInfo = (PAGEINFO *) GetWindowLongPtr(hWndWizPage,DWLP_USER);
    BOOL        bRet = FALSE;
        
    if (pPageInfo)
    {
        // See if there is a nested accelerator
        if (pPageInfo->hAccelNested)
            bRet = TranslateAccelerator(g_pICWApp->m_hWndApp, pPageInfo->hAccelNested, lpMsg);
        
        // If no nested, or nested not translated, then check for accelerators on the page    
        if (!bRet && pPageInfo->hAccel)
            bRet = TranslateAccelerator(g_pICWApp->m_hWndApp, pPageInfo->hAccel, lpMsg);
    }        
    else
        bRet =  FALSE;
        
    return bRet;        
}    

/*******************************************************************

  NAME:    RunSignupApp

  SYNOPSIS:  Create an application to host the Wizard pages

  ENTRY:    

  EXIT:     returns TRUE if user runs ICW to completion,
            FALSE if user cancels or an error occurs

  NOTES:    Wizard pages all use one dialog proc (GenDlgProc).
        They may specify their own handler procs to get called
        at init time or in response to Next, Cancel or a dialog
        control, or use the default behavior of GenDlgProc.

********************************************************************/
BOOL RunSignupApp(void)
{
    MSG msg;
    
    // Initialize the Application Class
    if (S_OK != g_pICWApp->Initialize())
        return FALSE;
            
    // Start the message loop. 
    while (GetMessage(&msg, (HWND) NULL, 0, 0)) 
    { 
        // If the wizard pages are being displayed, we need to see
        // if the wizard is ready to be destroyed.
        // (PropSheet_GetCurrentPageHwnd returns NULL) then destroy the dialog.
       
        // PropSheet_GetCurrentPageHwnd will return NULL after the OK or Cancel 
        // button has been pressed and all of the pages have been notified.
        if(gpWizardState->cmnStateData.hWndWizardPages && (NULL == PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages)))
        {
            DestroyWindow(gpWizardState->cmnStateData.hWndWizardPages);
            gpWizardState->cmnStateData.hWndWizardPages = NULL;
               
            DestroyWindow(g_pICWApp->m_hWndApp);
        }
        
        if(gpWizardState->cmnStateData.hWndWizardPages)
        {
            // Need to translate accelerators for this page. The page accelerators need
            // to be translated first, because some of the app level ones overlap, but
            // not visible at the same time. For this reason we want the page to have first
            // shot at translating.
            if (!TranslateWizardPageAccelerator(PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages), &msg))
            {
                // OK see if the app has any accelerators
                if (!g_pICWApp->m_haccel || !TranslateAccelerator(g_pICWApp->m_hWndApp,
                                                                  g_pICWApp->m_haccel,
                                                                  &msg))
                {
                    if (!PropSheet_IsDialogMessage(gpWizardState->cmnStateData.hWndWizardPages, &msg))
                    {
                        TranslateMessage(&msg); 
                        DispatchMessage(&msg); 
                    }
                }                    
            }
        }    
        else
        {
            // see if the app has any accelerators
            if (!g_pICWApp->m_haccel || !TranslateAccelerator(g_pICWApp->m_hWndApp,
                                                              g_pICWApp->m_haccel,
                                                               &msg))
            {                                                               
                TranslateMessage(&msg); 
                DispatchMessage(&msg); 
            }                
        }            
    } 
 
    // Return the exit code to the system. 
    return ((BOOL)msg.wParam);
}

//**********************************************************************
//
// bRegisterHelperOC
//
// Purpose:
//
//      Register the ICWCONN1 helper COM
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
//********************************************************************
BOOL bRegisterHelperOC
(
    HINSTANCE   hInstance,
    UINT        idLibString,
    BOOL        bReg
)
{
    BOOL    bRet = FALSE;
    HINSTANCE   hMod;
    char        szLib[MAX_PATH];

    // Self register the COM that ICWCONN1 needs
    // Because we load the DLL server into our own (ie, REGISTER.EXE)
    // process space, call to initialize the OLE COM Library.  Use the
    // OLE SUCCEEDED macro to detect success.  If fail then exit app
    // with error message.

    LoadStringA(hInstance, idLibString, szLib, sizeof(szLib));

    // Load the Server DLL into our process space.
    hMod = LoadLibraryA(szLib);

    if (NULL != hMod)
    {
        HRESULT (STDAPICALLTYPE *pfn)(void);

        // Extract the proper RegisterServer or UnRegisterServer entry point
        if (bReg)
            (FARPROC&)pfn = GetProcAddress(hMod, "DllRegisterServer");
        else
            (FARPROC&)pfn = GetProcAddress(hMod, "DllUnregisterServer");

        // Call the entry point if we have it.
        if (NULL != pfn)
        {
            if (FAILED((*pfn)()))
            {
                if (IsNT5() )
                {
                    if (*g_szShellNext)
                    {
                        // 1 Process Shell Next
                        // 2 Set Completed Bit
                        // 3 Remove ICW icon grom desktop
                        UndoDesktopChanges(hInstance);

                        SetICWComplete();
                    }
                    else
                    {
                        TCHAR szTemp[MAX_MESSAGE_LEN];
                        TCHAR szPrivDenied[MAX_MESSAGE_LEN] = TEXT("\0");

                        LoadString(hInstance, IDS_INSUFFICIENT_PRIV1, szPrivDenied, MAX_PATH);
                        LoadString(hInstance, IDS_INSUFFICIENT_PRIV2, szTemp, MAX_PATH);
                        lstrcat(szPrivDenied, szTemp);

                        LoadString(hInstance, IDS_APPNAME, szTemp, MAX_PATH);
                        MessageBox(NULL, szPrivDenied, szTemp, MB_OK | MB_ICONINFORMATION);
                    }
                }
                else
                {
                    MsgBox(NULL,IDS_DLLREG_FAIL,MB_ICONEXCLAMATION,MB_OK);
                }
                bRet = FALSE;
            }
            else
            {
                bRet = TRUE;
            }
        }
        else
        {
            MsgBox(NULL,IDS_NODLLREG_FAIL,MB_ICONEXCLAMATION,MB_OK);
            bRet = FALSE;
        }

        // Free the library
        FreeLibrary(hMod);

    }
    else
    {
        MsgBox(NULL,IDS_LOADLIB_FAIL,MB_ICONEXCLAMATION,MB_OK);
        bRet = FALSE;
    }

    return (bRet);
}

//**********************************************************************
//
// WinMain
//
// Purpose:
//
//      Program entry point
//
// Parameters:
//
//      HANDLE hInstance        - Instance handle for this instance
//
//      HANDLE hPrevInstance    - Instance handle for the last instance
//
//      LPTSTR lpCmdLine         - Pointer to the command line
//
//      int nCmdShow            - Window State
//
// Return Value:
//
//      msg.wParam
//
// Function Calls:
//      Function                        Location
//
//      CConnWizApp::CConnWizApp          APP.CPP
//      CConnWizApp::fInitApplication    APP.CPP
//      CConnWizApp::fInitInstance       APP.CPP
//      CConnWizApp::HandleAccelerators  APP.CPP
//      CConnWizApp::~CConnWizApp         APP.CPP
//      GetMessage                      Windows API
//      TranslateMessage                Windows API
//      DispatchMessage                 Windows API
//
// Comments:
//
//********************************************************************
int PASCAL WinMainT(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPTSTR lpCmdLine,int nCmdShow)
{
    int iRetVal = 1;

#ifdef UNICODE
    // Initialize the C runtime locale to the system locale.
    setlocale(LC_ALL, "");
#endif

    g_hInstance = hInstance;

    //Do this here to minimize the chance that a user will ever see this
    DeleteStartUpCommand();
    
    // needed for LRPC to work properly...
    SetMessageQueue(96);

    if (FAILED(CoInitialize(NULL)))
        return(0);

    //Is the user an admin?
    g_bUserIsAdmin = DoesUserHaveAdminPrivleges(hInstance);
    g_bUserIsIEAKRestricted = CheckForIEAKRestriction(hInstance);
    
    // Allocate memory for the global wizard state
    gpWizardState = new WIZARDSTATE;
    
    if (!gpWizardState)
    {
        MsgBox(NULL,IDS_ERR_OUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
        return 0;
    }
    
    // zero out structure
    ZeroMemory(gpWizardState,sizeof(WIZARDSTATE));
    SetDefaultProductCode(g_szProductCode,sizeof(g_szProductCode));
    ZeroMemory(g_szPromoCode,sizeof(g_szPromoCode));

#ifndef ICWDEBUG

    g_pszCmdLine = (TCHAR*)malloc((lstrlen(lpCmdLine) + 1)*sizeof(TCHAR));
    if(g_pszCmdLine == NULL)
    {
        iRetVal = 0;

        goto WinMainExit;
    }
    lstrcpy(g_pszCmdLine, lpCmdLine);

    if (IsOemVer())
       g_OEMOOBE = TRUE;

    if (!(g_bRetProcessCmdLine = ProcessCommandLine(hInstance, lpCmdLine)))
    {
        iRetVal = 0;

        goto WinMainExit;
    }

    if (g_OEMOOBE)
    {
        TCHAR szISPAppCmdLine[MAX_PATH];
        TCHAR szOobeSwitch[MAX_PATH];
        
        if (CheckOobeInfo(szOobeSwitch, szISPAppCmdLine))
        {
            if (IsWhistler())
            {
                // Ask if user want to run NCW or OEM version of OOBE 
                // [Windows Bug 325762]
                INT_PTR nResult = DialogBox(hInstance,
                                            MAKEINTRESOURCE(IDD_CHOOSEWIZARD),
                                            NULL,
                                            ChooseWizardDlgProc);
                if (nResult == RUNWIZARD_OOBE)
                {
                    // launch Mars sign-up on OEM preinstall machines which are 
                    // configured with default offer as Mars [Windows Bug 347909]
                    if (szISPAppCmdLine[0] == TEXT('\0'))
                    {
                        StartOOBE(g_pszCmdLine, szOobeSwitch);
                    }
                    else
                    {
                        StartISPApp(szISPAppCmdLine, g_pszCmdLine);
                    }
                }
                else if (nResult == RUNWIZARD_NCW)
                {
                    StartNCW(g_szShellNext, g_szShellNextParams);
                }
            }
            else
            {
                StartOOBE(g_pszCmdLine, szOobeSwitch);
            }

            g_szShellNext[0] = TEXT('\0');
            
            goto WinMainExit;

        }
    }

#endif

    //Is the user an admin?
    if(!g_bUserIsAdmin)
    {
        TCHAR szAdminDenied      [MAX_PATH] = TEXT("\0");
        TCHAR szAdminDeniedTitle [MAX_PATH] = TEXT("\0");
        LoadString(hInstance, IDS_ADMIN_ACCESS_DENIED, szAdminDenied, MAX_PATH);
        LoadString(hInstance, IDS_ADMIN_ACCESS_DENIED_TITLE, szAdminDeniedTitle, MAX_PATH);
        MessageBox(NULL, szAdminDenied, szAdminDeniedTitle, MB_OK | MB_ICONSTOP);
    
        TCHAR szOut[MAX_PATH];    
     
        // Get the first token
        GetCmdLineToken(&lpCmdLine,szOut);
        while (szOut[0])
        {
            GetShellNextToken(szOut, lpCmdLine);
            
            // Eat the next token, it will be null if we are at the end
            GetCmdLineToken(&lpCmdLine,szOut);
        }

        SetICWComplete();

        goto WinMainExit;
    }
    
    //Has an admin restricted access through the IEAK?
    if (g_bUserIsIEAKRestricted)
    {
        TCHAR szIEAKDenied[MAX_PATH];
        TCHAR szIEAKDeniedTitle[MAX_PATH];
        LoadString(hInstance, IDS_IEAK_ACCESS_DENIED, szIEAKDenied, MAX_PATH);
        LoadString(hInstance, IDS_IEAK_ACCESS_DENIED_TITLE, szIEAKDeniedTitle, MAX_PATH);
        MessageBox(NULL, szIEAKDenied, szIEAKDeniedTitle, MB_OK | MB_ICONSTOP);
        
        //Yup, bail.
        goto WinMainExit;
    }


    //Are we recovering from an OEM INS failure?
    if (CheckForOemConfigFailure(hInstance))
    {
        QuickCompleteSignup();
        //Yup, bail.
        goto WinMainExit;
    }

    // Register ICWHELP.DLL
    if (!bRegisterHelperOC(hInstance, IDS_HELPERLIB, TRUE))
    {
        iRetVal = 0;
        goto WinMainExit;
    }

    // Register ICWUTIL.DLL
    if (!bRegisterHelperOC(hInstance, IDS_UTILLIB, TRUE))
    {
        iRetVal = 0;
        goto WinMainExit;
    }

    // Register ICWCONN.DLL
    if (!bRegisterHelperOC(hInstance, IDS_WIZARDLIB, TRUE))
    {
        iRetVal = 0;
        goto WinMainExit;
    }
      
    // initialize the app state structure 
    //-- do this here so we don't changed made in cmdln process
    if (!InitWizardState(gpWizardState))
        return 0;    
   
    if(!LoadString(g_hInstance, IDS_APPNAME, gpWizardState->cmnStateData.szWizTitle, ARRAYSIZE(gpWizardState->cmnStateData.szWizTitle)))
        lstrcpy(gpWizardState->cmnStateData.szWizTitle, TEXT("Internet Connection Wizard"));
    
     
    //we are being run from an OEM
    if(g_bRunOnce)
    {
        //Do they have a connection
        if(MyIsSmartStartEx(NULL, 0))
        {   
            //Nope, look for oemconfig.ins
            if(RunOemconfigIns())
                goto WinMainExit;
        }
        else
        {
            //Yup, clean up desktop, set completed bit etc., then bail
            QuickCompleteSignup(); 
            goto WinMainExit;
        }
    }

    // If there was not a shellnext passed on the CMD line, there might be
    // one in the registry
    if( g_szShellNext[0]  == TEXT('\0'))
    {
        GetShellNextFromReg(g_szShellNext,g_szShellNextParams);
    }        
    // We need to remove this entry now, so ICWMAN (INETWIZ) does not 
    // pick it up later
    RemoveShellNextFromReg();

    if (IsWhistler() &&
        ((gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAGS_NONCW) == 0))
    {
        // If we have shellnext, we want to run NCW instead [Windows Bug 325157]
        if ( g_szShellNext[0] != TEXT('\0'))
        {
            StartNCW(g_szShellNext, g_szShellNextParams);

            g_szShellNext[0] = TEXT('\0');
            
            goto WinMainExit;
        }
    }
    
    // Create an instance of the App Class
    g_pICWApp = new CICWApp();
    if (NULL == g_pICWApp)
    {
        iRetVal = 0;
        goto WinMainExit;
    }
    
    // Superclass some dialog control types so we can correctly draw them
    // transparently if we are using OEM customizations
    SuperClassICWControls();
    
    if (bCheckOEMCustomization())
        iRetVal = RunSignupApp();
    else
        iRetVal = (RunSignupWizard(NULL) != NULL);
    
    // Prepare for reboot if necessary
    if (gfBackedUp == FALSE)
    {
        if (gpWizardState->fNeedReboot)
            SetupForReboot(0);
    }

    // Cleanup the wizard state
    ICWCleanup();

WinMainExit: 
    
    if (g_bUserIsAdmin && g_bRetProcessCmdLine && !g_bUserIsIEAKRestricted)
    {
        // Lets unregister the helper DLL
        if (!bRegisterHelperOC(hInstance, IDS_HELPERLIB, FALSE))
        {
            iRetVal = 0;
        }

        if (!bRegisterHelperOC(hInstance, IDS_UTILLIB, FALSE))
        {
            iRetVal = 0;
        }

        if (!bRegisterHelperOC(hInstance, IDS_WIZARDLIB, FALSE))
        {
            iRetVal = 0;
        }
    
        // Nuke the ICWApp class
        if (g_pICWApp)
        {
            delete g_pICWApp;
        }
    
        // Remove the superclassing for the ICW Controls
        RemoveICWControlsSuperClass();   
    
    }
    
    // deref from COM
    CoUninitialize();
    
    // free global structures
    if (gpWizardState) 
        delete gpWizardState;
    
    if(g_pszCmdLine)
        free(g_pszCmdLine);

    return (iRetVal);          /* Returns the value from PostQuitMessage */
}


void RemoveDownloadDirectory (void)
{
    DWORD dwAttribs;
    TCHAR szDownloadDir[MAX_PATH];
    TCHAR szSignedPID[MAX_PATH];

    // form the ICW98 dir.  It is basically the CWD
    if (0 == GetCurrentDirectory(MAX_PATH, szDownloadDir))
      return;
    
    // remove the signed.pid file from the ICW directory (see BUG 373)
    wsprintf(szSignedPID, TEXT("%s%s"), szDownloadDir, TEXT("\\signed.pid"));
    if (GetFileAttributes(szSignedPID) != 0xFFFFFFFF)
    {
      SetFileAttributes(szSignedPID, FILE_ATTRIBUTE_NORMAL);    
      DeleteFile(szSignedPID);
    }
    
    lstrcat(szDownloadDir, TEXT("\\download"));

   // See if the directory exists
   dwAttribs = GetFileAttributes(szDownloadDir);
   if (dwAttribs != 0xFFFFFFFF && dwAttribs & FILE_ATTRIBUTE_DIRECTORY)
      DeleteDirectory(szDownloadDir);
}

#ifdef ICWDEBUG
void RemoveTempOfferDirectory (void)
{
    DWORD dwAttribs;
    TCHAR szDownloadDir[MAX_PATH];
    // Set the current directory.
    HKEY    hkey = NULL;
    TCHAR   szAppPathKey[MAX_PATH];
    TCHAR   szICWPath[MAX_PATH];
    DWORD   dwcbPath = sizeof(szICWPath);
            
    lstrcpy (szAppPathKey, REGSTR_PATH_APPPATHS);
    lstrcat (szAppPathKey, TEXT("\\"));
    lstrcat (szAppPathKey, TEXT("ICWCONN1.EXE"));

    if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,szAppPathKey, 0, KEY_QUERY_VALUE, &hkey)) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hkey, TEXT("Path"), NULL, NULL, (BYTE *)szICWPath, (DWORD *)&dwcbPath) == ERROR_SUCCESS)
        {
            // The Apppaths' have a trailing semicolon that we need to get rid of
            // dwcbPath is the lenght of the string including the NULL terminator
            int nSize = lstrlen(szICWPath);
            if (nSize > 0)
                szICWPath[nSize-1] = TEXT('\0');
            //SetCurrentDirectory(szICWPath);
        }            
    }

    if (hkey) 
        RegCloseKey(hkey);

    lstrcpy(szDownloadDir, szICWPath);

    lstrcat(szDownloadDir, TEXT("\\tempoffer"));
   
    // See if the directory exists
    dwAttribs = GetFileAttributes(szDownloadDir);
    if (dwAttribs != 0xFFFFFFFF && dwAttribs & FILE_ATTRIBUTE_DIRECTORY)
        DeleteDirectory(szDownloadDir);
}
#endif

void DeleteDirectory (LPCTSTR szDirName)
{
WIN32_FIND_DATA fdata;
TCHAR szPath[MAX_PATH];
HANDLE hFile;
BOOL fDone;

   wsprintf(szPath, TEXT("%s\\*.*"), szDirName);
   hFile = FindFirstFile (szPath, &fdata);
   if (INVALID_HANDLE_VALUE != hFile)
      fDone = FALSE;
   else
      fDone = TRUE;

   while (!fDone)
   {
      wsprintf(szPath, TEXT("%s\\%s"), szDirName, fdata.cFileName);
      if (fdata.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY)
      {
         if (lstrcmpi(fdata.cFileName, TEXT("."))  != 0 &&
             lstrcmpi(fdata.cFileName, TEXT("..")) != 0)
         {
            // recursively delete this dir too
            DeleteDirectory(szPath);
         }
      }  
      else
      {
         SetFileAttributes(szPath, FILE_ATTRIBUTE_NORMAL);
         DeleteFile(szPath);
      }
      if (FindNextFile(hFile, &fdata) == 0)
      {
         FindClose(hFile);
         fDone = TRUE;
      }
   }
   SetFileAttributes(szDirName, FILE_ATTRIBUTE_NORMAL);
   RemoveDirectory(szDirName);
}

//+----------------------------------------------------------------------------
//
//    Function    AllocDialogIDList
//
//    Synopsis    Allocates memory for the g_pdwDialogIDList variable large enough
//                to maintain 1 bit for every valid external dialog ID
//
//    Arguments    None
//
//    Returns        TRUE if allocation succeeds
//                FALSE otherwise
//
//    History        4/23/97    jmazner        created
//
//-----------------------------------------------------------------------------

BOOL AllocDialogIDList( void )
{
    ASSERT( NULL == g_pdwDialogIDList );
    if( g_pdwDialogIDList )
    {
        TraceMsg(TF_ICWCONN1,TEXT("ICWCONN1: AllocDialogIDList called with non-null g_pdwDialogIDList!"));
        return FALSE;
    }

    // determine maximum number of external dialogs we need to track
    UINT uNumExternDlgs = EXTERNAL_DIALOGID_MAXIMUM - EXTERNAL_DIALOGID_MINIMUM + 1;

    // we're going to need one bit for each dialogID.
    // Find out how many DWORDS it'll take to get this many bits.
    UINT uNumDWORDsNeeded = (uNumExternDlgs / ( 8 * sizeof(DWORD) )) + 1;

    // set global var with length of the array
    g_dwDialogIDListSize = uNumDWORDsNeeded;

    g_pdwDialogIDList = (DWORD *) GlobalAlloc(GPTR, uNumDWORDsNeeded * sizeof(DWORD));

    if( !g_pdwDialogIDList )
    {
        TraceMsg(TF_ICWCONN1,TEXT("ICWCONN1: AllocDialogIDList unable to allocate space for g_pdwDialogIDList!"));
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//    Function    DialogIDAlreadyInUse
//
//    Synopsis    Checks whether a given dialog ID is marked as in use in the
//                global array pointed to by g_pdwDialogIDList
//
//    Arguments    uDlgID -- Dialog ID to check
//
//    Returns        TRUE if    -- DialogID is out of range defined by EXTERNAL_DIALOGID_*
//                        -- DialogID is marked as in use
//                FALSE if DialogID is not marked as in use
//
//    History        4/23/97    jmazner        created
//
//-----------------------------------------------------------------------------

BOOL DialogIDAlreadyInUse( UINT uDlgID )
{
    if( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) ||
        (uDlgID > EXTERNAL_DIALOGID_MAXIMUM)     )
    {
        // this is an out-of-range ID, don't want to accept it.
        TraceMsg(TF_ICWCONN1,TEXT("ICWCONN1: DialogIDAlreadyInUse received an out of range DialogID, %d"), uDlgID);
        return TRUE;
    }
    // find which bit we need
    UINT uBitToCheck = uDlgID - EXTERNAL_DIALOGID_MINIMUM;
    
    UINT bitsInADword = 8 * sizeof(DWORD);

    UINT baseIndex = uBitToCheck / bitsInADword;

    ASSERT( (baseIndex < g_dwDialogIDListSize));

    DWORD dwBitMask = 0x1 << uBitToCheck%bitsInADword;

    BOOL fBitSet = g_pdwDialogIDList[baseIndex] & (dwBitMask);

    return( fBitSet );
}

//+----------------------------------------------------------------------------
//
//    Function    SetDialogIDInUse
//
//    Synopsis    Sets or clears the in use bit for a given DialogID
//
//    Arguments    uDlgID -- Dialog ID for which to change status
//                fInUse -- New value for the in use bit.
//
//    Returns        TRUE if status change succeeded.
//                FALSE if DialogID is out of range defined by EXTERNAL_DIALOGID_*
//
//    History        4/23/97    jmazner        created
//
//-----------------------------------------------------------------------------
BOOL SetDialogIDInUse( UINT uDlgID, BOOL fInUse )
{
    if( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) ||
        (uDlgID > EXTERNAL_DIALOGID_MAXIMUM)     )
    {
        // this is an out-of-range ID, don't want to accept it.
        TraceMsg(TF_ICWCONN1,TEXT("ICWCONN1: SetDialogIDInUse received an out of range DialogID, %d"), uDlgID);
        return FALSE;
    }
    // find which bit we need
    UINT uBitToCheck = uDlgID - EXTERNAL_DIALOGID_MINIMUM;
    
    UINT bitsInADword = 8 * sizeof(DWORD);

    UINT baseIndex = uBitToCheck / bitsInADword;

    ASSERT( (baseIndex < g_dwDialogIDListSize));

    DWORD dwBitMask = 0x1 << uBitToCheck%bitsInADword;


    if( fInUse )
    {
        g_pdwDialogIDList[baseIndex] |= (dwBitMask);
    }
    else
    {
        g_pdwDialogIDList[baseIndex] &= ~(dwBitMask);
    }


    return TRUE;
}

BOOL CheckForIEAKRestriction(HINSTANCE hInstance)
{
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwData = 0;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER,
        IEAK_RESTRICTION_REGKEY,&hkey))
    {
        dwSize = sizeof(dwData);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey,IEAK_RESTRICTION_REGKEY_VALUE,0,&dwType,
            (LPBYTE)&dwData,&dwSize))
        {
            if (dwData)
            {   
                bRC = TRUE;
            }
        }
   }

   if (hkey)
        RegCloseKey(hkey);

    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function    StartISPApp
//
//    Synopsis    Launch ISP App as a detached process and pass the ICW command line
//                to the ISP App.
//
//    Arguments   pszISPPath    - ISP Application command line, including the
//                                application name and additional arguments
//
//                pszCmdLine    - ICW command line arguments (without ICW executable
//                                name). It must not be NULL, but can be empty.
//
//
//    Returns     none
//
//    History     3/11/01     chunhoc     created
//
//-----------------------------------------------------------------------------
VOID
StartISPApp(
    IN LPTSTR pszISPPath,
    IN LPTSTR pszCmdLine)
{
    static const TCHAR  COMMANDLINE_FORMAT[] = TEXT("%s %s");
    
    LPTSTR              szCommandLine = NULL;
    int                 cchCommandLine;
    int                 i;


    cchCommandLine = sizeof(COMMANDLINE_FORMAT) / sizeof(TCHAR) +
        lstrlen(pszISPPath) + lstrlen(pszCmdLine) + 1;
    szCommandLine = (LPTSTR) LocalAlloc(LPTR, cchCommandLine * sizeof(TCHAR));
    if (szCommandLine == NULL)
    {
        goto cleanup;
    }
    i = wsprintf(szCommandLine, COMMANDLINE_FORMAT, pszISPPath, pszCmdLine);
    ASSERT(i <= cchCommandLine);

    MyExecute(szCommandLine);
    
cleanup:

    if (szCommandLine != NULL)
    {
        LocalFree(szCommandLine);
    }

}

//+----------------------------------------------------------------------------
//
//    Function    StartOOBE
//
//    Synopsis    Launch OOBE as a detached process and pass the ICW command line
//                and additional switch to OOBE.
//
//    Arguments   pszCmdLine    - ICW command line arguments (without ICW executable
//                                name). It must not be NULL, but can be empty.
//
//                pszOobeSwitch - additional OOBE specific switch. It must not be
//                                NULL, but can be empty.
//
//    Returns     none
//
//    History     3/11/01     chunhoc     created
//
//-----------------------------------------------------------------------------
VOID
StartOOBE(
    IN LPTSTR pszCmdLine,
    IN LPTSTR pszOobeSwitch)
{
    static const TCHAR  COMMANDLINE_FORMAT[] = TEXT("%s\\msoobe.exe %s %s");
    
    TCHAR               szOOBEPath[MAX_PATH];
    LPTSTR              szCommandLine = NULL;
    int                 cchCommandLine;
    int                 i;

    if (GetSystemDirectory(szOOBEPath, MAX_PATH) == 0)
    {
        goto cleanup;
    }

    lstrcat(szOOBEPath, TEXT("\\oobe"));
    
    cchCommandLine = sizeof(COMMANDLINE_FORMAT) / sizeof(TCHAR) +
        lstrlen(szOOBEPath) + lstrlen(pszCmdLine) + lstrlen(pszOobeSwitch) + 1;
    szCommandLine = (LPTSTR) LocalAlloc(LPTR, cchCommandLine * sizeof(TCHAR));
    if (szCommandLine == NULL)
    {
        goto cleanup;
    }
    i = wsprintf(szCommandLine, COMMANDLINE_FORMAT, szOOBEPath, pszCmdLine, pszOobeSwitch);
    ASSERT(i <= cchCommandLine);

    SetCurrentDirectory(szOOBEPath);

    MyExecute(szCommandLine);

cleanup:

    if (szCommandLine != NULL)
    {
        LocalFree(szCommandLine);
    }

}

//+----------------------------------------------------------------------------
//
//    Function    StartNCW
//
//    Synopsis    Launch NCW as a detached process and pass the shellnext to it.
//                NCW is supposed to handle shellnext and 
//                disable ICW smart start on successful configuration
//
//    Arguments   szShellNext - shellnext
//
//                szShellNextParams - argument to shellnext
//
//    Returns     none
//
//    History     3/11/01     chunhoc     created
//
//-----------------------------------------------------------------------------
VOID 
StartNCW(
    IN LPTSTR szShellNext,
    IN LPTSTR szShellNextParams)
{
    static const TCHAR  COMMANDLINE_FORMAT[] = 
        TEXT("%s\\rundll32.exe %s\\netshell.dll StartNCW %d,%s,%s");
    static const int    NCW_FIRST_PAGE = 0;
    static const int    NCW_MAX_PAGE_NO_LENGTH = 5;
    
    TCHAR               szSystemDir[MAX_PATH];
    int                 cchSystemDir;
    LPTSTR              szCommandLine = NULL;
    int                 cchCommandLine;
    int                 i;


    if ((cchSystemDir = GetSystemDirectory(szSystemDir, MAX_PATH)) == 0)
    {
        goto cleanup;
    }
    cchCommandLine = sizeof(COMMANDLINE_FORMAT) / sizeof(TCHAR) + cchSystemDir * 2 +
        lstrlen(szShellNext) + lstrlen(szShellNextParams) + NCW_MAX_PAGE_NO_LENGTH + 1;        
    szCommandLine = (LPTSTR) LocalAlloc(LPTR, cchCommandLine * sizeof(TCHAR));
    if (szCommandLine == NULL)
    {
        goto cleanup;
    }
    i = wsprintf(szCommandLine, COMMANDLINE_FORMAT, szSystemDir, szSystemDir,
        NCW_FIRST_PAGE, szShellNext, szShellNextParams);
    ASSERT(i <= cchCommandLine);

    MyExecute(szCommandLine);
    
cleanup:

    if (szCommandLine != NULL)
    {
        LocalFree(szCommandLine);
    }

}

//+----------------------------------------------------------------------------
//
//    Function    ChooseWizardDlgProc
//
//    Synopsis    Let user to determine if they want to run NCW or OEM
//                customized OOBE
//
//    Arguments   (standard DialogProc, see MSDN)
//
//    Returns     RUNWIZARD_CANCEL - if user doesn't want to run any wizard
//                RUNWIZARD_OOBE   - if user wants to run OEM customized OOBE
//                RUNWIZARD_NCW    - if user wants to run NCW
//
//    History     3/11/01     chunhoc     created
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
ChooseWizardDlgProc(
    IN HWND hwnd,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
   switch (uMsg)
   {
       case WM_INITDIALOG:
       {
           RECT rcDialog;

           CheckRadioButton(hwnd, IDC_RUN_OOBE, IDC_RUN_NCW, IDC_RUN_OOBE);

           if (GetWindowRect(hwnd, &rcDialog))
           {
               int cxWidth = rcDialog.right - rcDialog.left;
               int cyHeight = rcDialog.bottom - rcDialog.top;              
               int cxDialog = (GetSystemMetrics(SM_CXSCREEN) - cxWidth) / 2;
               int cyDialog = (GetSystemMetrics(SM_CYSCREEN) - cyHeight) / 2;

               MoveWindow(hwnd, cxDialog, cyDialog, cxWidth, cyHeight, FALSE);           
           }

           MakeBold(GetDlgItem(hwnd, IDC_CHOOSEWIZARD_TITLE), TRUE, FW_BOLD);

           return TRUE;
       }

       case WM_CTLCOLORSTATIC:
       {
           if (GetDlgCtrlID((HWND)lParam) == IDC_CHOOSEWIZARD_TITLE)
           {
                HBRUSH hbr = (HBRUSH) GetStockObject(WHITE_BRUSH);
                SetBkMode((HDC)wParam, TRANSPARENT);
                return (LRESULT)hbr;
           }
       }

       case WM_COMMAND:
       {
           WORD id = LOWORD(wParam);
           switch (id)
           {
              case IDOK:                 
                 if (IsDlgButtonChecked(hwnd, IDC_RUN_OOBE))
                 {
                     EndDialog(hwnd, RUNWIZARD_OOBE);                      
                 }
                 else
                 {
                     EndDialog(hwnd, RUNWIZARD_NCW);
                 }
                 
                 break;
              case IDCANCEL:
                
                 EndDialog(hwnd, RUNWIZARD_CANCEL);
                 break;

           }

           return TRUE;
       }

       case WM_DESTROY:
       {
            ReleaseBold(GetDlgItem(hwnd, IDC_CHOOSEWIZARD_TITLE));
            return 0;
       }
       
   }

   return(FALSE);
}

//+----------------------------------------------------------------------------
//
//    Function    MyExecute
//
//    Synopsis    Run a command line in a detached process
//
//    Arguments   szCommandLine - the command line to be executed
//
//    Returns     TRUE if the process is created; FALSE otherwise
//
//    History     3/27/01     chunhoc     created
//
//-----------------------------------------------------------------------------
BOOL
MyExecute(
    IN LPTSTR szCommandLine)
{
    PROCESS_INFORMATION pi;
    STARTUPINFO         si;
    BOOL                bRet;
    
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    if (CreateProcess(NULL,
                      szCommandLine,
                      NULL,
                      NULL,
                      FALSE,
                      0,
                      NULL,
                      NULL,
                      &si,
                      &pi) == TRUE)
    {        
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        bRet = TRUE;
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
    
}

LONG
MakeBold (
    IN HWND hwnd,
    IN BOOL fSize,
    IN LONG lfWeight)
{
    LONG hr = ERROR_SUCCESS;
    HFONT hfont = NULL;
    HFONT hnewfont = NULL;
    LOGFONT* plogfont = NULL;

    if (!hwnd) goto MakeBoldExit;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (!hfont)
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeBoldExit;
    }

    plogfont = (LOGFONT*)malloc(sizeof(LOGFONT));
    if (!plogfont)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto MakeBoldExit;
    }

    if (!GetObject(hfont,sizeof(LOGFONT),(LPVOID)plogfont))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeBoldExit;
    }

    plogfont->lfWeight = (int) lfWeight;

    if (!(hnewfont = CreateFontIndirect(plogfont)))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeBoldExit;
    }

    SendMessage(hwnd,WM_SETFONT,(WPARAM)hnewfont,MAKELPARAM(TRUE,0));
    
    
MakeBoldExit:

    if (plogfont)
    {
        free(plogfont);
    }

    return hr;
}

LONG
ReleaseBold(
    HWND hwnd)
{
    HFONT hfont = NULL;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (hfont) DeleteObject(hfont);
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\icwconn1.h ===
//**********************************************************************
// File name: icwconn1.h
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************

#ifdef WIN32
#define EXPORT
#else
#define EXPORT __export
#endif

#define MAX_STRING              128

#define WIZ97_TITLE_FONT_PTS    12

#define WM_MYINITDIALOG             WM_USER
#define WM_USER_DOWNLOADCOMPLETE    ((WM_USER) + 1)

#define CONNWIZAPPNAME TEXT("InternetConnectionWizardWClass")

#define SETUPPATH_NONE TEXT("current")
#define SETUPPATH_MANUAL TEXT("manual")
#define SETUPPATH_AUTO TEXT("automatic")
#define MAX_SETUPPATH_TOKEN 200
#define MAX_PROMO 64

#define SMART_QUITICW FALSE

// Trace flags
#define TF_ICWCONN1         0x00000010      // General ICWCONN1 stuff
#define TF_GENDLG           0x00000020
#define TF_ICWEXTSN         0x00000040

extern INT              _convert;
extern HINSTANCE        g_hInstance;
extern WIZARDSTATE      *gpWizardState;
extern BOOL             g_bHelpShown;
extern DWORD            *g_pdwDialogIDList;
extern DWORD            g_dwDialogIDListSize;
extern BOOL             gfQuitWizard;
extern BOOL             gfUserCancelled;
extern BOOL             gfUserBackedOut;
extern BOOL             gfUserFinished;
extern BOOL             gfBackedUp;
extern BOOL             gfReboot;
extern BOOL             g_bReboot;
extern BOOL             g_bRunOnce;
extern BOOL             g_bAllowCancel;
extern PAGEINFO         PageInfo[];
extern BOOL             g_fICWCONNUILoaded;
extern BOOL             g_fINETCFGLoaded;
extern BOOL             g_bRunDefaultHtm;  
extern TCHAR            g_szShellNext[];
extern TCHAR            g_szBrandedHTML[];

#define ICWSETTINGSPATH TEXT("Software\\Microsoft\\Internet Connection Wizard")
#define ICWDESKTOPCHANGED TEXT("DesktopChanged")



typedef DWORD (WINAPI *PFNIsSmartStart)(void);
typedef DWORD (WINAPI *PFNIsSmartStartEx)(LPTSTR, DWORD);

#define STR_BSTR    0
#define STR_OLESTR  1
#define BSTRFROMANSI(x) (BSTR)MakeWideStrFromAnsi((LPTSTR)(x), STR_BSTR)
#define ANSIFROMOLE(x) (LPTSTR)MakeAnsiStrFromWide((LPCWSTR)(x))

#define TO_ASCII(x) (TCHAR)((unsigned TCHAR)x + 0x30)
LPWSTR MakeWideStrFromAnsi (LPTSTR psz, BYTE bType);
LPTSTR MakeAnsiStrFromWide (LPCWSTR lpwstr);

int PASCAL WinMainT(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPTSTR lpCmdLine,int nCmdShow);
BOOL InitApplication(HANDLE hInstance);
BOOL InitInstance(HANDLE hInstance, int nCmdShow);

long FAR PASCAL EXPORT MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
long FAR PASCAL EXPORT DocWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL FAR PASCAL EXPORT About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef ICWDEBUG
void RemoveTempOfferDirectory (void);
#endif

void RemoveDownloadDirectory (void);
void DeleteDirectory (LPCTSTR szDirName);

BOOL DialogIDAlreadyInUse( UINT uDlgID );
BOOL SetDialogIDInUse( UINT uDlgID, BOOL fInUse );

BOOL WINAPI ConfigureSystem(HWND hDlg);
BOOL DoesUserHaveAdminPrivleges(HINSTANCE hInstance);
BOOL CheckForIEAKRestriction(HINSTANCE hInstance);
BOOL CheckForOemConfigFailure(HINSTANCE hInstance);
BOOL RunOemconfigIns();

// Function avalable in UTIL.CPP
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons);
int MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons);
void SetICWComplete(void);
void OlsFinish(void);
LPTSTR GetSz(WORD wszID);
BOOL ConfirmCancel(HWND hWnd);
BOOL Restart(HWND hWnd);
void Reboot(HWND hWnd);

// String conversion in UTIL.CPP
LPWSTR WINAPI A2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars);
LPTSTR WINAPI W2AHelper(LPTSTR lpa, LPCWSTR lpw, int nChars);

#ifndef A2WHELPER
#define A2WHELPER A2WHelper
#define W2AHELPER W2AHelper
#endif

#ifdef UNICODE
#define A2W(lpa)  (lpa)
#define W2A(lpw)  (lpw)
#else  // UNICODE
#define A2W(lpa) (\
        ((LPCSTR)lpa == NULL) ? NULL : (\
                _convert = (lstrlenA(lpa)+1),\
                A2WHELPER((LPWSTR) alloca(_convert*2), lpa, _convert)))

#define W2A(lpw) (\
        ((LPCWSTR)lpw == NULL) ? NULL : (\
                _convert = (lstrlenW(lpw)+1)*2,\
                W2AHELPER((LPTSTR) alloca(_convert), lpw, _convert)))
#endif // UNICODE

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))


// For events
HRESULT ConnectToICWConnectionPoint(
    IUnknown            *punkThis, 
    REFIID              riidEvent, 
    BOOL                fConnect, 
    IUnknown            *punkTarget, 
    DWORD               *pdwCookie, 
    IConnectionPoint    **ppcpOut
);

// In reboot.cpp
BOOL SetupForReboot(long lRebootType);
void DeleteStartUpCommand();

// In Desktop.cpp
void UpdateWelcomeRegSetting(BOOL    bSetBit);
BOOL GetCompletedBit();
void UndoDesktopChanges(HINSTANCE   hAppInst);
void QuickCompleteSignup();
void ICWCleanup();

void WINAPI FillWindowWithAppBackground(HWND hWndToFill, HDC hdc);
void FillDCRectWithAppBackground(LPRECT lpRectDC, LPRECT lpRectApp, HDC hdc);

#define MAX_PROMO 64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\icwextsn.cpp ===
/****************************************************************************
 *
 *  ICWESTSN.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1997
 *  All rights reserved
 *
 *  This module provides the implementation of the methods for
 *  the CICWExtension class.
 *
 *  05/14/98    donaldm     copied from INETCFG
 *
 ***************************************************************************/

#include "pre.h"
#include "icwconn.h"
#include "icwextsn.h"


//+----------------------------------------------------------------------------
//
//  Function    CICWExtension::AddExternalPage
//
//  Synopsis    Adds a page created via CreatePropertySheetPage to the main
//              property sheet/wizard.
//
//
//  Arguments   hPage -- page handle returned from CreatePropertySheetPage
//              uDlgID -- the dialog ID of the page to be added, as defined
//                        the resource file of the page's owner.
//
//
//  Returns     FALSE is the dlgID is already in use in the Wizard
//              TRUE otherwise
//
//  Notes:      PropSheet_AddPage does not return a usefull error code.  Thus
//              the assumption here is that every AddPage will succeed.  But, even
//              though it is not enforced by PropSheet_AddPage, every page in the
//              PropSheet must have a unique dialog ID.  Thus, if the uDlgID passed
//              in has previously been added to the PropSheet, we'll return FALSE.
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
BOOL CICWExtension::AddExternalPage( HPROPSHEETPAGE hPage, UINT uDlgID )
{
    LRESULT lResult= 0;

    if ( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) || (EXTERNAL_DIALOGID_MAXIMUM < uDlgID) )
    {
        TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: SetFirstLastPage: uDlgID %d is out of range!"), uDlgID);
        return( FALSE );
    }

    if( !DialogIDAlreadyInUse(uDlgID) )
    {
        SetDialogIDInUse( uDlgID, TRUE );
        lResult = PropSheet_AddPage(m_hWizardHWND, hPage);
        TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: PS_AddPage DlgID %d"), uDlgID);

        return(TRUE);
    }
    else
    {
        TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: AddExternalPage DlgID %d is already in use, rejecting this page!"), uDlgID);
        return(FALSE);
    }
}

//+----------------------------------------------------------------------------
//
//  Function    CICWExtension::RemoveExternalPage
//
//  Synopsis    Removes a page added via ::AddExternalPage to the main
//              property sheet/wizard.
//
//
//  Arguments   hPage -- page handle returned from CreatePropertySheetPage
//              uDlgID -- the dialog ID of the page to be removed, as defined
//                        the resource file of the page's owner.
//
//
//  Returns     FALSE is the dlgID is not already in use in the Wizard
//              TRUE otherwise
//
//  Notes:      PropSheet_RemovePage does not return a usefull error code.  Thus
//              the assumption here is that every RemovePage will succeed if that
//              dialog id is currently in the property sheet
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
BOOL CICWExtension::RemoveExternalPage( HPROPSHEETPAGE hPage, UINT uDlgID )
{
    if ( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) || (EXTERNAL_DIALOGID_MAXIMUM < uDlgID) )
    {
        TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: SetFirstLastPage: uDlgID %d is out of range!"), uDlgID);
        return( FALSE );
    }

    if( DialogIDAlreadyInUse(uDlgID) )
    {
        SetDialogIDInUse( uDlgID, FALSE );
        PropSheet_RemovePage(m_hWizardHWND, NULL, hPage);
        TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: propmgr: PS_RemovePage DlgID %d"), uDlgID);

        return(TRUE);
    }
    else
    {
        TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: RemoveExternalPage: DlgID %d was not marked as in use!"), uDlgID);
        return(FALSE);
    }
}

//+----------------------------------------------------------------------------
//
//  Function    CICWExtension::ExternalCancel
//
//  Synopsis    Notifies the wizard that the user has cancelled while in the
//              apprentice pages
//
//
//  Arguments   uCancelType -- tells the wizard whether it should immediately
//                              quit out, or whether it should show the confirmation
//                              dialog (as though the user had hit Cancel within the
//                              wizard itself.)
//
//
//  Returns     TRUE if we're about to exit the wizard
//              FALSE if not.
//
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
BOOL CICWExtension::ExternalCancel( CANCELTYPE uCancelType )
{
    TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: propmgr.cpp: received ExternalCancel callback"));
    switch( uCancelType )
    {
        case CANCEL_PROMPT:
            gfUserCancelled = (MsgBox(m_hWizardHWND,
                                      IDS_QUERYCANCEL,
                                      MB_ICONQUESTION,MB_YESNO |  MB_DEFBUTTON2) == IDYES);
    
            if( gfUserCancelled )
            {
                PropSheet_PressButton( m_hWizardHWND, PSBTN_CANCEL );
                gfQuitWizard = TRUE;
                return( TRUE );
            }
            else
            {
                return( FALSE );
            }
            break;

        case CANCEL_SILENT:
            PropSheet_PressButton( m_hWizardHWND, PSBTN_CANCEL );
            gfQuitWizard = TRUE;
            return( TRUE );
            break;

        case CANCEL_REBOOT:
            PropSheet_PressButton( m_hWizardHWND, PSBTN_CANCEL );
            gfQuitWizard = TRUE;
            gpWizardState->fNeedReboot = TRUE;
            return( TRUE );
            break;

        default:
            TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: ExternalCancel got an unkown CancelType!"));
            return( FALSE );
    }
    
}

//+----------------------------------------------------------------------------
//
//  Function    CICWExtension::SetFirstLastPage
//
//  Synopsis    Lets the apprentice notify the wizard of the dialog IDs of the
//              first and last pages in the apprentice
//
//
//  Arguments   uFirstPageDlgID -- DlgID of first page in apprentice.
//              uLastPageDlgID -- DlgID of last page in apprentice
//
//
//  Returns     FALSE if the parameters passed in are out of range
//              TRUE if the update succeeded.
//
//  Notes:      If either variable is set to 0, the function will not update
//              that information, i.e. a value of 0 means "ignore me".  If both
//              variables are 0, the function immediately returns FALSE.
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
BOOL CICWExtension::SetFirstLastPage(UINT uFirstPageDlgID, UINT uLastPageDlgID)
{

    // validation code galore!
    if( (0 == uFirstPageDlgID) && (0 == uLastPageDlgID) )
    {
        TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: SetFirstLastPage: both IDs are 0!"));
        return( FALSE );
    }

    if( (0 != uFirstPageDlgID) )
    {
        if ( (uFirstPageDlgID < EXTERNAL_DIALOGID_MINIMUM) || (EXTERNAL_DIALOGID_MAXIMUM < uFirstPageDlgID) )
        {
            TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: SetFirstLastPage: uFirstPageDlgID %d is out of range!"), uFirstPageDlgID);
            return( FALSE );
        }

        if( !DialogIDAlreadyInUse(uFirstPageDlgID) )
        {
            TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: SetFirstLastPage: uFirstPageDlgID %d not marked as in use!"), uFirstPageDlgID);
            return( FALSE );
        }
    }

    if( (0 != uLastPageDlgID) )
    {
        if ( (uLastPageDlgID < EXTERNAL_DIALOGID_MINIMUM) || (EXTERNAL_DIALOGID_MAXIMUM < uLastPageDlgID) )
        {
            TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: SetFirstLastPage: uLastPageDlgID %d is out of range!"), uFirstPageDlgID);
            return( FALSE );
        }

        if( !DialogIDAlreadyInUse(uLastPageDlgID) )
        {
            TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: SetFirstLastPage: uLastPageDlgID %d not marked as in use!"), uFirstPageDlgID);
            return( FALSE );
        }
    }
    
    if( 0 != uFirstPageDlgID )
        g_uICWCONNUIFirst = uFirstPageDlgID;
    if( 0 != uLastPageDlgID )
        g_uICWCONNUILast = uLastPageDlgID;
    TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: SetFirstLastPage: updating mail, first = %d, last = %d"),
        uFirstPageDlgID, uLastPageDlgID);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWExtension::QueryInterface
//
//  Synopsis    This is the standard QI, with support for
//              IID_Unknown, IICW_Extension and IID_ICW50Apprentice
//              (Taken from Inside COM, chapter 7)
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
HRESULT CICWExtension::QueryInterface( REFIID riid, void** ppv )
{

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    // IID_IICW50Apprentice
    if (IID_IICW50Apprentice == riid)
        *ppv = (void *)(IICW50Apprentice *)this;
    // IID_IICWExtension
    else if (IID_IICW50Extension == riid)
        *ppv = (void *)(IICW50Extension *)this;
    // IID_IUnknown
    else if (IID_IUnknown == riid)
        *ppv = (void *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function    CICWExtension::AddRef
//
//  Synopsis    This is the standard AddRef
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
ULONG CICWExtension::AddRef( void )
{
    TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: CICWExtension::AddRef called %d"), m_lRefCount + 1);
    return InterlockedIncrement(&m_lRefCount) ;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWExtension::Release
//
//  Synopsis    This is the standard Release
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
ULONG CICWExtension::Release( void )
{

    ASSERT( m_lRefCount > 0 );

    InterlockedDecrement(&m_lRefCount);

    TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: CICWExtension::Release called %d"), m_lRefCount);

    if( 0 == m_lRefCount )
    {
        delete( this );
        return( 0 );
    }
    else
    {
        return( m_lRefCount );
    }
    
}


//+----------------------------------------------------------------------------
//
//  Function    CICWExtension::CICWExtension
//
//  Synopsis    The constructor.  Initializes member variables to NULL.
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
CICWExtension::CICWExtension( void )
{
    TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: CICWExtension constructor called"));
    m_lRefCount = 0;
    m_hWizardHWND = NULL;
}


//+----------------------------------------------------------------------------
//
//  Function    CICWExtension::CICWExtension
//
//  Synopsis    The constructor.  Since there was no fancy initialization,
//              there's nothing to do here.
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
CICWExtension::~CICWExtension( void )
{
    TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: CICWExtension destructor called with ref count of %d"), m_lRefCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\icwext.cpp ===
/******************************************************

  ICWEXT.CPP 

  Contains definitions for global variables and
  functions used for including wizard pages from ICWCONN.DLL

 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1996
 *  All rights reserved


  5/14/98   donaldm     created

 ******************************************************/

#include "pre.h"
#include "initguid.h"   // Make DEFINE_GUID declare an instance of each GUID
#include "icwacct.h"
#include "icwconn.h"
#include "webvwids.h"       // GUIDS for the ICW WEBVIEW class
#include "icwextsn.h"
#include "icwcfg.h"

extern BOOL g_bManualPath;     
extern BOOL g_bLanPath;     

IICW50Apprentice    *gpICWCONNApprentice = NULL;    // ICWCONN apprentice object
IICWApprenticeEx     *gpINETCFGApprentice = NULL;    // ICWCONN apprentice object

//+----------------------------------------------------------------------------
//
//  Function    LoadICWCONNUI
//
//  Synopsis    Loads in the ICWCONN's apprentice pages
//
//              If the UI has previously been loaded, the function will simply
//              update the Next and Back pages for the apprentice.
//
//              Uses global variable g_fICWCONNUILoaded.
//
//
//  Arguments   hWizHWND -- HWND of main property sheet
//              uPrevDlgID -- Dialog ID apprentice should go to when user leaves
//                            apprentice by clicking Back
//              uNextDlgID -- Dialog ID apprentice should go to when user leaves
//                            apprentice by clicking Next
//              dwFlags -- Flags variable that should be passed to
//                          IICWApprentice::AddWizardPages
//
//
//  Returns     TRUE if all went well
//              FALSE otherwise
//
//  History     5/13/98 donaldm     adapted from INETCFG code
//
//-----------------------------------------------------------------------------

BOOL LoadICWCONNUI( HWND hWizHWND, UINT uPrevDlgID, UINT uNextDlgID, DWORD dwFlags )
{
    HRESULT hResult = E_NOTIMPL;

    if( g_fICWCONNUILoaded )
    {
        ASSERT( g_pCICWExtension );
        ASSERT( gpICWCONNApprentice );

        TraceMsg(TF_ICWEXTSN, TEXT("LoadICWCONNUI: UI already loaded, just reset first (%d) and last (%d) pages"),
                uPrevDlgID, uNextDlgID);
                
        // Set the State data for the external pages
        hResult = gpICWCONNApprentice->SetStateDataFromExeToDll( &gpWizardState->cmnStateData);
        hResult = gpICWCONNApprentice->ProcessCustomFlags(dwFlags);
        hResult = gpICWCONNApprentice->SetPrevNextPage( uPrevDlgID, uNextDlgID );

        goto LoadICWCONNUIExit;
    }


    if( !hWizHWND )
    {
        TraceMsg(TF_ICWEXTSN, TEXT("LoadICWCONNUI got a NULL hWizHWND!"));
        return FALSE;
    }

    // Demand load the ICWCONN apprentice DLL, so we can dynamically update it
    if (!gpICWCONNApprentice)
    {
        HRESULT        hr;

        // Load the ICWCONN OLE in-proc server
        hr = CoCreateInstance(CLSID_ApprenticeICWCONN,NULL,CLSCTX_INPROC_SERVER,
                              IID_IICW50Apprentice,(LPVOID *)&gpICWCONNApprentice);

        if ( (!SUCCEEDED(hr) || !gpICWCONNApprentice) )
        {
            g_fICWCONNUILoaded = FALSE;
            TraceMsg(TF_ICWEXTSN, TEXT("Unable to CoCreateInstance on IID_IICW50Apprentice!  hr = %x"), hr);
            
            return FALSE;
        }
    }
    
    
    ASSERT(gpICWCONNApprentice);
    if( NULL == g_pCICWExtension )
    {
        TraceMsg(TF_ICWEXTSN, TEXT("Instantiating ICWExtension and using it to initialize ICWCONN's IICW50Apprentice"));
        g_pCICWExtension = new( CICWExtension );
        g_pCICWExtension->AddRef();
        g_pCICWExtension->m_hWizardHWND = hWizHWND;
        gpICWCONNApprentice->Initialize( g_pCICWExtension );
        
        // Initialize the DLL's state data before adding the pages.
        gpICWCONNApprentice->SetStateDataFromExeToDll( &gpWizardState->cmnStateData);
    }

    
    // Add the DLL's wizard pages
    hResult = gpICWCONNApprentice->AddWizardPages(dwFlags);

    if( !SUCCEEDED(hResult) )
    {
        goto LoadICWCONNUIExit;
    }

    hResult = gpICWCONNApprentice->SetPrevNextPage( uPrevDlgID, uNextDlgID );


LoadICWCONNUIExit:
    if( SUCCEEDED(hResult) )
    {
        g_fICWCONNUILoaded = TRUE;
        return TRUE;
    }
    else
    {
        TraceMsg(TF_ICWEXTSN, TEXT("LoadICWCONNUI failed with (hex) hresult %x"), hResult);
        return FALSE;
    }
}



//+----------------------------------------------------------------------------
//
//  Function    LoadInetCfgUI
//
//  Synopsis    Loads in the InetCfg's apprentice pages
//
//              If the UI has previously been loaded, the function will simply
//              update the Next and Back pages for the apprentice.
//
//              Uses global variable g_fICWCONNUILoaded.
//
//
//  Arguments   hWizHWND -- HWND of main property sheet
//              uPrevDlgID -- Dialog ID apprentice should go to when user leaves
//                            apprentice by clicking Back
//              uNextDlgID -- Dialog ID apprentice should go to when user leaves
//                            apprentice by clicking Next
//              dwFlags -- Flags variable that should be passed to
//                          IICWApprentice::AddWizardPages
//
//
//  Returns     TRUE if all went well
//              FALSE otherwise
//
//  History     5/13/98 donaldm     adapted from INETCFG code
//              10/5/00 seanch      No longer want to see the Mail & News stuff
//
//-----------------------------------------------------------------------------

BOOL LoadInetCfgUI( HWND hWizHWND, UINT uPrevDlgID, UINT uNextDlgID, DWORD dwFlags )
{
    HRESULT hResult = E_NOTIMPL;

    dwFlags |= (WIZ_USE_WIZARD97 | WIZ_NO_MAIL_ACCT | WIZ_NO_NEWS_ACCT);

    if( g_fINETCFGLoaded )
    {
        ASSERT( g_pCINETCFGExtension );
        ASSERT( gpINETCFGApprentice );

        TraceMsg(TF_ICWEXTSN, TEXT("LoadICWCONNUI: UI already loaded, just reset first (%d) and last (%d) pages"),
                uPrevDlgID, uNextDlgID);
        hResult = gpINETCFGApprentice->ProcessCustomFlags(dwFlags);
        //need to watch the retrun here since user may cancel out of installing files
        //and we don't want to hide the failure if the do.
        if( !SUCCEEDED(hResult) )
            goto LoadInetCfgUIExit;
        hResult = gpINETCFGApprentice->SetPrevNextPage( uPrevDlgID, uNextDlgID );
        goto LoadInetCfgUIExit;
    }


    if( !hWizHWND )
    {
        TraceMsg(TF_ICWEXTSN, TEXT("LoadICWCONNUI got a NULL hWizHWND!"));
        return FALSE;
    }

    // Demand load the ICWCONN apprentice DLL, so we can dynamically update it
    if (!gpINETCFGApprentice)
    {
        HRESULT        hr;

        // Load the ICWCONN OLE in-proc server
        hr = CoCreateInstance(/*CLSID_ApprenticeAcctMgr*/ CLSID_ApprenticeICW,NULL,CLSCTX_INPROC_SERVER,
                              IID_IICWApprenticeEx,(LPVOID *)&gpINETCFGApprentice);

        if ( (!SUCCEEDED(hr) || !gpINETCFGApprentice) )
        {
            g_fICWCONNUILoaded = FALSE;
            TraceMsg(TF_ICWEXTSN, TEXT("Unable to CoCreateInstance on IID_IICW50Apprentice!  hr = %x"), hr);
            
            return FALSE;
        }
    }
    
    
    ASSERT(gpINETCFGApprentice);
    if( NULL == g_pCINETCFGExtension )
    {
        TraceMsg(TF_ICWEXTSN, TEXT("Instantiating ICWExtension and using it to initialize ICWCONN's IICW50Apprentice"));
        g_pCINETCFGExtension = new( CICWExtension );
        g_pCINETCFGExtension->AddRef();
        g_pCINETCFGExtension->m_hWizardHWND = GetParent(hWizHWND);
        gpINETCFGApprentice->SetDlgHwnd(hWizHWND);
        gpINETCFGApprentice->Initialize((struct IICWExtension *)g_pCINETCFGExtension);
    }

    hResult = gpINETCFGApprentice->AddWizardPages(dwFlags | WIZ_USE_WIZARD97);

    if( !SUCCEEDED(hResult) )
    {
        goto LoadInetCfgUIExit;
    }

    hResult = gpINETCFGApprentice->SetPrevNextPage( uPrevDlgID, uNextDlgID );


LoadInetCfgUIExit:
    if( SUCCEEDED(hResult) )
    {
        g_fINETCFGLoaded = TRUE;
        return TRUE;
    }
    else
    {
        // Check if we are in /smartreboot mode, if so, don't add icw to runonce
        // to avoid infinite reboot.
        if (gpINETCFGApprentice && !g_bManualPath && !g_bLanPath)
        {
            HKEY    hkey;

            // Verify that we really changed the desktop
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                              ICWSETTINGSPATH,
                                              0,
                                              KEY_ALL_ACCESS,
                                              &hkey))
            {
                DWORD   dwICWErr = 0;    
                DWORD   dwTmp = sizeof(DWORD);
                DWORD   dwType = 0;
        
                RegQueryValueEx(hkey, 
                                ICW_REGKEYERROR, 
                                NULL, 
                                &dwType,
                                (LPBYTE)&dwICWErr, 
                                &dwTmp);
                RegDeleteValue(hkey, ICW_REGKEYERROR);
                RegCloseKey(hkey);
        
                // Bail if the desktop was not changed by us
                if(dwICWErr & ICW_CFGFLAG_SMARTREBOOT_MANUAL)
                {
                    ShowWindow(GetParent(hWizHWND), FALSE);

                    Reboot(GetParent(hWizHWND));
                    gfQuitWizard = TRUE;

                }            
            }

        }
        TraceMsg(TF_ICWEXTSN, TEXT("LoadInetCfgUIExit failed with (hex) hresult %x"), hResult);
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\icwsupr.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************
#include "pre.h"

typedef DWORD (WINAPI *PFNGETLAYOUT)(HDC);                   // gdi32!GetLayout
typedef DWORD (WINAPI *PFNSETLAYOUT)(HDC, DWORD);            // gdi32!SetLayout

TCHAR       g_szICWGrpBox[] = TEXT("ICW_GROUPBOX");
TCHAR       g_szICWStatic[] = TEXT("ICW_STATIC");
WNDPROC     lpfnOriginalGroupBoxWndProc;
WNDPROC     lpfnOriginalStaticWndProc;

int GetGroupBoxTextRect
(
    LPTSTR  lpszText,
    int     cch,
    HDC     hdc,
    LPRECT  lpGroupBoxRect
)
{
    int     dy;
    
    // Compute the rectangle needed to draw the group box text
    dy = DrawText(hdc, lpszText, cch, lpGroupBoxRect, DT_CALCRECT|DT_LEFT|DT_SINGLELINE);

    // Adjust rectangle for the group box text
    lpGroupBoxRect->left += 4;
    lpGroupBoxRect->right += 4;
    lpGroupBoxRect->bottom = lpGroupBoxRect->top + dy;
    
    return dy;
}    

#ifndef LAYOUT_RTL
#define LAYOUT_RTL                       0x00000001 // Right to left
//#else
//#error "LAYOUT_RTL is already defined in wingdi.h.remove local define"
#endif // LAYOUT_RTL

LRESULT CALLBACK ICWGroupBoxWndProc
(
    HWND hWnd,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
)
{
    if(gpWizardState->cmnStateData.bOEMCustom)
    {
        switch (uMessage)
        {
            // Handle the case where the text in the combo box title is being changed.
            // When the text is being changed, we first have to erase the existing
            // text with the background bitmap, and then allow the new text to
            // get set, and then repaint with the new text.
            case WM_SETTEXT:
            {   
                HFONT   hfont, hOldfont;    
                HDC     hdc = GetDC(hWnd);
                RECT    rcGroupBoxText, rcUpdate;
                int     cch;
                long    lStyle;
                TCHAR   szText[256];
                
                // Get the existing text to cover over
                cch = GetWindowText(hWnd, szText, ARRAYSIZE(szText));
                
                // Set the font for drawing the group box text
                if((hfont = (HFONT)SendMessage(hWnd, WM_GETFONT, 0, 0L)) != NULL)
                    hOldfont = (HFONT)SelectObject(hdc, hfont);
                
                // Compute the group box text area
                GetClientRect(hWnd, (LPRECT)&rcGroupBoxText);
                GetGroupBoxTextRect(szText, cch, hdc, &rcGroupBoxText);
                
                // Ccmpute the area to be updated
                rcUpdate = rcGroupBoxText;
                MapWindowPoints(hWnd, gpWizardState->cmnStateData.hWndApp, (LPPOINT)&rcUpdate, 2);
                FillDCRectWithAppBackground(&rcGroupBoxText, &rcUpdate, hdc);
                
                // Cleanup the DC
                SelectObject(hdc, hOldfont);
                ReleaseDC(hWnd, hdc);
                
                // Finish up by setting the new text, and updating the window                
                if((lStyle = GetWindowLong(hWnd, GWL_STYLE)) & WS_VISIBLE)
                {
                    // Call the original window handler to set the text, but prevent the
                    // window from updating. This is necessary because all painting of
                    // the window must be done from the WM_PAINT below
                    SetWindowLong(hWnd, GWL_STYLE, lStyle & ~(WS_VISIBLE));
                    CallWindowProc(lpfnOriginalGroupBoxWndProc, hWnd, uMessage, wParam, lParam);
                    SetWindowLong(hWnd, GWL_STYLE, GetWindowLong(hWnd, GWL_STYLE)|WS_VISIBLE);
                    
                    // Force the window to be repainted
                    RedrawWindow(hWnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_UPDATENOW);
                }                    
                return TRUE;
            }
                            
            case WM_PAINT:
            {
                PAINTSTRUCT ps;
                HDC         hdc;
                RECT        rcClient;
                RECT        rcGroupBoxText;
                RECT        rcUpdate;
                int         cch;
                TCHAR       szTitle[256];
                int         dy;

                HFONT       hfont, hOldfont;
                int         iOldBkMode;
                HBRUSH      hOldBrush;
                
                hdc = BeginPaint(hWnd, &ps); 
            
            
                GetClientRect(hWnd, (LPRECT)&rcClient);
                rcGroupBoxText = rcClient;

                // Set the font for drawing the group box text
                if((hfont = (HFONT)SendMessage(hWnd, WM_GETFONT, 0, 0L)) != NULL)
                    hOldfont = (HFONT)SelectObject(hdc, hfont);

                // Get the group box text that we need to draw, and compute it rectangle
                cch = GetWindowText(hWnd, szTitle, ARRAYSIZE(szTitle));
                dy = GetGroupBoxTextRect(szTitle, cch, hdc, &rcGroupBoxText);

                // Adjust rectangle for the group box outline
                rcClient.top += dy/2;
                rcClient.right--;
                rcClient.bottom--;
                DrawEdge(hdc, &rcClient, EDGE_ETCHED, BF_ADJUST| BF_RECT);
                
                // Erase the text area with the app background bitmap to cover over
                // the edge drawn above
                rcUpdate = rcGroupBoxText;
                MapWindowPoints(hWnd, gpWizardState->cmnStateData.hWndApp, (LPPOINT)&rcUpdate, 2);
                FillDCRectWithAppBackground(&rcGroupBoxText, &rcUpdate, hdc);
                
                // Set up to draw the text
                hOldBrush = (HBRUSH)SelectObject(hdc, GetStockObject(NULL_BRUSH));
                iOldBkMode = SetBkMode(hdc, TRANSPARENT);
                SetTextColor(hdc, gpWizardState->cmnStateData.clrText);
                DrawText(hdc, szTitle, cch, (LPRECT) &rcGroupBoxText, DT_LEFT|DT_SINGLELINE);

                // Cleanup GDI Objects
                SelectObject(hdc, hOldfont);
                SelectObject(hdc, hOldBrush);
                SetBkMode(hdc, iOldBkMode);

                EndPaint(hWnd, &ps); 
                break;
            }
            default:
                // Let the original proc handle other messages
                return CallWindowProc(lpfnOriginalGroupBoxWndProc, hWnd, uMessage, wParam, lParam);
        }  
        
        // Call the default window proc handler if necessary
        return DefWindowProc(hWnd, uMessage, wParam, lParam);
    }
    else
    {
        // Not in modeless mode, so just pass through the messages
        return CallWindowProc(lpfnOriginalGroupBoxWndProc, hWnd, uMessage, wParam, lParam);
    }
}    

DWORD Mirror_GetLayout( HDC hdc )
{
    DWORD dwRet=0;
    static PFNGETLAYOUT pfnGetLayout=NULL;

    if( NULL == pfnGetLayout )
    {
        HMODULE hmod = GetModuleHandleA("GDI32");

        if( hmod )
            pfnGetLayout = (PFNGETLAYOUT)GetProcAddress(hmod, "GetLayout");
    }

    if( pfnGetLayout )
        dwRet = pfnGetLayout( hdc );

    return dwRet;
}

DWORD Mirror_SetLayout( HDC hdc , DWORD dwLayout )
{
    DWORD dwRet=0;
    static PFNSETLAYOUT pfnSetLayout=NULL;

    if( NULL == pfnSetLayout )
    {
        HMODULE hmod = GetModuleHandleA("GDI32");

        if( hmod )
            pfnSetLayout = (PFNSETLAYOUT)GetProcAddress(hmod, "SetLayout");
    }

    if( pfnSetLayout )
        dwRet = pfnSetLayout( hdc , dwLayout );

    return dwRet;
}

LRESULT CALLBACK ICWStaticWndProc
(
    HWND hWnd,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
)
{
    switch (uMessage)
    {
        case WM_SETTEXT:
        {   
            // only handle this case for OEMcustom mode
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                FillWindowWithAppBackground(hWnd, NULL);
            }                
            return CallWindowProc(lpfnOriginalStaticWndProc, hWnd, uMessage, wParam, lParam);
        }
            
        case WM_PAINT:
        {
            // This case gets handled for oem custom and regular mode
            // since we have to paint the icon
            if (GetWindowLong(hWnd, GWL_STYLE) & SS_ICON)
            {
                PAINTSTRUCT ps;
                HDC         hdc;
                int        iIconID;
                HICON       hIcon;
                DWORD       dwLayout= 0L;
               
                // Get the name of the icon.  
                iIconID = (int)GetWindowLongPtr(hWnd, GWLP_USERDATA);
                       
                if (iIconID)
                {
                    // Load the icon by name.  It is stored with the next, not
                    // an integer value
                    hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(iIconID));
                
                    hdc = BeginPaint(hWnd, &ps); 
            
                    if(gpWizardState->cmnStateData.bOEMCustom)
                    {
                        // Fill in the window with the background color
                        FillWindowWithAppBackground(hWnd, hdc);
                    }
                        
                    // Draw the icon
                    // Disable mirroring before we draw
                    dwLayout = Mirror_GetLayout(hdc);
                    Mirror_SetLayout(hdc, dwLayout & ~LAYOUT_RTL);
                    DrawIcon(hdc, 0, 0, hIcon);
                    Mirror_SetLayout(hdc, dwLayout);
                
                    EndPaint(hWnd, &ps); 
                }
                break;
            }
            else
            {
                return CallWindowProc(lpfnOriginalStaticWndProc, hWnd, uMessage, wParam, lParam);
            }                    
        }
        default:
            // Let the original proc handle other messages
            return CallWindowProc(lpfnOriginalStaticWndProc, hWnd, uMessage, wParam, lParam);
    }   
    return DefWindowProc(hWnd, uMessage, wParam, lParam);
}    

BOOL SuperClassICWControls
(
    void
)
{
    WNDCLASS    WndClass;
    
    ZeroMemory (&WndClass, sizeof(WNDCLASS));
    // Create a Superclass for ICW_TEXT
    GetClassInfo(NULL,
                 TEXT("STATIC"),   // address of class name string
                 &WndClass);   // address of structure for class data
    WndClass.style |= CS_GLOBALCLASS;                 
    WndClass.hInstance = g_hInstance;
    WndClass.lpszClassName = g_szICWStatic;
    lpfnOriginalStaticWndProc = WndClass.lpfnWndProc;
    WndClass.lpfnWndProc = ICWStaticWndProc;
    
    if (!RegisterClass(&WndClass))
        return FALSE;
    
    ZeroMemory (&WndClass, sizeof(WNDCLASS));
    // Create a Superclass for ICW_GROUPBOX
    GetClassInfo(NULL,
                 TEXT("BUTTON"),   // address of class name string
                 &WndClass);   // address of structure for class data
    WndClass.style |= CS_GLOBALCLASS;                 
    WndClass.hInstance = g_hInstance;
    WndClass.lpszClassName = g_szICWGrpBox;
    lpfnOriginalGroupBoxWndProc = WndClass.lpfnWndProc;
    WndClass.lpfnWndProc = ICWGroupBoxWndProc;
    
    return (RegisterClass(&WndClass));
}

BOOL RemoveICWControlsSuperClass
(
    void
)
{
    UnregisterClass(g_szICWGrpBox, g_hInstance);
    UnregisterClass(g_szICWStatic, g_hInstance);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\icwdebug.cpp ===
#include "pre.h"
#include <stdio.h>
#include <tchar.h>
#include "lookups.h"
#include "icwextsn.h"

//Defines
#define TEMP_OFFER_DIR             TEXT("tempoffer\\")
#define DOWNLOAD_OFFER_DIR         TEXT("download\\")
#define VALID_MAIN_OFFER_FILE_TYPE TEXT(".cab")
#define VALID_OFFER_INFO_FILE_TYPE TEXT(".csv")
#define VALID_OFFER_INFO_FILE_NAME TEXT("offers50.csv")
#define VALID_ICW_INFO_FILE_NAME   TEXT("ispinfo.csv")
#define ISPINFO_CSV_HEADER         "Name,OfferID,Icon,LocalHtm,OEMSpecialIcon,OEMSpecialHtm,ISPFile,CFGFlag,UIFlag,BillingForm,PayCSV,GUID,MIRS,LCID\r\n"
#define INFO_FILE_DELIMITER        TEXT(',')
#define BROWSE_FILTER              TEXT("CAB Files(*.cab)\0*.cab\0\0")
#define ICWDEBUG_KEY               TEXT("software\\microsoft\\Icwdebug")
#define CORPNET_VAL                TEXT("CorpNet")
#define DBGPATH_VAL                TEXT("DebugPath")
#define ISPFILE_VAL                TEXT("IspFile")
#define URL_VAL                    TEXT("Url")
#define MAX_INT_STR                10
#define CAB_PATH_INDEX             7
#define NUMBER_OF_FIELDS           21

//Prototypes
void InitListView           (HWND   hwndDlg, int    iListViewCtrlID);
void SetupOfferToDebug      (HWND   hwndDlg, int    iListViewCtrlID);
void TryToUpdateListBox     (HWND   hwndDlg, int    iListViewCtrlID, int   iEditCtrlID);
void AddOffersToListView    (HWND   hwndLV,  TCHAR* pFileBuff,       DWORD dwBuffSize);
void Browse                 (HWND   hwndDlg);
BOOL WriteCSVLine           (HWND   hwndLV,  int    iSelItem,        HFILE hFile);
BOOL ValidateOfferFile      (TCHAR* pszFile, TCHAR* pszValidExt);
BOOL ExpandOfferFileIntoDir (TCHAR* pszFile, TCHAR* pszDir);

//External prototypes
extern BOOL fdi               (char* cabinet_fullpath, char* directory);
extern UINT GetDlgIDFromIndex (UINT  uPageIndex);

typedef struct IspStruct
{
    TCHAR szISPCab      [MAX_PATH];
    TCHAR szMIRS        [MAX_PATH];
    TCHAR szISPName     [MAX_PATH];
    TCHAR szIcon        [MAX_PATH];
    TCHAR szOEMTeaseHTM [MAX_PATH];
    TCHAR szOEMButton   [MAX_PATH];
    TCHAR szLocalHtm    [MAX_PATH];
    TCHAR szIspFile     [MAX_PATH];
    TCHAR szBilling     [MAX_PATH];
    TCHAR szPayCsv      [MAX_PATH];
    TCHAR szCab         [MAX_PATH];
    UINT  dwUiFlag;
    UINT  dwLCID;
    UINT  dwCfgFlag;

}ISPSTRUCT;

TCHAR* g_pszaHeader[8] = {TEXT("ISP Name     "),
                          TEXT("Country      "),
                          TEXT("Langauage    "),
                          TEXT("Area Code    "),
                          TEXT("Platform     "),
                          TEXT("Product Code "),
                          TEXT("Promo Code   "),
                          TEXT("Oem          ")};

int g_uLastLVSel = -1;

//CountryID to friendly name resolution
inline TCHAR* LookupCountry (TCHAR* pszCid)
{
	int iCid = _ttoi(pszCid);
	int i;

	for (i = 0; i < CIDLEN; i++)
	{
		if(iCid == aryCIDLookup[i].iCID)
			return aryCIDLookup[i].pszCountry;
	}
	return NULL;
}

//LCID to friendly name resolution
inline TCHAR* LookupLanguage (TCHAR* pszLcid)
{
	int iLcid = _ttoi(pszLcid);

	for (int i = 0; i < LCIDLEN; i++)
	{
		if(iLcid == aryLCIDLookup[i].iLCID)
			return aryLCIDLookup[i].pszLcid;
	}
	return NULL;
}

//Platform to friendly name resolution
inline TCHAR* LookupPlatform (TCHAR* pszOSType, TCHAR* pszOSArch, TCHAR* pszOSMajor)
{
	int    iOsType  = _ttoi(pszOSType);
	int    iOsArch  = _ttoi(pszOSArch);
#ifdef UNICODE
        CHAR   szTmp[MAX_PATH];
        wcstombs(szTmp, pszOSMajor, MAX_PATH);
	double fOsMajor = atof(szTmp);
#else
	double fOsMajor = atof(pszOSMajor);
#endif

    for (int i = 0; i < PLATFORMLEN; i++)
	{
		if ( (iOsType  == aryPlatformLookup[i].iOSType) &&
             (iOsArch  == aryPlatformLookup[i].iOSArch) &&
             (fOsMajor == aryPlatformLookup[i].fOSMajor) )
        {
            return aryPlatformLookup[i].pszOSDescription;
        }
	}
	return NULL;
}

BOOL CALLBACK DebugOfferInitProc (HWND hDlg,BOOL fFirstInit, UINT *puNextPage)
{
    if (fFirstInit)
    {
        PropSheet_SetWizButtons(GetParent(hDlg), 0);
        InitListView(hDlg, IDC_ISPCAB_LIST);
    }
    else
    {
        HWND hLst = GetDlgItem(hDlg, IDC_ISPCAB_LIST);
        if (g_uLastLVSel != -1)
            ListView_SetItemState(hLst, g_uLastLVSel, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
        if (IsWindowEnabled(hLst))
        {
            SetFocus(hLst);
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
        }
        else
            PropSheet_SetWizButtons(GetParent(hDlg), 0);
    }

    return TRUE;
}

BOOL CALLBACK DebugOfferOKProc (HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL * pfKeepHistory)
{
    if (fForward)
    {
        g_uLastLVSel = ListView_GetNextItem (GetDlgItem(hDlg, IDC_ISPCAB_LIST), -1, LVNI_SELECTED);
        if (g_uLastLVSel != -1)
        {
            SetupOfferToDebug(hDlg, IDC_ISPCAB_LIST);
            return TRUE;
        }
        else
            MessageBox(hDlg, TEXT("Please select an offer to debug"), NULL, MB_OK);
    }

    return FALSE;
}

BOOL CALLBACK DebugOfferCmdProc (HWND hDlg, WPARAM wParam, LPARAM  lParam)
{
    DWORD dwMsg = GET_WM_COMMAND_CMD(wParam, lParam);

    switch(dwMsg)
    {
        case EN_CHANGE:
        {
            TryToUpdateListBox(hDlg, IDC_ISPCAB_LIST, IDC_ISPCAB_PATH);
            break;
        }
        case BN_CLICKED:
        {
            Browse(hDlg);
            return FALSE;
            break;
        }
        default:
            break;
    }

    return TRUE;
}

BOOL CALLBACK DebugOfferNotifyProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{

    // Process ListView notifications
    switch(((LV_DISPINFO *)lParam)->hdr.code)
    {
        case NM_DBLCLK:
            PropSheet_PressButton(GetParent(hDlg),PSBTN_NEXT);
            break;
        case NM_SETFOCUS:
        case NM_KILLFOCUS:
            // update list view
            break;
        case LVN_ITEMCHANGED:
            break;
        // The listview is being emptied, or destroyed, either way, our lpSelectedISPInfo
        // is no longer valid, since the list view underlying data will be freed.
        case LVN_DELETEALLITEMS:
            break;
        case LVN_DELETEITEM:
            // We were notified that an item was deleted.
            // so delete the underlying data that it is pointing
            // to.
            if (((NM_LISTVIEW*)lParam)->lParam)
            {
                GlobalFree((ISPSTRUCT*)((NM_LISTVIEW*)lParam)->lParam);
                ((NM_LISTVIEW*)lParam)->lParam = NULL;
            }
            break;
        default:
            break;

    }
    return TRUE;
}

void InitListView (HWND hwndDlg, int iListViewCtrlID)
{
    ASSERT(hwndDlg);

    HWND      hwndListView;
    LVCOLUMN  lvColumn;
    int       iMaxNumHeader;

    hwndListView  = GetDlgItem(hwndDlg, iListViewCtrlID);
    lvColumn.mask = LVCF_TEXT;
    iMaxNumHeader = sizeof(g_pszaHeader) / sizeof(g_pszaHeader[0]);

    lvColumn.pszText = NULL;
    ListView_InsertColumn   (hwndListView, 0, &lvColumn);
    ListView_SetColumnWidth (hwndListView, 0, 0);

    for (int i = 1; i < iMaxNumHeader+1; i++)
    {
        lvColumn.pszText = g_pszaHeader[i-1];
        ListView_InsertColumn   (hwndListView, i, &lvColumn);
        ListView_SetColumnWidth (hwndListView, i, lstrlen(g_pszaHeader[i-1])*10);
    }

    //Add drag/drop/ordering and row select
    ListView_SetExtendedListViewStyle(hwndListView, LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP );

    //disable it
    Static_Enable(hwndListView, FALSE);
}

BOOL ValidateOfferFile (TCHAR* pszFile, TCHAR* pszValidExt)
{
    ASSERT(pszFile);
    ASSERT(pszValidExt);

    if (GetFileAttributes(pszFile) != 0xFFFFFFFF)
    {
        TCHAR szExt [_MAX_EXT] = TEXT("\0");

        _tsplitpath(pszFile, NULL, NULL, NULL, szExt);

        if(!lstrcmpi(szExt, pszValidExt))
            return TRUE;
    }
    return FALSE;
}

BOOL ExpandOfferFileIntoDir (TCHAR* pszFile, TCHAR* pszDir)
{
    ASSERT(pszFile);
    ASSERT(pszDir);

   // Set the current directory.
    HKEY    hkey = NULL;
    TCHAR   szAppPathKey[MAX_PATH];
    TCHAR   szICWPath[MAX_PATH];
    TCHAR   szCurPath[MAX_PATH];
    DWORD   dwcbPath = sizeof(szICWPath);


    GetCurrentDirectory(ARRAYSIZE(szCurPath), szCurPath);
    lstrcpy (szAppPathKey, REGSTR_PATH_APPPATHS);
    lstrcat (szAppPathKey, TEXT("\\"));
    lstrcat (szAppPathKey, TEXT("ICWCONN1.EXE"));

    if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,szAppPathKey, 0, KEY_QUERY_VALUE, &hkey)) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hkey, TEXT("Path"), NULL, NULL, (BYTE *)szICWPath, (DWORD *)&dwcbPath) == ERROR_SUCCESS)
        {
            // The Apppaths' have a trailing semicolon that we need to get rid of
            // dwcbPath is the lenght of the string including the NULL terminator
            int nSize = lstrlen(szICWPath);
            szICWPath[nSize-1] = '\0';
            SetCurrentDirectory(szICWPath);
        }
    }

    if (hkey)
        RegCloseKey(hkey);

    //create the temp dir for the offer cab
    CreateDirectory(pszDir, NULL);

    //
    // expand the cab file in the temp directory
    //
#ifdef UNICODE
    CHAR szFile[MAX_PATH+1];
    CHAR szDir[MAX_PATH+1];

    wcstombs(szFile, pszFile, MAX_PATH+1);
    wcstombs(szDir,  pszDir,  MAX_PATH+1);
    if (fdi(szFile, szDir))
        return TRUE;
#else
    if (fdi((LPTSTR)(LPCTSTR)pszFile, pszDir))
        return TRUE;
#endif

    SetCurrentDirectory(szCurPath);

    return FALSE;
}

void AddOffersToListView (HWND hwndLV, TCHAR* pFileBuff, DWORD dwBuffSize)
{
    TCHAR  szField [MAX_PATH]    = TEXT("\0");
    TCHAR  szOs    [MAX_INT_STR] = TEXT("\0");
    TCHAR  szArch  [MAX_INT_STR] = TEXT("\0");
    TCHAR* pszField              = (TCHAR*)&szField;
    int    i                     = 0;
    int    iLen                  = 0;
    LVITEM lvItem;

    lvItem.mask     = LVIF_TEXT | LVIF_PARAM;
    lvItem.pszText  = szField;
    lvItem.iItem    = 0;
    lvItem.iSubItem = 0;

    TCHAR* pFileBuffStart = pFileBuff;

    while((DWORD)(pFileBuff - pFileBuffStart) < dwBuffSize)
    {
        pszField  = (TCHAR*)&szField;

        ISPSTRUCT* pIspInfo = (ISPSTRUCT*)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(ISPSTRUCT));
        if (!pIspInfo)
        {
            MessageBox(GetParent(hwndLV), TEXT("OUT OF MEMORY!"), NULL, MB_OK);
            return;
        }

        lvItem.lParam = (LPARAM)pIspInfo;
        ListView_InsertItem(hwndLV, &lvItem);

        while(i <= NUMBER_OF_FIELDS)
        {
            while(*pFileBuff != ',' && *pFileBuff != '\n')
                *pszField++ = *pFileBuff++;
            *pFileBuff++;
            *pszField++ = '\0';

            switch (i)
            {
                case 0: //mirs
                    lstrcpy(pIspInfo->szMIRS, szField);
                    break;
                case 1: //isp name
                    lstrcpy(pIspInfo->szISPName, szField);
                    ListView_SetItemText(hwndLV, lvItem.iItem, 1, szField);
                    break;
                case 2: //local htm
                    lstrcpy(pIspInfo->szLocalHtm, szField);
                    break;
                case 3: //icon
                    lstrcpy(pIspInfo->szIcon, szField);
                    break;
                case 4: //OEM Button
                    lstrcpy(pIspInfo->szOEMButton, szField);
                    break;
                case 5: //OEM Teaser
                    lstrcpy(pIspInfo->szOEMTeaseHTM, szField);
                    break;
                case 6: //billing htm
                    lstrcpy(pIspInfo->szBilling, szField);
                    break;
                case 7: //isp file
                    lstrcpy(pIspInfo->szIspFile, szField);
                    break;
                case 8: //paycsv file
                    lstrcpy(pIspInfo->szPayCsv, szField);
                    break;
                case 9: //cab file
                    lstrcpy(pIspInfo->szCab, szField);
                    break;
                case 10: // LCID
                    pIspInfo->dwLCID = _ttoi(szField);
                    ListView_SetItemText(hwndLV, lvItem.iItem, 3, LookupLanguage(szField));
                    break;
                case 11: // Country
                    ListView_SetItemText(hwndLV, lvItem.iItem, 2, LookupCountry(szField));
                    break;
                case 12: // Areacode
                    ListView_SetItemText(hwndLV, lvItem.iItem, 4, szField);
                    break;
                case 13: // Exchng
                    break;
                case 14: //prod
                    ListView_SetItemText(hwndLV, lvItem.iItem, 6, szField);
                    break;
                case 15: //promo
                    ListView_SetItemText(hwndLV, lvItem.iItem, 7, szField);
                    break;
                case 16: //oem
                    ListView_SetItemText(hwndLV, lvItem.iItem, 8, szField);
                    break;
                case 17: //os
                    lstrcpyn(szOs, szField, ARRAYSIZE(szOs));
                    break;
                case 18: //arch
                    lstrcpyn(szArch, szField, ARRAYSIZE(szOs));
                    break;
                case 19: //major
                    ListView_SetItemText(hwndLV, lvItem.iItem, 5, LookupPlatform(szOs, szArch, szField));
                    break;
                case 20: //cfg
                    pIspInfo->dwCfgFlag = _ttoi(szField);
                    break;
                case 21: //ui
                    pIspInfo->dwUiFlag = _ttoi(szField);
                    break;
                default:
                    break;
            }
            pszField  = (TCHAR*)&szField;
            i++;
        }

        lvItem.iItem++;
        i = 0;
    }
    pFileBuff = pFileBuffStart;
}

void TryToUpdateListBox (HWND hwndDlg, int iListViewCtrlID, int iEditCtrlID)
{
    ASSERT(hwndDlg);

    HWND   hwndListView                   = NULL;
    HWND   hwndEdit                       = NULL;
    HFILE  hOfferFile                     = NULL;
    DWORD  dwSize                         = 0;
    TCHAR  szCabPath           [MAX_PATH] = TEXT("\0");
    TCHAR  szOfferInfoFilePath [MAX_PATH] = TEXT("\0");
    void* pFileBuff                       = NULL;

    hwndListView  = GetDlgItem(hwndDlg, iListViewCtrlID);
    hwndEdit      = GetDlgItem(hwndDlg, iEditCtrlID);

    GetWindowText(hwndEdit, szCabPath, ARRAYSIZE(szCabPath));

    if (!ValidateOfferFile(szCabPath, VALID_MAIN_OFFER_FILE_TYPE))
    {
        if (IsWindowEnabled(hwndListView))
        {
            Static_Enable(hwndListView, FALSE);
            PropSheet_SetWizButtons(GetParent(hwndDlg), 0);
        }
        return; //FAILURE
    }

    RemoveTempOfferDirectory();

    if(!ExpandOfferFileIntoDir(szCabPath, TEMP_OFFER_DIR))
        return; //FAILURE

    lstrcpy(szOfferInfoFilePath, TEMP_OFFER_DIR);
    lstrcat(szOfferInfoFilePath, VALID_OFFER_INFO_FILE_NAME);

    if (!ValidateOfferFile(szOfferInfoFilePath, VALID_OFFER_INFO_FILE_TYPE))
    {
        MessageBox(hwndDlg, TEXT("The selected cab is not a valid Offer Wizard 5.0 file."), NULL, MB_OK);
        return; //FAILURE
    }

#ifdef UNICODE
    CHAR szTmp[MAX_PATH+1];
    wcstombs(szTmp, szOfferInfoFilePath, MAX_PATH+1);
    hOfferFile = _lopen(szTmp, OF_READ | OF_SHARE_EXCLUSIVE);
#else
    hOfferFile = _lopen(szOfferInfoFilePath, OF_READ | OF_SHARE_EXCLUSIVE);
#endif
    if (hOfferFile)
    {
        dwSize = GetFileSize((HANDLE)LongToHandle(hOfferFile), NULL);
        if(dwSize)
        {
            pFileBuff =  malloc(dwSize + 1);

            if (pFileBuff)
            {
                if (_lread(hOfferFile, pFileBuff, dwSize) != HFILE_ERROR)
                {

                    ListView_DeleteAllItems(hwndListView);
                    AddOffersToListView(hwndListView, (TCHAR*)pFileBuff, dwSize);
                    Static_Enable(hwndListView, TRUE);
                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
                }
                free(pFileBuff);
            }
        }
        _lclose(hOfferFile);
    }
}

void Browse (HWND hwndDlg)
{
    OPENFILENAME ofn;

    TCHAR szNewFileBuff[MAX_PATH + 1] = TEXT("\0");
    TCHAR szDesktopPath[MAX_PATH + 1] = TEXT("\0");

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hwndDlg;
    ofn.lpstrFilter       = BROWSE_FILTER;
    ofn.lpstrFile         = szNewFileBuff;
    ofn.nMaxFile          = sizeof(szNewFileBuff);
    ofn.lpstrFileTitle    = NULL;
    ofn.lpstrInitialDir   = szDesktopPath;
    ofn.lpstrTitle        = NULL;
    ofn.lpstrCustomFilter = (LPTSTR) NULL;
    ofn.nMaxCustFilter    = 0L;
    ofn.nFileOffset       = 0;
    ofn.nFileExtension    = 0;
    ofn.lCustData         = 0;
    ofn.nFilterIndex      = 1L;
    ofn.nMaxFileTitle     = 0;
    ofn.Flags             = OFN_PATHMUSTEXIST | OFN_HIDEREADONLY |
                            OFN_EXPLORER      | OFN_LONGNAMES;

    GetOpenFileName(&ofn);
    SetWindowText(GetDlgItem(hwndDlg, IDC_ISPCAB_PATH), ofn.lpstrFile);
}

void SetupOfferToDebug (HWND hwndDlg, int iListViewCtrlID)
{
    ASSERT(hwndDlg);

    TCHAR      szCabPath    [MAX_PATH] = TEXT("\0");
    TCHAR      szFullPath   [MAX_PATH] = TEXT("\0");
    TCHAR      szCSVFile    [MAX_PATH] = TEXT("\0");
    HWND       hwndListView            = GetDlgItem(hwndDlg, iListViewCtrlID);
    int        iItem                   = ListView_GetSelectionMark(hwndListView);
    ISPSTRUCT* pIspStruct              = NULL;
    LVITEM     lvItem;

    lvItem.mask     = LVIF_PARAM;
    lvItem.iItem    = iItem;

    ListView_GetItem(hwndListView, &lvItem);
    pIspStruct = (ISPSTRUCT*)lvItem.lParam;

    lstrcpy(szFullPath, TEMP_OFFER_DIR);
    lstrcat(szFullPath, pIspStruct->szCab);

    if (ValidateOfferFile(szFullPath, VALID_MAIN_OFFER_FILE_TYPE))
    {
        RemoveDownloadDirectory();

        if (ExpandOfferFileIntoDir (szFullPath, DOWNLOAD_OFFER_DIR))
        {
            HFILE hIspCsvFile = NULL;

            lstrcpy(szCSVFile, DOWNLOAD_OFFER_DIR);
            lstrcat(szCSVFile, VALID_ICW_INFO_FILE_NAME);

#ifdef UNICODE
            CHAR szTmp[MAX_PATH+1];
            wcstombs(szTmp, szCSVFile, MAX_PATH+1);
            if ((hIspCsvFile = _lcreat(szTmp, 0))!= HFILE_ERROR)
#else
            if ((hIspCsvFile = _lcreat(szCSVFile, 0))!= HFILE_ERROR)
#endif
            {
                //write header
                _hwrite(hIspCsvFile, ISPINFO_CSV_HEADER, strlen(ISPINFO_CSV_HEADER));
                WriteCSVLine(hwndListView, iItem, hIspCsvFile);
                _lclose(hIspCsvFile);
            }

        }
    }
}

// Header Format of the CSV File
#define CSV_FORMAT50	_T("'%s',%d,%s%s,%s%s,%s%s,%s%s,%s%s,%lu,%lu,%s%s,%s%s,%s,%s,%ld\r\n")
//                         "Name,OfferID,Icon,LocalHtm,OEMSpecialIcon,OEMSpecialHtm,ISPFile,CFGFlag,UIFlag,BillingForm,PayCSV,GUID,MIRS,LCID\r\n";
#define GUID            _T("11111111-00000-000000000-0")

BOOL WriteCSVLine (HWND hwndLV, int iSelItem, HFILE hFile)
{
    ASSERT(hwndLV);
    ASSERT(hFile);

    TCHAR      szIspCsvLine  [1024]     = TEXT("\0");
    TCHAR      szName        [MAX_PATH] = TEXT("\0");
    ISPSTRUCT* pIspStruct               = NULL;
    LVITEM     lvItem;

    lvItem.mask     = LVIF_PARAM;
    lvItem.iItem    = iSelItem;

    ListView_GetItemText(hwndLV, iSelItem, 1,  szName, sizeof(szName));

    ListView_GetItem(hwndLV, &lvItem);

    pIspStruct = (ISPSTRUCT*)lvItem.lParam;

    wsprintf(szIspCsvLine, CSV_FORMAT50,
             pIspStruct->szISPName,
             0,
             DOWNLOAD_OFFER_DIR,
             pIspStruct->szIcon,
             DOWNLOAD_OFFER_DIR,
             pIspStruct->szLocalHtm,
             (pIspStruct->szOEMButton[0] != TEXT('\0') ? DOWNLOAD_OFFER_DIR : TEXT("")),
             (pIspStruct->szOEMButton[0] != TEXT('\0') ? pIspStruct->szOEMButton : TEXT("")),
             (pIspStruct->szOEMTeaseHTM[0] != TEXT('\0') ? DOWNLOAD_OFFER_DIR : TEXT("")),
             (pIspStruct->szOEMTeaseHTM[0] != TEXT('\0') ? pIspStruct->szOEMTeaseHTM : TEXT("")),
             DOWNLOAD_OFFER_DIR,
             pIspStruct->szIspFile,
             pIspStruct->dwCfgFlag,
             pIspStruct->dwUiFlag,
             DOWNLOAD_OFFER_DIR,
             pIspStruct->szBilling,
             DOWNLOAD_OFFER_DIR,
             pIspStruct->szPayCsv,
             GUID,
             pIspStruct->szMIRS,
             pIspStruct->dwLCID);

#ifdef UNICODE
    CHAR szTmp[1024];
    wcstombs(szTmp, szIspCsvLine, 1024);
    _hwrite(hFile, szTmp, lstrlenA(szTmp));
#else
    _hwrite(hFile, szIspCsvLine, lstrlen(szIspCsvLine));
#endif

    return TRUE;
}

/************************************************
*************************************************
*************************************************
************************************************/

void SetKeyValues (HKEY hKey, DWORD dwCorpNet, DWORD dwDbgPath, DWORD dwIspFile, TCHAR* pszUrl, size_t sizeUrl)
{
    RegSetValueEx(hKey,
                  CORPNET_VAL,
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwCorpNet,
                  sizeof(dwCorpNet));

    RegSetValueEx(hKey,
                  DBGPATH_VAL,
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwDbgPath,
                  sizeof(dwDbgPath));

    RegSetValueEx(hKey,
                  ISPFILE_VAL,
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwIspFile,
                  sizeof(dwIspFile));

    RegSetValueEx(hKey,
                  URL_VAL,
                  0,
                  REG_SZ,
                  (LPBYTE)pszUrl,
                  sizeUrl);
}

void GetSettingsFromReg (HKEY hKey, HWND hDlg)
{
    DWORD dwVal            = 0;
    DWORD dwSize           = sizeof(dwVal);
    TCHAR szUrl [MAX_PATH] = TEXT("\0");

    RegQueryValueEx(hKey,
                    CORPNET_VAL,
                    0,
                    NULL,
                    (LPBYTE)&dwVal,
                    &dwSize);

    Button_SetCheck(GetDlgItem(hDlg, IDC_USE_NETWORK),  (BOOL)dwVal);
    Button_SetCheck(GetDlgItem(hDlg, IDC_MODEM),       !(BOOL)dwVal);

    RegQueryValueEx(hKey,
                    DBGPATH_VAL,
                    0,
                    NULL,
                    (LPBYTE)&dwVal,
                    &dwSize);

    Button_SetCheck(GetDlgItem(hDlg, IDC_SIGNUP_PATH),  (BOOL)dwVal);
    Button_SetCheck(GetDlgItem(hDlg, IDC_AUTO_PATH),   !(BOOL)dwVal);

    RegQueryValueEx(hKey,
                    ISPFILE_VAL,
                    0,
                    NULL,
                    (LPBYTE)&dwVal,
                    &dwSize);

    Button_SetCheck(GetDlgItem(hDlg, IDC_ISP_URL),    (BOOL)dwVal);
    Button_SetCheck(GetDlgItem(hDlg, IDC_OTHER_URL), !(BOOL)dwVal);

    dwSize = sizeof(szUrl);

    RegQueryValueEx(hKey,
                    URL_VAL,
                    0,
                    NULL,
                    (LPBYTE)&szUrl,
                    &dwSize);

    SetWindowText(GetDlgItem(hDlg, IDC_URL), szUrl);
    Edit_Enable(GetDlgItem(hDlg, IDC_URL), !(BOOL)dwVal);
}

void SetSettingsInReg (HWND hDlg)
{
    HKEY  hKey             = NULL;
    DWORD dwAction         = 0;
    DWORD dwCorpNet        = 0;
    DWORD dwDbgPath        = 0;
    DWORD dwIspFile        = 0;
    TCHAR szUrl [MAX_PATH] = TEXT("\0");

    RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 ICWDEBUG_KEY,
                 0,
                 KEY_ALL_ACCESS,
                 &hKey);

    dwCorpNet = Button_GetCheck(GetDlgItem(hDlg, IDC_USE_NETWORK));
    dwDbgPath = Button_GetCheck(GetDlgItem(hDlg, IDC_SIGNUP_PATH));
    dwIspFile = Button_GetCheck(GetDlgItem(hDlg, IDC_ISP_URL));

    GetWindowText(GetDlgItem(hDlg, IDC_URL), szUrl, ARRAYSIZE(szUrl));

    SetKeyValues(hKey, dwCorpNet, dwDbgPath, dwIspFile, szUrl, lstrlen(szUrl));

    lstrcpy(gpWizardState->cmnStateData.ispInfo.szIspURL, szUrl);

    RegCloseKey(hKey);
}

void InitRegKeySettings (HWND hDlg)
{
    HKEY  hKey     = NULL;
    DWORD dwAction = 0;

    RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                   ICWDEBUG_KEY,
                   0,
                   NULL,
                   0,
                   KEY_ALL_ACCESS,
                   NULL,
                   &hKey,
                   &dwAction);

    if (dwAction == REG_CREATED_NEW_KEY)
        SetKeyValues(hKey, 0, 1, 1, TEXT("\0"), 1);

    GetSettingsFromReg(hKey, hDlg);

    RegCloseKey(hKey);
}

BOOL CALLBACK DebugSettingsInitProc (HWND hDlg,BOOL fFirstInit, UINT *puNextPage)
{
    if(!fFirstInit)
        InitRegKeySettings(hDlg);

    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

    return TRUE;
}

BOOL CALLBACK DebugSettingsOKProc (HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL * pfKeepHistory)
{
    SetSettingsInReg(hDlg);

    if (fForward)
    {
        if(Button_GetCheck(GetDlgItem(hDlg, IDC_USE_NETWORK)))
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_MODEMOVERRIDE;
        else
            gpWizardState->cmnStateData.dwFlags &= ~ICW_CFGFLAG_MODEMOVERRIDE;

        if(!Button_GetCheck(GetDlgItem(hDlg, IDC_SIGNUP_PATH)))
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_AUTOCONFIG;
        else
            gpWizardState->cmnStateData.dwFlags &= ~ICW_CFGFLAG_AUTOCONFIG;

        if(!Button_GetCheck(GetDlgItem(hDlg, IDC_ISP_URL)))
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_ISPURLOVERRIDE;
        else
            gpWizardState->cmnStateData.dwFlags &= ~ICW_CFGFLAG_ISPURLOVERRIDE;


        if (LoadICWCONNUI(GetParent(hDlg),
                          GetDlgIDFromIndex(ORD_PAGE_ICWDEBUG_SETTINGS),
                          IDD_PAGE_END,
                          gpWizardState->cmnStateData.dwFlags))
        {

            if( DialogIDAlreadyInUse(g_uICWCONNUIFirst))
            {
                // we're about to jump into the external apprentice, and we don't want
                // this page to show up in our history list, infact, we need to back
                // the history up 1, because we are going to come back here directly
                // from the DLL, not from the history list.

                *pfKeepHistory = FALSE;

                *puNextPage = g_uICWCONNUIFirst;
            }
        }
    }
    return TRUE;
}

BOOL CALLBACK DebugSettingsCmdProc (HWND hDlg, WPARAM wParam, LPARAM  lParam)
{
   DWORD dwMsg = GET_WM_COMMAND_CMD(wParam, lParam);

    switch(dwMsg)
    {
        case BN_CLICKED:
        {
            if((GET_WM_COMMAND_ID(wParam, lParam) == IDC_ISP_URL) ||
               (GET_WM_COMMAND_ID(wParam, lParam) == IDC_OTHER_URL))
                Edit_Enable(GetDlgItem(hDlg, IDC_URL), !Button_GetCheck(GetDlgItem(hDlg, IDC_ISP_URL)));
            break;
        }
        default:
            break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\isperr.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  ISPERR.CPP - Functions for ISP error dialog page
//
//  HISTORY:
//  
//  08/14/98    vyung     created
//
//*********************************************************************

#include "pre.h"
#include "icwextsn.h"

/*******************************************************************

  NAME:    ISPErrorInitProc

  SYNOPSIS:  This is a transparent page.

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ISPErrorInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    // This is a transparent page to determine which page to go
    // next based on error condition
    if (!fFirstInit)
    {
        if (gpICWCONNApprentice)
            gpICWCONNApprentice->SetStateDataFromDllToExe( &gpWizardState->cmnStateData);

        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        if (gpWizardState->cmnStateData.bOEMCustom)
            gpWizardState->uCurrentPage = ORD_PAGE_ENDOEMCUSTOM;
        else
            gpWizardState->uCurrentPage = ORD_PAGE_END;

        // there was a data corruption in download, go to server error page
        if (gpWizardState->cmnStateData.bParseIspinfo)
        {
            // Re-build the history list since we substract 1 in refdial
            gpWizardState->uPagesCompleted++;
            *puNextPage = ORD_PAGE_REFSERVERR;
        }
        else if (gpWizardState->cmnStateData.bPhoneManualWiz)
        {
            // If we are in OEM custom mode, then goto the manual page
            // which will handle switching to the external manual wizard
            if (gpWizardState->cmnStateData.bOEMCustom)
            {
                *puNextPage = ORD_PAGE_MANUALOPTIONS;
            }
            else
            {
                if (LoadInetCfgUI(  hDlg,
                                    IDD_PAGE_REFSERVDIAL,
                                    IDD_PAGE_END,
                                    WIZ_HOST_ICW_PHONE))
                {
                    if( DialogIDAlreadyInUse( g_uICWCONNUIFirst) )
                    {
                        // Re-build the history list since we substract 1 in refdial
                        gpWizardState->uPagesCompleted++;

                        // we're about to jump into the external apprentice, and we don't want
                        // this page to show up in our history list
                        *puNextPage = g_uICWCONNUIFirst;
                        g_bAllowCancel = TRUE;
                    }
                }
                gpWizardState->cmnStateData.bPhoneManualWiz = FALSE;
                gpICWCONNApprentice->SetStateDataFromExeToDll( &gpWizardState->cmnStateData);
            }                
        }
        else
        {
            // Normal case goes to End page
            if (gpWizardState->cmnStateData.bOEMCustom)
                *puNextPage = ORD_PAGE_ENDOEMCUSTOM;
            else
                *puNextPage = ORD_PAGE_END;
        }

    }        
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\intro.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  INTRO.C - Functions for introductory Wizard pages
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"
#include "windowsx.h"
#include "tutor.h"
#include "icwcfg.h"
#include "icwextsn.h"
extern UINT GetDlgIDFromIndex(UINT uPageIndex);

extern CICWTutorApp* g_pICWTutorApp; 
extern BOOL          g_bNewIspPath;     
extern BOOL          g_bAutoConfigPath; 
extern BOOL          g_bManualPath;     
extern BOOL          g_bLanPath;     
extern BOOL          g_bSkipIntro;
extern BOOL          MyIsSmartStartEx(LPTSTR lpszConnectionName, DWORD dwBufLen);

BOOL  g_bExistConnect                       = FALSE;
BOOL  g_bCheckForOEM                        = FALSE;
TCHAR g_szAnsiName    [ICW_MAX_RASNAME + 1] = TEXT("\0");


/*******************************************************************

  NAME:         ReadOEMOffline

  SYNOPSIS:     Read OfflineOffers flag from the oeminfo.ini file

  ENTRY:        None

  RETURN:       True if OEM offline is read

********************************************************************/
BOOL ReadOEMOffline(BOOL *bOEMOffline)
{
    // OEM code
    //
    TCHAR szOeminfoPath[MAX_PATH + 1];
    TCHAR *lpszTerminator = NULL;
    TCHAR *lpszLastChar = NULL;
    BOOL bRet = FALSE;

    // If we already checked, don't do it again
    if (!g_bCheckForOEM)
    {
        if( 0 != GetSystemDirectory( szOeminfoPath, MAX_PATH + 1 ) )
        {
            lpszTerminator = &(szOeminfoPath[ lstrlen(szOeminfoPath) ]);
            lpszLastChar = CharPrev( szOeminfoPath, lpszTerminator );

            if( TEXT('\\') != *lpszLastChar )
            {
                lpszLastChar = CharNext( lpszLastChar );
                *lpszLastChar = '\\';
                lpszLastChar = CharNext( lpszLastChar );
                *lpszLastChar = '\0';
            }

            lstrcat( szOeminfoPath, ICW_OEMINFO_FILENAME );

            //Default oem code must be NULL if it doesn't exist in oeminfo.ini
            if (1 == GetPrivateProfileInt(ICW_OEMINFO_ICWSECTION,
                                                ICW_OEMINFO_OFFLINEOFFERS,
                                                0,
                                                szOeminfoPath))
            {
                // Check if file already exists
                if (0xFFFFFFFF != GetFileAttributes(ICW_OEMINFOPath))
                {
                    bRet = TRUE;
                }
            }
        }
        *bOEMOffline = bRet;
        g_bCheckForOEM = TRUE;
    }
    return TRUE;
}

        
/*******************************************************************

  NAME:      SetNextPage

  SYNOPSIS:  Determine whether we should proceed to icwconn.dll

********************************************************************/
BOOL SetNextPage(HWND hDlg, UINT* puNextPage, BOOL *pfKeepHistory)
{
    BOOL bRetVal = FALSE;
    // If we have switched path, then redownload 
    if (gpWizardState->bDoneRefServDownload)
    {
        if ( (DWORD) (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG) != 
             (DWORD) (gpWizardState->dwLastSelection & ICW_CFGFLAG_AUTOCONFIG) )
        {
            gpWizardState->bDoneRefServDownload = FALSE;
        }
    }

    // Read OEM offline flag 
    ReadOEMOffline(&gpWizardState->cmnStateData.bOEMOffline);

    //
    // Make sure we are not in autoconfig 
    //
    if (!(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG))
    {
        if (gpWizardState->cmnStateData.bOEMOffline && gpWizardState->cmnStateData.bOEMEntryPt)
            gpWizardState->bDoneRefServDownload = TRUE;
    }
    gpWizardState->dwLastSelection = gpWizardState->cmnStateData.dwFlags;

    // If we have completed the download, then list just jump to the next page
    if (gpWizardState->bDoneRefServDownload)
    //if (TRUE)
    {
        int iReturnPage = 0;

        if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_BRANDED)
            iReturnPage = gpWizardState->uPageHistory[gpWizardState->uPagesCompleted];
        else
        {
            if (gpWizardState->uPagesCompleted > 0)
            {
                iReturnPage = gpWizardState->uPageHistory[gpWizardState->uPagesCompleted-1];
            }
            else
            {
                iReturnPage = gpWizardState->uCurrentPage;
            }
        }

        if (LoadICWCONNUI(GetParent(hDlg), GetDlgIDFromIndex(iReturnPage), IDD_PAGE_DEFAULT, gpWizardState->cmnStateData.dwFlags))
        {
            if( DialogIDAlreadyInUse( g_uICWCONNUIFirst) )
            {
                // we're about to jump into the external apprentice, and we don't want
                // this page to show up in our history list
                *puNextPage = g_uICWCONNUIFirst;
        
                // Backup 1 in the history list, since we the external pages navigate back
                // we want this history list to be in the correct spot.  Normally
                // pressing back would back up the history list, and figure out where to
                // go, but in this case, the external DLL just jumps right back in.
                // We also don't want to keep histroy.
                if (!(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_BRANDED))
                {
                    if (gpWizardState->uPagesCompleted > 0)
                    {
                        gpWizardState->uPagesCompleted--;
                    }
                    else
                    {
                        if (pfKeepHistory)
                        {
                            *pfKeepHistory = FALSE;
                        }
                    }
                }
                bRetVal = TRUE;
        
            }
        }
    }
    return bRetVal;

}

/*******************************************************************

  NAME:      SetIntroNextPage

  SYNOPSIS:  Determine whether we what is the next page of intro page

********************************************************************/
void SetIntroNextPage(HWND hDlg, UINT* puNextPage, BOOL *pfKeepHistory)
{
    short   wNumLocations;
    long    lCurrLocIndex;
    BOOL    bRetVal;

    *puNextPage = ORD_PAGE_AREACODE;
    // Check dialing location here to prevent flashing of areacode page
    gpWizardState->pTapiLocationInfo->GetTapiLocationInfo(&bRetVal);
    gpWizardState->pTapiLocationInfo->get_wNumberOfLocations(&wNumLocations, &lCurrLocIndex);
    if (1 >= wNumLocations)
    {
        BSTR    bstrAreaCode = NULL;
        DWORD   dwCountryCode;

        *puNextPage = ORD_PAGE_REFSERVDIAL;
        
        gpWizardState->pTapiLocationInfo->get_lCountryCode((long *)&dwCountryCode);
        gpWizardState->pTapiLocationInfo->get_bstrAreaCode(&bstrAreaCode);
        
        gpWizardState->cmnStateData.dwCountryCode = dwCountryCode;
        lstrcpy(gpWizardState->cmnStateData.szAreaCode, W2A(bstrAreaCode));
        SysFreeString(bstrAreaCode);

        // we can skip area code page
        *puNextPage = ORD_PAGE_REFSERVDIAL;
        SetNextPage(hDlg, puNextPage, pfKeepHistory);
    }
}

INT_PTR CALLBACK ExistingConnectionCmdProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            // put the dialog in the center of the screen
            RECT rc;
            TCHAR   szFmt   [MAX_MESSAGE_LEN];
            TCHAR   *args   [1];
            LPVOID  pszIntro = NULL;

            GetWindowRect(hDlg, &rc);
            SetWindowPos(hDlg,
                        NULL,
                        ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
                        ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
                        0, 0, SWP_NOSIZE | SWP_NOACTIVATE);


            args[0] = (LPTSTR) lParam;
    
            LoadString(g_hInstance, IDS_EXIT_CONN, szFmt, ARRAYSIZE(szFmt));
                
            if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                              szFmt, 
                              0, 
                              0, 
                              (LPTSTR)&pszIntro, 
                              0,
                              (va_list*)args))
            {
   
                SetWindowText(GetDlgItem(hDlg, IDC_EXIT_CONN), (LPTSTR) pszIntro);
            }

            if (pszIntro)
            {
                LocalFree(pszIntro);
            }
 
            break;
        }
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    EndDialog(hDlg,TRUE);
                    break;

                case IDCANCEL:
                   EndDialog(hDlg,FALSE);
                    break;                  
            }
            break;
    }

    return FALSE;
}

/*******************************************************************

  NAME:    IntroInitProc

  SYNOPSIS:  Called when "Intro" page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK IntroInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    if (!(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_BRANDED) 
        &&!(gpWizardState->cmnStateData.bOEMCustom)
       )
    {
        // This is the very first page, so do not allow back
        PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);
    }
    
    if (fFirstInit)
    {        
//#ifdef  NON_NT5
        // Hide the manual option when running in run once
        if (g_bRunOnce)
        {
            ShowWindow(GetDlgItem(hDlg, IDC_ICWMAN), SW_HIDE);
            EnableWindow(GetDlgItem(hDlg, IDC_ICWMAN), FALSE);
        }
                    
        // initialize radio buttons
        Button_SetCheck(GetDlgItem(hDlg, IDC_RUNNEW), g_bNewIspPath);
        Button_SetCheck(GetDlgItem(hDlg, IDC_RUNAUTO),  g_bAutoConfigPath);
        Button_SetCheck(GetDlgItem(hDlg, IDC_ICWMAN), g_bManualPath || g_bLanPath);

        if (SMART_QUITICW == MyIsSmartStartEx(g_szAnsiName, ARRAYSIZE(g_szAnsiName)))
             g_bExistConnect = TRUE;    
/* #else
        //We only support manual path for NT5 for NT5 beta3 release.
        EnableWindow(GetDlgItem(hDlg, IDC_RUNNEW), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RUNAUTO), FALSE);
        Button_SetCheck(GetDlgItem(hDlg, IDC_ICWMAN), TRUE);
#endif */

    }
    else
    {
        // If branded, then our template is intro2
        if ((gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_BRANDED)
           || (gpWizardState->cmnStateData.bOEMCustom)
            )
        {
            gpWizardState->uCurrentPage = ORD_PAGE_INTRO2;
        }            
        else        
        {
            gpWizardState->uCurrentPage = ORD_PAGE_INTRO;
        }
        // If it is reboot from manual wiz, advance to the manual option page
        if (g_bManualPath || g_bLanPath)
        {
            gpWizardState->uPageHistory[gpWizardState->uPagesCompleted] = gpWizardState->uCurrentPage;
            gpWizardState->uPagesCompleted++;
            
            TCHAR    szTitle[MAX_TITLE];
            LoadString(g_hInstance, IDS_APPNAME, szTitle, ARRAYSIZE(szTitle));
            SetWindowText(GetParent(hDlg), szTitle); 

            *puNextPage = ORD_PAGE_MANUALOPTIONS;
        }

        if (g_bSkipIntro)
        {
            PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
            g_bSkipIntro = FALSE;
        }
    }        
    return TRUE;
}

/*******************************************************************

  NAME:    IntroOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from "Intro" page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK IntroOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    if (fForward)
    {
         
        gpWizardState->lRefDialTerminateStatus = ERROR_SUCCESS;
        gpWizardState->cmnStateData.dwFlags &= ~(DWORD)ICW_CFGFLAG_AUTOCONFIG;
        gpWizardState->cmnStateData.dwFlags &= ~(DWORD)ICW_CFGFLAG_SMARTREBOOT_NEWISP;    
        gpWizardState->cmnStateData.dwFlags &= ~(DWORD)ICW_CFGFLAG_SMARTREBOOT_AUTOCONFIG; // this is seperate from ICW_CFGFLAG_AUTOCONFIG so as not to confuse function of flag
        gpWizardState->cmnStateData.dwFlags &= ~(DWORD)ICW_CFGFLAG_SMARTREBOOT_MANUAL;            
        gpWizardState->cmnStateData.dwFlags &= ~(DWORD)ICW_CFGFLAG_SMARTREBOOT_LAN;            

        // read radio button state
        if( IsDlgButtonChecked(hDlg, IDC_RUNNEW) )
        {
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_SMARTREBOOT_NEWISP;
            
            if (g_bExistConnect)
            {
                if (!DialogBoxParam(g_hInstance,MAKEINTRESOURCE(IDD_EXISTINGCONNECTION),hDlg, 
                                    ExistingConnectionCmdProc, (LPARAM)g_szAnsiName))
                {                                   
                    gfQuitWizard = TRUE;            // Quit the wizard
                    return FALSE;
                }                    
            }
        
            // Do the system config checks
            if (!gpWizardState->cmnStateData.bSystemChecked && !ConfigureSystem(hDlg))
            {
                // gfQuitWizard will be set in ConfigureSystem if we need to quit
                return FALSE;
            }
        
            // OK, give me the next page
            SetIntroNextPage(hDlg, puNextPage, pfKeepHistory);
            
        }
        else if( IsDlgButtonChecked(hDlg, IDC_RUNAUTO) )
        {
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_SMARTREBOOT_AUTOCONFIG;

            // Do the system config checks
            if (!gpWizardState->cmnStateData.bSystemChecked && !ConfigureSystem(hDlg))
            {
                // gfQuitWizard will be set in ConfigureSystem if we need to quit
                return FALSE;
            }
            // The system config check is done in Inetcfg
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_AUTOCONFIG;

            SetIntroNextPage(hDlg, puNextPage, pfKeepHistory);
        }
        else if( IsDlgButtonChecked(hDlg, IDC_ICWMAN) )
        {
            *puNextPage = ORD_PAGE_MANUALOPTIONS;
        }
    }
    else if (!(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_BRANDED))
    {
        // Were are out of here, since we cannot go back from the first page
        gpWizardState->uPagesCompleted = 1;
        gfUserBackedOut = TRUE;
        gfQuitWizard = TRUE;
    }
    else if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_BRANDED)
        gpWizardState->uPagesCompleted = 1;

    return TRUE;
}

BOOL CALLBACK IntroCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch (GET_WM_COMMAND_CMD(wParam, lParam)) 
    {
        case BN_CLICKED:
        {
            if (GET_WM_COMMAND_ID(wParam, lParam) == IDC_TUTORIAL)
                g_pICWTutorApp->LaunchTutorApp();
            break;
        }
        case BN_DBLCLK:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            { 
                case IDC_RUNNEW: 
                case IDC_RUNAUTO: 
                case IDC_ICWMAN: 
                {
		            // somebody double-clicked a radio button
		            // auto-advance to the next page
		            PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
                    break;
                }
            }
		    break;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\pre.h ===
//**********************************************************************
// File name: pre.h
//
//      Used for precompiled headers
//
// Copyright (c) 1993-1996 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _PRE_H_)
#define _PRE_H_

#include <windows.h>
#include <windowsx.h>
#include <wchar.h>
#include <ole2.h>
#include <assert.h>
#include <string.h>
#include <ccstock.h>
#include <commctrl.h>
#include <locale.h>

#include <malloc.h>
#include <wininet.h>
#include <regstr.h>
#include <shlwapi.h>
#include <shlwapip.h>

#include "icwunicd.h"

#include "icwcmn.h"
#include "icwhelp.h"
#include "connect.h"
#include "webview.h"            // ICW WEBView Interface

#include "wizdef.h"
#include "pagefcns.h"
#include "icwconn1.h"
#include "resource.h"

#include "button.h"
#include "appwnd.h"

#include <ole2ver.h>
#include <exdisp.h>

#include "appdefs.h"
#include "..\inc\debug.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\multinum.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  MULTINUM.CPP - Functions for final Wizard pages
//

//  HISTORY:
//  
//  05/28/98    donaldm     created
//
//*********************************************************************

#include "pre.h"


/*******************************************************************

  NAME:     InitListBox

  SYNOPSIS: Initialize the phone number list view

  ENTRY:    hListBox       - handle to the list view window

  EXIT:     returns TRUE when successful, FALSE otherwise.

********************************************************************/
BOOL InitListBox(HWND  hListBox)
{
    LONG        lNumDevice;
    LONG        i;
    
    gpWizardState->pRefDial->get_PhoneNumberEnum_NumDevices(&lNumDevice);
    if (lNumDevice > 0)
    {
        for (i=0; i < lNumDevice; i++)
        {
            BSTR        bstr = NULL;
            gpWizardState->pRefDial->PhoneNumberEnum_Next(&bstr);
            if (bstr != NULL)
            {
                ListBox_InsertString(hListBox, i, W2A(bstr));
                SysFreeString(bstr);
            }
        }

        ListBox_SetCurSel(hListBox, 0);
    }
    return(TRUE);
}

/*******************************************************************

  NAME:    MultiNumberInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK MultiNumberInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL    bRet = TRUE;
    
    if (fFirstInit)
    {
        InitListBox(GetDlgItem(hDlg, IDC_MULTIPHONE_LIST) );
    }
    else
    {
        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_MULTINUMBER;
    }        
    
    return bRet;
}

/*******************************************************************

  NAME:    MultiNumberOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK MultiNumberOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    if (fForward)
    {
        BOOL bRetVal = FALSE;
        // Do not go to this page when backing up
        *pfKeepHistory = FALSE;
        *puNextPage = ORD_PAGE_REFSERVDIAL;
        gpWizardState->lSelectedPhoneNumber = ListBox_GetCurSel(GetDlgItem(hDlg, IDC_MULTIPHONE_LIST));
    }
    else
        //FIX -- RAID: 33413
        //if the user is backing out of this page we must act as if no
        //number was ever selected.
        gpWizardState->bDoUserPick = FALSE;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\pagefcns.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************
 
//
//  PAGEFCNS.H - Prototypes for wizard page handler functions
//

//  HISTORY:
//  
//  05/18/98  donaldm  Created.
//

#ifndef _PAGEFCNS_H_
#define _PAGEFCNS_H_

// Functions in INTRO.CPP
BOOL CALLBACK IntroInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK IntroPostInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK IntroOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK IntroCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);

// Functions in BRANDED.CPP
BOOL CALLBACK BrandedIntroInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK BrandedIntroOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK BrandedIntroPostInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);

// Functions in MANUAL.CPP
BOOL CALLBACK ManualOptionsInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ManualOptionsCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK ManualOptionsOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);

// Functions in AREACODE.CPP
BOOL CALLBACK AreaCodeInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK AreaCodeOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK AreaCodeCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);

// Functions in REFDIAL.CPP
BOOL CALLBACK RefServDialInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK RefServDialPostInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK RefServDialOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK RefServDialCancelProc(HWND hDlg);

// Functions in END.CPP
BOOL CALLBACK EndInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK EndOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK EndOlsInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);

// Functions in DIALERR.CPP
BOOL CALLBACK DialErrorInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK DialErrorOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK DialErrorCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);

// Functions in MULTINUM.CPP
BOOL CALLBACK MultiNumberInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK MultiNumberOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);

// Functions in SERVERR.CPP
BOOL CALLBACK ServErrorInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ServErrorOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK ServErrorCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);

// Functions in ISPERR.CPP
BOOL CALLBACK ISPErrorInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);

// Functions in SBSINTRO.CPP
BOOL CALLBACK SbsInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK SbsIntroOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);

#ifdef ICWDEBUG

// Functions in ICWDEBUG.CPP
BOOL CALLBACK DebugOfferInitProc (HWND hDlg, BOOL   fFirstInit, UINT*  puNextPage);
BOOL CALLBACK DebugOfferOKProc   (HWND hDlg, BOOL   fForward,   UINT*  puNextPage, BOOL* pfKeepHistory);
BOOL CALLBACK DebugOfferCmdProc  (HWND hDlg, WPARAM wParam,     LPARAM lParam);
BOOL CALLBACK DebugOfferNotifyProc(HWND hDlg, WPARAM   wParam, LPARAM    lParam);

// Functions in ICWDEBUG.CPP
BOOL CALLBACK DebugSettingsInitProc   (HWND hDlg, BOOL fFirstInit, UINT*  puNextPage);
BOOL CALLBACK DebugSettingsOKProc     (HWND hDlg, BOOL fForward,   UINT*  puNextPage, BOOL* pfKeepHistory);
BOOL CALLBACK DebugSettingsCmdProc    (HWND hDlg, WPARAM wParam,   LPARAM lParam);

#endif //ICWDEBUG

#endif // _PAGEFCNS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\lookups.h ===
#ifndef _LOOKUPS_H
#define _LOOKUPS_H

#define LCIDLEN     124
#define CIDLEN      241
#define PLATFORMLEN 9

typedef struct LCIDstruct
{
    int    iLCID;
    TCHAR* pszLcid;

} LCIDSTRUCT;

typedef struct CIDstruct
{
    int    iCID;
    TCHAR* pszCountry;

} CIDSTRUCT;

typedef struct PlatfromStruct
{
    int    iOSType;
    int    iOSArch;
    double fOSMajor;
    TCHAR* pszOSDescription;

} PLATFORMSTRUCT;

PLATFORMSTRUCT aryPlatformLookup[PLATFORMLEN] =
{
    { 2,    2,    5.0001,    TEXT("Win 2000 Beta 3 / ICW5 on Alpha")},
    { 2,    0,    5.0001,    TEXT("Win 2000 Beta 3 / ICW5 on x86")  },
    { 1,    0,    4.0001,    TEXT("Windows 95 / ICW5")              },
    { 1,    0,    4.1   , TEXT("Windows 98 / ICW3")              },
    { 1,    0,    4.1001,    TEXT("Windows 98 / ICW5")              },
    { 1,    0,    4.1002,    TEXT("Windows 98 OSR1 / ICW5")         },
    { 2,    2,    4.0001,    TEXT("Windows NT4 / ICW5 on Alpha")    },
    { 2,    1,    4.0001,    TEXT("Windows NT4 / ICW5 on MIPS")     },
    { 2,    0,    4.0001,    TEXT("Windows NT4 / ICW5 on x86")      }
};

LCIDSTRUCT aryLCIDLookup[LCIDLEN] =
{
    {   -1,  TEXT("All Languages")                      },
    { 1025,  TEXT("Arabic (Saudi Arabia)")              },
    { 1026,  TEXT("Bulgarian")                          },
    { 1027,  TEXT("Catalan")                            },
    { 1028,  TEXT("Chinese (Taiwan)")                   },
    { 1029,  TEXT("Czech")                              },
    { 1030,  TEXT("Danish")                             },
    { 1031,  TEXT("German (Standard)")                  },
    { 1032,  TEXT("Greek")                              },
    { 1033,  TEXT("English (US)")                       },
    { 1034,  TEXT("Spanish (Spain - Traditional Sort)") },
    { 1035,  TEXT("Finnish")                            },
    { 1036,  TEXT("French (Standard)")                  },
    { 1037,  TEXT("Hebrew")                             },
    { 1038,  TEXT("Hungarian")                          },
    { 1039,  TEXT("Icelandic")                          },
    { 1040,  TEXT("Italian")                            },
    { 1041,  TEXT("Japanese")                           },
    { 1042,  TEXT("Korean")                             },
    { 1043,  TEXT("Dutch (Standard)")                   },
    { 1044,  TEXT("Norwegian (Bokmal)")                 },
    { 1045,  TEXT("Polish")                             },
    { 1046,  TEXT("Portugeuse (Brazil)")                },
    { 1047,  TEXT("Rhaeto-Romantic")                    },
    { 1048,  TEXT("Romanian")                           },
    { 1049,  TEXT("Russian")                            },
    { 1050,  TEXT("Croatia")                            },
    { 1051,  TEXT("Slovak")                             },
    { 1052,  TEXT("Albania")                            },
    { 1053,  TEXT("Swedish")                            },
    { 1054,  TEXT("Thai")                               },
    { 1055,  TEXT("Turkish")                            },
    { 1056,  TEXT("Urdu")                               },
    { 1057,  TEXT("Indonesian")                         },
    { 1058,  TEXT("Ukrainian")                          },
    { 1059,  TEXT("Byelorussian")                       },
    { 1060,  TEXT("Slovenian")                          },
    { 1061,  TEXT("Estonia")                            },
    { 1062,  TEXT("Latvian")                            },
    { 1063,  TEXT("Lithuanian")                         },
    { 1065,  TEXT("Farsi")                              },
    { 1066,  TEXT("Vietnamese")                         },
    { 1069,  TEXT("Basque")                             },
    { 1070,  TEXT("Sorbian")                            },
    { 1071,  TEXT("FYRO Macedonian")                    },
    { 1072,  TEXT("Sutu")                               },
    { 1073,  TEXT("Tsonga")                             },
    { 1074,  TEXT("Tswana")                             },
    { 1075,  TEXT("Venda")                              },
    { 1076,  TEXT("Xhosa")                              },
    { 1077,  TEXT("Zulu")                               },
    { 1078,  TEXT("Afrikaans")                          },
    { 1080,  TEXT("Faeroese")                           },
    { 1081,  TEXT("Hindi")                              },
    { 1082,  TEXT("Maltese")                            },
    { 1083,  TEXT("Sami (Lapland)")                     },
    { 1084,  TEXT("Gaelic (Scots / Gaidhilge)")         },
    { 1085,  TEXT("Yiddish")                            },
    { 1086,  TEXT("Malaysian")                          },
    { 2049,  TEXT("Arabic (Iraq)")                      },
    { 2052,  TEXT("Chinese (PRC)")                      },
    { 2055,  TEXT("German (Switzerland)")               },
    { 2057,  TEXT("English (UK)")                       },
    { 2058,  TEXT("Spanish (Mexico)")                   },
    { 2060,  TEXT("French (Belgium)")                   },
    { 2064,  TEXT("Italian (Switzerland)")              },
    { 2066,  TEXT("Korean (Johab)")                     },
    { 2067,  TEXT("Dutch (Belgium)")                    },
    { 2068,  TEXT("Norwegian (Nynorsk)")                },
    { 2070,  TEXT("Portugeuse (Standard)")              },
    { 2072,  TEXT("Romanian (Moldavia)")                },
    { 2073,  TEXT("Russian (Moldavia)")                 },
    { 2074,  TEXT("Serbian (Latin)")                    },
    { 2108,  TEXT("Gaelic (Irish)")                     },
    { 3073,  TEXT("Arabic (Egypt)")                     },
    { 3076,  TEXT("Chinese (Hong Kong SAR)")            },
    { 3079,  TEXT("German (Austria)")                   },
    { 3081,  TEXT("English (Austrailia)")               },
    { 3082,  TEXT("Spanish (Spain - Modern Sort)")      },
    { 3084,  TEXT("French (Canada)")                    },
    { 3098,  TEXT("Serbian (Cyrillic)")                 },
    { 4097,  TEXT("Arabic (Libya)")                     },
    { 4100,  TEXT("Chinese (Singapore)")                },
    { 4103,  TEXT("German (Luxembourg)")                },
    { 4105,  TEXT("English (Canada)")                   },
    { 4106,  TEXT("Spanish (Guatemala)")                },
    { 4108,  TEXT("French (Switzerland)")               },
    { 5121,  TEXT("Arabic (Algeria)")                   },
    { 5127,  TEXT("German (Liechtenstein)")             },
    { 5129,  TEXT("English (New Zealand)")              },
    { 5130,  TEXT("Spanish (Costa Rica)")               },
    { 5132,  TEXT("French (Luxembourg)")                },
    { 6145,  TEXT("Arabic (Morocco)")                   },
    { 6153,  TEXT("English (Ireland)")                  },
    { 6154,  TEXT("Spanish (Panama)")                   },
    { 7169,  TEXT("Arabic (Tunisia)")                   },
    { 7177,  TEXT("English (South Africa)")             },
    { 7178,  TEXT("Spanish (Dominican Republic)")       },
    { 8193,  TEXT("Arabic (Oman)")                      },
    { 8201,  TEXT("English (Jamacia)")                  },
    { 8202,  TEXT("Spanish (Venezuela)")                },
    { 9217,  TEXT("Arabic (Yemen)")                     },
    { 9225,  TEXT("English (Carribean)")                },
    { 9226,  TEXT("Spanish (Colombia)")                 },
    { 10241, TEXT("Arabic (Syria)")                     },
    { 10249, TEXT("English (Belize)")                   },
    { 10250, TEXT("Spanish (Peru)")                     },
    { 11265, TEXT("Arabic (Jordan)")                    },
    { 11273, TEXT("English (Trinidad)")                 },
    { 11274, TEXT("Spanish (Argentina)")                },
    { 12289, TEXT("Arabic (Lebanon)")                   },
    { 12298, TEXT("Spanish (Ecuador)")                  },
    { 13313, TEXT("Arabic (Kuwait)")                    },
    { 13322, TEXT("Spanish (Chile)")                    },
    { 14337, TEXT("Arabic (UAE)")                       },
    { 14346, TEXT("Spanish (Uruguay)")                  },
    { 15361, TEXT("Arabic (Bahrain)")                   },
    { 15370, TEXT("Spanish (Paraguay)")                 },
    { 16385, TEXT("Arabic (Qatar)")                     },
    { 16394, TEXT("Spanish (Boliva)")                   },
    { 17418, TEXT("Spanish (El Salvador)")              },
    { 18442, TEXT("Spanish (Honduras)")                 },
    { 19466, TEXT("Spanish (Nicaragua)")                },
    { 20490, TEXT("Spanish (Puerto Rico)")              }
};

CIDSTRUCT aryCIDLookup[CIDLEN] =
{
    { 1,    TEXT("United States of America")                           },
    { 7,    TEXT("Russia")                                             },
    { 20,   TEXT("Egypt")                                              },
    { 27,   TEXT("South Africa")                                       },
    { 30,   TEXT("Greece")                                             },
    { 31,   TEXT("Netherlands")                                        },
    { 32,   TEXT("Belgium")                                            },
    { 33,   TEXT("France")                                             },
    { 34,   TEXT("Spain")                                              },
    { 36,   TEXT("Hungary")                                            },
    { 39,   TEXT("Italy")                                              },
    { 40,   TEXT("Romania")                                            },
    { 41,   TEXT("Switzerland")                                        },
    { 42,   TEXT("Czech Republic")                                     },
    { 43,   TEXT("Austria")                                            },
    { 44,   TEXT("United Kingdom")                                     },
    { 45,   TEXT("Denmark")                                            },
    { 46,   TEXT("Sweden")                                             },
    { 47,   TEXT("Norway")                                             },
    { 48,   TEXT("Poland")                                             },
    { 49,   TEXT("Germany")                                            },
    { 51,   TEXT("Peru")                                               },
    { 52,   TEXT("Mexico")                                             },
    { 53,   TEXT("Cuba")                                               },
    { 54,   TEXT("Argentina")                                          },
    { 55,   TEXT("Brazil")                                             },
    { 56,   TEXT("Chile")                                              },
    { 57,   TEXT("Colombia")                                           },
    { 58,   TEXT("Venezuela")                                          },
    { 60,   TEXT("Malaysia")                                           },
    { 61,   TEXT("Australia")                                          },
    { 62,   TEXT("Indonesia")                                          },
    { 63,   TEXT("Philippines")                                        },
    { 64,   TEXT("New Zealand")                                        },
    { 65,   TEXT("Singapore")                                          },
    { 66,   TEXT("Thailand")                                           },
    { 81,   TEXT("Japan")                                              },
    { 82,   TEXT("Korea (South)")                                      },
    { 84,   TEXT("Vietnam")                                            },
    { 86,   TEXT("China")                                              },
    { 90,   TEXT("Turkey")                                             },
    { 91,   TEXT("India")                                              },
    { 92,   TEXT("Pakistan")                                           },
    { 93,   TEXT("Afghanistan")                                        },
    { 94,   TEXT("Sri Lanka")                                          },
    { 95,   TEXT("Myanmar")                                            },
    { 98,   TEXT("Iran")                                               },
    { 101,  TEXT("Anguilla")                                           },
    { 102,  TEXT("Antigua")                                            },
    { 103,  TEXT("Bahamas")                                            },
    { 104,  TEXT("Barbados")                                           },
    { 105,  TEXT("Bermuda")                                            },
    { 106,  TEXT("British Virgin Islands")                             },
    { 107,  TEXT("Canada")                                             },
    { 108,  TEXT("Cayman Islands")                                     },
    { 109,  TEXT("Dominica")                                           },
    { 110,  TEXT("Dominican Republic")                                 },
    { 111,  TEXT("Grenada")                                            },
    { 112,  TEXT("Jamaica")                                            },
    { 113,  TEXT("Montserrat")                                         },
    { 114,  TEXT("Nevis")                                              },
    { 115,  TEXT("St. Kitts")                                          },
    { 116,  TEXT("St. Vincent and the Grenadines")                     },
    { 117,  TEXT("Trinidad and Tobago")                                },
    { 118,  TEXT("Turks and Caicos Islands")                           },
    { 120,  TEXT("Barbuda")                                            },
    { 121,  TEXT("Puerto Rico")                                        },
    { 122,  TEXT("Saint Lucia")                                        },
    { 123,  TEXT("United States Virgin Islands")                       },
    { 212,  TEXT("Morocco")                                            },
    { 213,  TEXT("Algeria")                                            },
    { 216,  TEXT("Tunisia")                                            },
    { 218,  TEXT("Libya")                                              },
    { 220,  TEXT("Gambia")                                             },
    { 221,  TEXT("Senegal Republic")                                   },
    { 222,  TEXT("Mauritania")                                         },
    { 223,  TEXT("Mali")                                               },
    { 224,  TEXT("Guinea")                                             },
    { 225,  TEXT("Cote d'Ivoire")                                      },
    { 226,  TEXT("Burkina Faso")                                       },
    { 227,  TEXT("Niger")                                              },
    { 228,  TEXT("Togo")                                               },
    { 229,  TEXT("Benin")                                              },
    { 230,  TEXT("Mauritius")                                          },
    { 231,  TEXT("Liberia")                                            },
    { 232,  TEXT("Sierra Leone")                                       },
    { 233,  TEXT("Ghana")                                              },
    { 234,  TEXT("Nigeria")                                            },
    { 235,  TEXT("Chad")                                               },
    { 236,  TEXT("Central African Republic")                           },
    { 237,  TEXT("Cameroon")                                           },
    { 238,  TEXT("Cape Verde Islands")                                 },
    { 239,  TEXT("Sao Tome and Principe")                              },
    { 240,  TEXT("Equatorial Guinea")                                  },
    { 241,  TEXT("Gabon")                                              },
    { 242,  TEXT("Congo")                                              },
    { 243,  TEXT("Congo (DRC)")                                        },
    { 244,  TEXT("Angola")                                             },
    { 245,  TEXT("Guinea-Bissau")                                      },
    { 246,  TEXT("Diego Garcia")                                       },
    { 247,  TEXT("Ascension Island")                                   },
    { 248,  TEXT("Seychelle Islands")                                  },
    { 249,  TEXT("Sudan")                                              },
    { 250,  TEXT("Rwanda")                                             },
    { 251,  TEXT("Ethiopia")                                           },
    { 252,  TEXT("Somalia")                                            },
    { 253,  TEXT("Djibouti")                                           },
    { 254,  TEXT("Kenya")                                              },
    { 255,  TEXT("Tanzania")                                           },
    { 256,  TEXT("Uganda")                                             },
    { 257,  TEXT("Burundi")                                            },
    { 258,  TEXT("Mozambique")                                         },
    { 260,  TEXT("Zambia")                                             },
    { 261,  TEXT("Madagascar")                                         },
    { 262,  TEXT("Reunion Island")                                     },
    { 263,  TEXT("Zimbabwe")                                           },
    { 264,  TEXT("Namibia")                                            },
    { 265,  TEXT("Malawi")                                             },
    { 266,  TEXT("Lesotho")                                            },
    { 267,  TEXT("Botswana")                                           },
    { 268,  TEXT("Swaziland")                                          },
    { 269,  TEXT("Mayotte Island")                                     },
    { 290,  TEXT("St. Helena")                                         },
    { 291,  TEXT("Eritrea")                                            },
    { 297,  TEXT("Aruba")                                              },
    { 298,  TEXT("Faeroe Islands")                                     },
    { 299,  TEXT("Greenland")                                          },
    { 350,  TEXT("Gibraltar")                                          },
    { 351,  TEXT("Portugal")                                           },
    { 352,  TEXT("Luxembourg")                                         },
    { 353,  TEXT("Ireland")                                            },
    { 354,  TEXT("Iceland")                                            },
    { 355,  TEXT("Albania")                                            },
    { 356,  TEXT("Malta")                                              },
    { 357,  TEXT("Cyprus")                                             },
    { 358,  TEXT("Finland")                                            },
    { 359,  TEXT("Bulgaria")                                           },
    { 370,  TEXT("Lithuania")                                          },
    { 371,  TEXT("Latvia")                                             },
    { 372,  TEXT("Estonia")                                            },
    { 373,  TEXT("Moldova")                                            },
    { 374,  TEXT("Armenia")                                            },
    { 375,  TEXT("Belarus")                                            },
    { 376,  TEXT("Andorra")                                            },
    { 378,  TEXT("San Marino")                                         },
    { 379,  TEXT("Vatican City")                                       },
    { 380,  TEXT("Ukraine")                                            },
    { 381,  TEXT("Yugoslavia")                                         },
    { 385,  TEXT("Croatia")                                            },
    { 386,  TEXT("Slovenia")                                           },
    { 387,  TEXT("Bosnia and Herzegovina")                             },
    { 389,  TEXT("F.Y.R.O.M. (Former Yugoslav Republic of Macedonia)") },
    { 420,  TEXT("Czech Republic")                                     },
    { 421,  TEXT("Slovak Republic")                                    },
    { 500,  TEXT("Falkland Islands (Islas Malvinas)")                  },
    { 501,  TEXT("Belize")                                             },
    { 502,  TEXT("Guatemala")                                          },
    { 503,  TEXT("El Salvador")                                        },
    { 504,  TEXT("Honduras")                                           },
    { 505,  TEXT("Nicaragua")                                          },
    { 506,  TEXT("Costa Rica")                                         },
    { 507,  TEXT("Panama")                                             },
    { 508,  TEXT("St. Pierre and Miquelon")                            },
    { 509,  TEXT("Haiti")                                              },
    { 590,  TEXT("Guadeloupe")                                         },
    { 591,  TEXT("Bolivia")                                            },
    { 592,  TEXT("Guyana")                                             },
    { 593,  TEXT("Ecuador")                                            },
    { 594,  TEXT("French Guiana")                                      },
    { 595,  TEXT("Paraguay")                                           },
    { 596,  TEXT("Martinique")                                         },
    { 597,  TEXT("Suriname")                                           },
    { 598,  TEXT("Uruguay")                                            },
    { 599,  TEXT("Netherlands Antilles")                               },
    { 670,  TEXT("Saipan Island")                                      },
    { 671,  TEXT("Guam")                                               },
    { 672,  TEXT("Christmas Island")                                   },
    { 673,  TEXT("Brunei")                                             },
    { 674,  TEXT("Nauru")                                              },
    { 675,  TEXT("Papua New Guinea")                                   },
    { 676,  TEXT("Tonga")                                              },
    { 677,  TEXT("Solomon Islands")                                    },
    { 678,  TEXT("Vanuatu")                                            },
    { 679,  TEXT("Fiji Islands")                                       },
    { 680,  TEXT("Palau")                                              },
    { 681,  TEXT("Wallis and Futuna Islands")                          },
    { 682,  TEXT("Cook Islands")                                       },
    { 683,  TEXT("Niue")                                               },
    { 684,  TEXT("American Samoa")                                     },
    { 685,  TEXT("Samoa")                                              },
    { 686,  TEXT("Kiribati Republic")                                  },
    { 687,  TEXT("New Caledonia")                                      },
    { 688,  TEXT("Tuvalu")                                             },
    { 689,  TEXT("French Polynesia")                                   },
    { 690,  TEXT("Tokelau")                                            },
    { 691,  TEXT("Micronesia")                                         },
    { 692,  TEXT("Marshall Islands")                                   },
    { 705,  TEXT("Kazakhstan")                                         },
    { 706,  TEXT("Kyrgyzstan")                                         },
    { 708,  TEXT("Tajikistan")                                         },
    { 709,  TEXT("Turkmenistan")                                       },
    { 711,  TEXT("Uzbekistan")                                         },
    { 850,  TEXT("Korea (North)")                                      },
    { 852,  TEXT("Hong Kong")                                          },
    { 853,  TEXT("Macao")                                              },
    { 855,  TEXT("Cambodia")                                           },
    { 856,  TEXT("Laos")                                               },
    { 871,  TEXT("INMARSAT (Atlantic-East)")                           },
    { 872,  TEXT("INMARSAT (Pacific)")                                 },
    { 873,  TEXT("INMARSAT (Indian)")                                  },
    { 874,  TEXT("INMARSAT (Atlantic-West)")                           },
    { 880,  TEXT("Bangladesh")                                         },
    { 886,  TEXT("Taiwan")                                             },
    { 960,  TEXT("Maldives")                                           },
    { 961,  TEXT("Lebanon")                                            },
    { 962,  TEXT("Jordan")                                             },
    { 963,  TEXT("Syria")                                              },
    { 964,  TEXT("Iraq")                                               },
    { 965,  TEXT("Kuwait")                                             },
    { 966,  TEXT("Saudi Arabia")                                       },
    { 967,  TEXT("Yemen")                                              },
    { 968,  TEXT("Oman")                                               },
    { 971,  TEXT("United Arab Emirates")                               },
    { 972,  TEXT("Israel")                                             },
    { 973,  TEXT("Bahrain")                                            },
    { 974,  TEXT("Qatar")                                              },
    { 975,  TEXT("Bhutan")                                             },
    { 976,  TEXT("Mongolia")                                           },
    { 977,  TEXT("Nepal")                                              },
    { 994,  TEXT("Azerbaijan")                                         },
    { 995,  TEXT("Georgia")                                            },
    { 2691, TEXT("Comoros")                                            },
    { 3302, TEXT("Monaco")                                             },
    { 4101, TEXT("Liechtenstein")                                      },
    { 5399, TEXT("Guantanamo Bay")                                     },
    { 5901, TEXT("French Antilles")                                    },
    { 6101, TEXT("Cocos-Keeling Islands")                              },
    { 6701, TEXT("Rota Island")                                        },
    { 6702, TEXT("Tinian Island")                                      },
    { 6721, TEXT("Australian Antarctic Territory")                     },
    { 6722, TEXT("Norfolk Island")                                     }
};

#endif //_LOOKUPS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\manual.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  MANUAL.CPP - Functions for manual options page
//

//  HISTORY:
//  
//  05/13/98  jeremys  Created.
//
//*********************************************************************

#include "pre.h"
#include "icwextsn.h"
#include "icwacct.h"

extern UINT GetDlgIDFromIndex(UINT uPageIndex);
extern BOOL g_bManualPath;     
extern BOOL g_bLanPath;     

const   TCHAR  c_szICWMan[] = TEXT("INETWIZ.EXE");
const   TCHAR  c_szRegValICWCompleted[] = TEXT("Completed");

// Run the manual wizard
BOOL RunICWManProcess
(
    void
)
{
    STARTUPINFO             si;
    PROCESS_INFORMATION     pi;
    MSG                     msg ;
    DWORD                   iWaitResult = 0;
    BOOL                    bRetVal = FALSE;
    
    memset(&pi, 0, sizeof(pi));
    memset(&si, 0, sizeof(si));
    if(CreateProcess(c_szICWMan, 
                     NULL, 
                     NULL, 
                     NULL, 
                     TRUE, 
                     0, 
                     NULL, 
                     NULL, 
                     &si, 
                     &pi))
    {
        // wait for event or msgs. Dispatch msgs. Exit when event is signalled.
        while((iWaitResult=MsgWaitForMultipleObjects(1, &pi.hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
        {
            // read all of the messages in this next loop
            // removing each message as we read it
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                // how to handle quit message?
                if (msg.message == WM_QUIT)
                {
                    goto done;
                }
                else
                    DispatchMessage(&msg);
            }
        }
done:
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
    }   
    
    // See if ICWMAN completed, by checking the SmartStart Completed RegKey
    HKEY    hkey;
    if ( RegOpenKeyEx(HKEY_CURRENT_USER, 
                      ICWSETTINGSPATH,
                      0,
                      KEY_ALL_ACCESS,
                      &hkey) == ERROR_SUCCESS)
    {
        DWORD   dwType = REG_BINARY;
        DWORD   dwValue = 0;
        DWORD   cbValue = sizeof(DWORD);
        RegQueryValueEx(hkey,
                        c_szRegValICWCompleted,
                        NULL,
                        &dwType,
                        (LPBYTE) &dwValue,
                        &cbValue);                              

        RegCloseKey(hkey);
        
        bRetVal = dwValue;
    }
    
    return(bRetVal);
}

/*******************************************************************

  NAME:    ManualOptionsInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ManualOptionsInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    if (fFirstInit)
    {
        // If we are in modeless operation, then we need to 
        // quit the wizard, and launch INETWIZ.EXE
        if (gpWizardState->cmnStateData.bOEMCustom)
        {        
            ShowWindow(gpWizardState->cmnStateData.hWndApp,SW_HIDE);
            if (RunICWManProcess())
            {
                // Set the welcome state
                UpdateWelcomeRegSetting(TRUE);
            
                // Restore the desktop
                UndoDesktopChanges(g_hInstance);            
            }
        
            gfQuitWizard = TRUE;            // Quit the wizard
            return FALSE;
        }
        else
        {
            //BUGBUG  -- SHOULD BE AUTO?
            // initialize radio buttons
            CheckDlgButton(hDlg,IDC_MANUAL_MODEM, BST_CHECKED);
            TCHAR*   pszManualIntro = new TCHAR[MAX_MESSAGE_LEN * 3];
            if (pszManualIntro)
            {
                TCHAR    szTemp[MAX_MESSAGE_LEN];

                LoadString(g_hInstance, IDS_MANUAL_INTRO1, pszManualIntro, MAX_MESSAGE_LEN * 3);
                LoadString(g_hInstance, IDS_MANUAL_INTRO2, szTemp, ARRAYSIZE(szTemp));
                lstrcat(pszManualIntro, szTemp);
                SetWindowText(GetDlgItem(hDlg, IDC_MANUAL_INTRO), pszManualIntro);
                delete pszManualIntro;
            }
        }            
    }
    else
    {
        // If we are run from the Runonce with the smartreboot option, we need to 
        // jump to the Manual wiz immediately because that was where we left the user
        // last time.
        
        if (g_bManualPath || g_bLanPath)
        {
            Button_SetCheck(GetDlgItem(hDlg, IDC_MANUAL_MODEM), g_bManualPath);
            Button_SetCheck(GetDlgItem(hDlg, IDC_MANUAL_LAN), !g_bManualPath);

            if (LoadInetCfgUI(  hDlg,
                                IDD_PAGE_MANUALOPTIONS,
                                IDD_PAGE_END,
                                IsDlgButtonChecked(hDlg, IDC_MANUAL_LAN) ? WIZ_HOST_ICW_LAN : WIZ_HOST_ICW_MPHONE))
            {
                if( DialogIDAlreadyInUse( g_uICWCONNUIFirst) )
                {
                    // we're about to jump into the external apprentice, and we don't want
                    // this page to show up in our history list
                    *puNextPage = g_uICWCONNUIFirst;

                    g_bAllowCancel = TRUE;
                    if (gpINETCFGApprentice)
                        gpINETCFGApprentice->SetStateDataFromExeToDll( &gpWizardState->cmnStateData);

                }
            }
            g_bManualPath = FALSE;
            g_bLanPath = FALSE;

        }

    }

    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_MANUALOPTIONS;

    return TRUE;
}

/*******************************************************************

  NAME:         ManualOptionsCmdProc

  SYNOPSIS:     Called when a command is generated from  page

  ENTRY:        hDlg - dialog window
                wParam - wParam
                lParam - lParam
          
  EXIT:         returns TRUE 

********************************************************************/
BOOL CALLBACK ManualOptionsCmdProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
	switch (GET_WM_COMMAND_CMD(wParam, lParam)) 
    {
        case BN_DBLCLK:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            { 
                case IDC_MANUAL_MODEM: 
                case IDC_MANUAL_LAN: 
                {
		            // somebody double-clicked a radio button
		            // auto-advance to the next page
		            PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
                    break;
                }
            }
		    break;
    }

    return TRUE;
}



/*******************************************************************

  NAME:    ManualOptionsOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ManualOptionsOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);
    BOOL    bRet = TRUE;
    
    if (fForward)
    {
        if( IsDlgButtonChecked(hDlg, IDC_MANUAL_MODEM) )
        {
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_SMARTREBOOT_MANUAL;
        }
        else
        {
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_SMARTREBOOT_LAN;
        }

        bRet = FALSE;
        // read radio button state
        *pfKeepHistory = FALSE;
        if (LoadInetCfgUI(  hDlg,
                            IDD_PAGE_MANUALOPTIONS,
                            IDD_PAGE_END,
                            IsDlgButtonChecked(hDlg, IDC_MANUAL_LAN) ? WIZ_HOST_ICW_LAN : WIZ_HOST_ICW_MPHONE))
        {
            if( DialogIDAlreadyInUse( g_uICWCONNUIFirst) )
            {
                // we're about to jump into the external apprentice, and we don't want
                // this page to show up in our history list
                bRet = TRUE;
                *puNextPage = g_uICWCONNUIFirst;
                g_bAllowCancel = TRUE;
                if (gpINETCFGApprentice)
                    gpINETCFGApprentice->SetStateDataFromExeToDll( &gpWizardState->cmnStateData);

            }
        }
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\reboot.cpp ===
//**********************************************************************
// File name: reboot.cpp
//
//      Desktop manipulation functions
//
// Functions:
//
// Copyright (c) 1992 - 1998 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include <shlobj.h>

extern TCHAR  g_szProductCode[];
extern TCHAR  g_szPromoCode[];
extern TCHAR  g_szOemCode[];
extern TCHAR* g_pszCmdLine;

#define SHELL_LINK_NAME   TEXT("icwstart.lnk")
#define KEYVALUE_SIGNUPID TEXT("iSignUp")

#define MsgBox(m,s) MessageBox(NULL,GetSz(m),GetSz(IDS_APPNAME),s)
#define MB_MYERROR (MB_APPLMODAL | MB_ICONERROR | MB_SETFOREGROUND)

class RegEntry
{
    public:
        RegEntry(LPCTSTR pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
        ~RegEntry();
        
        long    GetError()    { return _error; }
        long    SetValue(LPCTSTR pszValue, LPCTSTR string);
        LPTSTR    GetString(LPCTSTR pszValue, LPTSTR string, unsigned long length);
        long    DeleteValue(LPCTSTR pszValue);

    private:
        HKEY    _hkey;
        long    _error;
        BOOL    bhkeyValid;
};

RegEntry::RegEntry(LPCTSTR pszSubKey, HKEY hkey)
{
    _error = RegCreateKey(hkey, pszSubKey, &_hkey);
    if (_error) {
        bhkeyValid = FALSE;
    }
    else {
        bhkeyValid = TRUE;
    }
}

RegEntry::~RegEntry()
{ 
    if (bhkeyValid) {
        RegCloseKey(_hkey); 
    }
}

long RegEntry::SetValue(LPCTSTR pszValue, LPCTSTR string)
{
    if (bhkeyValid) {
        _error = RegSetValueEx(_hkey, pszValue, 0, REG_SZ, (LPBYTE) string,
                               sizeof(TCHAR)*(lstrlen(string)+1));
    }
    return _error;
}

LPTSTR RegEntry::GetString(LPCTSTR pszValue, LPTSTR string, unsigned long length)
{
    DWORD     dwType = REG_SZ;
    
    if (bhkeyValid) {
        _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)string,
                    &length);
    }
    if (_error) {
        *string = '\0';
         return NULL;
    }

    return string;
}

long RegEntry::DeleteValue(LPCTSTR pszValue)
{
    if (bhkeyValid) {
      _error = RegDeleteValue(_hkey, (LPTSTR) pszValue);
  }
  return _error;
}

/*******************************************************************
    ARULM -- copied from JeremyS's UTIL.C in original INETCFG.DLL

    NAME:        PrepareForRunOnceApp

    SYNOPSIS:    Copies wallpaper value in registry to make the runonce
                app happy

    NOTES:        The runonce app (the app that displays a list of apps
                that are run once at startup) has a bug.  At first boot,
                it wants to change the wallpaper from the setup wallpaper
                to what the user had before running setup.  Setup tucks
                the "old" wallpaper away in a private key, then changes
                the wallpaper to the setup wallpaper.  After the runonce
                app finishes, it looks in the private key to get the old
                wallpaper and sets that to be the current wallpaper.
                However, it does this all the time, not just at first boot!
                The end effect is that whenever you do anything that
                causes runonce.exe to run (add stuff thru add/remove
                programs control panel), your wallpaper gets set back to
                whatever it was when you installed win 95.  This is
                especially bad for Plus!, since wallpaper settings are an
                important part of the product.

                To work around this bug, we copy the current wallpaper settings
                (which we want preserved) to setup's private key.  When
                runonce runs it will say "aha!" and copy those values back
                to the current settings.

********************************************************************/

// "Control Panel\\Desktop"
static const TCHAR szRegPathDesktop[] =      REGSTR_PATH_DESKTOP;

// "Software\\Microsoft\\Windows\\CurrentVersion\\Setup"
static const TCHAR szRegPathSetupWallpaper[] =  REGSTR_PATH_SETUP REGSTR_KEY_SETUP;

static const TCHAR szRegValWallpaper[]     = TEXT("Wallpaper");
static const TCHAR szRegValTileWallpaper[] = TEXT("TileWallpaper");

#define LD_USEDESC     0x00000001
#define LD_USEARGS     0x00000002
#define LD_USEICON     0x00000004
#define LD_USEWORKDIR  0x00000008
#define LD_USEHOTKEY   0x00000010
#define LD_USESHOWCMD  0x00000020

typedef struct {  
    // Mandatory members  
    LPTSTR pszPathname;   // Pathname of original object  
    DWORD  fdwFlags;       // LD_* flags ORed together for optional members  
    // Optional members  
    LPTSTR pszDesc;       // Description of link file (its filename)  
    LPTSTR pszArgs;       // command-line arguments  
    LPTSTR pszIconPath;   // Pathname of file containing the icon  
    LPTSTR pszWorkingDir; // Working directory when process starts  
    int    nIconIndex;      // Index of icon in pszIconPath  
    int    nShowCmd;        // How to show the initial window  
    WORD   wHotkey;        // Hot key for the link
} LINKDATA, *PLINKDATA;

HRESULT WINAPI Shell_CreateLink (LPCTSTR pszLinkFilePathname, PLINKDATA pld);

VOID PrepareForRunOnceApp(VOID)
{
    // open a key to the current wallpaper settings
    RegEntry reDesktop(szRegPathDesktop,HKEY_CURRENT_USER);
    Assert(reDesktop.GetError() == ERROR_SUCCESS);

    // open a key to the private setup section
    RegEntry reSetup(szRegPathSetupWallpaper,HKEY_LOCAL_MACHINE);
    Assert(reSetup.GetError() == ERROR_SUCCESS);

    if (reDesktop.GetError() == ERROR_SUCCESS &&
        reSetup.GetError() == ERROR_SUCCESS) {
        TCHAR szWallpaper[MAX_PATH+1] = TEXT("");
        TCHAR szTiled[10] = TEXT("");    // big enough for "1" + slop

        // get the current wallpaper name
        if (reDesktop.GetString(szRegValWallpaper,szWallpaper,
            sizeof(szWallpaper))) {

            // set the current wallpaper name in setup's private section
            UINT uRet=reSetup.SetValue(szRegValWallpaper,szWallpaper);
            Assert(uRet == ERROR_SUCCESS);

            // get the current 'tiled' value. 
            reDesktop.GetString(szRegValTileWallpaper,szTiled,
                sizeof(szTiled));

            // set the 'tiled' value in setup's section
            if (lstrlen(szTiled)) {
                uRet=reSetup.SetValue(szRegValTileWallpaper,szTiled);
                Assert(uRet == ERROR_SUCCESS);
            }
        }
    }
} 


//+----------------------------------------------------------------------------
//
//    Function    SetStartUpCommand
//
//    Synopsis    On an NT machine the RunOnce method is not reliable.  Therefore
//                we will restart the ICW by placing a .BAT file in the common
//                startup directory.
//
//    Arguments    lpCmd - command line used to restart the ICW
//
//    Returns        TRUE if it worked
//                FALSE otherwise.
//
//    History        1-10-97    ChrisK    Created
//
//-----------------------------------------------------------------------------

BOOL SetStartUpCommand(LPTSTR lpCmd, LPTSTR lpArgs)
{
    BOOL bRC = FALSE;
    TCHAR szCommandLine[MAX_PATH + 1];
    LPITEMIDLIST lpItemDList = NULL;
    HRESULT hr = ERROR_SUCCESS;
    IMalloc *pMalloc = NULL;

    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_STARTUP,&lpItemDList)))  
    {
        if (SHGetPathFromIDList(lpItemDList, szCommandLine))
        {
            // make sure there is a trailing \ character
            if ('\\' != szCommandLine[lstrlen(szCommandLine)-1])
                lstrcat(szCommandLine, TEXT("\\"));
            lstrcat(szCommandLine,SHELL_LINK_NAME);                     

            //Setup our link structure            
            LINKDATA ld;
            ld.pszPathname   = lpCmd; 
            ld.fdwFlags      = LD_USEARGS;
            ld.pszArgs       = lpArgs;
         
            //Create the shorLD_USEWORKDIRtcut in start-up
            if(SUCCEEDED(Shell_CreateLink(szCommandLine,  &ld)))
                bRC = TRUE;
        }
      
        // Free up the memory allocated for LPITEMIDLIST
        if (SUCCEEDED (SHGetMalloc (&pMalloc)))
        {
            //Don't worry about the return value of the function 
            //since even if we can't clean up the mem the shortcut was 
            //created so in that sense the function "succeded"
            pMalloc->Free (lpItemDList);
            pMalloc->Release ();
        }
    }

    return bRC;
}

HRESULT WINAPI Shell_CreateLink (LPCTSTR pszLinkFilePathname, PLINKDATA pld) 
{  
    HRESULT hres;  
    IShellLink* psl;  
    IPersistFile* ppf;  
    hres = CoInitialize(NULL);  // Create a shell link object  
    hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (PVOID *) &psl); 
    if (SUCCEEDED(hres)) 
    {   // Initialize the shell link object   
        psl->SetPath(pld->pszPathname);   
        if (pld->fdwFlags & LD_USEARGS)      
            psl->SetArguments(pld->pszArgs);   
        if (pld->fdwFlags & LD_USEDESC)      
            psl->SetDescription(pld->pszDesc);   
        if (pld->fdwFlags & LD_USEICON)      
            psl->SetIconLocation(pld->pszIconPath, pld->nIconIndex);   
        if (pld->fdwFlags & LD_USEWORKDIR)      
            psl->SetWorkingDirectory(pld->pszWorkingDir);   
        if (pld->fdwFlags & LD_USESHOWCMD)      
            psl->SetShowCmd(pld->nShowCmd);   
        if (pld->fdwFlags & LD_USEHOTKEY)      
            psl->SetHotkey(pld->wHotkey);   
        
        // Save the shell link object on the disk   
        hres = psl->QueryInterface(IID_IPersistFile, (PVOID *) &ppf);   
        if (SUCCEEDED(hres)) 
        {
            hres = ppf->Save(A2W(pszLinkFilePathname), TRUE);

            ppf->Release();   
        }   
        psl->Release();  
    }  
    CoUninitialize();  
    return(hres);
}

//+----------------------------------------------------------------------------
//
//    Function:    DeleteStartUpCommand
//
//    Synopsis:    After restart the ICW we need to delete the .bat file from
//                the common startup directory
//
//    Arguements: None
//
//    Returns:    None
//
//    History:    1-10-97    ChrisK    Created
//
//-----------------------------------------------------------------------------
void DeleteStartUpCommand ()
{
    TCHAR szFileName[MAX_PATH + 1];
    LPITEMIDLIST lpItemDList = NULL;
    IMalloc *pMalloc = NULL;

    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL,CSIDL_STARTUP,&lpItemDList)))
    {
        if (SHGetPathFromIDList(lpItemDList, szFileName))
        {
            // make sure there is a trailing \ character
            if ('\\' != szFileName[lstrlen(szFileName)-1])
                lstrcat(szFileName,TEXT("\\"));
            lstrcat(szFileName,SHELL_LINK_NAME);                     
    
            //delete the shortcut
            DeleteFile(szFileName);
        }
      
        // Free up the memory allocated for LPITEMIDLIST
        if (SUCCEEDED (SHGetMalloc (&pMalloc)))
        {
            //Don't worry about the return value of the function 
            //since even if we can't clean up the mem the shortcut was 
            //created so in that sense the function "succeded"
            pMalloc->Free (lpItemDList);
            pMalloc->Release ();
        }
    }
}

//    Function    CopyUntil
//
//    Synopsis    Copy from source until destination until running out of source
//                or until the next character of the source is the chend character
//
//    Arguments    dest - buffer to recieve characters
//                src - source buffer
//                lpdwLen - length of dest buffer
//                chend - the terminating character
//
//    Returns        FALSE - ran out of room in dest buffer
//
//    Histroy        10/25/96    ChrisK    Created
//-----------------------------------------------------------------------------
static BOOL CopyUntil(LPTSTR *dest, LPTSTR *src, LPDWORD lpdwLen, TCHAR chend)
{
    while (('\0' != **src) && (chend != **src) && (0 != *lpdwLen))
    {
        **dest = **src;
        (*lpdwLen)--;
        (*dest)++;
        (*src)++;
    }
    return (0 != *lpdwLen);
}

//+----------------------------------------------------------------------------
//
//    Function:    FGetSystemShutdownPrivledge
//
//    Synopsis:    For windows NT the process must explicitly ask for permission
//                to reboot the system.
//
//    Arguements:    none
//
//    Return:        TRUE - privledges granted
//                FALSE - DENIED
//
//    History:    8/14/96    ChrisK    Created
//
//    Note:        BUGBUG for Win95 we are going to have to softlink to these
//                entry points.  Otherwise the app won't even load.
//                Also, this code was originally lifted out of MSDN July96
//                "Shutting down the system"
//-----------------------------------------------------------------------------
BOOL FGetSystemShutdownPrivledge()
{
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tkp;
 
    BOOL bRC = FALSE;
    OSVERSIONINFO osver;
    
    ZeroMemory(&osver,sizeof(osver));
    osver.dwOSVersionInfoSize = sizeof(osver);
    if (GetVersionEx(&osver))
    {
        if (VER_PLATFORM_WIN32_NT == osver.dwPlatformId)
        {
            // 
            // Get the current process token handle 
            // so we can get shutdown privilege. 
            //

            if (!OpenProcessToken(GetCurrentProcess(), 
                    TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) 
                    goto FGetSystemShutdownPrivledgeExit;

            //
            // Get the LUID for shutdown privilege.
            //

            ZeroMemory(&tkp,sizeof(tkp));
            LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, 
                    &tkp.Privileges[0].Luid); 

            tkp.PrivilegeCount = 1;  /* one privilege to set    */ 
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 

            //
            // Get shutdown privilege for this process.
            //

            AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, 
                (PTOKEN_PRIVILEGES) NULL, 0); 

            if (ERROR_SUCCESS == GetLastError())
                bRC = TRUE;
        }
        else
        {
            bRC = TRUE;
        }
    }
FGetSystemShutdownPrivledgeExit:
    if (hToken) CloseHandle(hToken);
    return bRC;
}

BOOL SetupForReboot(long lRebootType)
{
    UINT   uRebootFlags;
    TCHAR* pszNewArgs = NULL;

    switch (lRebootType)
    {
        case 0:
            uRebootFlags = EWX_REBOOT;
            break;
            
        case 1:
            uRebootFlags = EWX_LOGOFF;
            break;
    }    
    //
    // twiddle the registry to work around a bug 
    // where it trashes the wallpaper
    //
    PrepareForRunOnceApp();

    LPTSTR lpRunOnceCmd;

    lpRunOnceCmd = (LPTSTR)GlobalAlloc(GPTR,MAX_PATH*2 + 1);

    if (lpRunOnceCmd)
    {
        GetModuleFileName(NULL, lpRunOnceCmd, MAX_PATH);

        //for smart reboot
        pszNewArgs = (TCHAR*)malloc((lstrlen(g_pszCmdLine)+MAX_PATH)*sizeof(TCHAR));
        
        if(pszNewArgs)
        {
            lstrcpy(pszNewArgs, g_pszCmdLine);
            lstrcat(pszNewArgs, TEXT(" "));
            lstrcat(pszNewArgs, SMARTREBOOT_CMD);
            lstrcat(pszNewArgs, TEXT(" "));
            if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_SMARTREBOOT_NEWISP)
                lstrcat(pszNewArgs, NEWISP_SR);
            else if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_SMARTREBOOT_AUTOCONFIG)
                lstrcat(pszNewArgs, AUTO_SR);
            else if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_SMARTREBOOT_MANUAL)
                lstrcat(pszNewArgs, MANUAL_SR);
            else if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_SMARTREBOOT_LAN)
                lstrcat(pszNewArgs, LAN_SR);
        }

        if (FALSE == SetStartUpCommand(lpRunOnceCmd, (pszNewArgs ? pszNewArgs : g_pszCmdLine)))
            MsgBox(IDS_CANTSAVEKEY,MB_MYERROR);
        else
        {
            if (!FGetSystemShutdownPrivledge() ||
                !ExitWindowsEx(uRebootFlags,0))
            {
                MsgBox(IDS_EXITFAILED, MB_MYERROR);
            }
        }
        if(pszNewArgs)
            free(pszNewArgs);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\sbsintro.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  SBSINTRO.C - Functions for SBS introductory Wizard pages
//

//  HISTORY:
//  
//  09/01/98  vyung  Created.
//
//*********************************************************************

#include "pre.h"


/*******************************************************************

  NAME:    SbsInitProc

  SYNOPSIS:  Called when "Intro" page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK SbsInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    if (!fFirstInit)
    {
        // This is the very first page, so do not allow back
        PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);
    }
    
    gpWizardState->uCurrentPage = ORD_PAGE_SBSINTRO;
    
    return TRUE;
}



/*******************************************************************

  NAME:    SbsIntroOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from "Intro" page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK SbsIntroOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    if (fForward)
    {
                    // Do the system config checks
        if (!gpWizardState->cmnStateData.bSystemChecked && !ConfigureSystem(hDlg))
        {
         // gfQuitWizard will be set in ConfigureSystem if we need to quit
         return FALSE;
        }
        
        gpWizardState->lRefDialTerminateStatus = ERROR_SUCCESS;

        *puNextPage = ORD_PAGE_AREACODE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\tutor.cpp ===
#include "pre.h"
#include "tutor.h"

CICWTutorApp::CICWTutorApp()
{
    //init the tutorial process structs
    memset(&m_StartInfo,   0, sizeof(m_StartInfo));
    memset(&m_ProcessInfo, 0, sizeof(m_ProcessInfo));

    SetTutorAppCmdLine();
}

CICWTutorApp::~CICWTutorApp()
{
    DWORD dwExitCode = 0; //thread is dead

    if (m_ProcessInfo.hThread)
    {
        GetExitCodeThread(m_ProcessInfo.hThread, &dwExitCode);

        if (dwExitCode == STILL_ACTIVE)
           TerminateProcess(m_ProcessInfo.hProcess, 0);
 
        CloseHandle(m_ProcessInfo.hThread);
        CloseHandle(m_ProcessInfo.hProcess);
    }
}

void CICWTutorApp::SetTutorAppCmdLine()
{
    
    if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_IEAKMODE)
    {
        //we're in IEAK mode get the path from the isp file
        GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_TUTORCMDLN, ICW_DEFAULT_TUTOR, 
                                m_szTutorAppCmdLine, SIZE_OF_TUTOR_PATH, 
                                gpWizardState->cmnStateData.ispInfo.szISPFile);
    }
    else
    {
        TCHAR szOEMInfoPath [MAX_PATH] = TEXT("\0");
        
        //Try and get the path from the OEM file
        GetSystemDirectory(szOEMInfoPath, ARRAYSIZE(szOEMInfoPath));
        lstrcat(szOEMInfoPath, TEXT("\\"));
        lstrcat(szOEMInfoPath, ICW_OEMINFO_FILENAME);
        
        //we're in IEAK mode get the path from the isp file
        GetPrivateProfileString(ICW_OEMINFO_ICWSECTION, ICW_OEMINFO_TUTORCMDLN, ICW_DEFAULT_TUTOR, 
                                m_szTutorAppCmdLine, SIZE_OF_TUTOR_PATH, 
                                szOEMInfoPath);
    }
}



BOOL CALLBACK EnumThreadWndProc(HWND hwnd, LPARAM lParam)
{
    
    if(IsWindowVisible(hwnd))
    {
        SetForegroundWindow(hwnd); 
    }
    return 1;
}


void CICWTutorApp::LaunchTutorApp()
{
    ASSERT(m_szTutorAppCmdLine);
    
    DWORD dwExitCode = 0; //thread is dead

    GetExitCodeThread(m_ProcessInfo.hThread, &dwExitCode);

    if (dwExitCode != STILL_ACTIVE)
    {
        CloseHandle(m_ProcessInfo.hThread);
        CloseHandle(m_ProcessInfo.hProcess);

        CreateProcess(NULL, 
                  m_szTutorAppCmdLine, 
                  NULL, 
                  NULL, 
                  TRUE, 
                  0, 
                  NULL, 
                  NULL, 
                  &m_StartInfo, 
                  &m_ProcessInfo);
    }
    else
    {
        EnumThreadWindows(m_ProcessInfo.dwThreadId, EnumThreadWndProc, 0);      
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\serverr.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  SERVERR.CPP - Functions for server error page
//

//  HISTORY:
//  
//  06/14/98    vyung     created
//
//*********************************************************************

#include "pre.h"
#include "htmlhelp.h"

/*******************************************************************

  NAME:    ServErrorInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
            fFirstInit - TRUE if this is the first time the dialog
            is initialized, FALSE if this InitProc has been called
            before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ServErrorInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL    bRet = TRUE;
   
    if (!fFirstInit)
    {
        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_REFSERVERR;
    
        
        switch (gpWizardState->lRefDialTerminateStatus)
        {
            case SP_OUTOFDISK:
            case ERROR_PATH_NOT_FOUND: //Occurs when download could not be created due to lack of space
            case ERROR_DISK_FULL:
            {
                TCHAR szErr [MAX_MESSAGE_LEN*3] = TEXT("\0");
                LoadString(g_hInstance, IDS_NOT_ENOUGH_DISKSPACE, szErr, ARRAYSIZE(szErr));
                SetWindowText(GetDlgItem(hDlg, IDC_SERVERR_TEXT), szErr);
                break;
            }
            case INTERNET_CONNECTION_OFFLINE:
            {
                TCHAR szErr [MAX_MESSAGE_LEN*3] = TEXT("\0");
                LoadString(g_hInstance, IDS_CONNECTION_OFFLINE, szErr, ARRAYSIZE(szErr));
                SetWindowText(GetDlgItem(hDlg, IDC_SERVERR_TEXT), szErr);
                break;
            }
            default:
            {   
                if(gpWizardState->bStartRefServDownload)
                {
                    TCHAR szErr [MAX_MESSAGE_LEN*3] = TEXT("\0");
                    LoadString(g_hInstance, IDS_SERVER_ERROR_COMMON, szErr, ARRAYSIZE(szErr));
                    SetWindowText(GetDlgItem(hDlg, IDC_SERVERR_TEXT), szErr);
                }
                else
                {
                    BSTR bstrErrMsg = NULL; 
                    gpWizardState->pRefDial->get_DialErrorMsg(&bstrErrMsg);
                    SetWindowText(GetDlgItem(hDlg, IDC_SERVERR_TEXT), W2A(bstrErrMsg));
                    SysFreeString(bstrErrMsg);
                }
                break;
            }
        }

        // Currently this is removed from BETA 2
        //BSTR  bstrSupportPhoneNum = NULL; 
        //TCHAR szFmt [MAX_MESSAGE_LEN*3];
        //gpWizardState->pRefDial->get_SupportNumber(&bstrSupportPhoneNum);
        //if (bstrSupportPhoneNum)
        //{
        //    LoadString(g_hInstance, IDS_DIALERR_HELP, szFmt, ARRAYSIZE(szFmt));
        //    lstrcat(szFmt, W2A(bstrSupportPhoneNum));
        //    SetWindowText(GetDlgItem(hDlg, IDC_SERVERR_HELP), szFmt);
        //    SysFreeString(bstrSupportPhoneNum);
        //    ShowWindow(GetDlgItem(hDlg, IDC_SERVERR_HELP), SW_SHOW);
        //}
        //else
        //    ShowWindow(GetDlgItem(hDlg, IDC_SERVERR_HELP), SW_HIDE);
    }        
   
    return bRet;
}


/*******************************************************************

  NAME:    ServErrorOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
            fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
            puNextPage - if 'Next' was pressed,
            proc can fill this in with next page to go to.  This
            parameter is ingored if 'Back' was pressed.
            pfKeepHistory - page will not be kept in history if
            proc fills this in with FALSE.

  EXIT:     returns TRUE to allow page to be turned, FALSE
            to keep the same page.

********************************************************************/
BOOL CALLBACK ServErrorOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);
    // Initialze status before connecting
    gpWizardState->lRefDialTerminateStatus = ERROR_SUCCESS;
    gpWizardState->bDoneRefServDownload    = FALSE;
    gpWizardState->bDoneRefServRAS         = FALSE;
    gpWizardState->bStartRefServDownload   = FALSE;

    if (fForward)
    {
        *pfKeepHistory = FALSE;
        *puNextPage = ORD_PAGE_REFSERVDIAL;
    }
    else
    {
        BOOL bRetVal;
        // Set userpick to FALSE to regenerate connectoid
        gpWizardState->bDoUserPick = FALSE;
        gpWizardState->pRefDial->RemoveConnectoid(&bRetVal);
    }

    return TRUE;
}

BOOL CALLBACK ServErrorCmdProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{

    if ((GET_WM_COMMAND_CMD (wParam, lParam) == BN_CLICKED) &&
        (GET_WM_COMMAND_ID  (wParam, lParam) == IDC_DIAL_HELP))
    {
        HtmlHelp(NULL, ICW_HTML_HELP_TROUBLE_TOPIC, HH_DISPLAY_TOPIC, NULL);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\refdial.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************
 
//
//  REFDIAL.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"
#include "icwextsn.h"
#include <raserror.h>

extern UINT GetDlgIDFromIndex(UINT uPageIndex);
extern BOOL SetNextPage(HWND hDlg, UINT* puNextPage, BOOL* pfKeepHistory);
extern TCHAR g_szOemCode[];
extern TCHAR g_szProductCode[];
extern TCHAR g_szPromoCode[];

const TCHAR cszISPINFOPath[] = TEXT("download\\ispinfo.csv");

/*******************************************************************

  NAME:    RefServDialInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK RefServDialInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL    bRet = TRUE;
    
    // Initialize the progres bar.
    SendDlgItemMessage(hDlg, IDC_REFSERV_DIALPROGRESS, PBM_SETRANGE, 0, MAKELPARAM(0, 100));
    SendDlgItemMessage(hDlg, IDC_REFSERV_DIALPROGRESS, PBM_SETPOS, 0, 0l);

    // Hide the progress bar
    ShowWindow(GetDlgItem(hDlg, IDC_REFSERV_DIALPROGRESS), SW_HIDE);

    // Disable Back and Next
    PropSheet_SetWizButtons(GetParent(hDlg), 0);

    g_bAllowCancel = FALSE;

    if (fFirstInit)
    {
        CRefDialEvent   *pRefDialEvent;
    
        //set the redial count
        gpWizardState->iRedialCount = 0;
        gpWizardState->dwLastSelection = 0;

        // Blank out the status text initially
        SetWindowText(GetDlgItem(hDlg, IDC_REFSERV_DIALSTATUS), TEXT(""));
        
        // Setup and Event Handler
        pRefDialEvent = new CRefDialEvent(hDlg);
        if (NULL != pRefDialEvent)
        {
            HRESULT hr;
            gpWizardState->pRefDialEvents = pRefDialEvent;
            gpWizardState->pRefDialEvents->AddRef();
    
            hr = ConnectToICWConnectionPoint((IUnknown *)gpWizardState->pRefDialEvents, 
                                         DIID__RefDialEvents,
                                        TRUE,
                                        (IUnknown *)gpWizardState->pRefDial, 
                                        &gpWizardState->pRefDialEvents->m_dwCookie, 
                                        NULL);     
            
            bRet = TRUE;
                
        }
        else
        {
            //BUGBUG: Throw error message
                        
            gfQuitWizard = TRUE;
            bRet = FALSE;
        } 

        return (bRet);
    }
    else
    {      
        ASSERT(puNextPage);


        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.

        gpWizardState->uCurrentPage = ORD_PAGE_REFSERVDIAL;

        SetNextPage(hDlg, puNextPage, NULL);

        //
        // Display the messages 
        //
        TCHAR    szTemp[MAX_MESSAGE_LEN];

        if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG)
        {
            LoadString(g_hInstance, IDS_REFDIAL_1, szTemp, MAX_MESSAGE_LEN);
            SetWindowText(GetDlgItem(hDlg, IDC_REFDIAL_TEXT), szTemp);
        }
        else
        {
            TCHAR    szIntro[MAX_MESSAGE_LEN];
            LoadString(g_hInstance, IDS_REFDIAL_1, szIntro, MAX_MESSAGE_LEN);
            LoadString(g_hInstance, IDS_REFDIAL_2, szTemp, MAX_MESSAGE_LEN);
            lstrcat(szIntro, szTemp);
            SetWindowText(GetDlgItem(hDlg, IDC_REFDIAL_TEXT), szIntro);
        }

        gpWizardState->pRefDial->DoInit();
    }
    return bRet;
}


BOOL CALLBACK RefServDialPostInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL    bRet = TRUE;

    if (!fFirstInit)
    {

        // Force the Window to update
        UpdateWindow(GetParent(hDlg));
        gpWizardState->bDoneRefServRAS       = FALSE;
        gpWizardState->bStartRefServDownload = FALSE;
        gpWizardState->bDoneRefServDownload  = FALSE;
        
        if (!gpWizardState->iRedialCount)
            // If it's not a redial blank out the status text 
            SetWindowText(GetDlgItem(hDlg, IDC_REFSERV_DIALSTATUS), TEXT(""));

        if (!gpWizardState->bDoUserPick)
        {
            BSTR            bstrPhoneNum = NULL; 
            DWORD           dwFlag = (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG) ? ICW_CFGFLAG_AUTOCONFIG : 0;
            BOOL            bRetVal;

            dwFlag |= gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_SBS;

            // Setup for Dialing.  This will ensure that we are ready to dial.
            gpWizardState->pRefDial->SetupForDialing(A2W(TEXT("msicw.isp")), 
                                                     gpWizardState->cmnStateData.dwCountryCode,
                                                     A2W(gpWizardState->cmnStateData.szAreaCode),
                                                     dwFlag,
                                                     &bRetVal);

            // if /branding switch is not specified in command line, alloffers become true.
            if (!(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_DO_NOT_OVERRIDE_ALLOFFERS))
                gpWizardState->pRefDial->put_AllOfferCode(1);

            // We override oem, product and promo codes with the one from command line if there is.
            if ( *g_szOemCode || *g_szPromoCode ||
                 gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_PRODCODE_FROM_CMDLINE )
            {
                BSTR    bstrTmp;

                if( *g_szOemCode )
                    bstrTmp = A2W(g_szOemCode);
                else
                    bstrTmp = A2W(DEFAULT_OEMCODE);
                gpWizardState->pRefDial->put_OemCode(bstrTmp);

                if( gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_PRODCODE_FROM_CMDLINE )
                    bstrTmp = A2W(g_szProductCode);
                else
                    bstrTmp = A2W(DEFAULT_PRODUCTCODE);
                gpWizardState->pRefDial->put_ProductCode(bstrTmp);

                if( *g_szPromoCode )
                    bstrTmp = A2W(g_szPromoCode);
                else
                    bstrTmp = A2W(DEFAULT_PROMOCODE);
                gpWizardState->pRefDial->put_PromoCode(bstrTmp);

                // if any of /oem, /prod, or /promo is specified in command line, Alloffers becomes false
                gpWizardState->pRefDial->put_AllOfferCode(0);
            }

            if(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG)
                gpWizardState->pRefDial->put_AllOfferCode(1);

            if (bRetVal)
            {
                // Show the phone Number
                gpWizardState->pRefDial->get_DialPhoneNumber(&bstrPhoneNum);
                SetWindowText(GetDlgItem(hDlg, IDC_REFSERV_PHONENUM), W2A(bstrPhoneNum));
        
                if (ERROR_SUCCESS == gpWizardState->pRefDial->FormReferralServerURL(&bRetVal))
                {
                    gpWizardState->pRefDial->DoConnect(&bRetVal);
                }
                else
                {
                    // BUGBUG: Throw error message
                
                    gfQuitWizard = TRUE;
                    bRet =  FALSE;
                }
            }
            else
            {
                //gpWizardState->pRefDial->SelectedPhoneNumber(1, &bRetVal);
                gpWizardState->pRefDial->get_UserPickNumber(&bRetVal);
                if (bRetVal)
                {
                    gpWizardState->bDoUserPick = TRUE;

                    // Simulate the press of the NEXT button
                    PropSheet_PressButton(GetParent(hDlg),PSBTN_NEXT);
                
            
                    bRet = TRUE;
                }
                else
                {       
                    gpWizardState->pRefDial->get_QuitWizard(&bRetVal);
                    if (bRetVal)
                    {
                        gfQuitWizard = TRUE;
                        bRet = FALSE;

                    }
                    else 
                    {
                        gpWizardState->pRefDial->get_TryAgain(&bRetVal);
                        if (bRetVal)
                        {
                            PropSheet_PressButton(GetParent(hDlg),PSBTN_BACK);
                        }
                        else
                        {
                            PropSheet_PressButton(GetParent(hDlg),PSBTN_NEXT);
                        }
                    }
                }                
            }   
            SysFreeString(bstrPhoneNum);                                              
        }        
        else // else (!gpWizardState->bDoUserPick)
        {

            BOOL    bRetVal;
            BSTR    bstrPhoneNum = NULL; 

            // Have we selected a phone number from Multi number page?
            if (gpWizardState->lSelectedPhoneNumber != -1) 
            {
                gpWizardState->pRefDial->SelectedPhoneNumber(gpWizardState->lSelectedPhoneNumber, &bRetVal);
                gpWizardState->lSelectedPhoneNumber = -1;
            }

            // Show the phone Number
            gpWizardState->pRefDial->get_DialPhoneNumber(&bstrPhoneNum);
            SetWindowText(GetDlgItem(hDlg, IDC_REFSERV_PHONENUM), W2A(bstrPhoneNum));
            SysFreeString(bstrPhoneNum);

            gpWizardState->pRefDial->FormReferralServerURL(&bRetVal);
            gpWizardState->pRefDial->DoConnect(&bRetVal);
            
            gpWizardState->bDoUserPick = FALSE;

        }
    }  // endif (!Firstinit)
    return bRet;
}

/*******************************************************************

  NAME:    RefServDialOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK RefServDialOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    //Load the External Pages here
    
    if (fForward)
    {
        *pfKeepHistory = FALSE;
        // BUGBUG move this to the global state
        if (gpWizardState->bDoUserPick)
        {
            *puNextPage = ORD_PAGE_MULTINUMBER;
            return TRUE;
        }
        gpWizardState->bDoUserPick = TRUE;
        
        if (gpWizardState->bDoneRefServDownload)
        {
            // BUGBUG, need to set a legit last page, maybe!
            int iReturnPage = gpWizardState->uPageHistory[gpWizardState->uPagesCompleted - 1];

            // Set it so that We will read the new ispinfo.csv in incwconn.dll
            gpWizardState->cmnStateData.bParseIspinfo = TRUE;
            
            //Make sure we really have a file to parse, other bail to server error
            HANDLE hFile = CreateFile((LPCTSTR)cszISPINFOPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
            if (INVALID_HANDLE_VALUE != hFile)
            {            
                CloseHandle(hFile);
                gpWizardState->pRefDial->get_bIsISDNDevice(&gpWizardState->cmnStateData.bIsISDNDevice);

                if (LoadICWCONNUI(GetParent(hDlg), GetDlgIDFromIndex(iReturnPage), IDD_PAGE_DEFAULT, gpWizardState->cmnStateData.dwFlags))
                {
                    if( DialogIDAlreadyInUse( g_uICWCONNUIFirst) )
                    {
                        // we're about to jump into the external apprentice, and we don't want
                        // this page to show up in our history list
                        BOOL bRetVal;
                        *pfKeepHistory = FALSE;
                        *puNextPage = g_uICWCONNUIFirst;
                        gpWizardState->pRefDial->RemoveConnectoid(&bRetVal);
                        gpWizardState->bDoUserPick = 0;
                    
                        // Backup 1 in the history list, since we the external pages navigate back
                        // we want this history list to be in the correct spot.  Normally
                        // pressing back would back up the history list, and figure out where to
                        // go, but in this case, the external DLL just jumps right back in.
                        gpWizardState->uPagesCompleted--;
                    
                    }
                    else
                    {
                    }
                }
            }
            else
            {
                // server error
                *puNextPage = ORD_PAGE_REFSERVERR;
            }
        }
        else
        {
            if (gpWizardState->bDoneRefServRAS)
            {
                // server error
                *puNextPage = ORD_PAGE_REFSERVERR;
            }
            else
            {
                //OK so we had a dialing error but let's figure out which one...
                HRESULT hrDialErr;
                
                gpWizardState->pRefDial->get_DialError(&hrDialErr);

                switch (hrDialErr)
                {
                    case ERROR_LINE_BUSY: //Line is engaged
                    {     
                        if (gpWizardState->iRedialCount < NUM_MAX_REDIAL)
                        {   
                            //Redial
                            // Initialze status before connecting
                            gpWizardState->lRefDialTerminateStatus = ERROR_SUCCESS;
                            gpWizardState->bDoneRefServDownload    = FALSE;
                            gpWizardState->bDoneRefServRAS         = FALSE;
                            gpWizardState->bStartRefServDownload   = FALSE;

                            // Assume the user has selected a number on this page
                            // So we will not do SetupForDialing again next time
                            gpWizardState->bDoUserPick          = TRUE;

                            *puNextPage = ORD_PAGE_REFSERVDIAL;
                            gpWizardState->iRedialCount++;
                            break;
                        }
                        gpWizardState->iRedialCount = 0;
                    }
                    default:
                    {
                        // nothing special just goto the dialing error page
                        *puNextPage = ORD_PAGE_REFDIALERROR;
                        break;
                    }
                }              
            }
        }            
    }     
    else // a retry is simulated when BACK is pressed
    {
        *puNextPage = ORD_PAGE_REFSERVDIAL;
    }
    return TRUE;
}

BOOL CALLBACK RefServDialCancelProc(HWND hDlg)
{
    ASSERT(gpWizardState->pRefDial);

    //User has canceled so reset the redial count
    gpWizardState->iRedialCount = 0;
    
    gpWizardState->pRefDial->DoHangup();

    //We should make sure the wiz thinks it's a dialerr to avoid
    //the server error page
    gpWizardState->bStartRefServDownload   = FALSE;
    gpWizardState->bDoneRefServDownload    = FALSE;
    gpWizardState->bDoneRefServRAS         = FALSE;
    gpWizardState->bDoUserPick             = FALSE;
    gpWizardState->lRefDialTerminateStatus = ERROR_CANCELLED;
    PropSheet_PressButton(GetParent(hDlg),PSBTN_NEXT);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SIMPCNTR.RC
//


////////////////////////////////////////////
////////////////////////////////////////////
#ifdef ICWDEBUG

#define IDC_BROWSE                      9000
#define IDC_ISPCAB_PATH                 9009
#define IDC_ISPCAB_LIST                 9002
#define IDC_ISPCAB_PATH_LBL             9003
#define IDC_ISPCAB_LIST_LBL             9004
#define IDC_INSTRUCT_TEXT               9005
#define IDC_CAB_INSTRUCT_TEXT           9005
#define IDC_SIGNUP_PATH                 9006
#define IDC_AUTO_PATH                   9007
#define IDC_USE_NETWORK                 9008
#define IDC_MODEM                       9009
#define IDC_ISP_URL                     9090
#define IDC_OTHER_URL                   9099
#define IDC_URL                         9092
#define IDC_CHOOSE_PATH_LBL             9093
#define IDC_CHOOSE_MODEM_LBL            9094
#define IDC_CHOOSE_URL_LBL              9095
#define IDC_PATH_INSTRUCT_TEXT          9096
#define IDC_URL_LBL                     9097

#define IDS_ICWDEBUG_OFFER_TITLE        9098
#define IDS_ICWDEBUG_SETTINGS_TITLE     9099

#define IDD_ICWDEBUG_OFFER              9100
#define IDD_ICWDEBUG_SETTINGS           9101


#endif //ICWDEBUG
////////////////////////////////////////////
////////////////////////////////////////////

#define IDD_PAGE_MANUALOPTIONS          100
#define IDD_PAGE_AREACODE               101
#define IDD_PAGE_REFSERVDIAL            102
#define IDD_PAGE_INTRO                  103
#define IDD_PAGE_END                    104
#define IDD_PAGE_ENDOLS                 105
#define IDD_PAGE_DIALERROR              106
#define IDD_PAGE_MULTINUMBER            107
#define IDD_PAGE_SERVERROR              108
#define IDD_PAGE_BRANDEDINTRO           109
#define IDD_PAGE_INTRO2                 110
#define IDD_PAGE_DEFAULT                111
#define IDD_QUIT                        112
#define IDD_PAGE_SBSINTRO               113
#define IDD_EXISTINGCONNECTION          114
#define IDD_PAGE_ENDOEMCUSTOM           115
#define IDD_PAGE_SIZER                  116
#define IDD_CHOOSEWIZARD                117

#define IDC_STATIC                      -1
#define IDC_LBLTITLE                    1000
#define IDC_RUNNEW                      1001
#define IDC_RUNAUTO                     1002
#define IDC_ICWMAN                      1003
#define IDC_MANUAL_OLS                  1005
#define IDC_AREACODE                    1006
#define IDC_REFSERV_PHONENUM            1007
#define IDC_REFSERV_DIALSTATUS          1008
#define IDC_REFSERV_DIALPROGRESS        1009
#define IDC_DIALERR_TEXT                1010
#define IDC_DIALERR_MODEM               1012
#define IDC_CHANGE_NUMBER               1013
#define IDC_DIALING_PROPERTIES          1014
#define IDC_SIGUP_COUNTRY               1015
#define IDC_SIGUP_STATE                 1016
#define IDC_SIGUP_PHONE_NUMBER          1017
#define IDC_BUTTON_SIGNUP_OK            1018
#define IDC_BUTTON_SIGNUP_CANCEL        1019
#define IDC_MULTIPHONE_LIST             1020
#define IDC_SERVERR_HELP                1022
#define IDC_DIALERR_HELP                1023
#define IDC_SERVERR_TEXT                1024
#define IDC_MANUAL_LAN                  1025
#define IDC_MANUAL_MODEM                1026
#define IDC_TUTORIAL                    1028
#define IDC_COUNTRY                     1029
#define IDC_FINISH_TEXT                 1031
#define IDC_FINISH_SUPPORT_TEXT         1032
#define IDC_BRANDEDWEBVIEW              1033
#define IDC_AREADETECT                  1034
#define IDC_LBLAREA                     1035
#define IDC_LBLCOUNTRY                  1036
#define IDC_REFDIAL_TEXT                1037
#define IDC_LBLREFNUM                   1038
#define IDC_INTRO_MAINTEXT              1039
#define IDC_INTRO_SELECTOPT             1040
#define IDC_OLS_MAINTEXT                1041
#define IDC_OLS_FINISHTEXT              1042
#define IDC_DIALERR_LBLPHONENUMBER      1042
#define IDC_DIALERR_LBLCURMODEM         1043
#define IDC_DIALERR_LBLNEWNUMBER        1044
#define IDC_DIALERR_LBLCHNGNUMBER       1045
#define IDC_DIALERR_LBLHELP             1046
#define IDC_MULTINUM_MAINTEXT           1047
#define IDC_MULTINUM_LBLPHONE           1048
#define IDC_LBDIAL_FROM                 1049
#define IDC_DIAL_FROM                   1050
#define IDC_CHECK_BROWSING              1051
#define IDC_CHECK_HIDE_ICW              1052
#define IDC_MANUAL_INTRO                1053
#define IDC_BACK                        1100
#define IDC_NEXT                        1101
#define IDC_CANCEL                      1102
#define IDC_FINISH                      1103
#define IDC_EXIT_CONN                   1104
#define IDC_STATIC_ICON                 1105
#define IDC_INSERROR_FINISH_TEXT        1106
#define IDC_CLOSE_WIZ_CLICK_FINISH      1107
#define IDC_RUN_OOBE                    1108
#define IDC_RUN_NCW                     1109
#define IDC_CHOOSEWIZARD_TITLE          1110

#define IDI_ICWCONN1_ICON               200
#define IDB_WATERMARK256                210
#define IDB_WATERMARK16                 211
#define IDB_BANNER256                   212
#define IDB_BANNER16                    213
#define IDB_BANNER                      214

#define ID_NEXT_FIELD                   250
#define ID_PREV_FIELD                   251

#define IDA_ACCEL                       2000
#define IDA_INTRO2                      2001
#define IDA_AREACODE                    2002
#define IDA_ENDOEMCUSTOM                2003
#define IDA_DIALERROR                   2004


#define IDS_APPNAME                     500
#define IDS_CONNECT_DESKTOP_TITLE       501
#define IDS_CONNECT_FNAME               502
#define IDS_WANTTOEXIT                  503
#define IDS_OE_DESKTOP_TITLE            504
#define IDS_OE_APP_NAME                 505
#define IDS_DECLINETOS                  506
#define IDS_REQUIREDINFO                507                                  
#define IDS_CANTSAVEKEY                 508
#define IDS_EXITFAILED                  509                                    
#define IDS_NEEDREBOOT1                 510
#define IDS_NEEDREBOOT2                 511 
#define IDS_NEEDRESTART1                512
#define IDS_NEEDRESTART2                513
#define IDS_QUERYCANCEL                 514
#define IDS_ERR_CANNOTRUN               550
#define IDS_ERR_OUTOFMEMORY             551
#define IDS_HELPERLIB                   552
#define IDS_DLLREG_FAIL                 553
#define IDS_LOADLIB_FAIL                554
#define IDS_NODLLREG_FAIL               555
#define IDS_UTILLIB                     556
#define IDS_WIZARDLIB                   557
#define IDS_MANUALOPTS_TITLE            600
#define IDS_RASSTATUS_INITIAL           700
#define IDS_SERVERROR_TITLE             701
#define IDS_IEAK_ACCESS_DENIED          702
#define IDS_IEAK_ACCESS_DENIED_TITLE    703
#define IDS_ENDOLS_TITLE                704
#define IDS_STEP1_TITLE                 705
#define IDS_DEFAULT_ISPNAME             706
#define IDS_FINISH_TEXT                 708
#define IDS_FINISH_SUPPORT_TEXT         709
#define IDS_DIALERR_HELP                710
#define IDS_MANUAL_INTRO1               711
#define IDS_MANUAL_INTRO2               712
#define IDS_NOT_ENOUGH_DISKSPACE        713
#define IDS_DIALING_ERROR_TITLE         714
#define IDS_SERVER_ERROR_TITLE          715
#define IDS_REFDIAL_1                   716
#define IDS_REFDIAL_2                   717
#define IDS_WIZ97_TITLE_FONT_FACE       718
#define IDS_CONNECTION_OFFLINE          719
#define IDS_ADMIN_ACCESS_DENIED         720
#define IDS_ADMIN_ACCESS_DENIED_TITLE   721
#define IDS_OEMCUST_END_TITLE           723
#define IDS_DESKTOP                     724
#define IDS_SERVER_ERROR_COMMON         725
#define IDS_BACK                        750
#define IDS_NEXT                        751
#define IDS_FINISH                      752
#define IDS_CANCEL                      753
#define IDS_TUTORIAL                    754
#define IDS_EXIT_CONN                   755
#define IDS_END_SIGNUP_FINISH           757
#define IDS_END_AUTOCFG_FINISH          758
#define IDS_END_MANUAL_FINISH           759
#define IDS_PRECONFIG_ERROR_1           760
#define IDS_PRECONFIG_ERROR_1_NOINFO    761
#define IDS_PRECONFIG_ERROR_2           762
#define IDS_PRECONFIG_ERROR_2_NOINFO    763
#define IDS_INSCONFIG_ERROR_TITLE       764
#define IDS_INSCONFIG_ERROR_INSTRUCT    765
#define IDS_SHORTCUT_DESC               766
#define IDS_INSUFFICIENT_PRIV1          767
#define IDS_INSUFFICIENT_PRIV2          768

#define OEMCUSTOM_ERR_MSGFMT                        799
#define OEMCUSTOM_ERR_NOTOEMENTRY                   800
#define OEMCUSTOM_ERR_WINAPI                        801
#define OEMCUSTOM_ERR_NOMEM                         802
#define OEMCUSTOM_ERR_NOBUTTONTRANSPARENTCOLOR      803
#define OEMCUSTOM_ERR_NOBUTTONFONTSIZE              804
#define OEMCUSTOM_ERR_NOBUTTONLEFT                  805
#define OEMCUSTOM_ERR_NOBUTTONFONTFACE              806
#define OEMCUSTOM_ERR_HEADERPARAMS                  807
#define OEMCUSTOM_ERR_BUTTONPARAMS                  808
#define OEMCUSTOM_ERR_SIZE                          809
#define OEMCUSTOM_ERR_WIZARDTOP                     810
#define OEMCUSTOM_ERR_WIZARDLEFT                    811
#define OEMCUSTOM_ERR_BACKGROUND                    812
#define OEMCUSTOM_ERR_FIRSTHTML                     813
#define OEMCUSTOM_ERR_CANNOTFINDOEMCUSTINI          814

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         113
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\tutor.h ===
#ifndef __TUTOR_H
#define __TUTOR_H

#define ICW_DEFAULT_TUTOR   TEXT("icwtutor.exe")
#define SIZE_OF_TUTOR_PATH  MAX_PATH*3

class CICWTutorApp
{
public:
    CICWTutorApp  ();
    ~CICWTutorApp ();

    void LaunchTutorApp ();
    void ReplaceTutorAppCmdLine(LPTSTR lpszCmdLine)
    {
        if (lpszCmdLine)
            lstrcpyn(m_szTutorAppCmdLine, lpszCmdLine, sizeof(m_szTutorAppCmdLine));
    };
    
private:
    STARTUPINFO         m_StartInfo;
    PROCESS_INFORMATION m_ProcessInfo;
    TCHAR               m_szTutorAppCmdLine [SIZE_OF_TUTOR_PATH];

    void SetTutorAppCmdLine ();
};

#endif __TUTOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\util.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  UTIL.C - common utility functions
//

//  HISTORY:
//  
//  12/21/94  jeremys  Created.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
//            Need to keep a modified SetInternetConnectoid to set the
//            MSN backup connectoid.
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//

#include "pre.h"

// function prototypes
VOID _cdecl FormatErrorMessage(LPTSTR pszMsg,DWORD cbMsg,LPTSTR pszFmt,LPTSTR szArg);
VOID Win95JMoveDlgItem( HWND hwndParent, HWND hwndItem, int iUp );

// Static data
static const TCHAR szRegValICWCompleted[] = TEXT("Completed");

#define MAX_STRINGS                  5
#define OEM_CONFIG_INS_FILENAME      TEXT("icw\\OEMCNFG.INS")
#define OEM_CONFIG_REGKEY            TEXT("SOFTWARE\\Microsoft\\Internet Connection Wizard\\INS processing")
#define OEM_CONFIG_REGVAL_FAILED     TEXT("Process failed")
#define OEM_CONFIG_REGVAL_ISPNAME    TEXT("ISP name")
#define OEM_CONFIG_REGVAL_SUPPORTNUM TEXT("Support number")
#define OEM_CONFIG_INS_SECTION       TEXT("Entry")
#define OEM_CONFIG_INS_ISPNAME       TEXT("Entry_Name")
#define OEM_CONFIG_INS_SUPPORTNUM    TEXT("Support_Number")

int     iSzTable=0;
TCHAR   szStrTable[MAX_STRINGS][512];

//+----------------------------------------------------------------------------
// NAME: GetSz
//
//    Load strings from resources
//
//  Created 1/28/96,        Chris Kauffman
//+----------------------------------------------------------------------------
LPTSTR GetSz(WORD wszID)
{
    LPTSTR psz = szStrTable[iSzTable];
    
    iSzTable++;
    if (iSzTable >= MAX_STRINGS)
        iSzTable = 0;
        
    if (!LoadString(g_hInstance, wszID, psz, 512))
    {
        *psz = 0;
    }
    return (psz);
}

/*******************************************************************

  NAME:    MsgBox

  SYNOPSIS:  Displays a message box with the specified string ID

********************************************************************/
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons)
{
    return (MessageBox(hWnd,
                       GetSz((USHORT)nMsgID),
                       GetSz(IDS_APPNAME),
                       uIcon | uButtons));
}

/*******************************************************************

  NAME:    MsgBoxSz

  SYNOPSIS:  Displays a message box with the specified text

********************************************************************/
int MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons)
{
    return (MessageBox(hWnd,szText,GetSz(IDS_APPNAME),uIcon | uButtons));
}

void OlsFinish()
{
    QuickCompleteSignup();
    g_bRunDefaultHtm = FALSE;
    g_szShellNext[0] = '\0';
}



void SetICWComplete(void)
{
    // Set the completed bit
    HKEY    hkey          = NULL;
    DWORD   dwValue       = 1;
    DWORD   dwDisposition = 0;

    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER,
                                       ICWSETTINGSPATH,
                                       0,
                                       NULL,
                                       REG_OPTION_NON_VOLATILE, 
                                       KEY_ALL_ACCESS, 
                                       NULL, 
                                       &hkey, 
                                       &dwDisposition))

    {
        RegSetValueEx(hkey,
                      szRegValICWCompleted,
                      0,
                      REG_BINARY,
                      (LPBYTE) &dwValue,
                      sizeof(DWORD));                              

        RegCloseKey(hkey);
    }
}


LPWSTR WINAPI A2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
    ASSERT(lpa != NULL);
    ASSERT(lpw != NULL);\
    
    // verify that no illegal character present
    // since lpw was allocated based on the size of lpa
    // don't worry about the number of chars
    lpw[0] = '\0';
    MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
    return lpw;
}

LPSTR WINAPI W2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
    ASSERT(lpw != NULL);
    ASSERT(lpa != NULL);
    
    // verify that no illegal character present
    // since lpa was allocated based on the size of lpw
    // don't worry about the number of chars
    lpa[0] = '\0';
    WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
    return lpa;
}


HRESULT ConnectToICWConnectionPoint
(
    IUnknown            *punkThis, 
    REFIID              riidEvent, 
    BOOL                fConnect, 
    IUnknown            *punkTarget, 
    DWORD               *pdwCookie, 
    IConnectionPoint    **ppcpOut
)
{
    // We always need punkTarget, we only need punkThis on connect
    if (!punkTarget || (fConnect && !punkThis))
    {
        return E_FAIL;
    }

    if (ppcpOut)
        *ppcpOut = NULL;

    HRESULT hr;
    IConnectionPointContainer *pcpContainer;

    if (SUCCEEDED(hr = punkTarget->QueryInterface(IID_IConnectionPointContainer, (void **)&pcpContainer)))
    {
        IConnectionPoint *pcp;
        if(SUCCEEDED(hr = pcpContainer->FindConnectionPoint(riidEvent, &pcp)))
        {
            if(fConnect)
            {
                // Add us to the list of people interested...
                hr = pcp->Advise(punkThis, pdwCookie);
                if (FAILED(hr))
                    *pdwCookie = 0;
            }
            else
            {
                // Remove us from the list of people interested...
                hr = pcp->Unadvise(*pdwCookie);
                *pdwCookie = 0;
            }

            if (ppcpOut && SUCCEEDED(hr))
                *ppcpOut = pcp;
            else
                pcp->Release();
                pcp = NULL;    
        }
        pcpContainer->Release();
        pcpContainer = NULL;
    }
    return hr;
}

BOOL ConfirmCancel(HWND hWnd)
{
    TCHAR    szTitle[MAX_TITLE];
    TCHAR    szMessage[MAX_MESSAGE];
        
    LoadString(g_hInstance, IDS_APPNAME, szTitle, ARRAYSIZE(szTitle));
    LoadString(g_hInstance, IDS_WANTTOEXIT, szMessage, ARRAYSIZE(szMessage));
        
    if (IDYES == MessageBox(hWnd,
                            szMessage, 
                            szTitle, 
                            MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL Restart(HWND  hWnd)
{
    TCHAR   szLongString[1024];
    LPTSTR  pszSmallString1, pszSmallString2;
    
    pszSmallString1 = GetSz(IDS_NEEDRESTART1);
    pszSmallString2 = GetSz(IDS_NEEDRESTART2);
    lstrcpy(szLongString,pszSmallString1);
    lstrcat(szLongString,pszSmallString2);
        
    if (IDYES == MessageBox(hWnd,
                            szLongString, 
                            GetSz(IDS_APPNAME),
                            MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2))
    {
        SetupForReboot(1);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}                
        
void Reboot(HWND hWnd)
{
    TCHAR   szLongString[1024];
    LPTSTR  pszSmallString1, pszSmallString2;

    // 4/28/97 ChrisK
    // Fix build break, because string was too long for compiler.
    pszSmallString1 = GetSz(IDS_NEEDREBOOT1);
    pszSmallString2 = GetSz(IDS_NEEDREBOOT2);
    lstrcpy(szLongString,pszSmallString1);
    lstrcat(szLongString,pszSmallString2);
    
    //
    // ChrisK Olympus 419
    // We changed our mind again and decided to no give the user a chance to avoid rebooting.
    //
    MessageBox( hWnd,
                szLongString,
                GetSz(IDS_APPNAME),
                MB_APPLMODAL |
                MB_ICONINFORMATION |
                MB_SETFOREGROUND |
                MB_OK);

    SetupForReboot(0);
}


BOOL WINAPI ConfigureSystem(HWND hDlg)
{
    BOOL    bReboot = FALSE;
    BOOL    bRestart = FALSE;
    BOOL    bQuitWizard = FALSE;
    BOOL    bNoPWCaching = FALSE;

    PropSheet_SetWizButtons(GetParent(hDlg),0);
    gpWizardState->cmnStateData.pICWSystemConfig->ConfigSystem(&gpWizardState->cmnStateData.bSystemChecked);
    PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);
    
    if (!gpWizardState->cmnStateData.bSystemChecked)
    {
        gpWizardState->cmnStateData.pICWSystemConfig->get_NeedsReboot(&bReboot);
        if (bReboot)
        {
            Reboot(hDlg);
            gfQuitWizard = TRUE;
            return FALSE;
        }
        
        gpWizardState->cmnStateData.pICWSystemConfig->get_NeedsRestart(&bRestart);
        if (bRestart)
        {
            if (Restart(hDlg))
            {
                gfQuitWizard = TRUE;
                return FALSE;
            }                
            else
            {
                if (ConfirmCancel(hDlg))
                {
                    gfQuitWizard = TRUE;
                }
                return FALSE;
            }                
        }
        
        gpWizardState->cmnStateData.pICWSystemConfig->get_QuitWizard(&bQuitWizard);
        if(bQuitWizard)
        {
            gfQuitWizard = TRUE;
            return FALSE;
        }
        else
        {
            if (ConfirmCancel(hDlg))
                gfQuitWizard = TRUE;
            return FALSE;
            
        }
    }
    
    // Make sure there is not a policy against password caching
    gpWizardState->cmnStateData.pICWSystemConfig->CheckPasswordCachingPolicy(&bNoPWCaching);
    if (bNoPWCaching)
    {
        // too bad, no password caching, no ICW
        gfQuitWizard = TRUE;
        return FALSE;
    }
    
    return true;
}

BOOL IsNT5()
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return ((VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId) && (OsVersionInfo.dwMajorVersion >= 5));
}

BOOL IsNT()
{
    OSVERSIONINFO OsVersionInfo;

    ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OsVersionInfo);
    return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);
}

BOOL IsWhistler()
{
    BOOL            bRet = FALSE;
    OSVERSIONINFO   OsVersionInfo;

    ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&OsVersionInfo))
    {
        if (OsVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&
            OsVersionInfo.dwMajorVersion >= 5 &&
            OsVersionInfo.dwMinorVersion >= 1)
        {
            bRet = TRUE;
        }
    }

    return bRet;
}

BOOL DoesUserHaveAdminPrivleges(HINSTANCE hInstance)
{
    HKEY hKey = NULL;
    BOOL bRet = FALSE;

    if (!IsNT())
        return TRUE;

    // BUGBUG: We should allow NT5 to run in all user groups
    // except normal users.
    if (IsNT5())
        return TRUE;
    
    //
    // Ensure caller is an administrator on this machine.
    //
    if(RegOpenKeyEx(HKEY_USERS, TEXT(".DEFAULT"), 0, KEY_WRITE, &hKey) == 0)
    {
        RegCloseKey(hKey);
        bRet = TRUE;
    }

    return bRet;
}

void WINAPI FillWindowWithAppBackground
(
    HWND    hWndToFill,
    HDC     hdc
)
{
    RECT        rcUpdate;
    RECT        rcBmp;
    HDC         hdcWnd;
    HDC         hSourceDC;
    HGDIOBJ     hgdiOldBitmap; 

    // If we are passed in the DC to use then use it, otherwise get 
    // the DC from the window handle
    if (hdc)
        hdcWnd = hdc;
    else
        hdcWnd = GetDC(hWndToFill);
    hSourceDC = CreateCompatibleDC( hdcWnd ); 
            
    // Compute the client area of the main window that needs to be
    // erased, so that we can extract that chunk of the background
    // bitmap
    GetUpdateRect(hWndToFill, &rcUpdate, FALSE);
    // Make sure the rectangle is not empty
    if (IsRectEmpty(&rcUpdate))
    {
        InvalidateRect(hWndToFill, NULL, FALSE);
        GetUpdateRect(hWndToFill, &rcUpdate, FALSE);
    }
    
    rcBmp = rcUpdate;
    if (hWndToFill != gpWizardState->cmnStateData.hWndApp)
        MapWindowPoints(hWndToFill, gpWizardState->cmnStateData.hWndApp, (LPPOINT)&rcBmp, 2);

    // paint the background bitmap
    hgdiOldBitmap = SelectObject( hSourceDC, (HGDIOBJ) gpWizardState->cmnStateData.hbmBkgrnd); 
    BitBlt( hdcWnd, 
            rcUpdate.left, 
            rcUpdate.top, 
            RECTWIDTH(rcUpdate),
            RECTHEIGHT(rcUpdate),
            hSourceDC, 
            rcBmp.left, 
            rcBmp.top, 
            SRCCOPY ); 

    // Cleanup GDI Objects
    SelectObject( hSourceDC, hgdiOldBitmap ); 
            
    DeleteDC(hSourceDC);
    // If we were not passed the DC, then release the one that we
    // got from the window handle
    if (!hdc)
        ReleaseDC(hWndToFill, hdcWnd);
}

// Fill in a rectangle within the specificed DC with the app's bkgrnd.
// lpRectDC is a rectangle in the DC's coordinate space, and lpRectApp
// is a rectangle in the Apps coordinate space
void FillDCRectWithAppBackground
(
    LPRECT  lpRectDC,
    LPRECT  lpRectApp,
    HDC     hdc
    
)
{
    HDC         hSourceDC = CreateCompatibleDC( hdc ); 
    HGDIOBJ     hgdiOldBitmap; 

    // paint the background bitmap
    hgdiOldBitmap = SelectObject( hSourceDC, (HGDIOBJ) gpWizardState->cmnStateData.hbmBkgrnd); 
    BitBlt( hdc, 
            lpRectDC->left, 
            lpRectDC->top, 
            RECTWIDTH(*lpRectDC),
            RECTHEIGHT(*lpRectDC),
            hSourceDC, 
            lpRectApp->left, 
            lpRectApp->top,
            SRCCOPY ); 

    // Cleanup GDI Objects
    SelectObject( hSourceDC, hgdiOldBitmap ); 
    DeleteDC(hSourceDC);
}


BOOL CheckForOemConfigFailure(HINSTANCE hInstance)
{
    HKEY  hKey                                        = NULL;
    DWORD dwFailed                                    = 0;
    DWORD dwSize                                      = sizeof(dwFailed);
    TCHAR szIspName    [MAX_PATH+1]                   = TEXT("\0");
    TCHAR szSupportNum [MAX_PATH+1]                   = TEXT("\0");    
    TCHAR szErrMsg1    [MAX_RES_LEN]                  = TEXT("\0");    
    TCHAR szErrMsg2    [MAX_RES_LEN]                  = TEXT("\0");    
    TCHAR szErrMsgTmp1 [MAX_RES_LEN]                  = TEXT("\0");    
    TCHAR szErrMsgTmp2 [MAX_RES_LEN]                  = TEXT("\0");    
    TCHAR szCaption    [MAX_RES_LEN]                  = TEXT("\0");    
    TCHAR szErrDlgMsg  [MAX_PATH*2 + MAX_RES_LEN + 2] = TEXT("\0");    
    
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                   OEM_CONFIG_REGKEY,
                   0,
                   KEY_ALL_ACCESS,
                   &hKey);
                   
    if(hKey)
    {
        RegQueryValueEx(hKey,
                        OEM_CONFIG_REGVAL_FAILED,
                        0,
                        NULL,
                        (LPBYTE)&dwFailed,
                        &dwSize);

        if(dwFailed)
        {
            dwSize = sizeof(szIspName);

            RegQueryValueEx(hKey,
                            OEM_CONFIG_REGVAL_ISPNAME,
                            0,
                            NULL,
                            (LPBYTE)&szIspName,
                            &dwSize);

            dwSize = sizeof(szSupportNum);

            RegQueryValueEx(hKey,
                            OEM_CONFIG_REGVAL_SUPPORTNUM,
                            0,
                            NULL,
                            (LPBYTE)&szSupportNum,
                            &dwSize);

            if(*szIspName)
            {
                LoadString(hInstance, IDS_PRECONFIG_ERROR_1, szErrMsg1, ARRAYSIZE(szErrMsg1));
                wsprintf(szErrMsgTmp1, szErrMsg1, szIspName); 
                lstrcpy(szErrDlgMsg,szErrMsgTmp1);
            }
            else
            {
                LoadString(hInstance, IDS_PRECONFIG_ERROR_1_NOINFO, szErrMsg1, ARRAYSIZE(szErrMsg1));
                lstrcpy(szErrDlgMsg, szErrMsg1);
            }
            
            if(*szSupportNum)
            {
                LoadString(hInstance, IDS_PRECONFIG_ERROR_2, szErrMsg2, ARRAYSIZE(szErrMsg2));
                wsprintf(szErrMsgTmp2, szErrMsg2, szSupportNum); 
                lstrcat(szErrDlgMsg, szErrMsgTmp2);
            }
            else
            {
                LoadString(hInstance, IDS_PRECONFIG_ERROR_2_NOINFO, szErrMsg2, ARRAYSIZE(szErrMsg2));
                lstrcat(szErrDlgMsg, szErrMsg2);
            }
            
            LoadString(hInstance, IDS_APPNAME, szCaption, ARRAYSIZE(szCaption));
            
            MessageBox(NULL, szErrDlgMsg, szCaption, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);

            dwFailed = 0;

            RegSetValueEx(hKey,
                          OEM_CONFIG_REGVAL_FAILED,
                          0,
                          REG_DWORD,
                          (LPBYTE)&dwFailed,
                          sizeof(dwFailed));

            RegCloseKey(hKey);
            
            return TRUE;
        }

        RegCloseKey(hKey);
    }

    return FALSE;
}

//returns TRUE if it could successfully find locate the file 
//and attempt to configure the system, this does not mean however that the process was successful
BOOL RunOemconfigIns()
{
    TCHAR szInsPath    [MAX_PATH+1] = TEXT("\0");
    TCHAR szIspName    [MAX_PATH+1] = TEXT("\0");
    TCHAR szSupportNum [MAX_PATH+1] = TEXT("\0");    
    BOOL  bRet                      = FALSE;
    
    GetWindowsDirectory(szInsPath, MAX_PATH+1);

    if(!szInsPath)
        return FALSE;

    if(*CharPrev(szInsPath, szInsPath + lstrlen(szInsPath)) != TEXT('\\'))
        lstrcat(szInsPath, TEXT("\\"));
    
    lstrcat(szInsPath, OEM_CONFIG_INS_FILENAME);

    //if we can't find the file return false
    if(0xFFFFFFFF == GetFileAttributes(szInsPath))
        return FALSE;

    //ProcessINS will nuke the file so if we want this info we should get it now
    GetPrivateProfileString(OEM_CONFIG_INS_SECTION,
                            OEM_CONFIG_INS_ISPNAME,
                            TEXT(""),
                            szIspName,
                            ARRAYSIZE(szIspName),
                            szInsPath);
        
    GetPrivateProfileString(OEM_CONFIG_INS_SECTION,
                            OEM_CONFIG_INS_SUPPORTNUM,
                            TEXT(""),
                            szSupportNum,
                            ARRAYSIZE(szSupportNum),
                            szInsPath);

    //set silent mode to disallow UI
    gpWizardState->pINSHandler->put_SilentMode(TRUE);
    // Process the inf file.
    gpWizardState->pINSHandler->ProcessINS(A2W(szInsPath), &bRet);

    if(bRet)
         QuickCompleteSignup(); 
    else
    {        
        HKEY  hKey           = NULL;
        DWORD dwDisposition  = 0;
        DWORD dwFailed       = 1;

        //Let's make double sure we nuke the file.
        if(0xFFFFFFFF != GetFileAttributes(szInsPath))
        {
            DeleteFile(szInsPath);
        }

        RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       OEM_CONFIG_REGKEY,
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE, 
                       KEY_ALL_ACCESS, 
                       NULL, 
                       &hKey, 
                       &dwDisposition);

        if(hKey)
        {
            RegSetValueEx(hKey,
                          OEM_CONFIG_REGVAL_FAILED,
                          0,
                          REG_DWORD,
                          (LPBYTE)&dwFailed,
                          sizeof(dwFailed));
            
            RegSetValueEx(hKey,
                          OEM_CONFIG_REGVAL_ISPNAME,
                          0,
                          REG_SZ,
                          (LPBYTE)szIspName,
                          sizeof(TCHAR)*lstrlen(szIspName));
            
            RegSetValueEx(hKey,
                          OEM_CONFIG_REGVAL_SUPPORTNUM,
                          0,
                          REG_SZ,
                          (LPBYTE)szSupportNum,
                          sizeof(TCHAR)*lstrlen(szSupportNum));

            CloseHandle(hKey);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn2\bmp.h ===
/****************************************************************************
 *
 * Bmp.H
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1993
 *  All rights reserved
 *
 *  Deals with painting bitmaps on the wizard pages
 *  FelixA 1994.
 ***************************************************************************/

// BMP functions
BOOL FAR PASCAL BMP_RegisterClass(HINSTANCE hInstance);
void FAR PASCAL BMP_DestroyClass(HINSTANCE hInstance);
void FAR PASCAL BMP_Paint(HWND hwnd);
LRESULT CALLBACK BMP_WndProc( HWND hWnd, UINT wMsg, WORD wParam, LONG lParam );

// Class name
#define SU_BMP_CLASS "ms_setup_bmp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\wizdef.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  WIZDEF.H -   data structures and constants for Internet setup/signup wizard
//

//  HISTORY:
//  
//  05/13/98    donaldm     new for ICW 5.0

#ifndef _WIZDEF_H_
#define _WIZDEF_H_
#include "appdefs.h"

// Defines
#define MAX_REG_LEN         2048    // max length of registry entries
#define MAX_RES_LEN         255     // max length of string resources
#define SMALL_BUF_LEN       48      // convenient size for small text buffers



// structure to hold information about wizard state
typedef struct tagWIZARDSTATE
{
    UINT    uCurrentPage;    // index of current page wizard is on
    
    // keeps a history of which pages were visited, so user can
    // back up and we know the last page completed in case of reboot.
    UINT    uPageHistory[EXE_NUM_WIZARD_PAGES]; // array of page #'s we visited
    UINT    uPagesCompleted;         // # of pages in uPageHistory

    BOOL    fNeedReboot;    // reboot needed at end

    BOOL    bStartRefServDownload;
    BOOL    bDoneRefServDownload;
    BOOL    bDoneRefServRAS;
    BOOL    bDoUserPick;
    long    lRefDialTerminateStatus;
    long    lSelectedPhoneNumber;

    long    lLocationID;
    long    lDefaultLocationID;

    int     iRedialCount;
    // Objects that live in ICWHELP.DLL that we need to use
    IRefDial*           pRefDial;
    IDialErr*           pDialErr;
    ISmartStart*        pSmartStart;
    ITapiLocationInfo*  pTapiLocationInfo;
    IINSHandler*        pINSHandler;
    CRefDialEvent*      pRefDialEvents;
    IICWWalker*         pHTMLWalker;
    IICWWebView*        pICWWebView; // ICWWebView Object
    HINSTANCE           hInstUtilDLL;
        
    // State data that is common to both sides of the WIZARD
    CMNSTATEDATA        cmnStateData;
    DWORD               dwLastSelection;

} WIZARDSTATE;


#define IEAK_RESTRICTION_REGKEY        TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")
#define IEAK_RESTRICTION_REGKEY_VALUE  TEXT("Connwiz Admin Lock")

#endif // _WIZDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn2\debug.h ===
/*-----------------------------------------------------------------------------
	debug.h

	Declarations for debug features

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved

	Authors:
		ChrisK	Chris Kauffman

	Histroy:
		7/22/96	ChrisK	Cleaned and formatted
	
-----------------------------------------------------------------------------*/

#ifndef _PHBKDEBUG
#define _PHBKDEBUG


void Dprintf(LPCTSTR pcsz, ...);

#ifdef DEBUG
	BOOL FAssertProc(LPCTSTR szFile,  DWORD dwLine, LPCTSTR szMsg, DWORD dwFlags);
	void DebugSz(LPCTSTR psz);
	#define AssertSzFlg(f, sz, dwFlg)		( (f) ? 0 : FAssertProc(__FILE__, __LINE__, sz, dwFlg) ? DebugBreak() : 1 )
	#define AssertSz(f, sz)				AssertSzFlg(f, sz, 0)
	#define Assert(f)					AssertSz((f), "!(" #f ")")
#else
	#define DebugSz(x)
	#define AssertSzFlg(f, sz, dwFlg)
	#define AssertSz(f, sz)
	#define Assert(f)
#endif
#endif //_PHBKDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn2\dialdlg.cpp ===
//+---------------------------------------------------------------------------
// File name: dialdlg.cpp
// 
// 	This file impelements the dialing and download progress dialog
// 
// 	Copyright (C) 1996 Microsoft Corporation
// 	All rights reserved
// 
// 	Authors:
// 		ChrisK	Chris Kauffman
// 		VetriV	Vellore Vetrivelkumaran
// 
// 	History:
// 		7/22/96	ChrisK	Cleaned and formatted
// 		8/5/96	VetriV	Added WIN16 code
// 		8/19/96	ValdonB	Added "dial as is" support
// 						Fixed some memory leaks
// 
// -----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "globals.h"

#if defined(WIN16)
#include "ietapi.h"
#include <comctlie.h>
#include <string.h>

static FARPROC lpfnCallback = (FARPROC) NULL;
#endif


#define MAX_EXIT_RETRIES 10
#define WM_DIAL WM_USER+3
#define MAX_RETIES 3

PMYDEVICE g_pdevice = NULL;
PDIALDLG g_pcPDLG = NULL;



// ############################################################################
void CALLBACK LineCallback(DWORD hDevice,
						   DWORD dwMessage,
						   DWORD dwInstance,
						   DWORD dwParam1,
						   DWORD dwParam2,
						   DWORD dwParam3)
{
}

#if defined(WIN16)
static BOOL g_bFirstTime = TRUE;
#endif
HWND	g_hDialDlgWnd = NULL;


// ############################################################################
HRESULT ShowDialingDialog(LPTSTR pszConnectoid, PGATHEREDINFO pGI, LPTSTR szUrl, HINSTANCE hInst, HWND hwnd, LPTSTR szINSFile)
{
	int iRC;
	HINSTANCE hDialDLL = NULL;
#if !defined(WIN16)
	PFNDDDlg pfnDDDlg = NULL;
	DIALDLGDATA ddData;
#endif

	if (!g_pdevice) g_pdevice = (PMYDEVICE)GlobalAlloc(GPTR,sizeof(MYDEVICE));
	if (!g_pdevice)
	{
		MessageBox(hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
		iRC = ERROR_NOT_ENOUGH_MEMORY;
		goto ShowDialingDialogExit;
	}
	g_pdevice->dwTapiDev = 0xffffffff;

#if defined(WIN16)

	if (!g_pcPDLG) g_pcPDLG = (PDIALDLG)GlobalAlloc(GPTR,sizeof(DIALDLG));
	if (!g_pcPDLG)
	{
		MessageBox(hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
		iRC = ERROR_NOT_ENOUGH_MEMORY;
		goto ShowDialingDialogExit;
	}
	
	g_pcPDLG->m_pszConnectoid = (LPTSTR)GlobalAlloc(GPTR,lstrlen(pszConnectoid)+1);
	if (!g_pcPDLG->m_pszConnectoid)
	{
		iRC = ERROR_NOT_ENOUGH_MEMORY;
		goto ShowDialingDialogExit;
	}
	lstrcpy(g_pcPDLG->m_pszConnectoid,pszConnectoid);
	g_pcPDLG->m_pGI = pGI;
	g_pcPDLG->m_szUrl = szUrl;
	g_pcPDLG->g_hInst = hInst;
	g_bProgressBarVisible = FALSE;

#define DLGPROC16 DLGPROC   // Identify as only cast for Win16
	DLGPROC dlgprc;
	dlgprc = (DLGPROC16) MakeProcInstance((FARPROC)DialDlgProc, g_pcPDLG->g_hInst);
	iRC = DialogBoxParam(g_pcPDLG->g_hInst,
							MAKEINTRESOURCE(IDD_DIALING),
							hwnd, dlgprc, (LPARAM)g_pcPDLG);
	FreeProcInstance((FARPROC) dlgprc);

ShowDialingDialogExit:
	if (g_pcPDLG->m_pszConnectoid) GlobalFree(g_pcPDLG->m_pszConnectoid);
	if (g_pcPDLG->m_pszDisplayable) GlobalFree(g_pcPDLG->m_pszDisplayable);
	if (g_pcPDLG) GlobalFree(g_pcPDLG);
	g_pcPDLG = NULL;
	return iRC;
#else

	//
	// Fill in data structure
	//
	ZeroMemory(&ddData,sizeof(ddData));
	ddData.dwSize = sizeof(ddData);
	StrDup(&ddData.pszMessage,GetSz(IDS_DOWNLOAD_SW));
	StrDup(&ddData.pszRasEntryName,pszConnectoid);
	StrDup(&ddData.pszMultipartMIMEUrl,pszSetupClientURL);
	ddData.pfnStatusCallback = StatusMessageCallback;
	ddData.hInst = hInst;
	ddData.bSkipDial = (0 == uiSetupClientNewPhoneCall);
	//
	// ChrisK 8/20/97
	// Pass .ins file to dialer so that the dialer can find the password
	//
	StrDup(&ddData.pszDunFile,szINSFile);

	//
	// Load API
	//
	hDialDLL = LoadLibrary(AUTODIAL_LIBRARY);
	if (!hDialDLL)
	{
		AssertSz(0,"Can't load icwdial.\r\n");
		iRC = GetLastError();
		goto ShowDialingDialogExit;
	}

	pfnDDDlg = (PFNDDDlg)GetProcAddress(hDialDLL,"DialingDownloadDialog");
	if (!pfnDDDlg)
	{
		AssertSz(0,"Can find DialingDownloadDialog.\r\n");
		iRC = GetLastError();
		goto ShowDialingDialogExit;
	}

	//
	// Display Dialog
	//
	iRC = pfnDDDlg(&ddData);

	//
	// Free memory and clean up
	//

	if (hDialDLL) FreeLibrary(hDialDLL);
	if (ddData.pszMessage) GlobalFree(ddData.pszMessage);
	if (ddData.pszRasEntryName) GlobalFree(ddData.pszRasEntryName);
	if (ddData.pszMultipartMIMEUrl) GlobalFree(ddData.pszMultipartMIMEUrl);

ShowDialingDialogExit:
	return iRC;
#endif
}

// ############################################################################
extern "C" INT_PTR CALLBACK FAR PASCAL DialDlgProc(HWND hwnd, 
                                                   UINT uMsg, 
												   WPARAM wparam, 
												   LPARAM lparam)
{
	static UINT unRasEvent = 0;
#if defined(WIN16)
	static BOOL bUserCancelled = FALSE;
#endif
	HRESULT hr;
	//BOOL bPW;
	WORD wIDS;
	//LPRASDIALPARAMS lpRasDialParams;
	HINSTANCE hDLDLL;
	FARPROC fp;
#if !defined(WIN16)
	DWORD dwThreadResults;
#endif
	INT iRetries;
#if defined(WIN16)
	RECT	MyRect;
	RECT	DTRect;
#endif


	BOOL bRes = TRUE;

	switch(uMsg)
	{
	case WM_DESTROY:
		ReleaseBold(GetDlgItem(hwnd,IDC_LBLTITLE));
#ifdef WIN16
		DeleteDlgFont(hwnd);
#endif
		bRes = FALSE;
		break;
#if defined(WIN16)
	case WM_SYSCOLORCHANGE:
		Ctl3dColorChange();
		break;
#endif
	case WM_INITDIALOG:
		g_hDialDlgWnd = hwnd;
#if defined(WIN16)
		g_bFirstTime = TRUE;
		bUserCancelled = FALSE;
		//
		// Move the window to the center of the screen
		//
		GetWindowRect(hwnd, &MyRect);
		GetWindowRect(GetDesktopWindow(), &DTRect);
		MoveWindow(hwnd, (DTRect.right - MyRect.right) / 2, (DTRect.bottom - MyRect.bottom) /2,
							MyRect.right, MyRect.bottom, FALSE);

		SetNonBoldDlg(hwnd);
#endif
		ShowWindow(GetDlgItem(hwnd,IDC_PROGRESS),SW_HIDE);

		g_pcPDLG->m_hwnd = hwnd;
		SPParams.hwnd = hwnd;

#if !defined(WIN16)
		unRasEvent = RegisterWindowMessageA( RASDIALEVENT );
#endif
		if (unRasEvent == 0) unRasEvent = WM_RASDIALEVENT; 
		MakeBold(GetDlgItem(hwnd,IDC_LBLTITLE),TRUE,FW_BOLD);

		// Do not make a call.  We are already connected
		//

		if (uiSetupClientNewPhoneCall == FALSE)
		{
			PostMessage(hwnd,unRasEvent,(WPARAM)RASCS_Connected,0);
			break;
		}

		// Show number to be dialed
		//

		hr = GetDisplayableNumberDialDlg();
		if (hr != ERROR_SUCCESS)
		{
			SetDlgItemText(hwnd,IDC_LBLNUMBER,g_pcPDLG->m_szPhoneNumber);
		} else {
			SetDlgItemText(hwnd,IDC_LBLNUMBER,g_pcPDLG->m_pszDisplayable);
		}

		PostMessage(hwnd,WM_DIAL,0,0);
		break;

	case WM_DIAL:
		hr = DialDlg();
#if defined(DEBUG)
		if (0 != hr)
		{
			TCHAR szTempBuf[255];
			RasGetErrorString((UINT)hr, szTempBuf, 254);
			Dprintf("CONNECT: Ras error string is <%s>\n", szTempBuf);
		}
#endif
		if (hr != ERROR_SUCCESS)
			EndDialog(hwnd,(int)hr);
		break;


	case WM_CLOSE:
		if (dwDownLoad)
		{
			hDLDLL = LoadLibrary(DOWNLOAD_LIBRARY);

			if (hDLDLL)
			{
				fp = GetProcAddress(hDLDLL,DOWNLOADCANCEL);
				if(fp && dwDownLoad)
					((PFNDOWNLOADCANCEL)fp)(dwDownLoad);
				FreeLibrary(hDLDLL);
			}
		}

		if (uiSetupClientNewPhoneCall)
		{
			if (g_pcPDLG->m_hrasconn) 
			{
				RasHangUp(g_pcPDLG->m_hrasconn);
				WaitForConnectionTermination(g_pcPDLG->m_hrasconn);
			}
			g_pcPDLG->m_hrasconn = NULL;
		}

		EndDialog(hwnd,ERROR_USERCANCEL);
		break;
		
	case WM_COMMAND:
		switch(LOWORD(wparam))
		{
		case IDC_CMDCANCEL:
			if (dwDownLoad)
			{
				hDLDLL = LoadLibrary(DOWNLOAD_LIBRARY);

				if (hDLDLL)
				{
					fp = GetProcAddress(hDLDLL,DOWNLOADCANCEL);
					if(fp && dwDownLoad)
						((PFNDOWNLOADCANCEL)fp)(dwDownLoad);
					FreeLibrary(hDLDLL);
				}
#if !defined(WIN16)
			} else {
				PostMessage(hwnd,unRasEvent,RASCS_Disconnected,ERROR_USER_DISCONNECTION);
#endif //!WIN16
			}

			if (uiSetupClientNewPhoneCall)
			{
				if (g_pcPDLG->m_hrasconn) 
				{
					RasHangUp(g_pcPDLG->m_hrasconn);
					WaitForConnectionTermination(g_pcPDLG->m_hrasconn);
				}
				g_pcPDLG->m_hrasconn = NULL;
			}
			break;
		}
#if defined(WIN16)
		bUserCancelled = TRUE;
#endif
		EndDialog(hwnd,ERROR_USERCANCEL);
		break;


	case WM_DOWNLOAD_DONE:
#if !defined(WIN16)
		dwThreadResults = STILL_ACTIVE;
#endif
		
		iRetries = 0;
		
		if (uiSetupClientNewPhoneCall)
		{
			if (g_pcPDLG->m_hrasconn) 
			{
				RasHangUp(g_pcPDLG->m_hrasconn);
				WaitForConnectionTermination(g_pcPDLG->m_hrasconn);
			}
		}

#if !defined(WIN16)
		do {
			if (!GetExitCodeThread(g_pcPDLG->m_hThread,&dwThreadResults))
			{
				AssertSz(0,"CONNECT:GetExitCodeThread failed.\n");
			}

			iRetries++;
			if (dwThreadResults == STILL_ACTIVE) Sleep(500);
		} while (dwThreadResults == STILL_ACTIVE && iRetries < MAX_EXIT_RETRIES);   

		if (dwThreadResults == ERROR_SUCCESS)
			EndDialog(hwnd,ERROR_USERNEXT);
		else
			EndDialog(hwnd, dwThreadResults);
 #else
		EndDialog(hwnd, ERROR_USERNEXT);
 #endif //!WIN16
		break;


	default:
		bRes = FALSE;

		if (uMsg == unRasEvent)
		{
			Dprintf(TEXT("CONNECT2: Ras event %u error code (%ld)\n"),wparam,lparam);
#if defined(DEBUG)
			if (0 != lparam)
			{
				TCHAR szTempBuf[255];
				RasGetErrorString((UINT)lparam, szTempBuf, 254);
				Dprintf("CONNECT2: Ras error string is <%s>\n", szTempBuf);
			}
#endif

#if !defined(WIN16)
			TCHAR dzRasError[10];
			wsprintf(dzRasError,TEXT("%d %d"),wparam,lparam);
			RegSetValue(HKEY_LOCAL_MACHINE,TEXT("Software\\Microsoft\\iSignUp"),REG_SZ,dzRasError,lstrlen(dzRasError));
#endif


#if defined(WIN16)
			//
			// Work around for WIN16 RAS bug - if status code to > 0x4000 
			// adjust it to the correct value
			//
			if (wparam >= 0x4000)
				wparam -= 0x4000;
#endif							

			wIDS = 0;
			switch(wparam)
			{
			case RASCS_OpenPort:
				wIDS = IDS_RAS_OPENPORT;
				break;
			case RASCS_PortOpened:
				wIDS = IDS_RAS_PORTOPENED;
				break;
			case RASCS_ConnectDevice:
				wIDS = IDS_RAS_DIALING;
				break;
			
#if defined(WIN16)
			case RASCS_AllDevicesConnected: 
				wIDS = IDS_RAS_CONNECTED;
				break; 
#else				
			case RASCS_DeviceConnected:
				wIDS = IDS_RAS_CONNECTED;
				break;
#endif				

			case RASCS_StartAuthentication:
			case RASCS_LogonNetwork:
				wIDS = IDS_RAS_LOCATING;
				break;
//			case RASCS_CallbackComplete:
//				wIDS = IDS_RAS_CONNECTED;
//				break;

/* ETC...
				RASCS_AllDevicesConnected, 
				RASCS_Authenticate, 
				RASCS_AuthNotify, 
				RASCS_AuthRetry, 
				RASCS_AuthCallback, 
				RASCS_AuthChangePassword, 
				RASCS_AuthProject, 
				RASCS_AuthLinkSpeed, 
				RASCS_AuthAck, 
				RASCS_ReAuthenticate, 
				RASCS_Authenticated, 
				RASCS_PrepareForCallback, 
				RASCS_WaitForModemReset, 
				RASCS_WaitForCallback,
				RASCS_Projected, 
 
 
				RASCS_Interactive = RASCS_PAUSED, 
				RASCS_RetryAuthentication, 
				RASCS_CallbackSetByCaller, 
				RASCS_PasswordExpired, 
 */
			case RASCS_Connected:
#if !defined(WIN16)
				MinimizeRNAWindow(g_pcPDLG->m_pszConnectoid, g_pcPDLG->g_hInst);
#endif // !WIN16
				//
				// The connection is open and ready.  Start the download.
				//
				g_pcPDLG->m_dwThreadID = 0;
#if defined(WIN16)
				if (ThreadInit() != ERROR_SUCCESS)
					g_pcPDLG->m_hThread = NULL;
				else
					g_pcPDLG->m_hThread = 1;
#else
 				g_pcPDLG->m_hThread = CreateThread(NULL,0,
												(LPTHREAD_START_ROUTINE)ThreadInit,
												NULL,0,
												&g_pcPDLG->m_dwThreadID);
#endif 				
				if (!g_pcPDLG->m_hThread)
				{
					if (uiSetupClientNewPhoneCall)
					{
						if (g_pcPDLG->m_hrasconn) 
						{
							RasHangUp(g_pcPDLG->m_hrasconn);
							WaitForConnectionTermination(g_pcPDLG->m_hrasconn);
						}
						g_pcPDLG->m_hrasconn =  NULL;
					}
					hr = GetLastError();
#if defined(WIN16)
					if (bUserCancelled)
						hr = ERROR_USERCANCEL;
#endif
					EndDialog(hwnd,(int)hr);
					break;
				}
				break;


			case RASCS_Disconnected:
				//if (FShouldRetry(lparam))
				//	PostMessage(hwnd,WM_DIAL,0,0);
				//else
				
				if (uiSetupClientNewPhoneCall)
				{
					if (g_pcPDLG->m_hrasconn) 
					{
						RasHangUp(g_pcPDLG->m_hrasconn);
						WaitForConnectionTermination(g_pcPDLG->m_hrasconn);
					}
					g_pcPDLG->m_hrasconn = NULL;
				}
				EndDialog(hwnd, (int)lparam);
				break;

				//EndDialog(hwnd,lparam);
				//break;
			}
			if (wIDS)
				SetDlgItemText(hwnd,IDC_LBLSTATUS,GetSz(wIDS));
		}
	}
	return bRes;
}


// ############################################################################
HRESULT GetDisplayableNumberDialDlg()
{
	HRESULT hr;
	LPRASENTRY lpRasEntry = NULL;
	LPRASDEVINFO lpRasDevInfo = NULL;
	DWORD dwRasEntrySize;
	DWORD dwRasDevInfoSize;
	LPLINETRANSLATEOUTPUT lpOutput1 = NULL;
	HINSTANCE hRasDll = NULL;
	FARPROC fp = NULL;

#if !defined(WIN16)
	DWORD dwNumDev;
	LPLINETRANSLATEOUTPUT lpOutput2;
	LPLINEEXTENSIONID lpExtensionID = NULL;
#endif


	//
	// Get phone number from connectoid
	//
/*#if defined(WIN16)
	//
	// Allocate extra 256 bytes to workaround memory overrun bug in RAS
	//
	lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY)+256);
#else
	lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY));
#endif
	if (!lpRasEntry)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}

	lpRasDevInfo = (LPRASDEVINFO)GlobalAlloc(GPTR,sizeof(RASDEVINFO));
	if (!lpRasDevInfo)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}
	dwRasEntrySize = sizeof(RASENTRY);
	dwRasDevInfoSize = sizeof(RASDEVINFO);

	lpRasEntry->dwSize = dwRasEntrySize;
	lpRasDevInfo->dwSize = dwRasDevInfoSize;
*/
	/*hRasDll = LoadLibrary(RASAPI_LIBRARY);
	if (!hRasDll)
	{
		hr = GetLastError();
		goto GetDisplayableNumberExit;
	}
	fp =GetProcAddress(hRasDll,"RasGetEntryProperties");
	if (!fp)
	{
		FreeLibrary(hRasDll);
		hRasDll = LoadLibrary("RNAPH.DLL");
		if (!hRasDll)
		{
			hr = GetLastError();
			goto GetDisplayableNumberExit;
		}
		fp = GetProcAddress(hRasDll,"RasGetEntryProperties");
		if (!fp)
		{
			hr = GetLastError();
			goto GetDisplayableNumberExit;
		}
	}*/
/*	
	hr = RasGetEntryProperties(NULL,g_pcPDLG->m_pszConnectoid,
#if defined(WIN16)
								(LPBYTE)
#endif
								lpRasEntry,

								&dwRasEntrySize,
								(LPBYTE)lpRasDevInfo,&dwRasDevInfoSize);
*/
	hr = MyRasGetEntryProperties( NULL,
								  g_pcPDLG->m_pszConnectoid,
								  &lpRasEntry,
								  &dwRasEntrySize,
								  &lpRasDevInfo,
								  &dwRasDevInfoSize);

	if (hr != ERROR_SUCCESS)
	{
		goto GetDisplayableNumberExit;
	}

	//FreeLibrary(hRasDll);

	//
	// If this is a dial as is number, just get it from the structure
	//
	g_pcPDLG->m_bDialAsIs = !(lpRasEntry->dwfOptions & RASEO_UseCountryAndAreaCodes);
	if (g_pcPDLG->m_bDialAsIs)
	{
		if (g_pcPDLG->m_pszDisplayable) GlobalFree(g_pcPDLG->m_pszDisplayable);
		g_pcPDLG->m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, lstrlen(lpRasEntry->szLocalPhoneNumber)+1);
		if (!g_pcPDLG->m_pszDisplayable)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}
		lstrcpy(g_pcPDLG->m_szPhoneNumber, lpRasEntry->szLocalPhoneNumber);
		lstrcpy(g_pcPDLG->m_pszDisplayable, lpRasEntry->szLocalPhoneNumber);
	}
	else
	{
		//
		// If there is no area code, don't use parentheses
		//
		if (lpRasEntry->szAreaCode[0])
			wsprintf(g_pcPDLG->m_szPhoneNumber,TEXT("+%lu (%s) %s\0"),lpRasEntry->dwCountryCode,
						lpRasEntry->szAreaCode,lpRasEntry->szLocalPhoneNumber);
		else
			wsprintf(g_pcPDLG->m_szPhoneNumber,TEXT("+%lu %s\0"),lpRasEntry->dwCountryCode,
						lpRasEntry->szLocalPhoneNumber);

#if defined(WIN16)
		TCHAR szBuffer[1024];
		LONG lRetCode;
		
		memset(&szBuffer[0], 0, sizeof(szBuffer));
		lpOutput1 = (LPLINETRANSLATEOUTPUT) & szBuffer[0];
		lpOutput1->dwTotalSize = sizeof(szBuffer);

		lRetCode = IETapiTranslateAddress(NULL, g_pcPDLG->m_szPhoneNumber,
											0L, 0L, lpOutput1);
		
		if (0 != lRetCode)
		{
			//
			// TODO: Set the correct error code
			//
			hr = GetLastError();
			goto GetDisplayableNumberExit;
		}
		g_pcPDLG->m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, 
														((size_t)lpOutput1->dwDisplayableStringSize+1));
		if (!g_pcPDLG->m_pszDisplayable)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}

		lstrcpy(g_pcPDLG->m_pszDisplayable, 
					&szBuffer[lpOutput1->dwDisplayableStringOffset]);


#else //WIN16
		
		//
		//  Initialize TAPIness
		//
		dwNumDev = 0;
		hr = lineInitialize(&g_pcPDLG->m_hLineApp,g_pcPDLG->g_hInst,LineCallback,NULL,&dwNumDev);

		if (hr != ERROR_SUCCESS)
			goto GetDisplayableNumberExit;

		if (g_pdevice->dwTapiDev == 0xFFFFFFFF)
		{
				g_pdevice->dwTapiDev = 0;
		}

		lpExtensionID = (LPLINEEXTENSIONID )GlobalAlloc(GPTR,sizeof(LINEEXTENSIONID));
		if (!lpExtensionID)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}

		do {
			hr = lineNegotiateAPIVersion(g_pcPDLG->m_hLineApp, g_pdevice->dwTapiDev, 0x00010004, 0x00010004,
				&g_pcPDLG->m_dwAPIVersion, lpExtensionID);
		} while (hr && g_pdevice->dwTapiDev++ < dwNumDev-1);

		// ditch it since we don't use it
		//
		if (lpExtensionID) GlobalFree(lpExtensionID);
		if (hr != ERROR_SUCCESS)
			goto GetDisplayableNumberExit;

		// Format the phone number
		//

		lpOutput1 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(GPTR,sizeof(LINETRANSLATEOUTPUT));
		if (!lpOutput1)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}
		lpOutput1->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

		
		//
		// Turn the canonical form into the "displayable" form
		//
		hr = lineTranslateAddress(g_pcPDLG->m_hLineApp,g_pdevice->dwTapiDev,
									g_pcPDLG->m_dwAPIVersion,
									g_pcPDLG->m_szPhoneNumber,0,
									LINETRANSLATEOPTION_CANCELCALLWAITING,
									lpOutput1);

		if (hr != ERROR_SUCCESS || (lpOutput1->dwNeededSize != lpOutput1->dwTotalSize))
		{
			lpOutput2 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(GPTR, (size_t)lpOutput1->dwNeededSize);
			if (!lpOutput2)
			{
				hr = ERROR_NOT_ENOUGH_MEMORY;
				goto GetDisplayableNumberExit;
			}
			lpOutput2->dwTotalSize = lpOutput1->dwNeededSize;
			GlobalFree(lpOutput1);
			lpOutput1 = lpOutput2;
			lpOutput2 = NULL;
			hr = lineTranslateAddress(g_pcPDLG->m_hLineApp,g_pdevice->dwTapiDev,
										g_pcPDLG->m_dwAPIVersion,
										g_pcPDLG->m_szPhoneNumber,0,
										LINETRANSLATEOPTION_CANCELCALLWAITING,
										lpOutput1);
		}

		if (hr != ERROR_SUCCESS)
		{
			goto GetDisplayableNumberExit;
		}

		g_pcPDLG->m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, (size_t)lpOutput1->dwDisplayableStringSize+1);
		if (!g_pcPDLG->m_pszDisplayable)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}

		lstrcpyn(g_pcPDLG->m_pszDisplayable,
					(LPTSTR)&((LPBYTE)lpOutput1)[lpOutput1->dwDisplayableStringOffset],
					lpOutput1->dwDisplayableStringSize / sizeof(TCHAR) );
#endif // WIN16
	}

GetDisplayableNumberExit:
	if (lpRasEntry) GlobalFree(lpRasEntry);
	if (lpRasDevInfo) GlobalFree(lpRasDevInfo);

#if !defined(WIN16)
	if (lpOutput1) GlobalFree(lpOutput1);
	if (g_pcPDLG->m_hLineApp) lineShutdown(g_pcPDLG->m_hLineApp);
#endif
	return hr;
}



#if defined(WIN16)
//////////////////////////////////////////////////////////////////////////
// The callback proc is called during the connection process. Display
// the connection progress status in the dialer window. When connection
// is complete, change the Cancel button to Disconnect, and change the
// state to connected.
extern "C" void CALLBACK __export DialCallback(UINT uiMsg,
												RASCONNSTATE rasState,
												DWORD dwErr)
{
        if (TRUE == g_bFirstTime)
		{	
			g_bFirstTime = FALSE;
			if (RASCS_Disconnected == rasState)
				return;
		}

		//
		// WIN 3.1 does not send disconnect event on error!!!
		//
		if (0 != dwErr)
			rasState = RASCS_Disconnected;

		PostMessage(g_hDialDlgWnd, WM_RASDIALEVENT, (WPARAM) rasState, 
						(LPARAM)dwErr);
} 
#endif



HRESULT DialDlg()
{
	LPRASDIALPARAMS lpRasDialParams = NULL;
	LPRASDIALEXTENSIONS lpRasDialExtentions = NULL;
	HRESULT hr = ERROR_SUCCESS;
	BOOL bPW;

	// Get connectoid information
	//

	lpRasDialParams = (LPRASDIALPARAMS)GlobalAlloc(GPTR,sizeof(RASDIALPARAMS));
	if (!lpRasDialParams)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto DialExit;
	}
	lpRasDialParams->dwSize = sizeof(RASDIALPARAMS);
	lstrcpyn(lpRasDialParams->szEntryName,g_pcPDLG->m_pszConnectoid,
				ARRAYSIZE(lpRasDialParams->szEntryName));
	bPW = FALSE;
	hr = RasGetEntryDialParams(NULL,lpRasDialParams,&bPW);
	if (hr != ERROR_SUCCESS)
	{
		goto DialExit;
	}


	//
	// This is only used on WINNT
	//
	lpRasDialExtentions = (LPRASDIALEXTENSIONS)GlobalAlloc(GPTR,sizeof(RASDIALEXTENSIONS));
	if (lpRasDialExtentions)
	{
		lpRasDialExtentions->dwSize = sizeof(RASDIALEXTENSIONS);
		lpRasDialExtentions->dwfOptions = RDEOPT_UsePrefixSuffix;
	}


	// Add the user's password
	//
	GetPrivateProfileString(
				INFFILE_USER_SECTION,INFFILE_PASSWORD,
				NULLSZ,lpRasDialParams->szPassword,PWLEN + 1,pszINSFileName);


#if defined(WIN16)
	if (g_pcPDLG->m_bDialAsIs)
	{
		Dprintf("CONNECT: Dialing as is <%s>\n", g_pcPDLG->m_szPhoneNumber);
		lstrcpy(lpRasDialParams->szPhoneNumber, g_pcPDLG->m_szPhoneNumber);
	}
	else
	{
		//
		// Translate the number in canonical format to a dialable string
		//
		TCHAR szBuffer[1024];
		LONG lRetCode;
		LPLINETRANSLATEOUTPUT lpLine;
		
		memset(&szBuffer[0], 0, sizeof(szBuffer));
		lpLine = (LPLINETRANSLATEOUTPUT) & szBuffer[0];
		lpLine->dwTotalSize = sizeof(szBuffer);
		lRetCode = IETapiTranslateAddress(NULL, g_pcPDLG->m_szPhoneNumber, 
											0L, 0L, lpLine);
		Dprintf("CONNECT2: Dialable string retured by IETAPI is <%s>\n", 
					(LPTSTR) &szBuffer[lpLine->dwDialableStringOffset]);
		lstrcpy(lpRasDialParams->szPhoneNumber, 
					&szBuffer[lpLine->dwDialableStringOffset]);
	}
#endif

	
	// Dial connectoid
	//

	g_pcPDLG->m_hrasconn = NULL;
#if defined(WIN16)
	lpfnCallback = MakeProcInstance((FARPROC)DialCallback, g_pcPDLG->g_hInst);
	hr = RasDial(lpRasDialExtentions, NULL,lpRasDialParams,0, 
					(LPVOID)lpfnCallback,
					&g_pcPDLG->m_hrasconn);
#else
	hr = RasDial(lpRasDialExtentions,NULL,lpRasDialParams,0xFFFFFFFF, 
					(LPVOID)g_pcPDLG->m_hwnd,
					&g_pcPDLG->m_hrasconn);
#endif					
	if (hr != ERROR_SUCCESS)
	{
		if (g_pcPDLG->m_hrasconn)
		{
			RasHangUp(g_pcPDLG->m_hrasconn);
		}
		goto DialExit;
	}

DialExit:
	if (lpRasDialParams) GlobalFree(lpRasDialParams);
	if (lpRasDialExtentions) GlobalFree(lpRasDialExtentions);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn2\dialcan.cpp ===
/*-----------------------------------------------------------------------------
	dialcan.cpp

	This function handle the stern warning given when the user cancels
	setting up their Internet software

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved

	Authors:
		ChrisK	Chris Kauffman

	Histroy:
		7/22/96	ChrisK	Cleaned and formatted
	
-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "globals.h"

HRESULT ShowDialReallyCancelDialog(HINSTANCE hInst, HWND hwnd, LPTSTR pszHomePhone)
{
	INT iRC = 0;

#if defined(WIN16)		
#define DLGPROC16 DLGPROC   // Identify as only cast for Win16
	DLGPROC dlgprc;
	dlgprc = (DLGPROC16) MakeProcInstance((FARPROC)DialReallyCancelDlgProc, hInst);
	iRC = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_DIALREALLYCANCEL),
							hwnd, dlgprc, (LPARAM)pszHomePhone);
	FreeProcInstance((FARPROC) dlgprc);
#else
	iRC = (HRESULT)DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_DIALREALLYCANCEL),
							hwnd, DialReallyCancelDlgProc,
							(LPARAM)pszHomePhone);
#endif

	return iRC;
}


extern "C" INT_PTR CALLBACK FAR PASCAL DialReallyCancelDlgProc(HWND hwnd, 
																UINT uMsg, 
																WPARAM wparam, 
																LPARAM lparam)
{
	BOOL bRes = TRUE;
#if defined(WIN16)
	RECT	MyRect;
	RECT	DTRect;
#endif

	switch (uMsg)
	{
	case WM_INITDIALOG:
#if defined(WIN16)
		//
		// Move the window to the center of the screen
		//
		GetWindowRect(hwnd, &MyRect);
		GetWindowRect(GetDesktopWindow(), &DTRect);
		MoveWindow(hwnd, (DTRect.right - MyRect.right) / 2, (DTRect.bottom - MyRect.bottom) /2,
							MyRect.right, MyRect.bottom, FALSE);

		SetNonBoldDlg(hwnd);
#endif
		MakeBold(GetDlgItem(hwnd,IDC_LBLTITLE),TRUE,FW_BOLD);
		if (lparam)
			SetDlgItemText(hwnd,IDC_LBLCALLHOME,(LPCTSTR)lparam);
		bRes = TRUE;
		break;
#if defined(WIN16)
	case WM_SYSCOLORCHANGE:
		Ctl3dColorChange();
		break;
#endif
	case WM_DESTROY:
		ReleaseBold(GetDlgItem(hwnd,IDC_LBLTITLE));
#ifdef WIN16
		DeleteDlgFont(hwnd);
#endif
		bRes=FALSE;
		break;
	case WM_CLOSE:
		EndDialog(hwnd,ERROR_USERCANCEL);
		break;
	case WM_COMMAND:
		switch(LOWORD(wparam))
		{
		case IDC_CMDCANCEL:
			EndDialog(hwnd,ERROR_USERCANCEL);
			break;
		case IDC_CMDNEXT:
			EndDialog(hwnd,ERROR_USERNEXT);
			break;
		}
		break;
	default:
		bRes = FALSE;
		break;
	}
	return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn2\debug.cpp ===
/*-----------------------------------------------------------------------------
	debug.cpp

	This file implements the debuggin features

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved

	Authors:
		ChrisK	Chris Kauffman

	Histroy:
		7/22/96	ChrisK	Cleaned and formatted
		7/31/96 ValdonB Changes for Win16
	
-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include <stdio.h>
#include <string.h>
#include <stdarg.h>



#if defined(WIN16)
extern HINSTANCE g_hInst;
extern LPSTR g_lpszCommandLine;
extern LPSTR GetCommandLine(void);
#endif 


BOOL fInAssert=FALSE;

// ############################################################################
// DebugSz
//
// This function outputs debug string
// 
//  Created 1/28/96,		Chris Kauffman
// ############################################################################
void DebugSz(LPCTSTR psz)
{
#if defined(DEBUG)
	OutputDebugString(psz);
#endif	
} // DebugSz

// ############################################################################
// Debug Printf to debug output screen
void Dprintf(LPCTSTR pcsz, ...)
{
#ifdef DEBUG
	va_list	argp;
	TCHAR	szBuf[1024];
	
	va_start(argp, pcsz);

#if defined(WIN16)
	vsprintf(szBuf, pcsz, argp);
#else
	wvsprintf(szBuf, pcsz, argp);
#endif
	

	DebugSz(szBuf);
	va_end(argp);
#endif
} // Dprintf()

// ############################################################################
// Handle asserts
BOOL FAssertProc(LPCTSTR szFile,  DWORD dwLine, LPCTSTR szMsg, DWORD dwFlags)
{

	BOOL fAssertIntoDebugger = FALSE;

	TCHAR szMsgEx[1024], szTitle[255], szFileName[MAX_PATH];
	int id;
	UINT fuStyle;
	LPTSTR pszCommandLine = GetCommandLine();
	//BYTE	szTime[80];
#if !defined(WIN16)
	HANDLE	hAssertTxt;
	TCHAR	szTime[80];
	SYSTEMTIME st;
	DWORD	cbWritten;
#endif
	
	// no recursive asserts
	if (fInAssert)
		{
		DebugSz(TEXT("***Recursive Assert***\r\n"));
		return(FALSE);
		}

	fInAssert = TRUE;
	
#if defined(WIN16)
	GetModuleFileName(g_hInst, szFileName, MAX_PATH);
	wsprintf(szMsgEx,"%s:#%ld\r\n%s,\r\n%s", szFile, dwLine, szFileName, szMsg);
#else
	GetModuleFileName(NULL, szFileName, MAX_PATH);
	wsprintf(szMsgEx,TEXT("%s:#%d\r\nProcess ID: %d %s, Thread ID: %d\r\n%s"),
		szFile,dwLine,GetCurrentProcessId(),szFileName,GetCurrentThreadId(),szMsg);
#endif
	wsprintf(szTitle,TEXT("Assertion Failed"));

	fuStyle = MB_APPLMODAL | MB_ABORTRETRYIGNORE;
	fuStyle |= MB_ICONSTOP;

	DebugSz(szTitle);		
	DebugSz(szMsgEx);		

	// dump the assert into ASSERT.TXT
#if !defined(WIN16)
	hAssertTxt = CreateFile(TEXT("assert.txt"), GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
	if (INVALID_HANDLE_VALUE != hAssertTxt) 
		{
		SetFilePointer(hAssertTxt, 0, NULL, FILE_END);
		GetLocalTime(&st);   
		wsprintf(szTime, TEXT("\r\n\r\n%02d/%02d/%02d %d:%02d:%02d\r\n"), st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
		WriteFile(hAssertTxt, szTime, lstrlen(szTime), &cbWritten, NULL);
		WriteFile(hAssertTxt, szMsgEx, lstrlen(szMsgEx), &cbWritten, NULL);
		CloseHandle(hAssertTxt);
		}
#endif

    id = MessageBox(NULL, szMsgEx, szTitle, fuStyle);
    switch (id)
    	{
    	case IDABORT:
#if defined(WIN16)
			exit(0);
#else
    		ExitProcess(0);
#endif
    		break;
    	case IDCANCEL:
    	case IDIGNORE:
    		break;
    	case IDRETRY:
    		fAssertIntoDebugger = TRUE;
    		break;
    	}
				
	fInAssert = FALSE;  
	
	return(fAssertIntoDebugger);
} // AssertProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn2\dialerr.cpp ===
/*-----------------------------------------------------------------------------
	dialerr.cpp

	This file implements the Could Not Connect dialog

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved

	Authors:
		ChrisK	Chris Kauffman

	Histroy:
		7/22/96	ChrisK	Cleaned and formatted
		8/19/96	ValdonB	Added ability to edit phone number
						Fixed some memory leaks
	
-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "globals.h"

#if defined(WIN16)
#include <string.h>
#include <ietapi.h>
#endif

TCHAR szBuf256[256];
TCHAR szValidPhoneCharacters[] = {TEXT("0123456789AaBbCcDdPpTtWw!@$ -.()+*#,&\0")};

#ifdef WIN16
	#define g_iMyMaxPhone	36
#else
	int g_iMyMaxPhone = 0;
	#define MAXPHONE_NT		80
	#define MAXPHONE_95		36
#endif


PDIALERR g_pcDialErr = NULL;

//////////////////////////////////////////////////////////////////////////
// Keyboard hook
static HHOOK    hKeyHook = NULL;        // our key hook
static HOOKPROC hpKey = NULL;           // hook proc

//+---------------------------------------------------------------------------
//
//	Function:	ProcessDBCS
//
//	Synopsis:	Converts control to use DBCS compatible font
//				Use this at the beginning of the dialog procedure
//	
//				Note that this is required due to a bug in Win95-J that prevents
//				it from properly mapping MS Shell Dlg.  This hack is not needed
//				under winNT.
//
//	Arguments:	hwnd - Window handle of the dialog
//				cltID - ID of the control you want changed.
//
//	Returns:	ERROR_SUCCESS
// 
//	History:	4/31/97 a-frankh	Created
//				5/13/97	jmazner		Stole from CM to use here
//----------------------------------------------------------------------------
void ProcessDBCS(HWND hDlg, int ctlID)
{
#if defined(WIN16)
	return;
#else
	HFONT hFont = NULL;

	if( IsNT() )
	{
		return;
	}

	hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
	if (hFont == NULL)
		hFont = (HFONT) GetStockObject(SYSTEM_FONT);
	if (hFont != NULL)
		SendMessage(GetDlgItem(hDlg,ctlID), WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0));
#endif
}



HRESULT ShowDialErrDialog(PGATHEREDINFO pGI, HRESULT hrErr, 
							LPTSTR pszConnectoid, HINSTANCE hInst, 
							HWND hwnd)
{
	int iRC;
//	CDialErrDlg *pcDED = NULL;

	g_pcDialErr = (PDIALERR)GlobalAlloc(GPTR,sizeof(DIALERR));
	if (!g_pcDialErr)
	{
		MessageBox(hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
		iRC = ERROR_NOT_ENOUGH_MEMORY;
		goto ShowDialErrDialogExit;
	}
	
	g_pcDialErr->m_pszConnectoid = (LPTSTR)GlobalAlloc(GPTR,RAS_MaxEntryName+1);
	if (!g_pcDialErr->m_pszConnectoid)
	{
		iRC = ERROR_NOT_ENOUGH_MEMORY;
		goto ShowDialErrDialogExit;
	}
	lstrcpy(g_pcDialErr->m_pszConnectoid,pszConnectoid);
	g_pcDialErr->m_pGI = pGI;
	g_pcDialErr->m_hrError = hrErr;
	g_pcDialErr->m_hInst = hInst;

#if defined(WIN16)		
#define DLGPROC16 DLGPROC   // Identify as only cast for Win16
	DLGPROC dlgprc;
	dlgprc = (DLGPROC16) MakeProcInstance((FARPROC)DialErrDlgProc, 
											g_pcDialErr->m_hInst);
	iRC = DialogBoxParam(g_pcDialErr->m_hInst,
							MAKEINTRESOURCE(IDD_DIALERR),
							hwnd, dlgprc, (LPARAM)g_pcDialErr);
	FreeProcInstance((FARPROC) dlgprc);
#else
	iRC = (HRESULT)DialogBoxParam(g_pcDialErr->m_hInst,MAKEINTRESOURCE(IDD_DIALERR),
							hwnd, DialErrDlgProc,
							(LPARAM)g_pcDialErr);
#endif

ShowDialErrDialogExit:
	if (g_pcDialErr->m_pszConnectoid) GlobalFree(g_pcDialErr->m_pszConnectoid);
	if (g_pcDialErr->m_pszDisplayable) GlobalFree(g_pcDialErr->m_pszDisplayable);
	if (g_pcDialErr->m_lprasdevinfo) GlobalFree(g_pcDialErr->m_lprasdevinfo);
	g_pcDialErr->m_lprasdevinfo = NULL;
	if (g_pcDialErr) GlobalFree(g_pcDialErr);
	g_pcDialErr = NULL;
	return iRC;
}

//+----------------------------------------------------------------------------
//
//	Function	LclSetEntryScriptPatch
//
//	Synopsis	Softlink to RasSetEntryPropertiesScriptPatch
//
//	Arguments	see RasSetEntryPropertiesScriptPatch
//
//	Returns		see RasSetEntryPropertiesScriptPatch
//
//	Histroy		10/3/96	ChrisK Created
//
//-----------------------------------------------------------------------------

BOOL LclSetEntryScriptPatch(LPTSTR lpszScript,LPTSTR lpszEntry)
{
	HINSTANCE hinst = NULL;
	LCLSETENTRYSCRIPTPATCH fp = NULL;
	BOOL bRC = FALSE;

	hinst = LoadLibrary(TEXT("ICWDIAL.DLL"));
	if (hinst)
	{
		fp = (LCLSETENTRYSCRIPTPATCH)GetProcAddress(hinst,"RasSetEntryPropertiesScriptPatch");
		if (fp)
			bRC = (fp)(lpszScript,lpszEntry);
		FreeLibrary(hinst);
		hinst = NULL;
		fp = NULL;
	}
	return bRC;
}

// ############################################################################
// HelpKybdHookProc
//
// Keyboard hook proc - check for F1, and if detected, fake a Help button
// hit to the main dialog.
//
// Paramters:
//		iCode		Windows message code
//		wParam		Windows wParam (contains virtual key code)
//		lParam		Windows lParam
//
// History:
//		8/26/96	ValdonB	Adapted from IEDIAL.C
//
// ############################################################################
#if defined(WIN16)
LRESULT CALLBACK _export HelpKybdHookProc
#else
LRESULT WINAPI HelpKybdHookProc
#endif
(
    int iCode,
    WPARAM wParam,
    LPARAM lParam
)
{
    LRESULT    lRet = 0;

	Assert(g_pcDialErr->m_hwnd);
    if ((iCode != HC_NOREMOVE && iCode >= 0) &&
		(GetActiveWindow() == g_pcDialErr->m_hwnd))
    {
        // HC_NOREMOVE indicates that message is being
        // retrieved using PM_NOREMOVE from peek message,
        // if iCode < 0, then we should not process... dont
        // know why, but sdk says so.
        if (wParam == VK_F1 && !(lParam & 0x80000000L))
        {
            // bit 32 == 1 if key is being release, else 0 if
            // key is being pressed
            PostMessage(g_pcDialErr->m_hwnd, WM_COMMAND, (WPARAM)IDC_CMDHELP, 0);
        }
    }
    if (hKeyHook)
    {
        lRet = CallNextHookEx(hKeyHook, iCode, wParam, lParam);
    }
    return(lRet);
}

// ############################################################################
// HelpInit
//
// Install a windows hook proc to launch help on F1
//
// History:
//		8/26/96	ValdonB	Adapted from IEDIAL.C
//
// ############################################################################
static void HelpInit()
{
    // now install the hook for the keyboard filter
    hpKey = (HOOKPROC)MakeProcInstance((FARPROC)HelpKybdHookProc,
                                        g_pcDialErr->m_hInst);
    if (hpKey)
    {
        hKeyHook = SetWindowsHookEx(WH_KEYBOARD, hpKey, g_pcDialErr->m_hInst,
#if defined(WIN16)
									GetCurrentTask());
#else
									GetCurrentThreadId());
#endif
    }
}


// ############################################################################
// HelpShutdown
//
// Shutdown the keyboard hook
//
// History:
//		8/26/96	ValdonB	Adapted from IEDIAL.C
//
// ############################################################################
static void HelpShutdown()
{
    // remove the hook
    if (hKeyHook)
    {
        UnhookWindowsHookEx(hKeyHook);
    }

    // dump the thunk
    if (hpKey)
    {
        FreeProcInstance((FARPROC)hpKey);
    }
}


extern "C" INT_PTR CALLBACK FAR PASCAL DialErrDlgProc(HWND hwnd, 
													UINT uMsg, 
													WPARAM wparam, 
													LPARAM lparam)
{
	BOOL bRes = TRUE;
	HRESULT hr;
	//LPLINEEXTENSIONID lpExtensionID;
#if !defined(WIN16)
	DWORD dwNumDev;
#endif
	//RNAAPI *pcRNA = NULL;
	WORD wIDS;
	LRESULT idx;
	LPRASENTRY lpRasEntry = NULL;
	LPRASDEVINFO lpRasDevInfo = NULL;
	DWORD dwRasEntrySize;
	DWORD dwRasDevInfoSize;
	HINSTANCE hRasDll = NULL;
	FARPROC fp = NULL;
	LPTSTR lpszDialNumber = NULL;
	static BOOL bCheckDisplayable = FALSE;
    static BOOL bInitComplete = FALSE; // if we initialize  the dialog - MKarki
    static BOOL bDlgPropEnabled = TRUE;   //this flags holds state of Dialing Properties PushButton MKarki - (5/3/97/) Fix for Bug#3393
#if defined(WIN16)
	RECT	MyRect;
	RECT	DTRect;
#endif

	RNAAPI *pRnaapi = NULL;

	static BOOL fUserEditedNumber = FALSE;

	switch(uMsg)
	{
	case WM_INITDIALOG:
		g_pcDialErr->m_hwnd = hwnd;

#if defined(WIN16)
		//
		// Move the window to the center of the screen
		//
		GetWindowRect(hwnd, &MyRect);
		GetWindowRect(GetDesktopWindow(), &DTRect);
		MoveWindow(hwnd, (DTRect.right - MyRect.right) / 2, (DTRect.bottom - MyRect.bottom) /2,
							MyRect.right, MyRect.bottom, FALSE);

		SetNonBoldDlg(hwnd);
#endif

		// Set limit on phone number length
		// Note: this should really be RAS_MaxPhoneNumber (128), but RAS is choking on 
		// anything longer than 100 bytes, so we'll have to limit it to that.
		//
		// 6/3/97 jmazner Olympus #4851
		// RAS has different limits on w95 and NT
		//
#ifndef WIN16
		if( IsNT() )
		{
			g_iMyMaxPhone = MAXPHONE_NT;
		}
		else
		{
			g_iMyMaxPhone = MAXPHONE_95;
		}
#endif
		AssertSz( (sizeof(g_pcDialErr->m_szPhoneNumber) >= g_iMyMaxPhone), "Maximum phone number is greater than m_szPhoneNumber" );

		SendDlgItemMessage(hwnd,IDC_TEXTNUMBER,EM_SETLIMITTEXT,g_iMyMaxPhone,0);

		// Show the phone number
		//
		hr = DialErrGetDisplayableNumber();
		if (hr != ERROR_SUCCESS)
		{
			bCheckDisplayable = FALSE;
			SetDlgItemText(hwnd,IDC_TEXTNUMBER,g_pcDialErr->m_szPhoneNumber);
		} else {
			bCheckDisplayable = TRUE;
			SetDlgItemText(hwnd,IDC_TEXTNUMBER,g_pcDialErr->m_pszDisplayable);
		}

		MakeBold(GetDlgItem(hwnd,IDC_LBLTITLE),TRUE,FW_BOLD);

		// Fill in error message
		//
		wIDS = (WORD)RasErrorToIDS(g_pcDialErr->m_hrError);
		AssertSz(wIDS != -1,"RasErrorToIDS got an error message it did not understand");

		if (wIDS != -1 && wIDS !=0)
			SetDlgItemText(hwnd,IDC_LBLERRMSG,GetSz(wIDS));

		ProcessDBCS(hwnd,IDC_CMBMODEMS);
		ProcessDBCS(hwnd,IDC_TEXTNUMBER);

		FillModems();
		
		// Set the focus to the Modems selection list
		//
	    SetFocus(GetDlgItem(hwnd,IDC_CMBMODEMS));

		// hook the keyboard for F1 help
		HelpInit();

		bRes = FALSE;

        //
        //  we should disable the Dialing Properites PushButton
        //  if we have changed the phone number once
        //  MKarki (5/3/97) - Fix for Bug#3393
        //
        if (FALSE == bDlgPropEnabled)
        {
            EnableWindow (
                GetDlgItem (hwnd, IDC_CMDDIALPROP), 
                FALSE
                );
        }

        //
        // This shows the INIT for the error dialog is complete
        // and we can start processing changes to Ph No. TEXTBOX
        // MKarki (4/24/97) - Fix for Bug#3511
        //
        bInitComplete = TRUE;

		break;

#if defined(WIN16)
	case WM_SYSCOLORCHANGE:
		Ctl3dColorChange();
		break;
#endif
	case WM_DESTROY:
		ReleaseBold(GetDlgItem(hwnd,IDC_LBLTITLE));
#ifdef WIN16
		DeleteDlgFont(hwnd);
#endif
		// Shutdown the keyboard hook
		HelpShutdown();

		bRes = FALSE;
		break;

	case WM_CLOSE:
		//if (MessageBox(hwnd,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
		//	MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
		//	EndDialog(hwnd,ERROR_USERCANCEL);
		EndDialog(hwnd,ERROR_USERCANCEL);
		break;
	
#if !defined(WIN16)
	case WM_HELP:
		//
		// Chrisk Olympus 5130 5/27/97
		// Added support for F1 Help Key
		//
			WinHelp(hwnd,TEXT("connect.hlp>proc4"),HELP_CONTEXT,(DWORD)ICW_TRB);
#endif

	case WM_COMMAND:
		switch(LOWORD(wparam))
		{
        //
        // We now processes changes to ph no. EDIT BOX
        // If there is anychange in the phone number we
        // disable to Dialing Properties Push Button
        // MKarki (3/22/97) - Fix for Bug #3511
        //
        case IDC_TEXTNUMBER:
			TCHAR lpszTempNumber[RAS_MaxPhoneNumber +1];

            if ((HIWORD (wparam) == EN_CHANGE) && (bInitComplete == TRUE))
            {
                if ((GetDlgItemText (
                            hwnd,
                            IDC_TEXTNUMBER,
                            lpszTempNumber,
                            RAS_MaxPhoneNumber
                            ))  && 
            		(0 != lstrcmp(
                             lpszTempNumber, 
                              bCheckDisplayable ? g_pcDialErr->m_pszDisplayable :g_pcDialErr->m_szPhoneNumber)))
			    {
                    //
                    // number has been modified by the user
                    // hide the Dialing Properties Push Button  
                    //
                    EnableWindow (
                            GetDlgItem (hwnd, IDC_CMDDIALPROP), 
                            FALSE
                            );
                    //
                    // save the state of the Dialing Properties PushButton
                    // MKarki (5/3/97) -  Fix for Bug#3393
                    //
                    bDlgPropEnabled = FALSE;
					
					//
					// 7/17/97 jmazner Olympus #8234
					//
					fUserEditedNumber = TRUE;
                }
            }
            break;

		case IDC_CMBMODEMS:
			if (HIWORD(wparam) == CBN_SELCHANGE)
			{

				idx = SendDlgItemMessage(hwnd,IDC_CMBMODEMS,CB_GETCURSEL,0,0);
				//
				// ChrisK Olympus 245 5/25/97
				// Get index of modem
				//
				idx = SendDlgItemMessage(hwnd,IDC_CMBMODEMS,CB_GETITEMDATA,idx,0);
				if (idx == CB_ERR) break;

				// Get the connectoid
				//

/***** this code is made obsolete by the call to MyRasGetEntryProperties below
#if defined(WIN16)
				//
				// Allocate extra 256 bytes to workaround memory overrun bug in RAS
				//
				lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY)+256);
#else
				lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY));
#endif
				if (!lpRasEntry)
				{
					MessageBox(hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
					break;
				}

				lpRasDevInfo = (LPRASDEVINFO)GlobalAlloc(GPTR,sizeof(RASDEVINFO));
				if (!lpRasDevInfo)
				{
					MessageBox(hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
					break;
				}
				dwRasEntrySize = sizeof(RASENTRY);
				dwRasDevInfoSize = sizeof(RASDEVINFO);

				lpRasEntry->dwSize = dwRasEntrySize;
				lpRasDevInfo->dwSize = dwRasDevInfoSize;
*******/
				
/*				hRasDll = LoadLibrary(RASAPI_LIBRARY);
				if (!hRasDll)
				{
					hr = GetLastError();
					break;
				}
				fp =GetProcAddress(hRasDll,"RasGetEntryPropertiesA");
				if (!fp)
				{
					FreeLibrary(hRasDll);
					hRasDll = LoadLibrary(TEXT("RNAPH.DLL"));
					if (!hRasDll)
					{
						hr = GetLastError();
						break;
					}
					fp = GetProcAddress(hRasDll,"RasGetEntryPropertiesA");
					if (!fp)
					{
						hr = GetLastError();
						break;
					}
				}
*/

/****** this call has been replaced with MyRasGetEntryProperties
				hr = RasGetEntryProperties(NULL,g_pcDialErr->m_pszConnectoid,
#if defined(WIN16)
											(LPBYTE)
#endif
											lpRasEntry,
											&dwRasEntrySize,
											(LPBYTE)lpRasDevInfo,
											&dwRasDevInfoSize);
****/

				// these two pointers should not have memory allocated to them
				// See MyRasGetEntryProperties function comment for details.
				if( lpRasEntry )
				{
					GlobalFree( lpRasEntry );
					lpRasEntry = NULL;
				}
				if( lpRasDevInfo )
				{
					GlobalFree( lpRasDevInfo );
					lpRasDevInfo = NULL;
				}
				hr = MyRasGetEntryProperties( NULL,
								  g_pcDialErr->m_pszConnectoid,
								  &lpRasEntry,
								  &dwRasEntrySize,
								  &lpRasDevInfo,
								  &dwRasDevInfoSize);

				if (hr != ERROR_SUCCESS)
				{
					break;
				}

				
				//
				// Replace the device with a new one
				//
				lstrcpyn(lpRasEntry->szDeviceType,g_pcDialErr->m_lprasdevinfo[idx].szDeviceType,RAS_MaxDeviceType+1);
				lstrcpyn(lpRasEntry->szDeviceName,g_pcDialErr->m_lprasdevinfo[idx].szDeviceName,RAS_MaxDeviceName+1);
				if (lpRasDevInfo) GlobalFree(lpRasDevInfo);
				lpRasDevInfo = NULL;
				// DANGER!!  Don't call GlobalFree on lpRasDevInfo after we set it below!!!!!!! --jmazner
				lpRasDevInfo = &g_pcDialErr->m_lprasdevinfo[idx];
				dwRasDevInfoSize = sizeof(RASDEVINFO);

				//hr = pcRNA->RasSetEntryProperties(NULL,g_pcDialErr->m_pszConnectoid,(LPBYTE)lpRasEntry,dwRasEntrySize,(LPBYTE)lpRasDevInfo,dwRasDevInfoSize);
				/*fp = GetProcAddress(hRasDll,"RasSetEntryPropertiesA");
				if (!fp)
				{
					hr = GetLastError();
					break;
				}*/

				// softlink to RasSetEntryProperties for simultaneous Win95/NT compatability
				if( !pRnaapi )
				{
					pRnaapi = new RNAAPI;
					if( !pRnaapi )
					{
						hr = ERROR_NOT_ENOUGH_MEMORY;
						break;
					}
				}
				hr = pRnaapi->RasSetEntryProperties(NULL,g_pcDialErr->m_pszConnectoid,
											(LPBYTE)lpRasEntry,
											dwRasEntrySize,
											(LPBYTE)lpRasDevInfo,
											dwRasDevInfoSize);
#if !defined(WIN16)
				LclSetEntryScriptPatch(lpRasEntry->szScript,g_pcDialErr->m_pszConnectoid);
#endif // !win16

				// Now that we're done with lpRasDevInfo, set it to NULL, but DON'T free it,
				// because it points to memory owned by g_pcDialErr->m_lprasdevinfo
				lpRasDevInfo = NULL;

				if (hr != ERROR_SUCCESS)
				{
					MessageBox(hwnd,GetSz(IDS_CANTSAVEKEY),GetSz(IDS_TITLE),MB_MYERROR);
					break;
				}

				/*FreeLibrary(hRasDll);
				hRasDll = NULL;
				fp = NULL;*/

			}
			break;
		case IDC_CMDHELP:
#if defined(WIN16)
			WinHelp(hwnd,"connect.hlp",HELP_CONTEXT,(DWORD)1001);
#else
			WinHelp(hwnd,TEXT("connect.hlp>proc4"),HELP_CONTEXT,(DWORD)1001);
#endif
			break;

		case IDC_CMDNEXT:
			// NOTE: This button is actually labeled "Redial"
			//
			lpszDialNumber = (LPTSTR)GlobalAlloc(GPTR, (RAS_MaxPhoneNumber + 1) * sizeof(TCHAR));
			if (NULL == lpszDialNumber)
			{
				MessageBox(hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_MYERROR);
				break;
			}
			// If the user has altered the phone number, make sure it can be used
			//
			if (fUserEditedNumber &&
				(GetDlgItemText(hwnd, IDC_TEXTNUMBER, lpszDialNumber, RAS_MaxPhoneNumber)) &&
				(0 != lstrcmp(lpszDialNumber, bCheckDisplayable ? g_pcDialErr->m_pszDisplayable : g_pcDialErr->m_szPhoneNumber)))
			{
				// Check that the phone number only contains valid characters
				//
				LPTSTR lpNum, lpValid;

				for (lpNum = lpszDialNumber;*lpNum;lpNum++)
				{
					for(lpValid = szValidPhoneCharacters;*lpValid;lpValid++)
					{
						if (*lpNum == *lpValid)
							break; // p2 for loop
					}
					if (!*lpValid) break; // p for loop
				}

				if (*lpNum)
				{
					MessageBox(hwnd,GetSz(IDS_INVALIDPHONE),GetSz(IDS_TITLE),MB_MYERROR);
					//
					// Set the focus back to the phone number field
					//
					SetFocus(GetDlgItem(hwnd,IDC_TEXTNUMBER));
					break; // switch statement
				}

/**** replaced by call to MyRasGetEntryProperties below
#if defined(WIN16)
				//
				// Allocate extra 256 bytes to workaround memory overrun bug in RAS
				//
				lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY)+256);
#else
				lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY));
#endif
				if (!lpRasEntry)
				{
					MessageBox(hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_MYERROR);
					break;
				}

				lpRasDevInfo = (LPRASDEVINFO)GlobalAlloc(GPTR,sizeof(RASDEVINFO));
				if (!lpRasDevInfo)
				{
					MessageBox(hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_MYERROR);
					break;
				}

				dwRasEntrySize = sizeof(RASENTRY);
				dwRasDevInfoSize = sizeof(RASDEVINFO);

				lpRasEntry->dwSize = dwRasEntrySize;
				lpRasDevInfo->dwSize = dwRasDevInfoSize;

				hr = RasGetEntryProperties(NULL,g_pcDialErr->m_pszConnectoid,
#if defined(WIN16)
											(LPBYTE)
#endif
											lpRasEntry,
											&dwRasEntrySize,
											(LPBYTE)lpRasDevInfo,
											&dwRasDevInfoSize);
****/

				// these two pointers should not have memory allocated to them
				// See MyRasGetEntryProperties function comment for details.
				if( lpRasEntry )
				{
					GlobalFree( lpRasEntry );
					lpRasEntry = NULL;
				}
				if( lpRasDevInfo )
				{
					GlobalFree( lpRasDevInfo );
					lpRasDevInfo = NULL;
				}

				dwRasEntrySize = dwRasDevInfoSize = 0;

				hr = MyRasGetEntryProperties( NULL,
								  g_pcDialErr->m_pszConnectoid,
								  &lpRasEntry,
								  &dwRasEntrySize,
								  &lpRasDevInfo,
								  &dwRasDevInfoSize);

				
				if (hr != ERROR_SUCCESS)
				{
					break;
				}

				// Replace the phone number with the new one
				//
				lstrcpy(lpRasEntry->szLocalPhoneNumber, lpszDialNumber);
				lpRasEntry->dwCountryID = 0;
				lpRasEntry->dwCountryCode = 0;
				lpRasEntry->szAreaCode[0] = '\0';

				// Set to dial as is
				//
				lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;

				// softlink to RasSetEntryProperties for simultaneous Win95/NT compatability
				if( !pRnaapi )
				{
					pRnaapi = new RNAAPI;
					if( !pRnaapi )
					{
						hr = ERROR_NOT_ENOUGH_MEMORY;
						break;
					}
				}
				hr = pRnaapi->RasSetEntryProperties(NULL,g_pcDialErr->m_pszConnectoid,
											(LPBYTE)lpRasEntry,
											dwRasEntrySize,
											(LPBYTE)lpRasDevInfo,
											dwRasDevInfoSize);
#if !defined(WIN16)
				LclSetEntryScriptPatch(lpRasEntry->szScript,g_pcDialErr->m_pszConnectoid);
#endif // !win16
				if (hr != ERROR_SUCCESS)
				{
					MessageBox(hwnd,GetSz(IDS_CANTSAVEKEY),GetSz(IDS_TITLE),MB_MYERROR);
					break;
				}
			}

			EndDialog(hwnd,ERROR_USERNEXT);
			break;

		case IDC_CMDCANCEL:
			//if (MessageBox(hwnd,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
			//	MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
			//	EndDialog(hwnd,ERROR_USERCANCEL);
			EndDialog(hwnd,ERROR_USERCANCEL);
			break;


		case IDC_CMDDIALPROP:
			// 12/4/96	jmazner	Normandy #10294
			//ShowWindow(hwnd,SW_HIDE);
			EnableWindow(hwnd, FALSE);
#if defined(WIN16)
			hr = IETapiTranslateDialog(hwnd, 
										g_pcDialErr->m_szPhoneNumber, 
										NULL);
#else
			// 10/24/96	jmazner	Normandy #10185/7019
			if (g_pdevice->dwTapiDev == 0xFFFFFFFF) g_pdevice->dwTapiDev = 0;

			hr = lineInitialize(&g_pcDialErr->m_hLineApp,g_pcDialErr->m_hInst,
									LineCallback,NULL,&dwNumDev);
			if (hr == ERROR_SUCCESS)
			{
				hr = lineTranslateDialog(g_pcDialErr->m_hLineApp,
											g_pdevice->dwTapiDev,
											g_pcDialErr->m_dwAPIVersion,
											hwnd,g_pcDialErr->m_szPhoneNumber);
#endif

				hr = DialErrGetDisplayableNumber();
				if (hr != ERROR_SUCCESS)
				{
					bCheckDisplayable = FALSE;
					SetDlgItemText(hwnd,IDC_TEXTNUMBER,g_pcDialErr->m_szPhoneNumber);
				} else {
					bCheckDisplayable = TRUE;
					SetDlgItemText(hwnd,IDC_TEXTNUMBER,g_pcDialErr->m_pszDisplayable);
				}
#if !defined(WIN16)
				lineShutdown(g_pcDialErr->m_hLineApp);
				g_pcDialErr->m_hLineApp = NULL;
			}
#endif
			// 12/4/96	jmazner	Normandy #10294
			//ShowWindow(hwnd,SW_SHOW);
			EnableWindow(hwnd, TRUE);

			//
			// 6/6/97 jmazner Olympus #4759
			//
			SetFocus(GetDlgItem(hwnd,IDC_CMDNEXT));
			
			break;
		}
		break;


	default:
		bRes = FALSE;
		break;
	}

	if (lpRasEntry) GlobalFree(lpRasEntry);
	if (lpRasDevInfo) GlobalFree(lpRasDevInfo);
	if (lpszDialNumber) GlobalFree(lpszDialNumber);
	if (pRnaapi) delete pRnaapi;

	return bRes;
}




HRESULT FillModems()
{
	//RNAAPI *pcRNA = NULL;
	HRESULT hr = ERROR_SUCCESS;
	//LPRASDEVINFO lprasdevinfo;
	DWORD dwSize;
	DWORD dwNumDev;
	DWORD idx;
    DWORD dwTempNumEntries;
	//HINSTANCE hRasDll=NULL;
	//FARPROC fp=NULL;

	LPRASENTRY lpRasEntry=NULL;
	LPRASDEVINFO lpRasDevInfo=NULL;
	DWORD dwRasEntrySize = 0;
	DWORD dwRasDevInfoSize = 0;
	LRESULT lLast = 0;

	RNAAPI *pRnaapi = NULL;



	// Get the connectoid
	//

/*******  This code has been obsoleted by the call to MyRasGetEntryProperties below
#if defined(WIN16)
	//
	// Allocate extra 256 bytes to workaround memory overrun bug in RAS
	//
	lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY)+256);
#else
	lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY));
#endif
	if (!lpRasEntry)
	{
		MessageBox(g_pcDialErr->m_hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
		goto FillModemExit;
	}

	lpRasDevInfo = (LPRASDEVINFO)GlobalAlloc(GPTR,sizeof(RASDEVINFO));
	if (!lpRasDevInfo)
	{
		MessageBox(g_pcDialErr->m_hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
		goto FillModemExit;
	}
	dwRasEntrySize = sizeof(RASENTRY);
	dwRasDevInfoSize = sizeof(RASDEVINFO);

	lpRasEntry->dwSize = dwRasEntrySize;
	lpRasDevInfo->dwSize = dwRasDevInfoSize;
*********/

/*	fp = NULL;
	hRasDll = LoadLibrary(RASAPI_LIBRARY);
	if (hRasDll)
	{
		fp = GetProcAddress(hRasDll,RASAPI_RASGETENTRY);
		if (!fp)
		{
			FreeLibrary(hRasDll);
			hRasDll = LoadLibrary(RNAPH_LIBRARY);
			if (hRasDll)
			{
				fp = GetProcAddress(hRasDll,RASAPI_RASGETENTRY);
			}
		}
	}

	if (!fp) 
	{
		hr = GetLastError();
		goto FillModemExit;
	}
*/

/******  This call has been replaced by MyRasGetEntryProperties below

  hr = RasGetEntryProperties(NULL,g_pcDialErr->m_pszConnectoid, 
#if defined(WIN16)
								(LPBYTE)
#endif
								lpRasEntry,
								&dwRasEntrySize,(LPBYTE)lpRasDevInfo,
								&dwRasDevInfoSize);
********/

	// these two pointers should not have memory allocated to them
	// See MyRasGetEntryProperties function comment for details.
	if( lpRasEntry )
	{
		GlobalFree( lpRasEntry );
		lpRasEntry = NULL;
	}
	if( lpRasDevInfo )
	{
		GlobalFree( lpRasDevInfo );
		lpRasDevInfo = NULL;
	}
	hr = MyRasGetEntryProperties( NULL,
								  g_pcDialErr->m_pszConnectoid,
								  &lpRasEntry,
								  &dwRasEntrySize,
								  &lpRasDevInfo,
								  &dwRasDevInfoSize);

	if( ERROR_SUCCESS != hr )
	{
		goto FillModemExit;
	}

	/*FreeLibrary(hRasDll);
	hRasDll = NULL;
	fp = NULL; */


	// Get devices from RAS/RNA
	//

	if (!g_pcDialErr->m_lprasdevinfo) 
		g_pcDialErr->m_lprasdevinfo = (LPRASDEVINFO)GlobalAlloc(GPTR,sizeof(RASDEVINFO));
	if (!g_pcDialErr->m_lprasdevinfo)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto FillModemExit;
	}

	g_pcDialErr->m_lprasdevinfo->dwSize = sizeof(RASDEVINFO);
	dwSize = sizeof(RASDEVINFO);
	dwNumDev = 0;

	/*hRasDll = LoadLibrary(RASAPI_LIBRARY);
	if (!hRasDll)
	{
		hr = GetLastError();
		goto FillModemExit;
	}
	fp =GetProcAddress(hRasDll,"RasEnumDevicesA");
	if (!fp)
	{
		FreeLibrary(hRasDll);
		hRasDll = LoadLibrary(TEXT("RNAPH.DLL"));
		if (!hRasDll)
		{
			hr = GetLastError();
			goto FillModemExit;
		}
		fp = GetProcAddress(hRasDll,"RasEnumDevicesA");
		if (!fp)
		{
			hr = GetLastError();
			goto FillModemExit;
		}
	}*/

	// soft link to RasEnumDevices to allow for simultaneous Win95/NT compatability
	pRnaapi = new RNAAPI;
	if( !pRnaapi )
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto FillModemExit;
	}

	hr = pRnaapi->RasEnumDevices(g_pcDialErr->m_lprasdevinfo,&dwSize,&dwNumDev);
	if (hr == ERROR_BUFFER_TOO_SMALL)
	{
		GlobalFree(g_pcDialErr->m_lprasdevinfo);
		g_pcDialErr->m_lprasdevinfo = (LPRASDEVINFO)GlobalAlloc(GPTR, (size_t)dwSize);
		if (!g_pcDialErr->m_lprasdevinfo)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto FillModemExit;
		}
		g_pcDialErr->m_lprasdevinfo->dwSize = sizeof(RASDEVINFO);
		hr = pRnaapi->RasEnumDevices(g_pcDialErr->m_lprasdevinfo,&dwSize,&dwNumDev);
	}

	/*FreeLibrary(hRasDll);
	hRasDll = NULL;
	fp = NULL;*/

	if (hr != ERROR_SUCCESS)
		goto FillModemExit;

	// Fill in combo box
	//
    dwTempNumEntries = dwNumDev;

	if (dwNumDev != 0)
	{
		for (idx=0;idx<dwTempNumEntries;idx++)
		{
			//
			// ChrisK Olympus 4560 do not add VPN's to list of modems
            // Vyung only add isdn and modem type devices
			//
			if ((0 == lstrcmpi(TEXT("MODEM"),g_pcDialErr->m_lprasdevinfo[idx].szDeviceType)) &&
                (0 == lstrcmpi(TEXT("ISDN"),g_pcDialErr->m_lprasdevinfo[idx].szDeviceType)))
			{
				lLast = SendDlgItemMessage(g_pcDialErr->m_hwnd,IDC_CMBMODEMS,CB_ADDSTRING,0,(LPARAM)&g_pcDialErr->m_lprasdevinfo[idx].szDeviceName[0]);
				//
				// ChrisK Olympus 245 5/25/97
				// Save index of modem
				//
				SendDlgItemMessage(g_pcDialErr->m_hwnd,IDC_CMBMODEMS,CB_SETITEMDATA,(WPARAM)lLast,(LPARAM)idx);
				if (lstrcmp(g_pcDialErr->m_lprasdevinfo[idx].szDeviceName,lpRasEntry->szDeviceName) == 0)
					SendDlgItemMessage(g_pcDialErr->m_hwnd,IDC_CMBMODEMS,CB_SETCURSEL,(WPARAM)lLast,0);
			}
            else
            {
                dwNumDev--;
            }
		}
	}

	if (dwNumDev == 1)
		SendDlgItemMessage(g_pcDialErr->m_hwnd,IDC_CMBMODEMS,CB_SETCURSEL,0,0);

	// UNDONE: select default device

FillModemExit:
	//if (g_pcDialErr->m_lprasdevinfo) GlobalFree(g_pcDialErr->m_lprasdevinfo);
	//if (pcRNA) delete pcRNA;
	if (lpRasEntry) GlobalFree(lpRasEntry);
	if (lpRasDevInfo) GlobalFree(lpRasDevInfo);
	if( pRnaapi ) delete pRnaapi;

	return hr;
}


HRESULT DialErrGetDisplayableNumber()
{
#if !defined(WIN16)
	DWORD dwNumDev;
	LPLINETRANSLATEOUTPUT lpOutput2;
	LPLINEEXTENSIONID lpExtensionID = NULL;
#endif
	
	HRESULT hr;
	LPRASENTRY lpRasEntry = NULL;
	LPRASDEVINFO lpRasDevInfo = NULL;
	DWORD dwRasEntrySize = 0;
	DWORD dwRasDevInfoSize = 0;
	LPLINETRANSLATEOUTPUT lpOutput1 = NULL;
	HINSTANCE hRasDll = NULL;
	FARPROC fp = NULL;

#if !defined(WIN16)
	// Normandy 13024 - ChrisK 12/31/96
	// In all cases we have to get the TAPI version number, because the dialing properies
	// button will not work on NT if the version is 0.

	//
	//  Initialize TAPIness
	//
	dwNumDev = 0;
 	hr = lineInitialize(&g_pcDialErr->m_hLineApp,g_pcDialErr->m_hInst,LineCallback,NULL,&dwNumDev);

	if (hr != ERROR_SUCCESS)
		goto GetDisplayableNumberExit;

	if (g_pdevice->dwTapiDev == 0xFFFFFFFF)
		g_pdevice->dwTapiDev = 0;

	// Get TAPI version number
	lpExtensionID = (LPLINEEXTENSIONID )GlobalAlloc(GPTR,sizeof(LINEEXTENSIONID));
	if (!lpExtensionID)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}

	do {
		hr = lineNegotiateAPIVersion(g_pcDialErr->m_hLineApp, g_pdevice->dwTapiDev, 0x00010004, 0x00010004,
			&g_pcDialErr->m_dwAPIVersion, lpExtensionID);
	} while (hr && g_pdevice->dwTapiDev++ < dwNumDev-1);

	// delete ExtenstionID since we don't use it
	if (lpExtensionID) GlobalFree(lpExtensionID);
	if (hr != ERROR_SUCCESS)
		goto GetDisplayableNumberExit;
#endif // !WIN16

	//RNAAPI * pcRNA;

	// Get phone number from connectoid
	//

/*  ---replaced by call to MyRasGetEntryProperties below 
#if defined(WIN16)
	//
	// Allocate extra 256 bytes to workaround memory overrun bug in RAS
	//
	lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY)+256);
#else
	lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY));
#endif
	if (!lpRasEntry)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}

	lpRasDevInfo = (LPRASDEVINFO)GlobalAlloc(GPTR,sizeof(RASDEVINFO));
	if (!lpRasDevInfo)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}
	dwRasEntrySize = sizeof(RASENTRY);
	dwRasDevInfoSize = sizeof(RASDEVINFO);
*/


/*  hRasDll = LoadLibrary(RASAPI_LIBRARY);
	if (!hRasDll)
	{
		hr = GetLastError();
		goto GetDisplayableNumberExit;
	}
	fp =GetProcAddress(hRasDll,"RasGetEntryPropertiesA");
	if (!fp)
	{
		FreeLibrary(hRasDll);
		hRasDll = LoadLibrary(TEXT("RNAPH.DLL"));
		if (!hRasDll)
		{
			hr = GetLastError();
			goto GetDisplayableNumberExit;
		}
		fp = GetProcAddress(hRasDll,"RasGetEntryPropertiesA");
		if (!fp)
		{
			hr = GetLastError();
			goto GetDisplayableNumberExit;
		}
	}
*/


	// lpRasEntry and lpRasDevInfo should not have memory allocated to them, and should be NULL
	// See MyRasGetEntryProperties function comment for details.
	hr = MyRasGetEntryProperties( NULL,
								  g_pcDialErr->m_pszConnectoid,
								  &lpRasEntry,
								  &dwRasEntrySize,
								  &lpRasDevInfo,
								  &dwRasDevInfoSize);

	if (hr != ERROR_SUCCESS)
	{
		goto GetDisplayableNumberExit;
	} 

	//FreeLibrary(hRasDll);

	//
	// If this is a dial as is number, just get it from the structure
	//
	if (!(lpRasEntry->dwfOptions & RASEO_UseCountryAndAreaCodes))
	{
		if (g_pcDialErr->m_pszDisplayable) GlobalFree(g_pcDialErr->m_pszDisplayable);
		g_pcDialErr->m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, lstrlen(lpRasEntry->szLocalPhoneNumber)+1);
		if (!g_pcDialErr->m_pszDisplayable)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}
		lstrcpy(g_pcDialErr->m_szPhoneNumber, lpRasEntry->szLocalPhoneNumber);
		lstrcpy(g_pcDialErr->m_pszDisplayable, lpRasEntry->szLocalPhoneNumber);
	}
	else
	{
		//
		// If there is no area code, don't use parentheses
		//
		if (lpRasEntry->szAreaCode[0])
			wsprintf(g_pcDialErr->m_szPhoneNumber,TEXT("+%lu (%s) %s\0"),lpRasEntry->dwCountryCode,
						lpRasEntry->szAreaCode,lpRasEntry->szLocalPhoneNumber);
		else
			wsprintf(g_pcDialErr->m_szPhoneNumber,TEXT("+%lu %s\0"),lpRasEntry->dwCountryCode,
						lpRasEntry->szLocalPhoneNumber);


#if defined(WIN16)
		char szBuffer[1024];
		LONG lRetCode;
		
		memset(&szBuffer[0], 0, sizeof(szBuffer));
		lpOutput1 = (LPLINETRANSLATEOUTPUT) & szBuffer[0];
		lpOutput1->dwTotalSize = sizeof(szBuffer);

		lRetCode = IETapiTranslateAddress(NULL, g_pcDialErr->m_szPhoneNumber,
											0L, 0L, lpOutput1);
		
		if (0 != lRetCode)
		{
			//
			// TODO: Set the correct error code
			//
			hr = GetLastError();
			goto GetDisplayableNumberExit;
		}
		if (g_pcDialErr->m_pszDisplayable) GlobalFree(g_pcDialErr->m_pszDisplayable);
		g_pcDialErr->m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, 
														((size_t)lpOutput1->dwDisplayableStringSize+1));
		if (!g_pcDialErr->m_pszDisplayable)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}

		lstrcpy(g_pcDialErr->m_pszDisplayable, 
					&szBuffer[lpOutput1->dwDisplayableStringOffset]);


#else //WIN16
	
/* Normandy 13024 this code was moved up
		//
		//  Initialize TAPIness
		//
		dwNumDev = 0;
 		hr = lineInitialize(&g_pcDialErr->m_hLineApp,g_pcDialErr->m_hInst,LineCallback,NULL,&dwNumDev);

		if (hr != ERROR_SUCCESS)
			goto GetDisplayableNumberExit;

		//Normandy #7019  jmazner
		//all devices should share the same dialing properties
		//(at least, this is what icwdial\dialerr.cpp appears to assume, and it works right ;)
//		if (g_pdevice->dwTapiDev == 0xFFFFFFFF)
//		{
//			if (dwNumDev == 1)
//				g_pdevice->dwTapiDev = 0;
//			//else
//			// UNDONE: Tell the user to select a modem
//			// DO NOT EXIT UNTIL THEY PICK ONE
//		}


		if (g_pdevice->dwTapiDev == 0xFFFFFFFF) g_pdevice->dwTapiDev = 0;

		lpExtensionID = (LPLINEEXTENSIONID )GlobalAlloc(GPTR,sizeof(LINEEXTENSIONID));
		if (!lpExtensionID)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}

		hr = lineNegotiateAPIVersion(g_pcDialErr->m_hLineApp, g_pdevice->dwTapiDev, 0x00010004, 0x00010004,
			&g_pcDialErr->m_dwAPIVersion, lpExtensionID);

		// ditch it since we don't use it
		//
		if (lpExtensionID) GlobalFree(lpExtensionID);
		if (hr != ERROR_SUCCESS)
			goto GetDisplayableNumberExit;
Normandy 13024 (see comments above) */

		// Format the phone number
		//

		lpOutput1 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(GPTR,sizeof(LINETRANSLATEOUTPUT));
		if (!lpOutput1)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}
		lpOutput1->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

		
		// Turn the canonical form into the "displayable" form
		//

		hr = lineTranslateAddress(g_pcDialErr->m_hLineApp,g_pdevice->dwTapiDev,
									g_pcDialErr->m_dwAPIVersion,
									g_pcDialErr->m_szPhoneNumber,0,
									LINETRANSLATEOPTION_CANCELCALLWAITING,
									lpOutput1);

		if (hr != ERROR_SUCCESS || (lpOutput1->dwNeededSize != lpOutput1->dwTotalSize))
		{
			lpOutput2 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(GPTR, (size_t) lpOutput1->dwNeededSize);
			if (!lpOutput2)
			{
				hr = ERROR_NOT_ENOUGH_MEMORY;
				goto GetDisplayableNumberExit;
			}
			lpOutput2->dwTotalSize = lpOutput1->dwNeededSize;
			GlobalFree(lpOutput1);
			lpOutput1 = lpOutput2;
			lpOutput2 = NULL;
			hr = lineTranslateAddress(g_pcDialErr->m_hLineApp,g_pdevice->dwTapiDev,
										g_pcDialErr->m_dwAPIVersion,
										g_pcDialErr->m_szPhoneNumber,0,
										LINETRANSLATEOPTION_CANCELCALLWAITING,
										lpOutput1);
		}

		if (hr != ERROR_SUCCESS)
		{
			goto GetDisplayableNumberExit;
		}

		if (g_pcDialErr->m_pszDisplayable) GlobalFree(g_pcDialErr->m_pszDisplayable);
		g_pcDialErr->m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, (size_t) lpOutput1->dwDisplayableStringSize+1);
		if (!g_pcDialErr->m_pszDisplayable)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}

		lstrcpyn(g_pcDialErr->m_pszDisplayable,
					(LPTSTR)&((LPBYTE)lpOutput1)[lpOutput1->dwDisplayableStringOffset],
					(size_t)lpOutput1->dwDisplayableStringSize);
#endif // WIN16
	}

GetDisplayableNumberExit:
	if (lpRasEntry) GlobalFree(lpRasEntry);
	if (lpRasDevInfo) GlobalFree(lpRasDevInfo);

#if !defined(WIN16)
	if (lpOutput1) GlobalFree(lpOutput1);
	if (g_pcDialErr->m_hLineApp) lineShutdown(g_pcDialErr->m_hLineApp);
#endif
	return hr;

}



//+---------------------------------------------------------------------------
//
//  Function:   MyRasGetEntryProperties()
//
//  Synopsis:   Performs some buffer size checks and then calls RasGetEntryProperties()
//				See the RasGetEntryProperties() docs to understand why this is needed.
//
//  Arguments:  Same as RasGetEntryProperties with the following exceptions:
//				lplpRasEntryBuff -- pointer to a pointer to a RASENTRY struct.  On successfull
//									return, *lplpRasEntryBuff will point to the RASENTRY struct
//									and buffer returned by RasGetEntryProperties.
//									NOTE: should not have memory allocated to it at call time!
//									      To emphasize this point, *lplpRasEntryBuff must be NULL
//				lplpRasDevInfoBuff -- pointer to a pointer to a RASDEVINFO struct.  On successfull
//									return, *lplpRasDevInfoBuff will point to the RASDEVINFO struct
//									and buffer returned by RasGetEntryProperties.
//									NOTE: should not have memory allocated to it at call time!
//									      To emphasize this point, *lplpRasDevInfoBuff must be NULL
//									NOTE: Even on a successfull call to RasGetEntryProperties,
//										  *lplpRasDevInfoBuff may return with a value of NULL
//										  (occurs when there is no extra device info)
//
//	Returns:	ERROR_NOT_ENOUGH_MEMORY if unable to allocate either RASENTRY or RASDEVINFO buffer
//				Otherwise, it retuns the error code from the call to RasGetEntryProperties.
//				NOTE: if return is anything other than ERROR_SUCCESS, *lplpRasDevInfoBuff and
//			          *lplpRasEntryBuff will be NULL,
//	                  and *lpdwRasEntryBuffSize and *lpdwRasDevInfoBuffSize will be 0
//
//  Example:
//
//	  LPRASENTRY    lpRasEntry = NULL;
//	  LPRASDEVINFO  lpRasDevInfo = NULL;
//	  DWORD			dwRasEntrySize, dwRasDevInfoSize;
//
//	  hr = MyRasGetEntryProperties( NULL,
//	  							    g_pcDialErr->m_pszConnectoid,
//								    &lpRasEntry,
//								    &dwRasEntrySize,
//								    &lpRasDevInfo,
//								    &dwRasDevInfoSize);
//
//
//	  if (hr != ERROR_SUCCESS)
//	  {
//	    	//handle errors here
//	  } else
//	  {
//			//continue processing
//	  }
//
//
//  History:    9/10/96     JMazner    Created
//
//----------------------------------------------------------------------------
HRESULT MyRasGetEntryProperties(LPTSTR lpszPhonebookFile,
								LPTSTR lpszPhonebookEntry, 
								LPRASENTRY *lplpRasEntryBuff,
								LPDWORD lpdwRasEntryBuffSize,
								LPRASDEVINFO *lplpRasDevInfoBuff,
								LPDWORD lpdwRasDevInfoBuffSize)
{
	HRESULT hr;
	RNAAPI *pRnaapi = NULL;

	DWORD dwOldDevInfoBuffSize;


	Assert( NULL != lplpRasEntryBuff );
	Assert( NULL != lpdwRasEntryBuffSize );
	Assert( NULL != lplpRasDevInfoBuff );
	Assert( NULL != lpdwRasDevInfoBuffSize );

	*lpdwRasEntryBuffSize = 0;
	*lpdwRasDevInfoBuffSize = 0;

	// Use reference variables internaly to make notation easier
	LPRASENTRY &reflpRasEntryBuff = *lplpRasEntryBuff;
	LPRASDEVINFO &reflpRasDevInfoBuff = *lplpRasDevInfoBuff;


	Assert( NULL == reflpRasEntryBuff );
	Assert( NULL == reflpRasDevInfoBuff );

	// need to softlink for simultaneous compatability with win95 and winnt
	pRnaapi = new RNAAPI;
	if( !pRnaapi )
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto MyRasGetEntryPropertiesErrExit;
	}
	

	// use RasGetEntryProperties with a NULL lpRasEntry pointer to find out size buffer we need
	// As per the docs' recommendation, do the same with a NULL lpRasDevInfo pointer.

	hr = pRnaapi->RasGetEntryProperties(lpszPhonebookFile, lpszPhonebookEntry,
								(LPBYTE)NULL,
								lpdwRasEntryBuffSize,
								(LPBYTE)NULL,lpdwRasDevInfoBuffSize);

	// we expect the above call to fail because the buffer size is 0
	// If it doesn't fail, that means our RasEntry is messed, so we're in trouble
	if( ERROR_BUFFER_TOO_SMALL != hr )
	{ 
		goto MyRasGetEntryPropertiesErrExit;
	}

	// dwRasEntryBuffSize and dwRasDevInfoBuffSize now contain the size needed for their
	// respective buffers, so allocate the memory for them

	// dwRasEntryBuffSize should never be less than the size of the RASENTRY struct.
	// If it is, we'll run into problems sticking values into the struct's fields

	Assert( *lpdwRasEntryBuffSize >= sizeof(RASENTRY) );

#if defined(WIN16)
	//
	// Allocate extra 256 bytes to workaround memory overrun bug in RAS
	//
	reflpRasEntryBuff = (LPRASENTRY)GlobalAlloc(GPTR,*lpdwRasEntryBuffSize + 256);
#else	
	reflpRasEntryBuff = (LPRASENTRY)GlobalAlloc(GPTR,*lpdwRasEntryBuffSize);
#endif

	if (!reflpRasEntryBuff)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto MyRasGetEntryPropertiesErrExit;
	}

	//
	// Allocate the DeviceInfo size that RasGetEntryProperties told us we needed.
	// If size is 0, don't alloc anything
	//
	if( *lpdwRasDevInfoBuffSize > 0 )
	{
		Assert( *lpdwRasDevInfoBuffSize >= sizeof(RASDEVINFO) );
	    reflpRasDevInfoBuff = (LPRASDEVINFO)GlobalAlloc(GPTR,*lpdwRasDevInfoBuffSize);
	    if (!reflpRasDevInfoBuff)
	    {
		    hr = ERROR_NOT_ENOUGH_MEMORY;
		    goto MyRasGetEntryPropertiesErrExit;
	    }
	} else
	{
		reflpRasDevInfoBuff = NULL;
	}

	// This is a bit convoluted:  lpRasEntrySize->dwSize needs to contain the size of _only_ the
	// RASENTRY structure, and _not_ the actual size of the buffer that lpRasEntrySize points to.
	// This is because the dwSize field is used by RAS for compatability purposes to determine which
	// version of the RASENTRY struct we're using.
	// Same holds for lpRasDevInfo->dwSize
	
	reflpRasEntryBuff->dwSize = sizeof(RASENTRY);
	if( reflpRasDevInfoBuff )
	{
		reflpRasDevInfoBuff->dwSize = sizeof(RASDEVINFO);
	}


	// now we're ready to make the actual call...

	// jmazner   see below for why this is needed
	dwOldDevInfoBuffSize = *lpdwRasDevInfoBuffSize;


	hr = pRnaapi->RasGetEntryProperties(lpszPhonebookFile, lpszPhonebookEntry,
								(LPBYTE)reflpRasEntryBuff,
								lpdwRasEntryBuffSize,
								(LPBYTE)reflpRasDevInfoBuff,lpdwRasDevInfoBuffSize);

	// jmazner 10/7/96  Normandy #8763
	// For unknown reasons, in some cases on win95, devInfoBuffSize increases after the above call,
	// but the return code indicates success, not BUFFER_TOO_SMALL.  If this happens, set the
	// size back to what it was before the call, so the DevInfoBuffSize and the actuall space allocated 
	// for the DevInfoBuff match on exit.
	if( (ERROR_SUCCESS == hr) && (dwOldDevInfoBuffSize != *lpdwRasDevInfoBuffSize) )
	{
		*lpdwRasDevInfoBuffSize = dwOldDevInfoBuffSize;
	}

    delete pRnaapi;
    pRnaapi = NULL;

	return( hr );

MyRasGetEntryPropertiesErrExit:

	if(reflpRasEntryBuff)
	{
		GlobalFree(reflpRasEntryBuff);
		reflpRasDevInfoBuff = NULL;
	}
	if(reflpRasDevInfoBuff)
	{
		GlobalFree(reflpRasDevInfoBuff);
		reflpRasDevInfoBuff = NULL;
	}	
	if (pRnaapi)
	{
        delete pRnaapi;
        pRnaapi = NULL;
	}

	*lpdwRasEntryBuffSize = 0;
	*lpdwRasDevInfoBuffSize = 0;
	
	return( hr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn2\pch.hpp ===
#if defined(WIN16)
#define WINVER 0x30a
#endif

#include <windows.h>
#include <locale.h>

#if defined(WIN16)
#define HRESULT long
#define WCHAR	WORD
#include <rasc.h>
#include <raserr.h>
#include <shellapi.h>
#include <ctl3d.h>
#include "tapi.h"
#include "win16def.h"
#include "..\icwdl\download.h"

#else

#include <ras.h>
#include <raserror.h>
#include <string.h>
#include <commctrl.h>
#include <wininet.h>
#define TAPI_CURRENT_VERSION 0x00010004
#include <tapi.h>
//#pragma pack(4)
//#include <rnaph.h>
//#pragma pack()

#include "icwunicd.h"

#endif // WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn2\globals.h ===
/*-----------------------------------------------------------------------------
    globals.h

    General declarations for ICWCONN2

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved

    Authors:
        ChrisK  Chris Kauffman

    Histroy:
        7/22/96 ChrisK   Cleaned and formatted
        9/11/98 a-jaswed really Cleaned and formatted
    
-----------------------------------------------------------------------------*/

#include "debug.h"
#include "resource.h"
#include "helpids.h"
#include "..\inc\icwdial.h"
#include "..\inc\icwerr.h"
#include "..\icwphbk\phbk.h" // need this to get the LPCNTRYNAMELOOKUPELEMENT struct definition
#include "ras2.h"
BOOL LclSetEntryScriptPatch(LPTSTR lpszScript,LPTSTR lpszEntry);
#include "rnaapi.h"

#define DOWNLOAD_LIBRARY         TEXT("icwdl.dll")
#define DOWNLOADINIT             "DownLoadInit"
#define DOWNLOADEXECUTE          "DownLoadExecute"
#define DOWNLOADCLOSE            "DownLoadClose"
#define DOWNLOADSETSTATUS        "DownLoadSetStatusCallback"
#define DOWNLOADPROCESS          "DownLoadProcess"
#define DOWNLOADCANCEL           "DownLoadCancel"
#define SIGNUPKEY                TEXT("SOFTWARE\\MICROSOFT\\ISIGNUP")
#define GATHERINFOVALUENAME      TEXT("UserInfo")
#define RASENTRYVALUENAME        TEXT("RasEntryName")
#define IEAPPPATHKEY             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE")
#define MAX_RASENTRYNAME         126
#define AUTODIAL_LIBRARY         TEXT("icwdial.dll")
#define AUTODIAL_INIT            "AutoDialInit"
#define RASAPI_LIBRARY           TEXT("RASAPI32.DLL")
#define RASDELETEAPI             "RasDeleteEntryA"
#define RASAPI_RASGETENTRY       "RasGetEntryPropertiesA"
#define RASAPI_RASSETENTRY       "RasSetEntryPropertiesA"
#define ERROR_USERCANCEL         32767 // quit message value
#define ERROR_USERBACK           32766 // back message value
#define ERROR_USERNEXT           32765 // back message value
#define ERROR_DOWNLOADDIDNT      32764 // download failed
#define MAX_PROMO                64
#define MAX_OEMNAME              64
#define MAX_AREACODE             RAS_MaxAreaCode
#define MAX_EXCHANGE             8
#define MAX_VERSION_LEN          40
#define CMD_CONNECTOID           TEXT("/CONNECTOID:")
#define CMD_INS                  TEXT("/INS:")
#define CMD_REBOOT               TEXT("/REBOOT")
#define LEN_CONNECTOID           sizeof(CMD_CONNECTOID)
#define LEN_INS                  sizeof(CMD_INS)
#define INSFILE_APPNAME          TEXT("ClientSetup")
#define INFFILE_SETUP_CLIENT_URL TEXT("Client_Setup_Url")
#define INFFILE_SETUP_NEW_CALL   TEXT("Client_Setup_New_Call")
#define INFFILE_DONE_MESSAGE     TEXT("Done_Message")
#define INFFILE_EXPLORE_CMD      TEXT("Explore_Command")
#define INFFILE_ENTRYSECTION     TEXT("Entry")
#define INFFILE_ENTRY_NAME       TEXT("Entry_Name")
#define INFFILE_USER_SECTION     TEXT("User")
#define INFFILE_PASSWORD         TEXT("Password")
#define INFFILE_ISPSUPP          TEXT("ISP_Support_Message")
#define NULLSZ                   TEXT("")
#define TIMEOUT                  15000  // 15 seconds
#define WM_DIENOW                WM_USER+1
#define WM_DUMMY                 WM_USER+2
#define WM_DOWNLOAD_DONE         WM_USER+2
#define irgMaxSzs                5
#define MB_MYERROR               (MB_APPLMODAL | MB_ICONERROR | MB_SETFOREGROUND)
#define MAX_RETIES               3
#define CALLHOME_SIZE            500

typedef DWORD   (WINAPI*   PFNRASDELETEENTRY)        (LPTSTR lpszPhonebook, LPTSTR lpszEntry);
typedef DWORD   (WINAPI*   PFNRASGETENTRYPROPERTIES) (LPTSTR lpszPhonebook, LPTSTR lpszEntry, LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);
typedef DWORD   (WINAPI*   PFNRASSETENTRYPROPERTIES) (LPTSTR lpszPhonebook, LPTSTR lpszEntry, LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize, LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
typedef DWORD   (CALLBACK* PFNRASENUMDEVICES)        (LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb, LPDWORD lpcDevices);
typedef HRESULT (CALLBACK* PFNAUTODIALINIT)          (LPTSTR lpszISPFile, BYTE fFlags, BYTE bMask, DWORD dwCountry, WORD wState);
typedef HRESULT (CALLBACK* PFNDOWNLOADINIT)          (LPTSTR pszURL, DWORD_PTR FAR *pdwDownLoad, HWND hWndMain);
typedef HRESULT (CALLBACK* PFNDOWNLOADEXECUTE)       (DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK* PFNDOWNLOADCLOSE)         (DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK* PFNDOWNLOADSETSTATUS)     (DWORD_PTR dwDownLoad, INTERNET_STATUS_CALLBACK lpfn);
typedef HRESULT (CALLBACK* PFNDOWNLOADPROCESS)       (DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK* PFNDOWNLOADCANCEL)        (DWORD_PTR dwDownLoad);
typedef HRESULT (WINAPI*   PFNINETGETAUTODIAL)       (LPBOOL, LPTSTR, DWORD);
typedef BOOL    (WINAPI*   LCLSETENTRYSCRIPTPATCH)   (LPTSTR, LPTSTR);

typedef struct tagGATHEREDINFO
{
    LCID    m_lcid;
    HWND    m_hwnd;
    DWORD   m_dwOS;
    DWORD   m_dwMajorVersion;
    DWORD   m_dwMinorVersion;
    DWORD   m_dwCountry;
    WORD    m_wState;
    WORD    m_wArchitecture;
    TCHAR   m_szAreaCode  [MAX_AREACODE+1];
    TCHAR   m_szExchange  [MAX_EXCHANGE+1];
    TCHAR   m_szPromo     [MAX_PROMO];
    TCHAR   m_szSUVersion [MAX_VERSION_LEN];
    TCHAR   m_szISPFile   [MAX_PATH+1];
    TCHAR   m_szAppDir    [MAX_PATH+1];
    BYTE    m_fType;
    BYTE    m_bMask;

    LPLINECOUNTRYLIST        m_pLineCountryList;
    LPCNTRYNAMELOOKUPELEMENT m_rgNameLookUp;

} GATHEREDINFO, *PGATHEREDINFO;

typedef struct _ShowProgressParams
{
    HANDLE    hProgressReadyEvent;
    HWND      hwnd;
    HWND      hwndParent;
    HINSTANCE hinst;
    DWORD     dwThreadID;

} ShowProgressParams, *PShowProgressParams;

typedef struct tagDialDlg
{
    HRASCONN      m_hrasconn;
    LPTSTR         m_pszConnectoid;
    HANDLE        m_hThread;
    DWORD         m_dwThreadID;
    DWORD_PTR     m_dwDownLoad;
    DWORD         m_dwAPIVersion;
    HWND          m_hwnd;
    PGATHEREDINFO m_pGI;
    LPTSTR         m_pszDisplayable;
    LPTSTR         m_szUrl;
    HLINEAPP      m_hLineApp;
    HINSTANCE     g_hInst;
    TCHAR         m_szPhoneNumber[256];
    BOOL          m_bDialAsIs;
    UINT          m_uiRetry;

} DIALDLG, *PDIALDLG;

typedef struct tagDialErr
{
    LPTSTR         m_pszConnectoid;
    HRESULT       m_hrError;
    PGATHEREDINFO m_pGI;
    HWND          m_hwnd;
    HLINEAPP      m_hLineApp;
    DWORD         m_dwAPIVersion;
    TCHAR         m_szPhoneNumber[256];
    LPTSTR         m_pszDisplayable;
    HINSTANCE     m_hInst;
    LPRASDEVINFO  m_lprasdevinfo;

} DIALERR, *PDIALERR;

typedef struct tagDEVICE
{
    DWORD      dwTapiDev;
    RASDEVINFO RasDevInfo;

} MYDEVICE, *PMYDEVICE;

extern "C" INT_PTR CALLBACK FAR PASCAL DialDlgProc             (HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam);
extern "C" INT_PTR CALLBACK FAR PASCAL DialErrDlgProc          (HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam);
extern "C" INT_PTR CALLBACK FAR PASCAL DialReallyCancelDlgProc (HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam);
extern HRESULT MyRasGetEntryProperties(LPTSTR lpszPhonebookFile,
                                LPTSTR lpszPhonebookEntry, 
                                LPRASENTRY *lplpRasEntryBuff,
                                LPDWORD lpdwRasEntryBuffSize,
                                LPRASDEVINFO *lplpRasDevInfoBuff,
                                LPDWORD lpdwRasDevInfoBuffSize);

extern PMYDEVICE          g_pdevice;
extern TCHAR              pszINSFileName[MAX_PATH+2];
extern TCHAR              pszFinalConnectoid[MAX_PATH+1];
extern HRASCONN           hrasconn;
extern TCHAR              pszSetupClientURL[1024];
extern UINT               uiSetupClientNewPhoneCall;
extern ShowProgressParams SPParams;
extern RECT               rect;
extern HBRUSH             hbBackBrush;
extern BOOL               fUserCanceled;
extern TCHAR              szBuff256[256];
extern HANDLE             hThread;
extern DWORD              dwThreadID;
extern DWORD_PTR          dwDownLoad;
extern DWORD              g_fNeedReboot;
extern BOOL               g_bProgressBarVisible;

HRESULT ReleaseBold                  (HWND hwnd);
HRESULT WINAPI StatusMessageCallback (DWORD dwStatus, LPTSTR pszBuffer, DWORD dwBufferSize);
HRESULT DeleteFileKindaLikeThisOne   (LPTSTR lpszFileName);
HRESULT DialDlg                      ();
HRESULT MakeBold                     (HWND hwnd, BOOL fSize, LONG lfWeight);
HRESULT ShowDialReallyCancelDialog   (HINSTANCE hInst, HWND hwnd, LPTSTR pszHomePhone);
HRESULT FillModems                   ();
HRESULT DialErrGetDisplayableNumber  ();
HRESULT GetDisplayableNumberDialDlg  ();
HRESULT ShowDialErrDialog            (PGATHEREDINFO pGI, HRESULT hrErr, LPTSTR pszConnectoid, HINSTANCE hInst, HWND hwnd);
HRESULT ShowDialingDialog            (LPTSTR pszConnectoid, PGATHEREDINFO pGI, LPTSTR szUrl, HINSTANCE hInst, HWND hwnd, LPTSTR szINSFile);
LPTSTR   StrDup                       (LPTSTR *ppszDest,LPCTSTR pszSource);
LPTSTR   GetSz                        (WORD wszID);
WORD    RasErrorToIDS                (DWORD dwErr);
BOOL    FShouldRetry                 (HRESULT hrErr);
BOOL    WaitForConnectionTermination (HRASCONN hConn);
BOOL    FileExists                   (TCHAR *pszINSFileName);
void    MinimizeRNAWindow            (LPTSTR pszConnectoidName, HINSTANCE hInst);
void    CALLBACK LineCallback        (DWORD hDevice,
                                      DWORD dwMessage,
                                      DWORD dwInstance,
                                      DWORD dwParam1,
                                      DWORD dwParam2,
                                      DWORD dwParam3);
DWORD WINAPI ThreadInit();


inline BOOL IsNT(void)
{
    OSVERSIONINFO  OsVersionInfo;

    ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OsVersionInfo);
    return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);
}

#define ARRAYSIZE(a)            (sizeof(a) / sizeof((a)[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn2\icwerr.cpp ===
/*-----------------------------------------------------------------------------
	icwerr.cpp

	Maps RAS and downloading errors to string resource indices

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		7/22/96		ChrisK	Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "globals.h"
//#include <raserror.h>
#include "..\inc\icwerr.h"

#define RAS_BOGUS_AUTHFAILCODE_1	84
#define RAS_BOGUS_AUTHFAILCODE_2	74389484

// ############################################################################
WORD RasErrorToIDS(DWORD dwErr)
{
	if(dwErr==RAS_BOGUS_AUTHFAILCODE_1 || dwErr==RAS_BOGUS_AUTHFAILCODE_2)
	{
		return IDS_PPPRANDOMFAILURE;
	}

	if((dwErr>=653 && dwErr<=663) || (dwErr==667) || (dwErr>=669 && dwErr<=675))
	{
#ifdef DEBUG    
		OutputDebugString("Got random RAS MEDIA error!\r\n");
#endif        
		return IDS_MEDIAINIERROR;
	}
	
	switch(dwErr)
	{
	default:
		return IDS_PPPRANDOMFAILURE;

	case SUCCESS:
		return IDS_PPPRANDOMFAILURE;

	case ERROR_DOWNLOADDIDNT:
		return IDS_CANTDOWNLOAD;
		
	case ERROR_LINE_BUSY:
		return IDS_PHONEBUSY;

	case ERROR_NO_ANSWER:
		return IDS_NOANSWER;
		
	case ERROR_VOICE_ANSWER:
	case ERROR_NO_CARRIER:
		return IDS_RASNOCARRIER;
		
	case ERROR_NO_DIALTONE:
		return IDS_NODIALTONE;

	case ERROR_HARDWARE_FAILURE:	// modem turned off
	case ERROR_PORT_ALREADY_OPEN:	// procomm/hypertrm/RAS has COM port
	case ERROR_PORT_OR_DEVICE:
		return IDS_NODEVICE;

	case ERROR_USER_DISCONNECTION:
		return IDS_USERCANCELEDDIAL;

	case ERROR_BUFFER_INVALID:				// bad/empty rasdilap struct
	case ERROR_BUFFER_TOO_SMALL:			// ditto?
	case ERROR_CANNOT_FIND_PHONEBOOK_ENTRY:	// if connectoid name in registry is wrong
		return IDS_TCPINSTALLERROR;

    case ERROR_AUTHENTICATION_FAILURE:		// get this on actual CHAP reject
		return IDS_PPPRANDOMFAILURE;

	case ERROR_PPP_TIMEOUT:		// get this on CHAP timeout
		return IDS_PPPRANDOMFAILURE;

	case ERROR_REMOTE_DISCONNECTION:		// Ascend drops connection on auth-fail
		return IDS_PPPRANDOMFAILURE;

	case ERROR_AUTH_INTERNAL:				// got this on random POP failure
	case ERROR_PROTOCOL_NOT_CONFIGURED:		// get this if LCP fails
	case ERROR_PPP_NO_PROTOCOLS_CONFIGURED:	// get this if IPCP addr download gives garbage
		return IDS_PPPRANDOMFAILURE;

	case ERROR_USERCANCEL:
		return IDS_USERCANCELEDDIAL;

/******
    case ERROR_CHANGING_PASSWORD:
    case ERROR_PASSWD_EXPIRED:
        ev = EVENT_INVALIDPASSWORD; break;

    case ERROR_ACCT_DISABLED:
    case ERROR_ACCT_EXPIRED:
		ev = EVENT_LOCKEDACCOUNT; break;

    case ERROR_NO_DIALIN_PERMISSION:
    case ERROR_RESTRICTED_LOGON_HOURS:
    case ERROR_AUTHENTICATION_FAILURE:
		ev = EVENT_RAS_AUTH_FAILED; break;

	case ERROR_ALREADY_DISCONNECTING:
	case ERROR_DISCONNECTION:
		ev = EVENT_CONNECTION_DROPPED; break;

	case PENDING: 
	case ERROR_INVALID_PORT_HANDLE:
	case ERROR_CANNOT_SET_PORT_INFO:
	case ERROR_PORT_NOT_CONNECTED:
	case ERROR_DEVICE_DOES_NOT_EXIST:
	case ERROR_DEVICETYPE_DOES_NOT_EXIST:
	case ERROR_PORT_NOT_FOUND:
	case ERROR_DEVICENAME_TOO_LONG:
	case ERROR_DEVICENAME_NOT_FOUND:
	 	ev=EVENT_BAD_MODEM_CONFIG; break;

	case ERROR_TAPI_CONFIGURATION:
		ev=EVENT_BAD_TAPI_CONFIG; break;
	
		ev=EVENT_MODEM_BUSY; break;
	
	case ERROR_BUFFER_TOO_SMALL:
	case ERROR_WRONG_INFO_SPECIFIED:
	case ERROR_EVENT_INVALID:
	case ERROR_BUFFER_INVALID:
	case ERROR_ASYNC_REQUEST_PENDING:
	case ERROR_CANNOT_OPEN_PHONEBOOK:
	case ERROR_CANNOT_LOAD_PHONEBOOK:
	case ERROR_CANNOT_WRITE_PHONEBOOK:
	case ERROR_CORRUPT_PHONEBOOK:
	case ERROR_CANNOT_LOAD_STRING:
	case ERROR_OUT_OF_BUFFERS:
	case ERROR_MACRO_NOT_FOUND:
	case ERROR_MACRO_NOT_DEFINED:
	case ERROR_MESSAGE_MACRO_NOT_FOUND:
	case ERROR_DEFAULTOFF_MACRO_NOT_FOUND:
	case ERROR_FILE_COULD_NOT_BE_OPENED:
	case ERROR_PORT_NOT_OPEN:
	case ERROR_PORT_DISCONNECTED:
	case ERROR_NO_ENDPOINTS:
	case ERROR_KEY_NOT_FOUND:
	case ERROR_INVALID_SIZE:
	case ERROR_PORT_NOT_AVAILABLE:
	case ERROR_UNKNOWN:
	case ERROR_WRONG_DEVICE_ATTACHED:
	case ERROR_BAD_STRING:
	case ERROR_BAD_USAGE_IN_INI_FILE:
	case ERROR_READING_SECTIONNAME:
	case ERROR_READING_DEVICETYPE:
	case ERROR_READING_DEVICENAME:
	case ERROR_READING_USAGE:
	case ERROR_READING_MAXCONNECTBPS:
	case ERROR_READING_MAXCARRIERBPS:
	case ERROR_IN_COMMAND:
	case ERROR_WRITING_SECTIONNAME:
	case ERROR_WRITING_DEVICETYPE:
	case ERROR_WRITING_DEVICENAME:
	case ERROR_WRITING_MAXCONNECTBPS:
	case ERROR_WRITING_MAXCARRIERBPS:
	case ERROR_WRITING_USAGE:
	case ERROR_WRITING_DEFAULTOFF:
	case ERROR_READING_DEFAULTOFF:
	case ERROR_EMPTY_INI_FILE:
	case ERROR_FROM_DEVICE:
	case ERROR_UNRECOGNIZED_RESPONSE:
	case ERROR_NO_RESPONSES:
	case ERROR_NO_COMMAND_FOUND:
	case ERROR_WRONG_KEY_SPECIFIED:
	case ERROR_UNKNOWN_DEVICE_TYPE:
	case ERROR_ALLOCATING_MEMORY:
	case ERROR_PORT_NOT_CONFIGURED:
	case ERROR_DEVICE_NOT_READY:
	case ERROR_READING_INI_FILE:
	case ERROR_NO_CONNECTION:
	case ERROR_PORT_OR_DEVICE:
	case ERROR_NOT_BINARY_MACRO:
	case ERROR_DCB_NOT_FOUND:
	case ERROR_STATE_MACHINES_NOT_STARTED:
	case ERROR_STATE_MACHINES_ALREADY_STARTED:
	case ERROR_PARTIAL_RESPONSE_LOOPING:
	case ERROR_UNKNOWN_RESPONSE_KEY:
	case ERROR_RECV_BUF_FULL:
	case ERROR_CMD_TOO_LONG:
	case ERROR_UNSUPPORTED_BPS:
	case ERROR_UNEXPECTED_RESPONSE:
	case ERROR_INTERACTIVE_MODE:
	case ERROR_BAD_CALLBACK_NUMBER:
	case ERROR_INVALID_AUTH_STATE:
	case ERROR_WRITING_INITBPS:
	case ERROR_X25_DIAGNOSTIC:
	case ERROR_OVERRUN:
	case ERROR_RASMAN_CANNOT_INITIALIZE:
	case ERROR_BIPLEX_PORT_NOT_AVAILABLE:
	case ERROR_NO_ACTIVE_ISDN_LINES:
	case ERROR_NO_ISDN_CHANNELS_AVAILABLE:
	case ERROR_TOO_MANY_LINE_ERRORS:
		ev=EVENT_INTERNAL_ERROR; break;
	
	case ERROR_ROUTE_NOT_AVAILABLE:
	case ERROR_ROUTE_NOT_ALLOCATED:
	case ERROR_INVALID_COMPRESSION_SPECIFIED:
	case ERROR_CANNOT_PROJECT_CLIENT:
	case ERROR_CANNOT_GET_LANA:
	case ERROR_NETBIOS_ERROR:
	case ERROR_NAME_EXISTS_ON_NET:
		ev=EVENT_BAD_NET_CONFIG; break;
	
	case ERROR_REQUEST_TIMEOUT:
	case ERROR_SERVER_OUT_OF_RESOURCES:
	case ERROR_SERVER_GENERAL_NET_FAILURE:
	case WARNING_MSG_ALIAS_NOT_ADDED:
	case ERROR_SERVER_NOT_RESPONDING:
		ev=EVENT_GENERAL_NET_ERROR; break;
		
	case ERROR_IP_CONFIGURATION:
	case ERROR_NO_IP_ADDRESSES:
	case ERROR_PPP_REMOTE_TERMINATED:
	case ERROR_PPP_NO_RESPONSE:
	case ERROR_PPP_INVALID_PACKET:
	case ERROR_PHONE_NUMBER_TOO_LONG:
	case ERROR_IPXCP_NO_DIALOUT_CONFIGURED:
	case ERROR_IPXCP_NO_DIALIN_CONFIGURED:
	case ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE:
	case ERROR_ACCESSING_TCPCFGDLL:
	case ERROR_NO_IP_RAS_ADAPTER:
	case ERROR_SLIP_REQUIRES_IP:
	case ERROR_PROJECTION_NOT_COMPLETE:
	case ERROR_PPP_NOT_CONVERGING:
	case ERROR_PPP_CP_REJECTED:
	case ERROR_PPP_LCP_TERMINATED:
	case ERROR_PPP_REQUIRED_ADDRESS_REJECTED:
	case ERROR_PPP_NCP_TERMINATED:
	case ERROR_PPP_LOOPBACK_DETECTED:
	case ERROR_PPP_NO_ADDRESS_ASSIGNED:
	case ERROR_CANNOT_USE_LOGON_CREDENTIALS:
	case ERROR_NO_LOCAL_ENCRYPTION:
	case ERROR_NO_REMOTE_ENCRYPTION:
	case ERROR_REMOTE_REQUIRES_ENCRYPTION:
	case ERROR_IPXCP_NET_NUMBER_CONFLICT:
		ev = EVENT_PPP_FAILURE; break;
***********/
	}
	return (0xFFFF);
}


// ############################################################################
	
HRESULT LoadDialErrorString(HRESULT hrIN, LPTSTR lpszBuff, DWORD dwBufferSize)
{
	if (lpszBuff && dwBufferSize)
	{
		WORD wSID = 0;
		wSID = RasErrorToIDS(hrIN);
		if (0xFFFF != wSID)
		{
			if (0 != LoadString(GetModuleHandle(NULL),wSID,lpszBuff,(int)dwBufferSize))
				return ERROR_SUCCESS;
		}
	}
	return ERROR_INVALID_PARAMETER;
}

HRESULT WINAPI StatusMessageCallback(DWORD dwStatus, LPTSTR pszBuffer, DWORD dwBufferSize)
{
	WORD iIDS = 0;

	switch(dwStatus)
	{
		case RASCS_OpenPort:
			iIDS = IDS_RAS_OPENPORT;
			break;
		case RASCS_PortOpened:
			iIDS = IDS_RAS_PORTOPENED;
			break;
		case RASCS_ConnectDevice:
			iIDS = IDS_RAS_DIALING;
			break;
		case RASCS_DeviceConnected:
			iIDS = IDS_RAS_CONNECTED;
			break;
#if (WINVER >= 0x400) 
		case RASCS_StartAuthentication:
		case RASCS_LogonNetwork:
			iIDS = IDS_RAS_LOCATING;
			break;
//		case RASCS_CallbackComplete:
//			iIDS = IDS_RAS_CONNECTED;
//			break;
#endif 

/* ETC...
				RASCS_AllDevicesConnected, 
				RASCS_Authenticate, 
				RASCS_AuthNotify, 
				RASCS_AuthRetry, 
				RASCS_AuthCallback, 
				RASCS_AuthChangePassword, 
				RASCS_AuthProject, 
				RASCS_AuthLinkSpeed, 
				RASCS_AuthAck, 
				RASCS_ReAuthenticate, 
				RASCS_Authenticated, 
				RASCS_PrepareForCallback, 
				RASCS_WaitForModemReset, 
				RASCS_WaitForCallback,
				RASCS_Projected, 
 
 
				RASCS_Interactive = RASCS_PAUSED, 
				RASCS_RetryAuthentication, 
				RASCS_CallbackSetByCaller, 
				RASCS_PasswordExpired, 
 */
		case RASCS_Connected:
			break;

		case RASCS_Disconnected:
			break;
	}
	if (iIDS && 0 != LoadString(GetModuleHandle(NULL),iIDS,pszBuffer,(int)dwBufferSize))
		return ERROR_SUCCESS;
	else
		return ERROR_INVALID_PARAMETER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn2\main.cpp ===
/*-----------------------------------------------------------------------------
    main.cpp

    Main entry and code for ICWCONN2

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved

    Authors:
        ChrisK  Chris Kauffman
        VetriV  Vellore Vetrivelkumaran

    Histroy:
        7/22/96 ChrisK  Cleaned and formatted
        8/5/96  VetriV  Added WIN16 code
        4/29/98 donaldm removed WIN16 code    
-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "globals.h"
#include "..\inc\semaphor.h"

#define IEAPPPATHKEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE")
DWORD CallCMConfig(LPCTSTR lpszINSFile, LPTSTR lpszConnectoidName);

TCHAR        pszINSFileName[MAX_PATH+2];
TCHAR        pszFinalConnectoid[MAX_PATH+1];
HRASCONN    hrasconn;
TCHAR        pszSetupClientURL[1024];
UINT        uiSetupClientNewPhoneCall;
ShowProgressParams SPParams;
RECT        rect;
HBRUSH      hbBackBrush;
BOOL        fUserCanceled;
TCHAR        szBuff256[256];
HANDLE      hThread;
DWORD       dwThreadID;
DWORD_PTR   dwDownLoad;
DWORD       g_fNeedReboot;
BOOL        g_bProgressBarVisible;
BOOL        g_bINSFileExists; 

TCHAR szStrTable[irgMaxSzs][256];
int iSzTable;

extern HWND g_hDialDlgWnd;


// The following two functions are for My[16|32]ShellExecute
BOOL fStrNCmpI (LPTSTR lp1, LPTSTR lp2, UINT iNum)
{
    UINT i;
    for (i = 0; (i < iNum) && (toupper(lp1[i]) == toupper(lp2[i])); i++) {}
    return (i == iNum);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsURL
//
//  Synopsis:   Determines whether a string is URL
//
//  Arguments:  lpszCommand - the string to check
//
//  Returns:    TRUE - For our purposes, it's a URL
//              FALSE - Do not treat as a URL
//
//  History:    jmazner     Created     10/23/96
//
//-----------------------------------------------------------------------------
BOOL IsURL( LPTSTR lpszCommand )
{
    return (fStrNCmpI(lpszCommand, TEXT("HTTP:"), 5) ||
            fStrNCmpI(lpszCommand, TEXT("HTTPS:"), 6) ||
            fStrNCmpI(lpszCommand, TEXT("FTP:"), 4) ||
            fStrNCmpI(lpszCommand, TEXT("GOPHER:"), 7) ||
            fStrNCmpI(lpszCommand, TEXT("FILE:"), 5));
}


int FindFirstWhiteSpace( LPTSTR szString ); //declared below

//+----------------------------------------------------------------------------
//
//  Function:   My32ShellExecute
//
//  Synopsis:   ShellExecute a command in such a way that browsers other than
//              IE won't get called to handle URLs.
//
//              If command is a URL, explicitly ShellExec IE on it,
//              if it's empty, shellExec IE with no parameters, and
//              if it's anything else, assume it's a command followed by a
//              parameter list, and shellExec that.
//
//  Arguments:  lpszCommand - the command to execute
//
//  Returns:    TRUE - For our purposes, it's a URL
//              FALSE - Do not treat as a URL
//
//  History:    10/23/96    jmazner     Created
//              11/5/96     jmazner     updated to use ShellExec in all cases,
//                                      to mimick behavior of start->run,
//                                      rather than dos box command line.
//              4/30/97     jmazner     updated to use IE AppPath reg key
//                                      (Olympus bug #200)
//
//-----------------------------------------------------------------------------
void My32ShellExecute(LPTSTR lpszCommand)
{
    HINSTANCE hInst = NULL;
    TCHAR * szParameter = NULL;
    TCHAR * pszIEAppPath = NULL;
    const TCHAR * cszGenericIE = TEXT("IEXPLORE.EXE");
    DWORD dwErr = ERROR_GEN_FAILURE;
    LONG lSize = 0;
    
    Assert( lpszCommand );
  
    dwErr = RegQueryValue(HKEY_LOCAL_MACHINE,IEAPPPATHKEY,NULL,&lSize);
    if ((ERROR_SUCCESS == dwErr || ERROR_MORE_DATA == dwErr) && (0 != lSize))
    {
        //
        // add 1 for null and 10 for slop
        //
        pszIEAppPath = (LPTSTR)LocalAlloc(LPTR,lSize+2+1+10); 
  
        if( pszIEAppPath )
        {
            dwErr = RegQueryValue(HKEY_LOCAL_MACHINE,IEAPPPATHKEY,
                                        pszIEAppPath,&lSize);

            if( ERROR_SUCCESS != dwErr )
            {
                LocalFree( pszIEAppPath );
                pszIEAppPath = NULL;
            }
            else
            {
                Dprintf(TEXT("ICWCONN2: got IE Path of %s\n"), pszIEAppPath);
            }
        }
    }

    if( !pszIEAppPath )
    {
        pszIEAppPath = (TCHAR *) cszGenericIE;
        Dprintf(TEXT("ICWCONN2: Couldn't find IE appPath, using generic %s"), pszIEAppPath);
    }



    if( IsURL(lpszCommand) )
    {
        // If the command looks like a URL, explicitly call IE to open it
        // (don't want to rely on default browser)
        hInst = ShellExecute(NULL,TEXT("open"),pszIEAppPath,lpszCommand,NULL,SW_SHOWNORMAL);
    }
    else if( !lpszCommand[0] )
    {
        // If there is no command, just exec IE
        hInst = ShellExecute(NULL,TEXT("open"),pszIEAppPath,NULL,NULL,SW_SHOWNORMAL);
    }
    else
    {
        int i = FindFirstWhiteSpace( lpszCommand );
        if( 0 == i )
        {
            hInst = ShellExecute(NULL, TEXT("open"), lpszCommand, NULL, NULL, SW_SHOWNORMAL);
        }
        else
        {
            lpszCommand[i] = '\0';

            // now skip past all consecutive white space
            while( ' ' == lpszCommand[++i] );

            szParameter = lpszCommand + i;
            hInst = ShellExecute(NULL, TEXT("open"), lpszCommand, szParameter, NULL, SW_SHOWNORMAL);
        }
    }

    if (hInst < (HINSTANCE)32)
    {
        Dprintf(TEXT("ICWCONN2: Couldn't execute the command '%s %s'\n"),
            lpszCommand, szParameter ? szParameter : TEXT("\0"));
        MessageBox(NULL,GetSz(IDS_CANTEXECUTE),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
    }

}

//+----------------------------------------------------------------------------
//
//  Function:   FindFirstWhiteSpace
//
//  Synopsis:   Return the index of the first whtie space character in the
//              string that's not enclosed in a double quote substring
//      
//              eg: "iexplore foo.htm" should return 8,
//                  ""c:\program files\ie" foo.htm" should return 21
//
//  Arguments:  szString - the string to search through
//
//  Returns:    index of first qualifying white space.
//              if no qualifying character exists, returns 0
//
//  History:    11/5/96 jmazner Created for Normandy #9867
//
//-----------------------------------------------------------------------------

int FindFirstWhiteSpace( LPTSTR szString )
{
    int i = 0;

    Assert( szString );

    if( '\"' == szString[0] )
    {
        // Don't look for spaces within a double quoted string
        // (example string "c:\Program Files\bob.exe" foo.bob)
    
        i++;
        while( '\"' != szString[i] )
        {
            if( NULL == szString[i] )
            {
                AssertSz(0, "ExploreNow command has unmatched quotes!\n");
                Dprintf(TEXT("ICWCONN2: FindFirstWhiteSpace discovered unmatched quote.\n"));
                return( 0 );
            }

            i++;
        }

    }

    while( ' ' != szString[i] )
    {
        if( NULL == szString[i] )
            //there is no white space to be found
            return 0;
        
        i++;
    }

    return( i );
}

//+---------------------------------------------------------------------------
//
//  Function:   WaitForConnectionTermination
//
//  Synopsis:   Waits for the given Ras Connection to complete termination
//
//  Arguments:  hConn - Connection handle of the RAS connection being terminated
//
//  Returns:    TRUE if wait till connection termination was successful
//              FALSE otherwise
// 
//  History:    6/30/96 VetriV  Created
//              8/19/96 ValdonB Moved from duplicate in icwconn1\dialdlg.cpp
//              8/29/96 VetriV  Added code to sleep for a second on WIN 3.1 
//----------------------------------------------------------------------------
// Normandy #12547 Chrisk 12-18-96
#define MAX_TIME_FOR_TERMINATION 5
BOOL WaitForConnectionTermination(HRASCONN hConn)
{
    RASCONNSTATUS RasConnStatus;
    DWORD dwRetCode;
    INT cnt = 0;

    //
    // Get Connection status for hConn in a loop until 
    // RasGetConnectStatus returns ERROR_INVALID_HANDLE
    //
    do
    {
        //
        // Intialize RASCONNSTATUS struct
        // GetConnectStatus API will fail if dwSize is not set correctly!!
        //
        ZeroMemory(&RasConnStatus, sizeof(RASCONNSTATUS));

        RasConnStatus.dwSize = sizeof(RASCONNSTATUS);

        //
        // Sleep for a second and then get the connection status
        //
        Sleep(1000L);
        // Normandy #12547 Chrisk 12-18-96
        cnt++;

        dwRetCode = RasGetConnectStatus(hConn, &RasConnStatus);
        if (0 != dwRetCode)
            return FALSE;
    
    // Normandy #12547 Chrisk 12-18-96
    } while ((ERROR_INVALID_HANDLE != RasConnStatus.dwError) && (cnt < MAX_TIME_FOR_TERMINATION));
    return TRUE;
}

// ############################################################################
// NAME: GetSz
//
//  Load strings from resources
//
//  Created 1/28/96,        Chris Kauffman
// ############################################################################
LPTSTR GetSz(WORD wszID)
{
    LPTSTR psz = &szStrTable[iSzTable][0];
    
    iSzTable++;
    if (iSzTable >= irgMaxSzs)
        iSzTable = 0;
        
    if (!LoadString(GetModuleHandle(NULL), wszID, psz, 256))
    {
        Dprintf(TEXT("CONNECT2:LoadString failed %d\n"), (DWORD) wszID);
        *psz = 0;
    }
        
    return (psz);
}

// ############################################################################
HRESULT ReleaseBold(HWND hwnd)
{
    HFONT hfont = NULL;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (hfont) DeleteObject(hfont);
    return ERROR_SUCCESS;
}
// ############################################################################
HRESULT MakeBold (HWND hwnd, BOOL fSize, LONG lfWeight)
{
    HRESULT hr = ERROR_SUCCESS;
    HFONT hfont = NULL;
    HFONT hnewfont = NULL;
    LOGFONT* plogfont = NULL;

    if (!hwnd) goto MakeBoldExit;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (!hfont)
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    plogfont = (LOGFONT*)GlobalAlloc(GPTR,sizeof(LOGFONT));
    if (!plogfont)
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    if (!GetObject(hfont,sizeof(LOGFONT),(LPVOID)plogfont))
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    if (abs(plogfont->lfHeight) < 24 && fSize)
    {
        plogfont->lfHeight = plogfont->lfHeight + (plogfont->lfHeight / 4);
    }

    plogfont->lfWeight = (int)lfWeight;

    if (!(hnewfont = CreateFontIndirect(plogfont)))
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    SendMessage(hwnd,WM_SETFONT,(WPARAM)hnewfont,MAKELPARAM(TRUE,0));
    
MakeBoldExit:
    // if (hfont) DeleteObject(hfont);
    // BUG:? Do I need to delete hnewfont at some time?
    return hr;
}



// ############################################################################
extern "C" INT_PTR CALLBACK FAR PASCAL DoneDlgProc(HWND  hwnd,UINT  uMsg,WPARAM  wParam,LPARAM lParam)
{
    BOOL bRet = TRUE;

    switch(uMsg)
    {
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDC_CMDCLOSE:
        case IDC_CMDEXPLORE:
            EndDialog(hwnd,LOWORD(wParam));
            break;
        }
        break;
    case WM_INITDIALOG:
        MakeBold(GetDlgItem(hwnd,IDC_LBLTITLE),TRUE,FW_BOLD);
        GetPrivateProfileString(
                    INSFILE_APPNAME,INFFILE_DONE_MESSAGE,
                    NULLSZ,szBuff256,255,pszINSFileName);
        SetDlgItemText(hwnd,IDC_LBLEXPLORE,szBuff256);

        break;
    case WM_DESTROY:
        ReleaseBold(GetDlgItem(hwnd,IDC_LBLTITLE));
        bRet = FALSE;
        break;
    case WM_CLOSE:
        EndDialog(hwnd,IDC_CMDCLOSE);
        break;
    default:
        bRet = FALSE;
        break;
    }
    return bRet;
}



// ############################################################################
extern "C" INT_PTR CALLBACK FAR PASCAL DoneRebootDlgProc(HWND  hwnd,UINT  uMsg,
                                                        WPARAM  wParam, 
                                                        LPARAM lParam)
{
    BOOL bRet = TRUE;

    switch(uMsg)
    {
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case WM_CLOSE:
        case IDC_CMDEXPLORE:
            EndDialog(hwnd,LOWORD(wParam));
            break;
        }
        break;
    case WM_INITDIALOG:
        MakeBold(GetDlgItem(hwnd,IDC_LBLTITLE),TRUE,FW_BOLD);
        GetPrivateProfileString(
                    INSFILE_APPNAME,INFFILE_DONE_MESSAGE,
                    NULLSZ,szBuff256,255,pszINSFileName);
        SetDlgItemText(hwnd,IDC_LBLEXPLORE,szBuff256);

        break;
    case WM_DESTROY:
        ReleaseBold(GetDlgItem(hwnd,IDC_LBLTITLE));
        bRet = FALSE;
        break;
    default:
        bRet = FALSE;
        break;
    }
    return bRet;
}



// ############################################################################
extern "C" BOOL CALLBACK FAR PASCAL StepTwoDlgProc(HWND  hwnd,UINT  uMsg,
                                                    WPARAM  wParam,
                                                    LPARAM lParam)
{
    BOOL bRet = TRUE;

    switch(uMsg)
    {
    default:
        bRet = FALSE;
        break;
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDC_CMDNEXT:
            EndDialog(hwnd,IDC_CMDNEXT);
            break;
        case IDC_CMDCANCEL:
            EndDialog(hwnd,IDC_CMDCANCEL);
            break;
        }
        break;
    case WM_INITDIALOG:
        MakeBold(GetDlgItem(hwnd,IDC_LBLTITLE),TRUE,FW_BOLD);
        break;
    case WM_DESTROY:
        ReleaseBold(GetDlgItem(hwnd,IDC_LBLTITLE));

        bRet = FALSE;
        break;
    }
    return bRet;
}

/*
// ############################################################################
BOOL CALLBACK ContextDlgProc(HWND  hwnd,UINT  uMsg,WPARAM  wParam,LPARAM lParam)
{
    LRESULT lRet = TRUE;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        MakeBold (GetDlgItem(hwnd, IDC_LBLARROW3NUM), FALSE, FW_BOLD);
        MakeBold (GetDlgItem(hwnd, IDC_LBLARROW3TEXT), FALSE, FW_BOLD);
        break;
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDC_CMDHELP:
            WinHelp(hwnd,TEXT("connect.hlp>proc4"),HELP_CONTEXT,(DWORD)idh_icwoverview);
            break;
        }
        break;
    case WM_QUIT:
        PostQuitMessage(0);
        break;
    default:
        lRet = FALSE;
        break;
    }
    return lRet;
}
*/

/*
// ############################################################################
BOOL CALLBACK BackDlgProc(
    HWND  hwndDlg,  // handle to dialog box
    UINT  uMsg, // message
    WPARAM  wParam, // first message parameter
    LPARAM  lParam  // second message parameter
   )
{
    HDC hdc;
    LRESULT lRet = TRUE;
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // SET WINDOW TEXT HERE
        hbBackBrush = (HBRUSH)(COLOR_BACKGROUND + 1);
        break;
    case WM_SIZE:
        GetClientRect(hwndDlg,&rect);
        lRet = FALSE;   // enable default processing
        break;
    case WM_CLOSE:
        //PostQuitMessage(0);
        //EndDialog(hwndDlg,FALSE);
        break;
    case WM_PAINT:
        hdc = GetDC(hwndDlg);
        FillRect(hdc,&rect,hbBackBrush);
        ReleaseDC(hwndDlg,hdc);
        lRet = 0;
        break;
    default:
        // let the system process the message
        lRet = FALSE;
    }
    return lRet;
}
*/



// ############################################################################
void CALLBACK ProgressCallBack(
    HINTERNET hInternet,
    DWORD_PTR dwContext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
    )
{
    LPTSTR pszStatus = NULL;
    int prc;
    static BOOL bMessageSet = FALSE;

    switch(dwInternetStatus)
    {
    case 99:
        prc = *(int*)lpvStatusInformation;
        
        if (!g_bProgressBarVisible)
        {
            ShowWindow(GetDlgItem(SPParams.hwnd,IDC_PROGRESS),SW_SHOW);
            g_bProgressBarVisible = TRUE;
        }

        SendDlgItemMessage(SPParams.hwnd,
                IDC_PROGRESS,
                PBM_SETPOS,
                (WPARAM)prc,
                0);
        if (!bMessageSet)
        {
            bMessageSet = TRUE;
            pszStatus = GetSz(IDS_RECEIVING_RESPONSE);
        }
        break;
    }
    if (pszStatus)
       SetDlgItemText(SPParams.hwnd,IDC_LBLSTATUS,pszStatus);
}



// ############################################################################
DWORD WINAPI ThreadInit()
{
    HINSTANCE hDLDLL;
    HINSTANCE hADDll = NULL;
    FARPROC fp;
    HRESULT hr;
    
    hDLDLL = LoadLibrary(DOWNLOAD_LIBRARY);

    if (!hDLDLL)
    {
        hr = GetLastError();
        goto ThreadInitExit;
    }

    // Set up for download
    //

    fp = GetProcAddress(hDLDLL,DOWNLOADINIT);
    AssertSz(fp,"DownLoadInit API missing");
    dwDownLoad = 0;
    hr = ((PFNDOWNLOADINIT)fp)(pszSetupClientURL, &dwDownLoad, g_hDialDlgWnd);
    if (hr != ERROR_SUCCESS) goto ThreadInitExit;

    // Set up progress call back
    //

    fp = GetProcAddress(hDLDLL,DOWNLOADSETSTATUS);
    Assert(fp);
    hr = ((PFNDOWNLOADSETSTATUS)fp)(dwDownLoad, &ProgressCallBack);

    // Download stuff
    //

    fp = GetProcAddress(hDLDLL,DOWNLOADEXECUTE);
    Assert(fp);
    hr = ((PFNDOWNLOADEXECUTE)fp)(dwDownLoad);
    // if there is an error, we still have to take down the window and
    // release the WinInet Internet handle.

    if (hr == ERROR_SUCCESS)
    {
        fp = GetProcAddress(hDLDLL,DOWNLOADPROCESS);
        Assert(fp);
        hr = ((PFNDOWNLOADPROCESS)fp)(dwDownLoad);
    }

    fp = GetProcAddress(hDLDLL,DOWNLOADCLOSE);
    Assert(fp);
    ((PFNDOWNLOADCLOSE)fp)(dwDownLoad);
    dwDownLoad = 0;

ThreadInitExit:
    PostMessage(SPParams.hwnd,WM_DOWNLOAD_DONE,0,0);
    if (hDLDLL) FreeLibrary(hDLDLL);
    if (hADDll) FreeLibrary(hADDll);
    return hr;
}

HRESULT HangUpAll()
{
    LPRASCONN lprasconn;
    DWORD cb;
    DWORD cConnections;
    DWORD idx;
    HRESULT hr;

    hr = ERROR_NOT_ENOUGH_MEMORY;

    lprasconn = (LPRASCONN)GlobalAlloc(GPTR,sizeof(RASCONN));
    if (!lprasconn) goto SkipHangUp;
    cb = sizeof(RASCONN);
    cConnections = 0;
    lprasconn->dwSize = cb;

    //if(RasEnumConnections(lprasconn,&cb,&cConnections))
    {
        GlobalFree(lprasconn);
        lprasconn = (LPRASCONN)GlobalAlloc(GPTR,(size_t)cb);
      
        if (!lprasconn) goto SkipHangUp;

        lprasconn->dwSize = cb;
        RasEnumConnections(lprasconn,&cb,&cConnections);
    }

    if (cConnections)
    {
        for (idx = 0; idx<cConnections; idx++)
        {
            RasHangUp(lprasconn[idx].hrasconn);
            WaitForConnectionTermination(lprasconn[idx].hrasconn);
        }
    }
    if (lprasconn) GlobalFree(lprasconn);
    hr = ERROR_SUCCESS;

SkipHangUp:
    return hr;
}



// ############################################################################
BOOL FShouldRetry(HRESULT hrErr)
{
    BOOL bRC;

    if (hrErr == ERROR_LINE_BUSY ||
        hrErr == ERROR_VOICE_ANSWER ||
        hrErr == ERROR_NO_ANSWER ||
        hrErr == ERROR_NO_CARRIER ||
        hrErr == ERROR_AUTHENTICATION_FAILURE ||
        hrErr == ERROR_PPP_TIMEOUT ||
        hrErr == ERROR_REMOTE_DISCONNECTION ||
        hrErr == ERROR_AUTH_INTERNAL ||
        hrErr == ERROR_PROTOCOL_NOT_CONFIGURED ||
        hrErr == ERROR_PPP_NO_PROTOCOLS_CONFIGURED)
    {
        bRC = TRUE;
    } else {
        bRC = FALSE;
    }

    return bRC;
}



// ############################################################################
HRESULT CallDownLoad(LPTSTR pszUrl, HINSTANCE hInst)
{
    FARPROC fp = NULL;
    HRESULT hr = ERROR_SUCCESS;
    HKEY hKey = NULL;
    DWORD dwType=0;
    DWORD dwSize=0;
    GATHEREDINFO gi;
    LPTSTR pszConnectoid=NULL;
    BOOL fEnabled;
    HINSTANCE hInet = NULL;
    INT cRetry;
    TCHAR szCallHomeMsg[CALLHOME_SIZE];
    DWORD dwCMRet = NULL;

    // 11/25/96 jmazner Normandy #12109
    // load in connectoid name before we get to ShowExploreNow

    //// BUG: If isignup keep creating unique filenames, this will only
    //// find the first connectoid created for this ISP.
    ////
    //
    pszConnectoid = (LPTSTR)GlobalAlloc(GPTR,RAS_MaxEntryName + 1);
    if (!pszConnectoid)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto CallDownLoadExit;
    }
    
    hInet = LoadLibrary(TEXT("INETCFG.DLL"));
    if (!hInet)
    {
        AssertSz(0,"Failed to load inetcfg.dll.\r\n");
        hr = GetLastError();
        goto CallDownLoadExit;
    }

    fp = GetProcAddress(hInet,"InetGetAutodial");
    if (!fp)
    {
        AssertSz(0,"Failed to load InetGetAutodial.\r\n");
        hr = GetLastError();
        goto CallDownLoadExit;
    }

    //
    // Get name of autodial connectoid
    //
    fEnabled = FALSE;
    hr = ((PFNINETGETAUTODIAL)fp)(&fEnabled,pszConnectoid,RAS_MaxEntryName);
    if ( hr != ERROR_SUCCESS)
        goto CallDownLoadExit;

    if (hInet) FreeLibrary(hInet);
    hInet = NULL;
    fp = NULL;

    Dprintf(TEXT("CONNECT2: call back using the '%s' connectoid.\n"),pszConnectoid);


    if (pszUrl[0] == '\0')
    {
        Dprintf(TEXT("CONNECT2: Client setup URL in .ins file is empty.\n"));
        goto ShowExploreNow;
    }

    SPParams.hwnd = NULL;
    SPParams.hwndParent = NULL;
    SPParams.hinst = hInst;

    //
    hr = RegOpenKey(HKEY_LOCAL_MACHINE,SIGNUPKEY,&hKey);
    if (hr == ERROR_SUCCESS)
    {
        dwType = REG_BINARY;
        dwSize = sizeof(gi);
        ZeroMemory(&gi,sizeof(gi));
        hr = RegQueryValueEx(hKey,GATHERINFOVALUENAME,0,&dwType,(LPBYTE)&gi,&dwSize);

        RegCloseKey(hKey);
        hKey = NULL;
    }  else {
        goto CallDownLoadExit;
    }   

    ZeroMemory(szCallHomeMsg,CALLHOME_SIZE);

    GetPrivateProfileString(
        INSFILE_APPNAME,INFFILE_ISPSUPP,
        NULLSZ,szCallHomeMsg,CALLHOME_SIZE,pszINSFileName);

TryDial:
    cRetry = 0;
TryRedial:
        //
        // ChrisK 8/20/97
        // Pass .ins file to dialer so that the dialer can find the password
        //
    hr = ShowDialingDialog(pszConnectoid, &gi, pszUrl, hInst, NULL, pszINSFileName);
    cRetry++;
    
    if ((cRetry < MAX_RETIES) && FShouldRetry(hr))
        goto TryRedial;

    if (hr != ERROR_USERNEXT)
    {
        if (!uiSetupClientNewPhoneCall)
        {
            hr = ShowDialReallyCancelDialog(hInst, NULL, szCallHomeMsg);
            if (hr == ERROR_USERNEXT)
                goto TryDial;
            else if (hr == ERROR_USERCANCEL)
                goto CallDownLoadExit;
        } else {
            if (RASBASE > hr || RASBASEEND < hr)
                hr = ERROR_DOWNLOADDIDNT;
            hr = ShowDialErrDialog(&gi, hr, pszConnectoid, hInst, NULL);
            if (hr == ERROR_USERNEXT)
                goto TryDial;
            else 
            {
                hr = ShowDialReallyCancelDialog(hInst, NULL, szCallHomeMsg);
                if (hr == ERROR_USERNEXT)
                    goto TryDial;
                else if (hr == ERROR_USERCANCEL)
                    goto CallDownLoadExit;
            }
        }
    }

    //
    // Determine if we should hang up
    //
    
ShowExploreNow:
    if (0 == uiSetupClientNewPhoneCall)
    {
        HangUpAll();
    }
    //
    // 1/8/96 jmazner Normanmdy #12930
    // function moved to isign32.dll
    //

    //
    // 5/9/97 jmazner Olympus #416
    //
    dwCMRet = CallCMConfig(pszINSFileName, pszConnectoid);
    switch( dwCMRet )
    {
        case ERROR_SUCCESS:
            break;
        case ERROR_MOD_NOT_FOUND:
        case ERROR_DLL_NOT_FOUND:
            Dprintf(TEXT("ICWCONN2: CMCFG32 DLL not found, I guess CM ain't installed.\n"));
            break;
        default:
            //ErrorMsg(hwnd, IDS_SBSCFGERROR);
            break;
    }

    if (g_fNeedReboot){
        int iReturnCode = 0;


        iReturnCode = (int)DialogBox(hInst,MAKEINTRESOURCE(IDD_DONEREBOOT),
                                    NULL,DoneRebootDlgProc); 
        
        switch(iReturnCode)
        {
            case IDC_CMDEXPLORE:
                ExitWindowsEx(EWX_REBOOT,0);
                break;
            case IDC_CMDCLOSE:
                HangUpAll();
                break;
        }
    } else { 
        int iReturnCode = 0;

        iReturnCode = (int)DialogBox(hInst,MAKEINTRESOURCE(IDD_DONE),
                                    NULL,DoneDlgProc); 
    
        switch(iReturnCode)
        {
        case IDC_CMDEXPLORE:
            GetPrivateProfileString(
                        INSFILE_APPNAME,INFFILE_EXPLORE_CMD,
                        NULLSZ,szBuff256,255,pszINSFileName);
            My32ShellExecute(szBuff256);
            break;
        case IDC_CMDCLOSE:
            HangUpAll();
            break;
        }
    }

CallDownLoadExit:
    if (pszConnectoid)
        GlobalFree(pszConnectoid);
    pszConnectoid = NULL;
    return hr;
}

// ############################################################################
HRESULT FindCurrentConn ()
{
    LPRASCONN lprasconn = NULL;
    DWORD   cb = sizeof(RASCONN);
    DWORD   cConnections = 0;
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    unsigned int idx;
    
    lprasconn = (LPRASCONN)GlobalAlloc(GPTR,sizeof(RASCONN));
    if (!lprasconn) goto FindCurrentConnExit;
    lprasconn[0].dwSize = sizeof(RASCONN);

    if(RasEnumConnections(lprasconn,&cb,&cConnections))
    {
        GlobalFree(lprasconn);
        lprasconn = (LPRASCONN)GlobalAlloc(GPTR,(size_t)cb);
      if (!lprasconn) goto FindCurrentConnExit;
        RasEnumConnections(lprasconn,&cb,&cConnections);
    }

    if (pszFinalConnectoid[0] != '\0')
    {
        if (cConnections)
        {
            for (idx = 0; idx<cConnections; idx++)
            {
                if (lstrcmpi(lprasconn[idx].szEntryName,pszFinalConnectoid)==0)
                {
                    hrasconn = lprasconn[idx].hrasconn;
                    break;
                }
            }
            if (!hrasconn) goto FindCurrentConnExit;
        }
    } else {
        // if they don't tell us the connectoid on the command line
        // we assume there is only one and the first one is the one we are going to use!!
        if (cConnections)
        {
            lstrcpyn(pszFinalConnectoid,lprasconn[0].szEntryName,sizeof(pszFinalConnectoid)/sizeof(TCHAR));
            hrasconn = lprasconn[0].hrasconn;
        }
    }

    hr = ERROR_SUCCESS;
FindCurrentConnExit:
    if (lprasconn) GlobalFree(lprasconn);
    return hr;
}

// ############################################################################
HRESULT CopyCmdLineData (LPTSTR pszCmdLine, LPTSTR pszField, LPTSTR pszOut)
{
    HRESULT hr = ERROR_SUCCESS;
    TCHAR *s;
    TCHAR *t;
    BOOL fQuote = FALSE;

    s = _tcsstr(pszCmdLine,pszField);
    if (s)
    {
        s += lstrlen(pszField);
        t = pszOut;
        *t = '\0';
        if (fQuote =(*s == '"'))
            s++;

        while (*s && 
                ((*s != ' ' && !fQuote)
            ||   (*s != '"' && fQuote )))       // copy until the end of the string or a space char
        {
            *t = *s;
            t++;
            s++;
        }
        *t = '\0';  // add null terminator
    } 
    else 
    {
        hr = ERROR_INVALID_PARAMETER;
    }

    return hr;
}

// ############################################################################
HRESULT ParseCommandLine(LPTSTR pszCmdLine)
{
    HRESULT hr;
    
    // jmazner 10/15/96  make parsing of cmd line options case insensitive
    CharUpper( pszCmdLine );

    g_fNeedReboot = (_tcsstr(pszCmdLine, CMD_REBOOT) != NULL);
    
    hr = CopyCmdLineData (pszCmdLine, CMD_CONNECTOID, &pszFinalConnectoid[0]);
    if (hr != ERROR_SUCCESS) pszFinalConnectoid[0] = '\0';
    hr = CopyCmdLineData (pszCmdLine, CMD_INS, &pszINSFileName[0]);
//ParseCommandLineExit:
    return hr;
}

// ############################################################################
HRESULT DeleteIRN()
{
    HRESULT hr = ERROR_SUCCESS;
    HKEY hKey;
    DWORD dwType;
    DWORD dwSize;
    TCHAR szRasEntry[MAX_RASENTRYNAME+1];
    RNAAPI *pRnaapi = NULL;

    pRnaapi = new RNAAPI;
    if(!pRnaapi)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwSize = sizeof(szRasEntry);
    dwType = REG_SZ;
    hKey = NULL;  
    
    hr = RegOpenKey(HKEY_LOCAL_MACHINE,SIGNUPKEY,&hKey);

    ZeroMemory(szRasEntry,sizeof(szRasEntry));

    if (hr == ERROR_SUCCESS)
    {
        hr = RegQueryValueEx(hKey,RASENTRYVALUENAME,NULL,&dwType,(LPBYTE)szRasEntry,&dwSize);
        //if (hr == ERROR_SUCCESS && fp)
        if (hr == ERROR_SUCCESS)
            pRnaapi->RasDeleteEntry(NULL, szRasEntry);
    }
    if (hKey) RegCloseKey(hKey);
    //if (hDLL) FreeLibrary(hDLL);
    if (pRnaapi)
    {
        delete pRnaapi;
        pRnaapi = NULL;
    }
    hKey = NULL;
    

    return hr;
}

// ############################################################################
int WINAPI WinMain(
    HINSTANCE  hInstance,   // handle to current instance
    HINSTANCE  hPrevInstance,   // handle to previous instance
    LPSTR  lpCmdLine,   // pointer to command line
    int  nShowCmd   // show state of window
   )
{
    int     irc = 1;
    BOOL    fHangUp = TRUE;
    HKEY    hkey = NULL;

    RNAAPI  *pRnaapi = NULL;

#ifdef UNICODE
    // Initialize the C runtime locale to the system locale.
    setlocale(LC_ALL, "");
#endif

    // Initialize globals
    //
    ZeroMemory(pszINSFileName,MAX_PATH+1);
    ZeroMemory(pszFinalConnectoid,MAX_PATH+1);
    ZeroMemory(pszSetupClientURL,1024);


    // 12/3/96  jmazner Normandy #12140, 12088
    // create a semaphore to signal other icw components that we're running
    // Since conn2 is not single instance (see semaphor.h), we don't care if
    // the semaphore already exists.
    HANDLE  hSemaphore = NULL;

    hSemaphore = CreateSemaphore(NULL, 1, 1, ICW_ELSE_SEMAPHORE);


    hrasconn = NULL;
    uiSetupClientNewPhoneCall = FALSE;
    fUserCanceled = FALSE;
    dwDownLoad = 0;
    g_bProgressBarVisible =FALSE;

    
    //
    // Delete referal service connectoid
    //
    DeleteIRN();

    //
    // Parse command line
    //
    if (ParseCommandLine(GetCommandLine()) != ERROR_SUCCESS)
    {
        irc = 2;
        Dprintf(TEXT("ICWCONN2: Malformed cmd line '%s'\n"), lpCmdLine);
        AssertSz(0,"Command Line parsing failed\r\n.");

        //CHAR szTemp[2048] = "not initialized\0";
        //wsprintf(szTemp, GetSz(IDS_BAD_CMDLINE), lpCmdLine);
        MessageBox(NULL,GetSz(IDS_BAD_CMDLINE),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
        goto WinMainExit;
    }

    g_bINSFileExists = TRUE;
    
    if( !FileExists(pszINSFileName) )
    {
        g_bINSFileExists = FALSE;
        irc = 2;
        TCHAR *pszTempBuff = NULL;
        TCHAR *pszErrString = NULL;
        DWORD dwBuffSize = 0;

        pszErrString = GetSz(IDS_MISSING_FILE);
        // If we can't access a resource string, we may as well just give up and quit silently
        if( !pszErrString ) goto WinMainExit;

        dwBuffSize = MAX_PATH + lstrlen( pszErrString ) + 3; //two quotes and terminating null
        pszTempBuff = (TCHAR *)GlobalAlloc( GPTR, dwBuffSize );

        if( !pszTempBuff )
        {
            MessageBox(NULL,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
            goto WinMainExit;
        }

        wsprintf(pszTempBuff, pszErrString);
        lstrcat(pszTempBuff, TEXT("\""));
        lstrcat(pszTempBuff, pszINSFileName);
        lstrcat(pszTempBuff, TEXT("\""));

        MessageBox(NULL,pszTempBuff,GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);

        GlobalFree(pszTempBuff);
        pszTempBuff = NULL;

        goto WinMainExit;
    }


    //
    // Find the handle to the current connection
    //
    if (FindCurrentConn() != ERROR_SUCCESS)
    {
        irc = 2;
        AssertSz(0,"Finding current connection failed\r\n.");
        goto WinMainExit;
    }

    
    
    //
    // Get SetUp Client URL
    //
    GetPrivateProfileString(
        INSFILE_APPNAME,INFFILE_SETUP_CLIENT_URL,
        NULLSZ,pszSetupClientURL,1024,pszINSFileName);

    //if (pszSetupClientURL[0])
    //{
        uiSetupClientNewPhoneCall = GetPrivateProfileInt(
            INSFILE_APPNAME,INFFILE_SETUP_NEW_CALL,0,pszINSFileName);
        if (uiSetupClientNewPhoneCall == 1 && hrasconn)
        {
            RasHangUp(hrasconn);
            WaitForConnectionTermination(hrasconn);

            pRnaapi = new RNAAPI;
            if(!pRnaapi)
            {
                MessageBox(NULL,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
                goto WinMainExit;
            }

            pRnaapi->RasDeleteEntry(NULL,pszFinalConnectoid);

            pszFinalConnectoid[0] = '\0';
            hrasconn = NULL;
        }

        CallDownLoad(&pszSetupClientURL[0],hInstance);
                
    //}
    //else
    //{
    //  if (hrasconn) 
    //  {
    //      RasHangUp(hrasconn);
    //      Sleep(3000);
    //  }
    //}

WinMainExit:
    hkey = NULL;
    if ((RegOpenKey(HKEY_LOCAL_MACHINE,SIGNUPKEY,&hkey)) == ERROR_SUCCESS)
    {
        RegDeleteValue(hkey,GATHERINFOVALUENAME);
        RegCloseKey(hkey);
    } 

    if (g_bINSFileExists && pszINSFileName)
    {
        if (pszINSFileName[0] != '\0')
        {
            DeleteFileKindaLikeThisOne(pszINSFileName);
        }
    }
    Dprintf(TEXT("CONNECT2:Quitting WinMain.\n"));
    if (hrasconn) 
    {
        RasHangUp(hrasconn);

        if (pszFinalConnectoid[0])
        {
            if(!pRnaapi)
            {
                pRnaapi = new RNAAPI;
                if(!pRnaapi)
                {
                    // no point in notifying user with message, we're quitting anyways
                    Dprintf(TEXT("ICWCONN2: couldn't allocate pRnaapi memory in WinMainExit\n"));
                }
                else
                {
                    pRnaapi->RasDeleteEntry(NULL,pszFinalConnectoid);
                }

            }

        }
        pszFinalConnectoid[0] = '\0';

        WaitForConnectionTermination(hrasconn);
        hrasconn = NULL;
    }

    if (g_pdevice) GlobalFree(g_pdevice);

    ExitProcess(0);

    if (pRnaapi)
    {
        delete pRnaapi;
        pRnaapi = NULL;
    }

    if( hSemaphore )
        CloseHandle( hSemaphore );

    return irc;
}

static const TCHAR cszBrandingSection[] = TEXT("Branding");
static const TCHAR cszBrandingServerless[] = TEXT("Serverless");
// ############################################################################
// This function serve the single function of cleaning up after IE3.0, because
// IE3.0 will issue multiple POST and get back multiple .INS files.  These files
// contain sensative data that we don't want lying arround, so we are going out,
// guessing what their names are, and deleting them.
HRESULT DeleteFileKindaLikeThisOne(LPTSTR lpszFileName)
{
    LPTSTR lpNext = NULL;
    HRESULT hr = ERROR_SUCCESS;
    WORD wRes = 0;
    HANDLE hFind = NULL;
    WIN32_FIND_DATA sFoundFile;
    TCHAR szPath[MAX_PATH];
    TCHAR szSearchPath[MAX_PATH + 1];
    LPTSTR lpszFilePart = NULL;

    // Validate parameter
    //

    if (!lpszFileName || lstrlen(lpszFileName) <= 4)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto DeleteFileKindaLikeThisOneExit;
    }

    // Check for serverless signup
    if (0 != GetPrivateProfileInt(cszBrandingSection,cszBrandingServerless,0,lpszFileName))
        goto DeleteFileKindaLikeThisOneExit;

    // Determine the directory name where the INS files are located
    //

    ZeroMemory(szPath,MAX_PATH);
    if (GetFullPathName(lpszFileName,MAX_PATH,szPath,&lpszFilePart))
    {
        *lpszFilePart = '\0';
    } else {
        hr = GetLastError();
        goto DeleteFileKindaLikeThisOneExit;
    };

    // Munge filename into search parameters
    //

    lpNext = &lpszFileName[lstrlen(lpszFileName)-4];

    if (CompareString(LOCALE_SYSTEM_DEFAULT,NORM_IGNORECASE,lpNext,4,TEXT(".INS"),4) != 2) goto DeleteFileKindaLikeThisOneExit;

    ZeroMemory(szSearchPath,MAX_PATH + 1);
    lstrcpyn(szSearchPath,szPath,MAX_PATH);
    lstrcat(szSearchPath,TEXT("*.INS"));

    // Start wiping out files
    //

    ZeroMemory(&sFoundFile,sizeof(sFoundFile));
    hFind = FindFirstFile(szSearchPath,&sFoundFile);
    if (hFind)
    {
        do {
            lstrcpy(lpszFilePart,sFoundFile.cFileName);
            SetFileAttributes(szPath,FILE_ATTRIBUTE_NORMAL);
            DeleteFile(szPath);
            ZeroMemory(&sFoundFile,sizeof(sFoundFile));
        } while (FindNextFile(hFind,&sFoundFile));
        FindClose(hFind);
    }

    hFind = NULL;

DeleteFileKindaLikeThisOneExit:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   StrDup
//
//  Synopsis:   Duplicate given string
//
//  Arguments:  ppszDest - pointer to pointer that will point to string
//              pszSource - pointer to the string to be copied
//
//  Returns:    NULL - failure
//              Pointer to duplicate - success
//
//  History:    7/26/96 ChrisK  Created
//
//-----------------------------------------------------------------------------
LPTSTR StrDup(LPTSTR *ppszDest,LPCTSTR pszSource)
{
    if (ppszDest && pszSource)
    {
        *ppszDest = (LPTSTR)GlobalAlloc(NONZEROLPTR,lstrlen(pszSource)+1);
        if (*ppszDest)
            return (lstrcpy(*ppszDest,pszSource));
    }
    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Function:   FileExists
//
//  Synopsis:   Uses FindFirstFile to determine whether a file exists on disk
//
//  Arguments:  None
//
//  Returns:    TRUE - Found the file on disk
//              FALSE - No file found
//
//  History:    jmazner     Created     9/11/96  (as fix for Normandy #7020)
//
//-----------------------------------------------------------------------------

BOOL FileExists(TCHAR *pszINSFileName)
{

    Assert (pszINSFileName);

    HANDLE hFindResult;
    WIN32_FIND_DATA foundData;
    
    hFindResult = FindFirstFile( (LPCTSTR)pszINSFileName, &foundData );
    FindClose( hFindResult );
    if (INVALID_HANDLE_VALUE == hFindResult)
    {
        return( FALSE );
    } 
    else
    {
        return(TRUE);
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CallCMConfig
//
//  Synopsis:   Call into the CMCFG32 dll's Configure function to allow Connection
//              manager to process the .ins file as needed
//
//  Arguements: hwnd -- hwnd of parent, in case sbs wants to put up messages
//              lpszINSFile -- full path to the .ins file
//
//  Returns:    windows error code that cmcfg32 returns.
//
//  History:    2/19/97 jmazner Created for Olympus #1106 (as CallSBSCfg )
//              5/9/97  jmazner Stolen from isign32 for Olympus #416
//
//-----------------------------------------------------------------------------
DWORD CallCMConfig(LPCTSTR lpszINSFile, LPTSTR lpszConnectoidName)
{
    HINSTANCE hCMDLL = NULL;
    DWORD dwRet = ERROR_SUCCESS;

    TCHAR FAR cszCMCFG_DLL[] = TEXT("CMCFG32.DLL\0");
    CHAR  FAR cszCMCFG_CONFIGURE[] = "_CMConfig@8\0";
    typedef DWORD (WINAPI * CMCONFIGURE) (LPTSTR lpszINSFile, LPTSTR lpszConnectoidName);
    CMCONFIGURE  lpfnConfigure = NULL;

    Dprintf(TEXT("ICWCONN2: Calling LoadLibrary on %s\n"), cszCMCFG_DLL);
    hCMDLL = LoadLibrary(cszCMCFG_DLL);

    //
    // Load DLL and entry point
    //
    if (NULL != hCMDLL)
    {
        Dprintf(TEXT("ICWCONN2: Calling GetProcAddress on %s\n"), cszCMCFG_CONFIGURE);
        lpfnConfigure = (CMCONFIGURE)GetProcAddress(hCMDLL,cszCMCFG_CONFIGURE);
    }
    else
    {
        //
        // 4/2/97   ChrisK  Olympus 2759
        // If the DLL can't be loaded, pick a specific error message to return.
        //
        dwRet = ERROR_DLL_NOT_FOUND;
        goto CallCMConfigExit;
    }
    
    //
    // Call function
    //
    if( hCMDLL && lpfnConfigure )
    {
        Dprintf(TEXT("ICWCONN2: Calling the %d entry point\n"), cszCMCFG_CONFIGURE);
        dwRet = lpfnConfigure((TCHAR *)lpszINSFile, lpszConnectoidName); 
    }
    else
    {
        Dprintf(TEXT("ICWCONN2: Unable to call the Configure entry point\n"));
        dwRet = GetLastError();
    }

CallCMConfigExit:
    if( hCMDLL )
        FreeLibrary(hCMDLL);
    if( lpfnConfigure )
        lpfnConfigure = NULL;

    Dprintf(TEXT("ICWCONN2: CallCMConfig exiting with error code %d \n"), dwRet);
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn2\sources.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwconn2

MAJORCOMP=GETCONN
MINORCOMP=ICWCONN2


TARGETNAME=ICWCONN2
TARGETTYPE=PROGRAM
TARGETPATH=obj
UMTYPE=windows
UMENTRY=winmain
NOT_LEAN_AND_MEAN=1
RCNOFONTMAP=1
C_DEFINES = -DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

386_STDCALL     = 0

SOURCES=            \
    ..\icwconn2.rc  \
    ..\rnawnd.cpp   \
    ..\debug.cpp    \
    ..\dialdlg.cpp  \
    ..\dialerr.cpp  \
    ..\dialcan.cpp  \
    ..\icwerr.cpp   \
    ..\rnaapi.cpp   \
    ..\main.cpp

TARGETLIBS= \
    $(SDK_LIB_PATH)\advapi32.lib      \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\gdi32.lib         \
    $(SDK_LIB_PATH)\shell32.lib       \
    $(SDK_LIB_PATH)\tapi32.lib        \
    $(SDK_LIB_PATH)\rasapi32.lib      \
    $(SDK_LIB_PATH)\kernel32.lib

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pch.hpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn2\rnaapi.h ===
// ############################################################################
#if !defined(WIN16)
#define RASAPI_LIBRARY TEXT("RASAPI32.DLL")
#define RNAPH_LIBRARY TEXT("RNAPH.DLL")
#else
#define RASAPI_LIBRARY "rasc16ie.dll"
#endif


#define RASAPI_RASSETENTRY "RasSetEntryPropertiesA"
#define RASAPI_RASGETENTRY "RasGetEntryPropertiesA"
#define RASAPI_RASDELETEENTRY "RasDeleteEntryA"

// ############################################################################
typedef DWORD (WINAPI* PFNRASENUMDEVICES)(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb, LPDWORD lpcDevices);
typedef DWORD (WINAPI* PFNRASVALIDATEENTRYNAE)(LPTSTR lpszPhonebook, LPTSTR lpszEntry);
typedef DWORD (WINAPI* PFNRASSETENTRYPROPERTIES)(LPTSTR lpszPhonebook, LPTSTR lpszEntry, LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize, LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
typedef DWORD (WINAPI* PFNRASGETENTRYPROPERTIES)(LPTSTR lpszPhonebook, LPTSTR lpszEntry, LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);
typedef DWORD (WINAPI* PFNRASDELETEENTRY)(LPTSTR lpszPhonebook, LPTSTR lpszEntry);
typedef DWORD (WINAPI* PFNRASHANGUP)(HRASCONN);

typedef DWORD (WINAPI* PFNRASENUMCONNECTIONS)(LPRASCONN, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* PFNRASDIAL)(LPRASDIALEXTENSIONS,LPTSTR,LPRASDIALPARAMS,DWORD,LPVOID,LPHRASCONN);
typedef DWORD (WINAPI* PFNRASGETENTRYDIALPARAMS)(LPTSTR,LPRASDIALPARAMS,LPBOOL);
typedef DWORD (WINAPI* PFNRASGETCONNECTSTATUS)(HRASCONN,LPRASCONNSTATUS);
typedef DWORD (WINAPI* PFNRASGETCOUNTRYINFO)(LPRASCTRYINFO,LPDWORD);
typedef DWORD (WINAPI* PFNRASSETENTRYDIALPARAMS)(LPTSTR,LPRASDIALPARAMS,BOOL);
typedef DWORD (WINAPI* PFNRASSETAUTODIALENABLE)(DWORD dwDialingLocation, BOOL fEnabled);

#ifndef WIN16
typedef DWORD (WINAPI* PFNRASSETAUTODIALADDRESS)(LPTSTR lpszAddress,DWORD dwReserved, LPRASAUTODIALENTRY lpAutoDialEntries,
								DWORD dwcbAutoDialEntries,DWORD dwcAutoDialEntries);
#endif

// ############################################################################
class RNAAPI
{
public:
	RNAAPI();
	~RNAAPI();

	DWORD RasEnumDevices(LPRASDEVINFO, LPDWORD, LPDWORD);
	DWORD RasValidateEntryName(LPTSTR,LPTSTR);
	DWORD RasSetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
								LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize,
								LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
	DWORD RasGetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
								LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize,
								LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);
	DWORD RasDeleteEntry(LPTSTR lpszPhonebook, LPTSTR lpszEntry);
	DWORD RasHangUp(HRASCONN hrasconn);
	DWORD RasGetEntryDialParams(LPTSTR lpszPhonebook,LPRASDIALPARAMS lprasdialparams,
								LPBOOL lpfPassword);
	DWORD RasDial(LPRASDIALEXTENSIONS lpRasDialExtensions,LPTSTR lpszPhonebook,
				  LPRASDIALPARAMS lpRasDialParams,DWORD dwNotifierType,LPVOID lpvNotifier,
				  LPHRASCONN lphRasConn);
	DWORD RasEnumConnections(LPRASCONN lprasconn,LPDWORD lpcb,LPDWORD lpcConnections);
    DWORD RasGetConnectStatus(HRASCONN, LPRASCONNSTATUS);
    DWORD RasGetCountryInfo(LPRASCTRYINFO, LPDWORD);
    DWORD RasSetEntryDialParams(LPTSTR,LPRASDIALPARAMS,BOOL);
 	DWORD RasSetAutodialEnable (DWORD dwDialingLocation, BOOL fEnabled);
    
#ifndef WIN16
	DWORD RasSetAutodialAddress(LPTSTR lpszAddress,DWORD dwReserved, LPRASAUTODIALENTRY lpAutoDialEntries,
								DWORD dwcbAutoDialEntries,DWORD dwcAutoDialEntries);
#endif

private:
	BOOL LoadApi(LPCSTR, FARPROC*);

	HINSTANCE m_hInst;
	HINSTANCE m_hInst2;

	PFNRASENUMDEVICES m_fnRasEnumDeviecs;
	PFNRASVALIDATEENTRYNAE m_fnRasValidateEntryName;
	PFNRASSETENTRYPROPERTIES m_fnRasSetEntryProperties;
	PFNRASGETENTRYPROPERTIES m_fnRasGetEntryProperties;
	PFNRASDELETEENTRY m_fnRasDeleteEntry;
	PFNRASHANGUP m_fnRasHangUp;
	PFNRASENUMCONNECTIONS m_fnRasEnumConnections;
	PFNRASDIAL m_fnRasDial;
	PFNRASGETENTRYDIALPARAMS m_fnRasGetEntryDialParams;
	PFNRASGETCONNECTSTATUS m_fnRasGetConnectStatus;
	PFNRASGETCOUNTRYINFO m_fnRasGetCountryInfo;
	PFNRASSETENTRYDIALPARAMS m_fnRasSetEntryDialParams;
	PFNRASSETAUTODIALENABLE m_fnRasSetAutodialEnable;

#ifndef WIN16
	PFNRASSETAUTODIALADDRESS m_fnRasSetAutodialAddress;
#endif

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn2\rnaapi.cpp ===
/*-----------------------------------------------------------------------------
	rnaapi.cpp

	Wrapper to softlink to RNAPH and RASAPI32.DLL

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		1/29/96		ChrisK	Created
		7/22/96		ChrisK	Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "globals.h"
#if defined(WIN16)
#include <memory.h>
#endif

static const TCHAR cszRASAPI32_DLL[] = TEXT("RASAPI32.DLL");
static const TCHAR cszRNAPH_DLL[] = TEXT("RNAPH.DLL");
static const TCHAR cszRAS16[] = TEXT("RASC16IE.DLL");

static const CHAR cszRasValidateEntryNamePlain[] = "RasValidateEntryName";
static const CHAR cszRasSetAutodialEnablePlain[] = "RasSetAutodialEnable";

#ifdef UNICODE
static const CHAR cszRasEnumDevices[] = "RasEnumDevicesW";
static const CHAR cszRasValidateEntryName[] = "RasValidateEntryNameW";
static const CHAR cszRasSetEntryProperties[] = "RasSetEntryPropertiesW";
static const CHAR cszRasGetEntryProperties[] = "RasGetEntryPropertiesW";
static const CHAR cszRasDeleteEntry[] = "RasDeleteEntryW";
static const CHAR cszRasHangUp[] = "RasHangUpW";
static const CHAR cszRasGetConnectStatus[] = "RasGetConnectStatusW";
static const CHAR cszRasDial[] = "RasDialW";
static const CHAR cszRasEnumConnections[] = "RasEnumConnectionsW";
static const CHAR cszRasGetEntryDialParams[] = "RasGetEntryDialParamsW";
static const CHAR cszRasGetCountryInfo[] = "RasGetCountryInfoW";
static const CHAR cszRasSetEntryDialParams[] = "RasSetEntryDialParamsW";
static const CHAR cszRasSetAutodialEnable[] = "RasSetAutodialEnableW";
static const CHAR cszRasSetAutodialAddress[] = "RasSetAutodialAddressW";
#else  // UNICODE
static const CHAR cszRasEnumDevices[] = "RasEnumDevicesA";
static const CHAR cszRasValidateEntryName[] = "RasValidateEntryNameA";
static const CHAR cszRasSetEntryProperties[] = "RasSetEntryPropertiesA";
static const CHAR cszRasGetEntryProperties[] = "RasGetEntryPropertiesA";
static const CHAR cszRasDeleteEntry[] = "RasDeleteEntryA";
static const CHAR cszRasHangUp[] = "RasHangUpA";
static const CHAR cszRasGetConnectStatus[] = "RasGetConnectStatusA";
static const CHAR cszRasDial[] = "RasDialA";
static const CHAR cszRasEnumConnections[] = "RasEnumConnectionsA";
static const CHAR cszRasGetEntryDialParams[] = "RasGetEntryDialParamsA";
static const CHAR cszRasGetCountryInfo[] = "RasGetCountryInfoA";
static const CHAR cszRasSetEntryDialParams[] = "RasSetEntryDialParamsA";
static const CHAR cszRasSetAutodialEnable[] = "RasSetAutodialEnableA";
static const CHAR cszRasSetAutodialAddress[] = "RasSetAutodialAddressA";
#endif // UNICODE

#if defined(WIN16)
// on Win3.x we have to call RasGetEntryProperties with a larger buffer than RASENTRY.
// Who knows why.  It isn't exactly the same bug as on NT, but similar.  If the buffer
// isn't larger, RasGetEntryProperties overwrites the buffer and eventually will
// cause unexpected behavior such as GPFs and spontaeous reboots of the system.
//
#define RASENTRY_SIZE_PATCH 256
#else
// on NT we have to call RasGetEntryProperties with a larger buffer than RASENTRY.
// This is a bug in WinNT4.0 RAS, that didn't get fixed.
//
#define RASENTRY_SIZE_PATCH (7 * sizeof(DWORD))
#endif

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RNAAPI
//
//	Synopsis:	Initialize class members and load DLLs
//
//	Arguments:	None
//
//	Returns:	None
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
RNAAPI::RNAAPI()
{
#if defined(WIN16)
	m_hInst = LoadLibrary(cszRAS16); 
	m_hInst2 = NULL;
#else
	m_hInst = LoadLibrary(cszRASAPI32_DLL);
    if (FALSE == IsNT ())
    {
        //
        // we only load RNAPH.DLL if it is not NT
        // MKarki (5/4/97) - Fix for Bug #3378
        //
	    m_hInst2 = LoadLibrary(cszRNAPH_DLL);
    }
    else
    {
        m_hInst2 =  NULL;
    }
#endif
	

	m_fnRasEnumDeviecs = NULL;
	m_fnRasValidateEntryName = NULL;
	m_fnRasSetEntryProperties = NULL;
	m_fnRasGetEntryProperties = NULL;
	m_fnRasDeleteEntry = NULL;
	m_fnRasHangUp = NULL;
	m_fnRasGetConnectStatus = NULL;
	m_fnRasEnumConnections = NULL;
	m_fnRasDial = NULL;
	m_fnRasGetEntryDialParams = NULL;
	m_fnRasGetCountryInfo = NULL;
	m_fnRasSetEntryDialParams = NULL;
	m_fnRasSetAutodialEnable = NULL;
#if !defined(WIN16)
	m_fnRasSetAutodialAddress = NULL;
#endif
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::~RNAAPI
//
//	Synopsis:	release DLLs
//
//	Arguments:	None
//
//	Returns:	None
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
RNAAPI::~RNAAPI()
{
	//
	// Clean up
	//
	if (m_hInst) FreeLibrary(m_hInst);
	if (m_hInst2) FreeLibrary(m_hInst2);
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasEnumDevices
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasEnumDevices(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb,
							 LPDWORD lpcDevices)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasEnumDevices,(FARPROC*)&m_fnRasEnumDeviecs);

	if (m_fnRasEnumDeviecs)
		dwRet = (*m_fnRasEnumDeviecs) (lpRasDevInfo, lpcb, lpcDevices);

	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::LoadApi
//
//	Synopsis:	If the given function pointer is NULL, then try to load the API
//				from the first DLL, if that fails, try to load from the second
//				DLL
//
//	Arguments:	pszFName - the name of the exported function
//				pfnProc - point to where the proc address will be returned
//
//	Returns:	TRUE - success
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
BOOL RNAAPI::LoadApi(LPCSTR pszFName, FARPROC* pfnProc)
{
	if (*pfnProc == NULL)
	{
		// Look for the entry point in the first DLL
		if (m_hInst)
			*pfnProc = GetProcAddress(m_hInst,pszFName);
		
		// if that fails, look for the entry point in the second DLL
		if (m_hInst2 && !(*pfnProc))
			*pfnProc = GetProcAddress(m_hInst2,pszFName);
	}

	return (pfnProc != NULL);
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasGetConnectStatus
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		7/16/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetConnectStatus(HRASCONN hrasconn,LPRASCONNSTATUS lprasconnstatus)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasGetConnectStatus,(FARPROC*)&m_fnRasGetConnectStatus);

	if (m_fnRasGetConnectStatus)
		dwRet = (*m_fnRasGetConnectStatus) (hrasconn,lprasconnstatus);

#if defined(WIN16) && defined(DEBUG)
	Dprintf("RasGetConnectStatus returned %lu\r\n", dwRet);	
#endif
	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasValidateEntryName
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasValidateEntryName(LPTSTR lpszPhonebook,LPTSTR lpszEntry)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasValidateEntryNamePlain,(FARPROC*)&m_fnRasValidateEntryName);

	LoadApi(cszRasValidateEntryName,(FARPROC*)&m_fnRasValidateEntryName);

	if (m_fnRasValidateEntryName)
		dwRet = (*m_fnRasValidateEntryName) (lpszPhonebook, lpszEntry);

	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasSetEntryProperties
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasSetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
									LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize,
									LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;
	RASENTRY FAR *lpRE = NULL;

	// Look for the API if we haven't already found it
	LoadApi(cszRasSetEntryProperties,(FARPROC*)&m_fnRasSetEntryProperties);

	Assert(
		(NULL != lpbDeviceInfo) && (NULL != dwDeviceInfoSize)
		||
		(NULL == lpbDeviceInfo) && (NULL == dwDeviceInfoSize)
		);

#if !defined(WIN16)
#define RASGETCOUNTRYINFO_BUFFER_SIZE 256
	// Only worry about valid countryCode and countryID if we're not dial-as-is
	if ( (0 == ((LPRASENTRY)lpbEntryInfo)->dwCountryCode) &&
		 (((LPRASENTRY)lpbEntryInfo)->dwfOptions & RASEO_UseCountryAndAreaCodes) )
	{
		BYTE rasCI[RASGETCOUNTRYINFO_BUFFER_SIZE];
		LPRASCTRYINFO prasCI;
		DWORD dwSize;
		DWORD dw;
		prasCI = (LPRASCTRYINFO)rasCI;
		ZeroMemory(prasCI,sizeof(rasCI));
		prasCI->dwSize = sizeof(RASCTRYINFO);
		dwSize = sizeof(rasCI);

		Assert(((LPRASENTRY)lpbEntryInfo)->dwCountryID);
		prasCI->dwCountryID = ((LPRASENTRY)lpbEntryInfo)->dwCountryID;

		dw = RNAAPI::RasGetCountryInfo(prasCI,&dwSize);
		if (ERROR_SUCCESS == dw)
		{
			Assert(prasCI->dwCountryCode);
			((LPRASENTRY)lpbEntryInfo)->dwCountryCode = prasCI->dwCountryCode;
		} 
		else
		{
			AssertSz(0,"Unexpected error from RasGetCountryInfo.\r\n");
		}
	}
#endif

	if (m_fnRasSetEntryProperties)
		dwRet = (*m_fnRasSetEntryProperties) (lpszPhonebook, lpszEntry,
									lpbEntryInfo, dwEntryInfoSize,
									lpbDeviceInfo, dwDeviceInfoSize);
	lpRE = (RASENTRY FAR*)lpbEntryInfo;
#if !defined(WIN16)
	LclSetEntryScriptPatch(lpRE->szScript,lpszEntry);
#endif

	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasGetEntryProperties
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		1/15/96
//				jmazner	9/17/96 Modified to allow calls with buffers = NULL and InfoSizes = 0.
//								(Based on earlier modification to the same procedure in icwdial)
//				                See RasGetEntryProperties docs to learn why this is needed.
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
									LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize,
									LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;
	LPBYTE lpbEntryInfoPatch = NULL;
	LPDWORD  lpdwEntryInfoPatchSize = 0;

#if (!defined(WIN16) && WINVER != 0x400)
#error This was built with WINVER not equal to 0x400.  The size of RASENTRY may not be valid.
#endif

	if( (NULL == lpbEntryInfo) && (NULL == lpbDeviceInfo) )
	{
		Assert( NULL != lpdwEntryInfoSize );
		Assert( NULL != lpdwDeviceInfoSize );

		Assert( 0 == *lpdwEntryInfoSize );
		Assert( 0 == *lpdwDeviceInfoSize );

		// we're here to ask RAS what size these buffers need to be, don't use the patch stuff
		// (see RasGetEntryProperties docs)
		lpbEntryInfoPatch = lpbEntryInfo;
		lpdwEntryInfoPatchSize = lpdwEntryInfoSize;
	}
	else
	{

		Assert((*lpdwEntryInfoSize) >= sizeof(RASENTRY));
		Assert(lpbEntryInfo && lpdwEntryInfoSize);

		//
		// We are going to fake out RasGetEntryProperties by creating a slightly larger
		// temporary buffer and copying the data in and out.
		//
		lpdwEntryInfoPatchSize = (LPDWORD) GlobalAlloc(GPTR, sizeof(DWORD));
		if (NULL == lpdwEntryInfoPatchSize)
			return ERROR_NOT_ENOUGH_MEMORY;

		*lpdwEntryInfoPatchSize = (*lpdwEntryInfoSize) + RASENTRY_SIZE_PATCH;
		lpbEntryInfoPatch = (LPBYTE)GlobalAlloc(GPTR,*lpdwEntryInfoPatchSize);
		if (NULL == lpbEntryInfoPatch)
			return ERROR_NOT_ENOUGH_MEMORY;

		// RAS expects the dwSize field to contain the size of the LPRASENTRY struct
		// (used to check which version of the struct we're using) rather than the amount
		// of memory actually allocated to the pointer.
#if defined(WIN16)
		//((LPRASENTRY)lpbEntryInfoPatch)->dwSize = ((LPRASENTRY)lpbEntryInfo)->dwSize;
		((LPRASENTRY)lpbEntryInfoPatch)->dwSize = sizeof(RASENTRY);
#else
				// RAS expects the dwSize field to contain the size of the LPRASENTRY struct
		// (used to check which version of the struct we're using) rather than the amount
		// of memory actually allocated to the pointer.
		//((LPRASENTRY)lpbEntryInfoPatch)->dwSize = dwEntryInfoPatch;
		((LPRASENTRY)lpbEntryInfoPatch)->dwSize = sizeof(RASENTRY);

#endif
	}

	// Look for the API if we haven't already found it
	LoadApi(cszRasGetEntryProperties,(FARPROC*)&m_fnRasGetEntryProperties);

	if (m_fnRasGetEntryProperties)
		dwRet = (*m_fnRasGetEntryProperties) (lpszPhonebook, lpszEntry,
									lpbEntryInfoPatch, lpdwEntryInfoPatchSize,
									lpbDeviceInfo, lpdwDeviceInfoSize);

	Dprintf(TEXT("ICWCONN2: RasGetEntryProperties returned %lu\r\n"), dwRet);	

	if( NULL != lpbEntryInfo )
	{
		//
		// Copy out the contents of the temporary buffer UP TO the size of the original buffer
		//
		Assert(lpbEntryInfoPatch);
		memcpy(lpbEntryInfo,lpbEntryInfoPatch,*lpdwEntryInfoSize);
		GlobalFree(lpbEntryInfoPatch);
		lpbEntryInfoPatch = NULL;

		if( lpdwEntryInfoPatchSize )
		{
			GlobalFree( lpdwEntryInfoPatchSize );
			lpdwEntryInfoPatchSize = NULL;
		}
		//
		// We are again faking Ras functionality here by over writing the size value;
		// This is neccesary due to a bug in the NT implementation of RasSetEntryProperties
		*lpdwEntryInfoSize = sizeof(RASENTRY);
	}

	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasDeleteEntry
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasDeleteEntry(LPTSTR lpszPhonebook, LPTSTR lpszEntry)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasDeleteEntry,(FARPROC*)&m_fnRasDeleteEntry);

	if (m_fnRasDeleteEntry)
		dwRet = (*m_fnRasDeleteEntry) (lpszPhonebook, lpszEntry);
	
	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasHangUp
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasHangUp(HRASCONN hrasconn)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasHangUp,(FARPROC*)&m_fnRasHangUp);

	if (m_fnRasHangUp)
	{
		dwRet = (*m_fnRasHangUp) (hrasconn);
#if !defined(WIN16)
		Sleep(3000);
#endif
	}

	return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasDial(LPRASDIALEXTENSIONS lpRasDialExtensions,LPTSTR lpszPhonebook,
					  LPRASDIALPARAMS lpRasDialParams, DWORD dwNotifierType,
					  LPVOID lpvNotifier, LPHRASCONN lphRasConn)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasDial,(FARPROC*)&m_fnRasDial);

	if (m_fnRasDial)
	{
		dwRet = (*m_fnRasDial) (lpRasDialExtensions,lpszPhonebook,lpRasDialParams,
								dwNotifierType,lpvNotifier,lphRasConn);
	}
	return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasEnumConnections(LPRASCONN lprasconn,LPDWORD lpcb,LPDWORD lpcConnections)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasEnumConnections,(FARPROC*)&m_fnRasEnumConnections);

	if (m_fnRasEnumConnections)
	{
		dwRet = (*m_fnRasEnumConnections) (lprasconn,lpcb,lpcConnections);
	}
	return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasGetEntryDialParams(LPTSTR lpszPhonebook,LPRASDIALPARAMS lprasdialparams,
									LPBOOL lpfPassword)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasGetEntryDialParams,(FARPROC*)&m_fnRasGetEntryDialParams);

	if (m_fnRasGetEntryDialParams)
	{
		dwRet = (*m_fnRasGetEntryDialParams) (lpszPhonebook,lprasdialparams,lpfPassword);
	}
	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasGetCountryInfo
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		8/16/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetCountryInfo(LPRASCTRYINFO lprci, LPDWORD lpdwSize)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasGetCountryInfo,(FARPROC*)&m_fnRasGetCountryInfo);

	if (m_fnRasGetCountryInfo)
	{
		dwRet = (*m_fnRasGetCountryInfo) (lprci,lpdwSize);
	}
	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasSetEntryDialParams
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		8/20/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasSetEntryDialParams(LPTSTR lpszPhonebook,LPRASDIALPARAMS lprasdialparams,
							BOOL fRemovePassword)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasSetEntryDialParams,(FARPROC*)&m_fnRasSetEntryDialParams);

	if (m_fnRasSetEntryDialParams)
	{
		dwRet = (*m_fnRasSetEntryDialParams) (lpszPhonebook,lprasdialparams,
							fRemovePassword);
	}
	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasSetAutodialEnable
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	jmazner	Created		10/8/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasSetAutodialEnable (DWORD dwDialingLocation, BOOL fEnabled)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasSetAutodialEnablePlain,(FARPROC*)&m_fnRasSetAutodialEnable);

	if (m_fnRasSetAutodialEnable)
	{
		dwRet = (*m_fnRasSetAutodialEnable) (dwDialingLocation, fEnabled);
	}
	return dwRet;

}

#if !defined(WIN16)
//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasSetAutodialAddress
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	jmazner	Created		10/8/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasSetAutodialAddress(LPTSTR lpszAddress,DWORD dwReserved, LPRASAUTODIALENTRY lpAutoDialEntries,
								DWORD dwcbAutoDialEntries,DWORD dwcAutoDialEntries)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasSetAutodialAddress,(FARPROC*)&m_fnRasSetAutodialAddress);

	if (m_fnRasSetAutodialAddress)
	{
		dwRet = (*m_fnRasSetAutodialAddress) (lpszAddress,dwReserved, lpAutoDialEntries,
								dwcbAutoDialEntries,dwcAutoDialEntries);
	}
	return dwRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn2\rnawnd.cpp ===
/*----------------------------------------------------------------------------
    rnawnd.cpp
        
	Functions to zap the RNA windows 
	
    Copyright (C) 1995 Microsoft Corporation
    All rights reserved.

    Authors:
        ArulM
	ChrisK	Updated for ICW usage
  --------------------------------------------------------------------------*/

#include "pch.hpp"
#include "globals.h"

#define SMALLBUFLEN 48

/*******************************************************************
	NAME:		MinimizeRNAWindow
	SYNOPSIS:	Finds and minimizes the annoying RNA window
    ENTRY:		pszConnectoidName - name of connectoid launched
	NOTES:		Does a FindWindow on window class "#32770" (hard-coded
    			dialog box class which will never change), with
                the title "connected to <connectoid name>" or its
                localized equivalent.
********************************************************************/

static const TCHAR szDialogBoxClass[] = TEXT("#32770");	// hard coded dialog class name
HWND hwndFound = NULL;
DWORD dwRASWndTitleMinLen = 0;


BOOL CALLBACK MyEnumWindowsProc(HWND hwnd, LPARAM lparam)
{
	TCHAR szTemp[SMALLBUFLEN+2];
	PTSTR pszTitle;
	UINT uLen1, uLen2;

	if(!IsWindowVisible(hwnd))
		return TRUE;
	if(GetClassName(hwnd, szTemp, SMALLBUFLEN)==0)
		return TRUE; // continue enumerating
	if(lstrcmp(szTemp, szDialogBoxClass)!=0)
		return TRUE;
	if(GetWindowText(hwnd, szTemp, SMALLBUFLEN)==0)
		return TRUE;
	szTemp[SMALLBUFLEN] = 0;
	uLen1 = lstrlen(szTemp);
	Assert(dwRASWndTitleMinLen);
	if(uLen1 < dwRASWndTitleMinLen)
		return TRUE;
	// skip last 5 chars of title, but keep length to at least the min len
	uLen1 = min(dwRASWndTitleMinLen, (uLen1-5));
	pszTitle = (PTSTR)lparam;
	Assert(pszTitle);
	uLen2 = lstrlen(pszTitle);
	Dprintf(TEXT("Title=(%s), len=%d, Window=(%s), len=%d\r\n"), pszTitle, uLen2, szTemp, uLen1);
	if(uLen2 < uLen1)
		return TRUE;
	if(_memicmp(pszTitle, szTemp, uLen1)!=0)
		return TRUE;
	Dprintf(TEXT("FOUND RNA WINDOW!!!\r\n"));
	hwndFound = hwnd;
	return FALSE;
}

HWND MyFindRNAWindow(PTSTR pszTitle)
{
	DWORD dwRet;
	hwndFound = NULL;
	dwRet = EnumWindows((WNDENUMPROC)(&MyEnumWindowsProc), (LPARAM)pszTitle);
	Dprintf(TEXT("EnumWindows returned %d\r\n"), dwRet);
	return hwndFound;
}

DWORD WINAPI WaitAndMinimizeRNAWindow(PVOID pTitle)
{
	// starts as a seperate thread
	int i;
	HWND hwndRNAApp;

	Assert(pTitle);
	
	for(i=0; !(hwndRNAApp=MyFindRNAWindow((PTSTR)pTitle)) && i<100; i++)
	{
		Dprintf(TEXT("Waiting for RNA Window\r\n"));
		Sleep(50);
	}

	Dprintf(TEXT("FindWindow (%s)(%s) returned %d\r\n"), szDialogBoxClass, pTitle, hwndRNAApp);

	if(hwndRNAApp)
	{
		// Hide the window
		// ShowWindow(hwndRNAApp,SW_HIDE);
		// Used to just minimize, but that wasnt enough
		// ChrisK reinstated minimize for ICW
		ShowWindow(hwndRNAApp,SW_MINIMIZE);
	}

	LocalFree(pTitle);
	// exit function and thread
	return ERROR_SUCCESS;
}

	
void MinimizeRNAWindow(LPTSTR pszConnectoidName, HINSTANCE hInst)
{
	HANDLE hThread;
	DWORD dwThreadId;
	
	Assert(pszConnectoidName);

	// alloc strings for title and format
	TCHAR * pFmt = (TCHAR*)LocalAlloc(LPTR, (SMALLBUFLEN+1) * sizeof(TCHAR));
	TCHAR * pTitle = (TCHAR*)LocalAlloc(LPTR, (RAS_MaxEntryName + SMALLBUFLEN + 1) * sizeof(TCHAR));
	if (!pFmt || !pTitle) 
		goto error;
	
	// load the title format ("connected to <connectoid name>" from resource
	Assert(hInst);
	LoadString(hInst, IDS_CONNECTED_TO, pFmt, SMALLBUFLEN);

	// get length of localized title (including the %s). Assume the unmunged
	// part of the window title is at least "Connected to XX" long.
	dwRASWndTitleMinLen = lstrlen(pFmt);

	// build the title
	wsprintf(pTitle, pFmt, pszConnectoidName);

	hThread = CreateThread(0, 0, &WaitAndMinimizeRNAWindow, pTitle, 0, &dwThreadId);
	Assert(hThread!=INVALID_HANDLE_VALUE && dwThreadId);
	// dont free pTitle. The child thread needs it!
	LocalFree(pFmt);
	// free the thread handle or the threads stack is leaked!
	CloseHandle(hThread);
	return;
	
error:
	if(pFmt)	LocalFree(pFmt);
	if(pTitle)	LocalFree(pTitle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn2\resource.h ===
/*-----------------------------------------------------------------------------
	resource.h

	Constants used by .rc file for ICWCONN2

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved

	Authors:
		ChrisK	Chris Kauffman

	Histroy:
		7/22/96	ChrisK	Cleaned and formatted
	
	NOTE:
		DO NOT EDIT THESE RESOURCES WITH MSVC

-----------------------------------------------------------------------------*/
#ifdef APSTUDIO_INVOKED
#error DO NOT EDIT WITH MSVC
#endif

#define IDD_PROGRESS                    101
#define IDD_BACK                        102
#define IDD_CONTEXT                     103
#define IDI_PHONE                       104
#define IDB_ARROW                       105
#define IDB_WORLD                       106
#define IDD_STEPTWO                     107
#define IDB_PHONE                       108
#define IDB_ICW                         109
#define IDD_DONE                        110
#define IDD_DIALING                     111
#define IDD_DIALERR                     112
#define IDD_DONEREBOOT                  113
#define IDD_DIALREALLYCANCEL            114
#define IDS_TITLE                       500
#define IDS_CANTDOWNLOAD                501 
#define IDS_RECEIVING_RESPONSE          502
#define IDS_OUTOFMEMORY                 503
#define IDS_CALLHOME                    504
#define IDS_DOWNLOAD_SW                 505
#if !defined(WIN16)
#define IDS_CONNECTED_TO                506
#endif //!WIN16
#define IDS_INVALIDPHONE                507
//#if defined(WIN16)
#define	IDS_CANTEXECUTE                 508
//#endif
#define IDS_MISSING_FILE				509
#define IDS_BAD_CMDLINE					510
//#define IDS_NT_AUTODIAL_SUCKS			511

#define IDC_STATIC                      -1
#define IDC_PROGRESS                    1000
#define IDC_CMDCANCEL                   IDCANCEL
#define IDC_PCTARROW1                   1002
#define IDC_PCTARROW2                   1003
#define IDC_PCTARROW3                   1004
#define IDC_CMDHELP                     1005
#define IDC_CMDNEXT                     1007
#define IDC_CMDBACK                     1008
#define IDC_LBLTITLE                    1009
#define IDC_LBLSTATUS                   1010
#define IDC_LBLEXPLORE                  1011
#define IDC_CMDCLOSE                    1012
#define IDC_LBLARROW3NUM                1014
#define IDC_LBLARROW3TEXT               1015
#define IDC_LBLNUMBER                   1016
#define IDC_TEXTNUMBER                  1017
#define IDC_LBLERRMSG                   1020
#define IDC_CMBMODEMS                   1021
#define IDC_CMDDIALPROP                 1023

#define IDS_WANTTOEXIT                  1040
#define IDS_CANTSAVEKEY                 1042
#define IDC_LBLCALLHOME                 1043
#define IDC_CLICK                       1044
#define IDC_EXPLORE                     1045
#define IDC_CLICK2                      1046
#define IDC_RESTART                     1047
#define IDC_CMDEXPLORE                  2023
#define IDC_NOTDONE                     2024 
#define IDC_EXITNOW                     2025
#define IDC_ATTEMPT                     2026

#define IDC_DIALING_TEXT2               2028
#define IDC_DIALING_TEXT3               2029
#define IDC_DIALERR_TEXT1               2030
#define IDC_DIALERR_TEXT2               2031
#define IDC_DIALERR_TEXT3               2032
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn2\ras2.h ===
/* Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
**
** ras.h
** Remote Access external API
** Public header for external API clients
**
** WINVER values in this file:
**      WINVER < 0x400 = Windows NT 3.5, Windows NT 3.51
**      WINVER = 0x400 = Windows 95, Windows NT SUR (default)
**      WINVER > 0x400 = Windows NT SUR enhancements
*/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef UNLEN
#include <lmcons.h>
#endif

#include <pshpack4.h>

/* Flags for RasConnectionNotification().
*/
#define RASCN_Connection        0x00000001
#define RASCN_Disconnection     0x00000002
#define RASCN_BandwidthAdded    0x00000004
#define RASCN_BandwidthRemoved  0x00000008

/* RASENTRY 'dwDialMode' values.
*/
#define RASEDM_DialAll                  1
#define RASEDM_DialAsNeeded             2

/* RASENTRY 'dwIdleDisconnectSeconds' constants.
*/
#define RASIDS_Disabled                 0xffffffff
#define RASIDS_UseGlobalValue           0

/* AutoDial DLL function parameter block.
*/
#define RASADPARAMS struct tagRASADPARAMS
RASADPARAMS
{
    DWORD       dwSize;
    HWND        hwndOwner;
    DWORD       dwFlags;
    LONG        xDlg;
    LONG        yDlg;
};

#define LPRASADPARAMS RASADPARAMS*

/* AutoDial DLL function parameter block 'dwFlags.'
*/
#define RASADFLG_PositionDlg            0x00000001

/* Prototype AutoDial DLL function.
*/
typedef BOOL (WINAPI *RASADFUNCA)( LPSTR, LPSTR, LPRASADPARAMS, LPDWORD );
typedef BOOL (WINAPI *RASADFUNCW)( LPWSTR, LPWSTR, LPRASADPARAMS, LPDWORD );

#ifdef UNICODE
#define RASADFUNC RASADFUNCW
#else
#define RASADFUNC RASADFUNCA
#endif

/* A RAS phone book multilinked sub-entry.
*/
#define RASSUBENTRYA struct tagRASSUBENTRYA
RASSUBENTRYA
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#define RASSUBENTRYW struct tagRASSUBENTRYW
RASSUBENTRYW
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#ifdef UNICODE
#define RASSUBENTRY RASSUBENTRYW
#else
#define RASSUBENTRY RASSUBENTRYA
#endif

#define LPRASSUBENTRYW RASSUBENTRYW*
#define LPRASSUBENTRYA RASSUBENTRYA*
#define LPRASSUBENTRY  RASSUBENTRY*

/* Ras{Get,Set}Credentials structure.  These calls
** supercede Ras{Get,Set}EntryDialParams.
*/
#define RASCREDENTIALSA struct tagRASCREDENTIALSA
RASCREDENTIALSA
{
    DWORD dwSize;
    DWORD dwMask;
    CHAR szUserName[ UNLEN + 1 ];
    CHAR szPassword[ PWLEN + 1 ];
    CHAR szDomain[ DNLEN + 1 ];
};

#define RASCREDENTIALSW struct tagRASCREDENTIALSW
RASCREDENTIALSW
{
    DWORD dwSize;
    DWORD dwMask;
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#ifdef UNICODE
#define RASCREDENTIALS RASCREDENTIALSW
#else
#define RASCREDENTIALS RASCREDENTIALSA
#endif

#define LPRASCREDENTIALSW RASCREDENTIALSW*
#define LPRASCREDENTIALSA RASCREDENTIALSA*
#define LPRASCREDENTIALS  RASCREDENTIALS*

/* RASCREDENTIALS 'dwMask' values.
*/
#define RASCM_UserName       0x00000001
#define RASCM_Password       0x00000002
#define RASCM_Domain         0x00000004

/* AutoDial address properties.
*/
#define RASAUTODIALENTRYA struct tagRASAUTODIALENTRYA
RASAUTODIALENTRYA
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    CHAR szEntry[ RAS_MaxEntryName + 1];
};

#define RASAUTODIALENTRYW struct tagRASAUTODIALENTRYW
RASAUTODIALENTRYW
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    WCHAR szEntry[ RAS_MaxEntryName + 1];
};

#ifdef UNICODE
#define RASAUTODIALENTRY RASAUTODIALENTRYW
#else
#define RASAUTODIALENTRY RASAUTODIALENTRYA
#endif

#define LPRASAUTODIALENTRYW RASAUTODIALENTRYW*
#define LPRASAUTODIALENTRYA RASAUTODIALENTRYA*
#define LPRASAUTODIALENTRY  RASAUTODIALENTRY*

/* AutoDial control parameter values for
** Ras{Get,Set}AutodialParam.
*/
#define RASADP_DisableConnectionQuery           0
#define RASADP_LoginSessionDisable              1
#define RASADP_SavedAddressesLimit              2
#define RASADP_FailedConnectionTimeout          3
#define RASADP_ConnectionQueryTimeout           4


DWORD APIENTRY RasGetSubEntryHandleA( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetSubEntryHandleW( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetCredentialsA( LPSTR, LPSTR, LPRASCREDENTIALSA);

DWORD APIENTRY RasGetCredentialsW( LPWSTR, LPWSTR, LPRASCREDENTIALSW );

DWORD APIENTRY RasSetCredentialsA( LPSTR, LPSTR, LPRASCREDENTIALSA, BOOL );

DWORD APIENTRY RasSetCredentialsW( LPWSTR, LPWSTR, LPRASCREDENTIALSW, BOOL );

DWORD APIENTRY RasConnectionNotificationA( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasConnectionNotificationW( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasGetSubEntryPropertiesA( LPSTR, LPSTR, DWORD,
                    LPRASSUBENTRYA, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasGetSubEntryPropertiesW( LPWSTR, LPWSTR, DWORD,
                    LPRASSUBENTRYW, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasSetSubEntryPropertiesA( LPSTR, LPSTR, DWORD,
                    LPRASSUBENTRYA, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasSetSubEntryPropertiesW( LPWSTR, LPWSTR, DWORD,
                    LPRASSUBENTRYW, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasGetAutodialAddressA( LPSTR, LPDWORD, LPRASAUTODIALENTRYA,
                    LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialAddressW( LPWSTR, LPDWORD, LPRASAUTODIALENTRYW,
                    LPDWORD, LPDWORD);

DWORD APIENTRY RasSetAutodialAddressA( LPSTR, DWORD, LPRASAUTODIALENTRYA,
                    DWORD, DWORD );

DWORD APIENTRY RasSetAutodialAddressW( LPWSTR, DWORD, LPRASAUTODIALENTRYW,
                    DWORD, DWORD );

DWORD APIENTRY RasEnumAutodialAddressesA( LPSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumAutodialAddressesW( LPWSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialEnableA( DWORD, LPBOOL );

DWORD APIENTRY RasGetAutodialEnableW( DWORD, LPBOOL );

DWORD APIENTRY RasSetAutodialEnableA( DWORD, BOOL );

DWORD APIENTRY RasSetAutodialEnableW( DWORD, BOOL );

DWORD APIENTRY RasGetAutodialParamA( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasGetAutodialParamW( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasSetAutodialParamA( DWORD, LPVOID, DWORD );

DWORD APIENTRY RasSetAutodialParamW( DWORD, LPVOID, DWORD );


#ifdef UNICODE
#define RasDial                 RasDialW
#define RasEnumConnections      RasEnumConnectionsW
#define RasEnumEntries          RasEnumEntriesW
#define RasGetConnectStatus     RasGetConnectStatusW
#define RasGetErrorString       RasGetErrorStringW
#define RasHangUp               RasHangUpW
#define RasGetProjectionInfo    RasGetProjectionInfoW
#define RasCreatePhonebookEntry RasCreatePhonebookEntryW
#define RasEditPhonebookEntry   RasEditPhonebookEntryW
#define RasSetEntryDialParams   RasSetEntryDialParamsW
#define RasGetEntryDialParams   RasGetEntryDialParamsW
#define RasEnumDevices          RasEnumDevicesW
#define RasGetCountryInfo       RasGetCountryInfoW
#define RasGetEntryProperties   RasGetEntryPropertiesW
#define RasSetEntryProperties   RasSetEntryPropertiesW
#define RasRenameEntry          RasRenameEntryW
#define RasDeleteEntry          RasDeleteEntryW
#define RasValidateEntryName    RasValidateEntryNameW
#define RasGetSubEntryHandle        RasGetSubEntryHandleW
#define RasConnectionNotification   RasConnectionNotificationW
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesW
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesW
#define RasGetCredentials           RasGetCredentialsW
#define RasSetCredentials           RasSetCredentialsW
#define RasGetAutodialAddress       RasGetAutodialAddressW
#define RasSetAutodialAddress       RasSetAutodialAddressW
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesW
#define RasGetAutodialEnable        RasGetAutodialEnableW
#define RasSetAutodialEnable        RasSetAutodialEnableW
#define RasGetAutodialParam         RasGetAutodialParamW
#define RasSetAutodialParam         RasSetAutodialParamW
#else
#define RasDial                 RasDialA
#define RasEnumConnections      RasEnumConnectionsA
#define RasEnumEntries          RasEnumEntriesA
#define RasGetConnectStatus     RasGetConnectStatusA
#define RasGetErrorString       RasGetErrorStringA
#define RasHangUp               RasHangUpA
#define RasGetProjectionInfo    RasGetProjectionInfoA
#define RasCreatePhonebookEntry RasCreatePhonebookEntryA
#define RasEditPhonebookEntry   RasEditPhonebookEntryA
#define RasSetEntryDialParams   RasSetEntryDialParamsA
#define RasGetEntryDialParams   RasGetEntryDialParamsA
#define RasEnumDevices          RasEnumDevicesA
#define RasGetCountryInfo       RasGetCountryInfoA
#define RasGetEntryProperties   RasGetEntryPropertiesA
#define RasSetEntryProperties   RasSetEntryPropertiesA
#define RasRenameEntry          RasRenameEntryA
#define RasDeleteEntry          RasDeleteEntryA
#define RasValidateEntryName    RasValidateEntryNameA
#define RasGetSubEntryHandle        RasGetSubEntryHandleA
#define RasConnectionNotification   RasConnectionNotificationA
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesA
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesA
#define RasGetCredentials           RasGetCredentialsA
#define RasSetCredentials           RasSetCredentialsA
#define RasGetAutodialAddress       RasGetAutodialAddressA
#define RasSetAutodialAddress       RasSetAutodialAddressA
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesA
#define RasGetAutodialEnable        RasGetAutodialEnableA
#define RasSetAutodialEnable        RasSetAutodialEnableA
#define RasGetAutodialParam         RasGetAutodialParamA
#define RasSetAutodialParam         RasSetAutodialParamA
#endif
					  
#ifdef __cplusplus
}
#endif

#include <poppack.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdial\autodial.cpp ===
/*-----------------------------------------------------------------------------
    autodial.cpp

    Main entry point for autodial hook.

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

    Authors:
        ChrisK        ChrisKauffman

    History:
        7/22/96        ChrisK    Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "resource.h"
#include "semaphor.h"

UINT g_cDialAttempts = 0;
UINT g_cHangupDelay = 0;
TCHAR g_szPassword[PWLEN + 1] = TEXT("");
TCHAR g_szEntryName[RAS_MaxEntryName + 1] = TEXT("");
HINSTANCE g_hInstance = NULL;
static LPRASDIALPARAMS lpDialParams = NULL;
// 4/2/97    ChrisK    Olympus 296
HANDLE g_hRNAZapperThread = INVALID_HANDLE_VALUE;

typedef struct tagIcwDialShare
{
    TCHAR        szISPFile[MAX_PATH + 1];
    TCHAR        szCurrentDUNFile[MAX_PATH + 1];
    BYTE         fFlags;
    BYTE         bMask;
    DWORD        dwCountryID;
    WORD         wState;
    GATHEREDINFO gi;
    DWORD        dwPlatform;
    
} ICWDIALSHARE, *PICWDIALSHARE;

static PICWDIALSHARE pDynShare;

LPCTSTR GetISPFile()
{
    return pDynShare->szISPFile;
}

void SetCurrentDUNFile(LPCTSTR szDUNFile)
{
    lstrcpyn(
        pDynShare->szCurrentDUNFile,
        szDUNFile,
        SIZEOF_TCHAR_BUFFER(pDynShare->szCurrentDUNFile));
}

DWORD GetPlatform()
{
    return pDynShare->dwPlatform;
}

LPCTSTR GIGetAppDir()
{
    return pDynShare->gi.szAppDir;
}


/********************************************************************

    NAME:        LibShareEntry

    SYNOPSIS:    Initialize or uninitialize shared memory of this DLL

    NOTES:       The share memory replaces the shared section

*********************************************************************/

BOOL LibShareEntry(BOOL fInit)
{
    static TCHAR    szSharedMemName[] = TEXT("ICWDIAL_SHAREMEMORY");
    static HANDLE   hSharedMem = 0;

    BOOL    retval = FALSE;
    
    if (fInit)
    {
        DWORD   dwErr = ERROR_SUCCESS;
        
        SetLastError(0);

        hSharedMem = CreateFileMapping(
            INVALID_HANDLE_VALUE,
            NULL,
            PAGE_READWRITE,
            0,
            sizeof(ICWDIALSHARE),
            szSharedMemName);

        dwErr = GetLastError();
            
        switch (dwErr)
        {
        case ERROR_ALREADY_EXISTS:
        case ERROR_SUCCESS:
            pDynShare = (PICWDIALSHARE) MapViewOfFile(
                hSharedMem,
                FILE_MAP_WRITE,
                0,
                0,
                0);
            if (pDynShare != NULL)
            {
                if (dwErr == ERROR_SUCCESS)
                {
                    pDynShare->szISPFile[0] = (TCHAR) 0;
                    pDynShare->szCurrentDUNFile[0] = (TCHAR) 0;
                    pDynShare->fFlags = 0;
                    pDynShare->bMask = 0;
                    pDynShare->dwCountryID = 0;
                    pDynShare->wState = 0;
                    pDynShare->dwPlatform = 0xffffffff;
                }
                else    // dwErr == ERROR_ALREADY_EXISTS
                {
                    // NO initialization needed
                }

                retval = TRUE;
                
            }
            else
            {
                TraceMsg(TF_ERROR, TEXT("MapViewOfFile failed: 0x%08lx"),
                    GetLastError());
                CloseHandle(hSharedMem);
                hSharedMem = 0;
                retval = FALSE;
            }
            break;
            
        default:
            TraceMsg(TF_ERROR, TEXT("CreateFileMapping failed: 0x08lx"), dwErr);
            hSharedMem = 0;
            retval = FALSE;
            
        }
        
    }
    else
    {
        if (pDynShare)
        {
            UnmapViewOfFile(pDynShare);
            pDynShare = NULL;
        }

        if (hSharedMem)
        {
            CloseHandle(hSharedMem);
            hSharedMem = NULL;
        }

        retval = TRUE;
    }

    return retval;
    
}

//static const CHAR szBrowserClass1[] = "IExplorer_Frame";
//static const CHAR szBrowserClass2[] = "Internet Explorer_Frame";
//static const CHAR szBrowserClass3[] = "IEFrame";

//
// 8/5/97 jmazner Olympus 11215
// Isignup window caption/title is IDS_APP_TITLE in isign32\strings.inc
// IDS_APP_TITLE should be in synch with IDS_TITLE in icwdial.rc
//
static const TCHAR cszIsignupWndClassName[] = TEXT("Internet Signup\0");


static DWORD AutoDialConnect(HWND hDlg, LPRASDIALPARAMS lpDialParams);
static BOOL AutoDialEvent(HWND hDlg, RASCONNSTATE state, LPDWORD lpdwError);
static VOID SetDialogTitle(HWND hDlg, LPCTSTR pszConnectoidName);
static HWND FindBrowser(void);
static UINT RetryMessage(HWND hDlg, DWORD dwError);

#define MAX_RETIES 3
#define irgMaxSzs 5
TCHAR szStrTable[irgMaxSzs][256];
int iSzTable;

/*******************************************************************

    NAME:        DllEntryPoint

    SYNOPSIS:    Entry point for DLL.

    NOTES:        Initializes thunk layer to WIZ16.DLL

********************************************************************/
extern "C" BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
{
    BOOL retval = TRUE;
    
    TraceMsg(TF_GENERAL, "ICWDIAL :DllEntryPoint()\n");
    if( fdwReason == DLL_PROCESS_ATTACH ) {
        //
        // ChrisK Olympus 6373 6/13/97
        // Disable thread attach calls in order to avoid race condition
        // on Win95 golden
        //
        DisableThreadLibraryCalls(hInstDll);
        g_hInstance = hInstDll;

        retval = LibShareEntry(TRUE);
        
        if (0xFFFFFFFF == pDynShare->dwPlatform)
        {
            OSVERSIONINFO osver;
            ZeroMemory(&osver,sizeof(osver));
            osver.dwOSVersionInfoSize = sizeof(osver);
            if (GetVersionEx(&osver))
            {
                pDynShare->dwPlatform = osver.dwPlatformId;
            }
        }
        
    }
    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        retval = LibShareEntry(FALSE);
    }
    else if (fdwReason == DLL_THREAD_DETACH)
    {
        //
        // ChrisK 6/3/97 296
        // Broaden window to close this thread
        //
        if (INVALID_HANDLE_VALUE != g_hRNAZapperThread)
        {
            StopRNAReestablishZapper(g_hRNAZapperThread);
        }

    }

    return retval;
}

// ############################################################################
HRESULT ReleaseBold(HWND hwnd)
{
    HFONT hfont = NULL;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (hfont) DeleteObject(hfont);
    return ERROR_SUCCESS;
}

// ############################################################################
HRESULT MakeBold (HWND hwnd, BOOL fSize, LONG lfWeight)
{
    HRESULT hr = ERROR_SUCCESS;
    HFONT hfont = NULL;
    HFONT hnewfont = NULL;
    LOGFONT* plogfont = NULL;

    if (!hwnd) goto MakeBoldExit;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (!hfont)
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    plogfont = (LOGFONT*)GlobalAlloc(GPTR,sizeof(LOGFONT));
    if (!plogfont)
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    if (!GetObject(hfont,sizeof(LOGFONT),(LPVOID)plogfont))
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    if (abs(plogfont->lfHeight) < 24 && fSize)
    {
        plogfont->lfHeight = plogfont->lfHeight + (plogfont->lfHeight / 4);
    }

    plogfont->lfWeight = lfWeight;

    if (!(hnewfont = CreateFontIndirect(plogfont)))
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    SendMessage(hwnd,WM_SETFONT,(WPARAM)hnewfont,MAKELPARAM(TRUE,0));
    
MakeBoldExit:
    if (plogfont) GlobalFree(plogfont);
    plogfont = NULL;

    // if (hfont) DeleteObject(hfont);
    // BUG:? Do I need to delete hnewfont at some time?
    return hr;
}

// ############################################################################
// NAME: GetSz
//
//    Load strings from resources
//
//  Created 1/28/96,        Chris Kauffman
// ############################################################################
PTSTR GetSz(WORD wszID)
{
    PTSTR psz = szStrTable[iSzTable];
    
    iSzTable++;
    if (iSzTable >= irgMaxSzs)
        iSzTable = 0;
        
    if (!LoadString(g_hInstance, wszID, psz, 256))
    {
        TraceMsg(TF_GENERAL, "Autodial:LoadString failed %d\n", (DWORD) wszID);
        *psz = 0;
    }
        
    return (psz);
}

//+----------------------------------------------------------------------------
//
//    Function:    IsISignupRunning
//
//    Synopsis:    Check if ISIGNUP is running
//
//    Arguments:    none
//
//    Returns:    TRUE - ISIGNUP is already running
//
//    History:    7/24/97    ChrisK    fixed part of 8445
//
//-----------------------------------------------------------------------------
BOOL IsISignupRunning()
{
    //
    // IE 8445 ChrisK 7/24/97
    // As part of fixing IE 8445, the ICW was inappropriately deleting the
    // isp signup connectoid because it thought isignup was not running.
    //    

    HANDLE hSemaphore;
    BOOL bRC = FALSE;

    //
    // Check the GetLastError value immediately after the CreateSemaphore to
    // make sure nothing else changes the error value
    //
    hSemaphore = CreateSemaphore(NULL, 1, 1, ICW_ELSE_SEMAPHORE);
    if( ERROR_ALREADY_EXISTS == GetLastError() )
    {
        bRC = TRUE;
    }

    //
    // 8/3/97    jmazner    Olympus #11206
    // Even if the semaphore already exists, we still get back a handle
    // reference to it, which means that we need to close that handle
    // or else the semaphore will never get destroyed.
    //
    if( hSemaphore && (hSemaphore != INVALID_HANDLE_VALUE) )
    {
        CloseHandle(hSemaphore);
        hSemaphore = INVALID_HANDLE_VALUE;
    }

    return bRC;
}

TCHAR szDialogBoxClass[] = TEXT("#32770");    // hard coded dialog class name

// check if ICWCONN1 is running
BOOL IsICWCONN1Running()
{
    return (FindWindow(szDialogBoxClass, GetSz(IDS_TITLE)) != NULL);
}

// ############################################################################
typedef HRESULT (WINAPI *PFNINETSETAUTODIAL)(BOOL,LPCTSTR);

void RemoveAutodialer()
{
    HINSTANCE hinst = NULL;
    FARPROC fp = NULL;

    hinst = LoadLibrary(TEXT("INETCFG.DLL"));
    if (hinst)
    {
        if(fp = GetProcAddress(hinst,"InetSetAutodial"))
        {
            ((PFNINETSETAUTODIAL)fp)(FALSE, TEXT(""));
        }
        FreeLibrary(hinst);
    }
}


// ############################################################################
BOOL WINAPI AutoDialHandler(
    HWND hwndParent,    
    LPCTSTR lpszEntry,
    DWORD dwFlags,
    LPDWORD pdwRetCode
)
{
    HRESULT hr;
    INT cRetry;
    TCHAR szToDebugOrNot[2];
    DWORD dwSize;
    RNAAPI *pcRNA = NULL;
    PDIALDLGDATA pDD = NULL;
    PERRORDLGDATA pDE = NULL;

    if(!IsISignupRunning())
    {

        //
        // 7/30/97 ChrisK IE 8445
        // In ICW 1.1 icwconn1 is left alive the whole time, so we should not
        // care whether or not it is around when we go to dial.
        //
        //// in some *really* weird circs we can be called while ICWCONN1 is running
        //// if so just return failure
        //if(IsICWCONN1Running())
        //{
        //    *pdwRetCode = ERROR_CANCELLED;
        //    return TRUE;
        //}
        
        OutputDebugString(TEXT("Someome didn't cleanup ICWDIAL correctly\r\n"));
        // clean it up now! delete connectoid
        pcRNA = new RNAAPI;
        if (pcRNA)
        {
            pcRNA->RasDeleteEntry(NULL, (LPTSTR)lpszEntry);
            delete pcRNA;
            pcRNA = NULL;
        }
        // remove autodial-hook. No clue who to restore, though
        RemoveAutodialer();
        // return FALSE so someone else will dial
        return FALSE;
    }
    
#ifdef _DEBUG
    // This is how we can break into the debugger when this DLL is called as
    // part of the autodialer sequence
    //

    lstrcpyn(szToDebugOrNot,TEXT("0"),2);
    dwSize = sizeof(szToDebugOrNot);
    RegQueryValue(HKEY_LOCAL_MACHINE,TEXT("SOFTWARE\\MICROSOFT\\ISIGNUP\\DEBUG"),szToDebugOrNot,(PLONG)&dwSize);
    if (szToDebugOrNot[0] == '1')
        DebugBreak();
#endif

    // Keep track of EntryName for later
    //

    lstrcpyn(g_szEntryName,  lpszEntry, RAS_MaxEntryName);
    
    if (lstrlen(pDynShare->szISPFile)==0)
    {
//        if ((*pdwRetCode = LoadInitSettingFromRegistry()) != ERROR_SUCCESS)
//            return TRUE;
        LoadInitSettingFromRegistry();
    }

//    g_pdevice = (PMYDEVICE)GlobalAlloc(GPTR,sizeof(MYDEVICE));
//    if (!g_pdevice)
//    {
//        *pdwRetCode = ERROR_NOT_ENOUGH_MEMORY;
//        return TRUE;
//    }

TryDial:
    cRetry = 0;
TryRedial:
    
    if (pDD)
    {
        GlobalFree(pDD);
        pDD = NULL;
    }
    pDD = (PDIALDLGDATA)GlobalAlloc(GPTR,sizeof(DIALDLGDATA));
    if (pDD)
    {
        pDD->dwSize = sizeof(DIALDLGDATA);
        StrDup(&pDD->pszMessage,GetSz(IDS_DIALMESSAGE));
        StrDup(&pDD->pszRasEntryName,lpszEntry);
        pDD->pfnStatusCallback = StatusMessageCallback;
        pDD->hInst = g_hInstance;
    } else {
        MessageBox(NULL,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_MYERROR);
    }

    // Dial ISP
    //

    hr = DialingDownloadDialog(pDD);

    cRetry++;

    // Check if we should automatically redial
    //

    if ((cRetry < MAX_RETIES) && (FShouldRetry(hr)))
        goto TryRedial;

    if (hr != ERROR_USERNEXT)
    {
        pDE = (PERRORDLGDATA)GlobalAlloc(GPTR,sizeof(ERRORDLGDATA));
        if (!pDE)
        {
            MessageBox(NULL,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_MYERROR);
        } else {
            pDE->dwSize = sizeof (ERRORDLGDATA);
            StrDup(&pDE->pszMessage,GetSz(RasErrorToIDS(hr)));
            StrDup(&pDE->pszRasEntryName,lpszEntry);

            pDE->pdwCountryID = &(pDynShare->dwCountryID);            
            pDE->pwStateID = &(pDynShare->wState);
            pDE->bType = pDynShare->fFlags;
            pDE->bMask = pDynShare->bMask;
            
            StrDup(&pDE->pszHelpFile,AUTODIAL_HELPFILE);
            pDE->dwHelpID = icw_trb;
            pDE->hInst = g_hInstance;
            pDE->hParentHwnd = NULL;

            hr = DialingErrorDialog(pDE);
            
            if (hr == ERROR_USERNEXT)
                goto TryDial;
            else
                hr = ERROR_USERCANCEL;
        }
    }

    GlobalFree(pDD);
    pDD = NULL;

    if (hr == ERROR_SUCCESS)
        *pdwRetCode = ERROR_SUCCESS;
    else if (hr == ERROR_USERCANCEL)
        *pdwRetCode = ERROR_CANCELLED;

    if (ERROR_SUCCESS != *pdwRetCode)
    {
        HWND hwndIsignup = NULL;

        //
        // 8/5/97 jmazner Olympus 11215
        // For ICW 1.1 and IE 4, looking for the browser won't work
        // Instead, look for isignup and send it a special quit message.
        //

        //hwndBrowser = FindBrowser();

        hwndIsignup = FindWindow(cszIsignupWndClassName, GetSz(IDS_TITLE));
        if (NULL != hwndIsignup)
        {
            PostMessage(hwndIsignup, WM_CLOSE, 0, 0);
        }

    }
    return TRUE;
}

// ############################################################################
HRESULT LoadInitSettingFromRegistry()
{
    HRESULT hr = ERROR_SUCCESS;
    HKEY hKey = NULL;
    DWORD dwType, dwSize;

    hr = RegOpenKey(HKEY_LOCAL_MACHINE,SIGNUPKEY,&hKey);
    if (hr != ERROR_SUCCESS)
    {
        TraceMsg(TF_ERROR, TEXT("Failed RegOpenKey: %s 0x%08lx"), SIGNUPKEY, hr);
        goto LoadInitSettingFromRegistryExit;
    }

        
    dwType = REG_BINARY;
    dwSize = sizeof(pDynShare->gi);
    ZeroMemory(&(pDynShare->gi),sizeof(pDynShare->gi));
    
    hr = RegQueryValueEx(
        hKey,
        GATHERINFOVALUENAME,
        0,
        &dwType,
        (LPBYTE) &(pDynShare->gi),
        &dwSize);
    if (hr != ERROR_SUCCESS)
    {
        TraceMsg(TF_ERROR, TEXT("Failed RegQueryValueEx: %s 0x%08lx"),
            GATHERINFOVALUENAME, hr);
        goto LoadInitSettingFromRegistryExit;
    }
    
    AutoDialInit(
        pDynShare->gi.szISPFile,
        pDynShare->gi.fType,
        pDynShare->gi.bMask,
        pDynShare->gi.dwCountry,
        pDynShare->gi.wState);
        
    SetCurrentDirectory(pDynShare->gi.szAppDir);

    // Get the name of the DUN file
    
    pDynShare->szCurrentDUNFile[0] = 0;
    dwSize = SIZEOF_TCHAR_BUFFER(pDynShare->szCurrentDUNFile);
    ReadSignUpReg(
        (LPBYTE)pDynShare->szCurrentDUNFile,
        &dwSize,
        REG_SZ,
        DUNFILEVALUENAME);
        
LoadInitSettingFromRegistryExit:
    if (hKey) RegCloseKey(hKey);
    return hr;
}

// ############################################################################
/******
 *
 * 8/5/97 jmazner Olympus 11215
 * This function is no longer required
 *
static HWND FindBrowser(void)
{
    HWND hwnd;

    //look for all the microsoft browsers under the sun

    if ((hwnd = FindWindow(szBrowserClass1, NULL)) == NULL)
    {
        if ((hwnd = FindWindow(szBrowserClass2, NULL)) == NULL)
        {
            hwnd = FindWindow(szBrowserClass3, NULL);
        }
    }

    return hwnd;
}
****/

// ############################################################################
HRESULT AutoDialInit(LPTSTR lpszISPFile, BYTE fFlags, BYTE bMask, DWORD dwCountry, WORD wState)
{
    TraceMsg(TF_GENERAL, "AUTODIAL:AutoDialInit()\n");
    if (lpszISPFile) lstrcpyn(pDynShare->szISPFile, lpszISPFile, MAX_PATH);
    pDynShare->fFlags = fFlags;
    pDynShare->bMask = bMask;
    pDynShare->dwCountryID = dwCountry;
    pDynShare->wState = wState;

    return ERROR_SUCCESS;
}


// ############################################################################
BOOL FShouldRetry(HRESULT hrErr)
{
    BOOL bRC;

    if (hrErr == ERROR_LINE_BUSY ||
        hrErr == ERROR_VOICE_ANSWER ||
        hrErr == ERROR_NO_ANSWER ||
        hrErr == ERROR_NO_CARRIER ||
        hrErr == ERROR_AUTHENTICATION_FAILURE ||
        hrErr == ERROR_PPP_TIMEOUT ||
        hrErr == ERROR_REMOTE_DISCONNECTION ||
        hrErr == ERROR_AUTH_INTERNAL ||
        hrErr == ERROR_PROTOCOL_NOT_CONFIGURED ||
        hrErr == ERROR_PPP_NO_PROTOCOLS_CONFIGURED)
    {
        bRC = TRUE;
    } else {
        bRC = FALSE;
    }

    return bRC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdial\dialutil.h ===
/*-----------------------------------------------------------------------------
	dialutil.h

	contains declarations for dialutil.cpp

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		7/22/96		ChrisK	Cleaned and formatted

-----------------------------------------------------------------------------*/

#ifndef _DIALUTIL_H
#define _DIALUTIL_H

#define IDS_RASCS                    100
#define IDS_OPENPORT                 IDS_RASCS+ 0
#define IDS_PORTOPENED               IDS_RASCS+ 1
#define IDS_CONNECTDEVICE            IDS_RASCS+ 2
#define IDS_DEVICECONNECTED          IDS_RASCS+ 3
#define IDS_ALLDEVICESCONNECTED      IDS_RASCS+ 4
#define IDS_AUTHENTICATE             IDS_RASCS+ 5
#define IDS_AUTHNOTIFY               IDS_RASCS+ 6
#define IDS_AUTHRETRY                IDS_RASCS+ 7
#define IDS_AUTHCALLBACK             IDS_RASCS+ 8
#define IDS_AUTHCHANGEPASSWORD       IDS_RASCS+ 9
#define IDS_AUTHPROJECT              IDS_RASCS+10
#define IDS_AUTHLINKSPEED            IDS_RASCS+11
#define IDS_AUTHACK                  IDS_RASCS+12
#define IDS_REAUTHENTICATE           IDS_RASCS+13
#define IDS_AUTHENTICATED            IDS_RASCS+14
#define IDS_PREPAREFORCALLBACK       IDS_RASCS+15
#define IDS_WAITFORMODEMRESET        IDS_RASCS+16
#define IDS_WAITFORCALLBACK          IDS_RASCS+17
#define IDS_INTERACTIVE              IDS_RASCS+18
#define IDS_RETRYAUTHENTICATION      IDS_RASCS+19
#define IDS_CALLBACKSETBYCALLER      IDS_RASCS+20
#define IDS_PASSWORDEXPIRED          IDS_RASCS+21
#define IDS_CONNECTED                IDS_RASCS+22
#define IDS_DISCONNECTED             IDS_RASCS+23
#define IDS_RASCS_END                IDS_DISCONNECTED
#define IDS_UNDEFINED_ERROR          IDS_RASCS_END+1

#define IDS_CONNECTED_TO             200
#define IDS_DOWNLOADING              201


VOID CenterWindow(HWND hwndChild, HWND hwndParent);
BOOL MinimizeRNAWindow(TCHAR * pszConnectoidName);
DWORD GetPhoneNumber(LPTSTR lpszEntryName, LPTSTR lpszPhoneNumber);
LPTSTR NEAR PASCAL GetDisplayPhone(LPTSTR szPhoneNum);
DWORD _RasGetStateString(RASCONNSTATE state, LPTSTR lpszState, DWORD cb);
HRESULT AutoDialInit(LPTSTR lpszISPFile, BYTE fFlags, BYTE bMask, DWORD dwCountry, WORD wState);
DWORD ReplacePhoneNumber(LPTSTR lpszEntryName, LPTSTR lpszPhoneNumber);
LPTSTR StrDup(LPTSTR *ppszDest,LPCTSTR pszSource);
INT_PTR CALLBACK GenericDlgProc(HWND, UINT, WPARAM, LPARAM);

#define PHONEBOOK_LIBRARY TEXT("ICWPHBK.DLL")
#define PHBK_LOADAPI           "PhoneBookLoad"
#define PHBK_SUGGESTAPI        "PhoneBookSuggestNumbers"
#define PHBK_DISPLAYAPI        "PhoneBookDisplaySignUpNumbers"
#define PHBK_UNLOADAPI         "PhoneBookUnload"
#define PHBK_GETCANONICAL      "PhoneBookGetCanonical"

typedef HRESULT (CALLBACK* PFNPHONEBOOKLOAD)(LPCTSTR pszISPCode, DWORD_PTR *pdwPhoneID);
typedef HRESULT (CALLBACK* PFNPHONEDISPLAY)(DWORD_PTR dwPhoneID,TCHAR **ppszPhoneNumbers,
											TCHAR **ppszDunFiles, WORD *pwPhoneNumbers,
											DWORD *pdwCountry,WORD *pwRegion,BYTE fType,
											BYTE bMask,HWND hwndParent,DWORD dwFlags);
typedef HRESULT (CALLBACK *PFNPHONEBOOKUNLOAD) (DWORD_PTR dwPhoneID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdial\dlapi.cpp ===
/*-----------------------------------------------------------------------------
	dlapi.cpp

	Wrapper for softlinking to download DLL

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		7/22/96		ChrisK	Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "debug.h"
#include "icwdl.h"
#include "dlapi.h"

// ############################################################################
CDownLoadAPI::CDownLoadAPI()
{
	m_hDLL = NULL;
	m_pfnDownLoadInit = NULL;
	m_pfnDownLoadCancel = NULL;
	m_pfnDownLoadExecute = NULL;
	m_pfnDownLoadClose = NULL;
	m_pfnDownLoadSetStatus = NULL;
	m_pfnDownLoadProcess = NULL;
}

// ############################################################################
CDownLoadAPI::~CDownLoadAPI()
{
	if (m_hDLL) FreeLibrary(m_hDLL);
	m_hDLL = NULL;
	m_pfnDownLoadInit = NULL;
	m_pfnDownLoadCancel = NULL;
	m_pfnDownLoadExecute = NULL;
	m_pfnDownLoadClose = NULL;
	m_pfnDownLoadSetStatus = NULL;
	m_pfnDownLoadProcess = NULL;
}

// ############################################################################
HRESULT CDownLoadAPI::LoadAPI(LPSTR szApiName, FARPROC* pfp)
{
	Assert(szApiName && pfp);
	if (!m_hDLL)
		m_hDLL = LoadLibrary(DOWNLOAD_LIBRARY);

	if (m_hDLL && !(*pfp))
	{
		*pfp = GetProcAddress(m_hDLL, szApiName);
		if (*pfp)
			return ERROR_SUCCESS;
		else
			return GetLastError();
	} else {
		return GetLastError();
	}
}

// ############################################################################
HRESULT CDownLoadAPI::DownLoadInit(PTSTR pszUrl, DWORD_PTR * lpCDialingDlg, DWORD_PTR *lpdwDownload, HWND hwndParent)
{
	HRESULT hr = ERROR_DLL_NOT_FOUND;
	LoadAPI(DOWNLOADINIT,(FARPROC*)&m_pfnDownLoadInit);
	if (m_pfnDownLoadInit)
		hr =  (m_pfnDownLoadInit)(pszUrl, lpCDialingDlg, lpdwDownload, hwndParent);
	return hr;
}

// ############################################################################
HRESULT CDownLoadAPI::DownLoadCancel(DWORD_PTR dwDownload)
{
	HRESULT hr = ERROR_DLL_NOT_FOUND;
	LoadAPI(DOWNLOADCANCEL,(FARPROC*)&m_pfnDownLoadCancel);
	if (m_pfnDownLoadCancel)
		hr =  (m_pfnDownLoadCancel)(dwDownload);
	return hr;
}

// ############################################################################
HRESULT CDownLoadAPI::DownLoadExecute(DWORD_PTR dwDownload)
{
	HRESULT hr = ERROR_DLL_NOT_FOUND;
	LoadAPI(DOWNLOADEXECUTE,(FARPROC*)&m_pfnDownLoadExecute);
	if (m_pfnDownLoadExecute)
		hr =  (m_pfnDownLoadExecute)(dwDownload);
	return hr;
}

// ############################################################################
HRESULT CDownLoadAPI::DownLoadProcess(DWORD_PTR dwDownload)
{
	HRESULT hr = ERROR_DLL_NOT_FOUND;
	LoadAPI(DOWNLOADPROCESS,(FARPROC*)&m_pfnDownLoadProcess);
	if (m_pfnDownLoadProcess)
		hr =  (m_pfnDownLoadProcess)(dwDownload);
	return hr;
}

// ############################################################################
HRESULT CDownLoadAPI::DownLoadClose(DWORD_PTR dwDownload)
{
	HRESULT hr = ERROR_DLL_NOT_FOUND;
	LoadAPI(DOWNLOADCLOSE,(FARPROC*)&m_pfnDownLoadClose);
	if (m_pfnDownLoadClose)
		hr =  (m_pfnDownLoadClose)(dwDownload);
	return hr;
}

// ############################################################################
HRESULT CDownLoadAPI::DownLoadSetStatus(DWORD_PTR dwDownload, INTERNET_STATUS_CALLBACK fnCallback)
{
	HRESULT hr = ERROR_DLL_NOT_FOUND;
	LoadAPI(DOWNLOADSETSTATUS,(FARPROC*)&m_pfnDownLoadSetStatus);
	if (m_pfnDownLoadSetStatus)
		// jmazner 10/2/96 Normandy # 8493
		// ICWDL.DLL's DownLoadSetStatus only has two parameters!!!
		//hr =  (m_pfnDownLoadSetStatus)(dwDownload, fnCallback, dwContext);
		  hr =  (m_pfnDownLoadSetStatus)(dwDownload, fnCallback);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdial\dlapi.h ===
/*-----------------------------------------------------------------------------
	dlapi.h

	contains declarations for download api soft link wrappers

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		7/22/96		ChrisK	Cleaned and formatted

-----------------------------------------------------------------------------*/

#ifndef _DLAPI_H
#define _DLAPI_H

class CDownLoadAPI
{
public:
	CDownLoadAPI();
	~CDownLoadAPI();
	HRESULT DownLoadInit(PTSTR, DWORD_PTR *, DWORD_PTR *, HWND);
	HRESULT DownLoadCancel(DWORD_PTR);
	HRESULT DownLoadExecute(DWORD_PTR);
	HRESULT DownLoadClose(DWORD_PTR);
	HRESULT DownLoadSetStatus(DWORD_PTR, INTERNET_STATUS_CALLBACK);
	HRESULT DownLoadProcess(DWORD_PTR);

private:
	HINSTANCE m_hDLL;
	PFNDOWNLOADINIT m_pfnDownLoadInit;
	PFNDOWNLOADCANCEL m_pfnDownLoadCancel;
	PFNDOWNLOADEXECUTE m_pfnDownLoadExecute;
	PFNDOWNLOADCLOSE m_pfnDownLoadClose;
	PFNDOWNLOADSETSTATUS m_pfnDownLoadSetStatus;
	PFNDOWNLOADPROCESS m_pfnDownLoadProcess;

	HRESULT LoadAPI(LPSTR, FARPROC*);
};

#endif // _DLAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdial\globals.h ===
/*-----------------------------------------------------------------------------
	globals.h

	contains general declarations for ICWDIAL

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		7/22/96		ChrisK	Cleaned and formatted

-----------------------------------------------------------------------------*/

#include <ras.h>
#include <raserror.h>
#include <tapi.h>
#include <wininet.h>
#include "debug.h"
#include "icwdial.h"
#include "icwdl.h"
#include "rnaapi.h"
#include "dlapi.h"
#include "helpids.h"
#include "dialutil.h"

// ############################################################################
#define NUMRETRIES      3

#define MAXHANGUPDELAY  20
#define ONE_SECOND      1000
#define TIMER_ID        0

#define SMALLBUFLEN 80

#define ERROR_USERCANCEL 32767 // quit message value
#define ERROR_USERBACK 32766 // back message value
#define ERROR_USERNEXT 32765 // back message value
#define ERROR_DOWNLOADIDNT 32764 // Download failure

#define ERROR_READING_DUN		32768
#define ERROR_READING_ISP		32769
#define ERROR_PHBK_NOT_FOUND	32770
#define ERROR_DOWNLOAD_NOT_FOUND 32771

#define SIGNUPKEY TEXT("Software\\Microsoft\\iSignUp")
#define GATHERINFOVALUENAME TEXT("UserInfo")

#define	MAX_PROMO 64
#define MAX_OEMNAME 64
#define MAX_AREACODE RAS_MaxAreaCode
#define MAX_EXCHANGE 8
#define MAX_VERSION_LEN 40
#define MAX_CANONICAL_NUMBER 40

#define INSFILE_APPNAME TEXT("ClientSetup")
#define INFFILE_SETUP_CLIENT_URL TEXT("Client_Setup_Url")
#define INFFILE_SETUP_NEW_CALL TEXT("Client_Setup_New_Call")
#define INFFILE_DONE_MESSAGE TEXT("Done_Message")
#define INFFILE_EXPLORE_CMD TEXT("Explore_Command")
#define INFFILE_ENTRYSECTION TEXT("Entry")
#define INFFILE_ENTRY_NAME TEXT("Entry_Name")
#define INFFILE_USER_SECTION TEXT("User")
#define INFFILE_PASSWORD TEXT("Password")

#define NULLSZ TEXT("")

#define MB_MYERROR (MB_APPLMODAL | MB_ICONERROR | MB_SETFOREGROUND)
#define MsgBox(x,y) MessageBox(NULL,GetSz(x),GetSz(IDS_TITLE),y)
#define DUNFILEVALUENAME  TEXT("DUNFilePath")
#define RASENTRYVALUENAME TEXT("RasEntryName")

#define DllExport extern "C" __declspec(dllexport)

#define WM_DOWNLOAD_DONE	WM_USER + 4

#define HINTERNET DWORD

#define AUTODIAL_HELPFILE  TEXT("connect.hlp>proc4")

#define IF_NTONLY if(VER_PLATFORM_WIN32_NT == GetPlatform()) {
#define ENDIF_NTONLY }
#define IF_WIN95ONLY if(VER_PLATFORM_WIN32_WINDOWS == GetPlatform()) {
#define ENDIF_WIN95ONLY }

#define SIZEOF_TCHAR_BUFFER(buf)    ((sizeof(buf) / sizeof(TCHAR)))

// ############################################################################

typedef struct tagGATHEREDINFO
{
	LCID	lcid;
	DWORD	dwOS;
	DWORD	dwMajorVersion;
	DWORD	dwMinorVersion;
	WORD	wArchitecture;
	TCHAR	szPromo[MAX_PROMO];
	TCHAR	szOEM[MAX_OEMNAME];
	TCHAR	szAreaCode[MAX_AREACODE+1];
	TCHAR	szExchange[MAX_EXCHANGE+1];
	DWORD	dwCountry;
	TCHAR	szSUVersion[MAX_VERSION_LEN];
	WORD	wState;
	BYTE	fType;
	BYTE	bMask;
	TCHAR   szISPFile[MAX_PATH+1];
	TCHAR	szAppDir[MAX_PATH+1];
} GATHEREDINFO, *PGATHEREDINFO;


// ############################################################################
class CDialog
{
public:
	BOOL m_bShouldAsk;

	CDialog() {m_bShouldAsk=TRUE;};
	~CDialog() {};

	virtual LRESULT DlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT)=0;
};

class CDialingDlg : public CDialog
{
public:
	HRASCONN m_hrasconn;
	LPTSTR m_pszConnectoid;
	HANDLE m_hThread;
	DWORD m_dwThreadID;
	HWND m_hwnd;
	LPTSTR m_pszUrl;
	LPTSTR m_pszDisplayable;
	DWORD_PTR m_dwDownLoad;
	LPTSTR m_pszPhoneNumber;
	LPTSTR m_pszMessage;
	PFNSTATUSCALLBACK m_pfnStatusCallback;
	HINSTANCE m_hInst;
	UINT m_unRasEvent;
	LPTSTR m_pszDunFile;
	HLINEAPP m_hLineApp;
	DWORD m_dwNumDev;
	DWORD m_dwTapiDev;
	DWORD m_dwAPIVersion;
	RNAAPI *m_pcRNA;
	BYTE m_bProgressShowing;
	DWORD m_dwLastStatus;
	CDownLoadAPI *m_pcDLAPI;
	BOOL m_bSkipDial;
	RASDIALFUNC1 m_pfnRasDialFunc1;
	//
	// ChrisK 5240 Olympus
	// Only the thread that creates the dwDownload should invalidate it
	// so we need another method to track if the cancel button has been
	// pressed.
	//
	BOOL m_fDownloadHasBeenCanceled;

	CDialingDlg();
	~CDialingDlg();
	HRESULT GetDisplayableNumberDialDlg();
	LRESULT DlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT);
	HRESULT DialDlg();
	HRESULT Init();
	VOID CDialingDlg::ProgressCallBack(HINTERNET hInternet,DWORD_PTR dwContext,
												DWORD dwInternetStatus,
												LPVOID lpvStatusInformation,
												DWORD dwStatusInformationLength);

};

class CDialingErrorDlg : public CDialog
{ 
public:
	HINSTANCE m_hInst;
	HWND m_hwnd;

	LPTSTR m_pszConnectoid;
	LPTSTR m_pszDisplayable;
	LPTSTR m_pszPhoneNumber;
	LPTSTR m_pszMessage;
	LPTSTR m_pszDunFile;
	DWORD_PTR m_dwPhoneBook;

	HLINEAPP m_hLineApp;
	DWORD m_dwTapiDev;
	DWORD m_dwAPIVersion;
	RNAAPI *m_pcRNA;

	DWORD m_dwNumDev;
	LPRASDEVINFO m_lpRasDevInfo;

	DWORD m_dwCountryID;
	WORD m_wState;
	BYTE m_bType;
	BYTE m_bMask;

	LPTSTR m_pszHelpFile;
	DWORD m_dwHelpID;

	CDialingErrorDlg();
	~CDialingErrorDlg();
	HRESULT Init();
	LRESULT DlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT);
	HRESULT GetDisplayableNumber();
	HRESULT FillModems();
	HRESULT CreateDialAsIsConnectoid(LPCTSTR lpszDialNumber);
};

/**
typedef struct tagDialErr
{
	LPTSTR m_pszConnectoid;
	HRESULT m_hrError;
	PGATHEREDINFO m_pGI;
	HWND m_hwnd;
	HLINEAPP m_hLineApp;
	DWORD m_dwAPIVersion;
	char m_szPhoneNumber[256];
	LPTSTR m_pszDisplayable;
	HINSTANCE m_hInst;
	LPRASDEVINFO m_lprasdevinfo;
} DIALERR, *PDIALERR;
**/

typedef struct tagDEVICE
{
	DWORD dwTapiDev;
	RASDEVINFO RasDevInfo;
} MYDEVICE, *PMYDEVICE;


// ############################################################################
extern HRASCONN g_hRasConn;
extern UINT g_cDialAttempts;
extern UINT g_cHangupDelay;
extern TCHAR g_szPassword[PWLEN + 1];
extern TCHAR g_szEntryName[RAS_MaxEntryName + 1];
extern HINSTANCE g_hInstance;
extern LPRASDIALPARAMS lpDialParams;

DWORD GetPlatform();
LPCTSTR GetISPFile();
void SetCurrentDUNFile(LPCTSTR szDUNFile);
LPCTSTR GIGetAppDir();

extern const TCHAR szBrowserClass1[];
extern const TCHAR szBrowserClass2[];
extern const TCHAR szBrowserClass3[];

// 3/28/97 ChrisK Olympus 296
extern HANDLE g_hRNAZapperThread;

//
// 6/3/97 jmazner Olympus #4851
//
#ifdef WIN16
	#define g_iMyMaxPhone 36
#else
	// allocated in dialerr.cpp
	extern int g_iMyMaxPhone;
	#define MAXPHONE_NT		80
	#define MAXPHONE_95		36
#endif

// ############################################################################
DWORD AutoDialConnect(HWND hDlg, LPRASDIALPARAMS lpDialParams);
BOOL AutoDialEvent(HWND hDlg, RASCONNSTATE state, LPDWORD lpdwError);
VOID SetDialogTitle(HWND hDlg, LPCTSTR pszConnectoidName);
HWND FindBrowser(void);
UINT RetryMessage(HWND hDlg, DWORD dwError);
HRESULT ReadSignUpReg(LPBYTE lpbData, DWORD *pdwSize, DWORD dwType, LPCTSTR pszKey);
HRESULT StoreInSignUpReg(LPBYTE lpbData, DWORD dwSize, DWORD dwType, LPCTSTR pszKey);

INT_PTR CALLBACK AutoDialDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM Param);
INT_PTR CALLBACK PhoneNumberDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM Param);
INT_PTR CALLBACK RetryDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM Param);

void CALLBACK LineCallback(DWORD hDevice,DWORD dwMessage,DWORD dwInstance,
						   DWORD dwParam1,DWORD dwParam2,DWORD dwParam3);
HRESULT ShowDialErrDialog(HRESULT hrErr, LPTSTR pszConnectoid, HINSTANCE hInst, HWND hwnd);
LRESULT DialErrDlgProc(HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam);
HRESULT FillModems();
HRESULT DialErrGetDisplayableNumber();
WORD RasErrorToIDS(DWORD dwErr);
HRESULT LoadInitSettingFromRegistry();
PTSTR GetSz(WORD wszID);
HRESULT ImportConnection (LPCTSTR szFileName, LPTSTR pszEntryName, LPTSTR pszUserName, LPTSTR pszPassword);
HRESULT CreateEntryFromDUNFile(PTSTR pszDunFile);
BOOL FSz2Dw(PCTSTR pSz,DWORD *dw);
BOOL BreakUpPhoneNumber(RASENTRY *prasentry, LPTSTR pszPhone);
int Sz2W (LPCTSTR szBuf);
int FIsDigit( int c );
void *MyMemCpy(void *dest,const void *src, size_t count);
PTSTR GetNextNumericChunk(PTSTR psz, PTSTR pszLim, PTSTR* ppszNext);
HRESULT DialDlg();
BOOL FShouldRetry(HRESULT hrErr);
HRESULT MakeBold (HWND hwnd, BOOL fSize, LONG lfWeight);
DWORD WINAPI DownloadThreadInit(CDialingDlg *pcPDlg);
VOID WINAPI ProgressCallBack(DWORD hInternet,DWORD_PTR dwContext,DWORD dwInternetStatus,
							   LPVOID lpvStatusInformation,DWORD dwStatusInformationLength);
HRESULT WINAPI StatusMessageCallback(DWORD dwStatus, LPTSTR pszBuffer, DWORD dwBufferSize);
HRESULT ReleaseBold(HWND hwnd);
void MinimizeRNAWindow(LPTSTR pszConnectoidName, HINSTANCE hInst);
#if !defined(WIN16) && defined(DEBUG)
BOOL FCampusNetOverride();
#endif //!WIN && DEBUG
#if !defined(WIN16)
BOOL WINAPI RasSetEntryPropertiesScriptPatch(LPTSTR lpszScript, LPTSTR lpszEntry);
// 4/2/97	ChrisK	Olympus 296
void StopRNAReestablishZapper(HANDLE hthread);
HANDLE LaunchRNAReestablishZapper(HINSTANCE hInst);
#endif //!WIN16


inline BOOL IsNT(void)
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdial\icwerr.cpp ===
/*-----------------------------------------------------------------------------
    icwerr.cpp

    Maps RAS and downloading errors to string resource indices

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

    Authors:
        ChrisK        ChrisKauffman

    History:
        7/22/96        ChrisK    Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "resource.h"

#define RAS_BOGUS_AUTHFAILCODE_1    84
#define RAS_BOGUS_AUTHFAILCODE_2    74389484

// ############################################################################
HRESULT WINAPI StatusMessageCallback(DWORD dwStatus, LPTSTR pszBuffer, DWORD dwBufferSize)
{
    if (pszBuffer && dwBufferSize)
    {
        WORD wSID = 0;
        switch(dwStatus)
        {
        case RASCS_OpenPort:
            wSID = IDS_RAS_OPENPORT;
            break;
        case RASCS_PortOpened:
            wSID = IDS_RAS_PORTOPENED;
            break;
        case RASCS_ConnectDevice:
            wSID = IDS_RAS_DIALING;
            break;
#if !defined(WIN16)
        case RASCS_DeviceConnected:
            wSID = IDS_RAS_CONNECTED;
            break;
#else
        case RASCS_AllDevicesConnected:
            wSID = IDS_RAS_CONNECTED;
            break; 
#endif

        case RASCS_Authenticate:
        case RASCS_StartAuthentication:
        case RASCS_LogonNetwork:
            wSID = IDS_RAS_LOCATING;
            break;  

        case RASCS_Disconnected:
            //
            // 8/3/97    jmazner    Olympus #11221
            //
            wSID = IDS_RAS_HANGINGUP;
            break;
        
        }
        if (0 == wSID && RASBASE <= dwStatus)
            wSID = RasErrorToIDS(dwStatus);
        
        lstrcpyn(pszBuffer,GetSz(wSID),dwBufferSize);
        return ERROR_SUCCESS;
    } else {
        return ERROR_INVALID_PARAMETER;
    }
}

// ############################################################################
WORD RasErrorToIDS(DWORD dwErr)
{

    TraceMsg(TF_GENERAL, "ICWDIAL: RasErrorToIDS received %d\n",dwErr);
    if(dwErr==RAS_BOGUS_AUTHFAILCODE_1 || dwErr==RAS_BOGUS_AUTHFAILCODE_2)
    {
        TraceMsg(TF_GENERAL, "ICWDIAL: RAS returned bogus AUTH error code %08x. Munging...\r\n", dwErr);
        return IDS_PPPRANDOMFAILURE;
    }

    if((dwErr>=653 && dwErr<=663) || (dwErr==667) || (dwErr>=669 && dwErr<=675))
    {
        TraceMsg(TF_GENERAL, "ICWDIAL: Got random RAS MEDIA error! (%d)\r\n",dwErr);
        return IDS_MEDIAINIERROR;
    }
    
    switch(dwErr)
    {
    default:
        return IDS_PPPRANDOMFAILURE;

    case SUCCESS:
        return 0;
        
    case ERROR_LINE_BUSY:
        return IDS_PHONEBUSY;

    case ERROR_NO_ANSWER:
        return IDS_NOANSWER;
        
    case ERROR_VOICE_ANSWER:
    case ERROR_NO_CARRIER:
        return IDS_RASNOCARRIER;
        
    case ERROR_NO_DIALTONE:
        return IDS_NODIALTONE;

    case ERROR_HARDWARE_FAILURE:    // modem turned off
    case ERROR_PORT_ALREADY_OPEN:    // procomm/hypertrm/RAS has COM port
        return IDS_NODEVICE;

    case ERROR_USER_DISCONNECTION:
        return IDS_USERCANCELEDDIAL;

    case ERROR_BUFFER_INVALID:                // bad/empty rasdilap struct
    case ERROR_BUFFER_TOO_SMALL:            // ditto?
    case ERROR_CANNOT_FIND_PHONEBOOK_ENTRY:    // if connectoid name in registry is wrong
        return IDS_TCPINSTALLERROR;

    case ERROR_AUTHENTICATION_FAILURE:        // get this on actual CHAP reject
        return IDS_PPPRANDOMFAILURE;

    case ERROR_PPP_TIMEOUT:        // get this on CHAP timeout
        return IDS_PPPRANDOMFAILURE;

    case ERROR_REMOTE_DISCONNECTION:        // Ascend drops connection on auth-fail
        return IDS_PPPRANDOMFAILURE;

    case ERROR_AUTH_INTERNAL:                // got this on random POP failure
    case ERROR_PROTOCOL_NOT_CONFIGURED:        // get this if LCP fails
    case ERROR_PPP_NO_PROTOCOLS_CONFIGURED:    // get this if IPCP addr download gives garbage
        return IDS_PPPRANDOMFAILURE;

    case ERROR_USERCANCEL:
        return IDS_USERCANCELEDDIAL;

/******
    case ERROR_CHANGING_PASSWORD:
    case ERROR_PASSWD_EXPIRED:
        ev = EVENT_INVALIDPASSWORD; break;

    case ERROR_ACCT_DISABLED:
    case ERROR_ACCT_EXPIRED:
        ev = EVENT_LOCKEDACCOUNT; break;

    case ERROR_NO_DIALIN_PERMISSION:
    case ERROR_RESTRICTED_LOGON_HOURS:
    case ERROR_AUTHENTICATION_FAILURE:
        ev = EVENT_RAS_AUTH_FAILED; break;

    case ERROR_ALREADY_DISCONNECTING:
    case ERROR_DISCONNECTION:
        ev = EVENT_CONNECTION_DROPPED; break;

    case PENDING: 
    case ERROR_INVALID_PORT_HANDLE:
    case ERROR_CANNOT_SET_PORT_INFO:
    case ERROR_PORT_NOT_CONNECTED:
    case ERROR_DEVICE_DOES_NOT_EXIST:
    case ERROR_DEVICETYPE_DOES_NOT_EXIST:
    case ERROR_PORT_NOT_FOUND:
    case ERROR_DEVICENAME_TOO_LONG:
    case ERROR_DEVICENAME_NOT_FOUND:
         ev=EVENT_BAD_MODEM_CONFIG; break;

    case ERROR_TAPI_CONFIGURATION:
        ev=EVENT_BAD_TAPI_CONFIG; break;
    
        ev=EVENT_MODEM_BUSY; break;
    
    case ERROR_BUFFER_TOO_SMALL:
    case ERROR_WRONG_INFO_SPECIFIED:
    case ERROR_EVENT_INVALID:
    case ERROR_BUFFER_INVALID:
    case ERROR_ASYNC_REQUEST_PENDING:
    case ERROR_CANNOT_OPEN_PHONEBOOK:
    case ERROR_CANNOT_LOAD_PHONEBOOK:
    case ERROR_CANNOT_WRITE_PHONEBOOK:
    case ERROR_CORRUPT_PHONEBOOK:
    case ERROR_CANNOT_LOAD_STRING:
    case ERROR_OUT_OF_BUFFERS:
    case ERROR_MACRO_NOT_FOUND:
    case ERROR_MACRO_NOT_DEFINED:
    case ERROR_MESSAGE_MACRO_NOT_FOUND:
    case ERROR_DEFAULTOFF_MACRO_NOT_FOUND:
    case ERROR_FILE_COULD_NOT_BE_OPENED:
    case ERROR_PORT_NOT_OPEN:
    case ERROR_PORT_DISCONNECTED:
    case ERROR_NO_ENDPOINTS:
    case ERROR_KEY_NOT_FOUND:
    case ERROR_INVALID_SIZE:
    case ERROR_PORT_NOT_AVAILABLE:
    case ERROR_UNKNOWN:
    case ERROR_WRONG_DEVICE_ATTACHED:
    case ERROR_BAD_STRING:
    case ERROR_BAD_USAGE_IN_INI_FILE:
    case ERROR_READING_SECTIONNAME:
    case ERROR_READING_DEVICETYPE:
    case ERROR_READING_DEVICENAME:
    case ERROR_READING_USAGE:
    case ERROR_READING_MAXCONNECTBPS:
    case ERROR_READING_MAXCARRIERBPS:
    case ERROR_IN_COMMAND:
    case ERROR_WRITING_SECTIONNAME:
    case ERROR_WRITING_DEVICETYPE:
    case ERROR_WRITING_DEVICENAME:
    case ERROR_WRITING_MAXCONNECTBPS:
    case ERROR_WRITING_MAXCARRIERBPS:
    case ERROR_WRITING_USAGE:
    case ERROR_WRITING_DEFAULTOFF:
    case ERROR_READING_DEFAULTOFF:
    case ERROR_EMPTY_INI_FILE:
    case ERROR_FROM_DEVICE:
    case ERROR_UNRECOGNIZED_RESPONSE:
    case ERROR_NO_RESPONSES:
    case ERROR_NO_COMMAND_FOUND:
    case ERROR_WRONG_KEY_SPECIFIED:
    case ERROR_UNKNOWN_DEVICE_TYPE:
    case ERROR_ALLOCATING_MEMORY:
    case ERROR_PORT_NOT_CONFIGURED:
    case ERROR_DEVICE_NOT_READY:
    case ERROR_READING_INI_FILE:
    case ERROR_NO_CONNECTION:
    case ERROR_PORT_OR_DEVICE:
    case ERROR_NOT_BINARY_MACRO:
    case ERROR_DCB_NOT_FOUND:
    case ERROR_STATE_MACHINES_NOT_STARTED:
    case ERROR_STATE_MACHINES_ALREADY_STARTED:
    case ERROR_PARTIAL_RESPONSE_LOOPING:
    case ERROR_UNKNOWN_RESPONSE_KEY:
    case ERROR_RECV_BUF_FULL:
    case ERROR_CMD_TOO_LONG:
    case ERROR_UNSUPPORTED_BPS:
    case ERROR_UNEXPECTED_RESPONSE:
    case ERROR_INTERACTIVE_MODE:
    case ERROR_BAD_CALLBACK_NUMBER:
    case ERROR_INVALID_AUTH_STATE:
    case ERROR_WRITING_INITBPS:
    case ERROR_X25_DIAGNOSTIC:
    case ERROR_OVERRUN:
    case ERROR_RASMAN_CANNOT_INITIALIZE:
    case ERROR_BIPLEX_PORT_NOT_AVAILABLE:
    case ERROR_NO_ACTIVE_ISDN_LINES:
    case ERROR_NO_ISDN_CHANNELS_AVAILABLE:
    case ERROR_TOO_MANY_LINE_ERRORS:
        ev=EVENT_INTERNAL_ERROR; break;
    
    case ERROR_ROUTE_NOT_AVAILABLE:
    case ERROR_ROUTE_NOT_ALLOCATED:
    case ERROR_INVALID_COMPRESSION_SPECIFIED:
    case ERROR_CANNOT_PROJECT_CLIENT:
    case ERROR_CANNOT_GET_LANA:
    case ERROR_NETBIOS_ERROR:
    case ERROR_NAME_EXISTS_ON_NET:
        ev=EVENT_BAD_NET_CONFIG; break;
    
    case ERROR_REQUEST_TIMEOUT:
    case ERROR_SERVER_OUT_OF_RESOURCES:
    case ERROR_SERVER_GENERAL_NET_FAILURE:
    case WARNING_MSG_ALIAS_NOT_ADDED:
    case ERROR_SERVER_NOT_RESPONDING:
        ev=EVENT_GENERAL_NET_ERROR; break;
        
    case ERROR_IP_CONFIGURATION:
    case ERROR_NO_IP_ADDRESSES:
    case ERROR_PPP_REMOTE_TERMINATED:
    case ERROR_PPP_NO_RESPONSE:
    case ERROR_PPP_INVALID_PACKET:
    case ERROR_PHONE_NUMBER_TOO_LONG:
    case ERROR_IPXCP_NO_DIALOUT_CONFIGURED:
    case ERROR_IPXCP_NO_DIALIN_CONFIGURED:
    case ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE:
    case ERROR_ACCESSING_TCPCFGDLL:
    case ERROR_NO_IP_RAS_ADAPTER:
    case ERROR_SLIP_REQUIRES_IP:
    case ERROR_PROJECTION_NOT_COMPLETE:
    case ERROR_PPP_NOT_CONVERGING:
    case ERROR_PPP_CP_REJECTED:
    case ERROR_PPP_LCP_TERMINATED:
    case ERROR_PPP_REQUIRED_ADDRESS_REJECTED:
    case ERROR_PPP_NCP_TERMINATED:
    case ERROR_PPP_LOOPBACK_DETECTED:
    case ERROR_PPP_NO_ADDRESS_ASSIGNED:
    case ERROR_CANNOT_USE_LOGON_CREDENTIALS:
    case ERROR_NO_LOCAL_ENCRYPTION:
    case ERROR_NO_REMOTE_ENCRYPTION:
    case ERROR_REMOTE_REQUIRES_ENCRYPTION:
    case ERROR_IPXCP_NET_NUMBER_CONFLICT:
        ev = EVENT_PPP_FAILURE; break;
***********/
    }
    return (0xFFFF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdial\dialerr.cpp ===
/*-----------------------------------------------------------------------------
	dialerr.cpp

	Handle Could Not Connect dialog

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		7/22/96		ChrisK	Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "resource.h"

TCHAR szBuf256[256];

#define VALID_INIT (m_pcRNA && m_hLineApp && m_pszPhoneNumber)
TCHAR szValidPhoneCharacters[] = {TEXT("0123456789AaBbCcDdPpTtWw!@$ -.()+*#,&\0")};

#ifndef WIN16
int g_iMyMaxPhone = 0;
#endif

//+---------------------------------------------------------------------------
//
//	Function:	ProcessDBCS
//
//	Synopsis:	Converts control to use DBCS compatible font
//				Use this at the beginning of the dialog procedure
//	
//				Note that this is required due to a bug in Win95-J that prevents
//				it from properly mapping MS Shell Dlg.  This hack is not needed
//				under winNT.
//
//	Arguments:	hwnd - Window handle of the dialog
//				cltID - ID of the control you want changed.
//
//	Returns:	ERROR_SUCCESS
// 
//	History:	4/31/97 a-frankh	Created
//				5/13/97	jmazner		Stole from CM to use here
//----------------------------------------------------------------------------
void ProcessDBCS(HWND hDlg, int ctlID)
{
#if defined(WIN16)
	return;
#else
	HFONT hFont = NULL;

	if( IsNT() )
	{
		return;
	}

	hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
	if (hFont == NULL)
		hFont = (HFONT) GetStockObject(SYSTEM_FONT);
	if (hFont != NULL)
		SendMessage(GetDlgItem(hDlg,ctlID), WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0));
#endif
}

//+---------------------------------------------------------------------------
//
//	Function:	IsSBCSString
//
//	Synopsis:	Walks through a string looking for DBCS characters
//
//	Arguments:	sz -- the string to check
//
//	Returns:	TRUE if no DBCS characters are found
//				FALSE otherwise
// 
//	History:	5/17/97	jmazner		Stole from conn1 to use here
//									(Olympus #137)
//----------------------------------------------------------------------------
#if !defined(WIN16)
BOOL IsSBCSString( LPCTSTR sz )
{
	Assert(sz);

#ifdef UNICODE
    // Check if the string contains only ASCII chars.
    int attrib = IS_TEXT_UNICODE_ASCII16 | IS_TEXT_UNICODE_CONTROLS;
    return (BOOL)IsTextUnicode((CONST LPVOID)sz, lstrlen(sz), &attrib);
#else
	while( NULL != *sz )
	{
		 if (IsDBCSLeadByte(*sz)) return FALSE;
		 sz++;
	}

	return TRUE;
#endif
}
#endif


//+----------------------------------------------------------------------------
//
//	Function: DialingErrorDialog
//
//	Synopsis:	Display and handle dialing error dialog, or as it is known
//				the "Could Not Connect" dialog
//
//	Arguemtns:	pED - pointer to error dialog data structure
//
//	Returns:	ERROR_USERNEXT - user hit redial
//				ERROR_USERCANCEL - user selected cancel
//				otherwise the function returns the appropriate error code
//
//	History:	7/2/96	ChrisK	Created
//
//-----------------------------------------------------------------------------
HRESULT WINAPI DialingErrorDialog(PERRORDLGDATA pED)
{
	HRESULT hr = ERROR_SUCCESS;
	CDialingErrorDlg *pcDEDlg = NULL;

	//
	// Validate parameters
	//

	if (!pED)
	{
		hr = ERROR_INVALID_PARAMETER;
		goto DialingErrorDialogExit;
	}

	if (pED->dwSize < sizeof(ERRORDLGDATA))
	{
		hr = ERROR_BUFFER_TOO_SMALL;
		goto DialingErrorDialogExit;
	}

	//
	// Initialize dialog
	//

	pcDEDlg = new CDialingErrorDlg;
	if (!pcDEDlg)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto DialingErrorDialogExit;
	}

#ifndef WIN16
	if( IsNT() )
	{
		g_iMyMaxPhone = MAXPHONE_NT;
	}
	else
	{
		g_iMyMaxPhone = MAXPHONE_95;
	}
#endif

	AssertMsg( (RAS_MaxPhoneNumber >= g_iMyMaxPhone), "RAS_MaxPhone < g_iMyMaxPhone" );

	//
	// Copy in data
	//

	pcDEDlg->m_hInst = pED->hInst;
	pcDEDlg->m_hwnd = pED->hParentHwnd;

	if (ERROR_SUCCESS != (hr = pcDEDlg->Init()))
		goto DialingErrorDialogExit;

	StrDup(&pcDEDlg->m_pszConnectoid,pED->pszRasEntryName);
	StrDup(&pcDEDlg->m_pszMessage,pED->pszMessage);
	StrDup(&pcDEDlg->m_pszDunFile,pED->pszDunFile);
	pcDEDlg->m_dwPhoneBook = pED->dwPhonebook;

	if (0 != pED->dwPhonebook)
	{
		if (pED->pdwCountryID) pcDEDlg->m_dwCountryID = *(pED->pdwCountryID);
		if (pED->pwStateID) pcDEDlg->m_wState = *(pED->pwStateID);
		pcDEDlg->m_bType = pED->bType;
		pcDEDlg->m_bMask = pED->bMask;
	}

	//
	// Help information, if one was not specified use the default trouble shooter
	//

	if (pcDEDlg->m_pszHelpFile)
	{
		StrDup(&pcDEDlg->m_pszHelpFile,pED->pszHelpFile);
		pcDEDlg->m_dwHelpID = pED->dwHelpID;
	}
	else
	{
		StrDup(&pcDEDlg->m_pszHelpFile,AUTODIAL_HELPFILE);
		pcDEDlg->m_dwHelpID = icw_trb;
	}

	//
	// Display dialog
	//

	hr = (HRESULT)DialogBoxParam(GetModuleHandle(TEXT("ICWDIAL")),MAKEINTRESOURCE(IDD_DIALERR),
		pED->hParentHwnd,GenericDlgProc,(LPARAM)pcDEDlg);

	//
	// Copy out data
	//

	if (pED->pszDunFile)
		GlobalFree(pED->pszDunFile);
	pED->pszDunFile = NULL;
	StrDup(&pED->pszDunFile,pcDEDlg->m_pszDunFile);


DialingErrorDialogExit:
	if (pcDEDlg) delete pcDEDlg;
	pcDEDlg = NULL;
	return hr;
}

//+----------------------------------------------------------------------------
//
//	Function:	CDialingErrorDlg (constructor)
//
//	Synopsis:	initializes CDialingErrorDlg data members
//
//	Arguements:	none
//
//	Returns:	none
//
//	History:	7/2/96	ChrisK	Created
//
//-----------------------------------------------------------------------------
CDialingErrorDlg::CDialingErrorDlg()
{
	m_hInst = NULL;
	m_hwnd = NULL;

	m_pszConnectoid = NULL;
	m_pszDisplayable = NULL;
	m_pszPhoneNumber = NULL;
	m_pszMessage = NULL;
	m_pszDunFile = NULL;
	m_dwPhoneBook = 0;

	m_hLineApp = NULL;
	m_dwTapiDev = 0;
	m_dwAPIVersion = 0;
	m_pcRNA = NULL;

	m_lpRasDevInfo = NULL;
	m_dwNumDev = 0;

	m_pszHelpFile = NULL;
	m_dwHelpID = 0;

	m_dwCountryID = 0;
	m_wState = 0;
	m_bType = 0;
	m_bMask = 0;

	// Normandy 10612 - ChrisK
	// The dial error dialog will handle its own prompt to exit.  The generic
	// dialog proc should not ask about this.
	m_bShouldAsk = FALSE;

}

//+----------------------------------------------------------------------------
//
//	Function:	~CDialingErrorDlg (destructor)
//
//	Synopsis:	deallocated and cleans up data members
//
//	Arguements:	none
//
//	Returns:	none
//
//	History:	7/2/96	ChrisK	Created
//
//-----------------------------------------------------------------------------
CDialingErrorDlg::~CDialingErrorDlg()
{
	m_hInst = NULL;
	m_hwnd = NULL;

	if (m_pszConnectoid) GlobalFree(m_pszConnectoid);
	m_pszConnectoid = NULL;

	if (m_pszDisplayable) GlobalFree(m_pszDisplayable);
	m_pszDisplayable = NULL;

	if (m_pszPhoneNumber) GlobalFree(m_pszPhoneNumber);
	m_pszPhoneNumber = NULL;

	if (m_pszMessage) GlobalFree(m_pszMessage);
	m_pszMessage = NULL;

	if (m_pszDunFile) GlobalFree(m_pszDunFile);
	m_pszDunFile = NULL;

	m_dwPhoneBook = 0;

	if (m_hLineApp) lineShutdown(m_hLineApp);
	m_hLineApp = NULL;

	if (m_pszHelpFile) GlobalFree(m_pszHelpFile);
	m_pszHelpFile = NULL;

	m_dwHelpID = 0;

	m_dwNumDev = 0;
	m_dwTapiDev = 0;
	m_dwAPIVersion = 0;
	m_pcRNA = NULL;

	m_dwCountryID = 0;
	m_wState = 0;
	m_bType = 0;
	m_bMask = 0;

}

//+----------------------------------------------------------------------------
//
//	Function:	CDialingErrorDlg::Init
//
//	Synopsis:	Intialize data members that may fail.  We need to return an
//				code for these cases and C++ constructors don't support this
//
//	Arguments:	none
//
//	Returns:	ERROR_SUCCESS - success
//				anything else indicates a failure
//
//	History:	7/2/96	ChrisK	Created
//
//-----------------------------------------------------------------------------
HRESULT CDialingErrorDlg::Init()
{
	HRESULT hr = ERROR_SUCCESS;
	LPLINEEXTENSIONID lpExtensionID = NULL;

	// Initialize RAS/RNA
	//

	m_pcRNA = new RNAAPI;
	if (!m_pcRNA)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto InitExit;
	}

	//
	// Initialize TAPI
	//

	hr = lineInitialize(&m_hLineApp,m_hInst,LineCallback,NULL,&m_dwNumDev);
	if (hr) goto InitExit;

	lpExtensionID = (LPLINEEXTENSIONID)GlobalAlloc(LPTR,sizeof(LINEEXTENSIONID));
	if (!lpExtensionID)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto InitExit;
	}

	hr = lineNegotiateAPIVersion(m_hLineApp, m_dwTapiDev, 0x00010004, 0x00010004,
		&m_dwAPIVersion, lpExtensionID);

	// 4/2/97	ChrisK	Olypmus 2745
	while (ERROR_SUCCESS != hr && m_dwTapiDev < (m_dwNumDev - 1))
	{
		m_dwTapiDev++;
		hr = lineNegotiateAPIVersion(m_hLineApp, m_dwTapiDev, 0x00010004, 0x00010004,
		&m_dwAPIVersion, lpExtensionID);
	}

	if (hr != ERROR_SUCCESS)
		goto InitExit;
	
	// Initialize strings
	//

	// 
	// 6/3/97 jmazner Olympus #4868
	// allocate enough space to hold maximum length phone numbers.
	//

	//m_pszPhoneNumber = (LPTSTR)GlobalAlloc(LPTR,MAX_CANONICAL_NUMBER);
	m_pszPhoneNumber = (LPTSTR)GlobalAlloc(GPTR,
		sizeof(TCHAR)*(MAX_CANONICAL_NUMBER>g_iMyMaxPhone?MAX_CANONICAL_NUMBER:g_iMyMaxPhone + 1));

	if (!m_pszPhoneNumber)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto InitExit;
	}

InitExit:
	if (lpExtensionID) GlobalFree(lpExtensionID);
	return hr;
}

//+----------------------------------------------------------------------------
//
//	Function:	CDialingErrorDlg::DlgProc
//
//	Synopsis:	Handle messages sent to the dial error dialog
//
//	Arguments:	See Windows documentation for DialogProc's
//
//	Returns:	See Windows documentation for DialogProc's
//
//	History:	7/8/96	ChrisK	Created
//
//-----------------------------------------------------------------------------
LRESULT CDialingErrorDlg::DlgProc(HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam, LRESULT lres)
{
	LRESULT lRes = TRUE;
	HRESULT hr;
	// Normandy 11745
	// WORD wIDS;
	FARPROC fp = NULL;
	LPTSTR *ppPhoneNumbers;
	LPTSTR pszPhoneNumber;
	LPTSTR *ppDunFiles;
	LPTSTR pszDunFile = NULL;
	WORD wNumber;
	DWORD dwSize;
	LPRASENTRY lpRasEntry = NULL;
	LPRASDEVINFO lpRasDevInfo = NULL;
	DWORD dwRasEntrySize = 0;
	DWORD dwRasDevInfoSize = 0;
	LRESULT idx = 0;
	HINSTANCE hPHBKDll = NULL;
	LPTSTR lpszDialNumber = NULL;
	static BOOL bCheckDisplayable = FALSE;
    static BOOL bInitComplete = FALSE;     //shows dialog init is complete - MKarki
    static BOOL bDlgPropEnabled = TRUE;   //this flags holds state of Dialing Properties PushButton MKarki - (5/3/97/) Fix for Bug#3393
    //CSupport    objSupportNum;
    //CHAR  szSupportNumber[256];
    //CHAR    szSupportMsg[256]; 

	static BOOL fUserEditedNumber = FALSE;

	Assert(NULL == m_hwnd || hwnd == m_hwnd);

	switch(uMsg)
	{
	case WM_INITDIALOG:
		Assert(VALID_INIT);

    //
    // This GOTO has been added to
    // display dialog again when phone numbers are
    // not valid -  MKarki (4/21/97) Fix for Bug#2868 and 3461
    //
ShowErrDlgAgain:

		m_hwnd = hwnd;


		// Set limit on phone number length
		//

		//
		// ChrisK Olympus 4851 6/9/97
		// The maximum length of this string needs to include space for a terminating
		// NULL
		//
		SendDlgItemMessage(hwnd,IDC_TEXTNUMBER,EM_SETLIMITTEXT,g_iMyMaxPhone - 1 ,0);

#if 0
        //
        // Get the PSS Support Number now
        // MKarki (5/9/97) -  Fix for Bug#267
        //
        if ((objSupportNum.GetSupportInfo(szSupportNumber)) == TRUE)
        {
            //
            // show the info
            //
            lstrcpy (szSupportMsg, GetSz (IDS_SUPPORTMSG));
            lstrcat (szSupportMsg, szSupportNumber); 
			SetDlgItemText(hwnd,IDC_LBSUPPORTMSG, szSupportMsg);
        }
#endif

		// Show the phone number
		//
		hr = GetDisplayableNumber();
		if (hr != ERROR_SUCCESS)
		{
			bCheckDisplayable = FALSE;
			SetDlgItemText(hwnd,IDC_TEXTNUMBER,m_pszPhoneNumber);
		} else {
			bCheckDisplayable = TRUE;
			SetDlgItemText(hwnd,IDC_TEXTNUMBER,m_pszDisplayable);
		}

		// Bug Normandy 5920
		// ChrisK, turns out we are calling MakeBold twice
		// MakeBold(GetDlgItem(m_hwnd,IDC_LBLTITLE),TRUE,FW_BOLD);

		// Fill in error message
		//
		if (m_pszMessage)
			SetDlgItemText(m_hwnd,IDC_LBLERRMSG,m_pszMessage);

		FillModems();

		//
		// Enable DBCS on win95-J systems
		//
		ProcessDBCS(m_hwnd, IDC_CMBMODEMS);
		ProcessDBCS(m_hwnd, IDC_TEXTNUMBER);

		// Set the focus to the Modems selection list
		//
	    SetFocus(GetDlgItem(m_hwnd,IDC_CMBMODEMS));

		lRes = FALSE;


		SetForegroundWindow(m_hwnd);

		if (0 == m_dwPhoneBook)
		{
			//
			// 8/1/97	jmazner	Olympus #11118
			// This ISP phonebook code is totally messed up, but we never use this
			// functionality anyways.  Just make sure that the phonebook button is gone
			// unless someone explicitly asks for it.
			//

			//if (g_szISPFile[0] == '\0') // BUG: this condition should go away eventually.
										// see the comments with the phone book button code below.
			//{
				ShowWindow(GetDlgItem(hwnd,IDC_LBLPHONE),SW_HIDE);
				ShowWindow(GetDlgItem(hwnd,IDC_CMDPHONEBOOK),SW_HIDE);
			//}
		}

        //
        //  we should disable the Dialing Properites PushButton
        //  if we have changed the phone number once
        //  MKarki (5/3/97) - Fix for Bug#3393
        //
        if (FALSE == bDlgPropEnabled)
        {
            EnableWindow (
                GetDlgItem (hwnd, IDC_CMDDIALPROP), 
                FALSE
                );
        }
            
        //
        // This shows the INIT for the error dialog is complete
        // and we can start processing changes to Ph No. TEXTBOX
        // MKarki (4/24/97) - Fix for Bug#3511
        //
        bInitComplete = TRUE;

		break;
	case WM_CLOSE:
		if (MessageBox(m_hwnd,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
			MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
			EndDialog(m_hwnd,ERROR_USERCANCEL);
		break;
	case WM_DESTROY:
		ReleaseBold(GetDlgItem(m_hwnd,IDC_LBLTITLE));
		break;

	case WM_HELP:
		//
		// Chrisk Olympus 5130 5/27/97
		// Added support for F1 Help Key
		//
		if (m_pszHelpFile && *m_pszHelpFile)
			WinHelp(m_hwnd,m_pszHelpFile,HELP_CONTEXT,m_dwHelpID);
		break;

	case WM_COMMAND:
		switch(LOWORD(wparam))
		{

        //
        // We now processes changes to ph no. EDIT BOX
        // If there is anychange in the phone number we
        // disable to Dialing Properties Push Button
        // MKarki (3/22/97) - Fix for Bug #3511
        //
        case IDC_TEXTNUMBER:
			TCHAR lpszTempNumber[RAS_MaxPhoneNumber + 1];

            if ((HIWORD (wparam) == EN_CHANGE) && (bInitComplete == TRUE))
            {
                if ((GetDlgItemText (
                            hwnd,
                            IDC_TEXTNUMBER,
                            lpszTempNumber,
                            RAS_MaxPhoneNumber + 1
                            ))  && 
            		(0 != lstrcmp(
                             lpszTempNumber, 
                              bCheckDisplayable ? m_pszDisplayable : m_pszPhoneNumber)))
			    {
                    //
                    // number has been modified by the user
                    // hide the Dialing Properties Push Button  
                    //
                    EnableWindow (
                            GetDlgItem (hwnd, IDC_CMDDIALPROP), 
                            FALSE
                            );
                    //
                    // save the state of the Dialing Properties PushButton
                    // MKarki (5/3/97) -  Fix for Bug#3393
                    //
                    bDlgPropEnabled = FALSE;

					//
					// 7/17/97 jmazner Olympus #8234
					//
					fUserEditedNumber = TRUE;
                }
            }
			break;

		case IDC_CMBMODEMS:
			if (HIWORD(wparam) == CBN_SELCHANGE)
			{

				idx = SendDlgItemMessage(m_hwnd,IDC_CMBMODEMS,CB_GETCURSEL,0,0);
				//
				// ChrisK Olympus 245 5/25/97
				// Get index of modem
				//
				idx = SendDlgItemMessage(m_hwnd,IDC_CMBMODEMS,CB_GETITEMDATA,idx,0);
				if (idx == CB_ERR) break;

				//
				// Get the connectoid
				//

				hr = ICWGetRasEntry(&lpRasEntry, &dwRasEntrySize, &lpRasDevInfo, &dwRasDevInfoSize, m_pszConnectoid);
				// UNDONE: Error Message

				//
				// Replace the device with a new one
				//

				lstrcpyn(lpRasEntry->szDeviceType,m_lpRasDevInfo[idx].szDeviceType,RAS_MaxDeviceType+1);
				lstrcpyn(lpRasEntry->szDeviceName,m_lpRasDevInfo[idx].szDeviceName,RAS_MaxDeviceName+1);

				if (lpRasDevInfo) GlobalFree(lpRasDevInfo);
				//
				// ChrisK Olympus 2461 5/30/97
				// Ras will take the modem settings from the RasEntry structure.  If these are
				// not zeroed out, then they will corrupt the entry.
				//
				lpRasDevInfo = 0;
				dwRasDevInfoSize = 0;
				
				hr = m_pcRNA->RasSetEntryProperties(NULL,m_pszConnectoid,(LPBYTE)lpRasEntry,dwRasEntrySize,(LPBYTE)lpRasDevInfo,dwRasDevInfoSize);
				lpRasDevInfo = NULL;	// Set back to NULL so we don't try and free later

				if (lpRasEntry) GlobalFree(lpRasEntry);
				lpRasEntry = NULL;
				// DO NOT FREE DEVINFO struct!!
				lpRasDevInfo = NULL;
				dwRasEntrySize = 0;
				dwRasDevInfoSize = 0;
			}
			break;
		case IDC_CMDNEXT:
			//
			// Redial button
			//

			// NOTE: This button is actually labeled "Redial"
			//
			lpszDialNumber = (LPTSTR)GlobalAlloc(GPTR, sizeof(TCHAR)*(g_iMyMaxPhone + 2));
			if (NULL == lpszDialNumber)
			{
				MsgBox(IDS_OUTOFMEMORY,MB_MYERROR);
				break;
			}
			// If the user has altered the phone number, make sure it can be used
			//
			if (fUserEditedNumber &&
				(GetDlgItemText(hwnd, IDC_TEXTNUMBER, lpszDialNumber, g_iMyMaxPhone + 1)) &&
				(0 != lstrcmp(lpszDialNumber, bCheckDisplayable ? m_pszDisplayable : m_pszPhoneNumber)))
			{
                //
                //  return failure if we do not have a valid
                //  phone number - MKarki 4/21/97 Bug# 2868 & 3461
                //
				hr = CreateDialAsIsConnectoid(lpszDialNumber);
                lRes = (hr == ERROR_SUCCESS);
			}

			if (lpszDialNumber) 
				GlobalFree(lpszDialNumber);

            //
            // only end this dialog, if we have a valid 
            //  phone number, else refresh the same dialog
            //  MKarki (4/21/97) Fix for Bug#2868 & 3461
            //
            if (lRes == TRUE)
			    EndDialog(m_hwnd,ERROR_USERNEXT);
            else
                goto ShowErrDlgAgain;

			break;
		case IDC_CMDHELP:
			//
			// Help Button
			//
			if (m_pszHelpFile && *m_pszHelpFile)
				WinHelp(m_hwnd,m_pszHelpFile,HELP_CONTEXT,m_dwHelpID);
			break;
		case IDC_CMDCANCEL:
			//
			// Cancel button
			//
			if (MessageBox(m_hwnd,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
				MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
				EndDialog(m_hwnd,ERROR_USERCANCEL);
			break;

		case IDC_CMDDIALPROP:
			//
			// Dialing properties
			//

			// If the user has altered the phone number, make sure it can be used
			//

			lpszDialNumber = (LPTSTR)GlobalAlloc(GPTR, sizeof(TCHAR)*(g_iMyMaxPhone + 2));
			if (NULL == lpszDialNumber)
			{
				MsgBox(IDS_OUTOFMEMORY,MB_MYERROR);
				break;
			}

			if (fUserEditedNumber &&
				(GetDlgItemText(hwnd, IDC_TEXTNUMBER, lpszDialNumber, g_iMyMaxPhone + 1)) &&
				(0 != lstrcmp(lpszDialNumber, bCheckDisplayable ? m_pszDisplayable : m_pszPhoneNumber)))
			{
				hr = CreateDialAsIsConnectoid(lpszDialNumber);
                lRes = (hr ==   ERROR_SUCCESS);
				lstrcpy(m_pszPhoneNumber,lpszDialNumber);
			}

			// 11/25/96	jmazner	Normandy #10294
			//ShowWindow(m_hwnd,SW_HIDE);
			EnableWindow(m_hwnd, FALSE);

			hr = lineTranslateDialog(m_hLineApp,m_dwTapiDev,m_dwAPIVersion,m_hwnd,m_pszPhoneNumber);

			hr = GetDisplayableNumber();
			if (hr != ERROR_SUCCESS)
			{
				bCheckDisplayable = FALSE;
				SetDlgItemText(hwnd,IDC_TEXTNUMBER,m_pszPhoneNumber);
			} else {
				bCheckDisplayable = TRUE;
				SetDlgItemText(hwnd,IDC_TEXTNUMBER,m_pszDisplayable);
			}

			if (lpszDialNumber) 
				GlobalFree(lpszDialNumber);

#if 0
            //
            //  See if support number has changed
            // MKarki (5/9/97) -  Fix for Bug#267
            //
            if ((objSupportNum.GetSupportInfo(szSupportNumber)) == TRUE)
            {
                //
                // show the info
                //
                lstrcpy (szSupportMsg, GetSz (IDS_SUPPORTMSG));
                lstrcat (szSupportMsg, szSupportNumber); 
			    SetDlgItemText(hwnd,IDC_LBSUPPORTMSG, szSupportMsg);
            }
            else
            {
                //
                // need to clear what is being displayed now
                //
                ZeroMemory ( szSupportMsg, sizeof (szSupportMsg));
			    SetDlgItemText(hwnd,IDC_LBSUPPORTMSG, szSupportMsg);
            }
#endif

			//ShowWindow(m_hwnd,SW_SHOW);
			EnableWindow(m_hwnd, TRUE);
			
			SetForegroundWindow(m_hwnd);

			//
			// 6/6/97 jmazner Olympus #4759
			//
			SetFocus(GetDlgItem(hwnd,IDC_CMDNEXT));

			break;
		case IDC_CMDPHONEBOOK:
			// BUG: This code will not work with the restructured dialer DLL.
			// The problem is the restructure DLL expects the call to have already
			// opened and load the phone book and just pass in the dwPhoneBook ID.
			// This code actually loads the phone book from the global ISP file.
PhoneBookClick:
			if (!hPHBKDll)
				hPHBKDll = LoadLibrary(PHONEBOOK_LIBRARY);
			if (!hPHBKDll)
			{
				wsprintf(szBuf256,GetSz(IDS_CANTLOADINETCFG),PHONEBOOK_LIBRARY);
				MessageBox(m_hwnd,szBuf256,GetSz(IDS_TITLE),MB_MYERROR);
			} else {
				fp = GetProcAddress(hPHBKDll,PHBK_LOADAPI);
				if (!fp)
					MsgBox(IDS_CANTLOADPHBKAPI,MB_MYERROR);
				else
				{
					hr = ((PFNPHONEBOOKLOAD)fp)(GetISPFile(),&m_dwPhoneBook);
					if (hr != ERROR_SUCCESS)
						MsgBox(IDS_CANTINITPHONEBOOK,MB_MYERROR);
					else
					{
						fp = GetProcAddress(hPHBKDll,PHBK_DISPLAYAPI);
						if (!fp)
							MsgBox(IDS_CANTLOADPHBKAPI,MB_MYERROR);
						else {
							ppPhoneNumbers = &pszPhoneNumber;
							pszPhoneNumber = m_pszPhoneNumber;
							ppDunFiles = &pszDunFile;
							pszDunFile = (LPTSTR)GlobalAlloc(GPTR,sizeof(TCHAR)*(256));
							// BUGBUG: ignoring error condition
							Assert(pszDunFile);
							wNumber = 1;
							if (pszDunFile && pszPhoneNumber)
							{
								ShowWindow(m_hwnd,SW_HIDE);
								hr = ((PFNPHONEDISPLAY)fp)
									(m_dwPhoneBook,
									ppPhoneNumbers,
									ppDunFiles,
									&wNumber,
									&m_dwCountryID,
									&m_wState,
									m_bType,
									m_bMask,
									NULL,8);
								ShowWindow(m_hwnd,SW_SHOW);
								SetForegroundWindow(m_hwnd);
								if (hr == ERROR_SUCCESS)
								{

									m_pcRNA->RasDeleteEntry(NULL,m_pszConnectoid);

									// Make a new connectoid
									//

									hr = CreateEntryFromDUNFile(pszDunFile);
									if (hr != ERROR_SUCCESS)
									{
										MsgBox(IDS_INVALIDPN,MB_MYERROR);
										goto PhoneBookClick;
										break;
									}

									// Get the name of the connectoid
									//

									dwSize = sizeof(TCHAR)*RAS_MaxEntryName;
									hr = ReadSignUpReg((LPBYTE)m_pszConnectoid, &dwSize, REG_SZ, RASENTRYVALUENAME);
									if (hr != ERROR_SUCCESS)
									{
										MsgBox(IDS_CANTREADKEY,MB_MYERROR);
										break;
									}

									// Get the connectoid
									//

									hr = ICWGetRasEntry(&lpRasEntry, &dwRasEntrySize, &lpRasDevInfo, &dwRasDevInfoSize, m_pszConnectoid);
									// UNDONE: ERROR MESSAGE

									// Break up phone number
									//
									if (!BreakUpPhoneNumber(lpRasEntry, m_pszPhoneNumber))
									{
										MsgBox(IDS_INVALIDPN,MB_MYERROR);
										goto PhoneBookClick;
										break;
									}

									// Set Country ID
									//
									lpRasEntry->dwCountryID=m_dwCountryID;

									// Set connectoid with new phone number
									//

									hr = m_pcRNA->RasSetEntryProperties(NULL,m_pszConnectoid,
										(LPBYTE)lpRasEntry,dwRasEntrySize,
										(LPBYTE)lpRasDevInfo,dwRasDevInfoSize);
									// UNDONE: ERROR MESSAGE

									// Update display
									//

									hr = GetDisplayableNumber();
									if (hr != ERROR_SUCCESS)
									{
										bCheckDisplayable = FALSE;
										SetDlgItemText(hwnd,IDC_TEXTNUMBER,m_pszPhoneNumber);
                                        //
                                        // Now we can show the Dialing Properties Push Button again
                                        // MKarki (4/24/97)  - Fix for Bug#3511
                                        //
                                        EnableWindow (GetDlgItem (hwnd, IDC_CMDDIALPROP), TRUE);
                                        //
                                        // save the state of the Dialing Properties PushButton
                                        // MKarki (5/3/97) -  Fix for Bug#3393
                                        //
                                        bDlgPropEnabled = TRUE;

									} else {
										bCheckDisplayable = TRUE;
										SetDlgItemText(hwnd,IDC_TEXTNUMBER,m_pszDisplayable);
									}
									fUserEditedNumber = FALSE;
								}
							} else {
								MsgBox(IDS_OUTOFMEMORY,MB_MYERROR);
							}
							Assert(pszDunFile);
							GlobalFree(pszDunFile);
							pszDunFile = NULL;
						}
					}
				}
			}
			break;
		}
		break;
	default:
		lRes = FALSE;
		break;
	}
	return lRes;
}

// ############################################################################
HRESULT CDialingErrorDlg::FillModems()
{
	HRESULT hr = ERROR_SUCCESS;
	DWORD dwSize;
	DWORD idx;

	DWORD dwRasEntrySize = 0;
	DWORD dwRasDevInfoSize = 0;

	LPRASENTRY lpRasEntry=NULL;
	LPRASDEVINFO lpRasDevInfo=NULL;
	LRESULT lLast = 0;

	LPLINEDEVCAPS lpLineDevCaps = NULL;

	//
	// Get the connectoid
	//

	hr = ICWGetRasEntry(&lpRasEntry,&dwRasEntrySize, &lpRasDevInfo, &dwRasDevInfoSize, m_pszConnectoid);
	if (hr) goto FillModemExit;

	//
	// Get devices from RAS
	//

	m_lpRasDevInfo = (LPRASDEVINFO)GlobalAlloc(LPTR,sizeof(RASDEVINFO));
	if (!m_lpRasDevInfo)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto FillModemExit;
	}

	m_dwNumDev = 0;
	m_lpRasDevInfo->dwSize = sizeof(RASDEVINFO);
	dwSize = sizeof(RASDEVINFO);
	hr = m_pcRNA->RasEnumDevices(m_lpRasDevInfo,&dwSize,&m_dwNumDev);

	if (hr == ERROR_BUFFER_TOO_SMALL)
	{
		GlobalFree(m_lpRasDevInfo);

		// 3/20/97	jmazner	Olympus #1768
		m_lpRasDevInfo = NULL;

		m_lpRasDevInfo = (LPRASDEVINFO)GlobalAlloc(LPTR,dwSize);
		if (!m_lpRasDevInfo)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto FillModemExit;
		}

		m_lpRasDevInfo->dwSize = sizeof(RASDEVINFO);
		m_dwNumDev = 0;

		hr = m_pcRNA->RasEnumDevices(m_lpRasDevInfo,&dwSize,&m_dwNumDev);
	}

	if (hr)
		goto FillModemExit;

	for (idx=0;idx < m_dwNumDev;idx++)
	{
		//
		// Add string to combo box
		//

		//
		// ChrisK Olympus 4560 do not add VPN's to list of modems
		//
		if (0 != lstrcmpi(TEXT("VPN"),m_lpRasDevInfo[idx].szDeviceType))
		{
			lLast = SendDlgItemMessage(m_hwnd,IDC_CMBMODEMS,CB_ADDSTRING,0,(LPARAM)m_lpRasDevInfo[idx].szDeviceName);
			//
			// ChrisK Olympus 245 5/25/97
			// Save index of modem
			//
			SendDlgItemMessage(m_hwnd,IDC_CMBMODEMS,CB_SETITEMDATA,(WPARAM)lLast,(LPARAM)idx);
			if (lstrcmp(m_lpRasDevInfo[idx].szDeviceName,lpRasEntry->szDeviceName) == 0)
				SendDlgItemMessage(m_hwnd,IDC_CMBMODEMS,CB_SETCURSEL,(WPARAM)lLast,0);
		}
	}

	if (m_dwNumDev == 1)
		SendDlgItemMessage(m_hwnd,IDC_CMBMODEMS,CB_SETCURSEL,0,0);

FillModemExit:
	if (lpRasEntry) GlobalFree(lpRasEntry);
	lpRasEntry = NULL;
	if (lpRasDevInfo) GlobalFree(lpRasDevInfo);
	lpRasDevInfo = NULL;
	return hr;
}


// ############################################################################
// UNDONE: Collapse this function with the one in dialdlg.cpp
HRESULT CDialingErrorDlg::GetDisplayableNumber()
{
	HRESULT hr;
	LPRASENTRY lpRasEntry = NULL;
	LPRASDEVINFO lpRasDevInfo = NULL;
	LPLINETRANSLATEOUTPUT lpOutput1;
	LPLINETRANSLATEOUTPUT lpOutput2;
	HINSTANCE hRasDll = NULL;
	// Normandy 11745
	// FARPROC fp = NULL;

	DWORD dwRasEntrySize = 0;
	DWORD dwRasDevInfoSize = 0;

	Assert(VALID_INIT);

	// Format the phone number
	//

	lpOutput1 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(LPTR,sizeof(LINETRANSLATEOUTPUT));
	if (!lpOutput1)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}
	lpOutput1->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

	// Get phone number from connectoid
	//
	hr = ICWGetRasEntry(&lpRasEntry, &dwRasEntrySize, &lpRasDevInfo, &dwRasDevInfoSize, m_pszConnectoid);
	if (hr != ERROR_SUCCESS)
	{
		goto GetDisplayableNumberExit;
	}
	//
	// If this is a dial as is number, just get it from the structure
	//
	if (!(lpRasEntry->dwfOptions & RASEO_UseCountryAndAreaCodes))
	{
		if (m_pszDisplayable) GlobalFree(m_pszDisplayable);
		m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, sizeof(TCHAR)*(lstrlen(lpRasEntry->szLocalPhoneNumber)+1));
		if (!m_pszDisplayable)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}
		lstrcpy(m_pszPhoneNumber, lpRasEntry->szLocalPhoneNumber);
		lstrcpy(m_pszDisplayable, lpRasEntry->szLocalPhoneNumber);
	}
	else
	{
		//
		// If there is no area code, don't use parentheses
		//
		if (lpRasEntry->szAreaCode[0])
			wsprintf(m_pszPhoneNumber,TEXT("+%d (%s) %s\0"),lpRasEntry->dwCountryCode,lpRasEntry->szAreaCode,lpRasEntry->szLocalPhoneNumber);
 		else
			wsprintf(m_pszPhoneNumber,TEXT("+%lu %s\0"),lpRasEntry->dwCountryCode,
						lpRasEntry->szLocalPhoneNumber);

		
		// Turn the canonical form into the "displayable" form
		//

		hr = lineTranslateAddress(m_hLineApp,m_dwTapiDev,m_dwAPIVersion,m_pszPhoneNumber,
									0,LINETRANSLATEOPTION_CANCELCALLWAITING,lpOutput1);

		if (hr != ERROR_SUCCESS || (lpOutput1->dwNeededSize != lpOutput1->dwTotalSize))
		{
			lpOutput2 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(LPTR,lpOutput1->dwNeededSize);
			if (!lpOutput2)
			{
				hr = ERROR_NOT_ENOUGH_MEMORY;
				goto GetDisplayableNumberExit;
			}
			lpOutput2->dwTotalSize = lpOutput1->dwNeededSize;
			GlobalFree(lpOutput1);
			lpOutput1 = lpOutput2;
			lpOutput2 = NULL;
			hr = lineTranslateAddress(m_hLineApp,m_dwTapiDev,m_dwAPIVersion,m_pszPhoneNumber,
										0,LINETRANSLATEOPTION_CANCELCALLWAITING,lpOutput1);
		}

		if (hr != ERROR_SUCCESS)
		{
			goto GetDisplayableNumberExit;
		}

		StrDup(&m_pszDisplayable,(LPTSTR)&((LPBYTE)lpOutput1)[lpOutput1->dwDisplayableStringOffset]);
	}

GetDisplayableNumberExit:
	 if (lpRasEntry) GlobalFree(lpRasEntry);
	 lpRasEntry = NULL;
	 if (lpRasDevInfo) GlobalFree(lpRasDevInfo);
	 lpRasDevInfo = NULL;
	 if (lpOutput1) GlobalFree(lpOutput1);
	 lpOutput1 = NULL;

	return hr;
}
/**
// ############################################################################
HRESULT ShowDialErrDialog(HRESULT hrErr, LPTSTR pszConnectoid, HINSTANCE hInst, HWND hwnd)
{
	int iRC;
//	CDialErrDlg *pcDED = NULL;

	g_pcDialErr = (PDIALERR)GlobalAlloc(LPTR,sizeof(DIALERR));
	if (!g_pcDialErr)
	{
		MessageBox(hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
		iRC = ERROR_NOT_ENOUGH_MEMORY;
		goto ShowDialErrDialogExit;
	}
	
	g_pcDialErr->m_pszConnectoid = (LPTSTR)GlobalAlloc(LPTR,RAS_MaxEntryName);
	if (!g_pcDialErr->m_pszConnectoid)
	{
		iRC = ERROR_NOT_ENOUGH_MEMORY;
		goto ShowDialErrDialogExit;
	}
	lstrcpyn(g_pcDialErr->m_pszConnectoid,pszConnectoid,RAS_MaxEntryName);
	g_pcDialErr->m_hrError = hrErr;
	g_pcDialErr->m_hInst = hInst;

	iRC = DialogBoxParam(g_pcDialErr->m_hInst,MAKEINTRESOURCE(IDD_DIALERR),hwnd,DialErrDlgProc,(LPARAM)g_pcDialErr);

	lstrcpyn(pszConnectoid,g_pcDialErr->m_pszConnectoid,RAS_MaxEntryName);

ShowDialErrDialogExit:
	if (g_pcDialErr->m_lprasdevinfo) GlobalFree(g_pcDialErr->m_lprasdevinfo);
	if (g_pcDialErr) GlobalFree(g_pcDialErr);
	return iRC;
}
**/

/**
// ############################################################################
HRESULT CDialingErrorDlg::DialErrGetDisplayableNumber()
{
	DWORD dwNumDev;
	HRESULT hr;
	LPRASENTRY lpRasEntry;
	LPRASDEVINFO lpRasDevInfo;
	DWORD dwRasEntrySize;
	DWORD dwRasDevInfoSize;
	LPLINETRANSLATEOUTPUT lpOutput1;
	LPLINETRANSLATEOUTPUT lpOutput2;
	LPLINEEXTENSIONID lpExtensionID = NULL;
	HINSTANCE hRasDll = NULL;
	FARPROC fp = NULL;

	//RNAAPI * pcRNA;

	//  Initialize TAPIness
	//
	dwNumDev = 0;
	hr = lineInitialize(&g_pcDialErr->m_hLineApp,g_pcDialErr->m_hInst,LineCallback,NULL,&dwNumDev);

	if (hr != ERROR_SUCCESS)
		goto GetDisplayableNumberExit;

	if (g_pdevice->dwTapiDev == 0xFFFFFFFF)
	{
		// if (dwNumDev == 1)
			g_pdevice->dwTapiDev = 0;
		//else
		// UNDONE: Tell the user to select a modem
		// DO NOT EXIT UNTIL THEY PICK ONE
	}

	lpExtensionID = (LPLINEEXTENSIONID )GlobalAlloc(LPTR,sizeof(LINEEXTENSIONID));
	if (!lpExtensionID)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}

	hr = lineNegotiateAPIVersion(g_pcDialErr->m_hLineApp, g_pdevice->dwTapiDev, 0x00010004, 0x00010004,
		&g_pcDialErr->m_dwAPIVersion, lpExtensionID);

	// ditch it since we don't use it
	//
	if (lpExtensionID) GlobalFree(lpExtensionID);
	lpExtensionID = NULL;
	if (hr != ERROR_SUCCESS)
		goto GetDisplayableNumberExit;

	// Format the phone number
	//

	lpOutput1 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(LPTR,sizeof(LINETRANSLATEOUTPUT));
	if (!lpOutput1)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}
	lpOutput1->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

	// Get phone number from connectoid
	//

	lpRasEntry = (LPRASENTRY)GlobalAlloc(LPTR,sizeof(RASENTRY));
	if (!lpRasEntry)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}

	lpRasDevInfo = (LPRASDEVINFO)GlobalAlloc(LPTR,sizeof(RASDEVINFO));
	if (!lpRasDevInfo)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}
	dwRasEntrySize = sizeof(RASENTRY);
	dwRasDevInfoSize = sizeof(RASDEVINFO);

	lpRasEntry->dwSize = dwRasEntrySize;
	lpRasDevInfo->dwSize = dwRasDevInfoSize;

	hRasDll = LoadLibrary(TEXT("RASAPI32.DLL"));
	if (!hRasDll)
	{
		hr = GetLastError();
		goto GetDisplayableNumberExit;
	}
	fp =GetProcAddress(hRasDll,"RasGetEntryPropertiesA");
	if (!fp)
	{
		FreeLibrary(hRasDll);
		hRasDll = LoadLibrary(TEXT("RNAPH.DLL"));
		if (!hRasDll)
		{
			hr = GetLastError();
			goto GetDisplayableNumberExit;
		}
		fp = GetProcAddress(hRasDll,"RasGetEntryPropertiesA");
		if (!fp)
		{
			hr = GetLastError();
			goto GetDisplayableNumberExit;
		}
	}

	hr = ((PFNRASGETENTRYPROPERTIES)fp)(NULL,g_pcDialErr->m_pszConnectoid,(LPBYTE)lpRasEntry,&dwRasEntrySize,(LPBYTE)lpRasDevInfo,&dwRasDevInfoSize);
	if (hr != ERROR_SUCCESS)
	{
		goto GetDisplayableNumberExit;
	}

	FreeLibrary(hRasDll);

	wsprintf(g_pcDialErr->m_szPhoneNumber,TEXT("+%d (%s) %s\0"),lpRasEntry->dwCountryCode,lpRasEntry->szAreaCode,lpRasEntry->szLocalPhoneNumber);
	
	// Turn the canonical form into the "displayable" form
	//

	hr = lineTranslateAddress(g_pcDialErr->m_hLineApp,g_pdevice->dwTapiDev,
								g_pcDialErr->m_dwAPIVersion,
								g_pcDialErr->m_szPhoneNumber,0,
								LINETRANSLATEOPTION_CANCELCALLWAITING,
								lpOutput1);

	if (hr != ERROR_SUCCESS || (lpOutput1->dwNeededSize != lpOutput1->dwTotalSize))
	{
		lpOutput2 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(LPTR,lpOutput1->dwNeededSize);
		if (!lpOutput2)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}
		lpOutput2->dwTotalSize = lpOutput1->dwNeededSize;
		GlobalFree(lpOutput1);
		lpOutput1 = lpOutput2;
		lpOutput2 = NULL;
		hr = lineTranslateAddress(g_pcDialErr->m_hLineApp,g_pdevice->dwTapiDev,
									g_pcDialErr->m_dwAPIVersion,
									g_pcDialErr->m_szPhoneNumber,0,
									LINETRANSLATEOPTION_CANCELCALLWAITING,
									lpOutput1);
	}

	if (hr != ERROR_SUCCESS)
	{
		goto GetDisplayableNumberExit;
	}

	g_pcDialErr->m_pszDisplayable = (LPTSTR)GlobalAlloc(LPTR,lpOutput1->dwDisplayableStringSize+1);
	if (!g_pcDialErr->m_pszDisplayable)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}

	lstrcpyn(g_pcDialErr->m_pszDisplayable,(LPTSTR)&((LPBYTE)lpOutput1)[lpOutput1->dwDisplayableStringOffset],lpOutput1->dwDisplayableStringSize);

GetDisplayableNumberExit:
	if (g_pcDialErr->m_hLineApp)
	{
		lineShutdown(g_pcDialErr->m_hLineApp);
		g_pcDialErr->m_hLineApp = NULL;
	}

	return hr;
}
**/

//+----------------------------------------------------------------------------
//
//	Function:	CDialingErrorDlg::CreateDialAsIsConnectoid
//
//	Synopsis:	Using the string in the editable text box create a dia-as-is 
//				connectoid
//
//	Arguemnts:	lpszDialNumber string containing the to-be-dailed number
//
//	Returns:	Error value (ERROR_SUCCESS == success)
//
//	History:	8/29/96	Chrisk	Created
//
//-----------------------------------------------------------------------------
HRESULT CDialingErrorDlg::CreateDialAsIsConnectoid(LPCTSTR lpszDialNumber)
{
	HRESULT hr = ERROR_SUCCESS;
	LPRASENTRY lpRasEntry=NULL;
	LPRASDEVINFO lpRasDevInfo=NULL;
	RNAAPI *pcRNA = NULL;
	LPCTSTR p, p2;

	DWORD dwRasEntrySize = 0;
	DWORD dwRasDevInfoSize = 0;

	Assert(lpszDialNumber);

	// Check that the phone number only contains valid characters
	//

	//
	// 5/17/97 jmazner Olympus #137
	// check for DBCS characters
	//
#ifndef WIN16
	if( !IsSBCSString( lpszDialNumber) )
	{
		MsgBox(IDS_SBCSONLY,MB_MYERROR);
		SetFocus(GetDlgItem(m_hwnd,IDC_TEXTNUMBER));
		SendMessage(GetDlgItem(m_hwnd, IDC_TEXTNUMBER),
						EM_SETSEL,
						(WPARAM) 0,
						(LPARAM) -1);
		hr = ERROR_INVALID_PARAMETER;
		goto CreateDialAsIsConnectoidExit;

	}
#endif
	
	for (p = lpszDialNumber;*p;p++)
	{
		for(p2 = szValidPhoneCharacters;*p2;p2++)
		{
			if (*p == *p2)
				break; // p2 for loop
		}
		if (!*p2) break; // p for loop
	}

	if (*p)
	{
		MsgBox(IDS_INVALIDPHONE,MB_MYERROR);
		//
		// Set the focus back to the phone number field
		//
		SetFocus(GetDlgItem(m_hwnd,IDC_TEXTNUMBER));
		{
			hr = ERROR_INVALID_PARAMETER;
			goto CreateDialAsIsConnectoidExit;
		}
	}

	//hr = ICWGetRasEntry(&lpRasEntry,&lpRasDevInfo,m_pszConnectoid);
	hr = ICWGetRasEntry(&lpRasEntry, &dwRasEntrySize, &lpRasDevInfo, &dwRasDevInfoSize, m_pszConnectoid);

	if (ERROR_SUCCESS != hr)
		goto CreateDialAsIsConnectoidExit;

	// Replace the phone number with the new one
	//
	lstrcpy(lpRasEntry->szLocalPhoneNumber, lpszDialNumber);

	//
	// This is dummy information and will not effect the dialed string
	// This information is required due to bugs in RAS apis.
	//
	lpRasEntry->dwCountryID = 1;
	lpRasEntry->dwCountryCode = 1;
	lpRasEntry->szAreaCode[0] = '8';
	lpRasEntry->szAreaCode[1] = '\0';

	// Set to dial as is
	//
	lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;

	if (!pcRNA) pcRNA = new RNAAPI;
	if (!pcRNA)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto CreateDialAsIsConnectoidExit;
	}


	// jmazner 10/10/96  Normandy #9066
	// Don't assume that sizeof lpRasEntry and lpRasDevInfo buffers is that of their
	// respective structs; RasGetEntryProperties sometimes needs these buffers to be
	// larger than just the struct!
//	hr = pcRNA->RasSetEntryProperties(NULL,m_pszConnectoid,(LPBYTE)lpRasEntry,
//		sizeof(RASENTRY),(LPBYTE)lpRasDevInfo,sizeof(RASDEVINFO));
	hr = pcRNA->RasSetEntryProperties(NULL,m_pszConnectoid,(LPBYTE)lpRasEntry,
		dwRasEntrySize,(LPBYTE)lpRasDevInfo,dwRasDevInfoSize);
	if (hr != ERROR_SUCCESS)
	{
		MsgBox(IDS_CANTSAVEKEY,MB_MYERROR);
		goto CreateDialAsIsConnectoidExit;
	}

CreateDialAsIsConnectoidExit:
	if (lpRasEntry)
		GlobalFree(lpRasEntry);
	lpRasEntry = NULL;
	if (lpRasDevInfo) 
		GlobalFree(lpRasDevInfo);
	lpRasDevInfo = NULL;
	if (pcRNA) 
		delete pcRNA;
	pcRNA = NULL;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdial\dialdlg.cpp ===
/*-----------------------------------------------------------------------------
    dialdlg.cpp

    Implement functionality of dialing and download progress dialog

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

    Authors:
        ChrisK        ChrisKauffman

    History:
        7/22/96        ChrisK    Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "icwdl.h"
#include "resource.h"
// the progress bar messages are defined in commctrl.h, but we can't include
// it, because it introduces a conflicting definition for strDup.
// so, just take out the one #define that we need
//#include <commctrl.h>
#define PBM_SETPOS              (WM_USER+2)

#define WM_DIAL WM_USER + 3
#define MAX_EXIT_RETRIES 10
#define MAX_RETIES 3

#define VALID_INIT (m_pcRNA && m_pcDLAPI)


// ############################################################################
void CALLBACK LineCallback(DWORD hDevice,
                           DWORD dwMessage,
                           DWORD dwInstance,
                           DWORD dwParam1,
                           DWORD dwParam2,
                           DWORD dwParam3)
{
}

//+----------------------------------------------------------------------------
//
//    Function: NeedZapper
//
//    Synopsis:    Checks to see if we need to handle the RNA connection dialog.
//                Only builds earlier than 1071 will have the RNA connection dialog
//
//    Arguments:    None
//
//    Returns:    True - the RNA dialog will have to be handled
//
//    History:    ArulM    Created        7/18/96
//                ChrisK    Installed into autodialer    7/19/96
//
//-----------------------------------------------------------------------------
static BOOL NeedZapper(void)
{
    OSVERSIONINFO oi;
    memset(&oi, 0, sizeof(oi));
    oi.dwOSVersionInfoSize = sizeof(oi);

    if( GetVersionEx(&oi) && 
       (oi.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS) &&
       (oi.dwMajorVersion==4) &&
       (oi.dwMinorVersion==0) &&
       (LOWORD(oi.dwBuildNumber) <= 1070) )
            return TRUE;
    else
            return FALSE;
}

// ############################################################################
VOID WINAPI ProgressCallBack(
    HINTERNET hInternet,
    DWORD_PTR dwContext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
    )
{
    if (dwContext)
        ((CDialingDlg*)dwContext)->ProgressCallBack(hInternet,dwContext,dwInternetStatus,
                                                    lpvStatusInformation,
                                                    dwStatusInformationLength);
}

// ############################################################################
HRESULT WINAPI DialingDownloadDialog(PDIALDLGDATA pDD)
{
    HRESULT hr = ERROR_SUCCESS;
    CDialingDlg *pcDialDlg;
    LPLINEEXTENSIONID lpExtensionID=NULL;

    // Validate parameters
    //
    Assert(pDD);

    if (!pDD)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto DialingDownloadDialogExit;
    }

    if (pDD->dwSize < sizeof(DIALDLGDATA))
    {
        hr = ERROR_BUFFER_TOO_SMALL;
        goto DialingDownloadDialogExit;
    }

    // Alloc and fill dialog object
    //

    pcDialDlg = new CDialingDlg;
    if (!pcDialDlg)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto DialingDownloadDialogExit;
    }

    if (ERROR_SUCCESS != (hr = pcDialDlg->Init()))
        goto DialingDownloadDialogExit;

    StrDup(&pcDialDlg->m_pszConnectoid,pDD->pszRasEntryName);
    StrDup(&pcDialDlg->m_pszMessage,pDD->pszMessage);
    StrDup(&pcDialDlg->m_pszUrl,pDD->pszMultipartMIMEUrl);
    StrDup(&pcDialDlg->m_pszDunFile,pDD->pszDunFile);
    pcDialDlg->m_pfnStatusCallback = pDD->pfnStatusCallback;
    pcDialDlg->m_hInst = pDD->hInst;
    pcDialDlg->m_bSkipDial = pDD->bSkipDial;

    // Initialize TAPI
    //
    hr = lineInitialize(&pcDialDlg->m_hLineApp,pcDialDlg->m_hInst,LineCallback,NULL,&pcDialDlg->m_dwNumDev);
    if (hr != ERROR_SUCCESS)
        goto DialingDownloadDialogExit;

    AssertMsg(pcDialDlg->m_dwTapiDev < pcDialDlg->m_dwNumDev,"The user has selected an invalid TAPI device.\n");

    lpExtensionID = (LPLINEEXTENSIONID)GlobalAlloc(GPTR,sizeof(LINEEXTENSIONID));
    if (!lpExtensionID)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto DialingDownloadDialogExit;
    }

    hr = lineNegotiateAPIVersion(pcDialDlg->m_hLineApp, pcDialDlg->m_dwTapiDev, 
        0x00010004, 0x00010004,&pcDialDlg->m_dwAPIVersion, lpExtensionID);

    // 4/2/97    ChrisK    Olympus 2745
    while (ERROR_SUCCESS != hr && pcDialDlg->m_dwTapiDev < (pcDialDlg->m_dwNumDev - 1))
    {
        pcDialDlg->m_dwTapiDev++;
        hr = lineNegotiateAPIVersion(pcDialDlg->m_hLineApp, pcDialDlg->m_dwTapiDev, 
            0x00010004, 0x00010004,&pcDialDlg->m_dwAPIVersion, lpExtensionID);
    }

    // Delete the extenstion ID since we don't use it, but keep the version information.
    //
    if (lpExtensionID) GlobalFree(lpExtensionID);
    if (hr != ERROR_SUCCESS)
        goto DialingDownloadDialogExit;

    // Call back filter for reconnect
    pcDialDlg->m_pfnRasDialFunc1 = pDD->pfnRasDialFunc1;

    // Display dialog
    //
    hr = (HRESULT)DialogBoxParam(GetModuleHandle(TEXT("ICWDIAL")),MAKEINTRESOURCE(IDD_DIALING),
        pDD->hParentHwnd,GenericDlgProc,(LPARAM)pcDialDlg);

    if (pDD->phRasConn)
        *(pDD->phRasConn) = pcDialDlg->m_hrasconn;

// 4/2/97    ChrisK    Olympus 296
// This is now handled inside the dialog
//#if !defined(WIN16)
//    if ((ERROR_USERNEXT == hr) && NeedZapper())
//        MinimizeRNAWindow(pDD->pszRasEntryName,GetModuleHandle("ICWDIAL"));
//#endif

// BUGBUG: on an error wait for the connection to die

DialingDownloadDialogExit:
    // Close tapi line
    //
    if (NULL != pcDialDlg)
    {
        // 4/2/97    ChrisK    Olympus 296
        if (pcDialDlg->m_hLineApp)
        {
            lineShutdown(pcDialDlg->m_hLineApp);    
            pcDialDlg->m_hLineApp = NULL;
        }
        //
        // ChrisK 296 6/3/97
        // Broaden window
        //
        // StopRNAReestablishZapper(g_hRNAZapperThread);
    }

    //
    // 5/23/97 jmazner Olympus #4652
    //
    delete(pcDialDlg);
    
    return hr;
}

// ############################################################################
CDialingDlg::CDialingDlg()
{
    m_hrasconn = NULL;
    m_pszConnectoid = NULL;
    m_hThread = NULL;
    m_dwThreadID = 0;
    m_hwnd = NULL;
    m_pszUrl = NULL;
    m_pszDisplayable = NULL;
    m_dwDownLoad = 0;
    m_pszPhoneNumber = NULL;
    m_pszMessage = NULL;
    m_pfnStatusCallback = NULL;
    m_unRasEvent = 0;
    m_pszDunFile = NULL;
    m_hLineApp = NULL;
    m_dwNumDev = 0;
    m_dwTapiDev = 0;
    m_dwAPIVersion = 0;
    m_pcRNA = NULL;
//    m_hDownLoadDll = NULL;
    m_bProgressShowing = FALSE;
    m_dwLastStatus = 0;
    m_pcDLAPI = NULL;
    m_bSkipDial = FALSE;

    // Normandy 11919 - ChrisK
    // Do not prompt to exit on dialing dialog since we don't exit the app from
    // here
    m_bShouldAsk = FALSE;

    //
    // ChrisK 5240 Olympus
    // Only the thread that creates the dwDownload should invalidate it
    // so we need another method to track if the cancel button has been
    // pressed.
    //
    m_fDownloadHasBeenCanceled = FALSE;
}

// ############################################################################
HRESULT CDialingDlg::Init()
{
    HRESULT hr = ERROR_SUCCESS;
    m_pcRNA = new RNAAPI;
    if (!m_pcRNA)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto InitExit;
    }

    m_pcDLAPI = new CDownLoadAPI;
    if (!m_pcDLAPI)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto InitExit;
    }

    m_pszPhoneNumber = (LPTSTR)GlobalAlloc(GPTR,sizeof(TCHAR)*256);
    if (!m_pszPhoneNumber)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto InitExit;
    }

InitExit:
    return hr;
}

// ############################################################################
CDialingDlg::~CDialingDlg()
{
    TraceMsg(TF_GENERAL, "ICWDIAL: CDialingDlg::~CDialingDlg");
    //
    // 5/25/97 ChrisK I know this will leak the connection but that's ok
    // since we sweep this up later and in the meantime we need to close
    // out the object
    //
    //if (m_hrasconn && m_pcRNA)
    //{
    //    m_pcRNA->RasHangUp(m_hrasconn);
    //}
    //m_hrasconn = NULL;

    if (m_pszConnectoid) GlobalFree(m_pszConnectoid);
    m_pszConnectoid = NULL;


    if (m_pszUrl) GlobalFree(m_pszUrl);
    m_pszUrl = NULL;

    if (m_pszDisplayable) GlobalFree(m_pszDisplayable);
    m_pszDisplayable = NULL;

    //
    // ChrisK 5240 Olympus
    // Only the thread that creates the dwDownload should invalidate it
    // so we need another method to track if the cancel button has been
    // pressed.
    //

    //
    // ChrisK 6/24/97    Olympus 6373
    // We have to call DownLoadClose even if the download was canceled because
    // we have to release the semaphores
    //
    if (m_dwDownLoad && m_pcDLAPI)
    {
        m_pcDLAPI->DownLoadClose(m_dwDownLoad);
        m_fDownloadHasBeenCanceled = TRUE;
    }
    m_dwDownLoad = 0;

    if (m_hThread)
    {
        //
        // 5/23/97    jmazner    Olympus #4652
        //
        // we want to make sure the thread is killed before
        // we delete the m_pcDLApi that it relies on.
        //
        WaitForSingleObject(m_hThread, INFINITE);
        CloseHandle(m_hThread);
    }
    m_hThread = NULL;

    m_dwThreadID = 0;
    m_hwnd = NULL;


    if (m_pszPhoneNumber) GlobalFree(m_pszPhoneNumber);
    m_pszPhoneNumber = NULL;

    if (m_pszMessage) GlobalFree(m_pszMessage);
    m_pszMessage = NULL;

    m_pfnStatusCallback=NULL;

    if (m_pszDunFile) GlobalFree(m_pszDunFile);
    m_pszDunFile = NULL;

    if (m_hLineApp) lineShutdown(m_hLineApp);
    m_hLineApp = NULL;

    m_dwNumDev = 0;
    m_dwTapiDev = 0;
    m_dwAPIVersion = 0;

    if (m_pcRNA) delete m_pcRNA;
    m_pcRNA = NULL;

    m_bProgressShowing = FALSE;
    m_dwLastStatus = 0;

    if (m_pcDLAPI) delete m_pcDLAPI;
    m_pcDLAPI = NULL;

    //
    // 4/2/97    ChrisK    Olympus 296
    //
    StopRNAReestablishZapper(g_hRNAZapperThread);
    
}

// ############################################################################
LRESULT CDialingDlg::DlgProc(HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam, LRESULT lres)
{
    HRESULT hr;
    // Normandy 11745
    // WORD wIDS;
    FARPROC fp;
    DWORD dwThreadResults;
    INT iRetries;
    static bDisconnect;

    Assert(VALID_INIT);

    switch(uMsg)
    {
    case WM_INITDIALOG:

        //
        // Register with caller's filter
        //
        if (m_pfnRasDialFunc1)
            (m_pfnRasDialFunc1)(NULL,WM_RegisterHWND,RASCS_OpenPort,HandleToUlong(hwnd),0);

        m_hwnd = hwnd;

        m_bProgressShowing = FALSE;

        ShowWindow(GetDlgItem(m_hwnd,IDC_PROGRESS),SW_HIDE);

        m_unRasEvent = RegisterWindowMessageA(RASDIALEVENT);
        if (m_unRasEvent == 0) m_unRasEvent = WM_RASDIALEVENT;

        // Bug Normandy 5920
        // ChrisK, turns out we are calling MakeBold twice
        // MakeBold(GetDlgItem(m_hwnd,IDC_LBLTITLE),TRUE,FW_BOLD);

        IF_NTONLY
            bDisconnect = FALSE;
        ENDIF_NTONLY

        //
        // Show number to be dialed
        //
        
        if (m_bSkipDial)
        {
            PostMessage(m_hwnd,m_unRasEvent,RASCS_Connected,SUCCESS);
        }
        else
        {
            hr = GetDisplayableNumberDialDlg();
            if (hr != ERROR_SUCCESS)
            {
                SetDlgItemText(m_hwnd,IDC_LBLNUMBER,m_pszPhoneNumber);
            } else {
                SetDlgItemText(m_hwnd,IDC_LBLNUMBER,m_pszDisplayable);
            }

            PostMessage(m_hwnd,WM_DIAL,0,0);
        }
        lres = TRUE;
        break;
    case WM_DIAL:
        SetForegroundWindow(m_hwnd);
        hr = DialDlg();

        if (hr != ERROR_SUCCESS)
            EndDialog(m_hwnd,hr);
        lres = TRUE;
        break;
    case WM_COMMAND:
        switch(LOWORD(wparam))
        {
        case IDC_CMDCANCEL:
            //
            // Tell the user what we are doing, since it may take awhile
            //
            SetDlgItemText(m_hwnd,IDC_LBLSTATUS,GetSz(IDS_RAS_HANGINGUP));

            //
            // Cancel download first, HangUp second....
            //

            //
            // ChrisK 5240 Olympus
            // Only the thread that creates the dwDownload should invalidate it
            // so we need another method to track if the cancel button has been
            // pressed.
            //
            if (m_dwDownLoad && m_pcDLAPI && !m_fDownloadHasBeenCanceled)
            {
                m_pcDLAPI->DownLoadCancel(m_dwDownLoad);
                m_fDownloadHasBeenCanceled = TRUE;
            }

            if (m_pcRNA && m_hrasconn)
            {
                m_pcRNA->RasHangUp(m_hrasconn);
            }
            PostMessage(m_hwnd,m_unRasEvent,(WPARAM)RASCS_Disconnected,(LPARAM)ERROR_USER_DISCONNECTION);
            lres = TRUE;
            break;
        }
        break;
    case WM_CLOSE:
        // CANCEL First, HangUp second....
        //

        //
        // ChrisK 5240 Olympus
        // Only the thread that creates the dwDownload should invalidate it
        // so we need another method to track if the cancel button has been
        // pressed.
        //
        if (m_dwDownLoad && m_pcDLAPI && !m_fDownloadHasBeenCanceled)
        {
            m_pcDLAPI->DownLoadCancel(m_dwDownLoad);
            m_fDownloadHasBeenCanceled = TRUE;
        }

        if (m_pcRNA && m_hrasconn)
        {
            m_pcRNA->RasHangUp(m_hrasconn);
        }
        EndDialog(hwnd,ERROR_USERCANCEL);
        m_hwnd = NULL;

        lres = TRUE;
        break;
    case WM_DOWNLOAD_DONE:
        dwThreadResults = STILL_ACTIVE;
        iRetries = 0;
        if (m_pcRNA && m_hrasconn)
        {
            m_pcRNA->RasHangUp(m_hrasconn);
            m_hrasconn = NULL;
        }

        do {
            if (!GetExitCodeThread(m_hThread,&dwThreadResults))
            {
                AssertMsg(0,"CONNECT:GetExitCodeThread failed.\n");
            }

            iRetries++;
            if (dwThreadResults == STILL_ACTIVE) Sleep(500);
        } while (dwThreadResults == STILL_ACTIVE && iRetries < MAX_EXIT_RETRIES);

        if (dwThreadResults == ERROR_SUCCESS)
            EndDialog(hwnd,ERROR_USERNEXT);
        else
            EndDialog(hwnd,dwThreadResults);
        lres = TRUE;
        break;
    default:
        if (uMsg == m_unRasEvent)
        {
            TCHAR szRasError[10];
            TCHAR szRasMessage[256];
            wsprintf(szRasError,TEXT("%d %d"),wparam,lparam);
            RegSetValue(HKEY_LOCAL_MACHINE,TEXT("Software\\Microsoft\\iSignUp"),REG_SZ,
                szRasError,lstrlen(szRasError));

            TraceMsg(TF_GENERAL, "AUTODIAL: Ras message %d error (%d).\n",wparam,lparam);
            hr = m_pfnStatusCallback((DWORD)wparam, szRasMessage, 256);

            if (!hr)
                SetDlgItemText(m_hwnd,IDC_LBLSTATUS,szRasMessage);

            switch(wparam)
            {
            case RASCS_Connected:

#if !defined(WIN16)
                // 4/2/97    ChrisK    Olympus 296

                //
                // ChrisK Olympus 6060 6/10/97
                // If the URL is blank, then we don't need the zapper thread.
                //
                if (NeedZapper())
                {
                    HMODULE hMod;
                    hMod = GetModuleHandle(TEXT("ICWDIAL"));
                    MinimizeRNAWindow(m_pszConnectoid,hMod);
                    if (m_pszUrl && m_pszUrl[0])
                    {
                        g_hRNAZapperThread = LaunchRNAReestablishZapper(hMod);
                    }
                    hMod = NULL;
                }
#endif
                if (m_pszUrl)
                {
                    //
                    //  we should now let the user know that we 
                    //  are downloading
                    //  MKarki (5/5/97) - Fix for Bug#423
                    //
                    SetDlgItemText(m_hwnd,IDC_LBLSTATUS,GetSz (IDS_DOWNLOADING));

                    // The connection is open and ready.  Start the download.
                    //

                    m_dwThreadID = 0;
                    m_hThread = CreateThread(NULL,0,
                        (LPTHREAD_START_ROUTINE)DownloadThreadInit,this,0,&m_dwThreadID);
                    if (!m_hThread)
                    {
                        hr = GetLastError();

                        if (m_pcRNA && m_hrasconn)
                        {
                            m_pcRNA->RasHangUp(m_hrasconn);
                            m_hrasconn = NULL;
                        }

                        EndDialog(m_hwnd,hr);
                        break;
                    }
                } else {
                    EndDialog(m_hwnd,ERROR_USERNEXT);
                }
                break;

            case RASCS_Disconnected:
                IF_NTONLY
                    // There is a possibility that we will get multiple disconnects in NT
                    // and we only want to handle the first one. Note: the flag is reset
                    // in the INITIALIZE event, so we should handle 1 disconnect per instance
                    // of the dialog.
                    if (bDisconnect)
                        break;
                    else
                        bDisconnect = TRUE;
                ENDIF_NTONLY
                if (m_hrasconn && m_pcRNA) m_pcRNA->RasHangUp(m_hrasconn);
                m_hrasconn = NULL;
                EndDialog(m_hwnd,lparam);
                break;
            default:
                IF_NTONLY
                    if (SUCCESS != lparam)
                    {
                        PostMessage(m_hwnd,m_unRasEvent,(WPARAM)RASCS_Disconnected,lparam);
                    }
                ENDIF_NTONLY
            }
        }
    }

return lres;
}

// ############################################################################
HRESULT CDialingDlg::GetDisplayableNumberDialDlg()
{
    HRESULT hr;
    LPRASENTRY lpRasEntry = NULL;
    LPRASDEVINFO lpRasDevInfo = NULL;
    DWORD dwRasEntrySize = 0;
    DWORD dwRasDevInfoSize = 0;
    LPLINETRANSLATEOUTPUT lpOutput1 = NULL;
    LPLINETRANSLATEOUTPUT lpOutput2 = NULL;
    HINSTANCE hRasDll = NULL;
    FARPROC fp = NULL;

    Assert(VALID_INIT);

    // Format the phone number
    //

    lpOutput1 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(GPTR,sizeof(LINETRANSLATEOUTPUT));
    if (!lpOutput1)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto GetDisplayableNumberExit;
    }
    lpOutput1->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

    // Get phone number from connectoid
    //
    hr = ICWGetRasEntry(&lpRasEntry, &dwRasEntrySize, &lpRasDevInfo, &dwRasDevInfoSize, m_pszConnectoid);
    if (hr != ERROR_SUCCESS)
        goto GetDisplayableNumberExit;

    //
    // If this is a dial as is number, just get it from the structure
    //
    if (!(lpRasEntry->dwfOptions & RASEO_UseCountryAndAreaCodes))
    {
        if (m_pszDisplayable) GlobalFree(m_pszDisplayable);
        m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, sizeof(TCHAR)*(lstrlen(lpRasEntry->szLocalPhoneNumber)+1));
        if (!m_pszDisplayable)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto GetDisplayableNumberExit;
        }
        lstrcpy(m_pszPhoneNumber, lpRasEntry->szLocalPhoneNumber);
        lstrcpy(m_pszDisplayable, lpRasEntry->szLocalPhoneNumber);
    }
    else
    {
        //
        // If there is no area code, don't use parentheses
        //
        if (lpRasEntry->szAreaCode[0])
                wsprintf(m_pszPhoneNumber,TEXT("+%d (%s) %s\0"),lpRasEntry->dwCountryCode,lpRasEntry->szAreaCode,lpRasEntry->szLocalPhoneNumber);
         else
            wsprintf(m_pszPhoneNumber,TEXT("+%lu %s\0"),lpRasEntry->dwCountryCode,
                        lpRasEntry->szLocalPhoneNumber);

    
        // Turn the canonical form into the "displayable" form
        //

        hr = lineTranslateAddress(m_hLineApp,m_dwTapiDev,m_dwAPIVersion,m_pszPhoneNumber,
                                    0,LINETRANSLATEOPTION_CANCELCALLWAITING,lpOutput1);

        if (hr != ERROR_SUCCESS || (lpOutput1->dwNeededSize != lpOutput1->dwTotalSize))
        {
            lpOutput2 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(GPTR,lpOutput1->dwNeededSize);
            if (!lpOutput2)
            {
                hr = ERROR_NOT_ENOUGH_MEMORY;
                goto GetDisplayableNumberExit;
            }
            lpOutput2->dwTotalSize = lpOutput1->dwNeededSize;
            GlobalFree(lpOutput1);
            lpOutput1 = lpOutput2;
            lpOutput2 = NULL;
            hr = lineTranslateAddress(m_hLineApp,m_dwTapiDev,m_dwAPIVersion,m_pszPhoneNumber,
                                        0,LINETRANSLATEOPTION_CANCELCALLWAITING,lpOutput1);
        }

        if (hr != ERROR_SUCCESS)
        {
            goto GetDisplayableNumberExit;
        }

        StrDup(&m_pszDisplayable,(LPTSTR)&((LPBYTE)lpOutput1)[lpOutput1->dwDisplayableStringOffset]);
     }

GetDisplayableNumberExit:
     if (lpRasEntry) GlobalFree(lpRasEntry);
     lpRasEntry = NULL;
     if (lpRasDevInfo) GlobalFree(lpRasDevInfo);
     lpRasDevInfo = NULL;
     if (lpOutput1) GlobalFree(lpOutput1);
     lpOutput1 = NULL;

    return hr;
}

// ############################################################################
HRESULT CDialingDlg::DialDlg()
{
    TCHAR szPassword[PWLEN+2];
    LPRASDIALPARAMS lpRasDialParams = NULL;
    HRESULT hr = ERROR_SUCCESS;
    BOOL bPW;

    Assert(VALID_INIT);

    // Get connectoid information
    //

    lpRasDialParams = (LPRASDIALPARAMS)GlobalAlloc(GPTR,sizeof(RASDIALPARAMS));
    if (!lpRasDialParams)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto DialExit;
    }
    lpRasDialParams->dwSize = sizeof(RASDIALPARAMS);
    lstrcpyn(lpRasDialParams->szEntryName,m_pszConnectoid,RAS_MaxEntryName);
    bPW = FALSE;

    hr = m_pcRNA->RasGetEntryDialParams(NULL,lpRasDialParams,&bPW);
    if (hr != ERROR_SUCCESS)
    {
        goto DialExit;
    }

    // Add the user's password
    //
    szPassword[0] = 0;
    if (GetISPFile() != NULL && *(GetISPFile()) != TEXT('\0'))
    {
        // GetPrivateProfileString examines one character before the filename
        // if it is an empty string, which could result in AV, if the address 
        // refers to an invalid page.
        GetPrivateProfileString(
                    INFFILE_USER_SECTION,INFFILE_PASSWORD,
                    NULLSZ,szPassword,PWLEN + 1,GetISPFile());
    }

    // if didnt get password, then try to get from DUN file (if any)
    if(!szPassword[0] && m_pszDunFile)
    {
        // 4-29-97 Chrisk Olympus 3985
        // Due to the wrong filename being used, the password was always being set to
        // NULL and therefore requiring the user to provide the password to log onto the 
        // signup server.
        GetPrivateProfileString(
                    INFFILE_USER_SECTION,INFFILE_PASSWORD,
                    NULLSZ,szPassword,PWLEN + 1,m_pszDunFile);
                    //NULLSZ,szPassword,PWLEN + 1,g_szCurrentDUNFile);
    }

    if(szPassword[0])
    {
        lstrcpyn(lpRasDialParams->szPassword, szPassword,PWLEN+1);
        TraceMsg(TF_GENERAL, "ICWDIAL: Password is not blank.\r\n");
    }
    else
    {
        TraceMsg(TF_GENERAL, "ICWDIAL: Password is blank.\r\n");
    }
    

    // Dial connectoid
    //

    Assert(!m_hrasconn);

#if !defined(WIN16) && defined(DEBUG)
    if (FCampusNetOverride())
    {
        //
        // Skip dialing because the server is on the campus network
        //
        PostMessage(m_hwnd,RegisterWindowMessageA(RASDIALEVENT),RASCS_Connected,0);
    }
    else
    {
#endif // !WIN16 && DEBUG

    if (m_pfnRasDialFunc1)
        hr = m_pcRNA->RasDial(NULL,NULL,lpRasDialParams,1,m_pfnRasDialFunc1,&m_hrasconn);
    else
        hr = m_pcRNA->RasDial(NULL,NULL,lpRasDialParams,0xFFFFFFFF,m_hwnd,&m_hrasconn);

    if (hr != ERROR_SUCCESS)
    {
        if (m_hrasconn && m_pcRNA)
        {
            m_pcRNA->RasHangUp(m_hrasconn);
            m_hrasconn = NULL;
        }
        goto DialExit;
    }

#if !defined(WIN16) && defined(DEBUG)
    }
#endif

    if (lpRasDialParams) GlobalFree(lpRasDialParams);
    lpRasDialParams = NULL;

DialExit:
    return hr;
}

// ############################################################################
VOID CDialingDlg::ProgressCallBack(
    HINTERNET hInternet,
    DWORD_PTR dwContext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
    )
{
    TCHAR szRasMessage[256];
    HRESULT hr = ERROR_SUCCESS;
    WPARAM *puiStatusInfo = NULL;

    //
    // 5/28/97 jmazner Olympus #4579
    // *lpvStatusInformation is the percentage of completed download,
    // as a value from 0 to 100.
    //
    puiStatusInfo = (WPARAM *) lpvStatusInformation;
    Assert(    puiStatusInfo );
    Assert( *puiStatusInfo <= 100 );

    Assert(VALID_INIT);

    if (!m_bProgressShowing) 
        ShowWindow(GetDlgItem(m_hwnd,IDC_PROGRESS),SW_SHOW);

    if (m_dwLastStatus != dwInternetStatus)
    {
        hr = m_pfnStatusCallback(dwInternetStatus,szRasMessage,256);
        if (!hr)
            SetDlgItemText(m_hwnd,IDC_LBLSTATUS,szRasMessage);
        m_dwLastStatus = dwInternetStatus;
        TraceMsg(TF_GENERAL, "CONNECT:inet status:%s, %d, %d.\n",szRasMessage,m_dwLastStatus,dwInternetStatus);
    }

    //
    // 5/28/97 jmazner Olympus #4579
    // Send update messages to the progress bar
    //

    PostMessage(GetDlgItem(m_hwnd,IDC_PROGRESS), PBM_SETPOS, *puiStatusInfo, 0);

    m_bProgressShowing = TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdial\dialutil.cpp ===
/*-----------------------------------------------------------------------------
    dialutil.cpp

    Miscellenous housekeeping functions for autodial handler

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

    Authors:
        ChrisK        ChrisKauffman

    History:
        7/22/96        ChrisK    Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include <raserror.h>
#include <tapi.h>
#include "dialutil.h"
#include "resource.h"

#define CANONICAL_CAP      TEXT("+%d (%s) %s")
#define CANONICAL_CXP      TEXT("+%d %s")

#define TAPI_VERSION        0x00010004

#define SMALLBUFLEN 80
#define ASSERT(c)
#define TRACE_OUT(c)

#define lstrnicmp(sz1, sz2, cch)          (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE, sz1, cch, sz2, cch) - 2)
#define lstrncmp(sz1, sz2, cch)           (CompareString(LOCALE_USER_DEFAULT, 0, sz1, cch, sz2, cch) - 2)

typedef DWORD (WINAPI * RASGETENTRYPROPERTIES)
        (LPTSTR lpszPhonebook, LPTSTR szEntry, LPBYTE lpbEntry,
        LPDWORD lpdwEntrySize, LPBYTE lpb, LPDWORD lpdwSize);
typedef DWORD (WINAPI * RASSETENTRYPROPERTIES)
        (LPTSTR lpszPhonebook, LPTSTR szEntry, LPBYTE lpbEntry,
        DWORD dwEntrySize, LPBYTE lpb, DWORD dwSize);

extern HINSTANCE g_hInstance;

static const HWND hwndNil = NULL;

static const TCHAR szRnaAppWindowClass[] = TEXT("#32770");    // hard coded dialog class name

static const CHAR szRasGetEntryProperties[] = "RasGetEntryProperties";
static const CHAR szRasSetEntryProperties[] = "RasSetEntryProperties";
static const TCHAR szRasDll[] = TEXT("rasapi32.dll");
static const TCHAR szRnaPhDll[] = TEXT("rnaph.dll");


void CALLBACK LineCallbackProc (DWORD handle, DWORD dwMsg, DWORD dwInst,
                                DWORD dwParam1, DWORD dwParam2, DWORD dwParam3);

//
// defined in dialerr.cpp
//
void ProcessDBCS(HWND hDlg, int ctlID);


/*  C E N T E R  W I N D O W */
/*-------------------------------------------------------------------------
    %%Function: CenterWindow

    Center a window over another window.
-------------------------------------------------------------------------*/
VOID CenterWindow(HWND hwndChild, HWND hwndParent)
{
    int   xNew, yNew;
    int   cxChild, cyChild;
    int   cxParent, cyParent;
    int   cxScreen, cyScreen;
    RECT  rcChild, rcParent;
    HDC   hdc;

    // Get the Height and Width of the child window
    GetWindowRect(hwndChild, &rcChild);
    cxChild = rcChild.right - rcChild.left;
    cyChild = rcChild.bottom - rcChild.top;

    // Get the Height and Width of the parent window
    GetWindowRect(hwndParent, &rcParent);
    cxParent = rcParent.right - rcParent.left;
    cyParent = rcParent.bottom - rcParent.top;

    // Get the display limits
    hdc = GetDC(hwndChild);
    if (hdc == NULL) {
        // major problems - move window to 0,0
        xNew = yNew = 0;
    } else {
        cxScreen = GetDeviceCaps(hdc, HORZRES);
        cyScreen = GetDeviceCaps(hdc, VERTRES);
        ReleaseDC(hwndChild, hdc);

        if (hwndParent == hwndNil) {
            cxParent = cxScreen;
            cyParent = cyScreen;
            SetRect(&rcParent, 0, 0, cxScreen, cyScreen);
        }

        // Calculate new X position, then adjust for screen
        xNew = rcParent.left + ((cxParent - cxChild) / 2);
        if (xNew < 0) {
            xNew = 0;
        } else if ((xNew + cxChild) > cxScreen) {
            xNew = cxScreen - cxChild;
        }

        // Calculate new Y position, then adjust for screen
        yNew = rcParent.top  + ((cyParent - cyChild) / 2);
        if (yNew < 0) {
            yNew = 0;
        } else if ((yNew + cyChild) > cyScreen) {
            yNew = cyScreen - cyChild;
        }

    }

    SetWindowPos(hwndChild, NULL, xNew, yNew,    0, 0,
        SWP_NOSIZE | SWP_NOZORDER);
}

static HWND hwndFound = NULL;

static BOOL CALLBACK MyEnumWindowsProc(HWND hwnd, LPARAM lparam)
{
    TCHAR szTemp[SMALLBUFLEN+2];
    PTSTR pszTitle;
    UINT uLen1, uLen2;

    if(!IsWindowVisible(hwnd))
        return TRUE;
    if(GetClassName(hwnd, szTemp, SMALLBUFLEN)==0)
        return TRUE; // continue enumerating
    if(lstrcmp(szTemp, szRnaAppWindowClass)!=0)
        return TRUE;
    if(GetWindowText(hwnd, szTemp, SMALLBUFLEN)==0)
        return TRUE;
    szTemp[SMALLBUFLEN] = 0;
    uLen1 = lstrlen(szTemp);
    if (uLen1 > 5)
        uLen1 -= 5; // skip last 5 chars of title (avoid "...")
    pszTitle = (PTSTR)lparam;
    ASSERT(pszTitle);
    uLen2 = lstrlen(pszTitle);
    TRACE_OUT(("Title=(%s), len=%d, Window=(%s), len=%d\r\n", pszTitle, uLen2, szTemp, uLen1));
    if(uLen2 < uLen1)
        return TRUE;
    if(lstrnicmp(pszTitle, szTemp, uLen1)!=0)
        return TRUE;
    hwndFound = hwnd;
    return FALSE;
}

static HWND MyFindRNAWindow(PTSTR pszTitle)
{
    DWORD dwRet;
    hwndFound = NULL;
    dwRet = EnumWindows((WNDENUMPROC)(&MyEnumWindowsProc), (LPARAM)pszTitle);
    TRACE_OUT(("EnumWindows returned %d\r\n", dwRet));
    return hwndFound;
}


/*******************************************************************

    NAME:        MinimizeRNAWindow

    SYNOPSIS:    Finds and minimizes the annoying RNA window

    ENTRY:        pszConnectoidName - name of connectoid launched

********************************************************************/
BOOL MinimizeRNAWindow(TCHAR * pszConnectoidName)
{
    HWND hwndRNAApp;
    TCHAR szFmt[SMALLBUFLEN + 1];
    TCHAR szTitle[RAS_MaxEntryName + SMALLBUFLEN + 1];
    
    // load the title format ("connected to <connectoid name>" from resource
    LoadString(g_hInstance, IDS_CONNECTED_TO, szFmt, SIZEOF_TCHAR_BUFFER(szFmt));
    // build the title
    wsprintf(szTitle, szFmt, pszConnectoidName);

    hwndRNAApp=MyFindRNAWindow(szTitle);
    if(hwndRNAApp)
    {
        // minimize the RNA window
        ShowWindow(hwndRNAApp,SW_MINIMIZE);
        return TRUE;
    }
    return FALSE;
}

//****************************************************************************
// static LPTSTR NEAR PASCAL GetDisplayPhone (LPTSTR)
//
// This function returns the pointer to displayable phone number. It stripped
//   all the prefixes we do not want to show to the user.
//
// History:
//  Tue 26-Jul-1994 16:07:00  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

LPTSTR NEAR PASCAL GetDisplayPhone (LPTSTR szPhoneNum)
{
  // Check whether the first string is the know prefix
  //
  if ((*szPhoneNum == 'T') || (*szPhoneNum == 'P'))
  {
    // It is the prefix
    //
    szPhoneNum++;

    // The first displayable number is not white space after prefix
    //
    while ((*szPhoneNum == ' ') || (*szPhoneNum == '\t'))
      szPhoneNum++;
  };
  return szPhoneNum;
}

void CALLBACK LineCallbackProc (DWORD handle, DWORD dwMsg, DWORD dwInst,
                                DWORD dwParam1, DWORD dwParam2, DWORD dwParam3)
{
}

//****************************************************************************
// TranslateCanonicalAddress()
//
// Function: This function translate a canonical address to a dialable address.
//
// Returns:  SUCCESS or an error code
//
//****************************************************************************

static DWORD NEAR PASCAL TranslateCanonicalAddress(DWORD dwID, LPTSTR szCanonical,
                                            LPTSTR szDialable, DWORD cb)
{
  LINETRANSLATEOUTPUT lto, FAR* lplto;
  DWORD dwRet;
  DWORD cDevices;
  HLINEAPP hApp;

  if ((dwRet = lineInitialize(&hApp, g_hInstance,
                                (LINECALLBACK)LineCallbackProc,
                                NULL, &cDevices)) == SUCCESS)
  {

    // Get the actual buffer size
    lto.dwTotalSize = sizeof(lto);
    if ((dwRet = lineTranslateAddress(hApp, dwID,
                                      TAPI_VERSION, szCanonical, 0,
                                      LINETRANSLATEOPTION_CANCELCALLWAITING,
                                      &lto)) == SUCCESS)
    {
      // Allocate the dialable number buffer
      if ((lplto = (LPLINETRANSLATEOUTPUT)GlobalAlloc(LMEM_FIXED, lto.dwNeededSize))
          != NULL)
      {
        // Translate the phone number
        lplto->dwTotalSize = lto.dwNeededSize;
        if ((dwRet = lineTranslateAddress(hApp, dwID,
                                          TAPI_VERSION, szCanonical, 0,
                                          LINETRANSLATEOPTION_CANCELCALLWAITING,
                                          lplto)) == SUCCESS)
        {
          LPTSTR szPhone;

          szPhone = (LPTSTR)(((LPBYTE)lplto)+lplto->dwDialableStringOffset);
          lstrcpyn(szDialable, szPhone, cb);
        }
        else
          dwRet = ERROR_TAPI_CONFIGURATION;


        GlobalFree((HLOCAL)lplto);
      }
      else
        dwRet = ERROR_OUTOFMEMORY;
    }
    else
      dwRet = ERROR_TAPI_CONFIGURATION;
  }
  else
    dwRet = ERROR_TAPI_CONFIGURATION;
      
  lineShutdown(hApp);

  return dwRet;
}

//****************************************************************************
// DWORD NEAR PASCAL BuildPhoneString (LPBYTE, LPPHONENUM)
//
// This function builds a phone number string from the phone number struct
//
// History:
//  Mon 14-Mar-1994 13:10:44  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

static DWORD NEAR PASCAL BuildPhoneString (LPTSTR szPhoneNum, LPRASENTRY lpRasEntry)
{
  if (*lpRasEntry->szAreaCode != '\0')
  {
    wsprintf(szPhoneNum, CANONICAL_CAP, lpRasEntry->dwCountryCode,
             lpRasEntry->szAreaCode, lpRasEntry->szLocalPhoneNumber);
  }
  else
  {
    wsprintf(szPhoneNum, CANONICAL_CXP, lpRasEntry->dwCountryCode,
             lpRasEntry->szLocalPhoneNumber);
  };
  return SUCCESS;
};

//****************************************************************************
// BOOL NEAR PASCAL TranslatePhoneNumber(LPTSTR, LPPHONENUM, LPTSTR)
//
// Translate phone number into a dialble string.
//
// Returns TRUE if successful, FALSE if use default.
//
// History:
//   Fri 17-Jun-1994 08:42:49  -by-  Viroon  Touranachun [viroont]
// Created
//****************************************************************************

static BOOL NEAR PASCAL TranslatePhoneNumber(LPRASENTRY lpRasEntry, LPTSTR szPhoneNumber)
{
  TCHAR    szOrgPhone[RAS_MaxPhoneNumber+1];

  // Do we need to use the addrees book phone number?
  //
  if (lpRasEntry != NULL)
  {
    // Yes! Do we need to translate anything?
    //
    if (lpRasEntry->dwCountryID == 0)
    {
      // No! we dial as is.
      //
      lstrcpyn(szOrgPhone, lpRasEntry->szLocalPhoneNumber, RAS_MaxPhoneNumber + 1);
    }
    else
    {
      // Yes! build the phone number
      //
      BuildPhoneString (szOrgPhone, lpRasEntry);
    };
  }
  else
  {
    // No! we have a overwritten phone number
    //
    ASSERT(lstrlen(szPhoneNumber) != 0);
    lstrcpyn(szOrgPhone, szPhoneNumber, RAS_MaxPhoneNumber+1);
  };

  // Attempt address translation
  //
  if (TranslateCanonicalAddress(0, szOrgPhone,
                            szPhoneNumber, RAS_MaxPhoneNumber+1)
  != ERROR_SUCCESS)
  {
    // Translation fails, use default phone number
    //
    if (lpRasEntry != NULL)
    {
      // Use entry's local phone number
      //
      lstrcpy(szPhoneNumber, lpRasEntry->szLocalPhoneNumber);
    }
    else
    {
      // Restore the original phone number
      //
      lstrcpy(szPhoneNumber, szOrgPhone);
    };
    return FALSE;
  };

  return TRUE;
}


DWORD GetPhoneNumber(LPTSTR lpszEntryName, LPTSTR lpszPhoneNumber)
{
    DWORD dwEntrySize = 0;
    DWORD dwSize = 0;
    DWORD dwRet;
    LPRASENTRY lpRasEntry = NULL;
    HINSTANCE hLib;
    RASGETENTRYPROPERTIES lpfnRasGetEntryProperties;

    // look for needed function in rasapi.dll
    hLib = LoadLibrary(szRasDll);
    if (NULL != hLib)
    {
        lpfnRasGetEntryProperties = (RASGETENTRYPROPERTIES)GetProcAddress(hLib, szRasGetEntryProperties);
        if (NULL != lpfnRasGetEntryProperties)
        {
            // we found the function
            goto get_entry;
        }
        FreeLibrary(hLib);
    }

    // try rnaph.dll if not on NT

    if (FALSE == IsNT ())
    {
        hLib = LoadLibrary(szRnaPhDll);
        if (NULL == hLib)
        {
            return ERROR_FILE_NOT_FOUND;
        }
        lpfnRasGetEntryProperties = (RASGETENTRYPROPERTIES)GetProcAddress(hLib, szRasGetEntryProperties);
        if (NULL == lpfnRasGetEntryProperties)
        {
            FreeLibrary(hLib);
            return ERROR_INVALID_FUNCTION;
        }
    }
    else
    {
            return ERROR_FILE_NOT_FOUND;
    }

get_entry:
    // get size needed for RASENTRY struct
    lpfnRasGetEntryProperties(
        NULL,
        lpszEntryName,
        NULL,
        &dwEntrySize,
        NULL,
        &dwSize);

    lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR, dwEntrySize + dwSize);

    if (NULL == lpRasEntry)
    {
        dwRet = ERROR_OUTOFMEMORY;
    }
    else
    {
        lpRasEntry->dwSize = dwEntrySize;

        dwRet = lpfnRasGetEntryProperties(
            NULL,
            lpszEntryName,
            (LPBYTE)lpRasEntry,
            &dwEntrySize,
            ((LPBYTE)lpRasEntry) + dwEntrySize,
            &dwSize);

        if (ERROR_SUCCESS == dwRet)
        {
            TranslatePhoneNumber(lpRasEntry, lpszPhoneNumber);
        }

        GlobalFree((HLOCAL)lpRasEntry);
    }

    FreeLibrary(hLib);

    return dwRet;
}

DWORD _RasGetStateString(RASCONNSTATE state, LPTSTR lpszState, DWORD cb)
{
    UINT idString;

    switch(state)
    {
        case RASCS_OpenPort:
            idString  = IDS_OPENPORT;
            break;
        case RASCS_PortOpened:
            idString = IDS_PORTOPENED;            
            break;
        case RASCS_ConnectDevice:
            idString = IDS_CONNECTDEVICE;        
            break;
        case RASCS_DeviceConnected:
            idString = IDS_DEVICECONNECTED;       
            break;
        case RASCS_AllDevicesConnected:
            idString = IDS_ALLDEVICESCONNECTED;   
            break;
        case RASCS_Authenticate:
            idString = IDS_AUTHENTICATE;          
            break;
        case RASCS_AuthNotify:
            idString = IDS_AUTHNOTIFY;            
            break;
        case RASCS_AuthRetry:
            idString = IDS_AUTHRETRY;             
            break;
        case RASCS_AuthCallback:
            idString = IDS_AUTHCALLBACK;          
            break;
        case RASCS_AuthChangePassword:
            idString = IDS_AUTHCHANGEPASSWORD;    
            break;
        case RASCS_AuthProject:
            idString = IDS_AUTHPROJECT;           
            break;
        case RASCS_AuthLinkSpeed:
            idString = IDS_AUTHLINKSPEED;         
            break;
        case RASCS_AuthAck: 
            idString = IDS_AUTHACK;               
            break;
        case RASCS_ReAuthenticate:
            idString = IDS_REAUTHENTICATE;        
            break;
        case RASCS_Authenticated:
            idString = IDS_AUTHENTICATED;         
            break;
        case RASCS_PrepareForCallback:
            idString = IDS_PREPAREFORCALLBACK;    
            break;
        case RASCS_WaitForModemReset:
            idString = IDS_WAITFORMODEMRESET;     
            break;
        case RASCS_WaitForCallback:
            idString = IDS_WAITFORCALLBACK;       
            break;
        case RASCS_Interactive:
            idString = IDS_INTERACTIVE;           
            break;
        case RASCS_RetryAuthentication: 
            idString = IDS_RETRYAUTHENTICATION;            
            break;
        case RASCS_CallbackSetByCaller: 
            idString = IDS_CALLBACKSETBYCALLER;   
            break;
        case RASCS_PasswordExpired:
            idString = IDS_PASSWORDEXPIRED;       
            break;
        case RASCS_Connected:
            idString = IDS_CONNECTED;            
            break;
        case RASCS_Disconnected:
            idString = IDS_DISCONNECTED;          
            break;
        default:
            idString = IDS_UNDEFINED_ERROR;
            break;
    }
    if (LoadString(g_hInstance, idString, lpszState, cb))
    {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}


DWORD ReplacePhoneNumber(LPTSTR lpszEntryName, LPTSTR lpszPhoneNumber)
{
    DWORD dwEntrySize = 0;
    DWORD dwSize = 0;
    DWORD dwRet;
    LPRASENTRY lpRasEntry = NULL;
    HINSTANCE hLib;
    RASGETENTRYPROPERTIES lpfnRasGetEntryProperties;
    RASSETENTRYPROPERTIES lpfnRasSetEntryProperties;

    // look for needed function in rasapi.dll
    hLib = LoadLibrary(szRasDll);
    if (NULL != hLib)
    {
        lpfnRasGetEntryProperties = (RASGETENTRYPROPERTIES)GetProcAddress(hLib, szRasGetEntryProperties);
        if (NULL != lpfnRasGetEntryProperties)
        {
            // we found the function
            goto get_entry2;
        }
        FreeLibrary(hLib);
    }

    // try rnaph.dll
    hLib = LoadLibrary(szRnaPhDll);
    if (NULL == hLib)
    {
        return ERROR_FILE_NOT_FOUND;
    }
    lpfnRasGetEntryProperties = (RASGETENTRYPROPERTIES)GetProcAddress(hLib, szRasGetEntryProperties);
    if (NULL == lpfnRasGetEntryProperties)
    {
        FreeLibrary(hLib);
        return ERROR_INVALID_FUNCTION;
    }

get_entry2:
    // get size needed for RASENTRY struct
    lpfnRasGetEntryProperties(
        NULL,
        lpszEntryName,
        NULL,
        &dwEntrySize,
        NULL,
        &dwSize);

    lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR, dwEntrySize + dwSize);

    if (NULL == lpRasEntry)
    {
        dwRet = ERROR_OUTOFMEMORY;
    }
    else
    {
        lpRasEntry->dwSize = dwEntrySize;

        dwRet = lpfnRasGetEntryProperties(
            NULL,
            lpszEntryName,
            (LPBYTE)lpRasEntry,
            &dwEntrySize,
            ((LPBYTE)lpRasEntry) + dwEntrySize,
            &dwSize);

        if (ERROR_SUCCESS == dwRet)
        {
            //lstrcpyn(lpRasEntry->szLocalPhoneNumber,lpszPhoneNumber,RAS_MaxPhoneNumber);
            lstrcpy(lpRasEntry->szLocalPhoneNumber,lpszPhoneNumber);
            lpfnRasSetEntryProperties = (RASSETENTRYPROPERTIES)GetProcAddress(hLib, szRasSetEntryProperties);
            lpRasEntry->dwfOptions &= ~(RASEO_UseCountryAndAreaCodes);
            TranslatePhoneNumber(lpRasEntry, lpszPhoneNumber);
            dwRet = lpfnRasSetEntryProperties(
                NULL,
                lpszEntryName,
                (LPBYTE)lpRasEntry,
                dwEntrySize,
                NULL,
                0);
//                ((LPBYTE)lpRasEntry) + dwEntrySize,
//                dwSize);
#if !defined(WIN16)
    RasSetEntryPropertiesScriptPatch(lpRasEntry->szScript, lpszEntryName);
#endif //!win16
        
        }

        GlobalFree((HLOCAL)lpRasEntry);
    }

    FreeLibrary(hLib);

    return dwRet;
}


// ############################################################################
LPTSTR StrDup(LPTSTR *ppszDest,LPCTSTR pszSource)
{
    if (ppszDest && pszSource)
    {
        *ppszDest = (LPTSTR)GlobalAlloc(GPTR,sizeof(TCHAR)*(lstrlen(pszSource)+1));
        if (*ppszDest)
            return (lstrcpy(*ppszDest,pszSource));
    }
    return NULL;
}

// ############################################################################
// NAME: GenericDlgProc
//
//    This is a common dlg proc that is shared by all of the signup connectoid
//    dialogs
//
// Notes:
//    This basically works because each dialog has an object associated
//    with it, and that object has a particular dlgproc that is called
//    at the end in order to handle specific functionality for the dialogs.
//
//  Created 1/28/96,        Chris Kauffman
// ############################################################################
INT_PTR CALLBACK GenericDlgProc(
    HWND  hwndDlg,    // handle to dialog box
    UINT  uMsg,    // message
    WPARAM  wParam,    // first message parameter
    LPARAM  lParam     // second message parameter
   )
{
    CDialog *pcDlg = NULL;
    INT_PTR lRet;
    switch (uMsg)
    {
    case WM_QUERYENDSESSION:
        EndDialog(hwndDlg,IDC_CMDCANCEL);
        lRet = TRUE;
        break;
    case WM_INITDIALOG:
        pcDlg = (CDialog *)lParam;
        SetWindowLongPtr(hwndDlg,DWLP_USER,(LONG_PTR)lParam);
        lRet = TRUE;

        MakeBold(GetDlgItem(hwndDlg,IDC_LBLTITLE),TRUE,FW_BOLD);

        //
        // 7/18/97 jmazner    Olympus #1111
        // dialing string could contain DBCS if using a calling card, so
        // make sure we display that correctly
        //
        ProcessDBCS(hwndDlg, IDC_LBLNUMBER);

        break;
    case WM_CLOSE:
        if (!pcDlg) pcDlg = (CDialog*)GetWindowLongPtr(hwndDlg,DWLP_USER);
        if (pcDlg)
        {
            if (pcDlg->m_bShouldAsk)
            {
                if (MessageBox(hwndDlg,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
                    MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
                    EndDialog(hwndDlg,IDC_CMDCANCEL);
                lRet = TRUE;
            }
        }
        break;
    default:
        // let the system process the message
        lRet = FALSE;
    }

    if (!pcDlg) pcDlg = (CDialog*)GetWindowLongPtr(hwndDlg,DWLP_USER);
    if (pcDlg)
        lRet = pcDlg->DlgProc(hwndDlg,uMsg,wParam,lParam,lRet);

    return lRet;
}


// ############################################################################
HRESULT WINAPI ICWGetRasEntry(LPRASENTRY *ppRasEntry, LPDWORD lpdwRasEntrySize, LPRASDEVINFO *ppRasDevInfo, LPDWORD lpdwRasDevInfoSize, LPTSTR pszEntryName)
{
    //DWORD dwRasEntrySize=0;
    //DWORD dwRasDevInfoSize=0;
    HINSTANCE hRasDll = NULL;
    HRESULT hr = ERROR_SUCCESS;
    FARPROC fp = NULL;
    RNAAPI *pcRNA;
    DWORD dwOldDevInfoBuffSize = 0;

    //
    // Validate parameters
    //
    if (!ppRasEntry || !lpdwRasEntrySize || !ppRasDevInfo || !lpdwRasDevInfoSize || !pszEntryName || !lstrlen(pszEntryName))
    {
        hr = ERROR_INVALID_PARAMETER;
        goto ICWGetRasEntryExit;
    }

    // *ppRasEntry and *ppRasDevInfo should not have memory allocated to them
    Assert( *ppRasEntry == NULL );
    Assert( *ppRasDevInfo == NULL );
    Assert( *lpdwRasEntrySize == 0);
    Assert( *lpdwRasDevInfoSize == 0);

    //
    // Instantiate RNA wrapper
    //
    pcRNA = new RNAAPI;
    if (NULL == pcRNA)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto ICWGetRasEntryExit;
    }
    

    // use RasGetEntryProperties with a NULL lpRasEntry pointer to find out size buffer we need
    // As per the docs' recommendation, do the same with a NULL lpRasDevInfo pointer.

    hr = pcRNA->RasGetEntryProperties(NULL,
                                      pszEntryName,
//#ifdef WIN16                                    
                                      (LPBYTE)
//#endif
                                      *ppRasEntry,
                                      lpdwRasEntrySize,
                                      (LPBYTE)*ppRasDevInfo,
                                      lpdwRasDevInfoSize);

    // we expect the above call to fail because the buffer size is 0
    // If it doesn't fail, that means our RasEntry is messed, so we're in trouble
    if( ERROR_BUFFER_TOO_SMALL != hr )
    { 
        goto ICWGetRasEntryExit;
    }

    // dwRasEntrySize and dwRasDevInfoSize now contain the size needed for their
    // respective buffers, so allocate the memory for them

    // dwRasEntrySize should never be less than the size of the RASENTRY struct.
    // If it is, we'll run into problems sticking values into the struct's fields

    Assert( *lpdwRasEntrySize >= sizeof(RASENTRY) );

#if defined(WIN16)
    //
    // Allocate extra 256 bytes to workaround memory overrun bug in RAS
    //
    *ppRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,*lpdwRasEntrySize + 256);
#else    
    *ppRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,*lpdwRasEntrySize);
#endif

    if ( !(*ppRasEntry) )
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto ICWGetRasEntryExit;
    }

    //
    // Allocate the DeviceInfo size that RasGetEntryProperties told us we needed.
    // If size is 0, don't alloc anything
    //
    if( *lpdwRasDevInfoSize > 0 )
    {
        Assert( *lpdwRasDevInfoSize >= sizeof(RASDEVINFO) );
        *ppRasDevInfo = (LPRASDEVINFO)GlobalAlloc(GPTR,*lpdwRasDevInfoSize);
        if ( !(*ppRasDevInfo) )
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto ICWGetRasEntryExit;
        }
    } else
    {
        *ppRasDevInfo = NULL;
    }

    // This is a bit convoluted:  lpRasEntrySize->dwSize needs to contain the size of _only_ the
    // RASENTRY structure, and _not_ the actual size of the buffer that lpRasEntrySize points to.
    // This is because the dwSize field is used by RAS for compatability purposes to determine which
    // version of the RASENTRY struct we're using.
    // Same holds for lpRasDevInfo->dwSize
    
    (*ppRasEntry)->dwSize = sizeof(RASENTRY);
    if( *ppRasDevInfo )
    {
        (*ppRasDevInfo)->dwSize = sizeof(RASDEVINFO);
    }

    //now we're ready to make the actual call to RasGetEntryProperties!

/*
    // Load RAS DLL and locate API
    //

    hRasDll = LoadLibrary(RASAPI_LIBRARY);
    if (!hRasDll)
    {
        hr = GetLastError();
        goto ICWGetRasEntryExit;
    }

    fp =GetProcAddress(hRasDll,RASAPI_RASGETENTRY);
    if (!fp)
    {
        FreeLibrary(hRasDll);
        hRasDll = LoadLibrary(RNAPH_LIBRARY);
        if (!hRasDll)
        {
            hr = GetLastError();
            goto ICWGetRasEntryExit;
        }
        fp = GetProcAddress(hRasDll,RASAPI_RASGETENTRY);
        if (!fp)
        {
            hr = GetLastError();
            goto ICWGetRasEntryExit;
        }
    }
*/
    // Get RasEntry
    //
    
    //hr = ((PFNRASGETENTRYPROPERTIES)fp)(NULL,pszEntryName,(LPBYTE)*ppRasEntry,&dwRasEntrySize,(LPBYTE)*ppDevInfo,&dwRasDevInfoSize);

    // jmazner   see below for why this is needed
    dwOldDevInfoBuffSize = *lpdwRasDevInfoSize;

    hr = pcRNA->RasGetEntryProperties(NULL,pszEntryName,(LPBYTE)*ppRasEntry,lpdwRasEntrySize,(LPBYTE)*ppRasDevInfo,lpdwRasDevInfoSize);

    // jmazner 10/7/96  Normandy #8763
    // For unknown reasons, in some cases on win95, devInfoBuffSize increases after the above call,
    // but the return code indicates success, not BUFFER_TOO_SMALL.  If this happens, set the
    // size back to what it was before the call, so the DevInfoBuffSize and the actuall space allocated 
    // for the DevInfoBuff match on exit.
    if( (ERROR_SUCCESS == hr) && (dwOldDevInfoBuffSize != *lpdwRasDevInfoSize) )
    {
        *lpdwRasDevInfoSize = dwOldDevInfoBuffSize;
    }



ICWGetRasEntryExit:
    if (hRasDll) FreeLibrary(hRasDll);
    hRasDll = NULL;
    if (pcRNA) delete pcRNA;
    pcRNA = NULL;

    return hr;
}

//+----------------------------------------------------------------------------
//
//    Function:    FCampusNetOverride
//
//    Synopsis:    Detect if the dial should be skipped for the campus network
//
//    Arguments:    None
//
//    Returns:    TRUE - overide enabled
//
//    History:    8/15/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
#if !defined(WIN16) && defined(DEBUG)
BOOL FCampusNetOverride()
{
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwData = 0;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
        TEXT("Software\\Microsoft\\ISignup\\Debug"),&hkey))
        goto FCampusNetOverrideExit;

    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS != RegQueryValueEx(hkey,TEXT("CampusNet"),0,&dwType,
        (LPBYTE)&dwData,&dwSize))
        goto FCampusNetOverrideExit;

    AssertMsg(REG_DWORD == dwType,"Wrong value type for CampusNet.  Must be DWORD.\r\n");
    bRC = (0 != dwData);

    if (bRC)
        MessageBox(NULL,TEXT("DEBUG ONLY: CampusNet will be used."),TEXT("Testing Override"),0);

FCampusNetOverrideExit:
    if (hkey)
        RegCloseKey(hkey);

    return bRC;
}
#endif //!WIN16 && DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdial\pch.hpp ===
#include <windows.h>
#include <ras.h>
#include "icwunicd.h"
#include "globals.h"
//#include "support.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdial\resource.h ===
/*-----------------------------------------------------------------------------
	resource.h

	contains declarations for all IDs in .rc file

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		7/22/96		ChrisK	Cleaned and formatted

	NOTE:
		DO NOT EDIT THIS WITH MSVC!  You will destroy the comments and all
		entries designed to build for WIN16

-----------------------------------------------------------------------------*/

#include "dialutil.h"

#define IDS_DIALMESSAGE                 125
#define IDC_STATIC                      -1

#define IDI_WARN                     101
#define IDI_PHONE                    102
#define IDB_PHONE                    108

#define IDS_CONNECTING_TO            401
#define IDS_OUTOFMEMORY              406
#define IDS_WANTTOEXIT               408
#define IDS_RAS_DIALING              409
#define IDS_RAS_PORTOPENED           410
#define IDS_RAS_OPENPORT             411
#define IDS_RAS_CONNECTED            412
#define IDS_RAS_LOCATING             413
#define IDS_TCPINSTALLERROR		     414
#define IDS_PPPRANDOMFAILURE 	     416
#define IDS_RASNOCARRIER		     418
#define IDS_PHONEBUSY			     419
#define IDS_NODIALTONE			     420
#define IDS_NODEVICE			     421
#define IDS_USERCANCELEDDIAL         423
#define IDS_TITLE                    424
#define IDS_CANTLOADINETCFG          425
#define IDS_CANTLOADCONFIGAPI		 426
#define IDS_CANTLOADPHBKAPI		 	 427
#define IDS_CANTINITPHONEBOOK        428
#define IDS_CANTLOADRNAPHAPI		 429
#define IDS_CANTSAVEKEY              430
#define IDS_CANTREADKEY              431
#define IDS_NOANSWER                 432
#define IDS_INVALIDPN                433
#define IDS_MEDIAINIERROR			 434
#define IDS_RAS_HANGINGUP            435
#define IDS_INVALIDPHONE             436
// 3/28/97 ChrisK Olympus 296
#define IDS_REESTABLISH              437
// 5/17/97 jmazner Olympus #137
#define IDS_SBCSONLY				 438

#define IDS_SUPPORTMSG              500

#define IDC_ERROR                   1000
#define IDC_STATUS                  1001
#define IDC_CONNECT                 1002
#define IDC_PHONENUMBER             1003
#define IDC_CMDPHONE			    1004

#define IDC_LBLTITLE                1005
#define IDC_LBLNUMBER               1006
#define IDC_LBLSTATUS               1007
#define IDC_CMDCANCEL               1008
#define IDC_PROGRESS                1009
#define IDC_LBLERRMSG               1010
#define IDC_CMBMODEMS               1011
#define IDC_CMDPHONEBOOK            1012
#define IDC_CMDDIALPROP             1013
#define IDC_CMDNEXT                 1014
#define IDC_CMDHELP                 1015
#define IDC_LBLPHONE                1016
#define IDC_TEXTNUMBER				1017
#define IDC_CONNECT_TEXT            1018
#define IDC_PHNUM_TEXT              1019
#define IDC_NUMTODIAL               1020
#define IDC_CURMODEM                1021
#define IDC_CHNGNUM                 1022


#define IDC_LBSUPPORTMSG            2000

#define IDD_DIALING                  200
#define IDD_DIALERR                  201
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdial\mimedl.cpp ===
/*-----------------------------------------------------------------------------
	mimedl.cpp

	Handle the downloading of MIME multi-part/mixed packages.

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		7/22/96		ChrisK	Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include <commctrl.h>

#define MAX_EXIT_RETRIES 10

// ############################################################################
DWORD WINAPI DownloadThreadInit(CDialingDlg *pcPDlg)
{
	HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
//	HINSTANCE hADDll;

	// Set up for download
	//

	Assert (pcPDlg->m_pcDLAPI);

	hr = pcPDlg->m_pcDLAPI->DownLoadInit(pcPDlg->m_pszUrl, (DWORD_PTR *)pcPDlg, &pcPDlg->m_dwDownLoad, pcPDlg->m_hwnd);
	if (hr != ERROR_SUCCESS) goto ThreadInitExit;

	// Set up call back for progress dialog
	//

	hr = pcPDlg->m_pcDLAPI->DownLoadSetStatus(pcPDlg->m_dwDownLoad,(INTERNET_STATUS_CALLBACK)ProgressCallBack);

	/**
	// Set up Autodialer DLL
	//

	hADDll = LoadLibrary(AUTODIAL_LIBRARY);
	if (!hADDll) goto end_autodial_setup;
	fp = GetProcAddress(hADDll,AUTODIAL_INIT);
	if (!fp) goto end_autodial_setup;
	((PFNAUTODIALINIT)fp)(g_szInitialISPFile,pcPDlg->m_pGI->fType,pcPDlg->m_pGI->bMask,pcPDlg->m_pGI->dwCountry,pcPDlg->m_pGI->wState);

end_autodial_setup:
	**/

	// Download stuff MIME multipart
	//

	hr = pcPDlg->m_pcDLAPI->DownLoadExecute(pcPDlg->m_dwDownLoad);
	if (hr)
		goto ThreadInitExit;

	hr = pcPDlg->m_pcDLAPI->DownLoadProcess(pcPDlg->m_dwDownLoad);
	if (hr)
		goto ThreadInitExit;

	// Clean up
	//

	hr = pcPDlg->m_pcDLAPI->DownLoadClose(pcPDlg->m_dwDownLoad);
	pcPDlg->m_dwDownLoad = 0;
	// NOTE: I realize this line is unecessary, it would be
	// required if there were any code after it in this function.
	if (hr != ERROR_SUCCESS) goto ThreadInitExit;  
	hr = ERROR_SUCCESS;

ThreadInitExit:
	PostMessage(pcPDlg->m_hwnd,WM_DOWNLOAD_DONE,0,0);
//	if (hADDll) FreeLibrary(hADDll);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdial\rnawnd.cpp ===
/*----------------------------------------------------------------------------
    rnawnd.cpp
        
    Functions to zap the RNA windows 
    
    Copyright (C) 1995 Microsoft Corporation
    All rights reserved.

    Authors:
        ArulM
    ChrisK    Updated for ICW usage
  --------------------------------------------------------------------------*/

#include "pch.hpp"
#include "resource.h"

//#define SMALLBUFLEN 48

/*******************************************************************
    NAME:        MinimizeRNAWindow
    SYNOPSIS:    Finds and minimizes the annoying RNA window
    ENTRY:        pszConnectoidName - name of connectoid launched
    NOTES:        Does a FindWindow on window class "#32770" (hard-coded
                dialog box class which will never change), with
                the title "connected to <connectoid name>" or its
                localized equivalent.
********************************************************************/

static const TCHAR szDialogBoxClass[] = TEXT("#32770");    // hard coded dialog class name
typedef struct tagWaitAndMinimizeRNAWindowArgs
{
    LPTSTR pTitle;
    HINSTANCE hinst;
} WnWRNAWind, FAR * LPRNAWindArgs;

WnWRNAWind RNAWindArgs;
HWND hwndFound = NULL;
DWORD dwRASWndTitleMinLen = 0;

BOOL CALLBACK MyEnumWindowsProc(HWND hwnd, LPARAM lparam)
{
    TCHAR szTemp[SMALLBUFLEN+2];
    PTSTR pszTitle;
    UINT uLen1, uLen2;

    if(!IsWindowVisible(hwnd))
        return TRUE;
    if(GetClassName(hwnd, szTemp, SMALLBUFLEN)==0)
        return TRUE; // continue enumerating
    if(lstrcmp(szTemp, szDialogBoxClass)!=0)
        return TRUE;
    if(GetWindowText(hwnd, szTemp, SMALLBUFLEN)==0)
        return TRUE;
    szTemp[SMALLBUFLEN] = 0;
    uLen1 = lstrlen(szTemp);
    Assert(dwRASWndTitleMinLen);
    if(uLen1 < dwRASWndTitleMinLen)
        return TRUE;
    // skip last 5 chars of title, but keep length to at least the min len
    uLen1 = min(dwRASWndTitleMinLen, (uLen1-5));
    pszTitle = (PTSTR)lparam;
    Assert(pszTitle);
    uLen2 = lstrlen(pszTitle);
    TraceMsg(TF_GENERAL, "Title=(%s), len=%d, Window=(%s), len=%d\r\n", pszTitle, uLen2, szTemp, uLen1);
    if(uLen2 < uLen1)
        return TRUE;
    if(_memicmp(pszTitle, szTemp, uLen1)!=0)
        return TRUE;
    TraceMsg(TF_GENERAL, "FOUND RNA WINDOW!!!\r\n");
    hwndFound = hwnd;
    return FALSE;
}

HWND MyFindRNAWindow(PTSTR pszTitle)
{
    DWORD dwRet;
    hwndFound = NULL;
    dwRet = EnumWindows((WNDENUMPROC)(&MyEnumWindowsProc), (LPARAM)pszTitle);
    TraceMsg(TF_GENERAL, "EnumWindows returned %d\r\n", dwRet);
    return hwndFound;
}

DWORD WINAPI WaitAndMinimizeRNAWindow(PVOID pArgs)
{
    // starts as a seperate thread
    int i;
    HWND hwndRNAApp;
    LPRNAWindArgs lpRNAArgs;

    lpRNAArgs = (LPRNAWindArgs)pArgs;
    
    Assert(lpRNAArgs->pTitle);
    
    for(i=0; !(hwndRNAApp=MyFindRNAWindow((PTSTR)lpRNAArgs->pTitle)) && i<100; i++)
    {
        TraceMsg(TF_GENERAL, "Waiting for RNA Window\r\n");
        Sleep(50);
    }

    TraceMsg(TF_GENERAL, "FindWindow (%s)(%s) returned %d\r\n", szDialogBoxClass, lpRNAArgs->pTitle, hwndRNAApp);

    if(hwndRNAApp)
    {
        // Hide the window
        // ShowWindow(hwndRNAApp,SW_HIDE);
        // Used to just minimize, but that wasnt enough
        // ChrisK reinstated minimize for ICW
        ShowWindow(hwndRNAApp,SW_MINIMIZE);
    }

    GlobalFree(lpRNAArgs->pTitle);
    // exit function and thread

    FreeLibraryAndExitThread(lpRNAArgs->hinst,HandleToUlong(hwndRNAApp));
    return (DWORD)0;
}

    
void MinimizeRNAWindow(TCHAR * pszConnectoidName, HINSTANCE hInst)
{
    HANDLE hThread;
    DWORD dwThreadId;
    
    Assert(pszConnectoidName);

    // alloc strings for title and format
    TCHAR * pFmt = (TCHAR*)GlobalAlloc(GPTR, sizeof(TCHAR)*(SMALLBUFLEN+1));
    TCHAR * pTitle = (TCHAR*)GlobalAlloc(GPTR, sizeof(TCHAR)*((RAS_MaxEntryName + SMALLBUFLEN + 1)));
    if (!pFmt || !pTitle) 
        goto error;
    
    // load the title format ("connected to <connectoid name>" from resource
    Assert(hInst);
    LoadString(hInst, IDS_CONNECTED_TO, pFmt, SMALLBUFLEN);

    // get length of localized title (including the %s). Assume the unmunged
    // part of the window title is at least "Connected to XX" long.
    dwRASWndTitleMinLen = lstrlen(pFmt);

    // build the title
    wsprintf(pTitle, pFmt, pszConnectoidName);

    RNAWindArgs.pTitle = pTitle;
    RNAWindArgs.hinst = LoadLibrary(TEXT("ICWDIAL.DLL"));

    hThread = CreateThread(0, 0, &WaitAndMinimizeRNAWindow, &RNAWindArgs, 0, &dwThreadId);
    Assert(hThread && dwThreadId);
    // dont free pTitle. The child thread needs it!
    GlobalFree(pFmt);
    // free the thread handle or the threads stack is leaked!
    CloseHandle(hThread);
    return;
    
error:
    if(pFmt)    GlobalFree(pFmt);
    if(pTitle)    GlobalFree(pTitle);
}

// 3/28/97 ChrisK Olympus 296
#if !defined (WIN16)
/*******************************************************************
    NAME:        RNAReestablishZapper
    SYNOPSIS:    Finds and closes the annoying RNA reestablish window
                should it ever appear
    NOTES:        Does a FindWindow on window class "#32770" (hard-coded
                dialog box class which will never change), with
                the title "Reestablish Connection" or it's
                localized equivalent.
********************************************************************/

BOOL fKeepZapping = 0;

void StopRNAReestablishZapper(HANDLE hthread)
{
    if (INVALID_HANDLE_VALUE != hthread && NULL != hthread)
    {
        TraceMsg(TF_GENERAL, "ICWDIAL: Started StopRNAZapper=%d\r\n", fKeepZapping);
        // reset the "stop" flag
        fKeepZapping = 0;
        // wait for thread to complete & free handle
        WaitForSingleObject(hthread, INFINITE);
        CloseHandle(hthread);
        TraceMsg(TF_GENERAL, "ICWDIAL: Stopped StopRNAZapper=%d\r\n", fKeepZapping);
    }
    else
    {
        TraceMsg(TF_GENERAL, "ICWCONN1: StopRNAReestablishZapper called with invalid handle.\r\n");
    }
}

DWORD WINAPI RNAReestablishZapper(PVOID pTitle)
{
    int i;
    HWND hwnd;

    TraceMsg(TF_GENERAL, "ICWDIAL: Enter RNAREstablishZapper(%s) f=%d\r\n", pTitle, fKeepZapping);

    // This thread continues until the fKeepZapping flag is reset
    while(fKeepZapping)
    {
        if(hwnd=FindWindow(szDialogBoxClass, (PTSTR)pTitle))
        {
            TraceMsg(TF_GENERAL, "ICWDIAL: Reestablish: Found Window (%s)(%s) hwnd=%x\r\n", szDialogBoxClass, pTitle, hwnd);
            // Post it the Cancel message
            PostMessage(hwnd, WM_COMMAND, IDCANCEL, 0);
        }
        Sleep(1000);
    }

    TraceMsg(TF_GENERAL, "ICWDIAL: Exit RNAREstablishZapper(%s) f=%d\r\n", pTitle, fKeepZapping);
    GlobalFree(pTitle);
    return 0;
}

HANDLE LaunchRNAReestablishZapper(HINSTANCE hInst)
{
    HANDLE hThread;
    DWORD dwThreadId;

    // alloc strings for title and format
    TCHAR* pTitle = (TCHAR*)GlobalAlloc(LPTR, (SMALLBUFLEN+1) * sizeof(TCHAR));
    if (!pTitle) goto error;
    
    // load the title format "Reestablish Connection" from resource
    Assert(hInst);
    LoadString(hInst, IDS_REESTABLISH, pTitle, SMALLBUFLEN);

    // enable zapping
    fKeepZapping = TRUE;

    hThread = CreateThread(0, 0, &RNAReestablishZapper, pTitle, 0, &dwThreadId);
    Assert(hThread && dwThreadId);
    // dont free pTitle. The child thread needs it!
    
    return hThread;
    
error:
    if(pTitle) GlobalFree(pTitle);
    return INVALID_HANDLE_VALUE;
}

#endif // !WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdial\support.h ===
//
// !!!!! this file no longer used !!!!!!
// 5/28/97 jmazner Olympus #4528
// We don't want to show support numbers for calls to the ISP
//


//#--------------------------------------------------------------
//        
//  File:       support.h
//        
//  Synopsis:   holds the  Class declaration for the CSupport
//              class
//
//  History:     5/8/97    MKarki Created
//
//    Copyright (C) 1996-97 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------

#include "..\icwphbk\icwsupport.h"

const CHAR PHBK_LIB[] = "icwphbk.dll";
const CHAR PHBK_SUPPORTNUMAPI[] = "GetSupportNumbers";

typedef HRESULT (WINAPI *PFNGETSUPPORTNUMBERS) (PSUPPORTNUM, PDWORD);

class CSupport
{
private:
    PSUPPORTNUM     m_pSupportNumList;
    DWORD           m_dwTotalNums;

    //
    // this function gets the countryID
    //
    BOOL GetCountryID (PDWORD pdwCountryID); 

public:
    CSupport (VOID)
    {
        m_pSupportNumList = NULL;
        m_dwTotalNums = 0;
    }

    ~CSupport (VOID);

    BOOL GetSupportInfo (PCHAR);

};  // end of CSupport class declaration
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdial\import.cpp ===
/*-----------------------------------------------------------------------------
    import.cpp

    This file contain all the functions that handle importing connection
    information from .DUN files

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

    Authors:
        ChrisK        ChrisKauffman

    History:
    Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
        this code started its life as ixport.c in RNAUI.DLL
        my thanks to viroont
        7/22/96        ChrisK    Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "resource.h"

#include "inetcfg.h"

#define ARRAYSIZE(a)    (sizeof(a) / sizeof((a)[0]))

#define IDS_DEFAULT_SCP         0
#define IDS_INI_SCRIPT_DIR      1
#define IDS_INI_SCRIPT_SHORTDIR 2

#define MAXLONGLEN      80
#define MAXNAME         80

//#ifdef __cplusplus
//extern "C" {
//#endif // __cplusplus
//extern HINSTANCE g_hInstance;
//#ifdef __cplusplus
//}
//#endif // __cplusplus

#define MAXIPADDRLEN    20
#define SIZE_ReadBuf    0x00008000    // 32K buffer size

#define AUTORUNSIGNUPWIZARDAPI "InetConfigClient"

typedef HRESULT (CALLBACK *PFNAUTORUNSIGNUPWIZARD) (HWND hwndParent,
                                                    LPCTSTR lpszPhoneBook,
                                                     LPCTSTR lpszConnectoidName,
                                                     LPRASENTRY lpRasEntry,
                                                     LPCTSTR lpszUsername,
                                                     LPCTSTR lpszPassword,
                                                     LPCTSTR lpszProfileName,
                                                     LPINETCLIENTINFO lpINetClientInfo,
                                                     DWORD dwfOptions,
                                                     LPBOOL lpfNeedsRestart);

#pragma data_seg(".rdata")

TCHAR cszEntrySection[] = TEXT("Entry");
TCHAR cszEntryName[]    = TEXT("Entry_Name");
TCHAR cszAlias[]        = TEXT("Import_Name");
TCHAR cszML[]           = TEXT("Multilink");

TCHAR cszPhoneSection[] = TEXT("Phone");
TCHAR cszDialAsIs[]     = TEXT("Dial_As_Is");
TCHAR cszPhone[]        = TEXT("Phone_Number");
TCHAR cszAreaCode[]     = TEXT("Area_Code");
TCHAR cszCountryCode[]  = TEXT("Country_Code");
TCHAR cszCountryID[]    = TEXT("Country_ID");

TCHAR cszDeviceSection[] = TEXT("Device");
TCHAR cszDeviceType[]    = TEXT("Type");
TCHAR cszDeviceName[]    = TEXT("Name");
TCHAR cszDevCfgSize[]    = TEXT("Settings_Size");
TCHAR cszDevCfg[]        = TEXT("Settings");

TCHAR cszServerSection[] = TEXT("Server");
TCHAR cszServerType[]    = TEXT("Type");
TCHAR cszSWCompress[]    = TEXT("SW_Compress");
TCHAR cszPWEncrypt[]     = TEXT("PW_Encrypt");
TCHAR cszNetLogon[]      = TEXT("Network_Logon");
TCHAR cszSWEncrypt[]     = TEXT("SW_Encrypt");
TCHAR cszNetBEUI[]       = TEXT("Negotiate_NetBEUI");
TCHAR cszIPX[]           = TEXT("Negotiate_IPX/SPX");
TCHAR cszIP[]            = TEXT("Negotiate_TCP/IP");

TCHAR cszIPSection[]     = TEXT("TCP/IP");
TCHAR cszIPSpec[]        = TEXT("Specify_IP_Address");
TCHAR cszIPAddress[]     = TEXT("IP_address");
TCHAR cszServerSpec[]    = TEXT("Specify_Server_Address");
TCHAR cszDNSAddress[]    = TEXT("DNS_address");
TCHAR cszDNSAltAddress[] = TEXT("DNS_Alt_address");
TCHAR cszWINSAddress[]   = TEXT("WINS_address");
TCHAR cszWINSAltAddress[]= TEXT("WINS_Alt_address");
TCHAR cszIPCompress[]    = TEXT("IP_Header_Compress");
TCHAR cszWanPri[]        = TEXT("Gateway_On_Remote");

TCHAR cszMLSection[]     = TEXT("Multilink");
TCHAR cszLinkIndex[]     = TEXT("Line_%s");

TCHAR cszScriptingSection[] = TEXT("Scripting");
TCHAR cszScriptName[]    = TEXT("Name");

TCHAR cszScriptSection[] = TEXT("Script_File");

TCHAR cszYes[]           = TEXT("yes");
TCHAR cszNo[]            = TEXT("no");

TCHAR cszUserSection[]   = TEXT("User");
TCHAR cszUserName[]      = TEXT("Name");
TCHAR cszPassword[]      = TEXT("Password");

TCHAR szNull[] = TEXT("");

#define DUN_NOPHONENUMBER TEXT("000000000000")

struct {
    TCHAR *szType;
    DWORD dwType;
    DWORD dwfOptions;
} aServerTypes[] =
{ 
    {TEXT("PPP"),     RASFP_Ppp,  0},
    {TEXT("SLIP"),    RASFP_Slip, 0},
    {TEXT("CSLIP"),   RASFP_Slip, RASEO_IpHeaderCompression},
    {TEXT("RAS"),     RASFP_Ras,  0}
};

#pragma data_seg()

//#define RASAPI_LIBRARY "RASAPI32.DLL"
//#define RNAPH_LIBRARY "RNAPH.DLL"
//typedef DWORD (WINAPI* PFNRASSETENTRYPROPERTIES)(LPSTR lpszPhonebook, LPSTR lpszEntry, LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize, LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);

//PreWriteConnectoid(LPSTR pszEntryName,RASENTRY *lpRasEntry)
//{
//    FARPROC        fp = NULL;
//    HINSTANCE hRNADLL;
//    DWORD dwRasSize;
//    hRNADLL = LoadLibrary(RASAPI_LIBRARY);
//    fp = NULL;
//    if (hRNADLL)
//    {
//        fp = GetProcAddress(hRNADLL,"RasGetEntryProperties");
//    }
//    if (!fp)
//    {
//        if (hRNADLL) FreeLibrary(hRNADLL);
//        hRNADLL = LoadLibrary(RNAPH_LIBRARY);
//        if (hRNADLL) fp = GetProcAddress(hRNADLL,"RasSetEntryProperties");
//    }
//    if (fp)
//    {
//        dwRasSize = sizeof(RASENTRY);
//        ((PFNRASSETENTRYPROPERTIES)fp)(NULL,pszEntryName,(LPBYTE)lpRasEntry,dwRasSize,NULL,0);
//    }
//    if (hRNADLL) FreeLibrary(hRNADLL);
//}

//****************************************************************************
// DWORD NEAR PASCAL StrToip (LPSTR szIPAddress, LPDWORD lpdwAddr)
//
// This function converts a IP address string to an IP address structure.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Cloned from SMMSCRPT.
//****************************************************************************

LPCTSTR NEAR PASCAL StrToSubip (LPCTSTR szIPAddress, BYTE *pVal)
{
  LPCTSTR pszIP = szIPAddress;

  *pVal = (BYTE)Sz2W(pszIP);
  // skip over digits
  while (FIsDigit(*pszIP))
  {
    ++pszIP;
  }

  // skip over one or more separators
  while (*pszIP && !FIsDigit(*pszIP))
  {
    ++pszIP;
  }

  return pszIP;
}


DWORD NEAR PASCAL StrToip (LPCTSTR szIPAddress, RASIPADDR *ipAddr)
{
  LPCTSTR pszIP = szIPAddress;

  pszIP = StrToSubip(pszIP, &ipAddr->a);
  pszIP = StrToSubip(pszIP, &ipAddr->b);
  pszIP = StrToSubip(pszIP, &ipAddr->c);
  pszIP = StrToSubip(pszIP, &ipAddr->d);

  return ERROR_SUCCESS;
}


//****************************************************************************
// DWORD NEAR PASCAL ImportPhoneInfo(PPHONENUM ppn, LPCTSTR szFileName)
//
// This function imports the phone number.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD NEAR PASCAL ImportPhoneInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
  TCHAR   szYesNo[MAXNAME];

  GetPrivateProfileString(cszPhoneSection,
                          cszPhone,
                          DUN_NOPHONENUMBER,
                          lpRasEntry->szLocalPhoneNumber,
                          RAS_MaxPhoneNumber,
                          szFileName);
/****************
 we need to accept entries w/o phone numbers
  if (GetPrivateProfileString(cszPhoneSection,
                              cszPhone,
                              szNull,
                              lpRasEntry->szLocalPhoneNumber,
                              sizeof(lpRasEntry->szLocalPhoneNumber),
                              szFileName) == 0)
  {
    return ERROR_CORRUPT_PHONEBOOK;
  };
****************/

  lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;

  GetPrivateProfileString(cszPhoneSection,
                          cszDialAsIs,
                          cszYes,
                          szYesNo,
                          MAXNAME,
                          szFileName);

  // Do we have to get country code and area code?
  //
  if (!lstrcmpi(szYesNo, cszNo))
  {

    // If we cannot get the country ID or it is zero, default to dial as is
    //
    if ((lpRasEntry->dwCountryID = GetPrivateProfileInt(cszPhoneSection,
                                                 cszCountryID,
                                                 0,
                                                 szFileName)) != 0)
    {
      lpRasEntry->dwCountryCode = GetPrivateProfileInt(cszPhoneSection,
                                                cszCountryCode,
                                                1,
                                                szFileName);

      if (GetPrivateProfileString(cszPhoneSection,
                              cszAreaCode,
                              szNull,
                              lpRasEntry->szAreaCode,
                              RAS_MaxAreaCode,
                              szFileName) != 0)
      {
        lpRasEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;
      }
    }
  }
  return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportServerInfo(PSMMINFO psmmi, LPSTR szFileName)
//
// This function imports the server type name and settings.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD NEAR PASCAL ImportServerInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
  TCHAR   szYesNo[MAXNAME];
  TCHAR   szType[MAXNAME];
  DWORD  i;

  // Get the server type name
  //
  GetPrivateProfileString(cszServerSection,
                          cszServerType,
                          szNull,
                          szType,
                          MAXNAME,
                          szFileName);

  // need to convert the string into
  // one of the following values
  //   RASFP_Ppp
  //   RASFP_Slip  Note CSLIP is SLIP with IP compression on
  //   RASFP_Ras

  for (i = 0; i < sizeof(aServerTypes)/sizeof(aServerTypes[0]); ++i)
  {
    if (!lstrcmpi(aServerTypes[i].szType, szType))
    {
       lpRasEntry->dwFramingProtocol = aServerTypes[i].dwType;
       lpRasEntry->dwfOptions |= aServerTypes[i].dwfOptions;
       break;
    }
  }

  // Get the server type settings
  //
  if (GetPrivateProfileString(cszServerSection,
                              cszSWCompress,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_SwCompression;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_SwCompression;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszPWEncrypt,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RequireEncryptedPw;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RequireEncryptedPw;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszNetLogon,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_NetworkLogon;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_NetworkLogon;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszSWEncrypt,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RequireDataEncryption;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RequireDataEncryption;
    };
  };

  // Get the protocol settings
  //
  if (GetPrivateProfileString(cszServerSection,
                              cszNetBEUI,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
//#ifdef _CHRISK
      lpRasEntry->dwfNetProtocols &= ~RASNP_NetBEUI;
//#else
//      lpRasEntry->dwfNetProtocols &= ~RASNP_Netbeui;
//#endif
    }
    else
    {
//#ifdef _CHRISK
      lpRasEntry->dwfNetProtocols |= RASNP_NetBEUI;
//#else
//      lpRasEntry->dwfNetProtocols |= RASNP_Netbeui;
//#endif
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszIPX,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfNetProtocols &= ~RASNP_Ipx;
    }
    else
    {
      lpRasEntry->dwfNetProtocols |= RASNP_Ipx;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszIP,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfNetProtocols &= ~RASNP_Ip;
    }
    else
    {
      lpRasEntry->dwfNetProtocols |= RASNP_Ip;
    };
  };
  return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportIPInfo(LPSTR szEntryName, LPSTR szFileName)
//
// This function imports the TCP/IP information
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD NEAR PASCAL ImportIPInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
  TCHAR   szIPAddr[MAXIPADDRLEN];
  TCHAR   szYesNo[MAXNAME];

  // Import IP address information
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszIPSpec,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszYes))
    {
      // The import file has IP address specified, get the IP address
      //
      lpRasEntry->dwfOptions |= RASEO_SpecificIpAddr;
      if (GetPrivateProfileString(cszIPSection,
                                  cszIPAddress,
                                  szNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddr);
      };
    }
    else
    {
      lpRasEntry->dwfOptions &= ~RASEO_SpecificIpAddr;
    };
  };

  // Import Server address information
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszServerSpec,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszYes))
    {
      // The import file has server address specified, get the server address
      //
      lpRasEntry->dwfOptions |= RASEO_SpecificNameServers;
      if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAddress,
                                  szNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrDns);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAltAddress,
                                  szNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrDnsAlt);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAddress,
                                  szNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrWins);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAltAddress,
                                  szNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrWinsAlt);
      };
    }
    else
    {
      lpRasEntry->dwfOptions &= ~RASEO_SpecificNameServers;
    };
  };

  // Header compression and the gateway settings
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszIPCompress,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_IpHeaderCompression;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_IpHeaderCompression;
    };
  };

  if (GetPrivateProfileString(cszIPSection,
                              cszWanPri,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RemoteDefaultGateway;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RemoteDefaultGateway;
    };
  };

  return ERROR_SUCCESS;
}

//****************************************************************************
// HANDLE NEAR PASCAL CreateUniqueFile(LPSTR szPath, LPSTR szFile)
//
// This function creates a unique file. If the file already exists, it will
// try to create a file with similar name and return the name.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HANDLE NEAR PASCAL CreateUniqueFile(LPTSTR szPath, LPTSTR szScript)
{
  HANDLE hFile;
  LPTSTR  pszSuffix, lpsz;
  UINT   uSuffix;

  pszSuffix = szPath + lstrlen(szPath);
  lpsz = CharPrev(szPath, pszSuffix);
  if (*lpsz != '\\')
  {
    *pszSuffix = '\\';
    pszSuffix++;
  };
  lstrcpy(pszSuffix, szScript);

  // Try the specified filename
  //
  hFile = CreateFile(szPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL, NULL);

  // If the file exists
  //
  if ((hFile == INVALID_HANDLE_VALUE) && (GetLastError() == ERROR_FILE_EXISTS))
  {
    TCHAR szNewName[MAX_PATH];

    // Need to copy it to another name in the same directory
    //
    if (LoadString(g_hInstance, IDS_DEFAULT_SCP, szNewName, MAX_PATH))
    {
      // Increment the file index until a non-duplicated file can be created
      //
      uSuffix = 0;
      do
      {
        wsprintf(pszSuffix, szNewName, uSuffix);
        uSuffix++;
        hFile = CreateFile(szPath, GENERIC_WRITE, 0, NULL, CREATE_NEW,
                           FILE_ATTRIBUTE_NORMAL, NULL);
      }
      while ((hFile == INVALID_HANDLE_VALUE) &&
             (GetLastError() == ERROR_FILE_EXISTS) &&
             (uSuffix < 0x0000FFFF));
    };
  };

  // If we do not have the file, reserve the pathname
  //
  if (hFile == INVALID_HANDLE_VALUE)
  {
    *pszSuffix = '\0';
  };
  return hFile;
}

//****************************************************************************
// HANDLE NEAR PASCAL CreateScriptFile(LPTSTR szScript, LPTSTR szImportFile)
//
// This function creates the script file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HANDLE NEAR PASCAL CreateScriptFile(LPTSTR szScript, LPCTSTR szImportFile)
{
  LPTSTR pszPath, pszShortName;
  LPTSTR pszDir;
  DWORD cb;
  HANDLE hFile;

  // Assume failure
  //
  hFile = INVALID_HANDLE_VALUE;

  // Allocate a buffer for pathname
  //
  if ((pszPath = (LPTSTR)GlobalAlloc(LMEM_FIXED, 2*MAX_PATH)) == NULL)
  {
      TraceMsg(TF_GENERAL, "CONNECT:CreateScriptFile(): Local Alloc failed\n");
    return INVALID_HANDLE_VALUE;
  }
  pszShortName = pszPath+MAX_PATH;

  // Get the default directory
  //
  if (GetWindowsDirectory(pszPath, MAX_PATH) != 0)
  {
    // Get the Windows drive
    //
    pszDir = pszPath;
    while((*pszDir != '\\') && (*pszDir != '\0'))
    {
      pszDir = CharNext(pszDir);
    };

    // Did we find Windows drive?
    //
    if (*pszDir != '\0')
    {
      // Prepare the drive
      //
      cb = (DWORD)(pszDir - pszPath);
      MyMemCpy(szScript, pszPath, cb);
      pszDir = szScript + cb;

      // Get the script filename
      //
      if (GetPrivateProfileString(cszScriptingSection,
                                  cszScriptName,
                                  szNull,
                                  pszShortName,
                                  MAX_PATH,
                                  szImportFile) != 0)
      {
        // Try the favorite script directory
        //
        if (LoadString(g_hInstance, IDS_INI_SCRIPT_DIR, pszDir,
                       MAX_PATH - cb) != 0)
        {
          // Try creating the file
          //
          hFile = CreateUniqueFile(szScript, pszShortName);
        };

        // If we do not have the file yet, try the second favorite
        //
        if (hFile == INVALID_HANDLE_VALUE)
        {
          if (LoadString(g_hInstance, IDS_INI_SCRIPT_SHORTDIR, pszDir,
                         MAX_PATH - cb))
          {
            // Try creating the file
            //
            hFile = CreateUniqueFile(szScript, pszShortName);
          };
        };

        // If we do not have the file yet, try Windows directory
        //
        if (hFile == INVALID_HANDLE_VALUE)
        {
          // Get original Windows directory
          //
          lstrcpy(szScript, pszPath);

          // Try one more time
          //
          hFile = CreateUniqueFile(szScript, pszShortName);
        };
      };
    };
  };

  GlobalFree((HLOCAL)pszPath);
  return hFile;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportScriptFile(LPTSTR szEntryName, LPTSTR szImportFile)
//
// This function imports the script file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD NEAR PASCAL ImportScriptFile(LPRASENTRY lpRasEntry, LPCTSTR szImportFile)
{
  HANDLE hfScript;
  LPTSTR  pszLine;
  LPTSTR  pszFile;
  int    i, iMaxLine;
  UINT   cbSize, cbRet;
  TCHAR   szTmp[4];
  DWORD  dwRet;

  dwRet=ERROR_SUCCESS;

  // If a script section does not exist, do nothing
  //
  if (GetPrivateProfileString(cszScriptingSection,
                              cszScriptName,
                              szNull,
                              szTmp,
                              4,
                              szImportFile) == 0)
  {
    return ERROR_SUCCESS;
  };

  // Allocate a buffer for the script lines
  //
  if ((pszLine = (LPTSTR)GlobalAlloc(LMEM_FIXED, SIZE_ReadBuf+MAX_PATH))
       == NULL)
    {
        TraceMsg(TF_GENERAL, "CONNECT:ImportScriptFile(): Local Alloc failed\n");
    return ERROR_OUTOFMEMORY;
    }

  // Look for script
  //
  if (GetPrivateProfileString(cszScriptSection,
                              NULL,
                              szNull,
                              pszLine,
                              SIZE_ReadBuf,
                              szImportFile) != 0)
  {
    // Get the maximum line number
    //
    pszFile = pszLine;
    iMaxLine = -1;
    while (*pszFile)
    {
      i = Sz2W(pszFile);
      iMaxLine = max(iMaxLine, i);
      pszFile += lstrlen(pszFile)+1;
    };

    // If we have at least one line, we will import the script file
    //
    if (iMaxLine >= 0)
    {
      pszFile = pszLine+SIZE_ReadBuf;

      // Create the script file
      //
      //DebugBreak();
      hfScript = CreateScriptFile(pszFile, szImportFile);
        TraceMsg(TF_GENERAL, "CONNECT:ImportScriptFile(): CreateScriptFile hfScript %d, %s, %s\n",hfScript,pszFile,szImportFile);

      if (hfScript != INVALID_HANDLE_VALUE)
      {
        TCHAR   szLineNum[MAXLONGLEN+1];

        // From The first line to the last line
        //
        for (i = 0; i <= iMaxLine; i++)
        {
          // Read the script line
          //
          wsprintf(szLineNum, TEXT("%d"), i);
          if ((cbSize = GetPrivateProfileString(cszScriptSection,
                                                szLineNum,
                                                szNull,
                                                pszLine,
                                                SIZE_ReadBuf,
                                                szImportFile)) != 0)
          {
            // Write to the script file
            //
            lstrcat(pszLine, TEXT("\x0d\x0a"));
            WriteFile(hfScript, pszLine, cbSize+2, (LPDWORD)&cbRet, NULL);
          };
        };

        CloseHandle(hfScript);

        // Associate it with the phonebook entry
        //
        lstrcpyn(lpRasEntry->szScript, pszFile, RAS_MaxEntryName);
      }
      else
      {
        dwRet = GetLastError();
      };
    }
    else
    {
      dwRet = ERROR_PATH_NOT_FOUND;
    };
  }
  else
  {
    dwRet = ERROR_PATH_NOT_FOUND;
  };
  GlobalFree((HLOCAL)pszLine);

  return dwRet;
}

//****************************************************************************
// DWORD WINAPI RnaValidateImportEntry (LPTSTR)
//
// This function is called to validate an importable file
//
// History:
//  Wed 03-Jan-1996 09:45:01  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD WINAPI RnaValidateImportEntry (LPCTSTR szFileName)
{
  TCHAR  szTmp[4];

  // Get the alias entry name
  //
  return (GetPrivateProfileString(cszEntrySection,
                                  cszEntryName,
                                  szNull,
                                  szTmp,
                                  4,
                                  szFileName) > 0 ?
          ERROR_SUCCESS : ERROR_CORRUPT_PHONEBOOK);
}

//****************************************************************************
// HRESULT ImportConnection (LPCTSTR szFileName, LPTSTR pszEntryName, LPTSTR pszUserName, LPTSTR pszPassword)
//
// This function is called to import an entry from a specified file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//  Sat 16-Mar-1996 10:01:00  -by-  Chris Kauffman [chrisk]
// Modified to return HRESULT and load DLL dynamically
//****************************************************************************

HRESULT ImportConnection (LPCTSTR szFileName, LPTSTR pszEntryName, LPTSTR pszUserName, LPTSTR pszPassword)
{
    LPRASENTRY    lpRasEntry;
    DWORD        dwRet;
    HINSTANCE    hinetcfg;
    FARPROC        fp;
    BOOL        fNeedsRestart;
//#ifdef DEBUG
//    char szDebug[256];
//#endif
    //char          szEntryName[RAS_MaxEntryName+1];
    //char          szUserName[UNLEN+1];
    //char          szPassword[PWLEN+1];
    //BOOL          fNeedsRestart;

    // Get the size of device configuration
    // This also validates an exported file
    //
    if ((dwRet = RnaValidateImportEntry(szFileName)) != ERROR_SUCCESS)
    {
        return dwRet;
    };

    // Allocate a buffer for entry and device config
    //
    if ((lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR, sizeof(RASENTRY))) == NULL)
    {
        return ERROR_OUTOFMEMORY;
    };

    // Get the entry name
    // Need to find a good name for it and remember it as an alias
    //
    GetPrivateProfileString(cszEntrySection,
                          cszEntryName,
                          szNull,
                          pszEntryName,
                          RAS_MaxEntryName+1,
                          szFileName);

    GetPrivateProfileString(cszUserSection,
                          cszUserName,
                          szNull,
                          pszUserName,
                          UNLEN+1,
                          szFileName);
  
    GetPrivateProfileString(cszUserSection,
                          cszPassword,
                          szNull,
                          pszPassword,
                          PWLEN+1,
                          szFileName);
  
    if ((dwRet = ImportPhoneInfo(lpRasEntry, szFileName))
          == ERROR_SUCCESS)
    {
        // Get device name, type and config
        //
        GetPrivateProfileString(cszDeviceSection,
                              cszDeviceType,
                              szNull,
                              lpRasEntry->szDeviceType,
                              RAS_MaxDeviceType,
                              szFileName);
        // Get Server Type settings
        //
        ImportServerInfo(lpRasEntry, szFileName);

        // Get IP address
        //
        ImportIPInfo(lpRasEntry, szFileName);

        // Import the script file
        //
        if ((dwRet = ImportScriptFile(lpRasEntry, szFileName)) != ERROR_SUCCESS)
        {
            TraceMsg(TF_GENERAL, "CONNECT:ImportScriptFile Failed with the error %d,%s,%s",dwRet,szFileName,lpRasEntry->szScript);
        }

        lpRasEntry->dwSize = sizeof(RASENTRY);

        // Load and Locate AutoRunSignUpWizard entry point
        //

        hinetcfg = LoadLibrary(TEXT("INETCFG.DLL"));
        AssertMsg(hinetcfg,"Cannot find INETCFG.DLL");
        if (!hinetcfg) 
        {
            dwRet = GetLastError();
            goto ImportConnectionExit;
        }
        fp = GetProcAddress(hinetcfg,AUTORUNSIGNUPWIZARDAPI);
        AssertMsg(fp,"Cannot find AutoRunSignupWizard entry point");
        if (!fp)
        {
            dwRet = GetLastError();
            goto ImportConnectionExit;
        }

        // Insert Autodialer
        //

        lstrcpy(lpRasEntry->szAutodialDll,TEXT("ICWDIAL.DLL"));
        lstrcpy(lpRasEntry->szAutodialFunc,TEXT("AutoDialHandler"));
        TraceMsg(TF_GENERAL, "CONNECT:Autodialer installed at %s, %s.\n",lpRasEntry->szAutodialDll,lpRasEntry->szAutodialFunc);

        // Call InetClientConfig
        //

//        PreWriteConnectoid(pszEntryName,lpRasEntry);

        dwRet =  ((PFNAUTORUNSIGNUPWIZARD)fp)(
                    NULL,
                    NULL,
                    pszEntryName,
                    lpRasEntry,
                    pszUserName,
                    pszPassword,
                    NULL,
                    NULL,
                    INETCFG_SETASAUTODIAL |
                       INETCFG_INSTALLRNA |
                    INETCFG_INSTALLTCP |
                    INETCFG_OVERWRITEENTRY,
                    &fNeedsRestart);
#if !defined(WIN16)
        RasSetEntryPropertiesScriptPatch(lpRasEntry->szScript,pszEntryName);
#endif //!Win16
        //RestoreDeskTopInternetCommand();

        TraceMsg(TF_GENERAL, "CONNECT:EntryName %s, User %s, Password %s, Number %s\n",pszEntryName,pszUserName,pszPassword,lpRasEntry->szLocalPhoneNumber);
        AssertMsg(!fNeedsRestart,"We have to reboot AGAIN!!");
    }

    // Exit and cleanup
    //

ImportConnectionExit:
    if (hinetcfg) FreeLibrary(hinetcfg);
    GlobalFree((HLOCAL)lpRasEntry);
    return dwRet;
}


// ############################################################################
HRESULT CreateEntryFromDUNFile(PTSTR pszDunFile)
{
    TCHAR szFileName[MAX_PATH];
    //char szEntryName[RAS_MaxEntryName+1];
    TCHAR szUserName[UNLEN+1];
    TCHAR szPassword[PWLEN+1];
    LPTSTR pszTemp;
    HRESULT hr;

    hr = ERROR_SUCCESS;

    // Get fully qualified path name
    //

    if (!SearchPath(GIGetAppDir(),pszDunFile,NULL,MAX_PATH,&szFileName[0],&pszTemp))
    {
        //MsgBox(IDS_CANTREADDUNFILE,MB_APPLMODAL | MB_ICONERROR);
        hr = ERROR_FILE_NOT_FOUND;
        goto CreateEntryFromDUNFileExit;
    }

    // save current DUN file name in global (for ourself)
    SetCurrentDUNFile(&szFileName[0]);

    hr = ImportConnection (&szFileName[0], g_szEntryName, szUserName, szPassword);
    //if (hr != ERROR_SUCCESS) 
    //{
    //    MsgBox(IDS_CANTREADDUNFILE,MB_APPLMODAL | MB_ICONERROR);
    //    goto CreateEntryFromDUNFileExit;
    //}// else {
//
//        // place the name of the connectoid in the registry
//        //
    if (ERROR_SUCCESS != (StoreInSignUpReg((LPBYTE)g_szEntryName, lstrlen(g_szEntryName), REG_SZ, RASENTRYVALUENAME)))
    {
        MsgBox(IDS_CANTSAVEKEY,MB_MYERROR);
        goto CreateEntryFromDUNFileExit;
    }
//    }
CreateEntryFromDUNFileExit:
    return hr;
}

// ############################################################################
BOOL FSz2Dw(PCTSTR pSz,DWORD *dw)
{
    DWORD val = 0;
    while (*pSz && *pSz != '.')
    {
        if (*pSz >= '0' && *pSz <= '9')
        {
            val *= 10;
            val += *pSz++ - '0';
        }
        else
        {
            return FALSE;  //bad number
        }
    }
    *dw = val;
    return (TRUE);
}

// ############################################################################
BOOL BreakUpPhoneNumber(RASENTRY *prasentry, LPTSTR pszPhone)
{
    PTSTR         pszStart,pszNext, pszLim;
//    LPPHONENUM     ppn;
    
    if (!pszPhone) return FALSE; // skip if no number
    
    pszLim = pszPhone + lstrlen(pszPhone);    // find end of string

    //ppn = (fMain) ? &(pic->PhoneNum) : &(pic->PhoneNum2);
    
    ////Get the country ID...
    //ppn->dwCountryID = PBKDWCountryId();
    
    // Get Country Code from phone number...
    pszStart = _tcschr(pszPhone,'+');
    if(!pszStart) goto error; // bad format

    // get country code
    pszStart = GetNextNumericChunk(pszStart, pszLim, &pszNext);
    if(!pszStart || !pszNext) goto error; // bad format
    //ppn->dwCountryCode = Sz2Dw(pszStart);
    FSz2Dw(pszStart,&prasentry->dwCountryCode);
    pszStart = pszNext;
        
    //Now get the area code
    pszStart = GetNextNumericChunk(pszStart, pszLim, &pszNext);
    if(!pszStart || !pszNext) goto error; // bad format
    //lstrcpy(ppn->szAreaCode, pszStart);
    lstrcpyn(prasentry->szAreaCode,pszStart,ARRAYSIZE(prasentry->szAreaCode));
    pszStart = pszNext;

    //now the local phone number (everything from here to : or end)
    pszNext = _tcschr(pszStart, ':');
    if(pszNext) *pszNext='\0';
    //lstrcpy(ppn->szLocal,pszStart);
    lstrcpyn(prasentry->szLocalPhoneNumber,pszStart,RAS_MaxPhoneNumber);

    //no extension. what is extension?
    //ppn->szExtension[0] = '\0';
    //GlobalFree(pszPhone);
    return TRUE;

error:
    // This means number is not canonical. Set it as local number anyway!
    // memset(ppn, 0, sizeof(*ppn));
    // Bug#422: need to strip stuff after : or dial fails!!
    pszNext = _tcschr(pszPhone, ':');
    if(pszNext) *pszNext='\0';
    //lstrcpy(ppn->szLocal,pszPhone);
    lstrcpy(prasentry->szLocalPhoneNumber,pszPhone);
    //GlobalFree(pszPhone);
    return TRUE;
}


// ############################################################################
int Sz2W (LPCTSTR szBuf)
{
    DWORD dw;
    if (FSz2Dw(szBuf,&dw))
    {
        return (WORD)dw;
    }
    return 0;
}

// ############################################################################
int FIsDigit( int c )
{
    TCHAR szIn[2];
    WORD rwOut[2];
    szIn[0] = (TCHAR)c;
    szIn[1] = '\0';
    GetStringTypeEx(LOCALE_USER_DEFAULT,CT_CTYPE1,szIn,-1,rwOut);
    return rwOut[0] & C1_DIGIT;
}

// ############################################################################
void *MyMemCpy(void *dest,const void *src, size_t count)
{
    LPBYTE pbDest = (LPBYTE)dest;
    LPBYTE pbSrc = (LPBYTE)src;
    LPBYTE pbEnd = (LPBYTE)((DWORD_PTR)src + count);
    while (pbSrc < pbEnd)
    {
        *pbDest = *pbSrc;
        pbSrc++;
        pbDest++;
    }
    return dest;
}


// ############################################################################
HRESULT ReadSignUpReg(LPBYTE lpbData, DWORD *pdwSize, DWORD dwType, LPCTSTR pszKey)
{
    HRESULT hr = ERROR_ACCESS_DENIED;
    HKEY hKey = 0;

    hr = RegOpenKey(HKEY_LOCAL_MACHINE,SIGNUPKEY,&hKey);
    if (hr != ERROR_SUCCESS) goto ReadSignUpRegExit;
    hr = RegQueryValueEx(hKey,pszKey,0,&dwType,lpbData,pdwSize);

ReadSignUpRegExit:
    if (hKey) RegCloseKey (hKey);
    return hr;
}

// ############################################################################
HRESULT StoreInSignUpReg(LPBYTE lpbData, DWORD dwSize, DWORD dwType, LPCTSTR pszKey)
{
    HRESULT hr = ERROR_ACCESS_DENIED;
    HKEY hKey = 0;

    hr = RegOpenKey(HKEY_LOCAL_MACHINE,SIGNUPKEY,&hKey);
    if (hr != ERROR_SUCCESS) goto ReadSignUpRegExit;
    hr = RegSetValueEx(hKey,pszKey,0,dwType,lpbData,sizeof(TCHAR)*dwSize);

ReadSignUpRegExit:
    if (hKey) RegCloseKey (hKey);
    return hr;
}

// ############################################################################
PTSTR GetNextNumericChunk(PTSTR psz, PTSTR pszLim, PTSTR* ppszNext)
{
    PTSTR pszEnd;

    // init for error case
    *ppszNext = NULL;
    // skip non numerics if any to start of next numeric chunk
    while(*psz<'0' || *psz>'9')
    {
        if(psz >= pszLim) return NULL;
        psz++;
    }
    // skip all numerics to end of country code
    for(pszEnd=psz; *pszEnd>='0' && *pszEnd<='9' && pszEnd<pszLim; pszEnd++)
        ;
    // zap whatever delimiter there was to terminate this chunk
    *pszEnd++ = '\0';
    // return ptr to next chunk (pszEnd now points to it)
    if(pszEnd<pszLim) 
        *ppszNext = pszEnd;
        
    return psz;    // return ptr to start of chunk
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdial\sources.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwdial

MAJORCOMP=GETCONN
MINORCOMP=ICWDIAL

TARGETNAME=ICWDIAL
TARGETTYPE=DYNLINK
TARGETPATH=obj

DLLENTRY=DllEntryPoint
DLLBASE=$(DEFBASEADDR)
DLLDEF=..\icwdial.def

NOT_LEAN_AND_MEAN   =1
RCNOFONTMAP         =1
C_DEFINES           =-DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

USE_MSVCRT          = 1

SOURCES=                \
    ..\icwdial.rc       \
    ..\autodial.cpp     \
    ..\dialdlg.cpp      \
    ..\dialerr.cpp      \
    ..\dialutil.cpp     \
    ..\dlapi.cpp        \
    ..\icwerr.cpp       \
    ..\import.cpp       \
    ..\mimedl.cpp       \
    ..\rnaapi.cpp       \
    ..\rnawnd.cpp       \

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib      \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\tapi32.lib        \
    $(SDK_LIB_PATH)\advapi32.lib      \
    $(SDK_LIB_PATH)\gdi32.lib         \
!if defined(NOT_UNICODE)
    $(GETCONN_DIR)\lib\ansi\$O\stocklib.lib
!else
    $(GETCONN_DIR)\lib\unicode\$O\stocklib.lib
!endif

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pch.hpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdial\rnaapi.cpp ===
/*-----------------------------------------------------------------------------
    rnaapi.cpp

    Wrapper to softlink to RNAPH and RASAPI32.DLL

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

    Authors:
        ChrisK        ChrisKauffman

    History:
        1/29/96        ChrisK    Created
        7/22/96        ChrisK    Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"

static const TCHAR cszRASAPI32_DLL[] = TEXT("RASAPI32.DLL");
static const TCHAR cszRNAPH_DLL[] = TEXT("RNAPH.DLL");
static const TCHAR cszRAS16[] = TEXT("RASC16IE.DLL");


#ifdef UNICODE
static const CHAR cszRasEnumDevices[] = "RasEnumDevicesW";
static const CHAR cszRasValidateEntryNamePlain[] = "RasValidateEntryName";
static const CHAR cszRasValidateEntryName[] = "RasValidateEntryNameW";
static const CHAR cszRasSetEntryProperties[] = "RasSetEntryPropertiesW";
static const CHAR cszRasGetEntryProperties[] = "RasGetEntryPropertiesW";
static const CHAR cszRasDeleteEntry[] = "RasDeleteEntryW";
static const CHAR cszRasHangUp[] = "RasHangUpW";
static const CHAR cszRasGetConnectStatus[] = "RasGetConnectStatusW";
static const CHAR cszRasDial[] = "RasDialW";
static const CHAR cszRasEnumConnections[] = "RasEnumConnectionsW";
static const CHAR cszRasGetEntryDialParams[] = "RasGetEntryDialParamsW";
static const CHAR cszRasGetCountryInfo[] = "RasGetCountryInfoW";
#else  // UNICODE
static const CHAR cszRasEnumDevices[] = "RasEnumDevicesA";
static const CHAR cszRasValidateEntryNamePlain[] = "RasValidateEntryName";
static const CHAR cszRasValidateEntryName[] = "RasValidateEntryNameA";
static const CHAR cszRasSetEntryProperties[] = "RasSetEntryPropertiesA";
static const CHAR cszRasGetEntryProperties[] = "RasGetEntryPropertiesA";
static const CHAR cszRasDeleteEntry[] = "RasDeleteEntryA";
static const CHAR cszRasHangUp[] = "RasHangUpA";
static const CHAR cszRasGetConnectStatus[] = "RasGetConnectStatusA";
static const CHAR cszRasDial[] = "RasDialA";
static const CHAR cszRasEnumConnections[] = "RasEnumConnectionsA";
static const CHAR cszRasGetEntryDialParams[] = "RasGetEntryDialParamsA";
static const CHAR cszRasGetCountryInfo[] = "RasGetCountryInfoA";
#endif // UNICODE

// on NT we have to call RasGetEntryProperties with a larger buffer than RASENTRY.
// This is a bug in WinNT4.0 RAS, that didn't get fixed.
//
#define RASENTRY_SIZE_PATCH (7 * sizeof(DWORD))

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RNAAPI
//
//    Synopsis:    Initialize class members and load DLLs
//
//    Arguments:    None
//
//    Returns:    None
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
RNAAPI::RNAAPI()
{
#if defined(WIN16)
    m_hInst = LoadLibrary(cszRAS16); 
    m_hInst2 = NULL;
#else
    m_hInst = LoadLibrary(cszRASAPI32_DLL);
    if (FALSE == IsNT ())
    {
        //
        // we only load RNAPH.DLL if it is not NT
        // MKarki (5/4/97) - Fix for Bug #3378
        //
        m_hInst2 = LoadLibrary(cszRNAPH_DLL);
    }
    else
    {
        m_hInst2 =  NULL;
    }
#endif    

    m_fnRasEnumDeviecs = NULL;
    m_fnRasValidateEntryName = NULL;
    m_fnRasSetEntryProperties = NULL;
    m_fnRasGetEntryProperties = NULL;
    m_fnRasDeleteEntry = NULL;
    m_fnRasHangUp = NULL;
    m_fnRasGetConnectStatus = NULL;
    m_fnRasEnumConnections = NULL;
    m_fnRasDial = NULL;
    m_fnRasGetEntryDialParams = NULL;
    m_fnRasGetCountryInfo = NULL;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::~RNAAPI
//
//    Synopsis:    release DLLs
//
//    Arguments:    None
//
//    Returns:    None
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
RNAAPI::~RNAAPI()
{
    //
    // Clean up
    //
    if (m_hInst) FreeLibrary(m_hInst);
    if (m_hInst2) FreeLibrary(m_hInst2);
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasEnumDevices
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasEnumDevices(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb,
                             LPDWORD lpcDevices)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasEnumDevices,(FARPROC*)&m_fnRasEnumDeviecs);

    if (m_fnRasEnumDeviecs)
        dwRet = (*m_fnRasEnumDeviecs) (lpRasDevInfo, lpcb, lpcDevices);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::LoadApi
//
//    Synopsis:    If the given function pointer is NULL, then try to load the API
//                from the first DLL, if that fails, try to load from the second
//                DLL
//
//    Arguments:    pszFName - the name of the exported function
//                pfnProc - point to where the proc address will be returned
//
//    Returns:    TRUE - success
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
BOOL RNAAPI::LoadApi(LPCSTR pszFName, FARPROC* pfnProc)
{
    if (*pfnProc == NULL)
    {
        // Look for the entry point in the first DLL
        if (m_hInst)
            *pfnProc = GetProcAddress(m_hInst,pszFName);
        
        // if that fails, look for the entry point in the second DLL
        if (m_hInst2 && !(*pfnProc))
            *pfnProc = GetProcAddress(m_hInst2,pszFName);
    }

    return (pfnProc != NULL);
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasGetConnectStatus
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        7/16/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetConnectStatus(HRASCONN hrasconn,LPRASCONNSTATUS lprasconnstatus)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasGetConnectStatus,(FARPROC*)&m_fnRasGetConnectStatus);

    if (m_fnRasGetConnectStatus)
        dwRet = (*m_fnRasGetConnectStatus) (hrasconn,lprasconnstatus);

#if defined(WIN16) && defined(DEBUG)
    TraceMsg(TF_GENERAL, ("RasGetConnectStatus returned %lu\r\n", dwRet);    
#endif
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasValidateEntryName
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasValidateEntryName(LPTSTR lpszPhonebook,LPTSTR lpszEntry)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasValidateEntryNamePlain,(FARPROC*)&m_fnRasValidateEntryName);

    LoadApi(cszRasValidateEntryName,(FARPROC*)&m_fnRasValidateEntryName);

    if (m_fnRasValidateEntryName)
        dwRet = (*m_fnRasValidateEntryName) (lpszPhonebook, lpszEntry);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasSetEntryProperties
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasSetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
                                    LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize,
                                    LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasSetEntryProperties,(FARPROC*)&m_fnRasSetEntryProperties);

#if !defined(WIN16)
#define RASGETCOUNTRYINFO_BUFFER_SIZE 256


    if (0 == ((LPRASENTRY)lpbEntryInfo)->dwCountryCode)
    {
        if( !( ((LPRASENTRY)lpbEntryInfo)->dwfOptions & RASEO_UseCountryAndAreaCodes) )
        {
            // jmazner 10/10/96
            // if this is a dial as is number, then RasGetEntryProperties will not have
            // filled in the fields below.  This makes sense.
            // However, RasSetEntryProperties fails to ignore these fileds for a dial-as-is number,
            // the hack below in the else clause takes care of an empty countryCode, but
            // if the CountryID is missing too, it doesn't work.
            // So deal with such a case here, filling in the fields that RasSetEntry will validate.
            ((LPRASENTRY)lpbEntryInfo)->dwCountryID = 1;
            ((LPRASENTRY)lpbEntryInfo)->dwCountryCode = 1;
            ((LPRASENTRY)lpbEntryInfo)->szAreaCode[0] = '8';
            ((LPRASENTRY)lpbEntryInfo)->szAreaCode[1] = '\0';
        }
        else
        {
            BYTE rasCI[RASGETCOUNTRYINFO_BUFFER_SIZE];
            LPRASCTRYINFO prasCI;
            DWORD dwSize;
            DWORD dw;
            prasCI = (LPRASCTRYINFO)rasCI;
            ZeroMemory(prasCI,sizeof(rasCI));
            prasCI->dwSize = sizeof(RASCTRYINFO);
            dwSize = sizeof(rasCI);

            Assert(((LPRASENTRY)lpbEntryInfo)->dwCountryID);
            prasCI->dwCountryID = ((LPRASENTRY)lpbEntryInfo)->dwCountryID;

            dw = RNAAPI::RasGetCountryInfo(prasCI,&dwSize);
            if (ERROR_SUCCESS == dw)
            {
                Assert(prasCI->dwCountryCode);
                ((LPRASENTRY)lpbEntryInfo)->dwCountryCode = prasCI->dwCountryCode;
            } 
            else
            {
                AssertMsg(0,"Unexpected error from RasGetCountryInfo.\r\n");
            }
        }
    }
#endif

    if (m_fnRasSetEntryProperties)
        dwRet = (*m_fnRasSetEntryProperties) (lpszPhonebook, lpszEntry,
                                    lpbEntryInfo, dwEntryInfoSize,
                                    lpbDeviceInfo, dwDeviceInfoSize);
#if !defined(WIN16)
    RasSetEntryPropertiesScriptPatch(((RASENTRY*)&(*lpbEntryInfo))->szScript, lpszEntry);
#endif

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasGetEntryProperties
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//                jmazner    9/16/96 Added bUsePatch variable to allow calls with buffers = NULL and InfoSizes = 0.
//                                See RasGetEntryProperties docs to learn why this is needed.
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
                                    LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize,
                                    LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize)
{
    DWORD    dwRet = ERROR_DLL_NOT_FOUND;
    LPBYTE    lpbEntryInfoPatch = NULL;
    LPDWORD    lpdwEntryInfoPatchSize = NULL;
    BOOL    bUsePatch = TRUE;

#if defined(WIN16)
    bUsePatch = FALSE;
#endif

    if( (NULL == lpbEntryInfo) && (NULL == lpbDeviceInfo) )
    {

        Assert( NULL != lpdwEntryInfoSize );
        Assert( NULL != lpdwDeviceInfoSize );

        Assert( 0 == *lpdwEntryInfoSize );
        Assert( 0 == *lpdwDeviceInfoSize );

        // we're here to ask RAS what size these buffers need to be, don't use the patch stuff
        // (see RasGetEntryProperties docs)
        bUsePatch = FALSE;
    }

    if( bUsePatch )
    {
        Assert(lpbEntryInfo && lpdwEntryInfoSize);
        Assert( (*lpdwEntryInfoSize) >= sizeof(RASENTRY) );

        //
        // We are going to fake out RasGetEntryProperties by creating a slightly larger
        // temporary buffer and copying the data in and out.
        //
        lpdwEntryInfoPatchSize = (LPDWORD) GlobalAlloc(GPTR, sizeof(DWORD));
        if (NULL == lpdwEntryInfoPatchSize)
            return ERROR_NOT_ENOUGH_MEMORY;


        *lpdwEntryInfoPatchSize = (*lpdwEntryInfoSize) + RASENTRY_SIZE_PATCH;
        lpbEntryInfoPatch = (LPBYTE)GlobalAlloc(GPTR,*lpdwEntryInfoPatchSize);
        if (NULL == lpbEntryInfoPatch)
            return ERROR_NOT_ENOUGH_MEMORY;
    
        // RAS expects the dwSize field to contain the size of the LPRASENTRY struct
        // (used to check which version of the struct we're using) rather than the amount
        // of memory actually allocated to the pointer.
        //((LPRASENTRY)lpbEntryInfoPatch)->dwSize = *lpdwEntryInfoPatchSize;
        ((LPRASENTRY)lpbEntryInfoPatch)->dwSize = sizeof(RASENTRY);
    }
    else
    {
        lpbEntryInfoPatch = lpbEntryInfo;
        lpdwEntryInfoPatchSize = lpdwEntryInfoSize;
    }


    // Look for the API if we haven't already found it
    LoadApi(cszRasGetEntryProperties,(FARPROC*)&m_fnRasGetEntryProperties);

    if (m_fnRasGetEntryProperties)
        dwRet = (*m_fnRasGetEntryProperties) (lpszPhonebook, lpszEntry,
                                    lpbEntryInfoPatch, lpdwEntryInfoPatchSize,
                                    lpbDeviceInfo, lpdwDeviceInfoSize);

    TraceMsg(TF_GENERAL, "ICWDIAL: RasGetEntryProperties returned %lu\r\n", dwRet);    

    if( bUsePatch )
    {
        //
        // Copy out the contents of the temporary buffer UP TO the size of the original buffer
        //
        Assert(lpbEntryInfoPatch);
        memcpy(lpbEntryInfo,lpbEntryInfoPatch,*lpdwEntryInfoSize);
        GlobalFree(lpbEntryInfoPatch);
        lpbEntryInfoPatch = NULL;
    }

    //
    // We are again faking Ras functionality here by over writing the size value;
    // This is so that RasSetEntryProperties will not choke...
    if( NULL != lpbEntryInfo )
    {
        *lpdwEntryInfoSize = sizeof(RASENTRY);
    }

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasDeleteEntry
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasDeleteEntry(LPTSTR lpszPhonebook, LPTSTR lpszEntry)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasDeleteEntry,(FARPROC*)&m_fnRasDeleteEntry);

    if (m_fnRasDeleteEntry)
        dwRet = (*m_fnRasDeleteEntry) (lpszPhonebook, lpszEntry);
    
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasHangUp
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasHangUp(HRASCONN hrasconn)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasHangUp,(FARPROC*)&m_fnRasHangUp);

    if (m_fnRasHangUp)
    {
        dwRet = (*m_fnRasHangUp) (hrasconn);
#if !defined(WIN16)
        Sleep(3000);
#endif
    }

    return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasDial(LPRASDIALEXTENSIONS lpRasDialExtensions,LPTSTR lpszPhonebook,
                      LPRASDIALPARAMS lpRasDialParams, DWORD dwNotifierType,
                      LPVOID lpvNotifier, LPHRASCONN lphRasConn)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasDial,(FARPROC*)&m_fnRasDial);

    if (m_fnRasDial)
    {
        dwRet = (*m_fnRasDial) (lpRasDialExtensions,lpszPhonebook,lpRasDialParams,
                                dwNotifierType,lpvNotifier,lphRasConn);
    }
    return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasEnumConnections(LPRASCONN lprasconn,LPDWORD lpcb,LPDWORD lpcConnections)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasEnumConnections,(FARPROC*)&m_fnRasEnumConnections);

    if (m_fnRasEnumConnections)
    {
        dwRet = (*m_fnRasEnumConnections) (lprasconn,lpcb,lpcConnections);
    }
    return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasGetEntryDialParams(LPTSTR lpszPhonebook,LPRASDIALPARAMS lprasdialparams,
                                    LPBOOL lpfPassword)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasGetEntryDialParams,(FARPROC*)&m_fnRasGetEntryDialParams);

    if (m_fnRasGetEntryDialParams)
    {
        dwRet = (*m_fnRasGetEntryDialParams) (lpszPhonebook,lprasdialparams,lpfPassword);
    }
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasGetCountryInfo
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        8/16/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetCountryInfo(LPRASCTRYINFO lprci, LPDWORD lpdwSize)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasGetCountryInfo,(FARPROC*)&m_fnRasGetCountryInfo);

    if (m_fnRasGetCountryInfo)
    {
        dwRet = (*m_fnRasGetCountryInfo) (lprci,lpdwSize);
    }
    return dwRet;
}

#if !defined(WIN16)
static const TCHAR cszDeviceSwitch[] = TEXT("DEVICE=switch");
static const TCHAR cszRasPBKFilename[] = TEXT("\\ras\\rasphone.pbk");
#define SCRIPT_PATCH_BUFFER_SIZE 2048
#define SIZEOF_NULL 1
static const TCHAR cszType[] = TEXT("Type=");
//+----------------------------------------------------------------------------
//
//    Function    RemoveOldScriptFilenames
//
//    Synopsis    Given the data returned from a call to GetPrivateProfileSection
//                remove any information about existing script file so that
//                we can replace it with the new script information.
//
//    Arguments    lpszData - pointer to input data
//
//    Returns        TRUE - success
//                lpdwSize - size of resulting data
//
//    History        10/2/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
static BOOL RemoveOldScriptFilenames(LPTSTR lpszData, LPDWORD lpdwSize)
{
    BOOL bRC = FALSE;
    LPTSTR lpszTemp = lpszData;
    LPTSTR lpszCopyTo = lpszData;
    INT iLen = 0;

    //
    // Walk through list of name value pairs
    //
    if (!lpszData || '\0' == lpszData[0])
        goto RemoveOldScriptFilenamesExit;
    while (*lpszTemp) {
        if (0 != lstrcmpi(lpszTemp,cszDeviceSwitch))
        {
            //
            //    Keep pairs that don't match criteria
            //
            iLen = lstrlen(lpszTemp);
            if (lpszCopyTo != lpszTemp)
            {
                memmove(lpszCopyTo, lpszTemp, iLen+1);
            }
            lpszCopyTo += iLen + 1;
            lpszTemp += iLen + 1;
        }
        else
        {
            //
            // Skip the pair that matches and the one after that
            //
            lpszTemp += lstrlen(lpszTemp) + 1;
            if (*lpszTemp)
                lpszTemp += lstrlen(lpszTemp) + 1;
        }
    }

    //
    // Add second trailing NULL
    //
    *lpszCopyTo = '\0';
    //
    // Return new size
    // Note the size does not include the final \0
    //
    *lpdwSize = (DWORD)(lpszCopyTo - lpszData);

    bRC = TRUE;
RemoveOldScriptFilenamesExit:
    return bRC;
}
//+----------------------------------------------------------------------------
//
//    Function    GleanRealScriptFileName
//
//    Synopsis    Given a string figure out the real filename
//                Due to another NT4.0 Ras bug, script filenames returned by
//                RasGetEntryProperties may contain a leading garbage character
//
//    Arguments    lppszOut - pointer that will point to real filename
//                lpszIn - points to current filename
//
//    Returns        TRUE - success
//                *lppszOut - points to real file name, remember to free the memory
//                    in this variable when you are done.  And don't talk with
//                    your mouth full - mom.
//
//    History        10/2/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
static BOOL GleanRealScriptFileName(LPTSTR *lppszOut, LPTSTR lpszIn)
{
    BOOL bRC = FALSE;
    LPTSTR lpsz = NULL;
    DWORD dwRet = 0;

    //
    // Validate parameters
    //
    Assert(lppszOut && lpszIn);
    if (!(lppszOut && lpszIn))
        goto GleanFilenameExit;

    //
    // first determine if the filename is OK as is
    //
    dwRet = GetFileAttributes(lpszIn);
    if ('\0' != lpszIn[0] && 0xFFFFFFFF == dwRet) // Empty filename is OK
    {
        //
        // Check for the same filename without the first character
        //
        lpsz = lpszIn+1;
        dwRet = GetFileAttributes(lpsz);
        if (0xFFFFFFFF == dwRet)
            goto GleanFilenameExit;
    } 
    else
    {
        lpsz = lpszIn;
    }

    //
    // Return filename
    //
    *lppszOut = (LPTSTR)GlobalAlloc(GPTR,sizeof(TCHAR)*(lstrlen(lpsz)+1));
    if (!(*lppszOut))
    {
        goto GleanFilenameExit;
    }
    
    lstrcpy(*lppszOut,lpsz);

    bRC = TRUE;
GleanFilenameExit:
    return bRC;
}
//+----------------------------------------------------------------------------
//
//    Function    IsScriptPatchNeeded
//
//    Synopsis    Check version to see if patch is needed
//
//    Arguments    lpszData - contents of section in rasphone.pbk
//                lpszScript - name of script file
//
//    Returns        TRUE - patch is needed
//
//    Histroy        10/1/96
//
//-----------------------------------------------------------------------------
static BOOL IsScriptPatchNeeded(LPTSTR lpszData, LPTSTR lpszScript)
{
    BOOL bRC = FALSE;
    LPTSTR lpsz = lpszData;
    TCHAR szType[MAX_PATH + sizeof(cszType)/sizeof(TCHAR) + 1];

    lstrcpy(szType,cszType);
    lstrcat(szType,lpszScript);

    Assert(MAX_PATH + sizeof(cszType)/sizeof(TCHAR) +1 > lstrlen(szType));

    lpsz = lpszData;
    while(*lpsz)
    {
        if (0 == lstrcmp(lpsz,cszDeviceSwitch))
        {
            lpsz += lstrlen(lpsz)+1;
            // if we find a DEVICE=switch statement and the script is empty
            // then we'll have to patch the entry
            if (0 == lpszScript[0])
                bRC = TRUE;
            // if we find a DEVICE=switch statement and the script is different
            // then we'll have to patch the entry
            else if (0 != lstrcmp(lpsz,szType))
                bRC = TRUE;
            // if we find a DEVICE=switch statement and the script is the same
            // then we DON'T have to patch it
            else
                bRC = FALSE;
            break; // get out of while statement
        }
        lpsz += lstrlen(lpsz)+1;
    }
    
    if ('\0' == *lpsz)
    {
        // if we didn't find DEVICE=switch statement and the script is empty
        // then we DON'T have to patch it
        if ('\0' == lpszScript[0])
            bRC = FALSE;
        // if we didn't find DEVICE=switch statement and the script is not
        // empty the we'll have to patch it.
        else
            bRC = TRUE;
    }

    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function    GetRasPBKFilename
//
//    Synopsis    Find the Ras phone book and return the fully qualified path
//                in the buffer
//
//    Arguments    lpBuffer - pointer to buffer
//                dwSize    - size of buffer (must be at least MAX_PATH)
//
//    Returns        TRUE - success
//
//    History        10/1/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
static BOOL GetRasPBKFilename(LPTSTR lpBuffer, DWORD dwSize)
{
    BOOL bRC = FALSE;
    UINT urc = 0;
    LPTSTR lpsz = NULL;

    //
    // Validate parameters
    //
    Assert(lpBuffer && (dwSize >= MAX_PATH));
    //
    // Get path to system directory
    //
    urc = GetSystemDirectory(lpBuffer,dwSize);
    if (0 == urc || urc > dwSize)
        goto GetRasPBKExit;
    //
    // Check for trailing '\' and add \ras\rasphone.pbk to path
    //
    lpsz = &lpBuffer[lstrlen(lpBuffer)-1];
    if ('\\' != *lpsz)
        lpsz++;
    lstrcpy(lpsz,cszRasPBKFilename);

    bRC = TRUE;
GetRasPBKExit:
    return bRC;
}
//+----------------------------------------------------------------------------
//
//    Function    RasSetEntryPropertiesScriptPatch
//
//    Synopsis    Work around bug in NT4.0 that does not save script file names
//                to RAS phone book entries
//
//    Arguments    lpszScript - name of script file
//                lpszEntry - name of phone book entry
//
//    Returns        TRUE - success
//
//    Histroy        10/1/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
BOOL WINAPI RasSetEntryPropertiesScriptPatch(LPTSTR lpszScript, LPTSTR lpszEntry)
{
    BOOL bRC = FALSE;
    TCHAR szRasPBK[MAX_PATH+1];
    TCHAR szData[SCRIPT_PATCH_BUFFER_SIZE];
    DWORD dwrc = 0;
    LPTSTR lpszTo;
    LPTSTR lpszFixedFilename = NULL;

    //
    // Validate parameters
    //
    Assert(lpszScript && lpszEntry);
    TraceMsg(TF_GENERAL, "ICWDIAL: ScriptPatch script %s, entry %s.\r\n", lpszScript,lpszEntry);    

    //
    // Verify and fix filename
    //
    if (!GleanRealScriptFileName(&lpszFixedFilename, lpszScript))
        goto ScriptPatchExit;

    //
    // Get the path to the RAS phone book
    //
    if (!GetRasPBKFilename(szRasPBK,MAX_PATH+1))
        goto ScriptPatchExit;
    //
    //    Get data
    //
    ZeroMemory(szData,SCRIPT_PATCH_BUFFER_SIZE);
    dwrc = GetPrivateProfileSection(lpszEntry,szData,SCRIPT_PATCH_BUFFER_SIZE,szRasPBK);
    if (SCRIPT_PATCH_BUFFER_SIZE == (dwrc + 2))
        goto ScriptPatchExit;
    //
    // Verify version
    //
    if (!IsScriptPatchNeeded(szData,lpszFixedFilename))
    {
        bRC = TRUE;
        goto ScriptPatchExit;
    }

    //
    // Clean up data
    //
    RemoveOldScriptFilenames(szData, &dwrc);
    //
    // Make sure there is enough space left to add new data
    //
    if (SCRIPT_PATCH_BUFFER_SIZE <=
        (dwrc + sizeof(cszDeviceSwitch)/sizeof(TCHAR) + SIZEOF_NULL + sizeof(cszType)/sizeof(TCHAR) + MAX_PATH))
        goto ScriptPatchExit;
    //
    // Add data
    //
    if ('\0' != lpszFixedFilename[0])
    {
        lpszTo = &szData[dwrc];
        lstrcpy(lpszTo,cszDeviceSwitch);
        lpszTo += sizeof(cszDeviceSwitch)/sizeof(TCHAR);
        lstrcpy(lpszTo,cszType);
        lpszTo += sizeof(cszType)/sizeof(TCHAR) - 1;
        lstrcpy(lpszTo,lpszFixedFilename);
        lpszTo += lstrlen(lpszFixedFilename) + SIZEOF_NULL;
        *lpszTo = '\0';    // extra terminating NULL

        Assert(&lpszTo[SIZEOF_NULL]<&szData[SCRIPT_PATCH_BUFFER_SIZE]);
    }
    //
    //    Write data
    //
    bRC = WritePrivateProfileSection(lpszEntry,szData,szRasPBK);

ScriptPatchExit:
    if (lpszFixedFilename)
        GlobalFree(lpszFixedFilename);
    lpszFixedFilename = NULL;
    if (!bRC)
        TraceMsg(TF_GENERAL, "ICWDIAL: ScriptPatch failed.\r\n");
    return bRC;
}
#endif //!win16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdl\boyer.cpp ===
/*-----------------------------------------------------------------------------
    Program Specification

    in:     search space s, pattern p
    out:    a pointer where p is exactly matched at s[i], NULL indicates fail
    why:    Boyer-Moore algorithm is best for general text search. On
            "average" it takes length(s)/length(p) steps to match p in s.

    ref:    I recommend the following references:

            "Algorithms". Robert Sedgewick. Addison Wesley Publishing Company.
            1988. 2nd addition. p286. QA76.6.S435 1983

            "Faster String Searches". Doctor Dobb's Journal. Volume 14
            Issue 7 July 1989. Costas Menico. p74.

    usage:  e.g. to find a pattern "tiger" in a text in RAM starting at
                 pointer "txtp" with a length of 1,000,000 characters,
                 program like this:

            LPSTR matchp;

            SetFindPattern( "tiger" );
            matchp = Find( txtp, 1000000L );
            if (matchp != NULL)
                // found
            else
                // not found

            matchp = FindBackward( txtp + 1000000L - 1, 1000000L);
            if (matchp != NULL)
                // found
            else
                // not found


    Q:      Can I use Find() with a GlobalLock() pointer in Windows?
    A:      Yes.

    Q:      Must I delcare my pointer as HPSTR (huge pointer) ?
    A:      Not necessary.  Find() and FindBackward() will convert your
            LPSTR as HPSTR.  However, in your own code you must aware
            that you are holding a LPSTR and take care of the pointer
            arithmetic and conversion. (see demo.c for example)

    Q:      What is the limit of the memory space I can search?
    A:      To the limit of huge pointer implementation and your hardware.

-----------------------------------------------------------------------------*/

#include "pch.hpp"


/*-----------------------------------------------------------------------------
    func:   SetFindPattern
    desc:   initialize the pattern to be matched and generate skip table
    pass:   lpszPattern = pattern string
    rtrn:   HFIND - the find handle for further text search
-----------------------------------------------------------------------------*/
HFIND SetFindPattern( LPTSTR lpszPattern )
{
    register unsigned int j;
    register TCHAR c;
    HFIND hfind;
   

    hfind = (HFIND)MyAlloc(sizeof(FINDSTRUCT));
    
    hfind->plen = lstrlen( lpszPattern );

    if (hfind->plen > MAXPAT)
        hfind->plen = MAXPAT;

#ifdef UNICODE
    wcstombs( (LPSTR)(hfind->p), lpszPattern, hfind->plen + 1 );
#else
    lstrcpy( (LPSTR)(hfind->p), lpszPattern );
#endif
    

    for (j=0; j<256; j++)
    {
        hfind->skip[j] = hfind->plen;
    }

    for (j=0; j<hfind->plen; j++)
    {
        c = lpszPattern[j];
        hfind->skip[c] =  hfind->plen - (j +1);
    }

    return (hfind);
}

/*-----------------------------------------------------------------------------
    func:   FreeFindPattern
    desc:   free the memory occupied by SetFindPattern
    pass:   hfind - the find handle
    rtrn:   nothing
-----------------------------------------------------------------------------*/
void FreeFindPattern( HFIND hfind )
{
	
	MyFree((LPTSTR)hfind);
}

/*-----------------------------------------------------------------------------
    func:   Find
    desc:   match a pattern defined in SetFindPattern against string s
    pass:   hfind = the find handle created by SetFindPattern
            s = start of search space, slen = length of s
    rtrn:   NULL = match fail
            else = a LPTSTR to p[0] in s matches p
-----------------------------------------------------------------------------*/
LPSTR Find( HFIND hfind, LPSTR s, long slen )

{
    register int i;
    unsigned int n, j;
    register unsigned char c;
    LPSTR lpresult;
    

    
    i = hfind->plen;
	j = hfind->plen;
  

    do
    {
        c = *(s + (i - 1));

        if (c == hfind->p[j - 1])
        {
			i--;
			j--;
        }
		else
        {
            n = hfind->plen - j + 1;
            if (n > hfind->skip[c] )
            {
                i += n;
            }
			else
            {
                i += hfind->skip[c];
            }
            j = hfind->plen;
        }
    }
    while ((j >= 1) && (i <= slen));

    /* match fails */
    if (i >= slen)
    {
        lpresult = (LPSTR)NULL;
    }
    /* match successful */
    else
    {
        lpresult = s + i;
    }

    
    return (lpresult);
}




#ifdef TEST_MAIN
#pragma message("Building with TEST_MAIN")
#include <stdio.h>
TCHAR test_buffer[]=TEXT("___________12191919191919This is string for testing our find ___________12191919191919function 12abE Is it in here somehwere ?");
TCHAR test_pattern[]=TEXT("___________12191919191919");

void main(void)
{
	HFIND hFind;
	TCHAR *tmp;

	hFind=SetFindPattern(test_pattern);
	tmp=Find(hFind, test_buffer,strlen(test_buffer));
	if (tmp!=NULL) printf("Found pattern at offset %u, %s",tmp-test_buffer,tmp);
	FreeFindPattern(hFind);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdl\download.h ===
/*----------------------------------------------------------------------------
    download.h
        
        Download handling for Signup

    Copyright (C) 1995 Microsoft Corporation
    All rights reserved.

    Authors:
        ArulM
  --------------------------------------------------------------------------*/
  
class MyBaseClass
{
public:
    void * operator new( size_t cb );
    void operator delete( void * p );
};

#include     <wininet.h>

#define InternetSessionCloseHandle(h)        InternetCloseHandle(h)            
#define InternetRequestCloseHandle(h)        InternetCloseHandle(h)
#define InternetGetLastError(h)                GetLastError()
#define InternetCancel(h)                    InternetCloseHandle(h)

extern HANDLE       g_hDLLHeap;        // private Win32 heap
extern HINSTANCE    g_hInst;        // our DLL hInstance

class CFileInfo : public MyBaseClass
{
public:
    CFileInfo*    m_pfiNext;
    LPTSTR        m_pszPath;
    BOOL          m_fInline;
    
    CFileInfo(LPTSTR psz, BOOL f) { m_pfiNext = NULL; m_pszPath = psz; m_fInline = f; }
    ~CFileInfo() { if(m_pszPath) MyFree(m_pszPath); }
};

class CDownLoad : public MyBaseClass
{
    CFileInfo*    m_pfiHead;
    LPTSTR        m_pszURL;
    HINTERNET    m_hSession;
    HINTERNET    m_hRequest;
    DWORD        m_dwContentLength;
    DWORD        m_dwReadLength;
    LPTSTR       m_pszBoundary;
    DWORD        m_dwBoundaryLen;
    LPTSTR       m_pszWindowsDir;
    LPTSTR       m_pszSystemDir;
    LPTSTR       m_pszTempDir;
    LPTSTR       m_pszICW98Dir;
    LPTSTR       m_pszSignupDir;
    DWORD        m_dwWindowsDirLen;
    DWORD        m_dwSystemDirLen;
    DWORD        m_dwTempDirLen;
    DWORD        m_dwSignupDirLen;
    DWORD        m_dwICW98DirLen;
    INTERNET_STATUS_CALLBACK m_lpfnCB;
    INTERNET_STATUS_CALLBACK m_lpfnPreviousCB;
    
    void AddToFileList(CFileInfo* pfi);
    LPTSTR FileToPath(LPTSTR pszFile);
    HRESULT ProcessRequest(void);
    void ShowProgress(DWORD dwRead);
    DWORD FillBuffer(LPBYTE pbBuf, DWORD dwLen, DWORD dwRead);
    DWORD MoveAndFillBuffer(LPBYTE pbBuf, DWORD dwLen, DWORD dwValid, LPBYTE pbNewStart);
#if defined(WIN16)
    HRESULT HandleDLFile(LPTSTR pszFile, BOOL fInline, LPHFILE phFile);
#else
    HRESULT HandleDLFile(LPTSTR pszFile, BOOL fInline, LPHANDLE phFile);
#endif
    HRESULT HandleURL(LPTSTR pszPath);

public:
    CDownLoad(LPTSTR psz);
    ~CDownLoad(void);
    HRESULT Execute(void);
    HRESULT Process(void);
    HINTERNET GetSession(void) { return m_hRequest; }
    HANDLE        m_hCancelSemaphore;
    DWORD_PTR     m_lpCDialingDlg;
    HRESULT SetStatusCallback (INTERNET_STATUS_CALLBACK lpfnCB);
    void Cancel() { if(m_hRequest) InternetCancel(m_hRequest); }
};

#define USERAGENT_FMT           TEXT("MSSignup/1.1 (%s; %d.%d; Lang=%04x)")
#define SIGNUP                  TEXT("signup")
#define SIGNUP_LEN              (sizeof(SIGNUP)-1)
#define SYSTEM                  TEXT("system")
#define SYSTEM_LEN              (sizeof(SYSTEM)-1)
#define WINDOWS                 TEXT("windows")
#define WINDOWS_LEN             (sizeof(WINDOWS)-1)
#define TEMP                    TEXT("temp")
#define TEMP_LEN                (sizeof(TEMP)-1)
#define ICW98DIR                TEXT("icw98dir")
#define ICW98DIR_LEN            (sizeof(ICW98DIR)-1)

#define MULTIPART_MIXED         "multipart/mixed"
#define MULTIPART_MIXED_LEN     (sizeof(MULTIPART_MIXED)-1)
#define CONTENT_DISPOSITION     "content-disposition"
#define CONTENT_DISPOSITION_LEN (sizeof(CONTENT_DISPOSITION)-1)
#define BOUNDARY                "boundary"
#define BOUNDARY_LEN            (sizeof(BOUNDARY)-1)
#define FILENAME                "filename"
#define FILENAME_LEN            (sizeof(FILENAME)-1)
#define INLINE                  "inline"
#define INLINE_LEN              (sizeof(INLINE)-1)
#define ATTACHMENT              "attachment"
#define ATTACHMENT_LEN          (sizeof(ATTACHMENT)-1)

#define DEFAULT_DATABUF_SIZE    4096
#define SLOP                    5
#define OVERLAP_LEN             100

#define DOUBLE_CRLF             TEXT("\r\n\r\n")
#define DOUBLE_CRLF_LEN         (sizeof(DOUBLE_CRLF)-1)

#define DIALOGBOXCLASS          TEXT("#32770")
#define REGEDIT_CMD             TEXT("regedit /s ")

#define EXT_EXE                 TEXT("exe")
#define EXT_REG                 TEXT("reg")
#define EXT_INF                 TEXT("inf")
#define EXT_CHG                 TEXT("chg")
#define EXT_URL                 TEXT("url")

// ICW Version 2.0 stuff.  Ref Server can send cabbed files now,
// this is the extension for it.  We have a cab File Handler which
// blasts open the cab and decompresses the files.
#define EXT_CAB                 TEXT("cab")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdl\boyer.h ===
#ifndef _INC_BOYER
#define _INC_BOYER

/* store the pattern, pattern length and skip table for 256 alphabets */
/* maximum pattern length (MAXPAT) cannot be larger than 65535 */

#define MAXPAT  256

typedef struct {
	unsigned int plen;
	CHAR p[MAXPAT + 1];
	unsigned int skip[256];
} FINDSTRUCT;

typedef FINDSTRUCT FAR * LPFIND;
typedef LPFIND HFIND;

/* boyer.c prototypes */

#ifdef __cplusplus
extern "C" {
#endif
	
	
	HFIND SetFindPattern( LPTSTR lpszPattern );
	void FreeFindPattern( HFIND hfind );
	LPSTR Find( HFIND hfind, LPSTR s, long slen );
	
#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdl\mydefs.h ===
#if !defined(WIN16)
extern HANDLE g_hDLLHeap;		// private Win32 heap

#define MyAlloc(n)			((LPTSTR)HeapAlloc(g_hDLLHeap, HEAP_ZERO_MEMORY, sizeof(TCHAR)*(n)))
#define MyFree(pv)			HeapFree(g_hDLLHeap, 0, pv)
#define MyRealloc(pv, n)	((LPTSTR)HeapReAlloc(g_hDLLHeap, HEAP_ZERO_MEMORY, (pv), sizeof(TCHAR)*(n)))
#define MyHeapSize(pv)     HeapSize(g_hDLLHeap, 0, pv)

LPTSTR MyStrDup(LPTSTR);

#ifdef DEBUG

#define MyAssert(f)			((f) ? 0 : MyAssertProc(__FILE__, __LINE__, #f))
#define MyTrace(x)			{ MyDprintf x; }
#define MyDbgSz(x)			{ puts x; OutputDebugString x; }
int MyAssertProc(LPTSTR, int, LPTSTR);
void CDECL MyDprintf(LPCSTR pcsz, ...);

#else // DEBUG

#	define MyTrace(x)			
#	define MyDbgSz(x)			
#	define MyAssert(f)			

#endif // DEBUG

#define W32toHR(x)	HRESULT_FROM_WIN32(x)

#endif // !WIN16

#define ARRAYSIZE(a)  (sizeof(a)/sizeof((a)[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdl\pch.hpp ===
#include <windows.h> 
#include <shellapi.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <wtypes.h>

#include "icwunicd.h"
#include "boyer.h"
#include "mydefs.h"

#include "download.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by download.rc
//
#define IDS_DOWNLOAD                    1
#define IDS_APPNAME                     3
#define IDS_TMPVAR                      4
#define IDS_TEMPVAR                     5

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdl\cabhandler.cpp ===
/*
 *  FDIDLL.C -- FDI interface using CABINET.DLL
 *
 *  Copyright (C) Microsoft Corporation 1997
 *  All Rights Reserved.
 *
 *  Overview:
 *      This code is a wrapper which provides access to the actual FDI code
 *      in CABINET.DLL.  CABINET.DLL dynamically loads/unloads as needed.
 */
 
#include    "pch.hpp"
#include <io.h>
#include <fcntl.h>
#include <sys/stat.h>

#include "fdi.h"

static HINSTANCE hCabinetDll = NULL;   /* DLL module handle */

/* pointers to the functions in the DLL */
typedef HFDI (FAR DIAMONDAPI *PFNFDICREATE)(
        PFNALLOC            pfnalloc,
        PFNFREE             pfnfree,
        PFNOPEN             pfnopen,
        PFNREAD             pfnread,
        PFNWRITE            pfnwrite,
        PFNCLOSE            pfnclose,
        PFNSEEK             pfnseek,
        int                 cpuType,
        PERF                perf);

static PFNFDICREATE pfnFDICreate = NULL;

typedef BOOL (FAR DIAMONDAPI *PFNFDIIsCabinet)(
        HFDI                hfdi,
        INT_PTR             hf,
        PFDICABINETINFO     pfdici);

static PFNFDIIsCabinet pfnFDIIsCabinet = NULL;

typedef BOOL (FAR DIAMONDAPI *PFNFDICopy)(
        HFDI                hfdi,
        CHAR               *pszCabinet,
        CHAR               *pszCabPath,
        int                 flags,
        PFNFDINOTIFY        pfnfdin,
        PFNFDIDECRYPT       pfnfdid,
        void                *pvUser);

static PFNFDICopy pfnFDICopy = NULL;

typedef BOOL (FAR DIAMONDAPI *PFNFDIDestroy)(
        HFDI                hfdi);

static PFNFDIDestroy pfnFDIDestroy = NULL;

/*
 *  FDICreate -- Create an FDI context
 *
 *  See fdi.h for entry/exit conditions.
 */

HFDI FAR DIAMONDAPI FDICreate(PFNALLOC pfnalloc,
                              PFNFREE  pfnfree,
                              PFNOPEN  pfnopen,
                              PFNREAD  pfnread,
                              PFNWRITE pfnwrite,
                              PFNCLOSE pfnclose,
                              PFNSEEK  pfnseek,
                              int      cpuType,
                              PERF     perf)
{
    HFDI hfdi;


    if ( hCabinetDll != NULL )
    {
        goto gotEntryPoints;
    }

    hCabinetDll = LoadLibrary(TEXT("CABINET"));
    if (hCabinetDll == NULL)
    {
        return(NULL);
    }

    pfnFDICreate = (PFNFDICREATE) GetProcAddress(hCabinetDll,"FDICreate");
    pfnFDICopy = (PFNFDICopy) GetProcAddress(hCabinetDll,"FDICopy");
    pfnFDIIsCabinet = (PFNFDIIsCabinet) GetProcAddress(hCabinetDll,"FDIIsCabinet");
    pfnFDIDestroy = (PFNFDIDestroy) GetProcAddress(hCabinetDll,"FDIDestroy");

    if ((pfnFDICreate == NULL) ||
        (pfnFDICopy == NULL) ||
        (pfnFDIIsCabinet == NULL) ||
        (pfnFDIDestroy == NULL))
    {
        FreeLibrary(hCabinetDll);
        hCabinetDll = NULL;
        return(NULL);
    }

gotEntryPoints:
    hfdi = pfnFDICreate(pfnalloc,pfnfree,
            pfnopen,pfnread,pfnwrite,pfnclose,pfnseek,cpuType,perf);
    if (hfdi == NULL)
    {
        FreeLibrary(hCabinetDll);
        hCabinetDll = NULL;
    }

    return(hfdi);
}


/*
 *  FDIIsCabinet -- Determines if file is a cabinet, returns info if it is
 *
 *  See fdi.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDIIsCabinet(HFDI            hfdi,
                                 INT_PTR         hf,
                                 PFDICABINETINFO pfdici)
{
    if (pfnFDIIsCabinet == NULL)
    {
        return(FALSE);
    }

    return(pfnFDIIsCabinet(hfdi,hf,pfdici));
}


/*
 *  FDICopy -- extracts files from a cabinet
 *
 *  See fdi.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDICopy(HFDI          hfdi,
                            char         *pszCabinet,
                            char        *pszCabPath,
                            int           flags,
                            PFNFDINOTIFY  pfnfdin,
                            PFNFDIDECRYPT pfnfdid,
                            void         *pvUser)
{
    if (pfnFDICopy == NULL)
    {
        return(FALSE);
    }

    return(pfnFDICopy(hfdi,pszCabinet,pszCabPath,flags,pfnfdin,pfnfdid,pvUser));
}


/*
 *  FDIDestroy -- Destroy an FDI context
 *
 *  See fdi.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDIDestroy(HFDI hfdi)
{
    BOOL rc;

    if (pfnFDIDestroy == NULL)
    {
        return(FALSE);
    }

    rc = pfnFDIDestroy(hfdi);

    return(rc);
}


/*
 * Memory allocation function
 */
FNALLOC(mem_alloc)
{
        return new BYTE[cb];
}


/*
 * Memory free function
 */
FNFREE(mem_free)
{
        delete pv;
}


FNOPEN(file_open)
{
    return _open(pszFile, oflag, pmode);
}


FNREAD(file_read)
{
        return _read((int)hf, pv, cb);
}


FNWRITE(file_write)
{
        return _write((int)hf, pv, cb);
}


FNCLOSE(file_close)
{
        return _close((int)hf);
}


FNSEEK(file_seek)
{
        return _lseek((int)hf, dist, seektype);
}

FNFDINOTIFY(notification_function)
{
    switch (fdint)
    {
        case fdintCABINET_INFO: // general information about the cabinet
#if 0
            printf(
                "fdintCABINET_INFO\n"
                "  next cabinet     = %s\n"
                "  next disk        = %s\n"
                "  cabinet path     = %s\n"
                "  cabinet set ID   = %d\n"
                "  cabinet # in set = %d (zero based)\n"
                "\n",
                pfdin->psz1,
                pfdin->psz2,
                pfdin->psz3,
                pfdin->setID,
                pfdin->iCabinet
            );
#endif
            return 0;

        case fdintPARTIAL_FILE: // first file in cabinet is continuation
#if 0
            printf(
                "fdintPARTIAL_FILE\n"
                "   name of continued file            = %s\n"
                "   name of cabinet where file starts = %s\n"
                "   name of disk where file starts    = %s\n",
                pfdin->psz1,
                pfdin->psz2,
                pfdin->psz3
            );
#endif
            return 0;

        case fdintCOPY_FILE:    // file to be copied
        {
            int        response;
            INT_PTR    handle;

#if 0
            printf(
                "fdintCOPY_FILE\n"
                "  file name in cabinet = %s\n"
                "  uncompressed file size = %d\n"
                "  copy this file? (y/n): ",
                pfdin->psz1,
                pfdin->cb
            );
#endif

            handle = file_open(
                pfdin->psz1,
                _O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL | _O_TRUNC,
                _S_IREAD | _S_IWRITE 
            );

            return handle;
        }

        case fdintCLOSE_FILE_INFO:    // close the file, set relevant info
        {
            HANDLE  handle;
            DWORD   attrs;
            char    destination[256];

#if 0
            printf(
                "fdintCLOSE_FILE_INFO\n"
                "   file name in cabinet = %s\n"
                "\n",
                pfdin->psz1
            );
#endif

            file_close(pfdin->hf);

            return TRUE;
        }

        case fdintNEXT_CABINET:    // file continued to next cabinet
#if 0
            printf(
                "fdintNEXT_CABINET\n"
                "   name of next cabinet where file continued = %s\n"
                "   name of next disk where file continued    = %s\n"
                "   cabinet path name                         = %s\n"
                "\n",
                pfdin->psz1,
                pfdin->psz2,
                pfdin->psz3
            );
#endif
            return 0;
    }

    return 0;
}

HRESULT HandleCab(LPTSTR cabinet_fullpath)
{
    ERF             erf;
    HFDI            hfdi;
    INT_PTR         hf;
    FDICABINETINFO    fdici;
    char            *p;
    char            cabinet_name[256];
    char            cabinet_path[256];
    char            szCurrentDirectory[MAX_PATH];
    char            szdrive[_MAX_DRIVE];   
    char            szPathName[_MAX_PATH];     // This will be the dir we need to create
    char            szdir[_MAX_DIR];
    char            szfname[_MAX_FNAME];   
    char            szext[_MAX_EXT];
	char            szcabinet_fullpath[MAX_PATH+1];
    HRESULT         err = S_OK;

#ifdef UNICODE
	wcstombs(szcabinet_fullpath, cabinet_fullpath, MAX_PATH+1);
#else
	lstrcpy(szcabinet_fullpath, cabinet_fullpath);
#endif

    if (GetCurrentDirectoryA(sizeof(szCurrentDirectory), szCurrentDirectory))
    {
        // Split the provided path to get at the drive and path portion
        _splitpath( szcabinet_fullpath, szdrive, szdir, szfname, szext );
        wsprintfA (szPathName, "%s%s", szdrive, szdir);
   
        // Set the directory to where the cab is
        if (!SetCurrentDirectoryA(szPathName))
        {
            return(GetLastError());
        }
    }
    else
    {
        return(GetLastError());
    }
    
    
    do
    {
        hfdi = FDICreate(mem_alloc,
                              mem_free,
                              file_open,
                              file_read,
                              file_write,
                              file_close,
                              file_seek,
                              cpuUNKNOWN,
                              &erf);

        if (hfdi == NULL)
        {
            err =  -1;
            break;
        }

        /*
         * Is this file really a cabinet?
         */
        hf = file_open(
            szcabinet_fullpath,
            _O_BINARY | _O_RDONLY | _O_SEQUENTIAL,
            0
        );

        if (hf == -1)
        {
            (void) FDIDestroy(hfdi);

            // Error Opening the file
            err =  -2;
            break;
            
        }

        if (FALSE == FDIIsCabinet(
                hfdi,
                hf,
                &fdici))
        {
            /*
             * No, it's not a cabinet!
             */
            _close((int)hf);

            (void) FDIDestroy(hfdi);
            err =  -3;
            break;
            
        }
        else
        {
            _close((int)hf);
        }

        p = strrchr(szcabinet_fullpath, '\\');

        if (p == NULL)
        {
            lstrcpynA(cabinet_name, szcabinet_fullpath, ARRAYSIZE(cabinet_name));
            lstrcpyA(cabinet_path, "");
        }
        else
        {
            lstrcpyA(cabinet_name, p+1);

            strncpy(cabinet_path, szcabinet_fullpath, (int) (p-szcabinet_fullpath)+1);
            cabinet_path[ (int) (p-szcabinet_fullpath)+1 ] = 0;
        }

        if (TRUE != FDICopy(
            hfdi,
            cabinet_name,
            cabinet_path,
            0,
            notification_function,
            NULL,
            NULL))
        {
            // Extract Failed.
            (void) FDIDestroy(hfdi);
            err =  -4;
            break;
        }

        if (FDIDestroy(hfdi) != TRUE)
        {

            // why in the world would the context destroy fail ?
            err =  -5;
            break;
            
        }
        
        break;
    }
    while(1 );


    // Set the directory back to the original place
    if (!SetCurrentDirectoryA(szCurrentDirectory))
        return(GetLastError());
        
    
    return err;
}

void CleanupCabHandler()
{
    if (hCabinetDll != NULL)
    {
        FreeLibrary(hCabinetDll);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdl\download.cpp ===
/*----------------------------------------------------------------------------
    download.cpp

        Download handling for Signup

    Copyright (C) 1995 Microsoft Corporation
    All rights reserved.

    Authors:
        ArulM
  --------------------------------------------------------------------------*/

#include    "pch.hpp"
#include    <stdio.h>
#include    <stdlib.h>
#include    <stdarg.h>
#include    <shellapi.h>
#include    <shlobj.h>
#include    <intshcut.h>
#include    <wininet.h>
#include    "icwdl.h"

// 12/4/96 jmazner    Normandy #12193
// path to icwconn1.exe registry key from HKEY_LOCAL_MACHINE
#define ICWCONN1PATHKEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CONNWIZ.EXE")
#define PATHKEYNAME     TEXT("Path")

#include <winreg.h>

// Cabbing up.
extern HRESULT HandleCab(LPTSTR pszPath);
extern void CleanupCabHandler();

// all global data is static shared, read-only
// (written only during DLL-load)
HANDLE      g_hDLLHeap;        // private Win32 heap
HINSTANCE   g_hInst;        // our DLL hInstance

HWND        g_hWndMain;        // hwnd of icwconn1 parent window


#define DllExport extern "C" __declspec(dllexport)
#define MAX_RES_LEN         255 // max length of string resources
#define SMALL_BUF_LEN       48  // convenient size for small text buffers


LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf);

//+---------------------------------------------------------------------------
//
//  Function:   MyGetTempPath()
//
//  Synopsis:   Gets the path to temporary directory
//                - Use GetTempFileName to get a file name
//                  and strips off the filename portion to get the temp path
//
//  Arguments:  [uiLength - Length of buffer to contain the temp path]
//                [szPath      - Buffer in which temp path will be returned]
//
//    Returns:    Length of temp path if successful
//                0 otherwise
//
//  History:    7/6/96     VetriV    Created
//                8/23/96        VetriV        Delete the temp file
//                12/4/96        jmazner     Modified to serve as a wrapper of sorts;
//                                     if TMP or TEMP don't exist, setEnv our own
//                                     vars that point to conn1's installed path
//                                     (Normandy #12193)
//
//----------------------------------------------------------------------------
DWORD MyGetTempPath(UINT uiLength, LPTSTR szPath)
{
    TCHAR szEnvVarName[SMALL_BUF_LEN + 1] = TEXT("\0unitialized szEnvVarName\0");
    DWORD dwFileAttr = 0;

    lstrcpyn( szPath, TEXT("\0unitialized szPath\0"), 20 );

    // is the TMP variable set?
    LoadSz(IDS_TMPVAR,szEnvVarName,sizeof(szEnvVarName));
    if( GetEnvironmentVariable( szEnvVarName, szPath, uiLength ) )
    {
        // 1/7/96 jmazner Normandy #12193
        // verify validity of directory name
        dwFileAttr = GetFileAttributes(szPath);
        // if there was any error, this directory isn't valid.
        if( 0xFFFFFFFF != dwFileAttr )
        {
            if( FILE_ATTRIBUTE_DIRECTORY & dwFileAttr )
            {
                return( lstrlen(szPath) );
            }
        }
    }

    lstrcpyn( szEnvVarName, TEXT("\0unitialized again\0"), 19 );

    // if not, is the TEMP variable set?
    LoadSz(IDS_TEMPVAR,szEnvVarName,sizeof(szEnvVarName));
    if( GetEnvironmentVariable( szEnvVarName, szPath, uiLength ) )
    {
        // 1/7/96 jmazner Normandy #12193
        // verify validity of directory name
        dwFileAttr = GetFileAttributes(szPath);
        if( 0xFFFFFFFF != dwFileAttr )
        {
            if( FILE_ATTRIBUTE_DIRECTORY & dwFileAttr )
            {
                return( lstrlen(szPath) );
            }
        }
    }

    // neither one is set, so let's use the path to the installed icwconn1.exe
    // from the registry  SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\ICWCONN1.EXE\Path
    HKEY hkey = NULL;

#ifdef UNICODE
    uiLength = uiLength*sizeof(TCHAR);
#endif
    if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,ICWCONN1PATHKEY, 0, KEY_QUERY_VALUE, &hkey)) == ERROR_SUCCESS)
        RegQueryValueEx(hkey, PATHKEYNAME, NULL, NULL, (BYTE *)szPath, (DWORD *)&uiLength);
    if (hkey)
    {
        RegCloseKey(hkey);
    }

    //The path variable is supposed to have a semicolon at the end of it.
    // if it's there, remove it.
    if( ';' == szPath[uiLength - 2] )
        szPath[uiLength - 2] = '\0';

    MyTrace(("ICWDL: using path "));
    MyTrace((szPath));
    MyTrace(("\r\n"));


    // go ahead and set the TEMP variable for future reference
    // (only effects currently running process)
    if( szEnvVarName[0] )
    {
        SetEnvironmentVariable( szEnvVarName, szPath );
    }
    else
    {
        lstrcpyn( szPath, TEXT("\0unitialized again\0"), 19 );
        return( 0 );
    }

    return( uiLength );
}


extern "C" BOOL _stdcall DllEntryPoint(HINSTANCE hInstance, DWORD dwReason, LPVOID lbv)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        // Need to use OLE/Com later
        if (FAILED(CoInitialize(NULL)))
            return(FALSE);

        //
        // ChrisK Olympus 6373 6/13/97
        // Disable thread attach calls in order to avoid race condition
        // on Win95 golden
        //
        DisableThreadLibraryCalls(hInstance);
        g_hInst = hInstance;
        g_hDLLHeap = HeapCreate(0, 0, 0);
        MyAssert(g_hDLLHeap);
        if (g_hDLLHeap == NULL)
            return FALSE;
        break;

    case DLL_PROCESS_DETACH:
        CoUninitialize();
        HeapDestroy(g_hDLLHeap);

        // Cleanup the cabbing stuff.
        CleanupCabHandler();
        break;
    }
    return TRUE;
}


LPTSTR MyStrDup(LPTSTR pszIn)
{
    int len;
    LPTSTR pszOut;

    MyAssert(pszIn);
    len = lstrlen(pszIn);
    if(!(pszOut = (LPTSTR)MyAlloc(len+1)))
    {
        MyAssert(FALSE);
        return NULL;
    }
    lstrcpy(pszOut, pszIn);
    pszOut[len] = 0;

    return pszOut;
}

#ifdef UNICODE
LPTSTR MyStrDup(LPSTR pszIn)
{
    int len;
    LPTSTR pszOut;

    MyAssert(pszIn);
    len = lstrlenA(pszIn);
    if(!(pszOut = (LPTSTR)MyAlloc(len+1)))
    {
        MyAssert(FALSE);
        return NULL;
    }
    mbstowcs(pszOut, pszIn, len);
    pszOut[len] = 0;

    return pszOut;
}
#endif

int MyAssertProc(LPTSTR pszFile, int nLine, LPTSTR pszExpr)
{
    TCHAR szBuf[512];

    wsprintf(szBuf, TEXT("Assert failed at line %d in file %s. (%s)\r\n"), nLine, pszFile, pszExpr);
    MyDbgSz((szBuf));
    return 0;
}

void _cdecl MyDprintf(LPCSTR pcsz, ...)
{
    va_list    argp;
    char szBuf[1024];

    if ((NULL == pcsz) || ('\0' == pcsz[0]))
        return;

    va_start(argp, pcsz);

    vsprintf(szBuf, pcsz, argp);

    MyDbgSz((szBuf));
    va_end(argp);
} // Dprintf()

// ############################################################################
//  operator new
//
//  This function allocate memory for C++ classes
//
//  Created 3/18/96,        Chris Kauffman
// ############################################################################
void * MyBaseClass::operator new( size_t cb )
{
    return MyAlloc(cb);
}

// ############################################################################
//  operator delete
//
//  This function frees memory for C++ classes
//
//  Created 3/18/96,        Chris Kauffman
// ############################################################################
void MyBaseClass::operator delete( void * p )
{
    MyFree( p );
}

void CDownLoad::AddToFileList(CFileInfo* pfi)
{
    CFileInfo **ppfi;

    // must add at tail
    for(ppfi=&m_pfiHead; *ppfi; ppfi = &((*ppfi)->m_pfiNext))
        ;
    *ppfi = pfi;
}


CDownLoad::CDownLoad(LPTSTR psz)
{
    TCHAR           szUserAgent[128];
    OSVERSIONINFO   osVer;
    LPTSTR          pszOS = TEXT("");

    memset(this, 0, sizeof(CDownLoad));

    if(psz)
        m_pszURL = MyStrDup(psz);

    memset(&osVer, 0, sizeof(osVer));
    osVer.dwOSVersionInfoSize = sizeof(osVer);
    GetVersionEx(&osVer);

    switch(osVer.dwPlatformId)
    {
        case VER_PLATFORM_WIN32_WINDOWS:
            pszOS = TEXT("Windows95");
            break;
        case VER_PLATFORM_WIN32_NT:
            pszOS = TEXT("WindowsNT");
    }


    wsprintf(szUserAgent, USERAGENT_FMT, pszOS, osVer.dwMajorVersion,
                osVer.dwMinorVersion, GetSystemDefaultLangID());

    m_hSession = InternetOpen(szUserAgent, 0, NULL, NULL, 0);

    TCHAR szBuf[MAX_PATH+1];

    GetWindowsDirectory(szBuf, MAX_PATH);
    szBuf[MAX_PATH] = 0;
    m_pszWindowsDir = MyStrDup(szBuf);
    m_dwWindowsDirLen = lstrlen(m_pszWindowsDir);

    GetSystemDirectory(szBuf, MAX_PATH);
    szBuf[MAX_PATH] = 0;
    m_pszSystemDir = MyStrDup(szBuf);
    m_dwSystemDirLen = lstrlen(m_pszSystemDir);

    MyGetTempPath(MAX_PATH, szBuf);
    szBuf[MAX_PATH] = 0;
    m_pszTempDir = MyStrDup(szBuf);
    m_dwTempDirLen = lstrlen(m_pszTempDir);
    if(m_pszTempDir[m_dwTempDirLen-1]=='\\')
    {
        m_pszTempDir[m_dwTempDirLen-1]=0;
        m_dwTempDirLen--;
    }

    // form the ICW98 dir.  It is basically the CWD
    m_pszICW98Dir = MyAlloc(MAX_PATH +1);
    GetCurrentDirectory(MAX_PATH, m_pszICW98Dir);
    m_dwICW98DirLen = lstrlen(m_pszICW98Dir);

    LPTSTR pszCmdLine = GetCommandLine();
    LPTSTR pszTemp = NULL, pszTemp2 = NULL;

    _tcsncpy(szBuf, pszCmdLine, MAX_PATH);
    szBuf[MAX_PATH] = 0;
    pszTemp = _tcstok(szBuf, TEXT(" \t\r\n"));
    if (NULL != pszTemp)
    {
        pszTemp2 = _tcschr(pszTemp, TEXT('\\'));
        if(!pszTemp2)
            pszTemp2 = _tcsrchr(pszTemp, TEXT('/'));
    }
    if(pszTemp2)
    {
        *pszTemp2 = 0;
        m_pszSignupDir = MyStrDup(pszTemp);
    }
    else
    {
        MyAssert(FALSE);
        GetCurrentDirectory(MAX_PATH, szBuf);
        szBuf[MAX_PATH] = 0;
        m_pszSignupDir = MyStrDup(szBuf);
    }
    m_dwSignupDirLen = lstrlen(m_pszSignupDir);
}

CDownLoad::~CDownLoad(void)
{
    MyDprintf("ICWDL: CDownLoad::~CDownLoad called\n", this);

    CFileInfo *pfi, *pfiNext;
    for(pfi=m_pfiHead; pfi; pfi=pfiNext)
    {
        pfiNext = pfi->m_pfiNext;
        delete pfi;
    }

    if(m_pszWindowsDir)
        MyFree(m_pszWindowsDir);
    if(m_pszSystemDir)
        MyFree(m_pszSystemDir);
    if(m_pszTempDir)
        MyFree(m_pszTempDir);
    if(m_pszICW98Dir)
        MyFree(m_pszICW98Dir);
    if(m_pszSignupDir)
        MyFree(m_pszSignupDir);
    if(m_pszURL)
        MyFree(m_pszURL);
    if(m_pszBoundary)
        MyFree(m_pszBoundary);
    if(m_hSession)
        InternetSessionCloseHandle(m_hSession);
    MyAssert(!m_hRequest);

    //
    // 5/23/97 jmazner Olympus #4652
    // Make sure that any waiting threads are freed up.
    //
    if( m_hCancelSemaphore )
    {
        ReleaseSemaphore( m_hCancelSemaphore, 1, NULL );

        CloseHandle( m_hCancelSemaphore );
        m_hCancelSemaphore = NULL;
    }
}

// perform a file name substitution
LPTSTR CDownLoad::FileToPath(LPTSTR pszFile)
{
    TCHAR szBuf[MAX_PATH+1];

    for(long j=0; *pszFile; pszFile++)
    {
        if(j>=MAX_PATH)
            return NULL;
        if(*pszFile=='%')
        {
            pszFile++;
            LPTSTR pszTemp = _tcschr(pszFile, '%');
            if(!pszTemp)
                return NULL;
            *pszTemp = 0;
            if(lstrcmpi(pszFile, SIGNUP)==0)
            {
                lstrcpy(szBuf+j, m_pszSignupDir);
                j+= m_dwSignupDirLen;
            }
            else if(lstrcmpi(pszFile, WINDOWS)==0)
            {
                lstrcpy(szBuf+j, m_pszWindowsDir);
                j+= m_dwWindowsDirLen;
            }
            else if(lstrcmpi(pszFile, SYSTEM)==0)
            {
                lstrcpy(szBuf+j, m_pszSystemDir);
                j+= m_dwSystemDirLen;
            }
            else if(lstrcmpi(pszFile, TEMP)==0)
            {
                lstrcpy(szBuf+j, m_pszTempDir);
                j+= m_dwTempDirLen;
            }
            else if(lstrcmpi(pszFile, ICW98DIR)==0)
            {
                lstrcpy(szBuf+j, m_pszICW98Dir);
                j+= m_dwICW98DirLen;
            }
            else
                return NULL;
            pszFile=pszTemp;
        }
        else
            szBuf[j++] = *pszFile;
    }
    szBuf[j] = 0;
    return MyStrDup(szBuf);
}

// Chops input up into CRLF-delimited chunks
// Modifies input
LPSTR GetNextLine(LPSTR pszIn)
{
    LPSTR pszNext;
    while(*pszIn)
    {
        pszNext = strchr(pszIn, '\r');

        if(!pszNext)
            return NULL;
        else if(pszNext[1]=='\n')
        {
            pszNext[0] = pszNext[1] = 0;
            return pszNext+2;
        }
        else
            pszIn = pszNext+1;
    }
    return NULL;
}

// Modifies input. Output is *in-place*
LPSTR FindHeaderParam(LPSTR pszIn, LPSTR pszLook)
{
    LPSTR pszEnd = pszIn + lstrlenA(pszIn);
    BOOL fFound = FALSE;
    LPSTR pszToken = NULL;

    while(pszIn<pszEnd)
    {
        pszToken=strtok(pszIn, " \t;=");
        if(fFound || !pszToken)
            break;

        pszIn = pszToken+lstrlenA(pszToken)+1;

        if(lstrcmpiA(pszToken, pszLook)==0)
            fFound = TRUE;
    }
    if(fFound && pszToken)
    {
        if(pszToken[0]=='"')
            pszToken++;
        int iLen = lstrlenA(pszToken);
        if(pszToken[iLen-1]=='"')
            pszToken[iLen-1]=0;
        return pszToken;
    }
    return NULL;
}

// Modifies input!!
LPSTR ParseHeaders(LPSTR pszIn, LPTSTR* ppszBoundary, LPTSTR* ppszFilename, BOOL* pfInline)
{
    LPSTR pszNext=NULL, pszCurr=NULL, pszToken=NULL, pszToken2=NULL, pszTemp=NULL;
    // int iLen;    ChrisK

    if(pfInline)     *pfInline = FALSE;
    if(ppszFilename) *ppszFilename = NULL;
    if(ppszBoundary) *ppszBoundary = NULL;

    for(pszCurr=pszIn; pszCurr; pszCurr=pszNext)
    {
        // terminate current line with null & get ptr to next
        pszNext = GetNextLine(pszCurr);

        // if we have a blank line, done with headers--exit loop
        if(*pszCurr==0)
        {
            pszCurr = pszNext;
            break;
        }

        if(!(pszToken = strtok(pszCurr, " \t:;")))
            continue;
        pszCurr = pszToken+lstrlenA(pszToken)+1;

        if(lstrcmpiA(pszToken, MULTIPART_MIXED)==0)
        {
            if(ppszBoundary)
            {
                pszTemp = FindHeaderParam(pszCurr, BOUNDARY);
                if(pszTemp)
                {
                    int iLen = lstrlenA(pszTemp);
                    *ppszBoundary = (LPTSTR)MyAlloc(iLen+2+1);
                    (*ppszBoundary)[0] = (*ppszBoundary)[1] = '-';
#ifdef UNICODE
                    mbstowcs(*ppszBoundary+2, pszTemp, lstrlenA(pszTemp)+1);
#else
                    lstrcpyA(*ppszBoundary+2, pszTemp);
#endif
                }
            }
        }
        else if(lstrcmpiA(pszToken, CONTENT_DISPOSITION)==0)
        {
            if(!(pszToken2 = strtok(pszCurr, " \t:;")))
                continue;
            pszCurr = pszToken2+lstrlenA(pszToken2)+1;

            if(lstrcmpiA(pszToken2, INLINE)==0)
            {
                if(pfInline)
                    *pfInline = TRUE;
            }
            else if(lstrcmpiA(pszToken2, ATTACHMENT)!=0)
                continue;

            if(ppszFilename)
            {
                pszTemp = FindHeaderParam(pszCurr, FILENAME);
                if(pszTemp)
                    *ppszFilename = MyStrDup(pszTemp);
            }
        }
    }
    return pszCurr;
}

BOOL g_ForceOnlineAttempted = FALSE;

HRESULT CDownLoad::Execute(void)
{
    TCHAR    szBuf[256];
    DWORD    dwLen;
    HRESULT hr = ERROR_GEN_FAILURE;

    if(!m_hSession || !m_pszURL)
        return ERROR_INVALID_PARAMETER;

    m_hRequest = InternetOpenUrl(m_hSession, m_pszURL, NULL, 0,
                (INTERNET_FLAG_RELOAD|INTERNET_FLAG_DONT_CACHE), (DWORD_PTR)this);

    if(!m_hRequest)
    {
        if (!m_hSession)
            return GetLastError();
        else
        {
            HRESULT hRes = InternetGetLastError(m_hSession);

            if (hRes == INTERNET_STATE_DISCONNECTED)
            {
                DWORD dwConnectedFlags = 0;

                InternetGetConnectedStateEx(&dwConnectedFlags,
                                             NULL,
                                             0,
                                             0);

                if(dwConnectedFlags & INTERNET_CONNECTION_OFFLINE)
                {
                    if(g_ForceOnlineAttempted)
                    {
                        g_ForceOnlineAttempted = FALSE;
                        hRes = INTERNET_CONNECTION_OFFLINE;
                    }
                    else
                    {
                        //ack! the user is offline. not good. let's put them back online.
                        INTERNET_CONNECTED_INFO ci;

                        memset(&ci, 0, sizeof(ci));
                        ci.dwConnectedState = INTERNET_STATE_CONNECTED;

                        InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));

                        g_ForceOnlineAttempted = TRUE;

                        //now that we've reset the state let's recurse the call.
                        //if we fail again, then we'll tell the user they need
                        //to disable the Offline themseleve
                        return Execute();
                    }
                }

            }
            return hRes;
        }
    }

    dwLen = sizeof(szBuf);
    if(HttpQueryInfo(m_hRequest, HTTP_QUERY_CONTENT_LENGTH, szBuf, &dwLen, NULL))
    {
        m_dwContentLength = _ttol(szBuf);
    }
    else
    {
        m_dwContentLength = 0;
    }


    dwLen = sizeof(szBuf);
    if(HttpQueryInfo(m_hRequest, HTTP_QUERY_CONTENT_TYPE, szBuf, &dwLen, NULL))
    {
#ifdef UNICODE
        CHAR szTmp[256];
        wcstombs(szTmp, szBuf, lstrlen(szBuf)+1);
        ParseHeaders(szTmp, &m_pszBoundary, NULL, NULL);
#else
        ParseHeaders(szBuf, &m_pszBoundary, NULL, NULL);
#endif
        if(m_pszBoundary)
            m_dwBoundaryLen = lstrlen(m_pszBoundary);
        else
            goto ExecuteExit; // Chrisk, you have to clean up before exiting

        hr = ProcessRequest();
    }

ExecuteExit:
    if (m_hRequest)
        InternetRequestCloseHandle(m_hRequest);
    m_hRequest = NULL;
    return hr;
}



//+----------------------------------------------------------------------------
//
//    Function:    ShowProgress
//
//    Synopsis:    update running total & call progress callback
//
//    Arguments:    dwRead - additional number of bytes read
//
//    Returns:    none
//
//    History:            ArulM    Created
//                8/896    ChrisK    Ported from \\TRANGO
//
//-----------------------------------------------------------------------------
void CDownLoad::ShowProgress(DWORD dwRead)
{
    int    prc;

    m_dwReadLength += dwRead;    // running total bytes read
    MyAssert(m_dwReadLength <= m_dwContentLength);

    if (m_lpfnCB)
    {
        if (m_dwContentLength)
        {
            prc = (int)((DWORD)100 * m_dwReadLength / m_dwContentLength);
        }
        else
        {
            prc = 0;
        }
        //
        // 5/27/97 jmazner Olympus #4579
        // need to pass in a valid pointer to a CDialingDlg!
        //
        (m_lpfnCB)(m_hRequest,m_lpCDialingDlg,CALLBACK_TYPE_PROGRESS,(LPVOID)&prc,sizeof(prc));
    }
}

//+----------------------------------------------------------------------------
//
//    Function:    FillBuffer
//
//    Synopsis:    takes a buffer that is partially-filled and reads until it is
//                full or until we've reached the end.
//
//    Arguments:    Buffer pointer, buffer size, count of valid data bytes
//
//    Returns:    total number of bytes in buf
//
//    History:            ArulM    Created
//                8/8/96    ChrisK    Ported from \\TRANGO
//
//-----------------------------------------------------------------------------
DWORD CDownLoad::FillBuffer(LPBYTE pbBuf, DWORD dwLen, DWORD dwRead)
{
    DWORD dwTemp;

    while(dwRead < dwLen)
    {
        dwTemp = 0;
        if(!InternetReadFile(m_hRequest, pbBuf+dwRead, (dwLen-dwRead), &dwTemp))
            break;
        if(!dwTemp)
            break;

        ShowProgress(dwTemp);
        dwRead += dwTemp;
    }
    if(dwLen-dwRead)
        memset(pbBuf+dwRead, 0, (size_t)(dwLen-dwRead));
    return dwRead;
}



//+----------------------------------------------------------------------------
//
//    Function:    MoveAndFillBuffer
//
//    Synopsis:    move remaining contents of buffer from middle of buffer back to
//                the beginning & refill buffer.
//
//    Arguements:    Buffer pointer, Buffer size, count of *total* valid data bytes
//                Pointer to start of data to be moved (everything before is nuked)
//
//    Returns:    total number of bytes in buffer
//
//    History:            ArulM    Created
//                8/8/96    ChrisK    Ported from \\TRANGO
//
//-----------------------------------------------------------------------------
DWORD CDownLoad::MoveAndFillBuffer(LPBYTE pbBuf, DWORD dwLen, DWORD dwValid, LPBYTE pbNewStart)
{
    MyAssert(pbNewStart >= pbBuf);
    MyAssert(pbBuf+dwValid >= pbNewStart);

    dwValid -= (DWORD)(pbNewStart-pbBuf);
    if(dwValid)
        memmove(pbBuf, pbNewStart, (size_t)dwValid);

    return FillBuffer(pbBuf, dwLen, dwValid);
}


//+----------------------------------------------------------------------------
//
//    Function:    HandlwDLFile
//
//    Synopsis:    Handle filename:
//                    (1) get full path after macro substituition. (2) Free
//                    pszFile string.
//                    (3) save the file path & inline/attach info internally for
//                    later handling
//                    (4) Create file on disk & return HANDLE
//
//    Aruguments:    pszFile - filename
//                fInLine - value of inline/attached header from the MIME mutli-part
//
//    Returns:    phFile - handle of file created
//                return - ERROR_SUCCESS == success
//
//    History:            ArulM    Created
//                8/8/96    ChrisK    Ported from \\TRANGO
//
//-----------------------------------------------------------------------------
HRESULT CDownLoad::HandleDLFile(LPTSTR pszFile, BOOL fInline, LPHANDLE phFile)
{
    TCHAR szdrive[_MAX_DRIVE];
    TCHAR szPathName[_MAX_PATH];     // This will be the dir we need to create
    TCHAR szdir[_MAX_DIR];
    TCHAR szfname[_MAX_FNAME];
    TCHAR szext[_MAX_EXT];

    MyAssert(phFile);
    *phFile = INVALID_HANDLE_VALUE;

    LPTSTR pszPath = FileToPath(pszFile);
    MyFree(pszFile);

    if(!pszPath)
        return ERROR_INVALID_DATA;


    // Split the provided path to get at the drive and path portion
    _tsplitpath( pszPath, szdrive, szdir, szfname, szext );
    wsprintf (szPathName, TEXT("%s%s"), szdrive, szdir);

    // Create the Directory
    CreateDirectory(szPathName, NULL);

    // create the file
    *phFile = CreateFile(pszPath,
                         GENERIC_WRITE,
                         0,
                         NULL,
                         OPEN_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);
    if(*phFile == INVALID_HANDLE_VALUE)
        return GetLastError();

    CFileInfo* pfi = new CFileInfo(pszPath, fInline);
    if(!pfi)
        return GetLastError();
    AddToFileList(pfi);

    return ERROR_SUCCESS;
}


/*******************************************************************
*
*  NAME:    LoadSz
*
*  SYNOPSIS:  Loads specified string resource into buffer
*
*  EXIT:    returns a pointer to the passed-in buffer
*
*  NOTES:    If this function fails (most likely due to low
*        memory), the returned buffer will have a leading NULL
*        so it is generally safe to use this without checking for
*        failure.
*
********************************************************************/
LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf)
{
    // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        LoadString( g_hInst, idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}

HRESULT CDownLoad::ProcessRequest(void)
{
    LPBYTE  pbData = NULL, pBoundary = NULL;
    DWORD   dwLen = 0;
    HFIND   hFindBoundary = NULL;
    LPTSTR   pszDLFileName = NULL;
    HANDLE  hOutFile = INVALID_HANDLE_VALUE;
    HRESULT hr = E_FAIL;

    MyAssert(m_hRequest && m_pszBoundary);
    MyAssert(m_pszBoundary[0]=='\r' && m_pszBoundary[1]=='\n');
    MyAssert(m_pszBoundary[2]=='-' && m_pszBoundary[3]=='-');
    // Buf Size must be greater than larget possible block of headers
    // also must be greater than the OVERLAP, which must be greater
    // than max size of MIME part boundary (70?)
    MyAssert(DEFAULT_DATABUF_SIZE > OVERLAP_LEN);
    MyAssert(OVERLAP_LEN > 80);

    // init buffer & find-pattern
    if(! (pbData = (LPBYTE)MyAlloc(DEFAULT_DATABUF_SIZE+SLOP)))
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    hFindBoundary = SetFindPattern(m_pszBoundary);

    // find first boundary. If not in first blob, we have too much
    // white-space. Discard & try again (everything before the first
    // boundary is discardable)
    for(pBoundary=NULL; !pBoundary; )
    {
        if(!(dwLen = FillBuffer(pbData, DEFAULT_DATABUF_SIZE, 0)))
            goto iNetError;
        pBoundary = (LPBYTE)Find(hFindBoundary, (LPSTR)pbData, dwLen);
    }

    for(;;)
    {
        MyAssert(pBoundary && pbData && dwLen);
        MyAssert(pBoundary>=pbData && (pBoundary+m_dwBoundaryLen)<=(pbData+dwLen));

        // move remaining data to front of buffer & refill.
        if(!(dwLen = MoveAndFillBuffer(pbData, DEFAULT_DATABUF_SIZE, dwLen, pBoundary+m_dwBoundaryLen)))
            goto iNetError;
        pBoundary = NULL;

        // look for trailing -- after boundary to indicate end of last part
        if(pbData[0]=='-' && pbData[1]=='-')
            break;

        // skip leading CRLF (alway one after boundary)
        MyAssert(pbData[0]=='\r' && pbData[1]=='\n');

        // reads headers and skips everything until doubleCRLF. assumes all
        // headers fit in the single buffer. Pass in pbData+2 to skip
        // leading CRLF. Return value is ptr to first byte past the dbl crlf
        LPTSTR pszFile = NULL;
        BOOL fInline = FALSE;

        LPBYTE pbNext = (LPBYTE)ParseHeaders((LPSTR)pbData+2, NULL, &pszFile, &fInline);

         if(!pszFile || !pbNext)
         {
             hr = ERROR_INVALID_DATA;
             goto error;
         }

        //
        // Make a copy of the file name - will be used
        // for displaying error message
        //
        pszDLFileName = (LPTSTR) MyAlloc(lstrlen(pszFile) + 1);
        lstrcpy(pszDLFileName, pszFile);


        // Handle filename: (1) get full path after macro substituition.
        // (2) Free pszFile string. (3) save the file path & inline/attach info
        // internally for later handling (4) Create file on disk &return HANDLE
        if(hr = HandleDLFile(pszFile, fInline, &hOutFile))
            goto error;

        // move remaining data (after headers) to front of buffer & refill.
        dwLen = MoveAndFillBuffer(pbData, DEFAULT_DATABUF_SIZE, dwLen, pbNext);
        pBoundary = NULL;

        MyAssert(dwLen);
        while(dwLen)
        {
            DWORD dwWriteLen = 0;
            DWORD dwTemp = 0;

            // look for boundary. careful of boundary cut across
            // blocks. Overlapping blocks by 100 bytes to cover this case.
            if(pBoundary = (LPBYTE)Find(hFindBoundary, (LPSTR)pbData, dwLen))
                dwWriteLen = (DWORD)(pBoundary - pbData);
            else if(dwLen > OVERLAP_LEN)
                dwWriteLen = dwLen-OVERLAP_LEN;
            else
                dwWriteLen = dwLen;

            MyAssert(dwWriteLen <= dwLen);
            MyAssert(hOutFile != INVALID_HANDLE_VALUE);

            if(dwWriteLen)
            {
                dwTemp = 0;
                if(!WriteFile(hOutFile, pbData, dwWriteLen, &dwTemp, NULL)
                    || dwTemp!=dwWriteLen)
                {
                    hr = GetLastError();
                    //
                    // If we are out of diskspace, get the drive letter
                    // and display an out of diskspace message
                    //
                    goto error;
                }

            }

            if(pBoundary)
                break;

            // move remaining data (after last byte written) to front of buffer & refill
            dwLen = MoveAndFillBuffer(pbData, DEFAULT_DATABUF_SIZE, dwLen, pbData+dwWriteLen);
        }

        // *truncate* file & close
        MyAssert(hOutFile != INVALID_HANDLE_VALUE);
        SetEndOfFile(hOutFile);

        // close file
        CloseHandle(hOutFile);
        hOutFile = INVALID_HANDLE_VALUE;
        if (NULL != pszDLFileName)
        {
            MyFree(pszDLFileName);
            pszDLFileName = NULL;
        }

        if(!pBoundary)
        {
            MyAssert(dwLen==0); // can only get here on dwLen==0 or found boundary
            goto iNetError;
        }
        // at start of loop we'll discard everything upto and including the boundary
        // if we loop back with pBoundary==NULL, we'll GPF
    }
    return ERROR_SUCCESS;

iNetError:
    hr = InternetGetLastError(m_hSession);
    if(!hr)
        hr = ERROR_INVALID_DATA;
    // goto error;
    // fall through

error:
    if(pbData) MyFree(pbData);
    if(hFindBoundary) FreeFindPattern(hFindBoundary);
    if (NULL != pszDLFileName)
    {
        MyFree(pszDLFileName);
        pszDLFileName = NULL;
    }
    if (hOutFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hOutFile);
        hOutFile = INVALID_HANDLE_VALUE;
    }
    return hr;
}


HRESULT HandleExe(LPTSTR pszPath, HANDLE hCancelSemaphore)
{
    MyAssert( hCancelSemaphore );

    STARTUPINFO         si;
    PROCESS_INFORMATION pi;

    memset(&pi, 0, sizeof(pi));
    memset(&si, 0, sizeof(si));
    if(!CreateProcess(pszPath, NULL, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
        return GetLastError();
    else
    {
        HANDLE lpHandles[2] = {hCancelSemaphore, pi.hProcess};
        DWORD dwRet = 0xDEAF;
        MyDprintf("ICWDL: HandleExe about to wait....\n");

        //
        // 5/23/97 jmazner Olympus #4652
        // sit here and wait until either
        // 1) the process we launched terminates, or
        // 2) the user tells us to cancel
        //
        dwRet = WaitForMultipleObjects( 2, lpHandles, FALSE, INFINITE );

        MyDprintf("ICWDL: ....HandleExe done waiting -- %s was signalled\n",
            (0==(dwRet - WAIT_OBJECT_0))?"hCancelSemaphore":"pi.hProcess");

        // should we try to kill the process here??
         CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        return NO_ERROR;
    }
}

HRESULT HandleReg(LPTSTR pszPath, HANDLE hCancelSemaphore)
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    TCHAR szCmd[MAX_PATH + 1];

    MyAssert( pszPath );
    MyAssert( hCancelSemaphore );

    // 11/20/96  jmazner  Normandy #5272
    // Wrap quotes around pszPath in a directory or file name includes a space.

    lstrcpy(szCmd, REGEDIT_CMD);

    if( '\"' != pszPath[0] )
    {
        // add 2 for two quotes
        MyAssert( (lstrlen(REGEDIT_CMD) + lstrlen(pszPath)) < MAX_PATH );

        lstrcat(szCmd, TEXT("\""));
        lstrcat(szCmd, pszPath);

        int i = lstrlen(szCmd);
        szCmd[i] = '\"';
        szCmd[i+1] = '\0';
    }
    else
    {
        MyAssert( (lstrlen(REGEDIT_CMD) + lstrlen(pszPath)) < MAX_PATH );

        lstrcat(szCmd, pszPath);
    }



    memset(&pi, 0, sizeof(pi));
    memset(&si, 0, sizeof(si));
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;
    if(!CreateProcess(NULL, szCmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
        return GetLastError();
    else
    {
        // HRESULT hr = (WaitAndKillRegeditWindow(10) ? NO_ERROR : E_FAIL);
        HANDLE lpHandles[2] = {hCancelSemaphore, pi.hProcess};
        DWORD dwRet = 0xDEAF;
        MyDprintf("ICWDL: HandleReg about to wait....\n");

        //
        // 5/23/97 jmazner Olympus #4652
        // sit here and wait until either
        // 1) the process we launched terminates, or
        // 2) the user tells us to cancel
        //
        dwRet = WaitForMultipleObjects( 2, lpHandles, FALSE, INFINITE );

        MyDprintf("ICWDL: ....HandleReg done waiting -- %s was signalled\n",
            (0==(dwRet - WAIT_OBJECT_0))?"hCancelSemaphore":"pi.hProcess");

        // should we try to kill the process here??
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        return ERROR_SUCCESS;
    }
}


HRESULT HandleInf(LPTSTR pszPath, HANDLE hCancelSemaphore)
{
    TCHAR szCmd[MAX_PATH + 1];

    MyAssert( pszPath );
    MyAssert( hCancelSemaphore );

    // add 2 for two quotes,
    // subtract 70 for approximate length of string in sprintf
    MyAssert( (lstrlen(pszPath) - 70 + 2) < MAX_PATH );

    // 11/20/96 jmazner Normandy #5272
    // wrap pszPath in quotes in case it includes a space
    if( '\"' != pszPath[0] )
    {
        wsprintf(szCmd, TEXT("rundll setupx.dll,InstallHinfSection DefaultInstall 128 \"%s"), pszPath);
        int i = lstrlen(szCmd);
        szCmd[i] = '\"';
        szCmd[i+1] = '\0';
    }
    else
    {
        wsprintf(szCmd, TEXT("rundll setupx.dll,InstallHinfSection DefaultInstall 128 %s"), pszPath);
    }


    STARTUPINFO         si;
    PROCESS_INFORMATION pi;

    memset(&pi, 0, sizeof(pi));
    memset(&si, 0, sizeof(si));

    si.cb = sizeof(STARTUPINFO);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOW;
    if(!CreateProcess(NULL, szCmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
        return GetLastError();
    else
    {
        HANDLE lpHandles[2] = {hCancelSemaphore, pi.hProcess};
        DWORD dwRet = 0xDEAF;
        MyDprintf("ICWDL: HandleInf about to wait....\n");

        //
        // 5/23/97 jmazner Olympus #4652
        // sit here and wait until either
        // 1) the process we launched terminates, or
        // 2) the user tells us to cancel
        //
        dwRet = WaitForMultipleObjects( 2, lpHandles, FALSE, INFINITE );

        MyDprintf("ICWDL: ....HandleInf done waiting -- %s was signalled\n",
            (0==(dwRet - WAIT_OBJECT_0))?"hCancelSemaphore":"pi.hProcess");

        // should we try to kill the process here??
         CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        return NO_ERROR;
    }
}

#define STR_BSTR    0
#define STR_OLESTR  1
#ifdef UNICODE
#define BSTRFROMANSI(x) (BSTR)(x)
#define OLESTRFROMANSI(x) (LPCOLESTR)(x)
#else
#define BSTRFROMANSI(x) (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x) (LPCOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)
#endif
#define TO_ASCII(x) (TCHAR)((unsigned char)x + 0x30)

//=--------------------------------------------------------------------------=
// MakeWideFromAnsi
//=--------------------------------------------------------------------------=
// given a string, make a BSTR out of it.
//
// Parameters:
//    LPTSTR         - [in]
//    BYTE          - [in]
//
// Output:
//    LPWSTR        - needs to be cast to final desired result
//
// Notes:
//
LPWSTR MakeWideStrFromAnsi (LPSTR psz, BYTE bType)
{
    int i;
    LPWSTR pwsz;

    if (!psz)
        return(NULL);

    if ((i = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0)) <= 0)    // compute the length of the required BSTR
        return NULL;

    switch (bType) {                                                    // allocate the widestr, +1 for null
        case STR_BSTR:
            pwsz = (LPWSTR)SysAllocStringLen(NULL, (i - 1));            // SysAllocStringLen adds 1
            break;
        case STR_OLESTR:
            pwsz = (LPWSTR)CoTaskMemAlloc(i * sizeof(WCHAR));
            break;
        default:
            return(NULL);
    }

    if (!pwsz)
        return(NULL);

    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;

    return(pwsz);

}   /*  MakeWideStrFromAnsi() */

// Get the URL location from the .URL file, and send it to the progress dude
HRESULT CDownLoad::HandleURL(LPTSTR pszPath)
{
    MyAssert( pszPath );

    LPTSTR   pszURL;

    // Create a IUniformResourceLocator object
    IUniformResourceLocator * pURL;
    if (SUCCEEDED(CoCreateInstance(CLSID_InternetShortcut,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IUniformResourceLocator,
                                   (LPVOID*)&pURL)))
    {
        // Get a persist file interface
        IPersistFile *ppf;
        if (SUCCEEDED(pURL->QueryInterface(IID_IPersistFile, (LPVOID*)&ppf)))
        {
            // Attempt to connect the storage of the IURL to the .URL file we
            // downloaded
            if (SUCCEEDED(ppf->Load(OLESTRFROMANSI(pszPath), STGM_READ)))
            {
                // OK, have the URL object give us the location
                if (SUCCEEDED(pURL->GetURL(&pszURL)) && pszURL)
                {
                    // Notify the callback about the URL location
                    (m_lpfnCB)(m_hRequest,m_lpCDialingDlg, CALLBACK_TYPE_URL, (LPVOID)pszURL, lstrlen(pszURL));

                    // Free the allocated URL, since the callback made a copy of it
                    IMalloc* pMalloc;
                    HRESULT hres = SHGetMalloc(&pMalloc);
                    if (SUCCEEDED(hres))
                    {
                        pMalloc->Free(pszURL);
                        pMalloc->Release();
                    }
                }
            }
            // Release the persist file interface
            ppf->Release();
        }
        // release the URL object
        pURL->Release();
    }
    return(NO_ERROR);
}

#define PHONEBOOK_LIBRARY TEXT("ICWPHBK.DLL")
#define PHBK_LOADAPI "PhoneBookLoad"
#define PHBK_MERGEAPI "PhoneBookMergeChanges"
#define PHBK_UNLOADAPI "PhoneBookUnload"
#define PHONEBOOK_SUFFIX TEXT(".PHB")

typedef HRESULT (CALLBACK* PFNPHONEBOOKLOAD)(LPCTSTR pszISPCode, DWORD *pdwPhoneID);
typedef HRESULT (CALLBACK* PFNPHONEBOOKMERGE)(DWORD dwPhoneID, LPTSTR pszFileName);
typedef HRESULT (CALLBACK *PFNPHONEBOOKUNLOAD) (DWORD dwPhoneID);

HRESULT HandleChg(LPTSTR pszPath)
{
    TCHAR szPhoneBookPath[MAX_PATH+1];
    TCHAR *p;
    LPTSTR szFilePart;
    HRESULT hr = ERROR_FILE_NOT_FOUND;
    HINSTANCE hPHBKDLL = NULL;
    FARPROC fp;
    DWORD dwPhoneBook;

    lstrcpy(szPhoneBookPath,pszPath);
    if (lstrlen(szPhoneBookPath) > 4)
    {
        p = &(szPhoneBookPath[lstrlen(szPhoneBookPath)-4]);
    } else {
        hr = ERROR_INVALID_PARAMETER;
        goto HandleChgExit;
    }

    lstrcpy(p,PHONEBOOK_SUFFIX);

    while (*p != '\\' && p > &szPhoneBookPath[0])
        p--;

    p++;
    if(!SearchPath(NULL,p,NULL,MAX_PATH,szPhoneBookPath,&szFilePart))
    {
        hr = GetLastError();
        goto HandleChgExit;
    }

    hPHBKDLL = LoadLibrary(PHONEBOOK_LIBRARY);
    if (!hPHBKDLL)
    {
        hr = GetLastError();
        goto HandleChgExit;
    }

    fp = GetProcAddress(hPHBKDLL,PHBK_LOADAPI);
    if (!fp)
    {
        hr = GetLastError();
        goto HandleChgExit;
    }

    hr = ((PFNPHONEBOOKLOAD)fp)(pszPath,&dwPhoneBook);
    if(hr != ERROR_SUCCESS)
        goto HandleChgExit;

    fp = GetProcAddress(hPHBKDLL,PHBK_MERGEAPI);
    if (!fp)
    {
        hr = GetLastError();
        goto HandleChgExit;
    }

    hr = ((PFNPHONEBOOKMERGE)fp)(dwPhoneBook,pszPath);

    fp = GetProcAddress(hPHBKDLL,PHBK_UNLOADAPI);
    if (!fp)
    {
        hr = GetLastError();
        goto HandleChgExit;
    }

    ((PFNPHONEBOOKUNLOAD)fp)(dwPhoneBook);

HandleChgExit:
    return hr;
}


HRESULT HandleOthers(LPTSTR pszPath)
{
    DWORD_PTR dwErr;
    TCHAR szCmd[MAX_PATH + 1];

    MyAssert( pszPath );

    // 11/20/96  jmazner  Normandy #5272
    // Wrap quotes around pszPath in case it includes a space.

    // add 2 for two quotes
    MyAssert( (lstrlen(pszPath) + 2) < MAX_PATH );

    if( '\"' != pszPath[0] )
    {
        lstrcpy(szCmd,TEXT("\""));
        lstrcat(szCmd, pszPath);

        int i = lstrlen(szCmd);
        szCmd[i] = '\"';
        szCmd[i+1] = '\0';
    }
    else
    {
        lstrcpyn(szCmd, pszPath, lstrlen(pszPath));
    }


    if((dwErr=(DWORD_PTR)ShellExecute(NULL, NULL, szCmd, NULL, NULL, SW_SHOWNORMAL)) < 32)
        return (DWORD)dwErr;
    else
        return ERROR_SUCCESS;
}



LPTSTR GetExtension(LPTSTR pszPath)
{
    LPTSTR pszRet = _tcsrchr(pszPath, '.');
    if(pszRet)
        return pszRet+1;
    else
        return NULL;
}

// Normandy 12093 - ChrisK 12/3/96
// return the error code for the first error that occurs while processing a file,
// but don't stop processing files.
//
HRESULT CDownLoad::Process(void)
{
    HRESULT     hr;
    HRESULT     hrProcess = ERROR_SUCCESS;
    LPTSTR       pszExt;
    CFileInfo   *pfi;

    for(pfi=m_pfiHead; pfi; pfi=pfi->m_pfiNext)
    {
        // Normandy 12093 - ChrisK 12/3/96
        hr = ERROR_SUCCESS;
        if(pfi->m_fInline)
        {
            pszExt = GetExtension(pfi->m_pszPath);
            if(!pszExt)
                continue;

        	if (lstrcmpi(pszExt, EXT_CAB)==0)
				hr = HandleCab(pfi->m_pszPath);
            else if(lstrcmpi(pszExt, EXT_EXE)==0)
                hr = HandleExe(pfi->m_pszPath, m_hCancelSemaphore);
            else if(lstrcmpi(pszExt, EXT_REG)==0)
                hr = HandleReg(pfi->m_pszPath, m_hCancelSemaphore);
            else if(lstrcmpi(pszExt, EXT_CHG)==0)
                hr = HandleChg(pfi->m_pszPath);
            else if(lstrcmpi(pszExt, EXT_INF)==0)
                hr = HandleInf(pfi->m_pszPath, m_hCancelSemaphore);
            else if(lstrcmpi(pszExt, EXT_URL)==0)
                hr = HandleURL(pfi->m_pszPath);
            else
                hr = HandleOthers(pfi->m_pszPath);

            // Normandy 12093 - ChrisK 12/3/96
            if ((ERROR_SUCCESS == hrProcess) && (ERROR_SUCCESS != hr))
                hrProcess = hr;
        }
    }

    // Normandy 12093 - ChrisK 12/3/96
    return hrProcess;
}


HRESULT CDownLoad::SetStatusCallback (INTERNET_STATUS_CALLBACK lpfnCB)
{
    HRESULT hr;

    hr = ERROR_SUCCESS;
    if (!lpfnCB)
    {
        hr = ERROR_INVALID_PARAMETER;
    } else {
        m_lpfnCB = lpfnCB;
    }
    return hr;
}




#ifdef DEBUG
extern "C" HRESULT WINAPI DLTest(LPTSTR pszURL)
{
    CDownLoad* pdl = new CDownLoad(pszURL);
    HRESULT hr = pdl->Execute();
    if(hr) goto done;

    hr = pdl->Process();
done:
    delete pdl;
    return hr;
}
#endif //DEBUG


HRESULT WINAPI DownLoadInit(LPTSTR pszURL, DWORD_PTR FAR *lpCDialingDlg, DWORD_PTR FAR *pdwDownLoad, HWND hWndMain)
{
    g_hWndMain = hWndMain;

    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    CDownLoad* pdl = new CDownLoad(pszURL);
    if (!pdl) goto DownLoadInitExit;

    *pdwDownLoad = (DWORD_PTR)pdl;

    //
    // 5/27/97    jmazner Olympus #4579
    //
    pdl->m_lpCDialingDlg = (DWORD_PTR)lpCDialingDlg;

    hr = ERROR_SUCCESS;

    //
    // 5/23/97    jmazner    Olympus #4652
    // create a semaphore in non-signaled state.  If we ever get a downLoadCancel, we
    // should signal the semaphore, and any waiting threads should notice that and bail out.
    //
    pdl->m_hCancelSemaphore = CreateSemaphore( NULL, 0, 1, TEXT("ICWDL DownloadCancel Semaphore") );
    if( !pdl->m_hCancelSemaphore || (ERROR_ALREADY_EXISTS == GetLastError()) )
    {
        MyDprintf("ICWDL: Unable to create CancelSemaphore!!\n");
        hr = ERROR_ALREADY_EXISTS;
    }

DownLoadInitExit:
    return hr;
}

HRESULT WINAPI DownLoadCancel(DWORD_PTR dwDownLoad)
{
    MyDprintf("ICWDL: DownLoadCancel called\n");
    if (dwDownLoad)
    {

        MyDprintf("ICWDL: DownLoadCancel releasing m_hCancelSemaphore\n");
        MyAssert( ((CDownLoad*)dwDownLoad)->m_hCancelSemaphore );
        ReleaseSemaphore( ((CDownLoad*)dwDownLoad)->m_hCancelSemaphore, 1, NULL );

        ((CDownLoad*)dwDownLoad)->Cancel();
        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }
}

HRESULT WINAPI DownLoadExecute(DWORD_PTR dwDownLoad)
{
    if (dwDownLoad)
    {
        return     ((CDownLoad*)dwDownLoad)->Execute();
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }
}
HRESULT WINAPI DownLoadClose(DWORD_PTR dwDownLoad)
{
    MyDprintf("ICWDL: DownLoadClose called \n");

    if (dwDownLoad)
    {
        // be good and cancel any downloads that are in progress
        ((CDownLoad*)dwDownLoad)->Cancel();

        delete ((CDownLoad*)dwDownLoad);
        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }
}




HRESULT WINAPI DownLoadSetStatusCallback
(
    DWORD_PTR dwDownLoad,
    INTERNET_STATUS_CALLBACK lpfnCB
)
{
    if (dwDownLoad)
    {
        return     ((CDownLoad*)dwDownLoad)->SetStatusCallback(lpfnCB);
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }
}

HRESULT WINAPI DownLoadProcess(DWORD_PTR dwDownLoad)
{
    MyDprintf("ICWDL: DownLoadProcess\n");
    if (dwDownLoad)
    {
        return ((CDownLoad*)dwDownLoad)->Process();
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\dialerr.cpp ===
// DialErr.cpp : Implementation of CDialErr
#include "stdafx.h"
#include "icwhelp.h"
#include "DialErr.h"

/////////////////////////////////////////////////////////////////////////////
// CDialErr


HRESULT CDialErr::OnDraw(ATL_DRAWINFO& di)
{
	RECT& rc = *(RECT*)di.prcBounds;
	Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
	DrawText(di.hdcDraw, _T("ATL 2.0"), -1, &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\debug.cpp ===
//
//
//
#include "stdafx.h"

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "shdocvw"
#define SZ_MODULE           "SHDOCVW"
#define DECLARE_DEBUG
#include "..\inc\debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\dialerr.h ===
// DialErr.h : Declaration of the CDialErr

#ifndef __DIALERR_H_
#define __DIALERR_H_

/////////////////////////////////////////////////////////////////////////////
// CDialErr
class ATL_NO_VTABLE CDialErr :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDialErr,&CLSID_DialErr>,
	public CComControl<CDialErr>,
	public IDispatchImpl<IDialErr, &IID_IDialErr, &LIBID_ICWHELPLib>,
	public IPersistStreamInitImpl<CDialErr>,
	public IOleControlImpl<CDialErr>,
	public IOleObjectImpl<CDialErr>,
	public IOleInPlaceActiveObjectImpl<CDialErr>,
	public IViewObjectExImpl<CDialErr>,
	public IOleInPlaceObjectWindowlessImpl<CDialErr>
{
public:
	CDialErr()
	{
 
	}

DECLARE_REGISTRY_RESOURCEID(IDR_DIALERR)

BEGIN_COM_MAP(CDialErr) 
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IDialErr)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CDialErr)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CDialErr)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
		return S_OK;
	}

// IDialErr
public:
	HRESULT OnDraw(ATL_DRAWINFO& di);

};

#endif //__DIALERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwdl\sources.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwdl

MAJORCOMP=GETCONN
MINORCOMP=ICWDL


TARGETNAME=ICWDL
TARGETTYPE=DYNLINK
TARGETPATH=obj

DLLENTRY=DllEntryPoint
DLLBASE=$(DEFBASEADDR)
DLLDEF=..\icwdl.def

NOT_LEAN_AND_MEAN   =1
RCNOFONTMAP         =1
C_DEFINES           =-DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

USE_MSVCRT          = 1

SOURCES=                \
    ..\icwdl.rc         \
    ..\boyer.cpp        \
    ..\download.cpp	    \
    ..\cabhandler.cpp

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib      \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\tapi32.lib        \
    $(SDK_LIB_PATH)\advapi32.lib      \
    $(SDK_LIB_PATH)\gdi32.lib         \
    $(SDK_LIB_PATH)\shell32.lib       \
    $(SDK_LIB_PATH)\wininet.lib       \
    $(SDK_LIB_PATH)\ole32.lib         \
    $(SDK_LIB_PATH)\oleaut32.lib      \
    $(SDK_LIB_PATH)\uuid.lib          \
!if defined(NOT_UNICODE)
    $(GETCONN_DIR)\lib\ansi\$O\stocklib.lib
!else
    $(GETCONN_DIR)\lib\unicode\$O\stocklib.lib
!endif

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pch.hpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\cpicwhelp.h ===
//////////////////////////////////////////////////////////////////////////////
// CProxy_RefDialEvents
template <class T>
class CProxy_RefDialEvents : public IConnectionPointImpl<T, &DIID__RefDialEvents, CComDynamicUnkArray>
{
public:
//methods:
//_RefDialEvents : IDispatch
public:
	void Fire_RasDialStatus(WORD wRasEvent)
	{
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                VARIANTARG* pvars = new VARIANTARG[1];
                VariantInit(&pvars[0]);
                pvars[0].vt  = VT_I2;
                pvars[0].iVal= wRasEvent;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
		}
		pT->Unlock();
	}
	void Fire_DownloadProgress(
		long lProgress)
	{
		VARIANTARG* pvars = new VARIANTARG[1];
		for (int i = 0; i < 1; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= lProgress;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}
	void Fire_DownloadComplete(
		BSTR  bstrURL,
		long  lStatus)
	{
		VARIANTARG* pvars = new VARIANTARG[2];
		for (int i = 0; i < 2; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[1].vt = VT_BSTR;
				pvars[1].bstrVal= bstrURL;
				pvars[0].vt = VT_I4;
				pvars[0].lVal= lStatus;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}
	void Fire_RasConnectComplete(
		long bSuccess)
	{
		VARIANTARG* pvars = new VARIANTARG[1];
		for (int i = 0; i < 1; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= bSuccess;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}

};


//////////////////////////////////////////////////////////////////////////////
// CProxy_WebGateEvents
template <class T>
class CProxy_WebGateEvents : public IConnectionPointImpl<T, &DIID__WebGateEvents, CComDynamicUnkArray>
{
public:
//methods:
//_WebGateEvents : IDispatch
public:
	void Fire_WebGateDownloadComplete(
		long lProgress)
	{
		VARIANTARG* pvars = new VARIANTARG[1];
		for (int i = 0; i < 1; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= lProgress;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}

	void Fire_WebGateDownloadProgress(
		long lProgress)
	{
		VARIANTARG* pvars = new VARIANTARG[1];
		for (int i = 0; i < 1; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= lProgress;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}

};


//////////////////////////////////////////////////////////////////////////////
// CProxy_INSHandlerEvents
template <class T>
class CProxy_INSHandlerEvents : public IConnectionPointImpl<T, &DIID__INSHandlerEvents, CComDynamicUnkArray>
{
public:
//methods:
//_INSHandlerEvents : IDispatch
public:
	void Fire_RunningCustomExecutable()
	{
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
	}
	void Fire_KillConnection()
	{
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\enumodem.cpp ===
/*-----------------------------------------------------------------------------
	enumodem.cpp

	Holds code that deals with the "Choose a modem" dialog needed when user has
	multiple modems installed

	Copyright (C) 1996-1998 Microsoft Corporation
	All rights reserved

	Authors:
		jmazner Jeremy Mazner

	History:
		10/19/96        jmazner Created, cloned almost verbatim from 
							INETCFG's rnacall.cpp and export.cpp    
        1-9-98          donaldm Adapted from ICWCONN1
-----------------------------------------------------------------------------*/


#include "stdafx.h"
#include "enumodem.h"

#include <windowsx.h>

// from psheet.cpp
extern void ProcessDBCS(HWND hDlg, int ctlID);


/*******************************************************************

  NAME:    CEnumModem::CEnumModem

  SYNOPSIS:  Constructor for class to enumerate modems

  NOTES:    Useful to have a class rather than C functions for
	this, due to how the enumerators function

********************************************************************/
CEnumModem::CEnumModem() :
  m_dwError(ERROR_SUCCESS),m_lpData(NULL),m_dwIndex(0)
{
  DWORD cbSize = 0;
}


/*******************************************************************

  NAME:     CEnumModem::ReInit

  SYNOPSIS: Re-enumerate the modems, freeing the old memory.

********************************************************************/
DWORD CEnumModem::ReInit()
{
  DWORD cbSize = 0;
  RNAAPI cRnaapi;

  // Clean up the old list
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
  m_dwNumEntries = 0;
  m_dwIndex = 0;

  // call RasEnumDevices with no buffer to find out required buffer size
  m_dwError = cRnaapi.RasEnumDevices(NULL, &cbSize, &m_dwNumEntries);

  // Special case check to work around RNA bug where ERROR_BUFFER_TOO_SMALL
  // is returned even if there are no devices.
  // If there are no devices, we are finished.
  if (0 == m_dwNumEntries)
  {
    m_dwError = ERROR_SUCCESS;
    return m_dwError;
  }

  // Since we were just checking how much mem we needed, we expect
  // a return value of ERROR_BUFFER_TOO_SMALL, or it may just return
  // ERROR_SUCCESS (ChrisK  7/9/96).
  if (ERROR_BUFFER_TOO_SMALL != m_dwError && ERROR_SUCCESS != m_dwError)
  {
    return m_dwError;
  }

  // Allocate the space for the data
  m_lpData = (LPRASDEVINFO) new CHAR[cbSize];
  if (NULL == m_lpData)
  {
	  TraceMsg(TF_GENERAL, TEXT("ICWCONN1: CEnumModem: Failed to allocate device list buffer\n"));
	  m_dwError = ERROR_NOT_ENOUGH_MEMORY;
	  return m_dwError;
  }
  m_lpData->dwSize = sizeof(RASDEVINFO);
  m_dwNumEntries = 0;

  // enumerate the modems into buffer
  m_dwError = cRnaapi.RasEnumDevices(m_lpData, &cbSize,
    &m_dwNumEntries);

    if (ERROR_SUCCESS != m_dwError)
	return m_dwError;

    //
    // ChrisK Olympus 4560 do not include VPN's in the list
    //
    DWORD dwTempNumEntries;
    DWORD idx;
    LPRASDEVINFO lpNextValidDevice;

    dwTempNumEntries = m_dwNumEntries;
    lpNextValidDevice = m_lpData;

	//
	// Walk through the list of devices and copy non-VPN device to the first
	// available element of the array.
	//
	for (idx = 0;idx < dwTempNumEntries; idx++)
	{
		if ((0 == lstrcmpi(RASDEVICETYPE_MODEM,m_lpData[idx].szDeviceType)) || 
            (0 == lstrcmpi(RASDEVICETYPE_ISDN,m_lpData[idx].szDeviceType)))
		{
			if (lpNextValidDevice != &m_lpData[idx])
			{
				MoveMemory(lpNextValidDevice ,&m_lpData[idx],sizeof(RASDEVINFO));
			}
			lpNextValidDevice++;
		}
		else
		{
			m_dwNumEntries--;
		}
	}


  return m_dwError;
}


/*******************************************************************

  NAME:    CEnumModem::~CEnumModem

  SYNOPSIS:  Destructor for class

********************************************************************/
CEnumModem::~CEnumModem()
{
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
}

/*******************************************************************

  NAME:     CEnumModem::Next

  SYNOPSIS: Enumerates next modem 

  EXIT:     Returns a pointer to device info structure.  Returns
	    NULL if no more modems or error occurred.  Call GetError
	    to determine if error occurred.

********************************************************************/
TCHAR * CEnumModem::Next()
{
  if (m_dwIndex < m_dwNumEntries)
  {
    return m_lpData[m_dwIndex++].szDeviceName;
  }

  return NULL;
}


/*******************************************************************

  NAME:     CEnumModem::GetDeviceTypeFromName

  SYNOPSIS: Returns type string for specified device.

  EXIT:     Returns a pointer to device type string for first
	    device name that matches.  Returns
	    NULL if no device with specified name is found

********************************************************************/

TCHAR * CEnumModem::GetDeviceTypeFromName(LPTSTR szDeviceName)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceName, szDeviceName))
    {
      return m_lpData[dwIndex].szDeviceType;
    }
    dwIndex++;
  }

  return NULL;
}


/*******************************************************************

  NAME:     CEnumModem::GetDeviceNameFromType

  SYNOPSIS: Returns type string for specified device.

  EXIT:     Returns a pointer to device name string for first
	    device type that matches.  Returns
	    NULL if no device with specified Type is found

********************************************************************/

TCHAR * CEnumModem::GetDeviceNameFromType(LPTSTR szDeviceType)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceType, szDeviceType))
    {
        return m_lpData[dwIndex].szDeviceName;
    }
    dwIndex++;
  }

  return NULL;
}


/*******************************************************************

  NAME:     CEnumModem::GetDeviceName
            CEnumModem::GetDeviceType

  SYNOPSIS: Returns the device name or type for the selected device.

  REMARKS:
            ONLY call this function after calling ReInit to initialize
            the device list. The device index is relative to the 
            current copy of the device list.

  EXIT:     Returns a pointer to the device name or type. 

  donsc - 3/11/98 
      Added this function because we need to be able to select a device
      from the list.
********************************************************************/

TCHAR * CEnumModem::GetDeviceName(DWORD dwIndex)
{
    if(dwIndex>=m_dwNumEntries)
        return NULL;

    return m_lpData[dwIndex].szDeviceName;
}

TCHAR * CEnumModem::GetDeviceType(DWORD dwIndex)
{
    if(dwIndex>=m_dwNumEntries)
        return NULL;

    return m_lpData[dwIndex].szDeviceType;
}


/*******************************************************************

  NAME:     CEnumModem::VerifyDeviceNameAndType

  SYNOPSIS: Determines whether there is a device with the name
	    and type given.

  EXIT:     Returns TRUE if the specified device was found, 
	    FALSE otherwise.

********************************************************************/

BOOL CEnumModem::VerifyDeviceNameAndType(LPTSTR szDeviceName, LPTSTR szDeviceType)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceType, szDeviceType) &&
      !lstrcmp(m_lpData[dwIndex].szDeviceName, szDeviceName))
    {
      return TRUE;
    }
    dwIndex++;
  }

  return FALSE;
}





/*******************************************************************

  NAME:     ChooseModemDlgProc

  SYNOPSIS: Dialog proc for choosing modem

********************************************************************/

INT_PTR CALLBACK ChooseModemDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
    BOOL fRet;

    switch (uMsg)
    {
        case WM_INITDIALOG:
          {
              // lParam contains pointer to CHOOSEMODEMDLGINFO struct, set it
              // in window data
              Assert(lParam);
              PCHOOSEMODEMDLGINFO pInfo = (PCHOOSEMODEMDLGINFO) lParam;
              pInfo->hr = ERROR_SUCCESS;
              SetWindowLongPtr(hDlg,DWLP_USER,lParam);
              fRet = ChooseModemDlgInit(hDlg,pInfo);
              if (!fRet)
              {
                  // An error occured.
                  EndDialog(hDlg,FALSE);
                  pInfo->hr = ERROR_INETCFG_UNKNOWN;
              }
              return fRet;
          }
          break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
            case IDC_CMDOK:
                {
                    // get data pointer from window data
                    PCHOOSEMODEMDLGINFO pChooseModemDlgInfo =
                        (PCHOOSEMODEMDLGINFO) GetWindowLongPtr(hDlg,DWLP_USER);
                    Assert(pChooseModemDlgInfo);

                    // pass the data to the OK handler
                    fRet=ChooseModemDlgOK(hDlg,pChooseModemDlgInfo);
                    if (fRet)
                    {
                        EndDialog(hDlg,TRUE);
                        pChooseModemDlgInfo->hr = ERROR_SUCCESS;
                    }
                }
                break;

            case IDC_CMDCANCEL:
            case IDCANCEL:
                {
                    PCHOOSEMODEMDLGINFO pInfo = (PCHOOSEMODEMDLGINFO) GetWindowLongPtr(hDlg,DWLP_USER);
                   EndDialog(hDlg,FALSE);
                   pInfo->hr = ERROR_CANCELLED;
                }
                break;                  
            }
            break;
    }

    return FALSE;
}


/*******************************************************************

  NAME:    ChooseModemDlgInit

  SYNOPSIS: proc to handle initialization of dialog for choosing modem

********************************************************************/

BOOL ChooseModemDlgInit(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo)
{
    Assert(pChooseModemDlgInfo);

    // put the dialog in the center of the screen
    //RECT rc;
    //GetWindowRect(hDlg, &rc);
    //SetWindowPos(hDlg, NULL,
    //      ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
    //      ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
    //      0, 0, SWP_NOSIZE | SWP_NOACTIVATE);

    ProcessDBCS(hDlg, IDC_MODEM);
    // fill the combobox with available modems
    DWORD dwRet = InitModemList(GetDlgItem(hDlg,IDC_MODEM));
    pChooseModemDlgInfo->hr = dwRet;
    if (ERROR_SUCCESS != dwRet)
    {
        TraceMsg(TF_GENERAL,TEXT("ICWCONN1: ChooseModemDlgInit: Error initializing modem list!\n"));
        return FALSE;
    }

    return TRUE;
}

/*******************************************************************

  NAME:    ChooseModemDlgOK

  SYNOPSIS:  OK handler for dialog for choosing modem

********************************************************************/

BOOL ChooseModemDlgOK(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo)
{
	Assert(pChooseModemDlgInfo);

	// should always have a selection in combo box if we get here
	Assert(ComboBox_GetCurSel(GetDlgItem(hDlg,IDC_MODEM)) >= 0);

	// get modem name out of combo box
	ComboBox_GetText(GetDlgItem(hDlg,IDC_MODEM),
		pChooseModemDlgInfo->szModemName,
		ARRAYSIZE(pChooseModemDlgInfo->szModemName));
	NULL_TERM_TCHARS(pChooseModemDlgInfo->szModemName);
	Assert(lstrlen(pChooseModemDlgInfo->szModemName));
    
	// clear the modem list
	ComboBox_ResetContent(GetDlgItem(hDlg,IDC_MODEM));
	
	return TRUE;
}


/*******************************************************************

  NAME:    InitModemList

  SYNOPSIS:  Fills a combo box window with installed modems

  ENTRY:    hCB - combo box window to fill
  
********************************************************************/
HRESULT InitModemList (HWND hCB)
{
	TraceMsg(TF_GENERAL,TEXT("ICWCONN1::enumodem.cpp  InitModemList()\n"));

	LPTSTR pNext;
	int   nIndex;
	Assert(hCB);

	CEnumModem cEnumModem;

    cEnumModem.ReInit();

	// clear out the combo box
	ComboBox_ResetContent(hCB);

	while ( pNext = cEnumModem.Next() )
	{
		// Add the device to the combo box
		nIndex = ComboBox_AddString(hCB, pNext);
		ComboBox_SetItemData(hCB, nIndex, NULL);
	}

	// Select the default device
	ComboBox_SetCurSel(hCB, nIndex);

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\icwcfg.h ===
// ICWCfg.h : Declaration of the CICWSystemConfig

#ifndef __ICWSYSTEMCONFIG_H_
#define __ICWSYSTEMCONFIG_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CICWSystemConfig
class ATL_NO_VTABLE CICWSystemConfig :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CICWSystemConfig,&CLSID_ICWSystemConfig>,
	public CComControl<CICWSystemConfig>,
	public IDispatchImpl<IICWSystemConfig, &IID_IICWSystemConfig, &LIBID_ICWHELPLib>,
	public IPersistStreamInitImpl<CICWSystemConfig>,
	public IOleControlImpl<CICWSystemConfig>,
	public IOleObjectImpl<CICWSystemConfig>,
	public IOleInPlaceActiveObjectImpl<CICWSystemConfig>,
	public IViewObjectExImpl<CICWSystemConfig>,
	public IOleInPlaceObjectWindowlessImpl<CICWSystemConfig>,
    public IObjectSafetyImpl<CICWSystemConfig>
{
public:
	CICWSystemConfig()
	{
    	m_bNeedsReboot = FALSE;
    	m_bNeedsRestart = FALSE;
    	m_bQuitWizard = FALSE;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_ICWSYSTEMCONFIG)

BEGIN_COM_MAP(CICWSystemConfig) 
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IICWSystemConfig)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CICWSystemConfig)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CICWSystemConfig)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = 0;
		return S_OK;
	}

// IICWSystemConfig
public:
	STDMETHOD(VerifyRASIsRunning)(/*[out, retval]*/ BOOL *pbRetVal);
	BOOL m_bNeedsReboot;
	BOOL m_bNeedsRestart;
	BOOL m_bQuitWizard;
	STDMETHOD(get_QuitWizard)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(get_NeedsReboot)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(get_NeedsRestart)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(ConfigSystem)(/*[out, retval]*/ BOOL *pbRetVal);
	HRESULT OnDraw(ATL_DRAWINFO& di);
	STDMETHOD (CheckPasswordCachingPolicy)(/*[out, retval]*/ BOOL *pbRetVal);

private:
    void InstallScripter(void);

};

#endif //__ICWSYSTEMCONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\icwcfg.cpp ===
// ICWCfg.cpp : Implementation of CICWSystemConfig
#include "stdafx.h"
#include "icwhelp.h"
#include "ICWCfg.h"

#include <winnetwk.h>
#include <regstr.h>

/////////////////////////////////////////////////////////////////////////////
// CICWSystemConfig


HRESULT CICWSystemConfig::OnDraw(ATL_DRAWINFO& di)
{
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//    Function    IsMSDUN11Installed
//
//    Synopsis    Check if MSDUN 1.1 or higher is installed
//
//    Arguments    none
//
//    Returns        TRUE - MSDUN 1.1 is installed
//
//    History        5/28/97 ChrisK created for Olympus Bug 4392
//              1/13/98 DONALDM Copied from ICW \\drywall\slm
//
//-----------------------------------------------------------------------------
#define DUN_11_Version (1.1)
BOOL IsMSDUN11Installed()
{
    CHAR    szBuffer[MAX_PATH] = {"\0"};
    HKEY    hkey = NULL;
    BOOL    bRC = FALSE;
    DWORD   dwType = 0;
    DWORD   dwSize = sizeof(szBuffer);
    DOUBLE  dVersion = 0.0;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Services\\RemoteAccess"),
        &hkey))
    {
        goto IsMSDUN11InstalledExit;
    }

    if (ERROR_SUCCESS != RegQueryValueEx(hkey,
        TEXT("Version"),
        NULL,
        &dwType,
        (LPBYTE)szBuffer,
        &dwSize))
    {
        goto IsMSDUN11InstalledExit;
    }

    dVersion = atof(szBuffer);
    if (dVersion >= DUN_11_Version)
    {
        bRC =  TRUE;
    }
IsMSDUN11InstalledExit:
    if (hkey != NULL)
    {
        RegCloseKey(hkey);
        hkey = NULL;
    }
    return bRC;
}

//
//    Function    IsScriptingInstalled
//
//    Synopsis    Check to see if scripting is already installed
//
//    Arguments    none
//
//    Returns        TRUE - scripting has been installed
//
//    History        10/14/96    ChrisK    Creaed
//              1/13/98 DONALDM Copied from ICW \\drywall\slm
//
//-----------------------------------------------------------------------------
BOOL IsScriptingInstalled()
{
    BOOL        bRC = FALSE;
    HKEY        hkey = NULL;
    DWORD       dwSize = 0;
    DWORD       dwType = 0;
    LONG        lrc = 0;
    HINSTANCE   hInst = NULL;
    TCHAR       szData[MAX_PATH+1];

    if (VER_PLATFORM_WIN32_NT == g_dwPlatform)
    {
        bRC = TRUE;
    }
    else if (IsMSDUN11Installed())
    {
        bRC = TRUE;
    }
    else
    {
        //
        // Verify scripting by checking for smmscrpt.dll in RemoteAccess registry key
        //
        if (1111 <= g_dwBuild)
        {
            bRC = TRUE;
        }
        else
        {
            bRC = FALSE;
            hkey = NULL;
            lrc=RegOpenKey(HKEY_LOCAL_MACHINE,TEXT("System\\CurrentControlSet\\Services\\RemoteAccess\\Authentication\\SMM_FILES\\PPP"),&hkey);
            if (ERROR_SUCCESS == lrc)
            {
                dwSize = sizeof(TCHAR)*MAX_PATH;
                lrc = RegQueryValueEx(hkey,TEXT("Path"),0,&dwType,(LPBYTE)szData,&dwSize);
                if (ERROR_SUCCESS == lrc)
                {
                    if (0 == lstrcmpi(szData,TEXT("smmscrpt.dll")))
                        bRC = TRUE;
                }
            }
            if (hkey)
                RegCloseKey(hkey);
            hkey = NULL;
        }

        //
        // Verify that the DLL can be loaded
        //
        if (bRC)
        {
            hInst = LoadLibrary(TEXT("smmscrpt.dll"));
            if (hInst)
                FreeLibrary(hInst);
            else
                bRC = FALSE;
            hInst = NULL;
        }
    }
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function    InstallScripter
//
//    Synopsis    Install scripting on win95 950.6 builds (not on OSR2)
//
//    Arguments    none
//
//    Returns        none
//
//    History        10/9/96    ChrisK    Copied from mt.cpp in \\trango sources
//              1/13/98 DONALDM Copied from ICW \\drywall\slm
//-----------------------------------------------------------------------------
void CICWSystemConfig::InstallScripter()
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    MSG                    msg ;
    DWORD                iWaitResult = 0;

    TraceMsg(TF_SYSTEMCONFIG, TEXT("ICWHELP: Install Scripter.\r\n"));

    //
    // check if scripting is already set up
    //
    if (!IsScriptingInstalled())
    {
        TCHAR szCommandLine[] = TEXT("\"icwscrpt.exe\"");

        memset(&pi, 0, sizeof(pi));
        memset(&si, 0, sizeof(si));
        if(!CreateProcess(NULL, szCommandLine, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
        {
            TraceMsg(TF_SYSTEMCONFIG, TEXT("ICWHELP: Cant find ICWSCRPT.EXE\r\n"));
        }
        else
        {
            TraceMsg(TF_SYSTEMCONFIG, TEXT("ICWHELP: Launched ICWSCRPT.EXE. Waiting for exit.\r\n"));
            //
            // wait for event or msgs. Dispatch msgs. Exit when event is signalled.
            //
            while((iWaitResult=MsgWaitForMultipleObjects(1, &pi.hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
            {
                //
                // read all of the messages in this next loop
                   // removing each message as we read it
                //
                   while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                   {
                    TraceMsg(TF_SYSTEMCONFIG, TEXT("ICWHELP: Got msg\r\n"));
                    //
                    // how to handle quit message?
                    //
                    if (msg.message == WM_QUIT)
                    {
                        TraceMsg(TF_SYSTEMCONFIG, TEXT("ICWHELP: Got quit msg\r\n"));
                        goto done;
                    }
                    else
                        DispatchMessage(&msg);
                }
            }
        done:
             CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
            TraceMsg(TF_SYSTEMCONFIG, TEXT("ICWHELP: ICWSCRPT.EXE done\r\n"));
        }
    }
}

//+----------------------------------------------------------------------------
//    Function    ConfigSystem
//
//    Synopsis    Make sure that the system is configured for RAS operations
//
//    Arguments    none
//
//    Return        FALSE - if the is not configured.  Caller needs to
//              call NeedsReboot QuitWizard to get the proper action
//              to take.
//              NeedsReboot means that we installed stuff, but need the user
//              to reboot for the changes to take place
//              QuitWizard means just that, time to bail out
//              Neither set, means to ask the user user if they really want to
//              Quit.
//              TRUE  - The things are ready to go
//
//    History        10/16/96    ChrisK    Created
//              1/13/98 DONALDM Copied from ICW \\drywall\slm
//
//-----------------------------------------------------------------------------
STDMETHODIMP CICWSystemConfig::ConfigSystem(BOOL *pbRetVal)
{
    HINSTANCE   hinetcfg;
    TCHAR       szBuff256[256+1];
    FARPROC     fp;
    HRESULT     hr;
    
    // Assume a failure below.
    *pbRetVal = FALSE;

    //
    // Locate installation entry point
    //
    hinetcfg = LoadLibrary(TEXT("INETCFG.DLL"));
    if (!hinetcfg)
    {
        wsprintf(szBuff256,GetSz(IDS_CANTLOADINETCFG),TEXT("INETCFG.DLL"));
        ::MessageBox(GetActiveWindow(),szBuff256,GetSz(IDS_TITLE),MB_MYERROR);
        m_bQuitWizard = TRUE;
        return S_OK;
    }

    fp = GetProcAddress(hinetcfg,"InetConfigSystem");
    if (!fp)
    {
        MsgBox(IDS_CANTLOADCONFIGAPI, MB_MYERROR);
        m_bQuitWizard = TRUE;
        return S_OK;
    }

    // Disable the active window, since any UI the following function brings
    // up needs to be modal.
    HWND    hWnd = GetActiveWindow();
    
    // Install and configure TCP/IP and RNA
    hr = ((PFNCONFIGAPI)fp)(hWnd,
                            INETCFG_INSTALLRNA | 
                            INETCFG_INSTALLTCP | 
                            INETCFG_INSTALLMODEM |
                            (IsNT()?INETCFG_SHOWBUSYANIMATION:0) |
                            INETCFG_REMOVEIFSHARINGBOUND,
                            &m_bNeedsReboot);

    // Renable the window, and bring it back to the top of the Z-Order
    ::SetForegroundWindow(hWnd);
//    ::BringWindowToTop(hWnd);
//    ::SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
                                
    if (hinetcfg) 
        FreeLibrary(hinetcfg);
    hinetcfg = NULL;

    // See what happened during the config call
    if (hr == ERROR_CANCELLED) 
    {
        return S_OK;
    } 
    else if (hr != ERROR_SUCCESS) 
    {
        WORD wTemp = ( VER_PLATFORM_WIN32_WINDOWS == g_dwPlatform )
            ? IDS_CONFIGAPIFAILEDRETRY : IDS_CONFIGURENTFAILEDRETRY;

        //
        // No retry anymore as its not going to help, just
        // provide the user with  an OK message
        // MKarki (4/15/97) Fix for Bug #7004
        //
        ::MessageBox(GetActiveWindow(),GetSz(wTemp),GetSz(IDS_TITLE),
                        MB_MYERROR | MB_OK);
        m_bQuitWizard = TRUE;
        return hr;
    } 
    else
    {
        // ChrisK - added 10/9/96
        // BUGBUG can this fail, and if so is it a problem???
        // original ICW code does not handle failure case here
        InstallScripter();  
    }

    
    // See if we need to reboot.  If not, we need to see if the user is logged in
    if (!m_bNeedsReboot)
    {
        TCHAR   szUser[MAX_PATH];
        DWORD   cchUser = ARRAYSIZE(szUser);
        
        // Verify the user is logged on.
        if (NO_ERROR != WNetGetUser(NULL,szUser, &cchUser))
        {
            // Failed to get user info, so we need to restart with a loggin
            m_bNeedsRestart = TRUE;
        }
        else
        {
            // User is logged in, so we are happy.
            *pbRetVal = TRUE;
        }
    }
    return S_OK;
}

STDMETHODIMP CICWSystemConfig::get_NeedsReboot(BOOL * pVal)
{
    *pVal = m_bNeedsReboot;
    return S_OK;
}

STDMETHODIMP CICWSystemConfig::get_NeedsRestart(BOOL * pVal)
{
    *pVal = m_bNeedsRestart;
    return S_OK;
}

STDMETHODIMP CICWSystemConfig::get_QuitWizard(BOOL * pVal)
{
    *pVal = m_bQuitWizard;
    return S_OK;
}

//+----------------------------------------------------------------------------
//    Function    VerifyRasServicesRunning
//
//    Synopsis    Make sure that the RAS services are enabled and running
//
//    Arguments    none
//
//    Return        FALSE - if the services couldn't be started
//
//    History        10/16/96    ChrisK    Created
//              1/13/98 DONALDM Copied from ICW \\drywall\slm
//
//-----------------------------------------------------------------------------
STDMETHODIMP CICWSystemConfig::VerifyRASIsRunning(BOOL *pbRetVal)
{
    HINSTANCE   hInst = NULL;
    FARPROC     fp = NULL;
    HRESULT     hr;

    *pbRetVal   = FALSE;        // Don't assume a positive result
    hInst = LoadLibrary(TEXT("INETCFG.DLL"));
    if (hInst)
    {
        fp = GetProcAddress(hInst, "InetStartServices");
        if (fp)
        {
            //
            // Check Services
            //
            hr = ((PFINETSTARTSERVICES)fp)();
            if (ERROR_SUCCESS == hr)
            {
                *pbRetVal = TRUE;   // Success.
            }
            else
            {
                // Report the error, using the Current Active Window
                ::MessageBox(GetActiveWindow(), GetSz(IDS_SERVICEDISABLED),
                    GetSz(IDS_TITLE),MB_MYERROR | MB_OK);
            }
        }
        FreeLibrary(hInst);
    }
    return S_OK;
}

const TCHAR szNetworkPolicies[] = REGSTR_PATH_POLICIES TEXT("\\") REGSTR_KEY_NETWORK;
const TCHAR szDisableCaching[] = REGSTR_VAL_DISABLEPWDCACHING;

//+----------------------------------------------------------------------------
//    Function    CheckPasswordCachingPolicy
//
//    Synopsis    check to see if a policy as been set against password caching
//
//    Arguments   none
//
//    Return      TRUE - if password caching is disabled
//
//    History        
//
//-----------------------------------------------------------------------------
STDMETHODIMP CICWSystemConfig::CheckPasswordCachingPolicy(BOOL *pbRetVal)
{
    CMcRegistry reg;

    *pbRetVal = FALSE;
        
    // Open the Network policies key    
    if (reg.OpenKey(HKEY_LOCAL_MACHINE, szNetworkPolicies))
    {
        DWORD  dwVal = 0;
        // Get the disableCaching value
        if (reg.GetValue(szDisableCaching, dwVal))
        {
            // if set, then set the return code to TRUE.
            if(dwVal)
            {
                *pbRetVal = TRUE;
                
                TCHAR szLongString[1024];
                TCHAR *pszSmallString1, *pszSmallString2;

                // 4/28/97 ChrisK
                // Fix build break, because string was too long for compiler.
                pszSmallString1 = GetSz(IDS_PWCACHE_DISABLED1);
                pszSmallString2 = GetSz(IDS_PWCACHE_DISABLED2);
                lstrcpy(szLongString,pszSmallString1);
                lstrcat(szLongString,pszSmallString2);
                
                ::MessageBox(GetActiveWindow(),szLongString,GetSz(IDS_TITLE), MB_MYERROR);
                
                // We are going to kill the app, so hide it now
                ::ShowWindow(GetActiveWindow(), SW_HIDE);
            }
        }
    }                                    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\enumodem.h ===
// jmazner  pinched from inetcfg\rnacall.h class ENUM_MODEM

#ifndef __ENUMODEM_H_
#define __ENUMODEM_H_


class CEnumModem
{
private:
  DWORD         m_dwError;
  DWORD         m_dwNumEntries;
  DWORD         m_dwIndex;
  LPRASDEVINFO  m_lpData;
public:
  CEnumModem();
  ~CEnumModem();
  DWORD ReInit();
  TCHAR * Next();
  TCHAR * GetDeviceTypeFromName(LPTSTR szDeviceName);
  TCHAR * GetDeviceNameFromType(LPTSTR szDeviceType);
  TCHAR * GetDeviceName(DWORD dwIndex);
  TCHAR * GetDeviceType(DWORD dwIndex);
  BOOL VerifyDeviceNameAndType(LPTSTR szDeviceName, LPTSTR szDeviceType);
  DWORD GetNumDevices() {  this->ReInit(); return m_dwNumEntries; }
  DWORD GetError()  { return m_dwError; }
  void  ResetIndex() { m_dwIndex = 0; }
};

// from inetcfg\export.cpp
// structure to pass data back from IDD_CHOOSEMODEMNAME handler
typedef struct tagCHOOSEMODEMDLGINFO
{
  TCHAR szModemName[RAS_MaxDeviceName + 1];
  HRESULT hr;
} CHOOSEMODEMDLGINFO, * PCHOOSEMODEMDLGINFO;

INT_PTR CALLBACK ChooseModemDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
BOOL ChooseModemDlgInit(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo);
BOOL ChooseModemDlgOK(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo);


//rnacall.cpp
HRESULT InitModemList(HWND hCB);

#endif      // ENUMODEM.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\icwhelp.cpp ===
// icwhelp.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//        To build a separate proxy/stub DLL,
//        run nmake -f icwhelpps.mk in the project directory.

#include "stdafx.h"
#include "initguid.h"
#include "icwhelp.h"

#include "icwhelp_i.c"
#include "RefDial.h"
#include "DialErr.h"
#include "SmStart.h"
#include "ICWCfg.h"
#include "tapiloc.h"
#include "UserInfo.h"
#include "webgate.h"
#include "INSHandler.h"

const TCHAR c_szICWDbgEXE[] = TEXT("ICWDEBUG.EXE");
const TCHAR c_szICWEXE[]    = TEXT("ICWCONN1.EXE");


CComModule _Module;

BOOL    g_fRasIsReady = FALSE;
BOOL    g_bProxy = FALSE;
DWORD   g_dwPlatform = 0xFFFFFFFF;
DWORD   g_dwBuild = 0xFFFFFFFF;
LPTSTR  g_pszAppDir = NULL;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_RefDial, CRefDial)
    OBJECT_ENTRY(CLSID_DialErr, CDialErr)
    OBJECT_ENTRY(CLSID_SmartStart, CSmartStart)
    OBJECT_ENTRY(CLSID_ICWSystemConfig, CICWSystemConfig)
    OBJECT_ENTRY(CLSID_TapiLocationInfo, CTapiLocationInfo)
    OBJECT_ENTRY(CLSID_UserInfo, CUserInfo)
    OBJECT_ENTRY(CLSID_WebGate, CWebGate)
    OBJECT_ENTRY(CLSID_INSHandler, CINSHandler)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TCHAR   szPath[MAX_PATH];
        BOOL    fBail = TRUE;

        // Make sure the attaching process is ICWCONN1.EXE. If not, we won't
        // load
        if (GetModuleFileName(NULL, szPath, ARRAYSIZE(szPath)))
        {
            NULL_TERM_TCHARS(szPath);
            // See of the file name part of the path contains what we expect
            if ( (NULL != _tcsstr(_tcsupr(szPath), c_szICWEXE)) || (NULL != _tcsstr(_tcsupr(szPath), c_szICWDbgEXE)))
                fBail = FALSE;
        }

// Allow a debug override of the check
#ifdef DEBUG
        {
            // See if we should override the BAIL out for debug
            if (fBail)
            {
                HKEY    hkey;
                DWORD   dwSize = 0;
                DWORD   dwType = 0;
                DWORD   dwData = 0;
                if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,
                                                TEXT("Software\\Microsoft\\ISignup\\Debug"),
                                                &hkey))
                {
                    dwSize = sizeof(dwData);
                    if (ERROR_SUCCESS == RegQueryValueEx(hkey,
                                                         TEXT("AllowICWHELPToRun"),
                                                         0,
                                                         &dwType,
                                                         (LPBYTE)&dwData,
                                                         &dwSize))
                    {
                        // Override the fBail if dwData is non-zero
                        fBail = (0 == dwData);
                    }
                }

                if (hkey)
                    RegCloseKey(hkey);
            }
        }
#endif
        if (fBail)
        {
            // We are outa here!!!
            return(FALSE);
        }

        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);

        // Get the OS Version
        if (0xFFFFFFFF == g_dwPlatform)
        {
            OSVERSIONINFO osver;
            ZeroMemory(&osver,sizeof(osver));
            osver.dwOSVersionInfoSize = sizeof(osver);
            if (GetVersionEx(&osver))
            {
                g_dwPlatform = osver.dwPlatformId;
                g_dwBuild = osver.dwBuildNumber & 0xFFFF;
            }
        }

        // Get the AppDir
        LPTSTR   p;
        g_pszAppDir = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH * sizeof(TCHAR));
        if (g_pszAppDir)
        {
            if (GetModuleFileName(hInstance, g_pszAppDir, MAX_PATH))
            {
                p = &g_pszAppDir[lstrlen(g_pszAppDir)-1];
                while (*p != '\\' && p >= g_pszAppDir)
                    p--;
                if (*p == '\\') *(p++) = '\0';
            }
            else
            {
                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        GlobalFree(g_pszAppDir);
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}

#define MAX_STRINGS     5
int     iSzTable=0;
TCHAR   szStrTable[MAX_STRINGS][512];


/////////////////////////////////////////////////////////////////////////////
// Utility Globals

//+----------------------------------------------------------------------------
// NAME: GetSz
//
//    Load strings from resources
//
//  Created 1/28/96,        Chris Kauffman
//+----------------------------------------------------------------------------
LPTSTR GetSz(WORD wszID)
{
    LPTSTR psz = szStrTable[iSzTable];

    iSzTable++;
    if (iSzTable >= MAX_STRINGS)
        iSzTable = 0;

    if (!LoadString(_Module.GetModuleInstance(), wszID, psz, 512))
    {
        TraceMsg(TF_GENERAL, TEXT("ICWHELP:LoadString failed %d\n"), (DWORD) wszID);
        *psz = 0;
    }

    return (psz);
}

#ifdef UNICODE
int     iSzTableA=0;
CHAR    szStrTableA[MAX_STRINGS][512];

//+----------------------------------------------------------------------------
// NAME: GetSzA
//
//    Load ascii strings from resources
//
//  Created 3/10/99,        Wootaek Seo
//+----------------------------------------------------------------------------
LPSTR GetSzA(WORD wszID)
{
    LPSTR psz = szStrTableA[iSzTable];

    iSzTableA++;
    if (iSzTableA >= MAX_STRINGS)
        iSzTableA = 0;

    if (!LoadStringA(_Module.GetModuleInstance(), wszID, psz, 512))
    {
        TraceMsg(TF_GENERAL, TEXT("ICWHELP:LoadStringA failed %d\n"), (DWORD) wszID);
        *psz = 0;
    }

    return (psz);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\icwglob.h ===
//--------------------------------------------------------------------------------
//    icwglob.h
//    The information contained in this file is the sole property of Microsoft Corporation.
//  Copywrite Microsoft 1998
//
//  Created 1/7/98,        DONALDM
//--------------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// INCLUDES

#include <wininet.h>
#include "enumodem.h"

#include "..\inc\debug.h"
#include "..\inc\inetcfg.h"
#include "..\inc\ras2.h"
#include "..\icwphbk\phbk.h"
// #include "..\icwdl\mydefs.h"
#include <rnaapi.h>

//-----------------------------------------------------------------------------
// DEFINES
#define ERROR_USERCANCEL 32767 // quit message value
#define ERROR_USERBACK 32766 // back message value
#define ERROR_USERNEXT 32765 // back message value
#define ERROR_DOWNLOADIDNT 32764 // Download failure

#define ERROR_READING_DUN        32768
#define ERROR_READING_ISP        32769
#define ERROR_PHBK_NOT_FOUND    32770
#define ERROR_DOWNLOAD_NOT_FOUND 32771

#define cMarvelBpsMin 2400 // minimum modem speed
#define INVALID_PORTID UINT_MAX
#define pcszDataModem TEXT("comm/datamodem")
//#define MsgBox(m,s) MessageBox(g_hwndBack,GetSz(m),GetSz(IDS_TITLE),s)
#if defined(WIN16)
#define MsgBox(m,s) MessageBox(g_hwndMessage,GetSz(m),GetSz(IDS_TITLE),s)
#endif
#define szLoginKey           TEXT("Software\\Microsoft\\MOS\\Connection")
#define szCurrentComDev      TEXT("CurrentCommDev")
#define szTollFree           TEXT("OlRegPhone")
#define CCD_BUFFER_SIZE 255
#define szSignupConnectoidName TEXT("MSN Signup Connection")
#define szSignupDeviceKey    TEXT("SignupCommDevice")
#define KEYVALUE_SIGNUPID    TEXT("iSignUp")
#define RASENTRYVALUENAME    TEXT("RasEntryName")
#define GATHERINFOVALUENAME  TEXT("UserInfo")
#define INFFILE_USER_SECTION TEXT("User")
#define INFFILE_PASSWORD     TEXT("Password")
#define NULLSZ               TEXT("")

#define cchMoreSpace 22000    // bytes needed to hold results of lineGetCountry(0,...). 
                            // Currently this function returns about 16K, docs say 20K,
                            // this should be enough.
#define DwFromSz(sz)         Sz2Dw(sz)            //make it inline, so this is faster.
#define DwFromSzFast(sz)     Sz2DwFast(sz)        
#define CONNECT_SIGNUPFIRST    1 // phonenumber constant for determining the firstcall phonenumber TO DO

#define CONNECTFLAGS_MASK_TOLLFREE     0x01
#define CONNECTFLAGS_MASK_TCP          0x02
#define CONNECTFLAGS_MASK_ISDN         0x04
#define CONNECTFLAGS_MASK_DIRECT    0x08
#define CONNECTFLAGS_MASK_OTHERDIALUP  0x10
#define CONNECTFLAGS_MASK_PROXY        0x20

#define CONNECTFLAGS_MASK_FIRST     CONNECTFLAGS_MASK_TCP
#define CONNECTFLAGS_MASK_LAST      CONNECTFLAGS_MASK_ISDN

#define CONNECTMSNDIALUP(dw) ((dw & (CONNECTFLAGS_MASK_TOLLFREE|CONNECTFLAGS_M
#define LANORSHUTTLE(dw) ((dw)==10 || (dw)==34)
#define IS_SHUTTLE(dw)   ((dw)==34)
#define IS_ISP(dw)       ((dw)==18)

#define CONNECTPROTOCOL_MSNDIALUPX25      0
#define CONNECTPROTOCOL_MSNDIALUPTCP      2
#define CONNECTPROTOCOL_MSNDIALUPTCPISDN  6
#define CONNECTPROTOCOL_LANDIRECT         10
#define CONNECTPROTOCOL_ISPDIALUPTCP      18
#define CONNECTPROTOCOL_LANSHUTTLE        34

#define clineMaxATT            16            //for 950 MNEMONIC
#define NXXMin 200
#define NXXMax 999
#define cbgrbitNXX ((NXXMax + 1 - NXXMin) / 8)
#define crgnpab (NPAMax + 1 - NPAMin)

#define    MAX_PROMO 64
#define MAX_OEMNAME 64
#define MAX_AREACODE RAS_MaxAreaCode
#define MAX_RELPROD    8
#define MAX_RELVER    30

#define MAX_STRING      256  //used by ErrorMsg1 in mt.cpp


#define PHONEBOOK_LIBRARY TEXT("icwphbk.DLL")
#ifdef WIN16
#define PHBK_LOADAPI "PhoneBookLoad"
#define PHBK_SUGGESTAPI "PhoneBookSuggestNumbers"
#define PHBK_DISPLAYAPI "PhoneBookDisplaySignUpNumbers"
#define PHBK_UNLOADAPI "PhoneBookUnload"
#define PHBK_GETCANONICAL "PhoneBookGetCanonical"
#else
#define PHBK_LOADAPI      "PhoneBookLoad"
#define PHBK_SUGGESTAPI   "PhoneBookSuggestNumbers"
#define PHBK_DISPLAYAPI   "PhoneBookDisplaySignUpNumbers"
#define PHBK_UNLOADAPI    "PhoneBookUnload"
#define PHBK_GETCANONICAL "PhoneBookGetCanonical"
#endif

#define NUM_PHBK_SUGGESTIONS    50

#define TYPE_SIGNUP_ANY            0x82
#define MASK_SIGNUP_ANY            0xB2

#define DOWNLOAD_LIBRARY   TEXT("icwdl.dll")
#if defined(WIN16)
#define DOWNLOADINIT       "DownLoadInit"
#define DOWNLOADEXECUTE    "DownLoadExecute"
#define DOWNLOADCLOSE      "DownLoadClose"
#define DOWNLOADSETSTATUS  "DownLoadSetStatusCallback"
#define DOWNLOADPROCESS    "DownLoadProcess"
#define DOWNLOADCANCEL     "DownLoadCancel"
#else
#define DOWNLOADINIT       "DownLoadInit"
#define DOWNLOADEXECUTE    "DownLoadExecute"
#define DOWNLOADCLOSE      "DownLoadClose"
#define DOWNLOADSETSTATUS  "DownLoadSetStatusCallback"
#define DOWNLOADPROCESS    "DownLoadProcess"
#define DOWNLOADCANCEL     "DownLoadCancel"
#endif

#if defined(WIN16)
extern "C" void CALLBACK __export DialCallback(UINT uiMsg, 
                                                RASCONNSTATE rasState, 
                                                DWORD dwErr);    
#endif

//#define RASENUMAPI       "RasEnumConnectionsA"
//#define RASHANGUP        "RasHangUpA"

#define INF_SUFFIX              TEXT(".ISP")
#define INF_PHONE_BOOK          TEXT("PhoneBookFile")
#define INF_DUN_FILE            TEXT("DUNFile")
#define INF_REFERAL_URL         TEXT("URLReferral")
#define INF_SIGNUPEXE           TEXT("Sign_Up_EXE")
#define INF_SIGNUPPARAMS        TEXT("Sign_Up_Params")
#define INF_WELCOME_LABEL       TEXT("Welcome_Label")
#define INF_ISP_MSNSU           TEXT("MSICW")
#define INF_SIGNUP_URL          TEXT("Signup")
#define INF_AUTOCONFIG_URL      TEXT("AutoConfig")
#define INF_ISDN_URL            TEXT("ISDNSignup")
#define INF_ISDN_AUTOCONFIG_URL TEXT("ISDNAutoConfig")
#define INF_SECTION_URL         TEXT("URL")
#define INF_SECTION_ISPINFO     TEXT("ISP INFO")

#define DUN_NOPHONENUMBER       TEXT("000000000000")
#define DUN_NOPHONENUMBER_A     "000000000000"

#define MAX_VERSION_LEN 40

#define MB_MYERROR (MB_APPLMODAL | MB_ICONERROR | MB_SETFOREGROUND)

// 8/9/96 jmazner
// Added new macro to fix MOS Normandy Bug #4170
#define MB_MYINFORMATION (MB_APPLMODAL | MB_ICONINFORMATION | MB_SETFOREGROUND)

// 8/27/96 jmazner
#define MB_MYEXCLAMATION (MB_APPLMODAL | MB_ICONEXCLAMATION | MB_SETFOREGROUND)

#define WM_STATECHANGE            WM_USER
#define WM_DIENOW                WM_USER + 1
#define WM_DUMMY                WM_USER + 2
#define WM_DOWNLOAD_DONE        WM_USER + 3
#define WM_DOWNLOAD_PROGRESS    WM_USER + 4

#define WM_MYINITDIALOG        (WM_USER + 4)

#define MAX_REDIALS 2

#define REG_USER_INFO     TEXT("Software\\Microsoft\\User information")
#define REG_USER_NAME1    TEXT("Default First Name")
#define REG_USER_NAME2    TEXT("Default Last Name")
#define REG_USER_COMPANY  TEXT("Default Company")
#define REG_USER_ADDRESS1 TEXT("Mailing Address")
#define REG_USER_ADDRESS2 TEXT("Additional Address")
#define REG_USER_CITY     TEXT("City")
#define REG_USER_STATE    TEXT("State")
#define REG_USER_ZIP      TEXT("ZIP Code")
#define REG_USER_PHONE    TEXT("Daytime Phone")
#define REG_USER_COUNTRY  TEXT("Country")

#define SIGNUPKEY         TEXT("SOFTWARE\\MICROSOFT\\GETCONN")
#define DEVICENAMEKEY     TEXT("DeviceName")    // used to store user's choice among multiple modems
#define DEVICETYPEKEY     TEXT("DeviceType")

#define ICWSETTINGSPATH   TEXT("Software\\Microsoft\\Internet Connection Wizard")
#define ICWBUSYMESSAGES   TEXT("Software\\Microsoft\\Internet Connection Wizard\\Busy Messages")
#define RELEASEPRODUCTKEY TEXT("Release Product")
#define RELEASEVERSIONKEY TEXT("Release Product Version")

#define SETUPPATH_NONE    TEXT("current")
#define SETUPPATH_MANUAL  TEXT("manual")
#define SETUPPATH_AUTO    TEXT("automatic")
#define MAX_SETUPPATH_TOKEN 200

// 12/3/96 jmazner superceded by definitions in ..\common\inc\semaphor.h
//#define SEMAPHORE_NAME "Internet Connection Wizard ICWCONN1.EXE"

//
// 5/24/97 ChrisK Olympus 4650
//
#define RASDEVICETYPE_VPN       TEXT("VPN")
#define RASDEVICETYPE_MODEM     TEXT("MODEM")
#define RASDEVICETYPE_ISDN      TEXT("ISDN")
//--------------------------------------------------------------------------------
// Type declarations

// NOTE: due to code in connmain, the order of these IS IMPORTANT.  They should be
// in the same order that they appear.
enum CState 
{
    STATE_WELCOME = 0,
    STATE_INITIAL,
    STATE_BEGINAUTO,
    STATE_CONTEXT1,
    STATE_NETWORK,
    STATE_AUTORUNSIGNUPWIZARD,
    STATE_GATHERINFO,
    STATE_DOWNLOADISPLIST,
    STATE_SHELLPARTTWO,
    STATE_MAX
};
    
typedef HINTERNET (WINAPI* PFNINTERNETOPEN) (LPCTSTR lpszCallerName, DWORD dwAccessType, LPCTSTR lpszProxyName, INTERNET_PORT nProxyPort, DWORD dwFlags);
typedef HINTERNET (CALLBACK* PFNINTERNETOPENURL) (HINSTANCE hInternetSession,
                                                  LPCTSTR lpszUrl, LPCTSTR    lpszHeaders,
                                                  DWORD    dwHeadersLength, DWORD    dwFlags,
                                                  DWORD    dwContext);
typedef INTERNET_STATUS_CALLBACK (CALLBACK *PFNINTERNETSETSTATUSCALLBACK)(HINTERNET hInternet, INTERNET_STATUS_CALLBACK lpfnInternetCallback);
typedef BOOL (CALLBACK *PFNINTERNETCLOSEHANDLE)(HINTERNET hInet); 

typedef HRESULT (CALLBACK* PFNPHONEBOOKLOAD)(LPCTSTR pszISPCode, DWORD_PTR *pdwPhoneID);
typedef HRESULT (CALLBACK* PFPHONEBOOKSUGGEST)(DWORD_PTR dwPhoneID, PSUGGESTINFO pSuggestInfo);
typedef HRESULT (CALLBACK* PFNPHONEDISPLAY)(DWORD_PTR dwPhoneID, LPTSTR *ppszPhoneNumbers,
                                            LPTSTR *ppszDunFiles, WORD *pwPhoneNumbers,
                                            DWORD *pdwCountry,WORD *pwRegion,BYTE fType,
                                            BYTE bMask,HWND hwndParent,DWORD dwFlags);
typedef HRESULT (CALLBACK *PFNPHONEBOOKUNLOAD) (DWORD_PTR dwPhoneID);
typedef HRESULT (CALLBACK *PFNPHONEBOOKGETCANONICAL)(DWORD_PTR dwPhoneID, PACCESSENTRY pAE, TCHAR *psOut);


typedef HRESULT (CALLBACK *PFNCONFIGAPI)(HWND hwndParent,DWORD dwfOptions,LPBOOL lpfNeedsRestart);
typedef HRESULT (WINAPI *PFNINETCONFIGSYSTEM)(HWND,LPCTSTR,LPCTSTR,LPRASENTRY,LPCTSTR,LPCTSTR,LPCTSTR,LPVOID,DWORD,LPBOOL);
typedef HRESULT (WINAPI *PFINETSTARTSERVICES)(void);
typedef DWORD (WINAPI *PFNLAUNCHSIGNUPWIZARDEX)(LPTSTR,int, PBOOL);
typedef VOID (WINAPI *PFNFREESIGNUPWIZARD) (VOID);
typedef DWORD (WINAPI *PFNISSMARTSTART)(VOID);

typedef DWORD (WINAPI *PFNINETCONFIGCLIENT)(HWND hwndParent, LPCTSTR lpszPhoneBook,LPCTSTR lpszEntryName, LPRASENTRY lpRasEntry,LPCTSTR lpszUserName, LPCTSTR lpszPassword,LPCTSTR lpszProfile, LPINETCLIENTINFO lpClientInfo,DWORD dwfOptions, LPBOOL lpfNeedsRestart);
typedef DWORD (WINAPI *PFNINETGETAUTODIAL)(LPBOOL lpfEnable, LPCTSTR lpszEntryName, DWORD cbEntryNameSize);
typedef DWORD (WINAPI *PFNINETSETAUTODIAL)(BOOL fEnable, LPCTSTR lpszEntryName);
typedef DWORD (WINAPI *PFNINETGETCLIENTINFO)(LPCTSTR lpszProfile, LPINETCLIENTINFO lpClientInfo);
typedef DWORD (WINAPI *PFNINETSETCLIENTINFO)(LPCTSTR lpszProfile, LPINETCLIENTINFO lpClientInfo);
typedef DWORD (WINAPI *PFNINETGETPROXY)(LPBOOL lpfEnable, LPCTSTR lpszServer, DWORD cbServer,LPCTSTR lpszOverride, DWORD cbOverride);
typedef DWORD (WINAPI *PFNINETSETPROXY)(BOOL fEnable, LPCTSTR lpszServer, LPCTSTR lpszOverride);

typedef BOOL (WINAPI *PFNBRANDICW)(LPCSTR pszIns, LPCSTR pszPath, DWORD dwFlags, LPCSTR pszConnectoid);

typedef DWORD (WINAPI *PFNRASSETAUTODIALADDRESS)(LPTSTR lpszAddress,DWORD dwReserved,LPRASAUTODIALENTRY lpAutoDialEntries,DWORD dwcbAutoDialEntries,DWORD dwcAutoDialEntries);
typedef DWORD (WINAPI *PFNRASSETAUTODIALENABLE)(DWORD dwDialingLocation, BOOL fEnabled);

typedef HRESULT (CALLBACK *PFNDOWNLOADINIT)(LPTSTR pszURL, DWORD_PTR FAR *pdwCDialDlg, DWORD_PTR FAR *pdwDownLoad, HWND g_hWndMain);
typedef HRESULT (CALLBACK *PFNDOWNLOADGETSESSION)(DWORD_PTR dwDownLoad, HINTERNET *phInternet);
typedef HRESULT (CALLBACK *PFNDOWNLOADCANCEL)(DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK *PFNDOWNLOADEXECUTE)(DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK *PFNDOWNLOADCLOSE)(DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK *PFNDOWNLOADSETSTATUS)(DWORD_PTR dwDownLoad, INTERNET_STATUS_CALLBACK lpfn);
typedef HRESULT (CALLBACK *PFNDOWNLOADPROCESS)(DWORD_PTR dwDownLoad);

typedef HRESULT (CALLBACK *PFNAUTODIALINIT)(LPTSTR lpszISPFile, BYTE fFlags, BYTE bMask, DWORD dwCountry, WORD wState);

typedef struct tagGatherInfo
{
    LCID    m_lcidUser;
    LCID    m_lcidSys;
    LCID    m_lcidApps;
    DWORD   m_dwOS;
    DWORD   m_dwMajorVersion;
    DWORD   m_dwMinorVersion;
    WORD    m_wArchitecture;
    TCHAR   m_szPromo[MAX_PROMO];

    DWORD   m_dwCountry;
    TCHAR   m_szAreaCode[MAX_AREACODE+1];
    HWND    m_hwnd;
    LPLINECOUNTRYLIST m_pLineCountryList;
    LPCNTRYNAMELOOKUPELEMENT m_rgNameLookUp;

    TCHAR   m_szSUVersion[MAX_VERSION_LEN];
    WORD    m_wState;
    BYTE    m_fType;
    BYTE    m_bMask;
    TCHAR   m_szISPFile[MAX_PATH+1];
    TCHAR   m_szAppDir[MAX_PATH+1];

    TCHAR   m_szRelProd[MAX_RELPROD + 1];
    TCHAR   m_szRelVer[MAX_RELVER + 1];
    DWORD    m_dwFlag;

} GATHERINFO, *LPGATHERINFO;


typedef struct tagRASDEVICE
{
    LPRASDEVINFO lpRasDevInfo;
    DWORD dwTapiDev;
} RASDEVICE, *PRASDEVICE;


//--------------------------------------------------------------------------------
// Prototypes
DWORD ConfigRasEntryDevice( LPRASENTRY lpRasEntry );
BOOL FInsureTCPIP();
LPTSTR GetSz(WORD wszID);
#ifdef UNICODE
LPSTR  GetSzA(WORD wszID);
#endif
void SetStatusArrow(CState wState);
BOOL FInsureModemTAPI(HWND hwnd);
BOOL FGetModemSpeed(PDWORD pdwSpeed);
BOOL FGetDeviceID(HLINEAPP *phLineApp, PDWORD pdwAPI, PDWORD pdwDevice);
BOOL FDoModemWizard(HWND hWnd);
void CALLBACK LineCallback(DWORD hDevice, DWORD dwMessage, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2, DWORD dwParam3);
BOOL FInsureNetwork(PBOOL pfNeedReboot);
BOOL TestInternetConnection();
inline DWORD Sz2Dw(LPCTSTR pSz);
inline DWORD Sz2DwFast(LPCTSTR pSz);
inline BOOL FSz2Dw(LPCTSTR pSz,LPDWORD dw);
int __cdecl CompareCountryNames(const void *pv1, const void *pv2);
DWORD GetCurrentTapiCountryID(void);
int __cdecl CompareNPAEntry(const void *pv1, const void *pv2);
//HRESULT GatherInformation(LPGATHERINFO pGatheredInfo, HWND hwndParent);
HRESULT DownLoadISPInfo(GATHERINFO *pGI);
HRESULT GetDataFromISPFile(LPTSTR pszISPCode, LPTSTR pszSection, LPTSTR pszDataName, LPTSTR pszOutput, 
                           DWORD dwOutputLength);
HRESULT GetINTFromISPFile
(
    LPTSTR   pszISPCode, 
    LPTSTR   pszSection,
    LPTSTR   pszDataName, 
    int far *lpData,
    int     iDefaultValue
);

HRESULT StoreInSignUpReg(LPBYTE lpbData, DWORD dwSize, DWORD dwType, LPCTSTR pszKey);
HRESULT ReadSignUpReg(LPBYTE lpbData, DWORD *pdwSize, DWORD dwType, LPCTSTR pszKey);
void CALLBACK LineCallback(DWORD hDevice,
                           DWORD dwMessage,
                           DWORD dwInstance,
                           DWORD dwParam1,
                           DWORD dwParam2,
                           DWORD dwParam3);
VOID WINAPI MyProgressCallBack(
    HINTERNET hInternet,
    DWORD dwContext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
    );

HRESULT ReleaseBold(HWND hwnd);
HRESULT MakeBold (HWND hwnd, BOOL fSize, LONG lfWeight);
HRESULT ShowPickANumberDlg(PSUGGESTINFO pSuggestInfo);
//HRESULT ShowDialingDialog(LPTSTR, LPGATHERINFO, LPTSTR);
DWORD RasErrorToIDS(DWORD dwErr);
HRESULT CreateEntryFromDUNFile(LPTSTR pszDunFile);
//HRESULT RestoreHappyWelcomeScreen();
HRESULT KillHappyWelcomeScreen();
HRESULT GetCurrentWebSettings();
LPTSTR LoadInfoFromWindowUser();
HRESULT GetTapiCountryID2(LPDWORD pdwCountryID);
HRESULT RestoreAutodialer();
//HRESULT FilterStringDigits(LPTSTR);
BOOL IsDigitString(LPTSTR szBuff);
BOOL WaitForAppExit(HINSTANCE hInstance);
VOID PrepareForRunOnceApp(VOID);
void MinimizeRNAWindow(LPTSTR pszConnectoidName, HINSTANCE hInst);
// 3/18/97 ChrisK Olympus 304
DWORD MyGetTempPath(UINT uiLength, LPTSTR szPath);
// 3/28/97 ChrisK Olympus 296
void StopRNAReestablishZapper(HANDLE hthread);
HANDLE LaunchRNAReestablishZapper(HINSTANCE hInst);
BOOL FGetSystemShutdownPrivledge();
BOOL LclSetEntryScriptPatch(LPTSTR lpszScript,LPTSTR lpszEntry);
BOOL IsScriptingInstalled();
void InstallScripter(void);
void DeleteStartUpCommand ();
extern BOOL IsNT (VOID);
extern BOOL IsNT4SP3Lower (VOID);
//
// ChrisK Olympus 6368 6/24/97
//
VOID Win95JMoveDlgItem( HWND hwndParent, HWND hwndItem, int iUp );
#if defined(DEBUG)
void LoadTestingLocaleOverride(LPDWORD lpdwCountryID, LCID FAR *lplcid);
BOOL FCampusNetOverride();
BOOL FRefURLOverride();
void TweakRefURL( TCHAR* szUrl, 
                  LCID*  lcid, 
                  DWORD* dwOS,
                  DWORD* dwMajorVersion, 
                  DWORD* dwMinorVersion,
                  WORD*  wArchitecture, 
                  TCHAR* szPromo, 
                  TCHAR* szOEM, 
                  TCHAR* szArea, 
                  DWORD* dwCountry,
                  TCHAR* szSUVersion,//&m_lpGatherInfo->m_szSUVersion[0],  
                  TCHAR* szProd, 
                  DWORD* dwBuildNumber, //For this we really want to LOWORD
                  TCHAR* szRelProd, 
                  TCHAR* szRelProdVer, 
                  DWORD* dwCONNWIZVersion, 
                  TCHAR* szPID, 
                  long*  lAllOffers);
#endif //DEBUG
                
//#ifdef __cplusplus
//extern "C" {
//#endif // __cplusplus
LPTSTR FileToPath(LPTSTR pszFile);
HRESULT ANSI2URLValue(TCHAR *s, TCHAR *buf, UINT uiLen);
BOOL BreakUpPhoneNumber(LPRASENTRY prasentry, LPTSTR pszPhone);
extern "C" int _cdecl _purecall(void);

//    //10/24/96 jmazner Normandy 6968
//    //No longer neccessary thanks to Valdon's hooks for invoking ICW.
// 11/21/96 jmazner Normandy 11812
// oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
// ICW 1.1 needs to morph the IE 3 icon.
HRESULT GetDeskTopInternetCommand();
HRESULT RestoreDeskTopInternetCommand();

//
// 7/24/97 ChrisK Olympus 1923
//
BOOL WaitForConnectionTermination(HRASCONN);

// 11/21/96 jmazner Normandy #11812
BOOL GetIEVersion(PDWORD pdwVerNumMS, PDWORD pdwVerNumLS);
// Note that bryanst and marcl have confirmed that this key will be supported in IE 4
#define IE_PATHKEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE")


// IE 4 has major.minor version 4.71
// IE 3 golden has major.minor.release.build version # > 4.70.0.1155
// IE 2 has major.minor of 4.40

#define IE4_MAJOR_VERSION (UINT) 4
#define IE4_MINOR_VERSION (UINT) 71
#define IE4_VERSIONMS (DWORD) ((IE4_MAJOR_VERSION << 16) | IE4_MINOR_VERSION)

HRESULT ClearProxySettings();
HRESULT RestoreProxySettings();
BOOL FShouldRetry2(HRESULT hrErr);

extern void ErrorMsg1(HWND hwnd, UINT uId, LPCTSTR lpszArg);
extern void InfoMsg1(HWND hwnd, UINT uId, LPCTSTR lpszArg);

VOID CALLBACK BusyMessagesTimerProc(HWND hwnd,
        UINT uMsg,
        UINT idEvent,
        DWORD dwTime);


// 4-30-97 ChrisK Olympus 2934
// While the ICW is trying to connect to the referral server, indicate something is
// working
#define MAX_BUSY_MESSAGE    255
#define MAX_VALUE_NAME        10
#define DEFAULT_IDEVENT        31
#define DEFAULT_UELAPSE        3000
class CBusyMessages
{
friend VOID CALLBACK BusyMessagesTimerProc(HWND hwnd,
        UINT uMsg,
        UINT idEvent,
        DWORD dwTime);
public:
    CBusyMessages();
    ~CBusyMessages();
    DWORD Start(HWND hwnd, INT iID, HRASCONN hrasconn);
    DWORD Stop();

private:
    // Private data members
    HWND    m_hwnd;
    INT        m_iStatusLabel;
    CHAR    m_szMessage[MAX_BUSY_MESSAGE];
    DWORD    m_dwCurIdx;
    UINT    m_uIDTimer;
    HINSTANCE m_hInstance;
    HRASCONN m_hrasconn;
    RNAAPI* m_prna;
};

//
// defined in connmain.cpp
//
class RegEntry
{
    public:
        RegEntry(const TCHAR *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
        ~RegEntry();
        
        long    GetError()    { return _error; }
        long    SetValue(const TCHAR *pszValue, const TCHAR *string);
        // long    SetValue(const TCHAR *pszValue, unsigned long dwNumber);
        TCHAR *    GetString(const TCHAR *pszValue, TCHAR *string, unsigned long length);
        //long    GetNumber(const TCHAR *pszValue, long dwDefault = 0);
        long    DeleteValue(const TCHAR *pszValue);
        /**long    FlushKey();
        long    MoveToSubKey(const TCHAR *pszSubKeyName);
        HKEY    GetKey()    { return _hkey; } **/

    private:
        HKEY    _hkey;
        long    _error;
        BOOL    bhkeyValid;
};


// Trace flags
#define TF_RNAAPI           0x00000010      // RNA Api stuff
#define TF_SMARTSTART       0x00000020      // Smart Start code
#define TF_SYSTEMCONFIG     0x00000040      // System Config
#define TF_TAPIINFO         0x00000080      // TAPI stuff
#define TF_INSHANDLER       0x00000100      // INS processing stuff

// Prototypes for stuff in MISC.CPP
int Sz2W (LPCTSTR szBuf);
int FIsDigit( int c );
LPBYTE MyMemSet(LPBYTE dest,int c, size_t count);
LPBYTE MyMemCpy(LPBYTE dest,const LPBYTE src, size_t count);
BOOL ShowControl(HWND hDlg,int idControl,BOOL fShow);
BOOL ConvertToLongFilename(LPTSTR szOut, LPTSTR szIn, DWORD dwSize);


//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : malloc(cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) free(m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    TCHAR  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

//
// Note: allocate lstrlenW(widestr) * 2 because its possible for a UNICODE 
// character to map to 2 ansi characters this is a quick guarantee that enough
// space will be allocated.
//
#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * 2 * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()

#define STR_BSTR   0
#define STR_OLESTR 1
#define BSTRFROMANSI(x)    (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x)  (LPOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)
#define BSTRFROMRESID(x)   (BSTR)MakeWideStrFromResourceId(x, STR_BSTR)
#define OLESTRFROMRESID(x) (LPOLESTR)MakeWideStrFromResourceId(x, STR_OLESTR)
#define COPYOLESTR(x)      (LPOLESTR)MakeWideStrFromWide(x, STR_OLESTR)
#define COPYBSTR(x)        (BSTR)MakeWideStrFromWide(x, STR_BSTR)

LPWSTR MakeWideStrFromAnsi(LPSTR, BYTE bType);
LPWSTR MakeWideStrFromResourceId(WORD, BYTE bType);
LPWSTR MakeWideStrFromWide(LPWSTR, BYTE bType);


typedef struct SERVER_TYPES_tag
{
    TCHAR szType[6];
    DWORD dwType;
    DWORD dwfOptions;
} SERVER_TYPES;
#define NUM_SERVER_TYPES    4

// Default branding flags the we will support
#define BRAND_FAVORITES 1
#define BRAND_STARTSEARCH 2
#define BRAND_TITLE 4
#define BRAND_BITMAPS 8
#define BRAND_MAIL 16
#define BRAND_NEWS 32

#define BRAND_DEFAULT (BRAND_FAVORITES | BRAND_STARTSEARCH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\import.cpp ===
// Import.cpp: implementation of the CISPImport class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "appdefs.h"
#include "icwhelp.h"

#ifdef _DEBUG
#undef THIS_FILE
static TCHAR THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#pragma data_seg(".rdata")

TCHAR cszEntrySection[] = TEXT("Entry");
TCHAR cszEntryName[]    = TEXT("Entry_Name");
TCHAR cszAlias[]        = TEXT("Import_Name");
TCHAR cszML[]           = TEXT("Multilink");

TCHAR cszPhoneSection[] = TEXT("Phone");
TCHAR cszDialAsIs[]     = TEXT("Dial_As_Is");
TCHAR cszPhone[]        = TEXT("Phone_Number");
TCHAR cszISDN[]         = TEXT("ISDN_Number");
TCHAR cszAreaCode[]     = TEXT("Area_Code");
TCHAR cszCountryCode[]  = TEXT("Country_Code");
TCHAR cszCountryID[]    = TEXT("Country_ID");

TCHAR cszDeviceSection[] = TEXT("Device");
TCHAR cszDeviceType[]    = TEXT("Type");
TCHAR cszDeviceName[]    = TEXT("Name");
TCHAR cszDevCfgSize[]    = TEXT("Settings_Size");
TCHAR cszDevCfg[]        = TEXT("Settings");

TCHAR cszServerSection[] = TEXT("Server");
TCHAR cszServerType[]    = TEXT("Type");
TCHAR cszSWCompress[]    = TEXT("SW_Compress");
TCHAR cszPWEncrypt[]     = TEXT("PW_Encrypt");
TCHAR cszNetLogon[]      = TEXT("Network_Logon");
TCHAR cszSWEncrypt[]     = TEXT("SW_Encrypt");
TCHAR cszNetBEUI[]       = TEXT("Negotiate_NetBEUI");
TCHAR cszIPX[]           = TEXT("Negotiate_IPX/SPX");
TCHAR cszIP[]            = TEXT("Negotiate_TCP/IP");
TCHAR cszDisableLcp[]    = TEXT("Disable_LCP");

TCHAR cszIPSection[]     = TEXT("TCP/IP");
TCHAR cszIPSpec[]        = TEXT("Specify_IP_Address");
TCHAR cszIPAddress[]     = TEXT("IP_address");
TCHAR cszServerSpec[]    = TEXT("Specify_Server_Address");
TCHAR cszDNSAddress[]    = TEXT("DNS_address");
TCHAR cszDNSAltAddress[] = TEXT("DNS_Alt_address");
TCHAR cszWINSAddress[]   = TEXT("WINS_address");
TCHAR cszWINSAltAddress[]= TEXT("WINS_Alt_address");
TCHAR cszIPCompress[]    = TEXT("IP_Header_Compress");
TCHAR cszWanPri[]        = TEXT("Gateway_On_Remote");

TCHAR cszMLSection[]     = TEXT("Multilink");
TCHAR cszLinkIndex[]     = TEXT("Line_%s");

TCHAR cszScriptingSection[] = TEXT("Scripting");
TCHAR cszScriptName[]    = TEXT("Name");

TCHAR cszScriptSection[] = TEXT("Script_File");

TCHAR cszYes[]           = TEXT("yes");
TCHAR cszNo[]            = TEXT("no");

TCHAR cszUserSection[]   = TEXT("User");
TCHAR cszUserName[]      = TEXT("Name");
TCHAR cszPassword[]      = TEXT("Password");

TCHAR szNull[] = TEXT("");

TCHAR cszSupport[]       = TEXT("Support");
TCHAR cszSupportNumber[] = TEXT("SupportPhoneNumber");

SERVER_TYPES aServerTypes[] =
{ 
    {TEXT("PPP"),     RASFP_Ppp,  0},
    {TEXT("SLIP"),    RASFP_Slip, 0},
    {TEXT("CSLIP"),   RASFP_Slip, RASEO_IpHeaderCompression},
    {TEXT("RAS"),     RASFP_Ras,  0}
};


#pragma data_seg()


TCHAR g_szDeviceName[RAS_MaxDeviceName + 1] = TEXT("\0"); //holds the user's modem choice when multiple
TCHAR g_szDeviceType[RAS_MaxDeviceType + 1] = TEXT("\0"); // modems are installed
#define ISIGNUP_KEY   TEXT("Software\\Microsoft\\ISIGNUP")
#define DEVICENAMEKEY TEXT("DeviceName")
#define DEVICETYPEKEY TEXT("DeviceType")

static const TCHAR cszInetcfg[] = TEXT("Inetcfg.dll");
static const CHAR  cszSetAutoProxyConnectoid[] = "SetAutoProxyConnectoid"; // Proc name. Must be ansi.
typedef HRESULT (WINAPI * SETAUTOPROXYCONNECTOID) (IN BOOL bEnable);

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CISPImport::CISPImport()
{

    m_szDeviceName[0] = TEXT('\0'); 
    m_szDeviceType[0] = TEXT('\0');
    m_szConnectoidName[0] = TEXT('\0');
    m_bIsISDNDevice = FALSE;
}

CISPImport::~CISPImport()
{
    // Clean up the registry
    DeleteUserDeviceSelection(DEVICENAMEKEY);
    DeleteUserDeviceSelection(DEVICETYPEKEY);
}

//+----------------------------------------------------------------------------
// DWORD NEAR PASCAL StrToip (LPTSTR szIPAddress, LPDWORD lpdwAddr)
//
// This function converts a IP address string to an IP address structure.
//
// 
LPCTSTR NEAR PASCAL StrToSubip (LPCTSTR szIPAddress, LPBYTE pVal)
{
  LPCTSTR pszIP = szIPAddress;

  *pVal = (BYTE)Sz2W(pszIP);
  // skip over digits
  while (FIsDigit(*pszIP))
  {
    ++pszIP;
  }

  // skip over one or more separators
  while (*pszIP && !FIsDigit(*pszIP))
  {
    ++pszIP;
  }

  return pszIP;
}


DWORD NEAR PASCAL StrToip (LPCTSTR szIPAddress, RASIPADDR FAR *ipAddr)
{
  LPCTSTR pszIP = szIPAddress;

  pszIP = StrToSubip(pszIP, &ipAddr->a);
  pszIP = StrToSubip(pszIP, &ipAddr->b);
  pszIP = StrToSubip(pszIP, &ipAddr->c);
  pszIP = StrToSubip(pszIP, &ipAddr->d);

  return ERROR_SUCCESS;
}


//****************************************************************************
// DWORD NEAR PASCAL ImportPhoneInfo(PPHONENUM ppn, LPCTSTR szFileName)
//
// This function imports the phone number.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************
DWORD NEAR PASCAL ImportPhoneInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName, BOOL bISDN)
{
  TCHAR   szYesNo[MAXNAME];

  if (!GetPrivateProfileString(cszPhoneSection,
                          (bISDN ? cszISDN : cszPhone),
                          szNull,
                          lpRasEntry->szLocalPhoneNumber,
                          ARRAYSIZE(lpRasEntry->szLocalPhoneNumber),
                          szFileName))
  {
      // If the ISDN_Number is empty, we read from the Phone_Number
      GetPrivateProfileString(cszPhoneSection,
                              cszPhone,
                              DUN_NOPHONENUMBER,
                              lpRasEntry->szLocalPhoneNumber,
                              ARRAYSIZE(lpRasEntry->szLocalPhoneNumber),
                              szFileName);
  }

  lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;

  GetPrivateProfileString(cszPhoneSection,
                          cszDialAsIs,
                          cszYes,
                          szYesNo,
                          ARRAYSIZE(szYesNo),
                          szFileName);

  // Do we have to get country code and area code?
  //
  if (!lstrcmpi(szYesNo, cszNo))
  {

    // If we cannot get the country ID or it is zero, default to dial as is
    //
    if ((lpRasEntry->dwCountryID = GetPrivateProfileInt(cszPhoneSection,
                                                 cszCountryID,
                                                 0,
                                                 szFileName)) != 0)
    {
      lpRasEntry->dwCountryCode = GetPrivateProfileInt(cszPhoneSection,
                                                cszCountryCode,
                                                1,
                                                szFileName);

      if (GetPrivateProfileString(cszPhoneSection,
                              cszAreaCode,
                              szNull,
                              lpRasEntry->szAreaCode,
                              ARRAYSIZE(lpRasEntry->szAreaCode),
                              szFileName) != 0)
      {
        lpRasEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;
      }
    }
  }
  return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportServerInfo(PSMMINFO psmmi, LPTSTR szFileName)
//
// This function imports the server type name and settings.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************
DWORD NEAR PASCAL ImportServerInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
  TCHAR   szYesNo[MAXNAME];
  TCHAR   szType[MAXNAME];
  DWORD  i;

  // Get the server type name
  //
  GetPrivateProfileString(cszServerSection,
                          cszServerType,
                          szNull,
                          szType,
                          ARRAYSIZE(szType),
                          szFileName);

  // need to convert the string into
  // one of the following values
  //   RASFP_Ppp
  //   RASFP_Slip  Note CSLIP is SLIP with IP compression on
  //   RASFP_Ras

  for (i = 0; i < NUM_SERVER_TYPES; ++i)
  {
    if (!lstrcmpi(aServerTypes[i].szType, szType))
    {
       lpRasEntry->dwFramingProtocol = aServerTypes[i].dwType;
       lpRasEntry->dwfOptions |= aServerTypes[i].dwfOptions;
       break;
    }
  }

  // Get the server type settings
  //
  if (GetPrivateProfileString(cszServerSection,
                              cszSWCompress,
                              szNull,
                              szYesNo,
                              ARRAYSIZE(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_SwCompression;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_SwCompression;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszPWEncrypt,
                              szNull,
                              szYesNo,
                              ARRAYSIZE(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RequireEncryptedPw;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RequireEncryptedPw;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszNetLogon,
                              szNull,
                              szYesNo,
                              ARRAYSIZE(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_NetworkLogon;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_NetworkLogon;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszSWEncrypt,
                              szNull,
                              szYesNo,
                              ARRAYSIZE(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RequireDataEncryption;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RequireDataEncryption;
    };
  };

  // Get the protocol settings
  //
  if (GetPrivateProfileString(cszServerSection,
                              cszNetBEUI,
                              szNull,
                              szYesNo,
                              ARRAYSIZE(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
        lpRasEntry->dwfNetProtocols &= ~RASNP_NetBEUI;
    }
    else
    {
        lpRasEntry->dwfNetProtocols |= RASNP_NetBEUI;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszIPX,
                              szNull,
                              szYesNo,
                              ARRAYSIZE(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
        lpRasEntry->dwfNetProtocols &= ~RASNP_Ipx;
    }
    else
    {
        lpRasEntry->dwfNetProtocols |= RASNP_Ipx;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszIP,
                              szNull,
                              szYesNo,
                              ARRAYSIZE(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
        lpRasEntry->dwfNetProtocols &= ~RASNP_Ip;
    }
    else
    {
        lpRasEntry->dwfNetProtocols |= RASNP_Ip;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszDisableLcp,
                              szNull,
                              szYesNo,
                              ARRAYSIZE(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszYes))
    {
        lpRasEntry->dwfOptions |= RASEO_DisableLcpExtensions;
    }
    else
    {
        lpRasEntry->dwfOptions &= ~RASEO_DisableLcpExtensions;
    }
  };
  return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportIPInfo(LPTSTR szEntryName, LPTSTR szFileName)
//
// This function imports the TCP/IP information
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************
DWORD NEAR PASCAL ImportIPInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
  TCHAR   szIPAddr[MAXIPADDRLEN];
  TCHAR   szYesNo[MAXNAME];

  // Import IP address information
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszIPSpec,
                              szNull,
                              szYesNo,
                              ARRAYSIZE(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszYes))
    {
      // The import file has IP address specified, get the IP address
      //
      lpRasEntry->dwfOptions |= RASEO_SpecificIpAddr;
      if (GetPrivateProfileString(cszIPSection,
                                  cszIPAddress,
                                  szNull,
                                  szIPAddr,
                                  ARRAYSIZE(szIPAddr),
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddr);
      };
    }
    else
    {
      lpRasEntry->dwfOptions &= ~RASEO_SpecificIpAddr;
    };
  };

  // Import Server address information
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszServerSpec,
                              szNull,
                              szYesNo,
                              ARRAYSIZE(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszYes))
    {
      // The import file has server address specified, get the server address
      //
      lpRasEntry->dwfOptions |= RASEO_SpecificNameServers;
      if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAddress,
                                  szNull,
                                  szIPAddr,
                                  ARRAYSIZE(szIPAddr),
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrDns);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAltAddress,
                                  szNull,
                                  szIPAddr,
                                  ARRAYSIZE(szIPAddr),
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrDnsAlt);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAddress,
                                  szNull,
                                  szIPAddr,
                                  ARRAYSIZE(szIPAddr),
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrWins);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAltAddress,
                                  szNull,
                                  szIPAddr,
                                  ARRAYSIZE(szIPAddr),
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrWinsAlt);
      };
    }
    else
    {
      lpRasEntry->dwfOptions &= ~RASEO_SpecificNameServers;
    };
  };

  // Header compression and the gateway settings
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszIPCompress,
                              szNull,
                              szYesNo,
                              ARRAYSIZE(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_IpHeaderCompression;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_IpHeaderCompression;
    };
  };

  if (GetPrivateProfileString(cszIPSection,
                              cszWanPri,
                              szNull,
                              szYesNo,
                              ARRAYSIZE(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RemoteDefaultGateway;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RemoteDefaultGateway;
    };
  };

  return ERROR_SUCCESS;
}

//****************************************************************************
// HANDLE NEAR PASCAL CreateUniqueFile(LPTSTR szPath, LPTSTR szFile)
//
// This function creates a unique file. If the file already exists, it will
// try to create a file with similar name and return the name.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HANDLE NEAR PASCAL CreateUniqueFile(LPTSTR szPath, LPTSTR szScript)
{
  HANDLE hFile; 

  LPTSTR  pszSuffix, lpsz;
  UINT   uSuffix;

  pszSuffix = szPath + lstrlen(szPath); 
  
  lpsz = CharPrev(szPath, pszSuffix);
  
  if (*lpsz != '\\')
  {
    *pszSuffix = '\\';
    pszSuffix++;
  };
  lstrcpy(pszSuffix, szScript);

  // Try the specified filename
  //
  hFile = CreateFile(szPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL, NULL);
                     

  // If the file exists
  //
    if ((hFile == INVALID_HANDLE_VALUE) && (GetLastError() == ERROR_FILE_EXISTS))
  {
    TCHAR szNewName[MAX_PATH];

    // Need to copy it to another name in the same directory
    //
    if (LoadString(_Module.GetModuleInstance(), IDS_DEFAULT_SCP, szNewName, ARRAYSIZE(szNewName)))
    {
      // Increment the file index until a non-duplicated file can be created
      //
      uSuffix = 0;
      do
      {
        wsprintf(pszSuffix, szNewName, uSuffix);
        uSuffix++;
        hFile = CreateFile(szPath, GENERIC_WRITE, 0, NULL, CREATE_NEW,
                               FILE_ATTRIBUTE_NORMAL, NULL);

      } 
      while ((hFile == INVALID_HANDLE_VALUE) &&
             (GetLastError() == ERROR_FILE_EXISTS) &&
             (uSuffix < 0x0000FFFF)); 
    };
  };

  // If we do not have the file, reserve the pathname
  //
  if (hFile == INVALID_HANDLE_VALUE)
  {
    *pszSuffix = '\0';
  };
  return hFile;
}

//****************************************************************************
// HANDLE NEAR PASCAL CreateScriptFile(LPTSTR szScript, LPTSTR szImportFile)
//
// This function creates the script file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HANDLE NEAR PASCAL CreateScriptFile(LPTSTR szScript, LPCTSTR szImportFile)
{
  LPTSTR pszDir;
  DWORD cb;
  HANDLE hFile;

  // Assume failure
  //
  hFile = INVALID_HANDLE_VALUE;

  // Allocate a buffer for pathname
  //
  TCHAR pszPath[MAX_PATH * 2];
  TCHAR pszShortName[MAX_PATH * 2]; //pszShortName = pszPath+MAX_PATH;

  // Get the default directory
  //
  if (GetWindowsDirectory(pszPath, MAX_PATH) != 0)
  {
    // Get the Windows drive
    //
    pszDir = pszPath;
    while((*pszDir != '\\') && (*pszDir != '\0'))
    {
      pszDir = CharNext(pszDir);
    };

    // Did we find Windows drive?
    //
    if (*pszDir != '\0')
    {
      // Prepare the drive
      //
      cb = (DWORD)(pszDir - pszPath);
      MyMemCpy((LPBYTE) szScript, (const LPBYTE) pszPath, (size_t) cb);
      pszDir = szScript + cb;

      // Get the script filename
      //
      if (GetPrivateProfileString(cszScriptingSection,
                                  cszScriptName,
                                  szNull,
                                  pszShortName,
                                  MAX_PATH,
                                  szImportFile) != 0)
      {
        // Try the favorite script directory
        //
        if (LoadString(_Module.GetModuleInstance(), IDS_INI_SCRIPT_DIR, pszDir,
                       (MAX_PATH - cb)) != 0)
        {
          // Try creating the file
          //
          hFile = CreateUniqueFile(szScript, pszShortName);
        };

        // If we do not have the file yet, try the second favorite
        //
        if (hFile == INVALID_HANDLE_VALUE)
        {
          if (LoadString(_Module.GetModuleInstance(), IDS_INI_SCRIPT_SHORTDIR, pszDir,
                       (MAX_PATH - cb)))
          {
            // Try creating the file
            //
            hFile = CreateUniqueFile(szScript, pszShortName);
          };
        };

        // If we do not have the file yet, try Windows directory
        //
        if (hFile == INVALID_HANDLE_VALUE)
        {
          // Get original Windows directory
          //
          lstrcpy(szScript, pszPath);

          // Try one more time
          //
          hFile = CreateUniqueFile(szScript, pszShortName);
        };
      };
    };
  };

  return hFile;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportScriptFile(LPTSTR szEntryName, LPTSTR szImportFile)
//
// This function imports the script file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD NEAR PASCAL ImportScriptFile(LPRASENTRY lpRasEntry, LPCTSTR szImportFile)
{
  HANDLE hfScript;
  LPTSTR  pszLine;
  LPTSTR  pszFile;
  int    i, iMaxLine;
  UINT   cbSize, cbRet;
  TCHAR   szTmp[4];
  DWORD  dwRet;

  dwRet=ERROR_SUCCESS;

  // If a script section does not exist, do nothing
  //
  if (GetPrivateProfileString(cszScriptingSection,
                              cszScriptName,
                              szNull,
                              szTmp,
                              4,
                              szImportFile) == 0)
  {
    return ERROR_SUCCESS;
  };

  // Allocate a buffer for the script lines
  //
  pszLine = new TCHAR[SIZE_ReadBuf+MAX_PATH];
  if (pszLine == NULL)
  {
    TraceMsg(TF_GENERAL,TEXT("CONNECT:ImportScriptFile(): Local Alloc failed\n"));
    return ERROR_OUTOFMEMORY;
  }

  // Look for script
  //
  if (GetPrivateProfileString(cszScriptSection,
                              NULL,
                              szNull,
                              pszLine,
                              SIZE_ReadBuf,
                              szImportFile) != 0)
  {
    // Get the maximum line number
    //
    pszFile = pszLine;
    iMaxLine = -1;
    while (*pszFile)
    {
      i = Sz2W(pszFile);
      iMaxLine = max(iMaxLine, i);
      pszFile += lstrlen(pszFile)+1;
    };

    // If we have at least one line, we will import the script file
    //
    if (iMaxLine >= 0)
    {
      pszFile = pszLine+SIZE_ReadBuf;

      // Create the script file
      //
      //DebugBreak();
      hfScript = CreateScriptFile(pszFile, szImportFile);
        TraceMsg(TF_GENERAL, TEXT("CONNECT:ImportScriptFile(): CreateScriptFile hfScript %d, %s, %s\n"),hfScript,pszFile,szImportFile);

      if (hfScript != INVALID_HANDLE_VALUE)
      {
        TCHAR   szLineNum[MAXLONGLEN+1];

        // From The first line to the last line
        //
        for (i = 0; i <= iMaxLine; i++)
        {
          // Read the script line
          //
          wsprintf(szLineNum, TEXT("%d"), i);
          if ((cbSize = GetPrivateProfileString(cszScriptSection,
                                                szLineNum,
                                                szNull,
                                                pszLine,
                                                SIZE_ReadBuf,
                                                szImportFile)) != 0)
          {
            // Write to the script file
            //
            lstrcat(pszLine, TEXT("\x0d\x0a"));
#ifdef UNICODE
            CHAR szTmp[SIZE_ReadBuf];
            size_t nSize = wcstombs(szTmp, pszLine, SIZE_ReadBuf);
            if (nSize > 0)
                WriteFile(hfScript, szTmp, nSize, (LPDWORD)&cbRet, NULL);
#else
            WriteFile(hfScript, pszLine, cbSize+2, (LPDWORD)&cbRet, NULL);
#endif 
          };
        };

        CloseHandle(hfScript);

        // Associate it with the phonebook entry
        //
        lstrcpyn(lpRasEntry->szScript, pszFile, RAS_MaxEntryName);

      }
      else
      {
        dwRet = GetLastError();
      };
    }
    else
    {
      dwRet = ERROR_PATH_NOT_FOUND;
    };
  }
  else
  {
    dwRet = ERROR_PATH_NOT_FOUND;
  };
  delete [] pszLine;

  return dwRet;
}

//****************************************************************************
// DWORD WINAPI RnaValidateImportEntry (LPTSTR)
//
// This function is called to validate an importable file
//
// History:
//  Wed 03-Jan-1996 09:45:01  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CISPImport::RnaValidateImportEntry (LPCTSTR szFileName)
{
  TCHAR  szTmp[4];

  // Get the alias entry name
  //
  return (GetPrivateProfileString(cszEntrySection,
                                  cszEntryName,
                                  szNull,
                                  szTmp,
                                  4,
                                  szFileName) > 0 ?
          ERROR_SUCCESS : ERROR_CORRUPT_PHONEBOOK);
}

//****************************************************************************
// HRESULT ImportConnection (LPCTSTR szFileName, LPTSTR pszEntryName, LPTSTR pszUserName, LPTSTR pszPassword)
//
// This function is called to import an entry from a specified file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//  Sat 16-Mar-1996 10:01:00  -by-  Chris Kauffman [chrisk]
// Modified to return HRESULT and load DLL dynamically
//****************************************************************************

HRESULT CISPImport::ImportConnection (LPCTSTR szFileName, LPTSTR pszSupportNumber, LPTSTR pszEntryName, LPTSTR pszUserName, LPTSTR pszPassword, LPBOOL pfNeedsRestart)
{
    LPRASENTRY      lpRasEntry;
    DWORD           dwRet;
    DWORD           dwOptions;
    HINSTANCE       hinetcfg;
    FARPROC         fp, fpSetAutoProxy;
    
    // Get the size of device configuration
    // This also validates an exported file
    //
    if ((dwRet = RnaValidateImportEntry(szFileName)) != ERROR_SUCCESS)
    {
        return dwRet;
    };

    // Allocate a buffer for entry and device config
    //
    if ((lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR, sizeof(RASENTRY))) == NULL)
    {
        return ERROR_OUTOFMEMORY;
    };
    
    // Get the entry name
    // Need to find a good name for it and remember it as an alias
    //
    GetPrivateProfileString(cszEntrySection,
                          cszEntryName,
                          szNull,
                          pszEntryName,
                          RAS_MaxEntryName+1,
                          szFileName);

    GetPrivateProfileString(cszUserSection,
                          cszUserName,
                          szNull,
                          pszUserName,
                          UNLEN+1,
                          szFileName);

    GetPrivateProfileString(cszUserSection,
                          cszPassword,
                          szNull,
                          pszPassword,
                          PWLEN+1,
                          szFileName);

    // Get ISP support number
    //
    GetPrivateProfileString(cszSupport,
                          cszSupportNumber,
                          szNull,
                          pszSupportNumber,
                          RAS_MaxAreaCode + RAS_MaxPhoneNumber +1,
                          szFileName);

    // Get device name, type and config
    //
    GetPrivateProfileString(cszDeviceSection,
                          cszDeviceType,
                          szNull,
                          lpRasEntry->szDeviceType,
                          ARRAYSIZE(lpRasEntry->szDeviceType),
                          szFileName);

    // Get Server Type settings
    //
    ImportServerInfo(lpRasEntry, szFileName);

    // Get IP address
    //
    ImportIPInfo(lpRasEntry, szFileName);

    // Import the script file
    //
    if ((dwRet = ImportScriptFile(lpRasEntry, szFileName)) != ERROR_SUCCESS)
    {
        TraceMsg(TF_GENERAL,TEXT("CONNECT:ImportScriptFile Failed with the error %d,%s,%s"),dwRet,szFileName,lpRasEntry->szScript);
    }

    lpRasEntry->dwSize = sizeof(RASENTRY);

    // Load and Locate AutoRunSignUpWizard entry point
    //

    hinetcfg = LoadLibrary(TEXT("INETCFG.DLL"));
    AssertMsg(hinetcfg != NULL, TEXT("Cannot find INETCFG.DLL"));
    if (!hinetcfg) 
    {
        dwRet = GetLastError();
        goto ImportConnectionExit;
    }

    fpSetAutoProxy = GetProcAddress(hinetcfg,cszSetAutoProxyConnectoid);
    if (fpSetAutoProxy)
    {
        ((SETAUTOPROXYCONNECTOID)fpSetAutoProxy) (FALSE);
    }

    fp = GetProcAddress(hinetcfg,AUTORUNSIGNUPWIZARDAPI);
    AssertMsg(fp != NULL, TEXT("Cannot find AutoRunSignupWizard entry point"));
    if (!fp)
    {
        dwRet = GetLastError();
        goto ImportConnectionExit;
    }

    // 10/19/96    jmazner    Normandy #8462 -- multiple modems
    dwRet = ConfigRasEntryDevice(lpRasEntry);
    switch( dwRet )
    {
        case ERROR_SUCCESS:
            break;
        case ERROR_CANCELLED:
            if( IDYES != MessageBox(GetActiveWindow(),GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
                            MB_APPLMODAL | MB_ICONQUESTION |
                            MB_YESNO | MB_DEFBUTTON2) )
            {
                dwRet = ERROR_RETRY;
            }
            goto ImportConnectionExit;

        default:
            goto ImportConnectionExit;
    }

    // See if this is a ISDN type device, and if so, then set the CFGFLAG_ISDN_OFFER
    if (lstrcmpi(g_szDeviceType, RASDT_Isdn) == 0)
        m_bIsISDNDevice = TRUE;
    
    ImportPhoneInfo(lpRasEntry, szFileName, m_bIsISDNDevice);

    //
    // ChrisK Olympus 4756 5/25/97
    // Do not display busy animation on Win95
    //
    dwOptions = INETCFG_INSTALLRNA |
                      INETCFG_INSTALLTCP |
                      INETCFG_OVERWRITEENTRY;

    dwRet =  ((PFNAUTORUNSIGNUPWIZARD)fp)(
                NULL,
                NULL,
                pszEntryName,
                lpRasEntry,
                pszUserName,
                pszPassword,
                NULL,
                NULL,
                dwOptions,
                pfNeedsRestart);

    if (fpSetAutoProxy)
    {
        ((SETAUTOPROXYCONNECTOID)fpSetAutoProxy) (TRUE);
    }
    LclSetEntryScriptPatch(lpRasEntry->szScript,pszEntryName);

    // now that we've made the connectoid in InetConfigClient (PFNAUTORUNSIGNUPWIZARD),
    // store its name in psheet's global so that we can delete it if user cancels
    lstrcpyn( m_szConnectoidName, pszEntryName, lstrlen(pszEntryName) + 1);

    TraceMsg(TF_GENERAL,TEXT("CONNECT:EntryName %s, User %s, Password (not shown), Number %s\n"),pszEntryName,pszUserName,lpRasEntry->szLocalPhoneNumber);
    //AssertMsg(!fNeedsRestart,TEXT("We have to reboot AGAIN!!"));

    // Exit and cleanup
    //

ImportConnectionExit:
    if (hinetcfg) FreeLibrary(hinetcfg);
    GlobalFree(lpRasEntry);
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function    GetDeviceSelectedByUser
//
//    Synopsis    Get the name of the RAS device that the user had already picked
//
//    Arguements    szKey - name of sub key
//                szBuf - pointer to buffer
//                dwSize - size of buffer
//
//    Return        TRUE - success
//
//    History        10/24/96    ChrisK    Created
//-----------------------------------------------------------------------------
BOOL CISPImport::GetDeviceSelectedByUser (LPTSTR szKey, LPTSTR szBuf, DWORD dwSize)
{
    BOOL bRC = FALSE;
    HKEY hkey = NULL;
    DWORD dwType = 0;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,ISIGNUP_KEY,&hkey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hkey,szKey,0,&dwType,
            (LPBYTE)szBuf,&dwSize))
            bRC = TRUE;
    }

    if (hkey)
        RegCloseKey(hkey);
    return bRC;
}

//+----------------------------------------------------------------------------
//    Function    SetDeviceSelectedByUser
//
//    Synopsis    Write user's device selection to registry
//
//    Arguments    szKey - name of key
//                szBuf - data to write to key
//
//    Returns        TRUE - success
//
//    History        10/24/96    ChrisK    Created
//-----------------------------------------------------------------------------
BOOL CISPImport::SetDeviceSelectedByUser (LPTSTR szKey, LPTSTR szBuf)
{
    BOOL bRC = FALSE;
    HKEY hkey = 0;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,
        ISIGNUP_KEY,&hkey))
    {
        if (ERROR_SUCCESS == RegSetValueEx(hkey,szKey,0,REG_SZ,
            (LPBYTE)szBuf,sizeof(TCHAR)*(lstrlen(szBuf)+1)))
            bRC = TRUE;
    }

    if (hkey)
        RegCloseKey(hkey);
    return bRC;
}

//+----------------------------------------------------------------------------
//    Funciton    DeleteUserDeviceSelection
//
//    Synopsis    Remove registry keys with device selection
//
//    Arguments    szKey - name of value to remove
//
//    Returns        TRUE - success
//
//    History        10/24/96    ChrisK    Created
//-----------------------------------------------------------------------------
BOOL CISPImport::DeleteUserDeviceSelection(LPTSTR szKey)
{
    BOOL bRC = FALSE;
    HKEY hkey = NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,ISIGNUP_KEY,&hkey))
    {
        bRC = (ERROR_SUCCESS == RegDeleteValue(hkey,szKey));
        RegCloseKey(hkey);
    }
    return bRC;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConfigRasEntryDevice()
//
//  Synopsis:   Checks whether user has already specified a modem to use;
//                If so, verifies that modem is valid.
//                If not, or if modem is invalid, presents user a dialog
//                to choose which modem to use (if only one modem is installed,
//                it automaticaly selects that device and bypasses the dialog)
//
//  Arguments:  lpRasEntry - Pointer to the RasEntry whose szDeviceName and
//                             szDeviceType members you wish to verify/configure
//
//    Returns:    ERROR_CANCELLED - Had to bring up "Choose Modem" dialog, and
//                                  and user hit its "Cancel" button
//                Otherwise returns any error code encountered.
//                ERROR_SUCCESS indicates success.
//
//  History:    5/18/96     VetriV    Created
//              3/7/98      DonSc     Added the process-wide tracking of the previously
//                                    selected device.
//
//----------------------------------------------------------------------------
DWORD CISPImport::ConfigRasEntryDevice( LPRASENTRY lpRasEntry )
{
    DWORD        dwRet = ERROR_SUCCESS;
    CEnumModem  EnumModem;

    GetDeviceSelectedByUser(DEVICENAMEKEY, g_szDeviceName, sizeof(g_szDeviceName));
    GetDeviceSelectedByUser(DEVICETYPEKEY, g_szDeviceType, sizeof(g_szDeviceType));

    ASSERT(lpRasEntry);

    dwRet = EnumModem.GetError();
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    // If there are no modems, we're horked
    if (0 == EnumModem.GetNumDevices())
    {
        TraceMsg(TF_GENERAL,TEXT("ICWHELP: import.cpp: ConfigRasEntryDevice: ERROR: No modems installed!\n"));
        return ERROR_CANCELLED;
    }


    // Validate the device if possible
    if ( lpRasEntry->szDeviceName[0] && lpRasEntry->szDeviceType[0] )
    {
        // Verify that there is a device with the given name and type
        if (!EnumModem.VerifyDeviceNameAndType(lpRasEntry->szDeviceName, 
                                                lpRasEntry->szDeviceType))
        {
            // There was no device that matched both name and type,
            // so reset the strings and bring up the choose modem UI.
            lpRasEntry->szDeviceName[0] = '\0';
            lpRasEntry->szDeviceType[0] = '\0';
        }
    }
    else if ( lpRasEntry->szDeviceName[0] )
    {
        // Only the name was given.  Try to find a matching type.
        // If this fails, fall through to recovery case below.
        LPTSTR szDeviceType =
            EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName);
        if (szDeviceType)
        {
            lstrcpy (lpRasEntry->szDeviceType, szDeviceType);
        }
    }
    else if ( lpRasEntry->szDeviceType[0] )
    {
        // Only the type was given.  Try to find a matching name.
        // If this fails, fall through to recovery case below.
        LPTSTR szDeviceName = 
            EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceType);
        if (szDeviceName)
        {
            lstrcpy (lpRasEntry->szDeviceName, szDeviceName);
        }
    }
    // If either name or type is missing, check whether the user has already made a choice.
    // if not, bring up choose modem UI if there
    // are multiple devices, else just get first device.
    // Since we already verified that there was at least one device,
    // we can assume that this will succeed.
    if( !(lpRasEntry->szDeviceName[0]) ||
        !(lpRasEntry->szDeviceType[0]) )
    {
        TraceMsg(TF_GENERAL,TEXT("ICWHELP: ConfigRasEntryDevice: no valid device passed in\n"));
        if( g_szDeviceName[0] )
        {
            // it looks like we have already stored the user's choice.
            // store the DeviceName in lpRasEntry, then call GetDeviceTypeFromName
            // to confirm that the deviceName we saved actually exists on the system
            lstrcpy(lpRasEntry->szDeviceName, g_szDeviceName);
            
            if( 0 == lstrcmp(EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName),
                              g_szDeviceType) )
            {
                lstrcpy(lpRasEntry->szDeviceType, g_szDeviceType);
                return ERROR_SUCCESS;
            }
        }
        if (1 == EnumModem.GetNumDevices())
        {
            // There is just one device installed, so copy the name
            TraceMsg(TF_GENERAL,TEXT("ICWHELP: import.cpp: ConfigRasEntryDevice: only one modem installed, using it\n"));
            lstrcpy (lpRasEntry->szDeviceName, EnumModem.Next());
        }
        else
        {
            TraceMsg(TF_GENERAL,TEXT("ICWHELP: import.cpp: ConfigRasEntryDevice: multiple modems detected\n"));
            if (IsNT4SP3Lower())
                lstrcpy (lpRasEntry->szDeviceName, EnumModem.Next() );
            else
            {
                CHOOSEMODEMDLGINFO ChooseModemDlgInfo;
 

                BOOL fRet=(BOOL)DialogBoxParam(GetModuleHandle(TEXT("ICWHELP.DLL")), MAKEINTRESOURCE(IDD_CHOOSEMODEMNAME), GetActiveWindow(),
                    ChooseModemDlgProc,(LPARAM) &ChooseModemDlgInfo);
                if (TRUE != fRet)
                {
                    // user cancelled or an error occurred.
                    dwRet = ChooseModemDlgInfo.hr;
                    /*
                    dwRet = GetLastError(); //This will NEVER be ERROR_SUCCESS
                
                    //BUBGUG -- If the user hits OK -> then ChooseModemDlgInfo.hr == ERROR_SUCCESS,
                    BUT if OK was hit then the function returns true and this can never be hit!
                    if (ERROR_SUCCESS == dwRet)
                    {
                        // Error occurred, but the error code was not set.
                        dwRet = ERROR_INETCFG_UNKNOWN;
                    }*/
                    return dwRet;
                }
    
                // Copy the modem name string
                lstrcpy (lpRasEntry->szDeviceName, ChooseModemDlgInfo.szModemName);
            }
        }

        // Now get the type string for this modem
        lstrcpy (lpRasEntry->szDeviceType,EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName));
    }

    lstrcpy(g_szDeviceName, lpRasEntry->szDeviceName);
    lstrcpy(g_szDeviceType, lpRasEntry->szDeviceType);

    // Save device name and type
    lstrcpy( m_szDeviceName, lpRasEntry->szDeviceName);
    lstrcpy( m_szDeviceType, lpRasEntry->szDeviceType);

    // Save data in registry
    SetDeviceSelectedByUser(DEVICENAMEKEY, g_szDeviceName);
    SetDeviceSelectedByUser (DEVICETYPEKEY, g_szDeviceType);

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\icwerr.cpp ===
#include "stdafx.h"

#define RAS_BOGUS_AUTHFAILCODE_1	84
#define RAS_BOGUS_AUTHFAILCODE_2	74389484

DWORD RasErrorToIDS(DWORD dwErr)
{
	//DWORD ev;

	if(dwErr==RAS_BOGUS_AUTHFAILCODE_1 || dwErr==RAS_BOGUS_AUTHFAILCODE_2)
	{
		// DebugTrace(("RAS returned bogus AUTH error code %08x. Munging...\r\n", dwErr));
		return IDS_PPPRANDOMFAILURE;
	}

	if((dwErr>=653 && dwErr<=663) || (dwErr==667) || (dwErr>=669 && dwErr<=675))
	{
		OutputDebugString(TEXT("Got random RAS MEDIA error!\r\n"));
		return IDS_MEDIAINIERROR;
	}

	switch(dwErr)
	{
	default:
		return IDS_PPPRANDOMFAILURE;

	case SUCCESS:
		return 0;

	case ERROR_DOWNLOAD_NOT_FOUND:
		return IDS_DOWNLOAD_NOT_FOUND;

	case ERROR_DOWNLOADIDNT:
		return IDS_CANTDOWNLOAD;
		
	case ERROR_LINE_BUSY:
		return IDS_PHONEBUSY;

	case ERROR_NO_ANSWER:
		return IDS_NOANSWER;
		
	case ERROR_VOICE_ANSWER:
	case ERROR_NO_CARRIER:
		return IDS_RASNOCARRIER;
		
	case ERROR_NO_DIALTONE:
		return IDS_NODIALTONE;

	case ERROR_HARDWARE_FAILURE:	// modem turned off
	case ERROR_PORT_ALREADY_OPEN:	// procomm/hypertrm/RAS has COM port
	case ERROR_PORT_OR_DEVICE:		// got this when hypertrm had the device open -- jmazner
		return IDS_NODEVICE;

	case ERROR_USER_DISCONNECTION:
		return IDS_USERCANCELEDDIAL;

	case ERROR_BUFFER_INVALID:				// bad/empty rasdilap struct
	case ERROR_BUFFER_TOO_SMALL:			// ditto?
	case ERROR_CANNOT_FIND_PHONEBOOK_ENTRY:	// if connectoid name in registry is wrong
		return IDS_TCPINSTALLERROR;

    case ERROR_AUTHENTICATION_FAILURE:		// get this on actual CHAP reject
		return IDS_PPPRANDOMFAILURE;

	case ERROR_PPP_TIMEOUT:		// get this on CHAP timeout
		return IDS_TIMEOUT;

	case ERROR_REMOTE_DISCONNECTION:		// Ascend drops connection on auth-fail
		return IDS_PPPRANDOMFAILURE;

	case ERROR_AUTH_INTERNAL:				// got this on random POP failure
	case ERROR_PROTOCOL_NOT_CONFIGURED:		// get this if LCP fails
	case ERROR_PPP_NO_PROTOCOLS_CONFIGURED:	// get this if IPCP addr download gives garbage
		return IDS_PPPRANDOMFAILURE;

	case ERROR_USERCANCEL:
		return IDS_USERCANCELEDDIAL;


	}
	return (DWORD)(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\import.h ===
// Import.h: interface for the CISPImport class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_IMPORT_H__BF2F451A_8899_11D1_ADD9_0000F87734F0__INCLUDED_)
#define AFX_IMPORT_H__BF2F451A_8899_11D1_ADD9_0000F87734F0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define IDS_DEFAULT_SCP         0
#define IDS_INI_SCRIPT_DIR      1
#define IDS_INI_SCRIPT_SHORTDIR 2

#define MAXLONGLEN      80
#define MAXNAME         80

#define MAXIPADDRLEN    20
#define SIZE_ReadBuf    0x00008000    // 32K buffer size

#ifdef UNICODE
#define AUTORUNSIGNUPWIZARDAPI "InetConfigClientW" // Proc name. Must be ansi.
#else
#define AUTORUNSIGNUPWIZARDAPI "InetConfigClient" // Proc name. Must be ansi.
#endif

typedef HRESULT (WINAPI *PFNAUTORUNSIGNUPWIZARD) (HWND hwndParent,
													LPCTSTR lpszPhoneBook,
													 LPCTSTR lpszConnectoidName,
													 LPRASENTRY lpRasEntry,
													 LPCTSTR lpszUsername,
													 LPCTSTR lpszPassword,
													 LPCTSTR lpszProfileName,
													 LPINETCLIENTINFO lpINetClientInfo,
													 DWORD dwfOptions,
													 LPBOOL lpfNeedsRestart);


#define DUN_NOPHONENUMBER TEXT("000000000000")
#define DUN_NOPHONENUMBER_A "000000000000"

class CISPImport  
{
public:
	CISPImport();
	virtual ~CISPImport();
    void    set_hWndMain(HWND   hWnd)
    {
        m_hWndMain = hWnd;
    };

    DWORD RnaValidateImportEntry (LPCTSTR szFileName);
    HRESULT ImportConnection (LPCTSTR szFileName, LPTSTR pszEntryName, LPTSTR pszSupportNumber, LPTSTR pszUserName, LPTSTR pszPassword, LPBOOL pfNeedsRestart);
    BOOL GetDeviceSelectedByUser (LPTSTR szKey, LPTSTR szBuf, DWORD dwSize);
    BOOL SetDeviceSelectedByUser (LPTSTR szKey, LPTSTR szBuf);
    BOOL DeleteUserDeviceSelection(LPTSTR szKey);
    DWORD ConfigRasEntryDevice( LPRASENTRY lpRasEntry );

    TCHAR m_szDeviceName[RAS_MaxDeviceName + 1]; //holds the user's modem choice when multiple
    TCHAR m_szDeviceType[RAS_MaxDeviceType + 1]; // modems are installed
    TCHAR m_szConnectoidName[RAS_MaxEntryName+1];

    HWND m_hWndMain;
    
    BOOL m_bIsISDNDevice;
};

#endif // !defined(AFX_IMPORT_H__BF2F451A_8899_11D1_ADD9_0000F87734F0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\inshandler.h ===
// INSHandler.h : Declaration of the CINSHandler

#ifndef __INSHANDLER_H_
#define __INSHANDLER_H_

// This struct is used to configure the client
typedef struct
{
    LPCTSTR lpszSection;
    LPCTSTR lpszValue;
    UINT    uOffset;
    UINT    uSize;
} CLIENT_TABLE, FAR *LPCLIENT_TABLE;

typedef struct
{
    TCHAR         szEntryName[RAS_MaxEntryName+1];
    TCHAR         szUserName[UNLEN+1];
    TCHAR         szPassword[PWLEN+1];
    TCHAR         szScriptFile[MAX_PATH+1];
    RASENTRY      RasEntry;
} ICONNECTION, FAR * LPICONNECTION;

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CINSHandler
class ATL_NO_VTABLE CINSHandler :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CINSHandler,&CLSID_INSHandler>,
	public CComControl<CINSHandler>,
	public IDispatchImpl<IINSHandler, &IID_IINSHandler, &LIBID_ICWHELPLib>,
    public IProvideClassInfo2Impl<&CLSID_INSHandler, &DIID__INSHandlerEvents, &LIBID_ICWHELPLib>,
	public IPersistStreamInitImpl<CINSHandler>,
	public IOleControlImpl<CINSHandler>,
	public IOleObjectImpl<CINSHandler>,
	public IOleInPlaceActiveObjectImpl<CINSHandler>,
	public IViewObjectExImpl<CINSHandler>,
	public IOleInPlaceObjectWindowlessImpl<CINSHandler>,
    public CProxy_INSHandlerEvents<CINSHandler>,
    public IConnectionPointContainerImpl<CINSHandler>,
    public IObjectSafetyImpl<CINSHandler>
{
public:
	CINSHandler()
	{
        m_szRunExecutable      [0]  = '\0';
        m_szRunArgument        [0]  = '\0';
        m_szCheckAssociations  [0]  = '\0';
        m_szAutodialConnection [0]  = '\0';
        m_szStartURL           [0]  = '\0';
        m_fResforeDefCheck          = FALSE;
        m_fAutodialSaved            = TRUE;
        m_fAutodialEnabled          = FALSE;
        m_fProxyEnabled             = FALSE;
        m_bSilentMode               = FALSE;
        m_lpfnInetConfigSystem      = NULL;
        m_lpfnInetGetProxy          = NULL;
        m_lpfnInetConfigClient      = NULL;
        //m_lpfnInetConfigClientEx    = NULL;
        m_lpfnInetGetAutodial       = NULL;
        m_lpfnInetSetAutodial       = NULL;
        m_lpfnInetSetClientInfo     = NULL;
        m_lpfnInetSetProxy          = NULL;
        m_lpfnBrandICW              = NULL;
        m_lpfnRasSetAutodialEnable  = NULL;
	    m_lpfnRasSetAutodialAddress = NULL;
        m_hInetCfg                  = NULL;
        m_hBranding                 = NULL;
        m_hRAS                      = NULL;
        m_dwBrandFlags              = BRAND_DEFAULT;      
	}

DECLARE_REGISTRY_RESOURCEID(IDR_INSHANDLER)

BEGIN_COM_MAP(CINSHandler) 
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IINSHandler)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CINSHandler)
    CONNECTION_POINT_ENTRY(DIID__INSHandlerEvents)
END_CONNECTION_POINT_MAP()


BEGIN_PROPERTY_MAP(CINSHandler)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CINSHandler)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = 0;
		return S_OK;
	}

    
// IINSHandler
public:
	STDMETHOD (put_BrandingFlags) (/*[in]*/ long lFlags);
	STDMETHOD (put_SilentMode)    (/*[in]*/ BOOL bSilent);
    STDMETHOD (get_NeedRestart)   (/*[out, retval]*/ BOOL *pVal);
	STDMETHOD (ProcessINS)        (BSTR bstrINSFilePath, /*[out, retval]*/ BOOL *pbRetVal);
	STDMETHOD (get_DefaultURL)    (/*[out, retval]*/ BSTR *pszURL);
	
    HRESULT   OnDraw(ATL_DRAWINFO& di);

private:
    CComBSTR    m_bstrINSFileName;
    HRESULT     MassageFile(LPCTSTR lpszFile);
    DWORD       RunExecutable(void);
    BOOL        KeepConnection(LPCTSTR lpszFile);
    DWORD       ImportCustomInfo(LPCTSTR lpszImportFile, LPTSTR lpszExecutable, DWORD cbExecutable, LPTSTR lpszArgument, DWORD cbArgument);
    DWORD       ImportFile(LPCTSTR lpszImportFile, LPCTSTR lpszSection, LPCTSTR lpszOutputFile);
    DWORD       ImportCustomFile(LPCTSTR lpszImportFile);
    DWORD       ImportBrandingInfo(LPCTSTR lpszFile, LPCTSTR lpszConnectoidName);
    // Client Config functions
    DWORD       ImportCustomDialer(LPRASENTRY lpRasEntry, LPCTSTR szFileName);
    LPCTSTR     StrToSubip (LPCTSTR szIPAddress, LPBYTE pVal);
    DWORD       StrToip (LPCTSTR szIPAddress, RASIPADDR *ipAddr);
    DWORD       ImportPhoneInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName);
    DWORD       ImportServerInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName);
    DWORD       ImportIPInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName);
    DWORD       ImportScriptFile(LPCTSTR lpszImportFile, LPTSTR szScriptFile, UINT cbScriptFile);
    DWORD       RnaValidateImportEntry (LPCTSTR szFileName);
    DWORD       ImportRasEntry (LPCTSTR szFileName, LPRASENTRY lpRasEntry);
    DWORD       ImportConnection (LPCTSTR szFileName, LPICONNECTION lpConn);
    DWORD       ImportMailAndNewsInfo(LPCTSTR lpszFile, BOOL fConnectPhone);
    HRESULT     WriteMailAndNewsKey(HKEY hKey, LPCTSTR lpszSection, LPCTSTR lpszValue,LPTSTR lpszBuff, DWORD dwBuffLen,LPCTSTR lpszSubKey,DWORD dwType, LPCTSTR lpszFile);
    BOOL        LoadExternalFunctions(void);
    DWORD       ReadClientInfo(LPCTSTR lpszFile, LPINETCLIENTINFO lpClientInfo, LPCLIENT_TABLE lpClientTable);
    BOOL        WantsExchangeInstalled(LPCTSTR lpszFile);
    BOOL        DisplayPassword(LPCTSTR lpszFile);
    DWORD       ImportClientInfo(LPCTSTR lpszFile, LPINETCLIENTINFO lpClientInfo);
    DWORD       ConfigureClient(HWND hwnd, LPCTSTR lpszFile, LPBOOL lpfNeedsRestart, LPBOOL lpfConnectoidCreated, BOOL fHookAutodial, LPTSTR szConnectoidName, DWORD dwConnectoidNameSize);
    HRESULT     PopulateNTAutodialAddress(LPCTSTR pszFileName, LPCTSTR pszEntryName);
    LPTSTR      MoveToNextAddress(LPTSTR lpsz);
    HRESULT     PreparePassword(LPTSTR szBuff, DWORD dwBuffLen);
    BOOL        FIsAthenaPresent();
    BOOL        FTurnOffBrowserDefaultChecking();
    BOOL        FRestoreBrowserDefaultChecking();
    void        SaveAutoDial(void);
    void        RestoreAutoDial(void);


    BOOL        OpenIcwRmindKey(CMcRegistry &reg);
    BOOL        ConfigureTrialReminder(LPCTSTR  lpszFile);

    BOOL        SetICWCompleted( DWORD dwCompleted );
    DWORD       CallSBSConfig(HWND hwnd, LPCTSTR lpszINSFile);
    BOOL        CallCMConfig(LPCTSTR lpszINSFile);
    
    
    DWORD       dw_ProcessFlags;        // Flags used to control INS processing
    TCHAR       m_szRunExecutable[MAX_PATH + 1];
    TCHAR       m_szRunArgument[MAX_PATH + 1];
    TCHAR       m_szCheckAssociations[20];
    TCHAR       m_szAutodialConnection[RAS_MaxEntryName + 1];
    TCHAR       m_szStartURL[MAX_PATH + 1];

    BOOL        m_fConnectionKilled;
    BOOL        m_fNeedsRestart;
    BOOL        m_fResforeDefCheck;
    BOOL        m_fAutodialSaved;
    BOOL        m_fAutodialEnabled;
    BOOL        m_fProxyEnabled;
    BOOL        m_bSilentMode;

    PFNINETCONFIGSYSTEM         m_lpfnInetConfigSystem;
    PFNINETGETPROXY             m_lpfnInetGetProxy;
    PFNINETCONFIGCLIENT         m_lpfnInetConfigClient;
    //PFNINETCONFIGCLIENTEX       m_lpfnInetConfigClientEx;
    PFNINETGETAUTODIAL          m_lpfnInetGetAutodial;
    PFNINETSETAUTODIAL          m_lpfnInetSetAutodial;
    PFNINETSETCLIENTINFO        m_lpfnInetSetClientInfo;
    PFNINETSETPROXY             m_lpfnInetSetProxy;

    PFNBRANDICW                 m_lpfnBrandICW;
    PFNRASSETAUTODIALENABLE     m_lpfnRasSetAutodialEnable;
	PFNRASSETAUTODIALADDRESS    m_lpfnRasSetAutodialAddress;


    HINSTANCE           m_hInetCfg;
    HINSTANCE           m_hBranding;
    HINSTANCE           m_hRAS;
    DWORD               m_dwBrandFlags;
};

#endif //__INSHANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\refdial.h ===
// RefDial.h : Declaration of the CRefDial

#ifndef __REFDIAL_H_
#define __REFDIAL_H_

// Defines used for Dialing
#define MAX_EXIT_RETRIES 10
#define MAX_RETIES 3
#define MAX_RASENTRYNAME 126

#define MAX_DIGITAL_PID     256

typedef DWORD (WINAPI *PFNRASGETCONNECTSTATUS)(HRASCONN,LPRASCONNSTATUS);

/////////////////////////////////////////////////////////////////////////////
// CRefDial
class ATL_NO_VTABLE CRefDial :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CRefDial,&CLSID_RefDial>,
    public CWindowImpl<CRefDial>,
    public IDispatchImpl<IRefDial, &IID_IRefDial, &LIBID_ICWHELPLib>,
    public IProvideClassInfo2Impl<&CLSID_RefDial, &DIID__RefDialEvents, &LIBID_ICWHELPLib>,
    public CProxy_RefDialEvents<CRefDial>,
    public IConnectionPointContainerImpl<CRefDial>
{
public:

    CRefDial()
    {
        m_szCurrentDUNFile[0]              = '\0';
        m_szLastDUNFile[0]                 = '\0';
        m_szEntryName[0]                   = '\0';
        m_szConnectoid[RAS_MaxEntryName]   = '\0';
        m_szConnectoid[0]                  = '\0';
        m_szPID[0]                         = '\0';
        m_szRefServerURL[0]                = '\0';
        m_hrDisplayableNumber              = ERROR_SUCCESS;
        m_dwCountryCode                    = 0;
        *m_szISPSupportNumber              = 0;
        m_RasStatusID                      = 0;
        m_dwTapiDev                        = 0xFFFFFFFF; // NOTE: 0 is a valid value
        m_dwWizardVersion                  = 0;
        m_lBrandingFlags                   = BRAND_DEFAULT;
        m_lCurrentModem                    = -1;
        m_lAllOffers                       = 0;
        m_PhoneNumberEnumidx               = 0;
        m_bDownloadHasBeenCanceled         = TRUE;  // This will get set to FALSE when a DOWNLOAD starts
        m_bQuitWizard                      = FALSE;
        m_bTryAgain                        = FALSE;
        m_bDisconnect                      = FALSE;
        m_bWaitingToHangup                 = FALSE;
        m_bModemOverride                   = FALSE; //allows campus net to be used.
        m_hThread                          = NULL;
        m_hrasconn                         = NULL;
        m_pSuggestInfo                     = NULL;
        m_rgpSuggestedAE                   = NULL;
        m_pszDisplayable                   = NULL;
        m_pcRNA                            = NULL;
        m_hRasDll                          = NULL;
        m_fpRasDial                        = NULL;
        m_fpRasGetEntryDialParams          = NULL;
        m_lpGatherInfo                     = new GATHERINFO; 
        m_reflpRasEntryBuff                = NULL;
        m_reflpRasDevInfoBuff              = NULL;
    }

    CRefDial::~CRefDial()
    {
        if (m_hThread)
        {
            //This is to fix a crashing bug where we unloaded this dll
            //before this thread figured out what had happened. 
            //Now we give it time to understand it's dead
            DWORD dwThreadResults = STILL_ACTIVE;
            while(dwThreadResults == STILL_ACTIVE)
            {
                GetExitCodeThread(m_hThread,&dwThreadResults);
                Sleep(500);
            }
        }    
        
        if (m_hrasconn)
            DoHangup();

        if (m_lpGatherInfo)
            delete(m_lpGatherInfo);
            
        if (m_pSuggestInfo)
        {
            GlobalFree(m_pSuggestInfo->rgpAccessEntry);
            
            GlobalFree(m_pSuggestInfo);
        }

        if( (m_pcRNA!=NULL) && (m_szConnectoid[0]!='\0') )
        {
            m_pcRNA->RasDeleteEntry(NULL,m_szConnectoid);
            delete m_pcRNA;
        }

        if(m_reflpRasEntryBuff)
        {
            GlobalFree(m_reflpRasEntryBuff);
            m_reflpRasEntryBuff = NULL;
        }
        if(m_reflpRasDevInfoBuff)
        {
            GlobalFree(m_reflpRasDevInfoBuff);
            m_reflpRasDevInfoBuff = NULL;
        }
    }

DECLARE_REGISTRY_RESOURCEID(IDR_REFDIAL)

BEGIN_COM_MAP(CRefDial) 
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRefDial)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CRefDial)
    CONNECTION_POINT_ENTRY(DIID__RefDialEvents)
END_CONNECTION_POINT_MAP()

BEGIN_PROPERTY_MAP(CRefDial)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CRefDial)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_DOWNLOAD_DONE, OnDownloadEvent)
    MESSAGE_HANDLER(WM_DOWNLOAD_PROGRESS, OnDownloadEvent)

    MESSAGE_HANDLER(WM_RASDIALEVENT, OnRasDialEvent)
    MESSAGE_HANDLER(m_unRasDialMsg, OnRasDialEvent)
ALT_MSG_MAP(1)
END_MSG_MAP()


// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = 0;
        return S_OK;
    }


    friend DWORD WINAPI DownloadThreadInit(LPVOID lpv);

// IRefDial
public:
    STDMETHOD(get_LoggingEndUrl)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_LoggingStartUrl)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ISPSupportPhoneNumber)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_ISPSupportPhoneNumber)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_CurrentModem)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_CurrentModem)(/*[in]*/ long newVal);
    STDMETHOD(get_BrandingFlags)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_BrandingFlags)(/*[in]*/ long newVal);
    STDMETHOD(get_HavePhoneBook)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(ValidatePhoneNumber)(/*[in]*/ BSTR bstrPhoneNumber, /*[out,retval]*/ BOOL *pbRetVal);
    STDMETHOD(ShowPhoneBook)(/*[in]*/ DWORD dwCountryCode, /*[in]*/ long newVal, /*[out,retval]*/ BOOL *pbRetVal);
    STDMETHOD(ShowDialingProperties)(/*[out,retval]*/ BOOL *pbRetVal);
    STDMETHOD(get_SupportNumber)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ISPSupportNumber)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ModemEnum_NumDevices)(/*[out, retval]*/ long *pVal);
    STDMETHOD(ModemEnum_Next)(/*[out, retval] */BSTR *pDeviceName);
    STDMETHOD(ModemEnum_Reset)();
    STDMETHOD(get_DialErrorMsg)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DialError)(/*[out, retval]*/ HRESULT *pVal);
    STDMETHOD(put_Redial)(/*[in]*/ BOOL newbVal);
    STDMETHOD(get_TryAgain)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_SignupURL)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_AutoConfigURL)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ISDNURL)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ISDNAutoConfigURL)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(FormReferralServerURL)(/*[out, retval]*/ BOOL *pbRetVal);
    STDMETHOD(get_SignedPID)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(ProcessSignedPID)(/*[out, retval]*/ BOOL *pbRetVal);
    void GetPID();
    STDMETHOD(DoInit)();
    STDMETHOD(DoHangup)();
    STDMETHOD(get_DialStatusString)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(DoOfferDownload)(/*[out, retval]*/ BOOL *pbRetVal);
    STDMETHOD(get_ProductCode)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_ProductCode)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_PromoCode)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_PromoCode)(/*[in]*/ BSTR newVal);
    STDMETHOD(put_OemCode)(/*[in]*/ BSTR newVal);
    STDMETHOD(put_AllOfferCode)(/*[in]*/ long newVal);
    STDMETHOD(get_URL)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DialPhoneNumber)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_DialPhoneNumber)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_UserPickNumber)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_QuitWizard)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(SetupForDialing)(BSTR bstrISPFile, DWORD dwCountry, BSTR bstrAreaCode, DWORD dwFlag,/*[out, retval] */BOOL *pbRetVal);
    STDMETHOD(get_DownloadStatusString)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(DoConnect)(/*[out, retval]*/ BOOL *pbRetVal);
    STDMETHOD(put_ModemOverride)(/*[in]*/ BOOL newbVal);

    HRESULT OnDraw(ATL_DRAWINFO& di);

    STDMETHOD(SelectedPhoneNumber)(/*[in]*/ long newVal, /*[out, retval]*/ BOOL * pbRetVal);
    STDMETHOD(PhoneNumberEnum_Reset)();
    STDMETHOD(PhoneNumberEnum_Next)(/*[out, retval]*/ BSTR *pNumber);
    STDMETHOD(get_PhoneNumberEnum_NumDevices)(/*[out, retval]*/ long * pVal);
    
    
    STDMETHOD(get_bIsISDNDevice)(/*[out, retval] */ BOOL *pVal);
    STDMETHOD(RemoveConnectoid)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_RasGetConnectStatus)(/*[out, retval]*/ BOOL *pVal);
    
    LRESULT OnRasDialEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDownloadEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDownloadDone(void);

    // Dialing service functions
    HRESULT GetDisplayableNumber();
    HRESULT Dial();
    BOOL FShouldRetry(HRESULT hrErr);

    DWORD MyRasDial(LPRASDIALEXTENSIONS,LPTSTR,LPRASDIALPARAMS,DWORD,LPVOID,LPHRASCONN);
    DWORD MyRasGetEntryDialParams(LPTSTR,LPRASDIALPARAMS,LPBOOL); 

    DWORD ReadConnectionInformation(void);
    DWORD FillGatherInfoStruct(LPGATHERINFO lpGatherInfo);
    HRESULT CreateEntryFromDUNFile(LPTSTR pszDunFile);
    HRESULT UserPickANumber(HWND hWnd,
                            LPGATHERINFO lpGatherInfo, 
                            PSUGGESTINFO lpSuggestInfo,
                            HINSTANCE hPHBKDll,
                            DWORD_PTR dwPhoneBook,
                            TCHAR *pszConnectoid, 
                            DWORD dwSize,
                            DWORD dwPhoneDisplayFlags);
    HRESULT SetupForRASDialing(LPGATHERINFO lpGatherInfo, 
                               HINSTANCE hPHBKDll,
                               DWORD_PTR *lpdwPhoneBook,
                               PSUGGESTINFO *ppSuggestInfo,
                               TCHAR *pszConnectoid, 
                               BOOL FAR *bConnectiodCreated);
    HRESULT SetupConnectoid(PSUGGESTINFO pSuggestInfo, int irc, 
                            TCHAR *pszConnectoid, DWORD dwSize, BOOL * pbSuccess);
    HRESULT FormURL(void);
    
    HRESULT MyRasGetEntryProperties(LPTSTR lpszPhonebookFile,
                                        LPTSTR lpszPhonebookEntry, 
                                        LPRASENTRY *lplpRasEntryBuff,
                                        LPDWORD lpdwRasEntryBuffSize,
                                        LPRASDEVINFO *lplpRasDevInfoBuff,
                                        LPDWORD lpdwRasDevInfoBuffSize);

    // Dialing service members
    UINT            m_unRasDialMsg;
    DWORD           m_dwTapiDev;
    HRASCONN        m_hrasconn;
    TCHAR           m_szConnectoid[RAS_MaxEntryName+1];
    HANDLE          m_hThread;
    DWORD           m_dwThreadID;
    HINSTANCE       m_hRasDll;
    FARPROC         m_fpRasDial;
    FARPROC         m_fpRasGetEntryDialParams;
    LPGATHERINFO    m_pGI;
    TCHAR           m_szUrl[INTERNET_MAX_URL_LENGTH];               // Download thread

    DWORD_PTR       m_dwDownLoad;           // Download thread
    HLINEAPP        m_hLineApp;
    DWORD           m_dwAPIVersion;
    LPTSTR          m_pszDisplayable;
    RNAAPI          *m_pcRNA;
    TCHAR           m_szPhoneNumber[256];
    BOOL            m_bDialAsIs;
    UINT            m_uiRetry;
    CComBSTR        m_bstrISPFile;
    TCHAR           m_szCurrentDUNFile[MAX_PATH];
    TCHAR           m_szLastDUNFile[MAX_PATH];
    TCHAR           m_szEntryName[RAS_MaxEntryName+1];
    TCHAR           m_szISPSupportNumber[RAS_MaxAreaCode + RAS_MaxPhoneNumber +1];

//  CBusyMessages   m_objBusyMessages;
    BOOL            m_bDownloadHasBeenCanceled;
    BOOL            m_bDisconnect;
    BOOL            m_bWaitingToHangup;

    LPGATHERINFO    m_lpGatherInfo;
    //
    // Used for Phone book look-up
    //
    PSUGGESTINFO    m_pSuggestInfo;
    PACCESSENTRY    *m_rgpSuggestedAE;

    CISPImport      m_ISPImport;      // Import an ISP file

    int             m_RasStatusID;
    int             m_DownloadStatusID;

    TCHAR           m_szRefServerURL[INTERNET_MAX_URL_LENGTH];
    LPRASENTRY      m_reflpRasEntryBuff;
    LPRASDEVINFO    m_reflpRasDevInfoBuff;
 

private:
    BOOL IsSBCSString( TCHAR *sz );
    void GetISPFileSettings(LPTSTR lpszFile);
    
    BOOL m_bModemOverride;

protected:
    BOOL            m_bTryAgain;
    BOOL            m_bQuitWizard;
    BOOL            m_bUserPickNumber;
    BOOL            m_bRedial;
    HRESULT         m_hrDisplayableNumber;
    HRESULT         m_hrDialErr;

    CComBSTR        m_bstrPromoCode;
    CComBSTR        m_bstrProductCode;
    TCHAR           m_szOEM[MAX_OEMNAME];
    CComBSTR        m_bstrSignedPID;
    CComBSTR        m_bstrSupportNumber;
    CComBSTR        m_bstrLoggingStartUrl;
    CComBSTR        m_bstrLoggingEndUrl;

    long            m_lAllOffers;
    CEnumModem      m_emModemEnum;
    CSupport        m_SupportInfo;
    DWORD           m_dwCountryCode;

    long            m_lBrandingFlags;
    long            m_lCurrentModem;
    // Version of the wizard HTML.  Sent to RefServer
    DWORD           m_dwWizardVersion;
    TCHAR           m_szPID[(MAX_DIGITAL_PID * 2) + 1];
    
    void CRefDial::ShowCredits();
    
    long            m_PhoneNumberEnumidx;
};

#endif //__REFDIAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\mcreg.cpp ===
#define  STRICT
#include "stdafx.h"

//---------------------------------------------------------------------------

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//---------------------------------------------------------------------------
// ctor
//---------------------------------------------------------------------------
CMcRegistry::CMcRegistry()
 :	m_hkey(NULL)
{
}

//---------------------------------------------------------------------------
// dtor
//---------------------------------------------------------------------------
CMcRegistry::~CMcRegistry()
{
	if (m_hkey)
	{
		CloseKey();
	}
}


//---------------------------------------------------------------------------
// OpenKey
//---------------------------------------------------------------------------
bool
CMcRegistry::OpenKey(
	HKEY hkeyStart, LPCTSTR strKey, REGSAM sam /* = KEY_READ | KEY_WRITE */)
{
	long lErr = ::RegOpenKeyEx(hkeyStart, strKey, 0, sam, &m_hkey);
	if (ERROR_SUCCESS != lErr)
	{
		m_hkey = NULL;
	}

	return ERROR_SUCCESS == lErr;
}


//---------------------------------------------------------------------------
// CreateKey
//---------------------------------------------------------------------------
bool
CMcRegistry::CreateKey(HKEY hkeyStart, LPCTSTR strKey)
{
	// You shouldn't have opened now.
	if (m_hkey)
	{
		_ASSERT(!m_hkey);
		return false;
	}

	long lErr = ::RegCreateKey(hkeyStart, strKey, &m_hkey);
	if (ERROR_SUCCESS != lErr)
	{
		m_hkey = NULL;
		_ASSERT(false);
	}

	return ERROR_SUCCESS == lErr;
}


//---------------------------------------------------------------------------
// CloseKey
//---------------------------------------------------------------------------
bool
CMcRegistry::CloseKey()
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	long lErr = ::RegCloseKey(m_hkey);
	if (ERROR_SUCCESS != lErr)
	{
		m_hkey = NULL;
		_ASSERT(false);
	}

	return ERROR_SUCCESS == lErr;
	
}


//---------------------------------------------------------------------------
// GetValue
//---------------------------------------------------------------------------
bool
CMcRegistry::GetValue(LPCTSTR strValue, LPTSTR strData, ULONG nBufferSize)
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	DWORD dwType;
	ULONG cbData = nBufferSize;

	long lErr = ::RegQueryValueEx(
		m_hkey, strValue, NULL, &dwType,
		reinterpret_cast<PBYTE>(strData), &cbData);

	return ERROR_SUCCESS == lErr && REG_SZ == dwType;
}


//---------------------------------------------------------------------------
// GetValue
//---------------------------------------------------------------------------
bool
CMcRegistry::GetValue(LPCTSTR strValue, DWORD& rdw)
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	DWORD dwType;
	ULONG cbData = sizeof(rdw);
	long lErr = ::RegQueryValueEx(
		m_hkey, strValue, NULL, &dwType,
		reinterpret_cast<PBYTE>(&rdw), &cbData);

	return ERROR_SUCCESS == lErr && REG_DWORD == dwType;
}


//---------------------------------------------------------------------------
// SetValue
//---------------------------------------------------------------------------
bool
CMcRegistry::SetValue(LPCTSTR strValue, LPCTSTR strData)
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	long lErr = ::RegSetValueEx(
		m_hkey, strValue, 0, REG_SZ, 
		reinterpret_cast<const BYTE*>(strData), sizeof(TCHAR)*(lstrlen(strData) + 1));

	if (ERROR_SUCCESS != lErr)
	{
		_ASSERT(false);
	}

	return ERROR_SUCCESS == lErr;
}


//---------------------------------------------------------------------------
// SetValue
//---------------------------------------------------------------------------
bool
CMcRegistry::SetValue(LPCTSTR strValue, DWORD rdw)
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	long lErr = ::RegSetValueEx(
		m_hkey, strValue, 0, REG_DWORD,
		reinterpret_cast<PBYTE>(&rdw), sizeof(rdw));

	if (ERROR_SUCCESS != lErr)
	{
		_ASSERT(false);
	}

	return ERROR_SUCCESS == lErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\refdial.cpp ===
//**********************************************************************
// File name: RefDial.cpp
//
//      Implementation of CRefDial
//
// Functions:
//
// Copyright (c) 1992 - 1999 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "stdafx.h"
#include "icwhelp.h"
#include "RefDial.h"
#include "appdefs.h"
#include <regstr.h>

#include <urlmon.h>
#include <mshtmhst.h>
const TCHAR  c_szCreditsMagicNum[] =    TEXT("1 425 555 1212");

const TCHAR c_szRegStrValDigitalPID[] = TEXT("DigitalProductId");
const TCHAR c_szSignedPIDFName[] =      TEXT("signed.pid");

const TCHAR c_szRASProfiles[] =         TEXT("RemoteAccess\\Profile");
const TCHAR c_szProxyEnable[] =         TEXT("ProxyEnable");

TCHAR g_BINTOHEXLookup[16] = 
{
    TEXT('0'),
    TEXT('1'),
    TEXT('2'),
    TEXT('3'),
    TEXT('4'),
    TEXT('5'),
    TEXT('6'),
    TEXT('7'),
    TEXT('8'),
    TEXT('9'),
    TEXT('A'),
    TEXT('B'),
    TEXT('C'),
    TEXT('D'),
    TEXT('E'),
    TEXT('F')
};

typedef DWORD (WINAPI * GETICWCONNVER) ();
GETICWCONNVER  lpfnGetIcwconnVer;

HWND g_hwndRNAApp = NULL;
    
/////////////////////////////////////////////////////////////////////////////
// CRefDial

HRESULT CRefDial::OnDraw(ATL_DRAWINFO& di)
{
    return S_OK;
}

LRESULT CRefDial::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Register the RASDIALEVENT message
    m_unRasDialMsg = RegisterWindowMessageA( RASDIALEVENT );
    if (m_unRasDialMsg == 0)
    {
        m_unRasDialMsg = WM_RASDIALEVENT;
    }
    
    // Make sure the window is hidden
    ShowWindow(SW_HIDE);
    return 0;
}

LRESULT CRefDial::OnDownloadEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    USES_CONVERSION;
    if (uMsg == WM_DOWNLOAD_DONE)
    {
        DWORD   dwThreadResults = STILL_ACTIVE;
        int     iRetries = 0;

        // We keep the RAS connection open here, it must be explicitly 
        // close by the container (a call DoHangup)
        // This code will wait until the download thread exists, and
        // collect the download status.
        do {
            if (!GetExitCodeThread(m_hThread,&dwThreadResults))
            {
                AssertMsg(0,TEXT("CONNECT:GetExitCodeThread failed.\n"));
            }

            iRetries++;
            if (dwThreadResults  == STILL_ACTIVE) 
                Sleep(500);
        } while (dwThreadResults == STILL_ACTIVE && iRetries < MAX_EXIT_RETRIES);  

        
        // See if there is an URL to pass to the container
        BSTR    bstrURL;
        if (m_szRefServerURL[0] != TEXT('\0'))
            bstrURL = (BSTR)A2BSTR(m_szRefServerURL);
        else
            bstrURL = NULL;

        m_RasStatusID    = IDS_DOWNLOAD_COMPLETE;
        Fire_DownloadComplete(bstrURL, dwThreadResults);
        
        // The download is complete now, so we reset this to TRUE, so the RAS
        // event handler does not get confused
        m_bDownloadHasBeenCanceled = TRUE;
        
        // Free any memory allocated above during the conversion
        SysFreeString(bstrURL);

    }
    else if (uMsg == WM_DOWNLOAD_PROGRESS)
    {
        // Fire a progress event to the container
        m_RasStatusID = IDS_DOWNLOADING;
        Fire_DownloadProgress((long)wParam);
    }
    return 0;
}

static const TCHAR szRnaAppWindowClass[] = _T("#32770");    // hard coded dialog class name

BOOL NeedZapperEx(void)
{
    OSVERSIONINFO oi;
    memset(&oi, 0, sizeof(oi));
    oi.dwOSVersionInfoSize = sizeof(oi);

    if( GetVersionEx(&oi) && 
       (oi.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS) &&
       (oi.dwMajorVersion==4) &&
       (oi.dwMinorVersion==0) &&
       (LOWORD(oi.dwBuildNumber) <= 1070) )
            return TRUE;
    else
            return FALSE;
}

void GetRNAWindowEx()
{
    TCHAR szTitle[MAX_PATH] = TEXT("\0");

    if (!LoadString(_Module.GetModuleInstance(), IDS_CONNECTED, szTitle, ARRAYSIZE(szTitle)))
        lstrcpy(szTitle , _T("Connected To "));

    g_hwndRNAApp = FindWindow(szRnaAppWindowClass, szTitle);
}

BOOL MinimizeRNAWindowEx()
{
    if(g_hwndRNAApp)
    {
        // Get the main frame window's style
        LONG window_style = GetWindowLong(g_hwndRNAApp, GWL_STYLE);

        //Remove the system menu from the window's style
        window_style |= WS_MINIMIZE;
        
        //set the style attribute of the main frame window
        SetWindowLong(g_hwndRNAApp, GWL_STYLE, window_style);

        ShowWindow(g_hwndRNAApp, SW_MINIMIZE);

        return TRUE;
    }
    return FALSE;
}

LRESULT CRefDial::OnRasDialEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    RNAAPI* pcRNA;

    TraceMsg(TF_GENERAL, TEXT("ICWHELP: Ras event %u error code (%ld)\n"),wParam,lParam);

    TCHAR dzRasError[10];
    wsprintf(dzRasError,TEXT("%d %d"),wParam,lParam);
    RegSetValue(HKEY_LOCAL_MACHINE,TEXT("Software\\Microsoft\\iSignUp"),REG_SZ,dzRasError,lstrlen(dzRasError)+1);

    // In NT4, it gives wParma with error code in lParam rather than a
    // actual wParam message
    if (lParam)
    {
         wParam = RASCS_Disconnected;
    }

    m_RasStatusID = 0;
    switch(wParam)
    {
        case RASCS_OpenPort:
            m_RasStatusID    = IDS_RAS_OPENPORT;
            break;
        case RASCS_PortOpened:
            m_RasStatusID    = IDS_RAS_PORTOPENED;
            break;
        case RASCS_ConnectDevice:
            m_RasStatusID    = IDS_RAS_DIALING;
            break;
        case RASCS_DeviceConnected:
            m_RasStatusID    = IDS_RAS_CONNECTED;
            break;
        case RASCS_AllDevicesConnected:
            m_RasStatusID    = IDS_RAS_CONNECTED;
            break; 
        case RASCS_Authenticate:
            m_RasStatusID    = IDS_RAS_CONNECTING;
            break;
        case RASCS_StartAuthentication:
        case RASCS_LogonNetwork:
            m_RasStatusID    = IDS_RAS_LOCATING;
            break;  
        case RASCS_Connected:
        {
            m_RasStatusID = IDS_RAS_CONNECTED;

            //
            // Hide RNA window on Win95 retail
            //
            if (NeedZapperEx())
                GetRNAWindowEx();
            
            break;
        }
        case RASCS_Disconnected:
            // Normandy 13184 - ChrisK 1-9-97
            m_RasStatusID    = IDS_RAS_HANGINGUP;
            IF_NTONLY
                // jmazner Normandy #5603 ported from ChrisK's fix in icwdial
                // There is a possibility that we will get multiple disconnects in NT
                // and we only want to handle the first one. Note: the flag is reset
                // in the INITIALIZE event, so we should handle 1 disconnect per instance
                // of the dialog.
                if (m_bDisconnect)
                    break;
                else
                    m_bDisconnect = TRUE;
            ENDIF_NTONLY
            //
            // If we are in the middle of a download, cancel the it!
            //
                //
            // ChrisK 5240 Olympus
            // Only the thread that creates the dwDownload should invalidate it
            // so we need another method to track if the cancel button has been
            // pressed.
            //
            if (!m_bDownloadHasBeenCanceled)
            {
                HINSTANCE hDLDLL = LoadLibrary(DOWNLOAD_LIBRARY);
                if (hDLDLL)
                {
                    FARPROC fp = GetProcAddress(hDLDLL,DOWNLOADCANCEL);
                    if(fp)
                        ((PFNDOWNLOADCANCEL)fp)(m_dwDownLoad);
                    FreeLibrary(hDLDLL);
                    hDLDLL = NULL;
                    m_bDownloadHasBeenCanceled = TRUE;
                }
            }

            // If we get a disconnected status from the RAS server, then
            // hangup the modem here
            if (m_hrasconn)
            {  
                pcRNA = new RNAAPI;
                if (pcRNA)
                {
                    pcRNA->RasHangUp(m_hrasconn);
                    m_hrasconn = NULL;
                    delete pcRNA;
                    pcRNA = NULL;
                }
            }
            break;
    }

    // Fire the event to the container.
    Fire_RasDialStatus((USHORT)wParam);

    // If we are connected then fire an event telling the container
    // that we are ready
    if (wParam == RASCS_Connected)
        Fire_RasConnectComplete(TRUE);
    else if (wParam == RASCS_Disconnected)
    {
        m_hrDialErr = (HRESULT)lParam;
        Fire_RasConnectComplete(FALSE);
    }

    return 0;
}

STDMETHODIMP CRefDial::get_DownloadStatusString(BSTR * pVal)
{
    USES_CONVERSION;
    if (pVal == NULL)
         return E_POINTER;
    if (m_DownloadStatusID)
        *pVal = (BSTR)A2BSTR(GetSz((USHORT)m_DownloadStatusID));
    else
        *pVal = (BSTR)A2BSTR(TEXT(""));

    return S_OK;
}

/******************************************************************************
// These functions come from the existing ICW code and are use to setup a 
// connectiod to the referral server, dial it, and perform the download.
******************************************************************************/

//+----------------------------------------------------------------------------
//    Function:    ReadConnectionInformation
//
//    Synopsis:    Read the contents from the ISP file
//
//    Arguments:    none
//
//    Returns:    error value - ERROR_SUCCESS = succes
//
//    History:    1/9/98      DONALDM     Adapted from ICW 1.x
//-----------------------------------------------------------------------------
DWORD CRefDial::ReadConnectionInformation(void)
{
    USES_CONVERSION;
    DWORD       hr;
    TCHAR       szUserName[UNLEN+1];
    TCHAR       szPassword[PWLEN+1];
    LPTSTR      pszTemp;
    BOOL        bReboot;
    LPTSTR      lpRunOnceCmd;
            
    bReboot = FALSE;
    lpRunOnceCmd = NULL;


    //
    // Get the name of DUN file from ISP file, if there is one.
    //
    TCHAR pszDunFile[MAX_PATH];
#ifdef UNICODE
    hr = GetDataFromISPFile(m_bstrISPFile,INF_SECTION_ISPINFO, INF_DUN_FILE, pszDunFile,MAX_PATH);
#else
    hr = GetDataFromISPFile(OLE2A(m_bstrISPFile),INF_SECTION_ISPINFO, INF_DUN_FILE, pszDunFile,MAX_PATH);
#endif
    if (ERROR_SUCCESS == hr) 
    {
        //
        // Get the full path to the DUN File
        //
        TCHAR    szTempPath[MAX_PATH];
        lstrcpy(szTempPath,pszDunFile);
        if (!(hr = SearchPath(NULL,szTempPath,NULL,MAX_PATH,pszDunFile,&pszTemp)))
        {
            ErrorMsg1(m_hWnd, IDS_CANTREADTHISFILE, CharUpper(pszDunFile));
            goto ReadConnectionInformationExit;
        } 

        //
        // save current DUN file name in global (for ourself)
        //
        lstrcpy(m_szCurrentDUNFile, pszDunFile);
    }
    
    //
    // Read the DUN/ISP file File
    //
    hr = m_ISPImport.ImportConnection(m_szCurrentDUNFile[0] != '\0' ? m_szCurrentDUNFile : OLE2A(m_bstrISPFile), 
                                      m_szISPSupportNumber,
                                      m_szEntryName,
                                      szUserName, 
                                      szPassword, 
                                      &bReboot);

    if ((VER_PLATFORM_WIN32_NT == g_dwPlatform) && (ERROR_INVALID_PARAMETER == hr))
    {
        // If there are only dial-out entries configured on NT, we get
        // ERROR_INVALID_PARAMETER returned from RasSetEntryProperties,
        // which InetConfigClient returns to ImportConnection which
        // returns it to us.  If we get this error, we want to display
        // a different error instructing the user to configure a modem
        // for dial-out.
        MessageBox(GetSz(IDS_NODIALOUT),
                   GetSz(IDS_TITLE),
                   MB_ICONERROR | MB_OK | MB_APPLMODAL);
        goto ReadConnectionInformationExit;
    }
    else
    if (ERROR_CANNOT_FIND_PHONEBOOK_ENTRY == hr)
    {
        //
        // The disk is full, or something is wrong with the
        // phone book file
        MessageBox(GetSz(IDS_NOPHONEENTRY),
                   GetSz(IDS_TITLE),
                   MB_ICONERROR | MB_OK | MB_APPLMODAL);
        goto ReadConnectionInformationExit;
    }
    else if (hr == ERROR_CANCELLED)
    {
        TraceMsg(TF_GENERAL, TEXT("ICWHELP: User cancelled, quitting.\n"));
        goto ReadConnectionInformationExit;
    }
    else if (hr == ERROR_RETRY)
    {
        TraceMsg(TF_GENERAL, TEXT("ICWHELP: User retrying.\n"));
        goto ReadConnectionInformationExit;
    }
    else if (hr != ERROR_SUCCESS) 
    {
        ErrorMsg1(m_hWnd, IDS_CANTREADTHISFILE, CharUpper(pszDunFile));
        goto ReadConnectionInformationExit;
    } 
    else 
    {

        //
        // place the name of the connectoid in the registry
        //
        if (ERROR_SUCCESS != (hr = StoreInSignUpReg((LPBYTE)m_szEntryName, lstrlen(m_szEntryName)+1, REG_SZ, RASENTRYVALUENAME)))
        {
            MsgBox(IDS_CANTSAVEKEY,MB_MYERROR);
            goto ReadConnectionInformationExit;
        }
    }

    AssertMsg(!bReboot, TEXT("ICWHELP: We should never reboot here.\r\n"));
ReadConnectionInformationExit:
    return hr;
}

HRESULT CRefDial::GetDisplayableNumber()
{
    HRESULT                 hr = ERROR_SUCCESS;
    LPRASENTRY              lpRasEntry = NULL;
    LPRASDEVINFO            lpRasDevInfo = NULL;
    DWORD                   dwRasEntrySize = 0;
    DWORD                   dwRasDevInfoSize = 0;
    RNAAPI                  *pcRNA = NULL;
    LPLINETRANSLATEOUTPUT   lpOutput1 = NULL;

    DWORD dwNumDev;
    LPLINETRANSLATEOUTPUT lpOutput2;
    LPLINEEXTENSIONID lpExtensionID = NULL;
    
    //
    // Get phone number from connectoid
    //
    hr = MyRasGetEntryProperties(NULL,
                                m_szConnectoid,
                                &lpRasEntry,
                                &dwRasEntrySize,
                                &lpRasDevInfo,
                                &dwRasDevInfoSize);


    if (hr != ERROR_SUCCESS || NULL == lpRasEntry)
    {
        goto GetDisplayableNumberExit;
    }

    //
    // If this is a dial as is number, just get it from the structure
    //
    m_bDialAsIs = !(lpRasEntry->dwfOptions & RASEO_UseCountryAndAreaCodes);
    if (m_bDialAsIs)
    {
        if (m_pszDisplayable) GlobalFree(m_pszDisplayable);
        m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, sizeof(TCHAR)*(lstrlen(lpRasEntry->szLocalPhoneNumber)+1));
        if (!m_pszDisplayable)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto GetDisplayableNumberExit;
        }
        lstrcpy(m_szPhoneNumber, lpRasEntry->szLocalPhoneNumber);
        lstrcpy(m_pszDisplayable, lpRasEntry->szLocalPhoneNumber);
        TCHAR szAreaCode[MAX_AREACODE+1];
        TCHAR szCountryCode[8];
        if (SUCCEEDED(tapiGetLocationInfo(szCountryCode,szAreaCode)))
        {
            if (szCountryCode[0] != '\0')
                m_dwCountryCode = _ttoi(szCountryCode);
            else    
                m_dwCountryCode = 1;
        }
        else
        {
            m_dwCountryCode = 1;
            
        }

    }
    else
    {
        //
        // If there is no area code, don't use parentheses
        //
        if (lpRasEntry->szAreaCode[0])
            wsprintf(m_szPhoneNumber,TEXT("+%lu (%s) %s\0"),lpRasEntry->dwCountryCode,
                        lpRasEntry->szAreaCode,lpRasEntry->szLocalPhoneNumber);
        else
            wsprintf(m_szPhoneNumber,TEXT("+%lu %s\0"),lpRasEntry->dwCountryCode,
                        lpRasEntry->szLocalPhoneNumber);
        
     
        //
        //  Initialize TAPIness
        //
        dwNumDev = 0;
        hr = lineInitialize(&m_hLineApp,_Module.GetModuleInstance(),LineCallback,(LPSTR)NULL,&dwNumDev);

        if (hr != ERROR_SUCCESS)
            goto GetDisplayableNumberExit;

        lpExtensionID = (LPLINEEXTENSIONID )GlobalAlloc(GPTR,sizeof(LINEEXTENSIONID));
        if (!lpExtensionID)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto GetDisplayableNumberExit;
        }

        if (m_dwTapiDev == 0xFFFFFFFF)
        {
                m_dwTapiDev = 0;
        }

        //
        // ChrisK Olympus 5558 6/11/97
        // PPTP device will choke the version negotiating
        //
        do {
            hr = lineNegotiateAPIVersion(m_hLineApp, m_dwTapiDev, 0x00010004, 0x00010004,
                &m_dwAPIVersion, lpExtensionID);

        } while (hr != ERROR_SUCCESS && m_dwTapiDev++ < dwNumDev - 1);

        if (m_dwTapiDev >= dwNumDev)
        {
            m_dwTapiDev = 0;
        }

        // ditch it since we don't use it
        //
        if (lpExtensionID) GlobalFree(lpExtensionID);
        lpExtensionID = NULL;
        if (hr != ERROR_SUCCESS)
            goto GetDisplayableNumberExit;

        // Format the phone number
        //

        lpOutput1 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(GPTR,sizeof(LINETRANSLATEOUTPUT));
        if (!lpOutput1)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto GetDisplayableNumberExit;
        }
        lpOutput1->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

        // Turn the canonical form into the "displayable" form
        //

        hr = lineTranslateAddress(m_hLineApp,m_dwTapiDev,m_dwAPIVersion,
                                    m_szPhoneNumber,0,
                                    LINETRANSLATEOPTION_CANCELCALLWAITING,
                                    lpOutput1);

        if (hr != ERROR_SUCCESS || (lpOutput1->dwNeededSize != lpOutput1->dwTotalSize))
        {
            lpOutput2 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(GPTR, (size_t)lpOutput1->dwNeededSize);
            if (!lpOutput2)
            {
                hr = ERROR_NOT_ENOUGH_MEMORY;
                goto GetDisplayableNumberExit;
            }
            lpOutput2->dwTotalSize = lpOutput1->dwNeededSize;
            GlobalFree(lpOutput1);
            lpOutput1 = lpOutput2;
            lpOutput2 = NULL;
            hr = lineTranslateAddress(m_hLineApp,m_dwTapiDev,
                                        m_dwAPIVersion,m_szPhoneNumber,0,
                                        LINETRANSLATEOPTION_CANCELCALLWAITING,
                                        lpOutput1);
        }

        if (hr != ERROR_SUCCESS)
        {
            goto GetDisplayableNumberExit;
        }

        m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, ((size_t)lpOutput1->dwDisplayableStringSize+1));
        if (!m_pszDisplayable)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto GetDisplayableNumberExit;
        }

        lstrcpyn(m_pszDisplayable,
                    (LPTSTR)&((LPBYTE)lpOutput1)[lpOutput1->dwDisplayableStringOffset],
                    (int)lpOutput1->dwDisplayableStringSize);

        TCHAR szAreaCode[MAX_AREACODE+1];
        TCHAR szCountryCode[8];
        if (SUCCEEDED(tapiGetLocationInfo(szCountryCode,szAreaCode)))
        {
            if (szCountryCode[0] != '\0')
                m_dwCountryCode = _ttoi(szCountryCode);
            else    
                m_dwCountryCode = 1;
        }
        else
        {
            m_dwCountryCode = 1;
            
        }

    }

GetDisplayableNumberExit:

    if (lpOutput1) GlobalFree(lpOutput1);
    if (m_hLineApp) lineShutdown(m_hLineApp);
    return hr;
}

typedef DWORD (WINAPI* PFNRASDIALA)(LPRASDIALEXTENSIONS,LPSTR,LPRASDIALPARAMSA,DWORD,LPVOID,LPHRASCONN);
DWORD CRefDial::MyRasDial
(
    LPRASDIALEXTENSIONS  lpRasDialExtensions,
    LPTSTR  lpszPhonebook,
    LPRASDIALPARAMS  lpRasDialParams,
    DWORD  dwNotifierType,
    LPVOID  lpvNotifier,
    LPHRASCONN  lphRasConn
)
{
    HRESULT hr;
    
    if (!m_hRasDll)
        m_hRasDll = LoadLibrary(TEXT("RasApi32.dll"));

    if (!m_hRasDll)
    {
        hr = GetLastError();
        goto MyRasDialExit;
    }

    if (m_hRasDll && !m_fpRasDial)
        m_fpRasDial = GetProcAddress(m_hRasDll,"RasDialA");

    if (!m_fpRasDial)
    {
        hr = GetLastError();
        goto MyRasDialExit;
    }

    if (m_fpRasDial)
    {
#ifdef UNICODE
        // RasDialW version always fails to connect.
        // I don't know why. So I want to call RasDialA even if this is UNICODE build.
        RASDIALPARAMSA RasDialParams;
        RasDialParams.dwSize = sizeof(RASDIALPARAMSA);
        wcstombs(RasDialParams.szEntryName, lpRasDialParams->szEntryName, RAS_MaxEntryName+1);
        wcstombs(RasDialParams.szPhoneNumber, lpRasDialParams->szPhoneNumber, RAS_MaxPhoneNumber+1);
        wcstombs(RasDialParams.szCallbackNumber, lpRasDialParams->szCallbackNumber, RAS_MaxCallbackNumber+1);
        wcstombs(RasDialParams.szUserName, lpRasDialParams->szUserName, UNLEN+1);
        wcstombs(RasDialParams.szPassword, lpRasDialParams->szPassword, PWLEN+1);
        wcstombs(RasDialParams.szDomain, lpRasDialParams->szDomain, DNLEN+1);

        hr = ((PFNRASDIALA)m_fpRasDial)(lpRasDialExtensions,NULL,
                                            &RasDialParams,
                                            dwNotifierType, 
                                            (LPVOID) lpvNotifier,
                                            lphRasConn);
#else
        hr = ((PFNRASDIAL)m_fpRasDial)(lpRasDialExtensions,lpszPhonebook,
                                            lpRasDialParams,
                                            dwNotifierType, 
                                            (LPVOID) lpvNotifier,
                                            lphRasConn);
#endif
        Assert(hr == ERROR_SUCCESS);
    }
   
MyRasDialExit:
    return hr;
}



DWORD CRefDial::MyRasGetEntryDialParams
(
    LPTSTR  lpszPhonebook,
    LPRASDIALPARAMS  lprasdialparams,
    LPBOOL  lpfPassword
)
{
    HRESULT hr;

    if (!m_hRasDll)
        m_hRasDll = LoadLibrary(TEXT("RasApi32.dll"));

    if (!m_hRasDll)
    {
        hr = GetLastError();
        goto MyRasGetEntryDialParamsExit;
    }

    if (m_hRasDll && !m_fpRasGetEntryDialParams)
#ifdef UNICODE
        m_fpRasGetEntryDialParams = GetProcAddress(m_hRasDll,"RasGetEntryDialParamsW");
#else
        m_fpRasGetEntryDialParams = GetProcAddress(m_hRasDll,"RasGetEntryDialParamsA");
#endif

    if (!m_fpRasGetEntryDialParams)
    {
        hr = GetLastError();
        goto MyRasGetEntryDialParamsExit;
    }

    if (m_fpRasGetEntryDialParams)
        hr = ((PFNRASGETENTRYDIALPARAMS)m_fpRasGetEntryDialParams)(lpszPhonebook,lprasdialparams,lpfPassword);

MyRasGetEntryDialParamsExit:
    return hr;
}


BOOL CRefDial::FShouldRetry(HRESULT hrErr)
{
    BOOL bRC;

    m_uiRetry++;

    if (hrErr == ERROR_LINE_BUSY ||
        hrErr == ERROR_VOICE_ANSWER ||
        hrErr == ERROR_NO_ANSWER ||
        hrErr == ERROR_NO_CARRIER ||
        hrErr == ERROR_AUTHENTICATION_FAILURE ||
        hrErr == ERROR_PPP_TIMEOUT ||
        hrErr == ERROR_REMOTE_DISCONNECTION ||
        hrErr == ERROR_AUTH_INTERNAL ||
        hrErr == ERROR_PROTOCOL_NOT_CONFIGURED ||
        hrErr == ERROR_PPP_NO_PROTOCOLS_CONFIGURED)
    {
        bRC = TRUE;
    } else {
        bRC = FALSE;
    }

    bRC = bRC && m_uiRetry < MAX_RETIES;

    return bRC;
}


// This function will perform the actual dialing
STDMETHODIMP CRefDial::DoConnect(BOOL * pbRetVal)
{
    USES_CONVERSION;

    TCHAR               szPassword[PWLEN+2];
    LPRASDIALPARAMS     lpRasDialParams = NULL;
    LPRASDIALEXTENSIONS lpRasDialExtentions = NULL;
    HRESULT             hr = ERROR_SUCCESS;
    BOOL                bPW;

    // Initialize the dial error member
    m_hrDialErr = ERROR_SUCCESS;    
    
    // Get connectoid information
    //
    lpRasDialParams = (LPRASDIALPARAMS)GlobalAlloc(GPTR,sizeof(RASDIALPARAMS));
    if (!lpRasDialParams)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto DialExit;
    }
    lpRasDialParams->dwSize = sizeof(RASDIALPARAMS);
    lstrcpyn(lpRasDialParams->szEntryName,m_szConnectoid,ARRAYSIZE(lpRasDialParams->szEntryName));
    bPW = FALSE;
    hr = MyRasGetEntryDialParams(NULL,lpRasDialParams,&bPW);
    if (hr != ERROR_SUCCESS)
    {
        goto DialExit;
    }

    //
    // This is only used on WINNT
    //
    lpRasDialExtentions = (LPRASDIALEXTENSIONS)GlobalAlloc(GPTR,sizeof(RASDIALEXTENSIONS));
    if (lpRasDialExtentions)
    {
        lpRasDialExtentions->dwSize = sizeof(RASDIALEXTENSIONS);
        lpRasDialExtentions->dwfOptions = RDEOPT_UsePrefixSuffix;
    }


    //
    // Add the user's password
    //
    szPassword[0] = 0;
    GetPrivateProfileString(INFFILE_USER_SECTION,
                            INFFILE_PASSWORD,
                            NULLSZ,
                            szPassword,
                            PWLEN + 1, 
                            m_szCurrentDUNFile[0] != '\0'? m_szCurrentDUNFile : OLE2A(m_bstrISPFile));

    if(szPassword[0])
        lstrcpy(lpRasDialParams->szPassword, szPassword);
                                        
    //
    // Dial connectoid
    //
    
    //Fix for redialing, on win9x we need to make sure we "hangup"
    //and free the rna resources in case we are redialing.
    //NT - is smart enough not to need it but it won't hurt.
    if (m_pcRNA)
        m_pcRNA->RasHangUp(m_hrasconn);
    
    m_hrasconn = NULL;




#if defined(DEBUG)
    if (FCampusNetOverride())
    {
        m_bModemOverride = TRUE;
    }
#endif

    if (m_bModemOverride)
    {
        // Skip dialing because the server is on the campus network
        //
        PostMessage(RegisterWindowMessageA(RASDIALEVENT),RASCS_Connected,0);
        hr = ERROR_SUCCESS;
    }
    else
        hr = MyRasDial(lpRasDialExtentions,NULL,lpRasDialParams,0xFFFFFFFF, m_hWnd,
                       &m_hrasconn);

    m_bModemOverride = FALSE;

    if (( hr != ERROR_SUCCESS) || m_bWaitingToHangup)
    {
        // We failed to connect for some reason, so hangup
        if (m_hrasconn)
        {
            if (!m_pcRNA) m_pcRNA = new RNAAPI;
            if (!m_pcRNA)
            {
                MsgBox(IDS_OUTOFMEMORY,MB_MYERROR);
            } else {
                m_pcRNA->RasHangUp(m_hrasconn);
                m_bWaitingToHangup = FALSE;
                m_hrasconn = NULL;
            }
        }
        goto DialExit;
    }

    if (lpRasDialParams) 
        GlobalFree(lpRasDialParams);
    lpRasDialParams = NULL;

DialExit:
    if (lpRasDialExtentions) 
        GlobalFree(lpRasDialExtentions);
    lpRasDialExtentions = NULL;

    // Set the return value for the method
    if (hr != ERROR_SUCCESS)
        *pbRetVal = FALSE;
    else
        *pbRetVal = TRUE;

    m_hrDialErr = hr;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   MyRasGetEntryProperties()
//
//  Synopsis:   Performs some buffer size checks and then calls RasGetEntryProperties()
//                See the RasGetEntryProperties() docs to understand why this is needed.
//
//  Arguments:  Same as RasGetEntryProperties with the following exceptions:
//                lplpRasEntryBuff -- pointer to a pointer to a RASENTRY struct.  On successfull
//                                    return, *lplpRasEntryBuff will point to the RASENTRY struct
//                                    and buffer returned by RasGetEntryProperties.
//                                    NOTE: should not have memory allocated to it at call time!
//                                          To emphasize this point, *lplpRasEntryBuff must be NULL
//                lplpRasDevInfoBuff -- pointer to a pointer to a RASDEVINFO struct.  On successfull
//                                    return, *lplpRasDevInfoBuff will point to the RASDEVINFO struct
//                                    and buffer returned by RasGetEntryProperties.
//                                    NOTE: should not have memory allocated to it at call time!
//                                          To emphasize this point, *lplpRasDevInfoBuff must be NULL
//                                    NOTE: Even on a successfull call to RasGetEntryProperties,
//                                          *lplpRasDevInfoBuff may return with a value of NULL
//                                          (occurs when there is no extra device info)
//
//    Returns:    ERROR_NOT_ENOUGH_MEMORY if unable to allocate either RASENTRY or RASDEVINFO buffer
//                Otherwise, it retuns the error code from the call to RasGetEntryProperties.
//                NOTE: if return is anything other than ERROR_SUCCESS, *lplpRasDevInfoBuff and
//                      *lplpRasEntryBuff will be NULL,
//                      and *lpdwRasEntryBuffSize and *lpdwRasDevInfoBuffSize will be 0
//
//  Example:
//
//      LPRASENTRY    lpRasEntry = NULL;
//      LPRASDEVINFO  lpRasDevInfo = NULL;
//      DWORD            dwRasEntrySize, dwRasDevInfoSize;
//
//      hr = MyRasGetEntryProperties( NULL,
//                                      g_pcDialErr->m_szConnectoid,
//                                    &lpRasEntry,
//                                    &dwRasEntrySize,
//                                    &lpRasDevInfo,
//                                    &dwRasDevInfoSize);
//
//
//      if (hr != ERROR_SUCCESS)
//      {
//            //handle errors here
//      } else
//      {
//            //continue processing
//      }
//
//
//  History:    9/10/96     JMazner        Created for icwconn2
//                9/17/96        JMazner        Adapted for icwconn1
//              1/8/98      DONALDM     Moved to the new ICW/GetConn project
//----------------------------------------------------------------------------
HRESULT CRefDial::MyRasGetEntryProperties(LPTSTR lpszPhonebookFile,
                                LPTSTR lpszPhonebookEntry, 
                                LPRASENTRY *lplpRasEntryBuff,
                                LPDWORD lpdwRasEntryBuffSize,
                                LPRASDEVINFO *lplpRasDevInfoBuff,
                                LPDWORD lpdwRasDevInfoBuffSize)
{

    HRESULT hr;
    RNAAPI *pcRNA = NULL;

    DWORD dwOldDevInfoBuffSize;

    Assert( NULL != lplpRasEntryBuff );
    Assert( NULL != lpdwRasEntryBuffSize );
    Assert( NULL != lplpRasDevInfoBuff );
    Assert( NULL != lpdwRasDevInfoBuffSize );

    *lpdwRasEntryBuffSize = 0;
    *lpdwRasDevInfoBuffSize = 0;

    pcRNA = new RNAAPI;
    if (!pcRNA)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto MyRasGetEntryPropertiesErrExit;
    }

    // use RasGetEntryProperties with a NULL lpRasEntry pointer to find out size buffer we need
    // As per the docs' recommendation, do the same with a NULL lpRasDevInfo pointer.

    hr = pcRNA->RasGetEntryProperties(lpszPhonebookFile, lpszPhonebookEntry,
                                (LPBYTE) NULL,
                                lpdwRasEntryBuffSize,
                                (LPBYTE) NULL,
                                lpdwRasDevInfoBuffSize);

    // we expect the above call to fail because the buffer size is 0
    // If it doesn't fail, that means our RasEntry is messed, so we're in trouble
    if( ERROR_BUFFER_TOO_SMALL != hr )
    { 
        goto MyRasGetEntryPropertiesErrExit;
    }

    // dwRasEntryBuffSize and dwRasDevInfoBuffSize now contain the size needed for their
    // respective buffers, so allocate the memory for them

    // dwRasEntryBuffSize should never be less than the size of the RASENTRY struct.
    // If it is, we'll run into problems sticking values into the struct's fields

    Assert( *lpdwRasEntryBuffSize >= sizeof(RASENTRY) );

    if (m_reflpRasEntryBuff)
    {
        if (*lpdwRasEntryBuffSize > m_reflpRasEntryBuff->dwSize)
        {
            LPRASENTRY pTemp = m_reflpRasEntryBuff;
            m_reflpRasEntryBuff = (LPRASENTRY)GlobalReAlloc(pTemp, *lpdwRasEntryBuffSize, GPTR);
            if (m_reflpRasEntryBuff == NULL)
            {
                GlobalFree(pTemp);
            }
        }
    }
    else
    {
        m_reflpRasEntryBuff = (LPRASENTRY)GlobalAlloc(GPTR,*lpdwRasEntryBuffSize);
    }


    if (!m_reflpRasEntryBuff)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto MyRasGetEntryPropertiesErrExit;
    }

    // This is a bit convoluted:  lpRasEntrySize->dwSize needs to contain the size of _only_ the
    // RASENTRY structure, and _not_ the actual size of the buffer that lpRasEntrySize points to.
    // This is because the dwSize field is used by RAS for compatability purposes to determine which
    // version of the RASENTRY struct we're using.
    // Same holds for lpRasDevInfo->dwSize
    
    m_reflpRasEntryBuff->dwSize = sizeof(RASENTRY);

    //
    // Allocate the DeviceInfo size that RasGetEntryProperties told us we needed.
    // If size is 0, don't alloc anything
    //
    if( *lpdwRasDevInfoBuffSize > 0 )
    {
        Assert( *lpdwRasDevInfoBuffSize >= sizeof(RASDEVINFO) );
        if (m_reflpRasDevInfoBuff)
        {
            // check if existing size is not sufficient
            if ( *lpdwRasDevInfoBuffSize > m_reflpRasDevInfoBuff->dwSize )
            {
                LPRASDEVINFO pTemp = m_reflpRasDevInfoBuff;
                m_reflpRasDevInfoBuff = (LPRASDEVINFO)GlobalReAlloc(pTemp,*lpdwRasDevInfoBuffSize, GPTR);
                if (m_reflpRasDevInfoBuff == NULL)
                {
                    GlobalFree(pTemp);
                }
            }
        }
        else
        {
            m_reflpRasDevInfoBuff = (LPRASDEVINFO)GlobalAlloc(GPTR,*lpdwRasDevInfoBuffSize);
        }

        if (!m_reflpRasDevInfoBuff)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto MyRasGetEntryPropertiesErrExit;
        }
    } 
    else
    {
        m_reflpRasDevInfoBuff = NULL;
    }

    if( m_reflpRasDevInfoBuff )
    {
        m_reflpRasDevInfoBuff->dwSize = sizeof(RASDEVINFO);
    }


    // now we're ready to make the actual call...

    // jmazner   see below for why this is needed
    dwOldDevInfoBuffSize = *lpdwRasDevInfoBuffSize;

    hr = pcRNA->RasGetEntryProperties(lpszPhonebookFile, lpszPhonebookEntry,
                                (LPBYTE) m_reflpRasEntryBuff,
                                lpdwRasEntryBuffSize,
                                (LPBYTE) m_reflpRasDevInfoBuff,
                                lpdwRasDevInfoBuffSize);

    // jmazner 10/7/96  Normandy #8763
    // For unknown reasons, in some cases on win95, devInfoBuffSize increases after the above call,
    // but the return code indicates success, not BUFFER_TOO_SMALL.  If this happens, set the
    // size back to what it was before the call, so the DevInfoBuffSize and the actuall space allocated 
    // for the DevInfoBuff match on exit.
    if( (ERROR_SUCCESS == hr) && (dwOldDevInfoBuffSize != *lpdwRasDevInfoBuffSize) )
    {
        *lpdwRasDevInfoBuffSize = dwOldDevInfoBuffSize;
    }


    if( pcRNA )
    {
        delete pcRNA;
        pcRNA = NULL;
    }

    *lplpRasEntryBuff = m_reflpRasEntryBuff;
    *lplpRasDevInfoBuff = m_reflpRasDevInfoBuff;

    return( hr );

MyRasGetEntryPropertiesErrExit:

    if(m_reflpRasEntryBuff)
    {
        GlobalFree(m_reflpRasEntryBuff);
        m_reflpRasEntryBuff = NULL;
        *lplpRasEntryBuff = NULL;
    }
    if(m_reflpRasDevInfoBuff)
    {
        GlobalFree(m_reflpRasDevInfoBuff);
        m_reflpRasDevInfoBuff = NULL;
        *lplpRasDevInfoBuff = NULL;
    }
        
    if( pcRNA )
    {
        delete pcRNA;
        pcRNA = NULL;
    }

    *lpdwRasEntryBuffSize = 0;
    *lpdwRasDevInfoBuffSize = 0;
    
    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   LineCallback()
//
//  Synopsis:   Call back for TAPI line
//
//+---------------------------------------------------------------------------
void CALLBACK LineCallback(DWORD hDevice,
                           DWORD dwMessage,
                           DWORD dwInstance,
                           DWORD dwParam1,
                           DWORD dwParam2,
                           DWORD dwParam3)
{
}


HRESULT MyGetFileVersion(LPCTSTR pszFileName, LPGATHERINFO lpGatherInfo)
{
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    DWORD   dwSize = 0;
    DWORD   dwTemp = 0;
    LPVOID  pv = NULL, pvVerInfo = NULL;
    UINT    uiSize;
    DWORD   dwVerPiece;
    //int idx;

    
    // verify parameters
    //
    Assert(pszFileName && lpGatherInfo);

    // Get version
    //
    dwSize = GetFileVersionInfoSize((LPTSTR)pszFileName,&dwTemp);
    if (!dwSize)
    {
        hr = GetLastError();
        goto MyGetFileVersionExit;
    }
    pv = (LPVOID)GlobalAlloc(GPTR, (size_t)dwSize);
    if (!pv) goto MyGetFileVersionExit;
    if (!GetFileVersionInfo((LPTSTR)pszFileName,dwTemp,dwSize,pv))
    {
        hr = GetLastError();
        goto MyGetFileVersionExit;
    }

    if (!VerQueryValue(pv,TEXT("\\\0"),&pvVerInfo,&uiSize))
    {
        hr = GetLastError();
        goto MyGetFileVersionExit;
    }
    pvVerInfo = (LPVOID)((DWORD_PTR)pvVerInfo + sizeof(DWORD)*4);
    lpGatherInfo->m_szSUVersion[0] = '\0';
    dwVerPiece = (*((LPDWORD)pvVerInfo)) >> 16;
    wsprintf(lpGatherInfo->m_szSUVersion,TEXT("%d."),dwVerPiece);

    dwVerPiece = (*((LPDWORD)pvVerInfo)) & 0x0000ffff;
    wsprintf(lpGatherInfo->m_szSUVersion,TEXT("%s%d."),lpGatherInfo->m_szSUVersion,dwVerPiece);

    dwVerPiece = (((LPDWORD)pvVerInfo)[1]) >> 16;
    wsprintf(lpGatherInfo->m_szSUVersion,TEXT("%s%d."),lpGatherInfo->m_szSUVersion,dwVerPiece);

    dwVerPiece = (((LPDWORD)pvVerInfo)[1]) & 0x0000ffff;
    wsprintf(lpGatherInfo->m_szSUVersion,TEXT("%s%d"),lpGatherInfo->m_szSUVersion,dwVerPiece);

    if (!VerQueryValue(pv,TEXT("\\VarFileInfo\\Translation"),&pvVerInfo,&uiSize))
    {
        hr = GetLastError();
        goto MyGetFileVersionExit;
    }

    // separate version information from character set
    lpGatherInfo->m_lcidApps = (LCID)(LOWORD(*(DWORD*)pvVerInfo));

    hr = ERROR_SUCCESS;

MyGetFileVersionExit:
    if (pv) GlobalFree(pv);
    
    return hr;
}

DWORD CRefDial::FillGatherInfoStruct(LPGATHERINFO lpGatherInfo)
{
    USES_CONVERSION;
    HKEY        hkey = NULL;
    SYSTEM_INFO si;
    TCHAR       szTempPath[MAX_PATH];
    DWORD       dwRet = ERROR_SUCCESS;
        
    lpGatherInfo->m_lcidUser  = GetUserDefaultLCID();
    lpGatherInfo->m_lcidSys   = GetSystemDefaultLCID();
    
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

     if (!GetVersionEx(&osvi))
    {
        // Nevermind, we'll just assume the version is 0.0 if we can't read it
        //
        ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
    }

    lpGatherInfo->m_dwOS = osvi.dwPlatformId;
    lpGatherInfo->m_dwMajorVersion = osvi.dwMajorVersion;
    lpGatherInfo->m_dwMinorVersion = osvi.dwMinorVersion;

    ZeroMemory(&si,sizeof(SYSTEM_INFO));
    GetSystemInfo(&si);

    lpGatherInfo->m_wArchitecture = si.wProcessorArchitecture;

    // Sign-up version
    //
    lpGatherInfo->m_szSUVersion[0] = '\0';
    if( GetModuleFileName(_Module.GetModuleInstance(), szTempPath, MAX_PATH))
    {
        if ((MyGetFileVersion(szTempPath, lpGatherInfo)) != ERROR_SUCCESS)
        {
            return (GetLastError());
        }
    }
    else
        return( GetLastError() );

    // OEM code
    //
    TCHAR szOeminfoPath[MAX_PATH + 1];
    TCHAR *lpszTerminator = NULL;
    TCHAR *lpszLastChar = NULL;
    TCHAR szTemp[MAX_PATH];
        
    if( 0 != GetSystemDirectory( szOeminfoPath, MAX_PATH + 1 ) )
    {
        lpszTerminator = &(szOeminfoPath[ lstrlen(szOeminfoPath) ]);
        lpszLastChar = CharPrev( szOeminfoPath, lpszTerminator );

        if( '\\' != *lpszLastChar )
        {
            lpszLastChar = CharNext( lpszLastChar );
            *lpszLastChar = '\\';
            lpszLastChar = CharNext( lpszLastChar );
            *lpszLastChar = '\0';
        }

        lstrcat( szOeminfoPath, ICW_OEMINFO_FILENAME );

        //Default oem code must be NULL if it doesn't exist in oeminfo.ini
        if (!GetPrivateProfileString(ICW_OEMINFO_OEMSECTION,
                                     ICW_OEMINFO_OEMKEY,
                                     TEXT(""),
                                     m_szOEM,
                                     MAX_OEMNAME,
                                     szOeminfoPath))
        {
            //oem = (nothing), set to NULL
            m_szOEM[0] = '\0';
        }
                    
        // Get the Product Code, Promo code and ALLOFFERS code if they exist
        if (GetPrivateProfileString(ICW_OEMINFO_ICWSECTION,
                                ICW_OEMINFO_PRODUCTCODE,
                                DEFAULT_PRODUCTCODE,
                                szTemp,
                                ARRAYSIZE(szTemp),
                                szOeminfoPath))
        {
            m_bstrProductCode = A2BSTR(szTemp);
        }
        else
            m_bstrProductCode = A2BSTR(DEFAULT_PRODUCTCODE);
       
        if (GetPrivateProfileString(ICW_OEMINFO_ICWSECTION,
                                ICW_OEMINFO_PROMOCODE,
                                DEFAULT_PROMOCODE,
                                szTemp,
                                ARRAYSIZE(szTemp),
                                szOeminfoPath))
        {
            m_bstrPromoCode = A2BSTR(szTemp);
        }
        else
            m_bstrPromoCode = A2BSTR(DEFAULT_PROMOCODE);
          
        m_lAllOffers = GetPrivateProfileInt(ICW_OEMINFO_ICWSECTION,
                                            ICW_OEMINFO_ALLOFFERS,
                                            1,
                                            szOeminfoPath);
    }


    // 2/20/97    jmazner    Olympus #259
    if ( RegOpenKey(HKEY_LOCAL_MACHINE,ICWSETTINGSPATH,&hkey) == ERROR_SUCCESS)
    {
        DWORD dwSize; 
        DWORD dwType;
        dwType = REG_SZ;
        dwSize = sizeof(TCHAR)*(MAX_RELPROD + 1);
        if (RegQueryValueEx(hkey,RELEASEPRODUCTKEY,NULL,&dwType,(LPBYTE)&lpGatherInfo->m_szRelProd[0],&dwSize) != ERROR_SUCCESS)
            lpGatherInfo->m_szRelProd[0] = '\0';

        dwSize = sizeof(TCHAR)*(MAX_RELVER + 1);
        if (RegQueryValueEx(hkey,RELEASEVERSIONKEY,NULL,&dwType,(LPBYTE)&lpGatherInfo->m_szRelVer[0],&dwSize) != ERROR_SUCCESS)
            lpGatherInfo->m_szRelVer[0] = '\0';


        RegCloseKey(hkey);
    }

    // PromoCode
    lpGatherInfo->m_szPromo[0] = '\0';

    
    TCHAR    szPIDPath[MAX_PATH];        // Reg path to the PID

    // Form the Path, it is HKLM\\Software\\Microsoft\Windows[ NT]\\CurrentVersion
    lstrcpy(szPIDPath, TEXT("Software\\Microsoft\\Windows"));
    IF_NTONLY
        lstrcat(szPIDPath, TEXT(" NT"));
    ENDIF_NTONLY
    lstrcat(szPIDPath, TEXT("\\CurrentVersion"));

    BYTE    byDigitalPID[MAX_DIGITAL_PID];

    // Get the Product ID for this machine
    if ( RegOpenKey(HKEY_LOCAL_MACHINE,szPIDPath,&hkey) == ERROR_SUCCESS)
    {
        DWORD dwSize; 
        DWORD dwType;
        dwType = REG_BINARY;
        dwSize = sizeof(byDigitalPID);
        if (RegQueryValueEx(hkey,
                            c_szRegStrValDigitalPID,
                            NULL,
                            &dwType,
                            (LPBYTE)byDigitalPID,
                            &dwSize) == ERROR_SUCCESS)
        {
            // BINHEX the digital PID data so we can send it to the ref_server
            int     i = 0;
            BYTE    by;
            for (DWORD dwX = 0; dwX < dwSize; dwX++)
            {
                by = byDigitalPID[dwX];
                m_szPID[i++] = g_BINTOHEXLookup[((by & 0xF0) >> 4)];
                m_szPID[i++] = g_BINTOHEXLookup[(by & 0x0F)];
            }
            m_szPID[i] = '\0';
        }
        else
        {
            m_szPID[0] = '\0';
        }
        RegCloseKey(hkey);
    }

    return( dwRet );
}

// ############################################################################
HRESULT CRefDial::CreateEntryFromDUNFile(LPTSTR pszDunFile)
{
    TCHAR    szFileName[MAX_PATH];
    TCHAR    szUserName[UNLEN+1];
    TCHAR    szPassword[PWLEN+1];
    LPTSTR   pszTemp;
    HRESULT  hr;
    BOOL     fNeedsRestart=FALSE;


    hr = ERROR_SUCCESS;

    // Get fully qualified path name
    //

    if (!SearchPath(NULL,pszDunFile,NULL,MAX_PATH,&szFileName[0],&pszTemp))
    {
        hr = ERROR_FILE_NOT_FOUND;
        goto CreateEntryFromDUNFileExit;
    } 

    // save current DUN file name in global
    lstrcpy(m_szCurrentDUNFile, &szFileName[0]);

    hr = m_ISPImport.ImportConnection (&szFileName[0], m_szISPSupportNumber, m_szEntryName, szUserName, szPassword,&fNeedsRestart);

    // place the name of the connectoid in the registry
    //
    if (ERROR_SUCCESS != (StoreInSignUpReg((LPBYTE)m_szEntryName, lstrlen(m_szEntryName)+1, REG_SZ, RASENTRYVALUENAME)))
    {
        goto CreateEntryFromDUNFileExit;
    }
    lstrcpy(m_szLastDUNFile, pszDunFile);

CreateEntryFromDUNFileExit:
    return hr;
}


HRESULT CRefDial::UserPickANumber(HWND hWnd,
                            LPGATHERINFO lpGatherInfo, 
                            PSUGGESTINFO lpSuggestInfo,
                            HINSTANCE hPHBKDll,
                            DWORD_PTR dwPhoneBook,
                            TCHAR *pszConnectoid, 
                            DWORD dwSize,
                            DWORD dwPhoneDisplayFlags)
{
    USES_CONVERSION;
    HRESULT     hr = ERROR_NOT_ENOUGH_MEMORY;
    FARPROC     fp;
    RASENTRY    *prasentry = NULL;
    RASDEVINFO  *prasdevinfo = NULL;
    DWORD       dwRasentrySize = 0;
    DWORD       dwRasdevinfoSize = 0;
    TCHAR        szTemp[256];
    TCHAR        *ppszDunFiles[1];
    TCHAR        *ppszTemp[1];
    TCHAR        szDunFile[12];
    BOOL        bStatus = TRUE;
    
    //
    // If the phone book can't find a number let the user pick
    //
    ppszDunFiles[0] = &szDunFile[0];
    lstrcpy(&szDunFile[0],OLE2A(m_bstrISPFile));

    fp = GetProcAddress(hPHBKDll, PHBK_DISPLAYAPI);
    AssertMsg(fp != NULL,TEXT("display access number api is missing"));
    ppszTemp[0] = szTemp;

    
    //
    // donsc - 3/10/98
    //   
    // We have seen at least one code-path that could bring you into
    // here with lpSuggestInfo or lpGatherInfo == NULL. That has been
    // fixed, but to be defensive, we will ensure that these pointers
    // are valid...even if they don't have information, we will still let
    // the user pick a number.

    SUGGESTINFO SugInfo;
    GATHERINFO  GatInfo;
    
    ::ZeroMemory(&SugInfo,sizeof(SugInfo));
    ::ZeroMemory(&GatInfo,sizeof(GatInfo));

    if(lpSuggestInfo == NULL)
    {
      TraceMsg(TF_GENERAL, TEXT("UserPickANumber: lpSuggestInfo is NULL\n"));
      lpSuggestInfo = &SugInfo;
    }

    if(lpGatherInfo == NULL)
    {
      TraceMsg(TF_GENERAL, TEXT("UserPickANumber: lpGatherInfo is NULL\n"));
      lpGatherInfo = &GatInfo;
    }

    hr = ((PFNPHONEDISPLAY)fp)(dwPhoneBook,
                                ppszTemp,
                                ppszDunFiles,
                                &(lpSuggestInfo->wNumber),
                                &(lpSuggestInfo->dwCountryID),
                                &(lpGatherInfo->m_wState),
                                lpGatherInfo->m_fType,
                                lpGatherInfo->m_bMask,
                                hWnd,
                                dwPhoneDisplayFlags);
    if (hr != ERROR_SUCCESS) 
        goto UserPickANumberExit;

    
    ZeroMemory(pszConnectoid,dwSize);
    hr = ReadSignUpReg((LPBYTE)pszConnectoid, &dwSize, REG_SZ, 
                        RASENTRYVALUENAME);
    if (hr != ERROR_SUCCESS) 
        goto UserPickANumberExit;


    hr = MyRasGetEntryProperties(NULL,
                                    pszConnectoid,
                                    &prasentry,
                                    &dwRasentrySize,
                                    &prasdevinfo,
                                    &dwRasdevinfoSize);
    if (hr != ERROR_SUCCESS) 
        goto UserPickANumberExit;
                            
    //
    // Check to see if the user selected a phone number with a different dun file
    // than the one already used to create the connectoid
    //
    TCHAR    szTempPath[MAX_PATH];

    // If we did not use dun file last time, assumed we used the default.
    if ( *m_szLastDUNFile )
        lstrcpy(szTempPath, m_szLastDUNFile);
    else
        bStatus = (ERROR_SUCCESS == GetDataFromISPFile(OLE2A(m_bstrISPFile),INF_SECTION_ISPINFO, INF_DUN_FILE,szTempPath,MAX_PATH));

    if (bStatus)
    {
        if (_tcsicmp(szTempPath,ppszDunFiles[0]))
        {

            //
            // Rats, they changed dun files. We now get to build the connectoid
            // from scratch
            //
            if (CreateEntryFromDUNFile(ppszDunFiles[0]) == ERROR_SUCCESS)
            {
                prasentry = NULL;
                dwRasentrySize = 0;
                prasdevinfo = NULL;
                dwRasdevinfoSize = 0;
            
                hr = MyRasGetEntryProperties(NULL,
                                            pszConnectoid,
                                            &prasentry,
                                            &dwRasentrySize,
                                            &prasdevinfo,
                                            &dwRasdevinfoSize);
            
                if (hr != ERROR_SUCCESS || NULL == prasentry) 
                    goto UserPickANumberExit;
            
                BreakUpPhoneNumber(prasentry, szTemp);
                prasentry->dwCountryID = lpSuggestInfo->dwCountryID;
            } 
            else 
            {
                hr = ERROR_READING_DUN;
                goto UserPickANumberExit;
            }
        } 
        else 
        {
            BreakUpPhoneNumber(prasentry, szTemp);
            prasentry->dwCountryID = lpSuggestInfo->dwCountryID;
        }
    } 
    else 
    {
        hr = ERROR_READING_ISP;
        goto UserPickANumberExit;
    }


    prasentry->dwfOptions |= RASEO_UseCountryAndAreaCodes;
    //
    // Write out new connectoid
    //
    if (m_pcRNA)
        hr = m_pcRNA->RasSetEntryProperties(NULL, pszConnectoid, 
                                                (LPBYTE)prasentry, 
                                                dwRasentrySize, 
                                                (LPBYTE)prasdevinfo, 
                                                dwRasdevinfoSize);
    if (hr != ERROR_SUCCESS) 
        goto UserPickANumberExit;
    
    
    return hr;


UserPickANumberExit:
    TCHAR    szBuff256[257];
    if (hr == ERROR_READING_ISP)
    {
        MsgBox(IDS_CANTREADMSNSUISP, MB_MYERROR);
    } else if (hr == ERROR_READING_DUN) {
        MsgBox(IDS_CANTREADMSDUNFILE, MB_MYERROR);
    } else if (hr == ERROR_PHBK_NOT_FOUND) {
        wsprintf(szBuff256,GetSz(IDS_CANTLOADINETCFG),TEXT("ICWPHBK.DLL"));
        MessageBox(szBuff256,GetSz(IDS_TITLE),MB_MYERROR);
    } else if (hr == ERROR_PHBK_NOT_FOUND) {
        wsprintf(szBuff256,GetSz(IDS_CANTLOADINETCFG),TEXT("ICWDL.DLL"));
        MessageBox(szBuff256,GetSz(IDS_TITLE),MB_MYERROR);
    } else if (hr == ERROR_USERBACK || hr == ERROR_USERCANCEL) {
        // Do nothing
    } else if (hr == ERROR_NOT_ENOUGH_MEMORY) {
        MsgBox(IDS_OUTOFMEMORY,MB_MYERROR);
    } else if ((hr == ERROR_NO_MORE_ITEMS) || (hr == ERROR_INVALID_DATA)
                || (hr == ERROR_FILE_NOT_FOUND)) {
        MsgBox(IDS_CORRUPTPHONEBOOK, MB_MYERROR);
    } else if (hr != ERROR_SUCCESS) {
        wsprintf(szBuff256,TEXT("You can ignore this, just report it and include this number (%d).\n"),hr);
        AssertMsg(0,szBuff256);
    }

    return hr;
} 

HRESULT CRefDial::SetupForRASDialing
(
    LPGATHERINFO lpGatherInfo, 
    HINSTANCE hPHBKDll,
    DWORD_PTR *lpdwPhoneBook,
    PSUGGESTINFO *ppSuggestInfo,
    TCHAR *pszConnectoid, 
    BOOL FAR *bConnectiodCreated
)
{
    USES_CONVERSION;

    HRESULT         hr = ERROR_NOT_ENOUGH_MEMORY;
    FARPROC         fp;
    PSUGGESTINFO    pSuggestInfo = NULL;
    TCHAR           szEntry[MAX_RASENTRYNAME];
    DWORD           dwSize = sizeof(szEntry);
    RASENTRY        *prasentry = NULL;
    RASDEVINFO      *prasdevinfo = NULL;
    DWORD           dwRasentrySize = 0;
    DWORD           dwRasdevinfoSize = 0;
    HINSTANCE       hRasDll =NULL;
    TCHAR           szBuff256[257];

    LPRASCONN       lprasconn = NULL;

    // Load the connectoid
    //
    if (!m_pcRNA) 
        m_pcRNA = new RNAAPI;
    if (!m_pcRNA) 
        goto SetupForRASDialingExit;

    prasentry = (RASENTRY*)GlobalAlloc(GPTR,sizeof(RASENTRY)+2);
    Assert(prasentry);
    if (!prasentry)
    {
        hr = GetLastError();
        goto SetupForRASDialingExit;
    }
    prasentry->dwSize = sizeof(RASENTRY);
    dwRasentrySize = sizeof(RASENTRY);

    
    prasdevinfo = (RASDEVINFO*)GlobalAlloc(GPTR,sizeof(RASDEVINFO));
    Assert(prasdevinfo);
    if (!prasdevinfo)
    {
        hr = GetLastError();
        goto SetupForRASDialingExit;
    }
    prasdevinfo->dwSize = sizeof(RASDEVINFO);
    dwRasdevinfoSize = sizeof(RASDEVINFO);

    
    hr = ReadSignUpReg((LPBYTE)&szEntry[0], &dwSize, REG_SZ, 
                        RASENTRYVALUENAME);
    if (hr != ERROR_SUCCESS) 
        goto SetupForRASDialingExit;

#ifdef UNICODE
    // Comment for UNICODE.
	// RasGetEntryProperties fails in case of UNICODE
	// because of size. So I ask the size first before actual call.
	hr = m_pcRNA->RasGetEntryProperties(NULL, szEntry, 
                                            NULL,
                                            &dwRasentrySize, 
                                            NULL,
                                            &dwRasdevinfoSize);
#else
    hr = m_pcRNA->RasGetEntryProperties(NULL, szEntry, 
                                            (LPBYTE)prasentry, 
                                            &dwRasentrySize, 
                                            (LPBYTE)prasdevinfo, 
                                            &dwRasdevinfoSize);
#endif
    if (hr == ERROR_BUFFER_TOO_SMALL)
    {
        // Comment for UNICODE.
        // This must be happen for UNICODE.

        TraceMsg(TF_GENERAL,TEXT("CONNECT:RasGetEntryProperties failed, try a new size.\n"));
        GlobalFree(prasentry);
        prasentry = (RASENTRY*)GlobalAlloc(GPTR,((size_t)dwRasentrySize));
        prasentry->dwSize = dwRasentrySize;

        GlobalFree(prasdevinfo);
		if(dwRasdevinfoSize > 0)
        {
            prasdevinfo = (RASDEVINFO*)GlobalAlloc(GPTR,((size_t)dwRasdevinfoSize));
            prasdevinfo->dwSize = dwRasdevinfoSize;
        }
        else
            prasdevinfo = NULL;
        hr = m_pcRNA->RasGetEntryProperties(NULL, szEntry, 
                                                (LPBYTE)prasentry, 
                                                &dwRasentrySize, 
                                                (LPBYTE)prasdevinfo, 
                                                &dwRasdevinfoSize);
    }
    if (hr != ERROR_SUCCESS) 
        goto SetupForRASDialingExit;


    lpGatherInfo->m_wState = 0;
    lpGatherInfo->m_fType = TYPE_SIGNUP_ANY | (m_ISPImport.m_bIsISDNDevice ? MASK_ISDN_BIT:MASK_ANALOG_BIT);
    lpGatherInfo->m_bMask = MASK_SIGNUP_ANY | (m_ISPImport.m_bIsISDNDevice ? MASK_ISDN_BIT:MASK_ANALOG_BIT);



    //
    // Check to see if the phone number was filled in
    //
    if (lstrcmp(&prasentry->szLocalPhoneNumber[0],DUN_NOPHONENUMBER) == 0)
    {
        //
        // allocate and intialize memory
        //
        pSuggestInfo = (PSUGGESTINFO)GlobalAlloc(GPTR,sizeof(SUGGESTINFO));
        Assert(pSuggestInfo);
        if (!pSuggestInfo) 
        {
            hr = GetLastError();
            goto SetupForRASDialingExit;
        }
        *ppSuggestInfo = pSuggestInfo;
 
        // set phone number type and mask
        pSuggestInfo->fType = TYPE_SIGNUP_ANY | (m_ISPImport.m_bIsISDNDevice ? MASK_ISDN_BIT:MASK_ANALOG_BIT);
        pSuggestInfo->bMask = MASK_SIGNUP_ANY | (m_ISPImport.m_bIsISDNDevice ? MASK_ISDN_BIT:MASK_ANALOG_BIT);

        pSuggestInfo->wAreaCode = Sz2W(lpGatherInfo->m_szAreaCode);
        pSuggestInfo->dwCountryID = lpGatherInfo->m_dwCountry;

    
        // Load Microsoft's phonebook
        //
        fp = GetProcAddress(hPHBKDll,PHBK_LOADAPI);
        AssertMsg(fp != NULL,TEXT("PhoneBookLoad is missing from icwphbk.dll"));

        hr = ((PFNPHONEBOOKLOAD)fp)(OLE2A(m_bstrISPFile),lpdwPhoneBook);
        if (hr != ERROR_SUCCESS) goto SetupForRASDialingExit;
        
        AssertMsg((*lpdwPhoneBook == TRUE),TEXT("Phonebook Load return no error and 0 for phonebook"));

        
        //
        // Load Suggest procedure
        //
        fp = GetProcAddress(hPHBKDll,PHBK_SUGGESTAPI);
        AssertMsg(fp != NULL,TEXT("PhoneBookSuggest is missing from icwphbk.dll"));

        // Set the number of suggestions
        pSuggestInfo->wNumber = NUM_PHBK_SUGGESTIONS;
        
        // get phone number
        hr = ((PFPHONEBOOKSUGGEST)fp)(*lpdwPhoneBook,pSuggestInfo);

        // Inore error because we can continue even without a suggested
        // phone number (the user will just have to pick one).
        hr = ERROR_SUCCESS;
    }
    else
    {
        ZeroMemory(pszConnectoid, dwSize);
        hr = ReadSignUpReg((LPBYTE)pszConnectoid, &dwSize, REG_SZ, 
                           RASENTRYVALUENAME);
        if (hr != ERROR_SUCCESS) 
            goto SetupForRASDialingExit;
    
        // Use the RASENTRY that we have to create the connectiod
        hr = m_pcRNA->RasSetEntryProperties(NULL, 
                                            pszConnectoid, 
                                            (LPBYTE)prasentry, 
                                            dwRasentrySize, 
                                            (LPBYTE)prasdevinfo, 
                                            dwRasdevinfoSize);
        *bConnectiodCreated = TRUE;                                            
    }

SetupForRASDialingExit:
    if (prasentry)
        GlobalFree(prasentry);
    if (prasdevinfo)
        GlobalFree(prasdevinfo);
    if (hr == ERROR_READING_ISP)
    {
        MsgBox(IDS_CANTREADMSNSUISP, MB_MYERROR);
    } else if (hr == ERROR_READING_DUN) {
        MsgBox(IDS_CANTREADMSDUNFILE, MB_MYERROR);
    } else if (hr == ERROR_PHBK_NOT_FOUND) {
        wsprintf(szBuff256,GetSz(IDS_CANTLOADINETCFG),TEXT("ICWPHBK.DLL"));
        MessageBox(szBuff256,GetSz(IDS_TITLE),MB_MYERROR);
    } else if (hr == ERROR_PHBK_NOT_FOUND) {
        wsprintf(szBuff256,GetSz(IDS_CANTLOADINETCFG),TEXT("ICWDL.DLL"));
        MessageBox(szBuff256,GetSz(IDS_TITLE),MB_MYERROR);
    } else if (hr == ERROR_USERBACK || hr == ERROR_USERCANCEL) {
        // Do nothing
    } else if (hr == ERROR_NOT_ENOUGH_MEMORY) {
        MsgBox(IDS_OUTOFMEMORY,MB_MYERROR);
    } else if ((hr == ERROR_NO_MORE_ITEMS) || (hr == ERROR_INVALID_DATA)
                || (hr == ERROR_FILE_NOT_FOUND)) {
        MsgBox(IDS_CORRUPTPHONEBOOK, MB_MYERROR);
    } else if (hr != ERROR_SUCCESS) {
        wsprintf(szBuff256,TEXT("You can ignore this, just report it and include this number (%d).\n"),hr);
        AssertMsg(0,szBuff256);
    }
    return hr;
}



// 10/22/96    jmazner    Normandy #9923
// Since in SetupConnectoidExit we're treating results other than ERROR_SUCCESS as
// indicating successfull completion, we need bSuccess to provide a simple way for the
// caller to tell whether the function completed.                
HRESULT CRefDial::SetupConnectoid
(
    PSUGGESTINFO    pSuggestInfo, 
    int             irc, 
    TCHAR           *pszConnectoid, 
    DWORD           dwSize, 
    BOOL            *pbSuccess
)
{
    USES_CONVERSION;
    
    HRESULT     hr = ERROR_NOT_ENOUGH_MEMORY;
    RASENTRY    *prasentry = NULL;
    RASDEVINFO  *prasdevinfo = NULL;
    DWORD       dwRasentrySize = 0;
    DWORD       dwRasdevinfoSize = 0;
    HINSTANCE   hPHBKDll = NULL;
    HINSTANCE   hRasDll =NULL;

    LPTSTR      lpszSetupFile;
    LPRASCONN   lprasconn = NULL;
    CMcRegistry reg;

    Assert(pbSuccess);

    if (!pSuggestInfo)
    {
        hr = ERROR_PHBK_NOT_FOUND;
        goto SetupConnectoidExit;
    }
    
    lpszSetupFile = m_szCurrentDUNFile[0] != '\0' ? m_szCurrentDUNFile : OLE2A(m_bstrISPFile);
    
    if (lstrcmp(pSuggestInfo->rgpAccessEntry[irc]->szDataCenter,lpszSetupFile))
    {
        hr = CreateEntryFromDUNFile(pSuggestInfo->rgpAccessEntry[irc]->szDataCenter);
        if (hr == ERROR_SUCCESS)
        {
            ZeroMemory(pszConnectoid, dwSize);
            hr = ReadSignUpReg((LPBYTE)pszConnectoid, &dwSize, REG_SZ, 
                               RASENTRYVALUENAME);
            if (hr != ERROR_SUCCESS) 
                goto SetupConnectoidExit;
        
            if( prasentry )
            {
                GlobalFree( prasentry );
                prasentry = NULL;
                dwRasentrySize = NULL;
            }
        
            if( prasdevinfo )
            {
                GlobalFree( prasdevinfo );
                prasdevinfo = NULL;
                dwRasdevinfoSize = NULL;
            }

            hr = MyRasGetEntryProperties(NULL,
                                        pszConnectoid,
                                        &prasentry,
                                        &dwRasentrySize,
                                        &prasdevinfo,
                                        &dwRasdevinfoSize);
            if (hr != ERROR_SUCCESS || NULL == prasentry) 
                goto SetupConnectoidExit;
        }
        else
        {
            // 10/22/96    jmazner    Normandy #9923
            goto SetupConnectoidExit;
        }
    }
    else
    {
        goto SetupConnectoidExit;
    }
    
    prasentry->dwCountryID = pSuggestInfo->rgpAccessEntry[irc]->dwCountryID;
    lstrcpyn(prasentry->szAreaCode,
                pSuggestInfo->rgpAccessEntry[irc]->szAreaCode,
                ARRAYSIZE(prasentry->szAreaCode));
    lstrcpyn(prasentry->szLocalPhoneNumber,
                pSuggestInfo->rgpAccessEntry[irc]->szAccessNumber,
                ARRAYSIZE(prasentry->szLocalPhoneNumber));

    prasentry->dwCountryCode = 0;
    prasentry->dwfOptions |= RASEO_UseCountryAndAreaCodes;

    // 10/19/96 jmazner Multiple modems problems
    // If no device name and type has been specified, grab the one we've stored
    // in ConfigRasEntryDevice

    if( 0 == lstrlen(prasentry->szDeviceName) )
    {
        // doesn't make sense to have an empty device name but a valid device type
        Assert( 0 == lstrlen(prasentry->szDeviceType) );

        // double check that we've already stored the user's choice.
        Assert( lstrlen(m_ISPImport.m_szDeviceName) );
        Assert( lstrlen(m_ISPImport.m_szDeviceType) );

        lstrcpyn( prasentry->szDeviceName, m_ISPImport.m_szDeviceName, lstrlen(m_ISPImport.m_szDeviceName) );
        lstrcpyn( prasentry->szDeviceType, m_ISPImport.m_szDeviceType, lstrlen(m_ISPImport.m_szDeviceType) );
    }

    // Write out new connectoid
    if (m_pcRNA)
        hr = m_pcRNA->RasSetEntryProperties(NULL, pszConnectoid, 
                                                (LPBYTE)prasentry, 
                                                dwRasentrySize, 
                                                (LPBYTE)prasdevinfo, 
                                                dwRasdevinfoSize);


    // Set this connetiod to have not proxy enabled
    TCHAR        szConnectionProfile[REGSTR_MAX_VALUE_LENGTH];
    
    lstrcpy(szConnectionProfile, c_szRASProfiles);
    lstrcat(szConnectionProfile, TEXT("\\"));
    lstrcat(szConnectionProfile,  pszConnectoid);
    
    reg.CreateKey(HKEY_CURRENT_USER, szConnectionProfile);
    reg.SetValue(c_szProxyEnable, (DWORD)0);
    
        
SetupConnectoidExit:

    *pbSuccess = FALSE;
    TCHAR    szBuff256[257];
    if (hr == ERROR_READING_ISP)
    {
        MsgBox(IDS_CANTREADMSNSUISP, MB_MYERROR);
    } else if (hr == ERROR_READING_DUN) {
        MsgBox(IDS_CANTREADMSDUNFILE, MB_MYERROR);
    } else if (hr == ERROR_PHBK_NOT_FOUND) {
        wsprintf(szBuff256,GetSz(IDS_CANTLOADINETCFG),TEXT("ICWPHBK.DLL"));
        MessageBox(szBuff256,GetSz(IDS_TITLE),MB_MYERROR);
    } else if (hr == ERROR_PHBK_NOT_FOUND) {
        wsprintf(szBuff256,GetSz(IDS_CANTLOADINETCFG),TEXT("ICWDL.DLL"));
        MessageBox(szBuff256,GetSz(IDS_TITLE),MB_MYERROR);
    } else if (hr == ERROR_USERBACK || hr == ERROR_USERCANCEL || hr == ERROR_SUCCESS) {
        // Do nothing
        *pbSuccess = TRUE;
    } else if (hr == ERROR_NOT_ENOUGH_MEMORY) {
        MsgBox(IDS_OUTOFMEMORY,MB_MYERROR);
    } else if ((hr == ERROR_NO_MORE_ITEMS) || (hr == ERROR_INVALID_DATA)
                || (hr == ERROR_FILE_NOT_FOUND)) {
        MsgBox(IDS_CORRUPTPHONEBOOK, MB_MYERROR);
    } else if (hr != ERROR_SUCCESS) {
        wsprintf(szBuff256,TEXT("You can ignore this, just report it and include this number (%d).\n"),hr);
        AssertMsg(0,szBuff256);
        *pbSuccess = TRUE;
    }
    return hr;
}

// Form the Dialing URL.  Must be called after setting up for dialing.
HRESULT CRefDial::FormURL()
{
    USES_CONVERSION;

    TCHAR    szTemp[MAX_PATH];
    TCHAR    szPromo[MAX_PATH];
    TCHAR    szProd[MAX_PATH];
    TCHAR    szArea[MAX_PATH];
    TCHAR    szOEM[MAX_PATH];
    DWORD    dwCONNWIZVersion = 0;        // Version of CONNWIZ.HTM
        
    //
    // ChrisK Olympus 3997 5/25/97
    //
    TCHAR szRelProd[MAX_PATH];
    TCHAR szRelProdVer[MAX_PATH];
    HRESULT hr = ERROR_SUCCESS;
    OSVERSIONINFO osvi;


    //
    // Build URL complete with name value pairs
    //
    hr = GetDataFromISPFile(OLE2A(m_bstrISPFile),INF_SECTION_ISPINFO, INF_REFERAL_URL,&szTemp[0],256);
    if ('\0' == szTemp[0])
    {
        MsgBox(IDS_MSNSU_WRONG,MB_MYERROR);
        return hr;
    }
    
    Assert(szTemp[0]);

    ANSI2URLValue(m_szOEM,szOEM,0);
    ANSI2URLValue(m_lpGatherInfo->m_szAreaCode,szArea,0);
    if (m_bstrProductCode)
        ANSI2URLValue(OLE2A((BSTR)m_bstrProductCode),szProd,0);
    else
        ANSI2URLValue(DEFAULT_PRODUCTCODE,szProd,0);

    if (m_bstrPromoCode)
        ANSI2URLValue(OLE2A((BSTR)m_bstrPromoCode),szPromo,0);
    else
        ANSI2URLValue(DEFAULT_PROMOCODE,szProd,0);
        
    //
    // ChrisK Olympus 3997 5/25/97
    //
    ANSI2URLValue(m_lpGatherInfo->m_szRelProd, szRelProd, 0);
    ANSI2URLValue(m_lpGatherInfo->m_szRelVer, szRelProdVer, 0);
    ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osvi))
    {
        ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
    }

#if defined(DEBUG)
    LoadTestingLocaleOverride(&m_lpGatherInfo->m_dwCountry, 
                                &m_lpGatherInfo->m_lcidUser);
#endif //DEBUG

    HINSTANCE hInstIcwconn = LoadLibrary(ICW_DOWNLOADABLE_COMPONENT_NAME);

    if (hInstIcwconn)
    {
        lpfnGetIcwconnVer = (GETICWCONNVER)GetProcAddress(hInstIcwconn, ICW_DOWNLOADABLE_COMPONENT_GETVERFUNC);
        // Get the version of ICWCONN.DLL
        if (lpfnGetIcwconnVer)
            dwCONNWIZVersion = lpfnGetIcwconnVer(); 
    
        FreeLibrary(hInstIcwconn);
    }


#if defined(DEBUG)
    if (FRefURLOverride())
    {
       TweakRefURL(szTemp, 
                   &m_lpGatherInfo->m_lcidUser, 
                   &m_lpGatherInfo->m_dwOS,
                   &m_lpGatherInfo->m_dwMajorVersion, 
                   &m_lpGatherInfo->m_dwMinorVersion,
                   &m_lpGatherInfo->m_wArchitecture, 
                   szPromo, 
                   szOEM, 
                   szArea, 
                   &m_lpGatherInfo->m_dwCountry,
                   &m_lpGatherInfo->m_szSUVersion[0], 
                   szProd, 
                   &osvi.dwBuildNumber, //For this we really want to LOWORD
                   szRelProd, 
                   szRelProdVer, 
                   &dwCONNWIZVersion, 
                   m_szPID, 
                   &m_lAllOffers);
    }
#endif //DEBUG

    // Autoconfig will set alloffers always.
    if ( m_lAllOffers || (m_lpGatherInfo->m_dwFlag & ICW_CFGFLAG_AUTOCONFIG) )
    {
        m_lpGatherInfo->m_dwFlag |= ICW_CFGFLAG_ALLOFFERS;
    }
    wsprintf(m_szUrl,TEXT("%slcid=%lu&sysdeflcid=%lu&appslcid=%lu&icwos=%lu&osver=%lu.%2.2d%s&arch=%u&promo=%s&oem=%s&area=%s&country=%lu&icwver=%s&prod=%s&osbld=%d&icwrp=%s&icwrpv=%s&wizver=%lu&PID=%s&cfgflag=%lu"),
                 szTemp,
                 m_lpGatherInfo->m_lcidUser,
                 m_lpGatherInfo->m_lcidSys,
                 m_lpGatherInfo->m_lcidApps,
                 m_lpGatherInfo->m_dwOS,
                 m_lpGatherInfo->m_dwMajorVersion,    
                 m_lpGatherInfo->m_dwMinorVersion,
                 ICW_OS_VER,
                 m_lpGatherInfo->m_wArchitecture, 
                 szPromo,
                 szOEM, 
                 szArea,
                 m_lpGatherInfo->m_dwCountry, 
                 &m_lpGatherInfo->m_szSUVersion[0], 
                 szProd,
                 LOWORD(osvi.dwBuildNumber), 
                 szRelProd, 
                 szRelProdVer,
                 dwCONNWIZVersion,
                 m_szPID,
                 m_lpGatherInfo->m_dwFlag);

    // Update registry values
    //
    wsprintf(m_lpGatherInfo->m_szISPFile,TEXT("%s\\%s"),g_pszAppDir,OLE2A(m_bstrISPFile));
    lstrcpyn(m_lpGatherInfo->m_szAppDir,g_pszAppDir,ARRAYSIZE(m_lpGatherInfo->m_szAppDir));

    StoreInSignUpReg(
        (LPBYTE)m_lpGatherInfo,
        sizeof(GATHERINFO), 
        REG_BINARY, 
        GATHERINFOVALUENAME);  
    return hr;
}

static const TCHAR cszBrandingSection[] = TEXT("Branding");
static const TCHAR cszBrandingFlags[]   = TEXT("Flags");

static const TCHAR cszSupportSection[]  = TEXT("Support");
static const TCHAR cszSupportNumber[]   = TEXT("SupportPhoneNumber");

static const TCHAR cszLoggingSection[]  = TEXT("Logging");
static const TCHAR cszStartURL[]        = TEXT("StartURL");
static const TCHAR cszEndURL[]          = TEXT("EndURL");


void CRefDial::GetISPFileSettings(LPTSTR lpszFile)
{
    
    TCHAR szTemp[INTERNET_MAX_URL_LENGTH];

    GetINTFromISPFile(lpszFile, 
                      (LPTSTR)cszBrandingSection, 
                      (LPTSTR)cszBrandingFlags, 
                      (int FAR *)&m_lBrandingFlags, 
                      BRAND_DEFAULT);

    // Read the Support Number
    if (ERROR_SUCCESS == GetDataFromISPFile(lpszFile,
                                     (LPTSTR)cszSupportSection,
                                     (LPTSTR)cszSupportNumber,
                                     szTemp,
                                     ARRAYSIZE(szTemp)))
        m_bstrSupportNumber = A2BSTR(szTemp);
    else
        m_bstrSupportNumber.Empty();


    if (ERROR_SUCCESS == GetDataFromISPFile(lpszFile,
                                     (LPTSTR)cszLoggingSection,
                                     (LPTSTR)cszStartURL,
                                     szTemp,
                                     ARRAYSIZE(szTemp)))
        m_bstrLoggingStartUrl = A2BSTR(szTemp);
    else
        m_bstrLoggingStartUrl.Empty();


    if (ERROR_SUCCESS == GetDataFromISPFile(lpszFile,
                                     (LPTSTR)cszLoggingSection,
                                     (LPTSTR)cszEndURL,
                                     szTemp,
                                     ARRAYSIZE(szTemp)))
        m_bstrLoggingEndUrl = A2BSTR(szTemp);
    else
        m_bstrLoggingEndUrl.Empty();

}

// This function will accept user selected values that are necessary to
// setup a connectiod for dialing
// Returns:
//      TRUE        OK to dial
//      FALSE       Some kind of problem
//                  QuitWizard - TRUE, then terminate
//                  UserPickNumber - TRUE, then display Pick a Number DLG
//                  QuitWizard and UserPickNumber both FALSE, then just
//                  display the page prior to Dialing UI.
STDMETHODIMP CRefDial::SetupForDialing
(
    BSTR bstrISPFile, 
    DWORD dwCountry, 
    BSTR bstrAreaCode, 
    DWORD dwFlag,
    BOOL *pbRetVal
)
{
    USES_CONVERSION;
    HRESULT             hr = S_OK;
    long                lRC = 0;
    LPLINECOUNTRYENTRY  pLCETemp;
    HINSTANCE           hPHBKDll = NULL;
    DWORD_PTR           dwPhoneBook = 0;
    DWORD               idx;
    BOOL                bSuccess = FALSE;
    BOOL                bConnectiodCreated = FALSE;   
    
    // Create a Window. We need a window, which will be hidden, so that we can process RAS status
    // messages
    RECT rcPos;
    Create(NULL, rcPos, NULL, 0, 0, 0 );
    
    // Initialize failure codes
    *pbRetVal = FALSE;
    m_bQuitWizard = FALSE;
    m_bUserPickNumber = FALSE;


    // Stuff the Area Code, and Country Code into the GatherInfo struct
    Assert(bstrAreaCode);
    lstrcpy(m_lpGatherInfo->m_szAreaCode,OLE2A(bstrAreaCode));

    m_lpGatherInfo->m_dwCountry = dwCountry;
    m_lpGatherInfo->m_dwFlag = dwFlag;

    // Make a copy of the ISP file we should use.
    Assert(bstrISPFile);
    m_bstrISPFile = bstrISPFile;

    // Read the ISP file stuff
    GetISPFileSettings(OLE2A(m_bstrISPFile));

    // Read the Connection File information which will create
    // a connectiod from the passed in ISP file
    switch(ReadConnectionInformation())
    {
        case ERROR_SUCCESS:
        {
            // Fill in static info into the GatherInfo sturct
            DWORD dwRet = FillGatherInfoStruct(m_lpGatherInfo);
            switch( dwRet )
            {
                case ERROR_FILE_NOT_FOUND:
                    MsgBox(IDS_MSNSU_WRONG,MB_MYERROR);
                    m_bQuitWizard = TRUE;
                    hr = S_FALSE;
                    break;
                case ERROR_SUCCESS:
                    //do nothing
                    break;
                default:
                    AssertMsg(dwRet, TEXT("FillGatherInfoStruct did not successfully complete.  DUNfile entry corrupt?"));
                    break;
            }
            break;
        }
        case ERROR_CANCELLED:
            hr = S_FALSE;
            m_bQuitWizard = TRUE;
            goto SetupForDialingExit;
            break;
        case ERROR_RETRY:
            m_bTryAgain = TRUE;
            hr = S_FALSE;
            break;
        default:
            MsgBox(IDS_MSNSU_WRONG,MB_MYERROR);
            hr = S_FALSE;
            break;
    }

    //  If we failed for some reason above, we need to return
    //  the error to the caller, and Quit The Wizard.
    if (S_OK != hr)
        goto SetupForDialingExit;

    //  we need to pass a valid window handle to  lineTranslateDialog 
    //  API call -MKarki (4/17/97) Fix for Bug #428
    //
    if (m_lpGatherInfo != NULL)
    {
        m_lpGatherInfo->m_hwnd = GetActiveWindow();
    }

    //
    // Fill in country
    //
    m_lpGatherInfo->m_pLineCountryList = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,sizeof(LINECOUNTRYLIST));
    Assert(m_lpGatherInfo->m_pLineCountryList);
    if (!(m_lpGatherInfo->m_pLineCountryList))
    {
        m_bQuitWizard = TRUE;
        MsgBox(IDS_OUTOFMEMORY,MB_MYERROR);
        goto SetupForDialingExit;
    }
    
    m_lpGatherInfo->m_pLineCountryList->dwTotalSize = sizeof(LINECOUNTRYLIST);

    //
    // figure out how much memory we will need
    //
    lRC = lineGetCountry(m_lpGatherInfo->m_dwCountry,0x10004,
                            m_lpGatherInfo->m_pLineCountryList);
    
    if ( lRC && lRC != LINEERR_STRUCTURETOOSMALL)
        AssertMsg(0,TEXT("lineGetCountry error"));
    
    Assert(m_lpGatherInfo->m_pLineCountryList->dwNeededSize);
    
    LPLINECOUNTRYLIST pLineCountryTemp;
    pLineCountryTemp = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR, 
                                                        ((size_t)m_lpGatherInfo->m_pLineCountryList->dwNeededSize));
    Assert (pLineCountryTemp);
    if (!pLineCountryTemp)
    {
        m_bQuitWizard = TRUE;
        MsgBox(IDS_OUTOFMEMORY,MB_MYERROR);
        goto SetupForDialingExit;        
    }
        
    //
    // initialize structure
    //
    pLineCountryTemp->dwTotalSize = m_lpGatherInfo->m_pLineCountryList->dwNeededSize;
    GlobalFree(m_lpGatherInfo->m_pLineCountryList);
    m_lpGatherInfo->m_pLineCountryList = pLineCountryTemp;
    pLineCountryTemp = NULL;

    //
    // fetch information from TAPI
    //
    lRC = lineGetCountry(m_lpGatherInfo->m_dwCountry,0x10004,
                            m_lpGatherInfo->m_pLineCountryList);
    if (lRC)
    {
        Assert(0);
        m_bQuitWizard = TRUE;
        // BUGBUG Probably should have an error message here
        goto SetupForDialingExit;
   }


    //
    // On Windows 95, lineGetCountry has a bug -- if we try to retrieve the 
    // dialing properties of just one country (i.e, if the first parameter is
    // not zero), it returns m_pLineCountryList->dwNumCountries = 0!!
    // But the m_pLineCountryList still has valid data
    //
    if (VER_PLATFORM_WIN32_NT != g_dwPlatform)
    {
        if (0 == m_lpGatherInfo->m_pLineCountryList->dwNumCountries)
            m_lpGatherInfo->m_pLineCountryList->dwNumCountries = 1;
    }

    pLCETemp = (LPLINECOUNTRYENTRY)((UINT_PTR)m_lpGatherInfo->m_pLineCountryList + 
                                    (UINT)m_lpGatherInfo->m_pLineCountryList->dwCountryListOffset);

    //
    // build look up array
    //
    m_lpGatherInfo->m_rgNameLookUp = (LPCNTRYNAMELOOKUPELEMENT)GlobalAlloc(GPTR,((size_t)(sizeof(CNTRYNAMELOOKUPELEMENT)
        * m_lpGatherInfo->m_pLineCountryList->dwNumCountries)));

    for (idx=0; idx < m_lpGatherInfo->m_pLineCountryList->dwNumCountries;
            idx++)
    {
        m_lpGatherInfo->m_rgNameLookUp[idx].psCountryName = (LPTSTR)((DWORD_PTR)m_lpGatherInfo->m_pLineCountryList + (DWORD)pLCETemp[idx].dwCountryNameOffset);
        m_lpGatherInfo->m_rgNameLookUp[idx].dwNameSize = pLCETemp[idx].dwCountryNameSize;
        m_lpGatherInfo->m_rgNameLookUp[idx].pLCE = &pLCETemp[idx];
        AssertMsg(m_lpGatherInfo->m_rgNameLookUp[idx].psCountryName[0],
                    TEXT("Blank country name in look up array"));
    }

    // Prepare to Setup for Dialing, which will use the phonebook
    // to get a suggested number 
    hPHBKDll = LoadLibrary(PHONEBOOK_LIBRARY);
    AssertMsg(hPHBKDll != NULL,TEXT("Phonebook DLL is missing"));
    if (!hPHBKDll)
    {
        //
        // TODO: BUGBUG Pop-up error message
        //
        m_bQuitWizard = TRUE;
        goto SetupForDialingExit;
    }

 
    // Setup, and possible create a connectiod
    hr = SetupForRASDialing(m_lpGatherInfo, 
                         hPHBKDll,
                         &dwPhoneBook,
                         &m_pSuggestInfo,
                         &m_szConnectoid[0],
                         &bConnectiodCreated);
    if (ERROR_SUCCESS != hr)
    {
        m_bQuitWizard = TRUE;
        goto SetupForDialingExit;
    }

    // If we have a RASENTRY struct from SetupForRASDialing, then just use it
    // otherwise use the suggest info
    if (!bConnectiodCreated)
    {
        
        // If there is only 1 suggested number, then we setup the
        // connectiod, and we are ready to dial
        if (1 == m_pSuggestInfo->wNumber)
        {
            SetupConnectoid(m_pSuggestInfo, 0, &m_szConnectoid[0],
                                sizeof(m_szConnectoid), &bSuccess);
            if( !bSuccess )
            {
                m_bQuitWizard = TRUE;
                goto SetupForDialingExit;
            }
        }
        else
        {
            // More than 1 entry in the Phonebook, so we need to
            // ask the user which one they want to use
            if (m_pSuggestInfo->wNumber > 1)
            {
                // we are going to have to save these values for later
                if (m_rgpSuggestedAE)
                {
                    // We allocated an extra pointer so we'd have NULL on the
                    // end of the list and this for loop will work
                    for (int i=0; m_rgpSuggestedAE[i]; i++)
                        GlobalFree(m_rgpSuggestedAE[i]);
                    GlobalFree(m_rgpSuggestedAE);
                    m_rgpSuggestedAE = NULL;
                }

                // We first need to allocate space for the pointers.
                // We'll allocate an extra one so that we will have
                // a NULL pointer at the end of the list for when
                // we free g_rgpSuggestedAE. We don't need to set
                // the pointers to NULL because GPTR includes a flag
                // to tell GlobalAlloc to initialize the memory to zero.
                m_rgpSuggestedAE = (PACCESSENTRY*)GlobalAlloc(GPTR,
                    sizeof(PACCESSENTRY)*(m_pSuggestInfo->wNumber + 1));

                if (NULL == m_rgpSuggestedAE)
                    hr = E_ABORT;
                else if (m_pSuggestInfo->rgpAccessEntry)
                {
                    for (UINT i=0; i < m_pSuggestInfo->wNumber; i++)
                    {
                        m_rgpSuggestedAE[i] = (PACCESSENTRY)GlobalAlloc(GPTR, sizeof(ACCESSENTRY));
                        if (NULL == m_rgpSuggestedAE[i])
                        {
                            hr = E_ABORT;
                            break; // for loop
                        }
                        memmove(m_rgpSuggestedAE[i], m_pSuggestInfo->rgpAccessEntry[i],
                                sizeof(ACCESSENTRY));
                    }
                    m_pSuggestInfo->rgpAccessEntry = m_rgpSuggestedAE;
                }

                if (E_ABORT == hr)
                {
                    MsgBox(IDS_OUTOFMEMORY,MB_MYERROR);
                    m_bQuitWizard = TRUE;
                    goto SetupForDialingExit;
                }

                m_bUserPickNumber = TRUE;
                goto SetupForDialingExit;
            }
            else
            {
                // Call RAS to have the user pick a number to dial
                hr = UserPickANumber(   GetActiveWindow(), m_lpGatherInfo, 
                                        m_pSuggestInfo,
                                        hPHBKDll,
                                        dwPhoneBook,
                                        &m_szConnectoid[0],
                                        sizeof(m_szConnectoid), 
                                        0);
                if (ERROR_USERBACK == hr)
                {
                    goto SetupForDialingExit;
                }
                else if (ERROR_USERCANCEL == hr)
                {
                    m_bQuitWizard = TRUE;
                    goto SetupForDialingExit;
                }
                else if (ERROR_SUCCESS != hr)
                {
                    // Go back to prev page.
                    goto SetupForDialingExit;
                }

                // Error SUCCESS will fall through and set pbRetVal to TRUE below
            }
        }
    }

    // Success if we get to here
    *pbRetVal = TRUE;

    // Generate a Displayable number
    m_hrDisplayableNumber = GetDisplayableNumber();

SetupForDialingExit:

    if (hPHBKDll)
    {
        if (dwPhoneBook)
        {
            FARPROC fp = GetProcAddress(hPHBKDll,PHBK_UNLOADAPI);
            ASSERT(fp);
            ((PFNPHONEBOOKUNLOAD)fp)(dwPhoneBook);
            dwPhoneBook = 0;
        }
        FreeLibrary(hPHBKDll);
        hPHBKDll = NULL;
    }
    return S_OK;
}


STDMETHODIMP CRefDial::RemoveConnectoid(BOOL * pVal)
{
    if (m_hrasconn)
        DoHangup();

    if (m_pSuggestInfo)
    {
        GlobalFree(m_pSuggestInfo->rgpAccessEntry);
        
        GlobalFree(m_pSuggestInfo);
        m_pSuggestInfo = NULL;
    }

    if( (m_pcRNA!=NULL) && (m_szConnectoid[0]!='\0') )
    {
       m_pcRNA->RasDeleteEntry(NULL,m_szConnectoid);
       delete m_pcRNA;
       m_pcRNA = NULL;
    }
    return S_OK;
}

STDMETHODIMP CRefDial::get_QuitWizard(BOOL * pVal)
{
    if (pVal == NULL)
         return E_POINTER;
    *pVal = m_bQuitWizard;    
    return S_OK;
}

STDMETHODIMP CRefDial::get_UserPickNumber(BOOL * pVal)
{
    if (pVal == NULL)
         return E_POINTER;
    *pVal = m_bUserPickNumber;    
    return S_OK;
}

STDMETHODIMP CRefDial::get_DialPhoneNumber(BSTR * pVal)
{
    USES_CONVERSION;
    if (pVal == NULL)
        return E_POINTER;
    if (m_hrDisplayableNumber == ERROR_SUCCESS)
        *pVal = A2BSTR(m_pszDisplayable);
    else
        *pVal = A2BSTR(m_szPhoneNumber);
    return S_OK;
}


STDMETHODIMP CRefDial::put_DialPhoneNumber(BSTR newVal)
{
    USES_CONVERSION;

    LPRASENTRY              lpRasEntry = NULL;
    LPRASDEVINFO            lpRasDevInfo = NULL;
    DWORD                   dwRasEntrySize = 0;
    DWORD                   dwRasDevInfoSize = 0;
    RNAAPI                  *pcRNA = NULL;
    HRESULT                 hr;

    // Get the current RAS entry properties
    hr = MyRasGetEntryProperties(NULL,
                                m_szConnectoid,
                                &lpRasEntry,
                                &dwRasEntrySize,
                                &lpRasDevInfo,
                                &dwRasDevInfoSize);

    if (NULL ==lpRasDevInfo)
    {
        dwRasDevInfoSize = 0;
    }

    if (hr == ERROR_SUCCESS && NULL != lpRasEntry)
    {
        // Replace the phone number with the new one
        //
        lstrcpy(lpRasEntry->szLocalPhoneNumber, OLE2A(newVal));

        // non-zero dummy values are required due to bugs in win95
        lpRasEntry->dwCountryID = 1;
        lpRasEntry->dwCountryCode = 1;
        lpRasEntry->szAreaCode[1] = '\0';
        lpRasEntry->szAreaCode[0] = '8';

        // Set to dial as is
        //
        lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;

        pcRNA = new RNAAPI;
        if (pcRNA)
        {
#if defined(DEBUG)
            TCHAR szMsg[256];
            OutputDebugString(TEXT("CRefDial::put_DialPhoneNumber - MyRasGetEntryProperties()"));
            wsprintf(szMsg, TEXT("lpRasEntry->dwfOptions: %ld"), lpRasEntry->dwfOptions);
            OutputDebugString(szMsg);
            wsprintf(szMsg, TEXT("lpRasEntry->dwCountryID: %ld"), lpRasEntry->dwCountryID);
            OutputDebugString(szMsg);
            wsprintf(szMsg, TEXT("lpRasEntry->dwCountryCode: %ld"), lpRasEntry->dwCountryCode);
            OutputDebugString(szMsg);
            wsprintf(szMsg, TEXT("lpRasEntry->szAreaCode: %s"), lpRasEntry->szAreaCode);
            OutputDebugString(szMsg);
            wsprintf(szMsg, TEXT("lpRasEntry->szLocalPhoneNumber: %s"), lpRasEntry->szLocalPhoneNumber);
            OutputDebugString(szMsg);
            wsprintf(szMsg, TEXT("lpRasEntry->dwAlternateOffset: %ld"), lpRasEntry->dwAlternateOffset);
            OutputDebugString(szMsg);
#endif //DEBUG

            pcRNA->RasSetEntryProperties(NULL,
                                         m_szConnectoid,
                                         (LPBYTE)lpRasEntry,
                                         dwRasEntrySize,
                                         (LPBYTE)lpRasDevInfo,
                                         dwRasDevInfoSize);

            delete pcRNA;
        }
    }

    // Regenerate the displayable number
    GetDisplayableNumber();

    return S_OK;
}

STDMETHODIMP CRefDial::get_URL(BSTR * pVal)
{
    USES_CONVERSION;
    TCHAR szTemp[256];

    if (pVal == NULL)
        return E_POINTER;

    // Get the URL from the ISP file, and then convert it
    if (SUCCEEDED(GetDataFromISPFile(OLE2A(m_bstrISPFile),INF_SECTION_ISPINFO, INF_REFERAL_URL,&szTemp[0],256)))
    {
        *pVal = A2BSTR(szTemp);
    }
    else
    {
        *pVal = NULL;
    }
    return S_OK;
}

STDMETHODIMP CRefDial::get_PromoCode(BSTR * pVal)
{
    if (pVal == NULL)
         return E_POINTER;
    *pVal = m_bstrPromoCode.Copy();    
    return S_OK;
}

STDMETHODIMP CRefDial::put_PromoCode(BSTR newVal)
{
    if (newVal && wcslen(newVal))
        m_bstrPromoCode = newVal;
    return S_OK;
}

STDMETHODIMP CRefDial::get_ProductCode(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    *pVal = m_bstrProductCode;
    return S_OK;
}

STDMETHODIMP CRefDial::put_ProductCode(BSTR newVal)
{
    if (newVal && wcslen(newVal))
        m_bstrProductCode = newVal;
    return S_OK;
}

STDMETHODIMP CRefDial::put_OemCode(BSTR newVal)
{
    USES_CONVERSION;

    if (newVal && wcslen(newVal))
        lstrcpy(m_szOEM, OLE2A(newVal));
    return S_OK;
}

STDMETHODIMP CRefDial::put_AllOfferCode(long newVal)
{
        m_lAllOffers = newVal;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoOfferDownload
//
//  Synopsis:   Download the ISP offer from the ISP server
//
//+---------------------------------------------------------------------------
STDMETHODIMP CRefDial::DoOfferDownload(BOOL *pbRetVal)
{
    HRESULT hr;
       RNAAPI  *pcRNA;

 
    //
    // Hide RNA window on Win95 retail
    //
//        MinimizeRNAWindow(m_pszConnectoid,g_hInst);
        // 4/2/97    ChrisK    Olympus 296
//        g_hRNAZapperThread = LaunchRNAReestablishZapper(g_hInst);
    //
    // The connection is open and ready.  Start the download.
    //
    m_dwThreadID = 0;
    m_hThread = CreateThread(NULL,
                             0,
                             (LPTHREAD_START_ROUTINE)DownloadThreadInit,
                             (LPVOID)this,
                             0,
                             &m_dwThreadID);

    // 5-1-97    ChrisK Olympus 2934
//    m_objBusyMessages.Start(m_hWnd,IDC_LBLSTATUS,m_hrasconn);

    // If we dont get the donwload thread, then kill the open
    // connection
    if (!m_hThread)
    {
        hr = GetLastError();
        if (m_hrasconn)
        {
            pcRNA = new RNAAPI;
            if (pcRNA)
            {
                pcRNA->RasHangUp(m_hrasconn);
                m_hrasconn = NULL;
                delete pcRNA;
                pcRNA = NULL;
            }
        }

        *pbRetVal = FALSE;
    }
    else
    {
        // Download has started.
        m_bDownloadHasBeenCanceled = FALSE;
        *pbRetVal = TRUE;
    }        
    return S_OK;
}

STDMETHODIMP CRefDial::get_DialStatusString(BSTR * pVal)
{
    USES_CONVERSION;
    if (pVal == NULL)
         return E_POINTER;
    if (m_RasStatusID)
    {
        if (m_bRedial)
        {
            switch (m_RasStatusID)
            {
                case IDS_RAS_DIALING:
                case IDS_RAS_PORTOPENED:
                case IDS_RAS_OPENPORT:
                {
                    *pVal = A2BSTR(GetSz(IDS_RAS_REDIALING));
                    return S_OK;
                }
                default:
                    break;
            }
        }    
        *pVal = A2BSTR(GetSz((USHORT)m_RasStatusID));
    }
    else
        *pVal = A2BSTR(TEXT(""));

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoInit
//
//  Synopsis:   Initialize cancel status and the displayable number for this
//              round of dialing.
//
//+---------------------------------------------------------------------------
STDMETHODIMP CRefDial::DoInit()
{
    m_bWaitingToHangup = FALSE;

    // Update the phone number to display if user has changed dialing properties
    // This function should be called re-init the dialing properties.
    // SetupforDialing should be called prior to this.
    GetDisplayableNumber();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoHangup
//
//  Synopsis:   Hangup the modem for the currently active RAS session
//
//+---------------------------------------------------------------------------
STDMETHODIMP CRefDial::DoHangup()
{
    RNAAPI  *pcRNA;

    // Set the disconnect flag as the system may be too busy with dialing.
    // Once we get a chance to terminate dialing, we know we have to hangup
    m_bWaitingToHangup = TRUE;
    if (NULL != m_hrasconn)
    {
        pcRNA = new RNAAPI;
        if (pcRNA)
        {
            pcRNA->RasHangUp(m_hrasconn);
            m_hrasconn = NULL;
            delete pcRNA;
            pcRNA = NULL;
        }
    }

    return (m_hrasconn == NULL) ? S_OK : E_POINTER;
}


STDMETHODIMP CRefDial::ProcessSignedPID(BOOL * pbRetVal)
{
    USES_CONVERSION;
    HANDLE  hfile;
    DWORD   dwFileSize;
    DWORD   dwBytesRead;
    LPBYTE  lpbSignedPID;
    LPTSTR  lpszSignedPID;

    *pbRetVal = FALSE;

    // Open the PID file for Binary Reading.  It will be in the CWD
    if (INVALID_HANDLE_VALUE != (hfile = CreateFile(c_szSignedPIDFName,
                                                  GENERIC_READ,
                                                  0,
                                                  NULL,
                                                  OPEN_EXISTING,
                                                  FILE_ATTRIBUTE_NORMAL,
                                                  NULL)))
    {
        dwFileSize = GetFileSize(hfile, NULL);
        
        // Allocate a buffer to read the file, and one to store the BINHEX version
        lpbSignedPID = new BYTE[dwFileSize];
        lpszSignedPID = new TCHAR[(dwFileSize * 2) + 1];

        if (lpbSignedPID && lpszSignedPID)
        {
            if (ReadFile(hfile, (LPVOID) lpbSignedPID, dwFileSize, &dwBytesRead, NULL) &&
                    (dwFileSize == dwBytesRead))
            {
                // BINHEX the signed PID data so we can send it to the signup server
                DWORD   dwX = 0;
                BYTE    by;
                for (DWORD dwY = 0; dwY < dwFileSize; dwY++)
                {
                    by = lpbSignedPID[dwY];
                    lpszSignedPID[dwX++] = g_BINTOHEXLookup[((by & 0xF0) >> 4)];
                    lpszSignedPID[dwX++] = g_BINTOHEXLookup[(by & 0x0F)];
                }
                lpszSignedPID[dwX] = '\0';

                // Convert the signed pid to a BSTR
                m_bstrSignedPID = A2BSTR(lpszSignedPID);

                // Set the return value
                *pbRetVal = TRUE;
            }
        }

        // Free the buffers we allocated
        if (lpbSignedPID)
        {
            delete[] lpbSignedPID;
        }
        if (lpszSignedPID)
        {
            delete[] lpszSignedPID;
        }

        // Close the File
        CloseHandle(hfile);

#ifndef DEBUG
        // Delete the File
        // defer removal of this file until the container app exits.
        // see BUG 373.
        //DeleteFile(c_szSignedPIDFName);
#endif
    }

    return S_OK;
}

STDMETHODIMP CRefDial::get_SignedPID(BSTR * pVal)
{
    if (pVal == NULL)
         return E_POINTER;
    *pVal = m_bstrSignedPID.Copy();    
    return S_OK;
}

STDMETHODIMP CRefDial::FormReferralServerURL(BOOL * pbRetVal)
{
    // Form the URL to be used to access the referal server
    if (ERROR_SUCCESS != FormURL())
        *pbRetVal = FALSE;
    else
        *pbRetVal = TRUE;

    return S_OK;
}

STDMETHODIMP CRefDial::get_SignupURL(BSTR * pVal)
{
    USES_CONVERSION;
    TCHAR szTemp[256];

    if (pVal == NULL)
        return E_POINTER;

    // Get the URL from the ISP file, and then convert it
    if (SUCCEEDED(GetDataFromISPFile(OLE2A(m_bstrISPFile),INF_SECTION_URL, INF_SIGNUP_URL,&szTemp[0],256)))
    {
        *pVal = A2BSTR(szTemp);
    }
    else
    {
        *pVal = NULL;
    }
    return S_OK;
}

STDMETHODIMP CRefDial::get_AutoConfigURL(BSTR * pVal)
{
    USES_CONVERSION;
    TCHAR szTemp[256];

    if (pVal == NULL)
        return E_POINTER;

    // Get the URL from the ISP file, and then convert it
    if (SUCCEEDED(GetDataFromISPFile(OLE2A(m_bstrISPFile),INF_SECTION_URL, INF_AUTOCONFIG_URL,&szTemp[0],256)))
    {
        *pVal = A2BSTR(szTemp);
    }
    else
    {
        *pVal = NULL;
    }
    return S_OK;
}

STDMETHODIMP CRefDial::get_ISDNURL(BSTR * pVal)
{
    USES_CONVERSION;
    TCHAR szTemp[256];

    if (pVal == NULL)
        return E_POINTER;

    // Get the ISDN URL from the ISP file, and then convert it
    if (SUCCEEDED(GetDataFromISPFile(OLE2A(m_bstrISPFile),INF_SECTION_URL, INF_ISDN_URL,&szTemp[0],256)))
    {
        *pVal = A2BSTR(szTemp);
    }
    else
    {
        *pVal = NULL;
    }
    if (0 == szTemp[0] || NULL == *pVal)
    {
        // Get the sign up URL from the ISP file, and then convert it
        if (SUCCEEDED(GetDataFromISPFile(OLE2A(m_bstrISPFile),INF_SECTION_URL, INF_SIGNUP_URL,&szTemp[0],256)))
        {
            *pVal = A2BSTR(szTemp);
        }
        else
        {
            *pVal = NULL;
        }

    }
    return S_OK;
}

STDMETHODIMP CRefDial::get_ISDNAutoConfigURL(BSTR * pVal)
{
    USES_CONVERSION;
    TCHAR szTemp[256];

    if (pVal == NULL)
        return E_POINTER;

    // Get the URL from the ISP file, and then convert it
    if (SUCCEEDED(GetDataFromISPFile(OLE2A(m_bstrISPFile),INF_SECTION_URL, INF_ISDN_AUTOCONFIG_URL,&szTemp[0],256)))
    {
        *pVal = A2BSTR(szTemp);
    }
    else
    {
        *pVal = NULL;
    }
    return S_OK;
}

STDMETHODIMP CRefDial::get_TryAgain(BOOL * pVal)
{
    if (pVal == NULL)
         return E_POINTER;
    *pVal = m_bTryAgain;    
    return S_OK;
}

STDMETHODIMP CRefDial::get_DialError(HRESULT * pVal)
{
    *pVal = m_hrDialErr;
    
    return S_OK;
}

STDMETHODIMP CRefDial::put_ModemOverride(BOOL newbVal)
{
    m_bModemOverride = newbVal;
    return S_OK;
}

STDMETHODIMP CRefDial::put_Redial(BOOL newbVal)
{
    m_bRedial = newbVal;

    return S_OK;
}

STDMETHODIMP CRefDial::get_DialErrorMsg(BSTR * pVal)
{
    USES_CONVERSION;

    if (pVal == NULL)
        return E_POINTER;

    if (m_hrDialErr != ERROR_SUCCESS)
    {
        DWORD dwIDS = RasErrorToIDS(m_hrDialErr);
        if (dwIDS != -1 && dwIDS !=0)
        {
            *pVal = A2BSTR(GetSz((WORD)dwIDS));
        }
        else
        {
            *pVal = A2BSTR(GetSz(IDS_PPPRANDOMFAILURE));
        }
    }
    else
    {
        *pVal = A2BSTR(GetSz(IDS_PPPRANDOMFAILURE));
    }
    return S_OK;
}

STDMETHODIMP CRefDial::ModemEnum_Reset()
{
    m_emModemEnum.ResetIndex();

    return S_OK;
}

STDMETHODIMP CRefDial::ModemEnum_Next(BSTR *pDeviceName)
{
    if (pDeviceName == NULL)
        return E_POINTER;

    *pDeviceName = A2BSTR(m_emModemEnum.Next());
    return S_OK;
}

STDMETHODIMP CRefDial::get_ModemEnum_NumDevices(long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    m_emModemEnum.ReInit();
    *pVal = m_emModemEnum.GetNumDevices();

    if(m_ISPImport.m_szDeviceName[0]!='\0')
    {
        //
        // Find out what the current device index is
        //
        for(int l=0; l<(*pVal); l++)
        {
            if(lstrcmp(m_ISPImport.m_szDeviceName,m_emModemEnum.GetDeviceName(l))==0)
            {
                m_lCurrentModem = l;
                break;
            }
        }
        if(l == (*pVal))
            m_lCurrentModem = -1;
    }
    else
        m_lCurrentModem = -1;
    
    return S_OK;
}

STDMETHODIMP CRefDial::get_SupportNumber(BSTR * pVal)
{
    USES_CONVERSION;

    TCHAR    szSupportNumber[MAX_PATH];

    if (pVal == NULL)
        return E_POINTER;

    if (m_SupportInfo.GetSupportInfo(szSupportNumber, m_dwCountryCode))
        *pVal = A2BSTR(szSupportNumber);
    else
        *pVal = NULL;

    return S_OK;
}

STDMETHODIMP CRefDial::get_ISPSupportNumber(BSTR * pVal)
{
    USES_CONVERSION;

    if (pVal == NULL)
        return E_POINTER;

    if (*m_szISPSupportNumber)
        *pVal = A2BSTR(m_szISPSupportNumber);
    else
        *pVal = NULL;

    return S_OK;
}

STDMETHODIMP CRefDial::ShowDialingProperties(BOOL * pbRetVal)
{
    HRESULT hr;
    DWORD   dwNumDev = 0;

    *pbRetVal = FALSE;
    
    hr = lineInitialize(&m_hLineApp,_Module.GetModuleInstance(),LineCallback,(LPSTR)NULL,&dwNumDev);

    if (hr == ERROR_SUCCESS)
    {
        LPLINEEXTENSIONID lpExtensionID;
        
        
        if (m_dwTapiDev == 0xFFFFFFFF)
        {
                m_dwTapiDev = 0;
        }

        lpExtensionID = (LPLINEEXTENSIONID)GlobalAlloc(GPTR,sizeof(LINEEXTENSIONID));
        if (lpExtensionID)
        {
            //
            // Negotiate version - without this call
            // lineTranslateDialog would fail
            //
            do {
                hr = lineNegotiateAPIVersion(m_hLineApp, 
                                             m_dwTapiDev, 
                                             0x00010004, 0x00010004,
                                             &m_dwAPIVersion, 
                                             lpExtensionID);

            } while ((hr != ERROR_SUCCESS) && (m_dwTapiDev++ < dwNumDev - 1));

            if (m_dwTapiDev >= dwNumDev)
            {
                m_dwTapiDev = 0;
            }

            //
            // ditch it since we don't use it
            //
            GlobalFree(lpExtensionID);
            lpExtensionID = NULL;

            if (hr == ERROR_SUCCESS)
            {
                hr = lineTranslateDialog(m_hLineApp,
                                         m_dwTapiDev,
                                         m_dwAPIVersion,
                                         GetActiveWindow(),
                                         m_szPhoneNumber);

                lineShutdown(m_hLineApp);
                m_hLineApp = NULL;
            }
        }
    }
    
    if (hr == ERROR_SUCCESS)
    {
        GetDisplayableNumber();
        *pbRetVal = TRUE;
    }        
    
    return S_OK;
}

STDMETHODIMP CRefDial::ShowPhoneBook(DWORD dwCountryCode, long newVal, BOOL * pbRetVal)
{
    USES_CONVERSION;

    DWORD_PTR   dwPhoneBook;
    HINSTANCE   hPHBKDll;
    FARPROC     fp;
    BOOL        bBookLoaded = FALSE;

    *pbRetVal = FALSE;      // Assume Failure

    hPHBKDll = LoadLibrary(PHONEBOOK_LIBRARY);
    if (hPHBKDll)
    {
        if (NULL != (fp = GetProcAddress(hPHBKDll,PHBK_LOADAPI)))
        {
            if (ERROR_SUCCESS  == ((PFNPHONEBOOKLOAD)fp)(OLE2A(m_bstrISPFile),&dwPhoneBook))
            {
                bBookLoaded = TRUE;
                m_pSuggestInfo->dwCountryID = dwCountryCode;

                // Update the device type so we can distinguish ISDN numbers
                TCHAR *pszNewType = m_emModemEnum.GetDeviceType(newVal);
                m_ISPImport.m_bIsISDNDevice = (lstrcmpi(pszNewType, RASDT_Isdn) == 0);
                m_lpGatherInfo->m_fType = TYPE_SIGNUP_ANY | (m_ISPImport.m_bIsISDNDevice ? MASK_ISDN_BIT:MASK_ANALOG_BIT);
                m_lpGatherInfo->m_bMask = MASK_SIGNUP_ANY | (m_ISPImport.m_bIsISDNDevice ? MASK_ISDN_BIT:MASK_ANALOG_BIT);

                if (ERROR_SUCCESS == UserPickANumber(GetActiveWindow(), 
                                                     m_lpGatherInfo, 
                                                     m_pSuggestInfo,
                                                     hPHBKDll,
                                                     dwPhoneBook,
                                                     &m_szConnectoid[0],
                                                     sizeof(m_szConnectoid),
                                                     DIALERR_IN_PROGRESS))
                {
                    // Regenerate the displayable number
                    GetDisplayableNumber();
                    
                    // Base the Country code on the ras entry, since it was
                    // directly modified in this case
                    LPRASENTRY              lpRasEntry = NULL;
                    LPRASDEVINFO            lpRasDevInfo = NULL;
                    DWORD                   dwRasEntrySize = 0;
                    DWORD                   dwRasDevInfoSize = 0;
                    
                    if (SUCCEEDED(MyRasGetEntryProperties(NULL,
                                                        m_szConnectoid,
                                                        &lpRasEntry,
                                                        &dwRasEntrySize,
                                                        &lpRasDevInfo,
                                                        &dwRasDevInfoSize)))
                    {
                        m_dwCountryCode = lpRasEntry->dwCountryCode;
                    }
                    
                    // Set the return code
                    *pbRetVal = TRUE;
                }
            }
        }
        FreeLibrary(hPHBKDll);
    }


    if (! bBookLoaded)
    {
        // Give the user a message
        MsgBox(IDS_CANTINITPHONEBOOK,MB_MYERROR);
    }
    return S_OK;
}

BOOL CRefDial::IsSBCSString( TCHAR *sz )
{
    Assert(sz);

#ifdef UNICODE
    // Check if the string contains only ASCII chars.
    int attrib = IS_TEXT_UNICODE_ASCII16 | IS_TEXT_UNICODE_CONTROLS;
    return (BOOL)IsTextUnicode(sz, lstrlen(sz), &attrib);
#else
    while( NULL != *sz )
    {
         if (IsDBCSLeadByte(*sz)) return FALSE;
         sz++;
    }

    return TRUE;
#endif
}

TCHAR szValidPhoneCharacters[] = {TEXT("0123456789AaBbCcDdPpTtWw!@$ -.()+*#,&\0")};

STDMETHODIMP CRefDial::ValidatePhoneNumber(BSTR bstrPhoneNumber, BOOL * pbRetVal)
{
    USES_CONVERSION;

    // Bail if an empty string is passed
    if (!bstrPhoneNumber || !wcslen(bstrPhoneNumber))
    {
        MsgBox(IDS_INVALIDPHONE,MB_MYERROR);
        *pbRetVal = FALSE;
        return(S_OK);
    }
    
    // Check that the phone number only contains valid characters
    LPTSTR   lpNum, lpValid;
    LPTSTR   lpszDialNumber = OLE2A(bstrPhoneNumber);

    // vyung 03/06/99 Remove Easter egg as requested by NT5
#ifdef ICW_EASTEREGG
    if (lstrcmp(lpszDialNumber, c_szCreditsMagicNum) == 0)
    {
        ShowCredits();
        *pbRetVal = FALSE;
        return(S_OK);
    }
#endif
    
    *pbRetVal = TRUE;

    if (!IsSBCSString(lpszDialNumber))
    {
        MsgBox(IDS_SBCSONLY,MB_MYEXCLAMATION);
        *pbRetVal = FALSE;
    }
    else
    {

        for (lpNum = lpszDialNumber;*lpNum;lpNum++)
        {
            for(lpValid = szValidPhoneCharacters;*lpValid;lpValid++)
            {
                if (*lpNum == *lpValid)
                {
                    break; // p2 for loop
                }
            }
            if (!*lpValid) 
            {
                break; // p for loop
            }
        }
    }

    if (*lpNum)
    {
        MsgBox(IDS_INVALIDPHONE,MB_MYERROR);
        *pbRetVal = FALSE;
    }

    return S_OK;
}

STDMETHODIMP CRefDial::get_HavePhoneBook(BOOL * pVal)
{
    USES_CONVERSION;

    DWORD_PTR   dwPhoneBook;
    HINSTANCE   hPHBKDll;
    FARPROC     fp;

    if (pVal == NULL)
        return E_POINTER;

    // Assume failure.
    *pVal = FALSE;

    // Try to load the phone book
    hPHBKDll = LoadLibrary(PHONEBOOK_LIBRARY);
    if (hPHBKDll)
    {
        if (NULL != (fp = GetProcAddress(hPHBKDll,PHBK_LOADAPI)))
        {
            if (ERROR_SUCCESS  == ((PFNPHONEBOOKLOAD)fp)(OLE2A(m_bstrISPFile),&dwPhoneBook))
            {
                *pVal = TRUE;    // Got IT!
            }
        }
        FreeLibrary(hPHBKDll);
    }
    return S_OK;
}

STDMETHODIMP CRefDial::get_BrandingFlags(long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    *pVal = m_lBrandingFlags;

    return S_OK;
}

STDMETHODIMP CRefDial::put_BrandingFlags(long newVal)
{
    m_lBrandingFlags = newVal;

    return S_OK;
}

/**********************************************************************/
//  
// FUNCTION:   get_CurrentModem
//             put_CurrentModem
//
// DESCRIPTION:
//   These functions are used to set the current modem
//   based on the enumerated modem list, and should only
//   be used after taking a snapshot of the modem list
//   with the ModemEnum_* functions.  The functions are also
//   intended to be used with an existing RAS connectoid, not
//   to set-up the RefDial object before connecting.
//
// HISTORY:
//
//   donsc - 3/11/98   Added these functions to support the dial error
//                     page in the HTML JavaScript code.
//
/**********************************************************************/

//
// get_CurrentModem will return -1 if the modem list was not enumerated
// or no modem has been selected for this RefDial object
//
STDMETHODIMP CRefDial::get_CurrentModem(long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    *pVal = m_lCurrentModem;

    return S_OK;
}


STDMETHODIMP CRefDial::put_CurrentModem(long newVal)
{
    LPRASENTRY              lpRasEntry = NULL;
    LPRASDEVINFO            lpRasDevInfo = NULL;
    DWORD                   dwRasEntrySize = 0;
    DWORD                   dwRasDevInfoSize = 0;
    RNAAPI                  *pcRNA = NULL;
    HRESULT                 hr = S_OK;

    TCHAR *pszNewName = m_emModemEnum.GetDeviceName(newVal);
    TCHAR *pszNewType = m_emModemEnum.GetDeviceType(newVal);

    if((pszNewName==NULL) || (pszNewType==NULL))
        return E_INVALIDARG;

    if(m_lCurrentModem == newVal)
        return S_OK;

    //
    // Must have a connectoid already established to set the
    // current modem.
    //
    if(m_szConnectoid[0]=='\0')
        return E_FAIL;

    // Get the current RAS entry properties
    hr = MyRasGetEntryProperties(NULL,
                                m_szConnectoid,
                                &lpRasEntry,
                                &dwRasEntrySize,
                                &lpRasDevInfo,
                                &dwRasDevInfoSize);

    //
    // The MyRas function returns 0 on success, not technically
    // an HRESULT
    //
    if(hr!=0 || NULL == lpRasEntry)
        hr = E_FAIL;

    lpRasDevInfo = NULL;
    dwRasDevInfoSize = 0;

    if (SUCCEEDED(hr))
    {
        //
        // Retrieve the dial entry params of the existing entry
        //
        LPRASDIALPARAMS lpRasDialParams = (LPRASDIALPARAMS)GlobalAlloc(GPTR,sizeof(RASDIALPARAMS));
        BOOL bPW = FALSE;

        if (!lpRasDialParams)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto PutModemExit;
        }
        lpRasDialParams->dwSize = sizeof(RASDIALPARAMS);
        lstrcpyn(lpRasDialParams->szEntryName,m_szConnectoid,ARRAYSIZE(lpRasDialParams->szEntryName));
        bPW = FALSE;
        hr = MyRasGetEntryDialParams(NULL,lpRasDialParams,&bPW);
        
        if (FAILED(hr))
            goto PutModemExit;

        //
        // Enter the new ras device info.
        //
        lstrcpy(lpRasEntry->szDeviceName,pszNewName);
        lstrcpy(lpRasEntry->szDeviceType,pszNewType);

        //
        // Set to dial as is
        //

        pcRNA = new RNAAPI;
        if (pcRNA)
        {
            //
            // When changing the actual device, it is not always reliable
            // to just set the new properties. We need to remove the
            // previous entry and create a new one.
            //
            pcRNA->RasDeleteEntry(NULL,m_szConnectoid);
            
            if(pcRNA->RasSetEntryProperties(NULL,
                                        m_szConnectoid,
                                        (LPBYTE)lpRasEntry,
                                        dwRasEntrySize,
                                        (LPBYTE)NULL,
                                        0)==0)
            {
                //
                // And set the other dialing parameters
                //
                if(pcRNA->RasSetEntryDialParams(NULL,lpRasDialParams,!bPW)!=0)
                    hr = E_FAIL;
            }
            else
                hr = E_FAIL;

            delete pcRNA;
        }
        else
            hr = E_FAIL;

        GlobalFree(lpRasDialParams);
    }

PutModemExit:

    if(SUCCEEDED(hr))
    {
        m_lCurrentModem = newVal;
        lstrcpy(m_ISPImport.m_szDeviceName,pszNewName);
        lstrcpy(m_ISPImport.m_szDeviceType,pszNewType);
        
        // Get the device name and type in the registry, since ConfigRasEntryDevice
        // will use them.  ConfigRasEntryDevice is called when the new connectoid
        // is being created, so if the user changes the modem, we want that
        // reflected in the new connectoid (BUG 20841)
        m_ISPImport.SetDeviceSelectedByUser(DEVICENAMEKEY, pszNewName);
        m_ISPImport.SetDeviceSelectedByUser (DEVICETYPEKEY, pszNewType);

        m_ISPImport.m_bIsISDNDevice = (lstrcmpi(pszNewType, RASDT_Isdn) == 0);
        m_lpGatherInfo->m_fType = TYPE_SIGNUP_ANY | (m_ISPImport.m_bIsISDNDevice ? MASK_ISDN_BIT:MASK_ANALOG_BIT);
        m_lpGatherInfo->m_bMask = MASK_SIGNUP_ANY | (m_ISPImport.m_bIsISDNDevice ? MASK_ISDN_BIT:MASK_ANALOG_BIT);
    }

    return hr;
}

STDMETHODIMP CRefDial::get_ISPSupportPhoneNumber(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    *pVal = m_bstrSupportNumber.Copy();
    return S_OK;
}

STDMETHODIMP CRefDial::put_ISPSupportPhoneNumber(BSTR newVal)
{
    // TODO: Add your implementation code here
    m_bstrSupportNumber = newVal;
    return S_OK;
}

STDMETHODIMP CRefDial::get_LoggingStartUrl(BSTR * pVal)
{
    if(pVal == NULL)
        return E_POINTER;

    *pVal = m_bstrLoggingStartUrl;

    return S_OK;
}

STDMETHODIMP CRefDial::get_LoggingEndUrl(BSTR * pVal)
{
    if(pVal == NULL)
        return E_POINTER;

    *pVal = m_bstrLoggingEndUrl;

    return S_OK;
}


void CRefDial::ShowCredits()
{
#ifdef ICW_EASTEREGG

    HINSTANCE   hinstMSHTML = LoadLibrary(TEXT("MSHTML.DLL"));

    if(hinstMSHTML)
    {
        SHOWHTMLDIALOGFN  *pfnShowHTMLDialog;
      
        pfnShowHTMLDialog = (SHOWHTMLDIALOGFN*)GetProcAddress(hinstMSHTML, "ShowHTMLDialog");

        if(pfnShowHTMLDialog)
        {
            IMoniker *pmk;
            TCHAR    szTemp[MAX_PATH*2];
            BSTR     bstr;

            lstrcpy(szTemp, TEXT("res://"));
            GetModuleFileName(_Module.GetModuleInstance(), szTemp + lstrlen(szTemp), ARRAYSIZE(szTemp) - lstrlen(szTemp));
            lstrcat(szTemp, TEXT("/CREDITS_RESOURCE"));

            bstr = A2BSTR((LPTSTR) szTemp);

            CreateURLMoniker(NULL, bstr, &pmk);

            if(pmk)
            {
                HRESULT  hr;
                VARIANT  varReturn;
         
                VariantInit(&varReturn);

                hr = (*pfnShowHTMLDialog)(NULL, pmk, NULL, NULL, &varReturn);

                pmk->Release();
            }
            SysFreeString(bstr);
        }
        FreeLibrary(hinstMSHTML);
    }
#endif
}



        
STDMETHODIMP CRefDial::SelectedPhoneNumber(long newVal, BOOL * pbRetVal)
{
    BOOL bSuccess = FALSE;
    
    *pbRetVal = TRUE;
    
    SetupConnectoid(m_pSuggestInfo, 
                    newVal, 
                    &m_szConnectoid[0],
                    sizeof(m_szConnectoid), 
                    &bSuccess);
    if( !bSuccess )
    {
        m_bQuitWizard = TRUE;
        *pbRetVal = FALSE;
    }
    else
    {
        // Generate a Displayable number
        m_hrDisplayableNumber = GetDisplayableNumber();
    }
    return S_OK;
}
        
STDMETHODIMP CRefDial::PhoneNumberEnum_Reset()
{
    m_PhoneNumberEnumidx = 0;

    return S_OK;
}

#define MAX_PAN_NUMBER_LEN 64
STDMETHODIMP CRefDial::PhoneNumberEnum_Next(BSTR *pNumber)
{
    TCHAR            szTemp[MAX_PAN_NUMBER_LEN + 1];
    PACCESSENTRY    pAE;

    if (pNumber == NULL)
        return E_POINTER;

    if (m_PhoneNumberEnumidx > m_pSuggestInfo->wNumber - 1)        
        m_PhoneNumberEnumidx = m_pSuggestInfo->wNumber -1;
    
    pAE = m_pSuggestInfo->rgpAccessEntry[m_PhoneNumberEnumidx];
    wsprintf(szTemp,TEXT("%s (%s) %s"),pAE->szCity,pAE->szAreaCode,pAE->szAccessNumber);
    
    ++m_PhoneNumberEnumidx;
    
    *pNumber = A2BSTR(szTemp);
    return S_OK;
}

STDMETHODIMP CRefDial::get_PhoneNumberEnum_NumDevices(long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    m_PhoneNumberEnumidx = 0;
    *pVal = m_pSuggestInfo->wNumber;
        
    return S_OK;
}

STDMETHODIMP CRefDial::get_bIsISDNDevice(BOOL *pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // NOTE SetupForDialing needs to be called before this API, otherwise the return
    // value is really undefined

    // Set the return value based on the ISPImport object (that is the object which
    // imports the data from the .ISP file, and also selects the RAS device used
    // to connect
    
    *pVal = m_ISPImport.m_bIsISDNDevice;
    
    return (S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   get_RasGetConnectStatus
//
//  Synopsis:   Checks for existing Ras connection
//
//+---------------------------------------------------------------------------
STDMETHODIMP CRefDial::get_RasGetConnectStatus(BOOL *pVal)
{
    RNAAPI      *pcRNA;
    HRESULT     hr = E_FAIL;
    *pVal = FALSE;

    if (NULL != m_hrasconn)
    {
        RASCONNSTATUS rasConnectState;
        rasConnectState.dwSize = sizeof(RASCONNSTATUS);
        pcRNA = new RNAAPI;
        if (pcRNA)
        {
            if (0 == pcRNA->RasGetConnectStatus(m_hrasconn, 
                                       &rasConnectState))
            {
                if (RASCS_Disconnected != rasConnectState.rasconnstate)
                    *pVal = TRUE;
            }
            delete pcRNA;
            pcRNA = NULL;
            hr = S_OK;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by icwhelp.rc
//
#define IDS_PROJNAME                    100
#define IDS_OUTOFMEMORY                 101
#define IDS_TITLE                       102
#define IDS_TMPVAR                      103
#define IDS_TEMPVAR                     104
#define IDS_CANTREADMSDUNFILE           105
#define IDS_CANTREADTHISFILE            106
#define IDS_NODIALOUT                   107
#define IDS_NOPHONEENTRY                108
#define IDS_CANTREADMSNSUISP            109
#define IDS_CANTSAVEKEY                 110
#define IDS_CANTREADKEY                 111
#define IDS_WANTTOEXIT                  112
#define IDS_AREACODEREQUIRED            113
#define IDS_EXCHCODEREQUIRED            114
#define IDS_CANTINITPHONEBOOK           115
#define IDS_CONNECTED_TO                116
#define IDS_REDIAL                      117
#define IDS_REESTABLISH                 118
#define IDS_CANTLOADINETCFG             119
#define IDS_MSNSU_WRONG                 120
#define IDS_CORRUPTPHONEBOOK            121
#define IDS_INVALIDPN                   122
#define IDS_RAS_DIALING                 124
#define IDS_RAS_PORTOPENED              125
#define IDS_RAS_OPENPORT                126
#define IDS_RAS_CONNECTED               127
#define IDS_RAS_LOCATING                128
#define IDS_RAS_HANGINGUP               129
#define IDS_RAS_CONNECTING              130
#define IDS_RECEIVING_RESPONSE          131
#define IDS_CANTLOADCONFIGAPI           132
#define IDS_EXITFAILED                  133
#define IDS_CONFIGAPIFAILED             134
#define IDS_CONFIGAPIFAILEDRETRY        135
#define IDS_CONFIGURENTFAILED           136
#define IDS_CONFIGURENTFAILEDRETRY      137
#define IDS_CANNOTPROCESSINS            139
#define IDS_MAILFAILED                  140
#define IDS_BADSETTINGS                 141
#define IDS_EXECFAILED                  142
#define IDS_PASSWORD                    143
#define IDS_SIGNUPCANCELLED             144
#define IDS_PPPRANDOMFAILURE            145
#define IDS_NOANSWER                    146
#define IDS_RASNOCARRIER                147
#define IDS_TCPINSTALLERROR             148
#define IDS_PHONEBUSY                   149
#define IDS_NODIALTONE                  150
#define IDS_NODEVICE                    151
#define IDS_USERCANCELEDDIAL            152
#define IDS_DOWNLOAD_NOT_FOUND          153
#define IDS_CANTDOWNLOAD                154
#define IDS_MEDIAINIERROR               155
#define IDS_SERVICEDISABLED             156
#define IDS_SUPPORTMSG                  157
#define IDS_INVALIDPHONE                158
#define IDS_SBCSONLY                    159
#define IDS_INSTALLFAILED               160
#define IDS_SBSCFGERROR                 161
#define IDS_PWCACHE_DISABLED1           164
#define IDS_PWCACHE_DISABLED2           165
#define IDS_RAS_REDIALING               166
#define IDS_CONNECTED                   167
#define IDS_TIMEOUT                     168
#define IDS_DOWNLOADING                 169
#define IDS_DOWNLOAD_COMPLETE           170

#define IDI_PHONE                       500
#define IDI_IE                          501
#define IDC_MODEM                       600
#define IDC_CMDOK                       601
#define IDC_CMDCANCEL                   602
#define IDR_REFDIAL                     1036
#define IDR_DIALERR                     1037
#define IDD_CHOOSEMODEMNAME             1038
#define IDR_SMARTSTART                  1039
#define IDR_ICWSYSTEMCONFIG             1040
#define IDR_TAPILOCATIONINFO            1041
#define IDR_USERINFO                    1042
#define IDR_WEBGATE                     1043
#define IDR_INSHANDLER                  1044
#define IDD_AUTODISCONNECT              1045
#define IDC_SECONDS                     1047
#define IDC_IDLE_TEXT                   1048
#define IDC_DISCONNECT_TEXT             1049
#define IDC_SEC_TEXT                    1050

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         603
#define _APS_NEXT_SYMED_VALUE           1047
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\misc.cpp ===
/*-----------------------------------------------------------------------------
    misc.cpp

    service functions

  History:
        1/7/98      DONALDM Moved to new ICW project and string
                    and nuked 16 bit stuff
-----------------------------------------------------------------------------*/

#include "stdafx.h"
#include <stdio.h>

#if defined (DEBUG)
#include "refdial.h"
#endif

#define DIR_SIGNUP  TEXT("signup")
#define DIR_WINDOWS TEXT("windows")
#define DIR_SYSTEM  TEXT("system")
#define DIR_TEMP    TEXT("temp")

BOOL g_bGotProxy=FALSE; 

#if defined (DEBUG)
extern TCHAR g_BINTOHEXLookup[16];
#endif

//+---------------------------------------------------------------------------
//
//    Function:    ProcessDBCS
//
//    Synopsis:    Converts control to use DBCS compatible font
//                Use this at the beginning of the dialog procedure
//    
//                Note that this is required due to a bug in Win95-J that prevents
//                it from properly mapping MS Shell Dlg.  This hack is not needed
//                under winNT.
//
//    Arguments:    hwnd - Window handle of the dialog
//                cltID - ID of the control you want changed.
//
//    Returns:    ERROR_SUCCESS
// 
//    History:    4/31/97 a-frankh    Created
//                5/13/97    jmazner        Stole from CM to use here
//----------------------------------------------------------------------------
void ProcessDBCS(HWND hDlg, int ctlID)
{
    HFONT hFont = NULL;

    if( IsNT() )
    {
        return;
    }

    hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
    if (hFont == NULL)
        hFont = (HFONT) GetStockObject(SYSTEM_FONT);
    if (hFont != NULL)
        SendMessage(GetDlgItem(hDlg,ctlID), WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0));
}

// ############################################################################
//  StoreInSignUpReg
//
//  Created 3/18/96,        Chris Kauffman
// ############################################################################
HRESULT StoreInSignUpReg(LPBYTE lpbData, DWORD dwSize, DWORD dwType, LPCTSTR pszKey)
{
    HRESULT hr = ERROR_ACCESS_DENIED;
    HKEY hKey;

    hr = RegCreateKey(HKEY_LOCAL_MACHINE,SIGNUPKEY,&hKey);
    if (hr != ERROR_SUCCESS) goto StoreInSignUpRegExit;
    hr = RegSetValueEx(hKey,pszKey,0,dwType,lpbData,sizeof(TCHAR)*dwSize);


    RegCloseKey(hKey);

StoreInSignUpRegExit:
    return hr; 
}

HRESULT ReadSignUpReg(LPBYTE lpbData, DWORD *pdwSize, DWORD dwType, LPCTSTR pszKey)
{
    HRESULT hr = ERROR_ACCESS_DENIED;
    HKEY hKey = 0;

    hr = RegOpenKey(HKEY_LOCAL_MACHINE,SIGNUPKEY,&hKey);
    if (hr != ERROR_SUCCESS) goto ReadSignUpRegExit;
    hr = RegQueryValueEx(hKey,pszKey,0,&dwType,lpbData,pdwSize);

ReadSignUpRegExit:
    if (hKey) RegCloseKey (hKey);
    return hr;
}

// ############################################################################
//  GetDataFromISPFile
//
//  This function will read a specific piece of information from an ISP file.
//
//  Created 3/16/96,        Chris Kauffman
// ############################################################################
HRESULT GetDataFromISPFile
(
    LPTSTR pszISPCode, 
    LPTSTR pszSection,
    LPTSTR pszDataName, 
    LPTSTR pszOutput, 
    DWORD  dwOutputLength)
{
    LPTSTR  pszTemp;
    HRESULT hr = ERROR_SUCCESS;
    TCHAR   szTempPath[MAX_PATH];
    TCHAR   szBuff256[256];

    // Locate ISP file
    if (!SearchPath(NULL,pszISPCode,INF_SUFFIX,MAX_PATH,szTempPath,&pszTemp))
    {
        wsprintf(szBuff256,TEXT("Can not find:%s%s (%d) (connect.exe)"),pszISPCode,INF_SUFFIX,GetLastError());
        AssertMsg(0,szBuff256);
        lstrcpyn(szTempPath,pszISPCode,MAX_PATH);
        lstrcpyn(&szTempPath[lstrlen(szTempPath)],INF_SUFFIX,MAX_PATH-lstrlen(szTempPath));
        wsprintf(szBuff256,GetSz(IDS_CANTLOADINETCFG),szTempPath);
        MessageBox(NULL,szBuff256,GetSz(IDS_TITLE),MB_MYERROR);
        hr = ERROR_FILE_NOT_FOUND;
    } else if (!GetPrivateProfileString(pszSection,pszDataName,INF_DEFAULT,
        pszOutput, (int)dwOutputLength,szTempPath))
    {
        TraceMsg(TF_GENERAL, TEXT("ICWHELP: %s not specified in ISP file.\n"),pszDataName);
        hr = ERROR_FILE_NOT_FOUND;
    } 

    // 10/23/96    jmazner    Normandy #9921
    // CompareString does _not_ have same return values as lsrtcmp!
    // Return value of 2 indicates strings are equal.
    //if (!CompareString(LOCALE_SYSTEM_DEFAULT,0,INF_DEFAULT,lstrlen(INF_DEFAULT),pszOutput,lstrlen(pszOutput)))
    if (2 == CompareString(LOCALE_SYSTEM_DEFAULT,0,INF_DEFAULT,lstrlen(INF_DEFAULT),pszOutput,lstrlen(pszOutput)))
    {
        hr = ERROR_FILE_NOT_FOUND;
    }

    if (hr != ERROR_SUCCESS && dwOutputLength) 
        *pszOutput = TEXT('\0');
    return hr;
}

// ############################################################################
//  GetINTFromISPFile
//
//  This function will read a specific integer from an ISP file.
//
//  
// ############################################################################
HRESULT GetINTFromISPFile
(
    LPTSTR  pszISPCode, 
    LPTSTR  pszSection,
    LPTSTR  pszDataName, 
    int far *lpData,
    int     iDefaultValue
)
{
    LPTSTR  pszTemp;
    HRESULT hr = ERROR_SUCCESS;
    TCHAR   szTempPath[MAX_PATH];
    TCHAR   szBuff256[256];

    // Locate ISP file
    if (!SearchPath(NULL,pszISPCode,INF_SUFFIX,MAX_PATH,szTempPath,&pszTemp))
    {
        wsprintf(szBuff256,TEXT("Can not find:%s%s (%d) (connect.exe)"),pszISPCode,INF_SUFFIX,GetLastError());
        AssertMsg(0,szBuff256);
        lstrcpyn(szTempPath,pszISPCode,MAX_PATH);
        lstrcpyn(&szTempPath[lstrlen(szTempPath)],INF_SUFFIX,MAX_PATH-lstrlen(szTempPath));
        wsprintf(szBuff256,GetSz(IDS_CANTLOADINETCFG),szTempPath);
        MessageBox(NULL,szBuff256,GetSz(IDS_TITLE),MB_MYERROR);
        hr = ERROR_FILE_NOT_FOUND;
    } 
    
    *lpData = GetPrivateProfileInt(pszSection, 
                                   pszDataName, 
                                   iDefaultValue, 
                                   szTempPath);
    return hr;
}


//+-------------------------------------------------------------------
//
//    Function:    IsNT
//
//    Synopsis:    findout If we are running on NT
//
//    Arguements:    none
//
//    Return:        TRUE -  Yes
//                FALSE - No
//
//--------------------------------------------------------------------
BOOL 
IsNT (
    VOID
    )
{
    OSVERSIONINFO  OsVersionInfo;

    ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OsVersionInfo);
    return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);

}  //end of IsNT function call

//+-------------------------------------------------------------------
//
//    Function:    IsNT4SP3Lower
//
//    Synopsis:    findout If we are running on NTSP3 or lower
//
//    Arguements:    none
//
//    Return:        TRUE -  Yes
//                FALSE - No
//
//--------------------------------------------------------------------

BOOL IsNT4SP3Lower()
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        
    GetVersionEx(&os);

    if(os.dwPlatformId != VER_PLATFORM_WIN32_NT)
        return FALSE;

    // Exclude NT5 or higher
    if(os.dwMajorVersion > 4)
        return FALSE;

	if(os.dwMajorVersion < 4)
        return TRUE;

    // version 4.0
    if ( os.dwMinorVersion > 0)
        return FALSE;        // assume that sp3 is not needed for nt 4.1 or higher

    int nServicePack;
    if(_stscanf(os.szCSDVersion, TEXT("Service Pack %d"), &nServicePack) != 1)
        return TRUE;

    if(nServicePack < 4)
        return TRUE;
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   MyGetTempPath()
//
//  Synopsis:   Gets the path to temporary directory
//                - Use GetTempFileName to get a file name 
//                  and strips off the filename portion to get the temp path
//
//  Arguments:  [uiLength - Length of buffer to contain the temp path]
//                [szPath      - Buffer in which temp path will be returned]
//
//    Returns:    Length of temp path if successful
//                0 otherwise
//
//  History:    7/6/96     VetriV    Created
//                8/23/96        VetriV        Delete the temp file
//                12/4/96        jmazner     Modified to serve as a wrapper of sorts;
//                                     if TMP or TEMP don't exist, setEnv our own
//                                     vars that point to conn1's installed path
//                                     (Normandy #12193)
//
//----------------------------------------------------------------------------
DWORD MyGetTempPath(UINT uiLength, LPTSTR szPath)
{ 
#    define ICWHELPPATHKEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\ICWHELP.EXE")
#    define PATHKEYNAME TEXT("Path")
    TCHAR szEnvVarName[MAX_PATH + 1] = TEXT("\0unitialized szEnvVarName\0");
    DWORD dwFileAttr = 0;

    lstrcpyn( szPath, TEXT("\0unitialized szPath\0"), 20 );

    // is the TMP variable set?
    lstrcpyn(szEnvVarName,GetSz(IDS_TMPVAR),ARRAYSIZE(szEnvVarName));
    if( GetEnvironmentVariable( szEnvVarName, szPath, uiLength ) )
    {
        // 1/7/96 jmazner Normandy #12193
        // verify validity of directory name
        dwFileAttr = GetFileAttributes(szPath);
        // if there was any error, this directory isn't valid.
        if( 0xFFFFFFFF != dwFileAttr )
        {
            if( FILE_ATTRIBUTE_DIRECTORY & dwFileAttr )
            {
                return( lstrlen(szPath) );
            }
        }
    }

    lstrcpyn( szEnvVarName, TEXT("\0unitialized again\0"), 19 );

    // if not, is the TEMP variable set?
    lstrcpyn(szEnvVarName,GetSz(IDS_TEMPVAR),ARRAYSIZE(szEnvVarName));
    if( GetEnvironmentVariable( szEnvVarName, szPath, uiLength ) )
    {
        // 1/7/96 jmazner Normandy #12193
        // verify validity of directory name
        dwFileAttr = GetFileAttributes(szPath);
        if( 0xFFFFFFFF != dwFileAttr )
        {
            if( FILE_ATTRIBUTE_DIRECTORY & dwFileAttr )
            {
                return( lstrlen(szPath) );
            }
        }
    }

    // neither one is set, so let's use the path to the installed icwhelp.dll
    // from the registry  SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\ICWHELP.DLL\Path
    HKEY hkey = NULL;

#ifdef UNICODE
    uiLength = sizeof(TCHAR)*uiLength;
#endif
    if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,ICWHELPPATHKEY, 0, KEY_QUERY_VALUE, &hkey)) == ERROR_SUCCESS)
        RegQueryValueEx(hkey, PATHKEYNAME, NULL, NULL, (LPBYTE)szPath, (DWORD *)&uiLength);
    if (hkey) 
    {
        RegCloseKey(hkey);
    }

    //The path variable is supposed to have a semicolon at the end of it.
    // if it's there, remove it.
    if( TEXT(';') == szPath[uiLength - 2] )
        szPath[uiLength - 2] = TEXT('\0');

    TraceMsg(TF_GENERAL, TEXT("ICWHELP: using path %s\r\n"), szPath);


    // go ahead and set the TEMP variable for future reference
    // (only effects currently running process)
    if( szEnvVarName[0] )
    {
        SetEnvironmentVariable( szEnvVarName, szPath );
    }
    else
    {
        lstrcpyn( szPath, TEXT("\0unitialized again\0"), 19 );
        return( 0 );
    }

    return( uiLength );
} 

// ############################################################################
HRESULT ClearProxySettings()
{
    HINSTANCE hinst = NULL;
    FARPROC fp;
    HRESULT hr = ERROR_SUCCESS;

    hinst = LoadLibrary(TEXT("INETCFG.DLL"));
    if (hinst)
    {
        fp = GetProcAddress(hinst,"InetGetProxy");
        if (!fp)
        {
            hr = GetLastError();
            goto ClearProxySettingsExit;
        }
        hr = ((PFNINETGETPROXY)fp)(&g_bProxy,NULL,0,NULL,0);
        if (hr == ERROR_SUCCESS) 
            g_bGotProxy = TRUE;
        else
            goto ClearProxySettingsExit;

        if (g_bProxy)
        {
            fp = GetProcAddress(hinst, "InetSetProxy");
            if (!fp)
            {
                hr = GetLastError();
                goto ClearProxySettingsExit;
            }
            ((PFNINETSETPROXY)fp)(FALSE,NULL,NULL);
        }
    } else {
        hr = GetLastError();
    }

ClearProxySettingsExit:
    if (hinst) 
        FreeLibrary(hinst);
    return hr;
}

// ############################################################################
HRESULT RestoreProxySettings()
{
    HINSTANCE hinst = NULL;
    FARPROC fp;
    HRESULT hr = ERROR_SUCCESS;

    hinst = LoadLibrary(TEXT("INETCFG.DLL"));
    if (hinst && g_bGotProxy)
    {
        fp = GetProcAddress(hinst, "InetSetProxy");
        if (!fp)
        {
            hr = GetLastError();
            goto RestoreProxySettingsExit;
        }
        ((PFNINETSETPROXY)fp)(g_bProxy,NULL,NULL);
    } else {
        hr = GetLastError();
    }

RestoreProxySettingsExit:
    if (hinst) 
        FreeLibrary(hinst);
    return hr;
}

// ############################################################################
BOOL FSz2Dw(LPCTSTR pSz,LPDWORD dw)
{
    DWORD val = 0;
    while (*pSz && *pSz != TEXT('.'))
    {
        if (*pSz >= TEXT('0') && *pSz <= TEXT('9'))
        {
            val *= 10;
            val += *pSz++ - TEXT('0');
        }
        else
        {
            return FALSE;  //bad number
        }
    }
    *dw = val;
    return (TRUE);
}

// ############################################################################
LPTSTR GetNextNumericChunk(LPTSTR psz, LPTSTR pszLim, LPTSTR* ppszNext)
{
    LPTSTR pszEnd;

    // init for error case
    *ppszNext = NULL;
    // skip non numerics if any to start of next numeric chunk
    while(*psz<TEXT('0') || *psz>TEXT('9'))
    {
        if(psz >= pszLim) return NULL;
        psz++;
    }
    // skip all numerics to end of country code
    for(pszEnd=psz; *pszEnd>=TEXT('0') && *pszEnd<=TEXT('9') && pszEnd<pszLim; pszEnd++)
        ;
    // zap whatever delimiter there was to terminate this chunk
    *pszEnd++ = TEXT('\0');
    // return ptr to next chunk (pszEnd now points to it)
    if(pszEnd<pszLim) 
        *ppszNext = pszEnd;
        
    return psz;    // return ptr to start of chunk
}

// ############################################################################
BOOL BreakUpPhoneNumber(LPRASENTRY prasentry, LPTSTR pszPhone)
{
    LPTSTR         pszStart,pszNext, pszLim, pszArea;
//    LPPHONENUM     ppn;
    
    if (!pszPhone) return FALSE; // skip if no number
    
    pszLim = pszPhone + lstrlen(pszPhone);    // find end of string

    //ppn = (fMain) ? &(pic->PhoneNum) : &(pic->PhoneNum2);
    
    ////Get the country ID...
    //ppn->dwCountryID = PBKDWCountryId();
    
    // Get Country Code from phone number...
    pszStart = _tcschr(pszPhone,TEXT('+'));
    if(!pszStart) goto error; // bad format

    // get country code
    pszStart = GetNextNumericChunk(pszStart, pszLim, &pszNext);
    if(!pszStart) goto error; // bad format
    //ppn->dwCountryCode = Sz2Dw(pszStart);
    FSz2Dw(pszStart,&prasentry->dwCountryCode);
    pszStart = pszNext;
        
    //Now get the area code
    if(!pszStart) goto error; // bad format
    pszStart = GetNextNumericChunk(pszStart, pszLim, &pszNext);
    if(!pszStart) goto error; // bad format //icw bug 8950
    //lstrcpy(ppn->szAreaCode, pszStart);
    lstrcpyn(prasentry->szAreaCode,pszStart,ARRAYSIZE(prasentry->szAreaCode));
    //
    // Keep track of the start of the area code, because it may actually be the
    // local phone number.
    //
    pszArea = pszStart;

    pszStart = pszNext;

    // If pszStart is NULL then we don't have an area code, just a country code and a local
    // phone number.  Therefore we will copy what we thought was the area code into the
    // phone number and replace the area code with a space (which seems to make RAS happy).
    //
    if (pszStart)
    {
        //now the local phone number (everything from here to : or end)
        pszNext = _tcschr(pszStart, TEXT(':'));
        if(pszNext) *pszNext=TEXT('\0');

        lstrcpyn(prasentry->szLocalPhoneNumber,pszStart,ARRAYSIZE(prasentry->szLocalPhoneNumber));
    } else {
        //
        // Turns out that there is no area code. So copy what we thought was the area code
        // into the local phone number and make the area code NULL
        //
        lstrcpyn(prasentry->szLocalPhoneNumber,pszArea,ARRAYSIZE(prasentry->szLocalPhoneNumber));
        //lstrcpyn(prasentry->szAreaCode," ",sizeof(prasentry->szAreaCode));
        prasentry->szAreaCode[0] = TEXT('\0');
    }

    //no extension. what is extension?
    //ppn->szExtension[0] = TEXT('\0');
    //LocalFree(pszPhone);
    return TRUE;

error:
    // This means number is not canonical. Set it as local number anyway!
    // memset(ppn, 0, sizeof(*ppn));
    // Bug#422: need to strip stuff after : or dial fails!!
    pszNext = _tcschr(pszPhone, TEXT(':'));
    if(pszNext) *pszNext=TEXT('\0');
    //lstrcpy(ppn->szLocal,pszPhone);
    lstrcpy(prasentry->szLocalPhoneNumber,pszPhone);
    //LocalFree(pszPhone);
    return TRUE;
}


// ############################################################################
int Sz2W (LPCTSTR szBuf)
{
    DWORD dw;
    if (FSz2Dw(szBuf,&dw))
    {
        return (WORD)dw;
    }
    return 0;
}

// ############################################################################
int FIsDigit( int c )
{
    TCHAR  szIn[2];
    WORD   rwOut[2];
    szIn[0] = (TCHAR)c;
    szIn[1] = TEXT('\0');
    GetStringTypeEx(LOCALE_USER_DEFAULT,CT_CTYPE1,szIn,-1,rwOut);
    return rwOut[0] & C1_DIGIT;

}

// ############################################################################
LPBYTE MyMemSet(LPBYTE dest,int c, size_t count)
{
    LPVOID pv = dest;
    LPVOID pvEnd = (LPVOID)(dest + (WORD)count);
    while (pv < pvEnd)
    {
        *(LPINT)pv = c;
        //((WORD)pv)++;
        pv=((LPINT)pv)+1;
    }
    return dest;
}

// ############################################################################
LPBYTE MyMemCpy(LPBYTE dest,const LPBYTE src, size_t count)
{
    LPBYTE pbDest = (LPBYTE)dest;
    LPBYTE pbSrc = (LPBYTE)src;
    LPBYTE pbEnd = (LPBYTE)((DWORD_PTR)src + count);
    while (pbSrc < pbEnd)
    {
        *pbDest = *pbSrc;
        pbSrc++;
        pbDest++;
    }
    return dest;
}

// ############################################################################
BOOL ShowControl(HWND hDlg,int idControl,BOOL fShow)
{
    HWND hWnd;

    if (NULL == hDlg)
    {
        AssertMsg(0,TEXT("Null Param"));
        return FALSE;
    }


    hWnd = GetDlgItem(hDlg,idControl);
    if (hWnd)
    {
        ShowWindow(hWnd,fShow ? SW_SHOW : SW_HIDE);
    }

    return TRUE;
}

BOOL isAlnum(TCHAR c)
{
    if ((c >= TEXT('0') && c <= TEXT('9') ) ||
        (c >= TEXT('a') && c <= TEXT('z') ) ||
        (c >= TEXT('A') && c <= TEXT('Z') ))
        return TRUE;
    return FALSE;
}

// ############################################################################
HRESULT ANSI2URLValue(TCHAR *s, TCHAR *buf, UINT uiLen)
{
    HRESULT hr;
    TCHAR *t;
    hr = ERROR_SUCCESS;

    for (t=buf;*s; s++)
    {
        if (*s == TEXT(' ')) *t++ = TEXT('+');
        else if (isAlnum(*s)) *t++ = *s;
        else {
            wsprintf(t, TEXT("%%%02X"), (unsigned char) *s);
            t += 3;
        }
    }
    *t = TEXT('\0');
    return hr;
}

// ############################################################################
LPTSTR FileToPath(LPTSTR pszFile)
{
    TCHAR  szBuf[MAX_PATH+1];
    TCHAR  szTemp[MAX_PATH+1];
    LPTSTR pszTemp;
    LPTSTR pszTemp2;
    LPTSTR pszHold = pszFile;
    int    j;

    for(j=0; *pszFile; pszFile++)
    {
        if(j>=MAX_PATH)
                return NULL;
        if(*pszFile==TEXT('%'))
        {
            pszFile++;
            pszTemp = _tcschr(pszFile, TEXT('%'));
            if(!pszTemp)
                    return NULL;
            *pszTemp = 0;
            if(lstrcmpi(pszFile, DIR_SIGNUP)==0)
            {
                LPTSTR pszCmdLine = GetCommandLine();
                _tcsncpy(szTemp, pszCmdLine, MAX_PATH);
                szBuf[MAX_PATH] = 0;
                pszTemp = _tcstok(szTemp, TEXT(" \t\r\n"));
                pszTemp2 = _tcsrchr(pszTemp, TEXT('\\'));
                if(!pszTemp2) pszTemp2 = _tcsrchr(pszTemp, TEXT('/'));
                if(pszTemp2)
                {
                    *pszTemp2 = 0;
                    lstrcpy(szBuf+j, pszTemp);
                }
                else
                {
                    Assert(FALSE);
                    GetCurrentDirectory(MAX_PATH, szTemp);
                    szTemp[MAX_PATH] = 0;
                    lstrcpy(szBuf+j, pszTemp);
                }
                
                j+= lstrlen(pszTemp);
            }
            else if(lstrcmpi(pszFile, DIR_WINDOWS)==0)
            {
                GetWindowsDirectory(szTemp, MAX_PATH);
                szTemp[MAX_PATH] = 0;
                lstrcpy(szBuf+j, szTemp);
                j+= lstrlen(szTemp);
            }
            else if(lstrcmpi(pszFile, DIR_SYSTEM)==0)
            {
                GetSystemDirectory(szTemp, MAX_PATH);
                szTemp[MAX_PATH] = 0;
                lstrcpy(szBuf+j, szTemp);
                j+= lstrlen(szTemp);
            }
            else if(lstrcmpi(pszFile, DIR_TEMP)==0)
            {
                // 3/18/97 ChrisK Olympus 304
                MyGetTempPath(MAX_PATH, &szTemp[0]);
                szTemp[MAX_PATH] = 0;
                if(szTemp[lstrlen(szTemp)-1]==TEXT('\\'))
                    szTemp[lstrlen(szTemp)-1]=0;
                lstrcpy(szBuf+j, szTemp);
                j+= lstrlen(szTemp);
            }
            else
                    return NULL;
            pszFile=pszTemp;
        }
        else
            szBuf[j++] = *pszFile;
    }
    szBuf[j] = 0;
    TraceMsg(TF_GENERAL, TEXT("CONNECT:File to Path output ,%s.\n"),szBuf);
    return lstrcpy(pszHold,&szBuf[0]);
}

// ############################################################################
BOOL FShouldRetry2(HRESULT hrErr)
{
    BOOL bRC;

    if (hrErr == ERROR_LINE_BUSY ||
        hrErr == ERROR_VOICE_ANSWER ||
        hrErr == ERROR_NO_ANSWER ||
        hrErr == ERROR_NO_CARRIER ||
        hrErr == ERROR_AUTHENTICATION_FAILURE ||
        hrErr == ERROR_PPP_TIMEOUT ||
        hrErr == ERROR_REMOTE_DISCONNECTION ||
        hrErr == ERROR_AUTH_INTERNAL ||
        hrErr == ERROR_PROTOCOL_NOT_CONFIGURED ||
        hrErr == ERROR_PPP_NO_PROTOCOLS_CONFIGURED)
    {
        bRC = TRUE;
    } else {
        bRC = FALSE;
    }

    return bRC;
}

#if 0
// DJM I don't this we will need this
//+----------------------------------------------------------------------------
//
//    Function:    FGetSystemShutdownPrivledge
//
//    Synopsis:    For windows NT the process must explicitly ask for permission
//                to reboot the system.
//
//    Arguements:    none
//
//    Return:        TRUE - privledges granted
//                FALSE - DENIED
//
//    History:    8/14/96    ChrisK    Created
//
//    Note:        BUGBUG for Win95 we are going to have to softlink to these
//                entry points.  Otherwise the app won't even load.
//                Also, this code was originally lifted out of MSDN July96
//                "Shutting down the system"
//-----------------------------------------------------------------------------
BOOL FGetSystemShutdownPrivledge()
{
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tkp;
 
    BOOL bRC = FALSE;

    if (VER_PLATFORM_WIN32_NT == g_dwPlatform)
    {
        // 
        // Get the current process token handle 
        // so we can get shutdown privilege. 
        //

        if (!OpenProcessToken(GetCurrentProcess(), 
                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) 
                goto FGetSystemShutdownPrivledgeExit;

        //
        // Get the LUID for shutdown privilege.
        //

        ZeroMemory(&tkp,sizeof(tkp));
        LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, 
                &tkp.Privileges[0].Luid); 

        tkp.PrivilegeCount = 1;  /* one privilege to set    */ 
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 

        //
        // Get shutdown privilege for this process.
        //

        AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, 
            (PTOKEN_PRIVILEGES) NULL, 0); 

        if (ERROR_SUCCESS == GetLastError())
            bRC = TRUE;
    }
    else
    {
        bRC = TRUE;
    }

FGetSystemShutdownPrivledgeExit:
    if (hToken) CloseHandle(hToken);
    return bRC;
}
#endif

//+----------------------------------------------------------------------------
//
//    Function:    LoadTestingLocaleOverride
//
//    Synopsis:    Allow the testers to override the locale information sent to
//                the referal server
//
//    Arguments:    lpdwCountryID - pointer to country ID
//                lplcid - pointer to current lcid
//
//    Returns:    none
//
//    History:    8/15/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
#if defined(DEBUG)
void LoadTestingLocaleOverride(LPDWORD lpdwCountryID, LCID FAR *lplcid)
{
    HKEY hkey = NULL;
    LONG lRC = ERROR_SUCCESS;
    DWORD dwTemp = 0;
    LCID lcidTemp = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;
    BOOL fWarn = FALSE;

    Assert(lpdwCountryID && lplcid);

    //
    // Open debug key
    //
    lRC = RegOpenKey(HKEY_LOCAL_MACHINE,TEXT("Software\\Microsoft\\ISignup\\Debug"),&hkey);
    if (ERROR_SUCCESS != lRC)
        goto LoadTestingLocaleOverrideExit;

    //
    //    Get CountryID
    //
    dwSize = sizeof(dwTemp);
    lRC = RegQueryValueEx(hkey,TEXT("CountryID"),0,&dwType,(LPBYTE)&dwTemp,&dwSize);
    AssertMsg(lRC || REG_DWORD == dwType,TEXT("Wrong value type for CountryID.  Must be DWORD.\r\n"));
    if (ERROR_SUCCESS==lRC)
    {
        *lpdwCountryID = dwTemp;
        fWarn = TRUE;
    }

    //
    //    Get LCID
    //
    dwSize = sizeof(lcidTemp);
    lRC = RegQueryValueEx(hkey,TEXT("LCID"),0,&dwType,(LPBYTE)&lcidTemp,&dwSize);
    AssertMsg(lRC || REG_DWORD == dwType,TEXT("Wrong value type for LCID.  Must be DWORD.\r\n"));
    if (ERROR_SUCCESS==lRC)
    {
        *lplcid = lcidTemp;
        fWarn = TRUE;
    }

    //
    // Inform the user that overrides have been used
    //
    if (fWarn)
    {
        MessageBox(NULL,TEXT("DEBUG ONLY: LCID and/or CountryID overrides from the registry are now being used."),TEXT("Testing Override"),0);
    }

LoadTestingLocaleOverrideExit:
    if (hkey)
        RegCloseKey(hkey);
    hkey = NULL;
    return;
}
#endif //DEBUG

//+----------------------------------------------------------------------------
//
//    Function:    FCampusNetOverride
//
//    Synopsis:    Detect if the dial should be skipped for the campus network
//
//    Arguments:    None
//
//    Returns:    TRUE - overide enabled
//
//    History:    8/15/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
#if defined(DEBUG)
BOOL FCampusNetOverride()
{
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwData = 0;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
        TEXT("Software\\Microsoft\\ISignup\\Debug"),&hkey))
        goto FCampusNetOverrideExit;

    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS != RegQueryValueEx(hkey,TEXT("CampusNet"),0,&dwType,
        (LPBYTE)&dwData,&dwSize))
        goto FCampusNetOverrideExit;

    AssertMsg(REG_DWORD == dwType,TEXT("Wrong value type for CampusNet.  Must be DWORD.\r\n"));
    bRC = (0 != dwData);

    if (bRC)
    {
        if (IDOK != MessageBox(NULL,TEXT("DEBUG ONLY: CampusNet will be used."),TEXT("Testing Override"),MB_OKCANCEL))
            bRC = FALSE;
    }
FCampusNetOverrideExit:
    if (hkey)
        RegCloseKey(hkey);

    return bRC;
}
#endif //DEBUG

#if defined(DEBUG)
BOOL FRefURLOverride()
{
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwData = 0;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
        TEXT("Software\\Microsoft\\ISignup\\Debug"),&hkey))
        goto FRefURLOverrideExit;

    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS != RegQueryValueEx(hkey,TEXT("TweakURL"),0,&dwType,
        (LPBYTE)&dwData,&dwSize))
        goto FRefURLOverrideExit;

    AssertMsg(REG_DWORD == dwType,TEXT("Wrong value type for TweakURL.  Must be DWORD.\r\n"));
    bRC = (0 != dwData);

    if (bRC)
    {
        if (IDOK != MessageBox(NULL,TEXT("DEBUG ONLY: TweakURL settings will be used."),TEXT("Testing Override"),MB_OKCANCEL))
            bRC = FALSE;
    }
FRefURLOverrideExit:
    if (hkey)
        RegCloseKey(hkey);

    return bRC;
}

void TweakRefURL( TCHAR* szUrl, 
                  LCID*  lcid, 
                  DWORD* dwOS,
                  DWORD* dwMajorVersion, 
                  DWORD* dwMinorVersion,
                  WORD*  wArchitecture, 
                  TCHAR* szPromo, 
                  TCHAR* szOEM, 
                  TCHAR* szArea, 
                  DWORD* dwCountry,
                  TCHAR* szSUVersion,//&m_lpGatherInfo->m_szSUVersion[0],  
                  TCHAR* szProd, 
                  DWORD* dwBuildNumber, 
                  TCHAR* szRelProd, 
                  TCHAR* szRelProdVer, 
                  DWORD* dwCONNWIZVersion, 
                  TCHAR* szPID, 
                  long*  lAllOffers)
{
    HKEY  hKey = NULL;
    BOOL  bRC = FALSE;
    BYTE  bData[MAX_PATH*3];
    DWORD cbData = MAX_PATH*3;          
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwData = 0;

    dwSize = sizeof(dwData);
      
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ISignup\\Debug\\TweakURLValues"),&hKey))
    {
       //szURL
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("URL"), NULL ,&dwType, bData, &cbData))
       {
          if ((cbData > 1) && (cbData <= MAX_PATH))
          {
              lstrcpy(szUrl, (TCHAR*)&bData);             
          }
       }
       //lcid
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("LCID"),0,&dwType, (LPBYTE)&dwData, &dwSize))
       {
          if (dwData != 0)
            *lcid = dwData;
       }
       //dwOS
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("OS"),0,&dwType, (LPBYTE)&dwData, &dwSize))
       {
          if (dwData != 0)
            *dwOS = dwData;
       }
       //dwMajorVersion
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("MajorVer"),0,&dwType, (LPBYTE)&dwData, &dwSize))
       {
          if (dwData != 0)
            *dwMajorVersion = dwData;
       }
       //dwMinorVersion
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("MinorVer"),0,&dwType, (LPBYTE)&dwData, &dwSize))
       {
          if (dwData != 0)
            *dwMinorVersion = dwData;
       }
       //wArchitecture
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("SysArch"),0,&dwType, (LPBYTE)&dwData, &dwSize))
       {
          if (dwData != 0)
            *wArchitecture = (WORD)dwData;
       }
       //szPromo
       cbData = sizeof(TCHAR)*(MAX_PATH*3);  
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("Promo"),0,&dwType, bData, &cbData))
       {
          if ((cbData > 1) && (cbData <= MAX_PATH))
          {
              lstrcpy(szPromo, (TCHAR*)&bData);             
          }
       }
       //szOEM
       cbData = sizeof(TCHAR)*(MAX_PATH*3);  
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("OEM"),0,&dwType, bData, &cbData))
       {
          if ((cbData > 1) && (cbData <= MAX_PATH))
          {
              lstrcpy(szOEM, (TCHAR*)&bData);             
          }
       }
       //szArea
       cbData = sizeof(TCHAR)*(MAX_PATH*3);  
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("Area"),0,&dwType, bData, &cbData))
       {
          if ((cbData > 1) && (cbData <= MAX_PATH))
          {
              lstrcpy(szArea, (TCHAR*)&bData);             
          }
       }
       //dwCountry
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("Country"),0,&dwType, (LPBYTE)&dwData, &dwSize))
       {
          if (dwData != 0)
            *dwCountry = dwData;
       }
       //szSUVersion
       cbData = sizeof(TCHAR)*(MAX_PATH*3);  
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("SUVer"),0,&dwType, bData, &cbData))
       {
          if ((cbData > 1) && (cbData <= MAX_VERSION_LEN))
          {
              lstrcpy(szSUVersion, (TCHAR*)&bData);             
          }
       }
       //szProd
       cbData = sizeof(TCHAR)*(MAX_PATH*3);  
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("Product"),0,&dwType, bData, &cbData))
       {
          if ((cbData > 1) && (cbData <= MAX_PATH))
          {
              lstrcpy(szProd, (TCHAR*)&bData);             
          }
       }
       //dwBuildNumber
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("BuildNum"),0,&dwType, (LPBYTE)&dwData, &dwSize))
       {
          if (dwData != 0)
            *dwBuildNumber = dwData;
       }
       //szRelProd
       cbData = sizeof(TCHAR)*(MAX_PATH*3);  
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("RelProd"),0,&dwType, bData, &cbData))
       {
          if ((cbData > 1) && (cbData <= MAX_PATH))
          {
              lstrcpy(szRelProd, (TCHAR*)&bData);             
          }
       } 
       //szRelProdVer
       cbData = sizeof(TCHAR)*(MAX_PATH*3);  
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("RelProdVer"),0,&dwType, bData, &cbData))
       {
          if ((cbData > 1) && (cbData <= MAX_PATH))
          {
              lstrcpy(szRelProdVer, (TCHAR*)&bData);             
          }
       }
       //dwCONNWIZVersion
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("ConnwizVer"),0,&dwType, (LPBYTE)&dwData, &dwSize))
       {
          if (dwData != 0)
            *dwCONNWIZVersion = dwData;
       }
       //szPID
       BYTE byDigitalPID[MAX_DIGITAL_PID];
       DWORD dwType2 = REG_BINARY;
       DWORD dwSize2 = sizeof(byDigitalPID);
       if (RegQueryValueEx(hKey,
                            TEXT("PID"),
                            NULL,
                            &dwType2,
                            (LPBYTE)byDigitalPID,
                            &dwSize2) == ERROR_SUCCESS)
       {
           if ((dwSize2 > 1) && (dwSize2 <= ((MAX_DIGITAL_PID * 2) + 1)))
           {
               // BINHEX the digital PID data so we can send it to the ref_server
               int     i = 0;
               BYTE    by;
               for (DWORD dwX = 0; dwX < dwSize2; dwX++)
               {
                   by = byDigitalPID[dwX];
                   szPID[i++] = g_BINTOHEXLookup[((by & 0xF0) >> 4)];
                   szPID[i++] = g_BINTOHEXLookup[(by & 0x0F)];
               }
               szPID[i] = TEXT('\0');
           }
           else
           {
               szPID[0] = TEXT('\0');
           }
       }

       //lAllOffers
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("AllOffers"),0,&dwType, (LPBYTE)&dwData, &dwSize))
       {
          if (dwData != 0)
            *lAllOffers = dwData;
       }
    }
    if (hKey)
        RegCloseKey(hKey);
}

#endif //DEBUG
   
   
//+----------------------------------------------------------------------------
//    Function    CopyUntil
//
//    Synopsis    Copy from source until destination until running out of source
//                or until the next character of the source is the chend character
//
//    Arguments    dest - buffer to recieve characters
//                src - source buffer
//                lpdwLen - length of dest buffer
//                chend - the terminating character
//
//    Returns        FALSE - ran out of room in dest buffer
//
//    Histroy        10/25/96    ChrisK    Created
//-----------------------------------------------------------------------------
static BOOL CopyUntil(LPTSTR *dest, LPTSTR *src, LPDWORD lpdwLen, TCHAR chend)
{
    while ((TEXT('\0') != **src) && (chend != **src) && (0 != *lpdwLen))
    {
        **dest = **src;
        (*lpdwLen)--;
        (*dest)++;
        (*src)++;
    }
    return (0 != *lpdwLen);
}

//+----------------------------------------------------------------------------
//    Function    ConvertToLongFilename
//
//    Synopsis    convert a file to the full long file name
//                ie. c:\progra~1\icw-in~1\isignup.exe becomes
//                c:\program files\icw-internet connection wizard\isignup.exe
//
//    Arguments    szOut - output buffer
//                szIn - filename to be converted
//                dwSize - size of the output buffer
//
//    Returns        TRUE - success
//
//    History        10/25/96    ChrisK    Created
//-----------------------------------------------------------------------------
BOOL ConvertToLongFilename(LPTSTR szOut, LPTSTR szIn, DWORD dwSize)
{
    BOOL   bRC = FALSE;
    LPTSTR pCur = szIn;
    LPTSTR pCurOut = szOut;
    LPTSTR pCurOutFilename = NULL;
    WIN32_FIND_DATA fd;
    DWORD  dwSizeTemp;
    LPTSTR pTemp = NULL;

    ZeroMemory(pCurOut,dwSize);

    //
    // Validate parameters
    //
    if (NULL != pCurOut && NULL != pCur && 0 != dwSize)
    {
        //
        // Copy drive letter
        //
        if (!CopyUntil(&pCurOut,&pCur,&dwSize,TEXT('\\')))
            goto ConvertToLongFilenameExit;
        pCurOut[0] = TEXT('\\');
        dwSize--;
        pCur++;
        pCurOut++;
        pCurOutFilename = pCurOut;

        while (*pCur)
        {
            //
            // Copy over possibly short name
            //
            pCurOut = pCurOutFilename;
            dwSizeTemp = dwSize;
            if (!CopyUntil(&pCurOut,&pCur,&dwSize,TEXT('\\')))
                goto ConvertToLongFilenameExit;

            ZeroMemory(&fd, sizeof(fd));
            //
            // Get long filename
            //
            if (INVALID_HANDLE_VALUE != FindFirstFile(szOut,&fd))
            {
                //
                // Replace short filename with long filename
                //
                dwSize = dwSizeTemp;
                pTemp = &(fd.cFileName[0]);
                if (!CopyUntil(&pCurOutFilename,&pTemp,&dwSize,TEXT('\0')))
                    goto ConvertToLongFilenameExit;
                if (*pCur)
                {
                    //
                    // If there is another section then we just copied a directory
                    // name.  Append a \ character;
                    //
                    pTemp = (LPTSTR)memcpy(TEXT("\\X"),TEXT("\\X"),0);
                    if (!CopyUntil(&pCurOutFilename,&pTemp,&dwSize,TEXT('X')))
                        goto ConvertToLongFilenameExit;
                    pCur++;
                }
            }
            else
            {
                break;
            }
        }
        //
        // Did we get to the end (TRUE) or fail before that (FALSE)?
        //
        bRC = (TEXT('\0') == *pCur);
    }
ConvertToLongFilenameExit:
    return bRC;
}

#if 0
// DJM I don't think we need this
//+----------------------------------------------------------------------------
//
//    Function:    GetIEVersion
//
//    Synopsis:    Gets the major and minor version # of the installed copy of Internet Explorer
//
//    Arguments:    pdwVerNumMS - pointer to a DWORD;
//                  On succesful return, the top 16 bits will contain the major version number,
//                  and the lower 16 bits will contain the minor version number
//                  (this is the data in VS_FIXEDFILEINFO.dwProductVersionMS)
//                pdwVerNumLS - pointer to a DWORD;
//                  On succesful return, the top 16 bits will contain the release number,
//                  and the lower 16 bits will contain the build number
//                  (this is the data in VS_FIXEDFILEINFO.dwProductVersionLS)
//
//    Returns:    TRUE - Success.  *pdwVerNumMS and LS contains installed IE version number
//                FALSE - Failure. *pdVerNumMS == *pdVerNumLS == 0
//
//    History:    jmazner        Created        8/19/96    (as fix for Normandy #4571)
//                jmazner        updated to deal with release.build as well 10/11/96
//                jmazner        stolen from isign32\isignup.cpp 11/21/96
//                            (for Normandy #11812)
//
//-----------------------------------------------------------------------------
BOOL GetIEVersion(PDWORD pdwVerNumMS, PDWORD pdwVerNumLS)
{
    HRESULT hr;
    HKEY hKey = 0;
    LPVOID lpVerInfoBlock;
    VS_FIXEDFILEINFO *lpTheVerInfo;
    UINT uTheVerInfoSize;
    DWORD dwVerInfoBlockSize, dwUnused, dwPathSize;
    TCHAR szIELocalPath[MAX_PATH + 1] = TEXT("");


    *pdwVerNumMS = 0;
    *pdwVerNumLS = 0;

    // get path to the IE executable
    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, IE_PATHKEY,0, KEY_READ, &hKey);
    if (hr != ERROR_SUCCESS) return( FALSE );

    dwPathSize = sizeof (szIELocalPath);
    hr = RegQueryValueEx(hKey, NULL, NULL, NULL, (LPBYTE) szIELocalPath, &dwPathSize);
    RegCloseKey( hKey );
    if (hr != ERROR_SUCCESS) return( FALSE );

    // now go through the convoluted process of digging up the version info
    dwVerInfoBlockSize = GetFileVersionInfoSize( szIELocalPath, &dwUnused );
    if ( 0 == dwVerInfoBlockSize ) return( FALSE );

    lpVerInfoBlock = GlobalAlloc( GPTR, dwVerInfoBlockSize );
    if( NULL == lpVerInfoBlock ) return( FALSE );

    if( !GetFileVersionInfo( szIELocalPath, NULL, dwVerInfoBlockSize, lpVerInfoBlock ) )
        return( FALSE );

    if( !VerQueryValue(lpVerInfoBlock, TEXT("\\"), (void **)&lpTheVerInfo, &uTheVerInfoSize) )
        return( FALSE );

    *pdwVerNumMS = lpTheVerInfo->dwProductVersionMS;
    *pdwVerNumLS = lpTheVerInfo->dwProductVersionLS;


    GlobalFree( lpVerInfoBlock );

    return( TRUE );
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   GenericMsg
//
//----------------------------------------------------------------------------
void GenericMsg
(
    HWND    hwnd,
    UINT    uId,
    LPCTSTR  lpszArg,
    UINT    uType
)
{
    TCHAR szTemp[MAX_STRING + 1];
    TCHAR szMsg[MAX_STRING + MAX_PATH + 1];

    Assert( lstrlen( GetSz((USHORT)uId) ) <= MAX_STRING );

    lstrcpy( szTemp, GetSz( (USHORT)uId ) );

    if (lpszArg)
    {
        Assert( lstrlen( lpszArg ) <= MAX_PATH );
        wsprintf(szMsg, szTemp, lpszArg);
    }
    else
    {
        lstrcpy(szMsg, szTemp);
    }
    MessageBox(hwnd,
               szMsg,
               GetSz(IDS_TITLE),
               uType);
}
//+---------------------------------------------------------------------------
//
//  Function:   ErrorMsg1()
//
//  Synopsis:   1 stop shopping for showing a msgBox when you need to wsprintf the string to be displayed
//
//                Displays an error dialog from a string resource with a "%s" format command,
//                and a string argument to stick into it.
//
//  Arguments:  hwnd -- Handle of parent window  
//                uID -- ID of a string resource with a %s argument
//                lpszArg -- pointer to a string to fill into the %s in uID string
//
//
//  History:    9/18/96        jmazner        copied from isign32\utils.cpp (for Normandy 7537)
//                                        modified to work in conn1
//
//----------------------------------------------------------------------------
void ErrorMsg1(HWND hwnd, UINT uId, LPCTSTR lpszArg)
{
    GenericMsg(hwnd, 
               uId, 
               lpszArg, 
               MB_ICONERROR | MB_SETFOREGROUND | MB_OK | MB_APPLMODAL);
}

//+---------------------------------------------------------------------------
//
//  Function:   InfoMsg1()
//
//----------------------------------------------------------------------------
void InfoMsg1(HWND hwnd, UINT uId, LPCTSTR lpszArg)
{
    GenericMsg(hwnd, 
               uId, 
               lpszArg, 
               MB_ICONINFORMATION | MB_SETFOREGROUND | MB_OK | MB_APPLMODAL);
}


//=--------------------------------------------------------------------------=
// MakeWideFromAnsi
//=--------------------------------------------------------------------------=
// given a string, make a BSTR out of it.
//
// Parameters:
//    LPTSTR         - [in]
//    BYTE          - [in]
//
// Output:
//    LPWSTR        - needs to be cast to final desired result
//
// Notes:
//
LPWSTR MakeWideStrFromAnsi
(
    LPSTR psz,
    BYTE  bType
)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr
    //
    switch (bType) {
      case STR_BSTR:
        // -1 since it'll add it's own space for a NULL terminator
        //
        pwsz = (LPWSTR) SysAllocStringLen(NULL, i - 1);
        break;
      case STR_OLESTR:
        pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));
        break;
      default:
        AssertMsg(0,TEXT("Bogus String Type."));
    }

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromResId
//=--------------------------------------------------------------------------=
// given a resource ID, load it, and allocate a wide string for it.
//
// Parameters:
//    WORD            - [in] resource id.
//    BYTE            - [in] type of string desired.
//
// Output:
//    LPWSTR          - needs to be cast to desired string type.
//
// Notes:
//
#ifndef UNICODE // this module is not necessary for Unicode.
LPWSTR MakeWideStrFromResourceId
(
    WORD    wId,
    BYTE    bType
)
{
    int i;

    TCHAR szTmp[512];

    // load the string from the resources.
    //
    i = LoadString(_Module.GetModuleInstance(), wId, szTmp, 512);
    if (!i) return NULL;

    return MakeWideStrFromAnsi(szTmp, bType);

}
#endif

//=--------------------------------------------------------------------------=
// MakeWideStrFromWide
//=--------------------------------------------------------------------------=
// given a wide string, make a new wide string with it of the given type.
//
// Parameters:
//    LPWSTR            - [in]  current wide str.
//    BYTE              - [in]  desired type of string.
//
// Output:
//    LPWSTR
//
// Notes:
//
LPWSTR MakeWideStrFromWide
(
    LPWSTR pwsz,
    BYTE   bType
)
{
    LPWSTR pwszTmp;
    int i;

    if (!pwsz) return NULL;

    // just copy the string, depending on what type they want.
    //
    switch (bType) {
      case STR_OLESTR:
        i = lstrlenW(pwsz);
        pwszTmp = (LPWSTR)CoTaskMemAlloc((i * sizeof(WCHAR)) + sizeof(WCHAR));
        if (!pwszTmp) return NULL;
        memcpy(pwszTmp, pwsz, (sizeof(WCHAR) * i) + sizeof(WCHAR));
        break;

      case STR_BSTR:
        pwszTmp = (LPWSTR)SysAllocString(pwsz);
        break;
    }

    return pwszTmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\inshandler.cpp ===
// INSHandler.cpp : Implementation of CINSHandler
#include "stdafx.h"
#include "icwhelp.h"
#include "INSHandler.h"
#include "webgate.h"

#include <icwacct.h>

#define MAXNAME             80
#define MAXIPADDRLEN        20
#define MAXLONGLEN          80
#define MAX_ISP_NAME        256
#define MAX_ISP_MSG         560
#define MAX_ISP_PHONENUMBER 80

#define SIZE_ReadBuf    0x00008000    // 32K buffer size
#define myisdigit(ch) (((ch) >= '0') && ((ch) <= '9'))


// The following values are global read only strings used to
// process the INS file
#pragma data_seg(".rdata")

static const TCHAR cszAlias[]         = TEXT("Import_Name");
static const TCHAR cszML[]            = TEXT("Multilink");

static const TCHAR cszPhoneSection[]  = TEXT("Phone");
static const TCHAR cszDialAsIs[]      = TEXT("Dial_As_Is");
static const TCHAR cszPhone[]         = TEXT("Phone_Number");
static const TCHAR cszAreaCode[]      = TEXT("Area_Code");
static const TCHAR cszCountryCode[]   = TEXT("Country_Code");
static const TCHAR cszCountryID[]     = TEXT("Country_ID");

static const TCHAR cszDeviceSection[] = TEXT("Device");
static const TCHAR cszDeviceType[]    = TEXT("Type");
static const TCHAR cszDeviceName[]    = TEXT("Name");
static const TCHAR cszDevCfgSize[]    = TEXT("Settings_Size");
static const TCHAR cszDevCfg[]        = TEXT("Settings");

static const TCHAR cszServerSection[] = TEXT("Server");
static const TCHAR cszServerType[]    = TEXT("Type");
static const TCHAR cszSWCompress[]    = TEXT("SW_Compress");
static const TCHAR cszPWEncrypt[]     = TEXT("PW_Encrypt");
static const TCHAR cszNetLogon[]      = TEXT("Network_Logon");
static const TCHAR cszSWEncrypt[]     = TEXT("SW_Encrypt");
static const TCHAR cszNetBEUI[]       = TEXT("Negotiate_NetBEUI");
static const TCHAR cszIPX[]           = TEXT("Negotiate_IPX/SPX");
static const TCHAR cszIP[]            = TEXT("Negotiate_TCP/IP");
static TCHAR cszDisableLcp[]          = TEXT("Disable_LCP");

static const TCHAR cszIPSection[]     = TEXT("TCP/IP");
static const TCHAR cszIPSpec[]        = TEXT("Specify_IP_Address");
static const TCHAR cszIPAddress[]     = TEXT("IP_address");
static const TCHAR cszServerSpec[]    = TEXT("Specify_Server_Address");
static const TCHAR cszDNSAddress[]    = TEXT("DNS_address");
static const TCHAR cszDNSAltAddress[] = TEXT("DNS_Alt_address");
static const TCHAR cszWINSAddress[]   = TEXT("WINS_address");
static const TCHAR cszWINSAltAddress[]= TEXT("WINS_Alt_address");
static const TCHAR cszIPCompress[]    = TEXT("IP_Header_Compress");
static const TCHAR cszWanPri[]        = TEXT("Gateway_On_Remote");

static const TCHAR cszMLSection[]     = TEXT("Multilink");
static const TCHAR cszLinkIndex[]     = TEXT("Line_%s");

static const TCHAR cszScriptingSection[] = TEXT("Scripting");
static const TCHAR cszScriptName[]    = TEXT("Name");

static const TCHAR cszScriptSection[] = TEXT("Script_File");

static const TCHAR cszCustomDialerSection[] = TEXT("Custom_Dialer");
static const TCHAR cszAutoDialDLL[]   = TEXT("Auto_Dial_DLL");
static const TCHAR cszAutoDialFunc[]  = TEXT("Auto_Dial_Function");

// These strings will be use to populate the registry, with the data above
static const TCHAR cszKeyIcwRmind[]   = TEXT("Software\\Microsoft\\Internet Connection Wizard\\IcwRmind");

static const TCHAR cszTrialRemindSection[] = TEXT("TrialRemind");
static const TCHAR cszEntryISPName[]       = TEXT("ISP_Name");
static const TCHAR cszEntryISPPhone[]      = TEXT("ISP_Phone");
static const TCHAR cszEntryISPMsg[]        = TEXT("ISP_Message");
static const TCHAR cszEntryTrialDays[]     = TEXT("Trial_Days");
static const TCHAR cszEntrySignupURL[]     = TEXT("Signup_URL");
// ICWRMIND expects this value in the registry
static const TCHAR cszEntrySignupURLTrialOver[] = TEXT("Expired_URL");

// We get these two from the INS file 
static const TCHAR cszEntryExpiredISPFileName[] = TEXT("Expired_ISP_File");
static const TCHAR cszSignupExpiredISPURL[] = TEXT("Expired_ISP_URL");

static const TCHAR cszEntryConnectoidName[] = TEXT("Entry_Name");
static const TCHAR cszSignupSuccessfuly[] = TEXT("TrialConverted");

static const TCHAR cszReminderApp[] = TEXT("ICWRMIND.EXE");
static const TCHAR cszReminderParams[] = TEXT("-t");

static const TCHAR cszPassword[]      = TEXT("Password");
static const TCHAR cszCMHeader[]      = TEXT("Connection Manager CMS 0");

extern SERVER_TYPES aServerTypes[];

// These are the field names from an INS file that will
// determine the mail and news settings
static const TCHAR cszMailSection[]       = TEXT("Internet_Mail");
static const TCHAR cszEntryName[]         = TEXT("Entry_Name");
static const TCHAR cszPOPServer[]         = TEXT("POP_Server");
static const TCHAR cszPOPServerPortNumber[] = TEXT("POP_Server_Port_Number");
static const TCHAR cszPOPLogonName[]      = TEXT("POP_Logon_Name");
static const TCHAR cszPOPLogonPassword[]  = TEXT("POP_Logon_Password");
static const TCHAR cszSMTPServer[]        = TEXT("SMTP_Server");
static const TCHAR cszSMTPServerPortNumber[] = TEXT("SMTP_Server_Port_Number");
static const TCHAR cszNewsSection[]       = TEXT("Internet_News");
static const TCHAR cszNNTPServer[]        = TEXT("NNTP_Server");
static const TCHAR cszNNTPServerPortNumber[] = TEXT("NNTP_Server_Port_Number");
static const TCHAR cszNNTPLogonName[]     = TEXT("NNTP_Logon_Name");
static const TCHAR cszNNTPLogonPassword[] = TEXT("NNTP_Logon_Password");
static const TCHAR cszUseMSInternetMail[] = TEXT("Install_Mail");
static const TCHAR cszUseMSInternetNews[] = TEXT("Install_News");


static const TCHAR cszEMailSection[]    = TEXT("Internet_Mail");
static const TCHAR cszEMailName[]       = TEXT("EMail_Name");
static const TCHAR cszEMailAddress[]    = TEXT("EMail_Address");
static const TCHAR cszUseExchange[]     = TEXT("Use_MS_Exchange");
static const TCHAR cszUserSection[]     = TEXT("User");
static const TCHAR cszUserName[]        = TEXT("Name");
static const TCHAR cszDisplayPassword[] = TEXT("Display_Password");
static const TCHAR cszYes[]             = TEXT("yes");
static const TCHAR cszNo[]              = TEXT("no");

#define CLIENT_OFFSET(elem)    ((DWORD)(DWORD_PTR)&(((LPINETCLIENTINFO)(NULL))->elem))
#define CLIENT_SIZE(elem)      sizeof(((LPINETCLIENTINFO)(NULL))->elem)
#define CLIENT_ENTRY(section, value, elem) \
    {section, value, CLIENT_OFFSET(elem), CLIENT_SIZE(elem)}

CLIENT_TABLE iniTable[] =
{
    CLIENT_ENTRY(cszEMailSection, cszEMailName,         szEMailName),
    CLIENT_ENTRY(cszEMailSection, cszEMailAddress,      szEMailAddress),
    CLIENT_ENTRY(cszEMailSection, cszPOPLogonName,      szPOPLogonName),
    CLIENT_ENTRY(cszEMailSection, cszPOPLogonPassword,  szPOPLogonPassword),
    CLIENT_ENTRY(cszEMailSection, cszPOPServer,         szPOPServer),
    CLIENT_ENTRY(cszEMailSection, cszSMTPServer,        szSMTPServer),
    CLIENT_ENTRY(cszNewsSection,  cszNNTPLogonName,     szNNTPLogonName),
    CLIENT_ENTRY(cszNewsSection,  cszNNTPLogonPassword, szNNTPLogonPassword),
    CLIENT_ENTRY(cszNewsSection,  cszNNTPServer,        szNNTPServer),
    {NULL, NULL, 0, 0}
};

static const TCHAR cszFileName[]           = TEXT("Custom_File");
static const TCHAR cszCustomFileSection[]  = TEXT("Custom_File");
static const TCHAR cszNull[] = TEXT("");

static const TCHAR cszURLSection[] = TEXT("URL");
static const TCHAR cszSignupURL[] =  TEXT("Signup");
static const TCHAR cszAutoConfigURL[] =  TEXT("Autoconfig");

static const TCHAR cszExtINS[] = TEXT(".ins");
static const TCHAR cszExtISP[] = TEXT(".isp");
static const TCHAR cszExtHTM[] = TEXT(".htm");
static const TCHAR cszExtHTML[] = TEXT(".html");

static const TCHAR cszEntrySection[]     = TEXT("Entry");
static const TCHAR cszCancel[]           = TEXT("Cancel");
static const TCHAR cszStartURL[]         = TEXT("StartURL");
static const TCHAR cszRun[]              = TEXT("Run");
static const TCHAR cszArgument[]         = TEXT("Argument");

static const TCHAR cszConnect2[]         = TEXT("icwconn2.exe");
static const TCHAR cszClientSetupSection[]  = TEXT("ClientSetup");

static const TCHAR cszRequiresLogon[]  = TEXT("Requires_Logon");

static const TCHAR cszCustomSection[]  = TEXT("Custom");
static const TCHAR cszKeepConnection[] = TEXT("Keep_Connection");
static const TCHAR cszKeepBrowser[]    = TEXT("Keep_Browser");

static const TCHAR cszBrandingSection[]  = TEXT("Branding");
static const TCHAR cszBrandingFlags[] = TEXT("Flags");

static const TCHAR cszHTTPS[] = TEXT("https:");
// code relies on these two being the same length
static const TCHAR cszHTTP[] = TEXT("http:");
static const TCHAR cszFILE[] = TEXT("file:");

static const TCHAR cszKioskMode[] = TEXT("-k ");
static const TCHAR cszOpen[] = TEXT("open");
static const TCHAR cszBrowser[] = TEXT("iexplore.exe");
static const TCHAR szNull[] = TEXT("");

static const TCHAR cszDEFAULT_BROWSER_KEY[] = TEXT("Software\\Microsoft\\Internet Explorer\\Main");
static const TCHAR cszDEFAULT_BROWSER_VALUE[] = TEXT("check_associations");

// Registry keys which will contain News and Mail settings
#define MAIL_KEY        TEXT("SOFTWARE\\Microsoft\\Internet Mail and News\\Mail")
#define MAIL_POP3_KEY    TEXT("SOFTWARE\\Microsoft\\Internet Mail and News\\Mail\\POP3\\")
#define MAIL_SMTP_KEY    TEXT("SOFTWARE\\Microsoft\\Internet Mail and News\\Mail\\SMTP\\")
#define NEWS_KEY        TEXT("SOFTWARE\\Microsoft\\Internet Mail and News\\News")
#define MAIL_NEWS_INPROC_SERVER32 TEXT("CLSID\\{89292102-4755-11cf-9DC2-00AA006C2B84}\\InProcServer32")
typedef HRESULT (WINAPI *PFNSETDEFAULTNEWSHANDLER)(void);

// These are the value names where the INS settings will be saved
// into the registry                                            
static const TCHAR cszMailSenderName[]        = TEXT("Sender Name");
static const TCHAR cszMailSenderEMail[]        = TEXT("Sender EMail");
static const TCHAR cszMailRASPhonebookEntry[]= TEXT("RAS Phonebook Entry");
static const TCHAR cszMailConnectionType[]    = TEXT("Connection Type");
static const TCHAR cszDefaultPOP3Server[]    = TEXT("Default POP3 Server");
static const TCHAR cszDefaultSMTPServer[]    = TEXT("Default SMTP Server");
static const TCHAR cszPOP3Account[]            = TEXT("Account");
static const TCHAR cszPOP3Password[]            = TEXT("Password");
static const TCHAR cszPOP3Port[]                = TEXT("Port");
static const TCHAR cszSMTPPort[]                = TEXT("Port");
static const TCHAR cszNNTPSenderName[]        = TEXT("Sender Name");
static const TCHAR cszNNTPSenderEMail[]        = TEXT("Sender EMail");
static const TCHAR cszNNTPDefaultServer[]    = TEXT("DefaultServer"); // NOTE: NO space between "Default" and "Server".
static const TCHAR cszNNTPAccountName[]        = TEXT("Account Name");
static const TCHAR cszNNTPPassword[]            = TEXT("Password");
static const TCHAR cszNNTPPort[]                = TEXT("Port");
static const TCHAR cszNNTPRasPhonebookEntry[]= TEXT("RAS Phonebook Entry");
static const TCHAR cszNNTPConnectionType[]    = TEXT("Connection Type");

static const TCHAR arBase64[] = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U',
            'V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p',
            'q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9','+','/','='};


#define ICWCOMPLETEDKEY TEXT("Completed")
            
// 2/19/97 jmazner Olympus #1106 -- SAM/SBS integration
TCHAR FAR cszSBSCFG_DLL[] = TEXT("SBSCFG.DLL\0");
CHAR FAR cszSBSCFG_CONFIGURE[] = "Configure\0";
typedef DWORD (WINAPI * SBSCONFIGURE) (HWND hwnd, LPTSTR lpszINSFile, LPTSTR szConnectoidName);
SBSCONFIGURE  lpfnConfigure;

// 09/02/98 Donaldm: Integrate with Connection Manager
TCHAR FAR cszCMCFG_DLL[] = TEXT("CMCFG32.DLL\0");
CHAR  FAR cszCMCFG_CONFIGURE[]   = "CMConfig\0"; // Proc address
CHAR  FAR cszCMCFG_CONFIGUREEX[] = "CMConfigEx\0"; // Proc address

typedef BOOL (WINAPI * CMCONFIGUREEX)(LPCSTR lpszINSFile);
typedef BOOL (WINAPI * CMCONFIGURE)(LPCSTR lpszINSFile, LPCSTR lpszConnectoidNams);
CMCONFIGURE   lpfnCMConfigure;
CMCONFIGUREEX lpfnCMConfigureEx;
            
#pragma data_seg()


//+----------------------------------------------------------------------------
//
//    Function:    CallCMConfig
//
//    Synopsis:    Call into the Connection Manager dll's Configure function to allow CM to
//                process the .ins file as needed.
//
//    Arguements: lpszINSFile -- full path to the .ins file
//
//    Returns:    TRUE if a CM profile is created, FALSE otherwise
//
//    History:    09/02/98    DONALDM
//
//-----------------------------------------------------------------------------
BOOL CINSHandler::CallCMConfig(LPCTSTR lpszINSFile)
{
    HINSTANCE   hCMDLL = NULL;
    BOOL        bRet = FALSE;

    TraceMsg(TF_INSHANDLER, TEXT("ICWCONN1: Calling LoadLibrary on %s\n"), cszCMCFG_DLL);
    // Load DLL and entry point
    hCMDLL = LoadLibrary(cszCMCFG_DLL);
    if (NULL != hCMDLL)
    {

        // To determine whether we should call CMConfig or CMConfigEx
        // Loop to find the appropriate buffer size to retieve the ins to memory
        ULONG ulBufferSize = 1024*10;
        // Parse the ISP section in the INI file to find query pair to append
        TCHAR *pszKeys = NULL;
        PTSTR pszKey = NULL;
        ULONG ulRetVal     = 0;
        BOOL  bEnumerate = TRUE;
        BOOL  bUseEx = FALSE;
 
        PTSTR pszBuff = NULL;
        ulRetVal = 0;

        pszKeys = new TCHAR [ulBufferSize];
        while (ulRetVal < (ulBufferSize - 2))
        {

            ulRetVal = ::GetPrivateProfileString(NULL, NULL, _T(""), pszKeys, ulBufferSize, lpszINSFile);
            if (0 == ulRetVal)
               bEnumerate = FALSE;

            if (ulRetVal < (ulBufferSize - 2))
            {
                break;
            }
            delete [] pszKeys;
            ulBufferSize += ulBufferSize;
            pszKeys = new TCHAR [ulBufferSize];
            if (!pszKeys)
            {
                bEnumerate = FALSE;
            }

        }

        if (bEnumerate)
        {
            pszKey = pszKeys;
            if (ulRetVal != 0) 
            {
                while (*pszKey)
                {
                    if (!lstrcmpi(pszKey, cszCMHeader)) 
                    {
                        bUseEx = TRUE;
                        break;
                    }
                    pszKey += lstrlen(pszKey) + 1;
                }
            }
        }


        if (pszKeys)
            delete [] pszKeys;
        
        TCHAR   szConnectoidName[RAS_MaxEntryName];
        // Get the connectoid name from the [Entry] Section
        GetPrivateProfileString(cszEntrySection,
                                    cszEntryName,
                                    cszNull,
                                    szConnectoidName,
                                    RAS_MaxEntryName,
                                    lpszINSFile);

        if (bUseEx)
        {
            // Call CMConfigEx
            lpfnCMConfigureEx = (CMCONFIGUREEX)GetProcAddress(hCMDLL,cszCMCFG_CONFIGUREEX);
            if( lpfnCMConfigureEx )
            {
#ifdef UNICODE
                CHAR szFile[_MAX_PATH + 1];

                wcstombs(szFile, lpszINSFile, _MAX_PATH + 1);

                bRet = lpfnCMConfigureEx(szFile);    
#else
                bRet = lpfnCMConfigureEx(lpszINSFile);    
#endif
            }
        }
        else
        {
            // Call CMConfig
            lpfnCMConfigure = (CMCONFIGURE)GetProcAddress(hCMDLL,cszCMCFG_CONFIGURE);
            // Call function
            if( lpfnCMConfigure )
            {

#ifdef UNICODE
                CHAR szEntry[RAS_MaxEntryName];
                CHAR szFile[_MAX_PATH + 1];

                wcstombs(szEntry, szConnectoidName, RAS_MaxEntryName);
                wcstombs(szFile, lpszINSFile, _MAX_PATH + 1);

                bRet = lpfnCMConfigure(szFile, szEntry);  
#else
                bRet = lpfnCMConfigure(lpszINSFile, szConnectoidName);  
#endif

            }
        }

        if (bRet)
        {
            // restore original autodial settings
            m_lpfnInetSetAutodial(TRUE, szConnectoidName);
        }
    }

    // Cleanup
    if( hCMDLL )
        FreeLibrary(hCMDLL);
    if( lpfnCMConfigure )
        lpfnCMConfigure = NULL;

    TraceMsg(TF_INSHANDLER, TEXT("ICWCONN1: CallSBSConfig exiting with error code %d \n"), bRet);
    return bRet;
}


//+----------------------------------------------------------------------------
//
//    Function:    CallSBSConfig
//
//    Synopsis:    Call into the SBSCFG dll's Configure function to allow SBS to
//                process the .ins file as needed
//
//    Arguements: hwnd -- hwnd of parent, in case sbs wants to put up messages
//                lpszINSFile -- full path to the .ins file
//
//    Returns:    windows error code that sbscfg returns.
//
//    History:    2/19/97    jmazner    Created for Olympus #1106
//
//-----------------------------------------------------------------------------
DWORD CINSHandler::CallSBSConfig(HWND hwnd, LPCTSTR lpszINSFile)
{
    HINSTANCE   hSBSDLL = NULL;
    DWORD       dwRet = ERROR_SUCCESS;
    TCHAR       lpszConnectoidName[RAS_MaxEntryName] = TEXT("nogood\0");

    //
    // Get name of connectoid we created by looking in autodial
    // We need to pass this name into SBSCFG
    // 5/14/97    jmazner    Windosw NT Bugs #87209
    //
    BOOL fEnabled = FALSE;

    if( NULL == m_lpfnInetGetAutodial )
    {
        TraceMsg(TF_INSHANDLER, TEXT("m_lpfnInetGetAutodial is NULL!!!!"));
        return ERROR_INVALID_FUNCTION;
    }

    dwRet = m_lpfnInetGetAutodial(&fEnabled,lpszConnectoidName,RAS_MaxEntryName);

    TraceMsg(TF_INSHANDLER, TEXT("ICWCONN1: Calling LoadLibrary on %s\n"), cszSBSCFG_DLL);
    hSBSDLL = LoadLibrary(cszSBSCFG_DLL);

    // Load DLL and entry point
    if (NULL != hSBSDLL)
    {
        TraceMsg(TF_INSHANDLER, TEXT("ICWCONN1: Calling GetProcAddress on %s\n"), cszSBSCFG_CONFIGURE);
        lpfnConfigure = (SBSCONFIGURE)GetProcAddress(hSBSDLL,cszSBSCFG_CONFIGURE);
    }
    else
    {
        // 4/2/97    ChrisK    Olympus 2759
        // If the DLL can't be loaded, pick a specific error message to return.
        dwRet = ERROR_DLL_NOT_FOUND;
        goto CallSBSConfigExit;
    }
    
    // Call function
    if( hSBSDLL && lpfnConfigure )
    {
        TraceMsg(TF_INSHANDLER, TEXT("ICWCONN1: Calling the Configure entry point: %s, %s\n"), lpszINSFile, lpszConnectoidName);
        dwRet = lpfnConfigure(hwnd, (TCHAR *)lpszINSFile, lpszConnectoidName);    
    }
    else
    {
        TraceMsg(TF_INSHANDLER, TEXT("ICWCONN1: Unable to call the Configure entry point\n"));
        dwRet = GetLastError();
    }

CallSBSConfigExit:
    if( hSBSDLL )
        FreeLibrary(hSBSDLL);
    if( lpfnConfigure )
        lpfnConfigure = NULL;

    TraceMsg(TF_INSHANDLER, TEXT("ICWCONN1: CallSBSConfig exiting with error code %d \n"), dwRet);
    return dwRet;
}

BOOL CINSHandler::SetICWCompleted( DWORD dwCompleted )
{
    HKEY hKey = NULL;

    HRESULT hr = RegCreateKey(HKEY_CURRENT_USER,ICWSETTINGSPATH,&hKey);
    if (ERROR_SUCCESS == hr)
    {
        hr = RegSetValueEx(hKey, ICWCOMPLETEDKEY, 0, REG_DWORD,
                    (CONST BYTE*)&dwCompleted, sizeof(dwCompleted));
        RegCloseKey(hKey);
    }

    if( ERROR_SUCCESS == hr )
        return TRUE;
    else
        return FALSE;

}

/////////////////////////////////////////////////////////////////////////////
// CINSHandler


HRESULT CINSHandler::OnDraw(ATL_DRAWINFO& di)
{
    return S_OK;
}

#define FILE_BUFFER_SIZE 65534
#ifndef FILE_BEGIN
#define FILE_BEGIN  0
#endif

//+---------------------------------------------------------------------------
//
//  Function:   MassageFile
//
//  Synopsis:   Convert 0x0d's in the file to 0x0d 0x0A sequences
//
//+---------------------------------------------------------------------------
HRESULT CINSHandler::MassageFile(LPCTSTR lpszFile)
{
    LPBYTE  lpBufferIn;
    LPBYTE  lpBufferOut;
    HFILE   hfile;
    HRESULT hr = ERROR_SUCCESS;

    if (!SetFileAttributes(lpszFile, FILE_ATTRIBUTE_NORMAL))
    {
        return GetLastError();
    }

    lpBufferIn = (LPBYTE) GlobalAlloc(GPTR, 2 * FILE_BUFFER_SIZE);
    if (NULL == lpBufferIn)
    {
        return ERROR_OUTOFMEMORY;
    }
    lpBufferOut = lpBufferIn + FILE_BUFFER_SIZE;

#ifdef UNICODE
    CHAR szTmp[MAX_PATH+1];
    wcstombs(szTmp, lpszFile, MAX_PATH+1);
    hfile = _lopen(szTmp, OF_READWRITE);
#else
    hfile = _lopen(lpszFile, OF_READWRITE);
#endif
    if (HFILE_ERROR != hfile)
    {
        BOOL    fChanged = FALSE;
        UINT    uBytesOut = 0;
        UINT    uBytesIn = _lread(hfile, lpBufferIn, (UINT)(FILE_BUFFER_SIZE - 1));

        // Note:  we asume, in our use of lpCharIn, that the file is always less than
        // FILE_BUFFER_SIZE
        if (HFILE_ERROR != uBytesIn)
        {
            LPBYTE  lpCharIn = lpBufferIn;
            LPBYTE  lpCharOut = lpBufferOut;

            while ((*lpCharIn) && (FILE_BUFFER_SIZE - 2 > uBytesOut))
            {
              *lpCharOut++ = *lpCharIn;
              uBytesOut++;
              if ((0x0d == *lpCharIn) && (0x0a != *(lpCharIn + 1)))
              {
                fChanged = TRUE;

                *lpCharOut++ = 0x0a;
                uBytesOut++;
              }
              lpCharIn++;
            }

            if (fChanged)
            {
                if (HFILE_ERROR != _llseek(hfile, 0, FILE_BEGIN))
                {
                    if (HFILE_ERROR ==_lwrite(hfile, (LPCSTR) lpBufferOut, uBytesOut))
                    {
                        hr = GetLastError();
                    }
                }
                else
                {
                    hr = GetLastError();
                }
            }
        }
        else
        {
            hr = GetLastError();
        }
        _lclose(hfile);
    }
    else
    {
        hr = GetLastError();
    }

    GlobalFree((HGLOBAL)lpBufferIn);
    return ERROR_SUCCESS;
}

DWORD CINSHandler::RunExecutable(void)
{
    DWORD               dwRet;
    SHELLEXECUTEINFO    sei;

    // Hide the active window first
    HWND  hWndHide = GetActiveWindow();
    ::ShowWindow(hWndHide, SW_HIDE);
    
    sei.cbSize = sizeof(sei);
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.hwnd = NULL;
    sei.lpVerb = cszOpen;
    sei.lpFile = m_szRunExecutable;
    sei.lpParameters = m_szRunArgument;
    sei.lpDirectory = NULL;
    sei.nShow = SW_SHOWNORMAL;
    sei.hInstApp = NULL;
    // Optional members 
    sei.hProcess = NULL;

    if (ShellExecuteEx(&sei))
    {
        DWORD iWaitResult = 0;
        // wait for event or msgs. Dispatch msgs. Exit when event is signalled.
        while((iWaitResult=MsgWaitForMultipleObjects(1, &sei.hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
        {
           MSG msg ;
           // read all of the messages in this next loop
           // removing each message as we read it
           while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
           {
               if (msg.message == WM_QUIT)
               {
                   CloseHandle(sei.hProcess);
                   return NO_ERROR;
               }
               else
                   DispatchMessage(&msg);
            }
        }

        CloseHandle(sei.hProcess);
        dwRet = ERROR_SUCCESS;
    }
    else
    {
        dwRet = GetLastError();
    }

    ::ShowWindow(hWndHide, SW_SHOW);
    
    return dwRet;
}

void CINSHandler::SaveAutoDial(void)
{
    Assert(m_lpfnInetGetAutodial);
    Assert(m_lpfnInetGetProxy);
    Assert(m_lpfnInetSetProxy);

    // if the original autodial settings have not been saved 
    if (!m_fAutodialSaved)
    {
        // save the current autodial settings
        m_lpfnInetGetAutodial(
                &m_fAutodialEnabled,
                m_szAutodialConnection,
                sizeof(m_szAutodialConnection));

        m_lpfnInetGetProxy(
                &m_fProxyEnabled,
                NULL, 0,
                NULL, 0);

        // turn off proxy
        m_lpfnInetSetProxy(FALSE, NULL, NULL);

        m_fAutodialSaved = TRUE;
    }
}

void CINSHandler::RestoreAutoDial(void)
{
    Assert(m_lpfnInetSetAutodial);
    Assert(m_lpfnInetSetProxy);

    if (m_fAutodialSaved)
    {
        // restore original autodial settings
        m_lpfnInetSetAutodial(m_fAutodialEnabled, m_szAutodialConnection);
        m_fAutodialSaved = FALSE;
    }
}

BOOL CINSHandler::KeepConnection(LPCTSTR lpszFile)
{
    TCHAR szTemp[10];

    GetPrivateProfileString(cszCustomSection,
                            cszKeepConnection,
                            cszNo,
                            szTemp,
                            10,
                            lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}

DWORD CINSHandler::ImportCustomInfo
(
    LPCTSTR lpszImportFile,
    LPTSTR lpszExecutable,
    DWORD cbExecutable,
    LPTSTR lpszArgument,
    DWORD cbArgument
)
{
    GetPrivateProfileString(cszCustomSection,
                              cszRun,
                              cszNull,
                              lpszExecutable,
                              (int)cbExecutable,
                              lpszImportFile);

    GetPrivateProfileString(cszCustomSection,
                              cszArgument,
                              cszNull,
                              lpszArgument,
                              (int)cbArgument,
                              lpszImportFile);

    return ERROR_SUCCESS;
}


DWORD CINSHandler::ImportFile
(
    LPCTSTR lpszImportFile, 
    LPCTSTR lpszSection, 
    LPCTSTR lpszOutputFile
)
{
    HFILE   hFile;
    LPTSTR  pszLine, pszFile;
    int     i, iMaxLine;
    UINT    cbSize, cbRet;
    DWORD   dwRet = ERROR_SUCCESS;

    // Allocate a buffer for the file
    if ((pszFile = (LPTSTR)LocalAlloc(LMEM_FIXED, SIZE_ReadBuf * 2)) == NULL)
    { 
        return ERROR_OUTOFMEMORY;
    }

    // Look for script
    if (GetPrivateProfileString(lpszSection,
                                NULL,
                                szNull,
                                pszFile,
                                SIZE_ReadBuf / sizeof(TCHAR),
                                lpszImportFile) != 0)
    {
        // Get the maximum line number
        pszLine = pszFile;
        iMaxLine = -1;
        while (*pszLine)
        {
            i = _ttoi(pszLine);
            iMaxLine = max(iMaxLine, i);
            pszLine += lstrlen(pszLine)+1;
        };

        // If we have at least one line, we will import the script file
        if (iMaxLine >= 0)
        {
            // Create the script file
#ifdef UNICODE
            CHAR szTmp[MAX_PATH+1];
            wcstombs(szTmp, lpszOutputFile, MAX_PATH+1);
            hFile = _lcreat(szTmp, 0);
#else
            hFile = _lcreat(lpszOutputFile, 0);
#endif

            if (hFile != HFILE_ERROR)
            {     
                TCHAR  szLineNum[MAXLONGLEN+1];

                // From The first line to the last line
                for (i = 0; i <= iMaxLine; i++)
                {
                    // Read the script line
                    wsprintf(szLineNum, TEXT("%d"), i);
                    if ((cbSize = GetPrivateProfileString(lpszSection,
                                                          szLineNum,
                                                          szNull,
                                                          pszLine,
                                                          SIZE_ReadBuf / sizeof(TCHAR),
                                                          lpszImportFile)) != 0)
                    {
                        // Write to the script file
                        lstrcat(pszLine, TEXT("\x0d\x0a"));
#ifdef UNICODE
                        wcstombs(szTmp, pszLine, MAX_PATH+1);
                        cbRet=_lwrite(hFile, szTmp, cbSize+2);
#else
			cbRet=_lwrite(hFile, pszLine, cbSize+2);
#endif
                    }
                }
                _lclose(hFile);
            }
            else
            {
                dwRet = ERROR_PATH_NOT_FOUND;
            }
        }
        else
        {
            dwRet = ERROR_PATH_NOT_FOUND;
        }
    }
    else
    {
        dwRet = ERROR_PATH_NOT_FOUND;
    }
    LocalFree(pszFile);

    return dwRet;
}

DWORD CINSHandler::ImportCustomFile
(
    LPCTSTR lpszImportFile
)
{
    TCHAR   szFile[_MAX_PATH];
    TCHAR   szTemp[_MAX_PATH];

    // If a custom file name does not exist, do nothing
    if (GetPrivateProfileString(cszCustomSection,
                                cszFileName,
                                cszNull,
                                szTemp,
                                _MAX_PATH,
                                lpszImportFile) == 0)
    {
        return ERROR_SUCCESS;
    };

    GetWindowsDirectory(szFile, _MAX_PATH);
    if (*CharPrev(szFile, szFile + lstrlen(szFile)) != '\\')
    {
        lstrcat(szFile, TEXT("\\"));
    }
    lstrcat(szFile, szTemp);
  
    return (ImportFile(lpszImportFile, cszCustomFileSection, szFile));
}

BOOL CINSHandler::LoadExternalFunctions(void)
{
    BOOL    bRet = FALSE;

    do 
    {
        // Load the Brading library functions
        m_hBranding = LoadLibrary(TEXT("IEDKCS32.DLL"));
        if (m_hBranding != NULL)
        {
            if (NULL == (m_lpfnBrandICW = (PFNBRANDICW)GetProcAddress(m_hBranding, "BrandICW2")))
                break;
        }
        else
        {
            break;
        }

        // Load the Inet Config library functions
        m_hInetCfg = LoadLibrary(TEXT("INETCFG.DLL"));
        if (m_hInetCfg != NULL)
        {
#ifdef UNICODE
            if (NULL == (m_lpfnInetConfigSystem = (PFNINETCONFIGSYSTEM)GetProcAddress(m_hInetCfg, "InetConfigSystem")))
                break;
            if (NULL == (m_lpfnInetGetProxy = (PFNINETGETPROXY)GetProcAddress(m_hInetCfg, "InetGetProxyW")))
                break;
            if (NULL == (m_lpfnInetConfigClient = (PFNINETCONFIGCLIENT)GetProcAddress(m_hInetCfg, "InetConfigClientW")))
                break;
            //if (NULL == (m_lpfnInetConfigClientEx = (PFNINETCONFIGCLIENTEX)GetProcAddress(m_hInetCfg, "InetConfigClientExW")))
            //    break;
            if (NULL == (m_lpfnInetGetAutodial = (PFNINETGETAUTODIAL)GetProcAddress(m_hInetCfg, "InetGetAutodialW")))
                break;
            if (NULL == (m_lpfnInetSetAutodial = (PFNINETSETAUTODIAL)GetProcAddress(m_hInetCfg, "InetSetAutodialW")))
                break;
            if (NULL == (m_lpfnInetSetClientInfo = (PFNINETSETCLIENTINFO)GetProcAddress(m_hInetCfg, "InetSetClientInfoW")))
                break;
            if (NULL == (m_lpfnInetSetProxy = (PFNINETSETPROXY)GetProcAddress(m_hInetCfg, "InetSetProxyW")))
                break;
#else  // UNICODE
            if (NULL == (m_lpfnInetConfigSystem = (PFNINETCONFIGSYSTEM)GetProcAddress(m_hInetCfg, "InetConfigSystem")))
                break;
            if (NULL == (m_lpfnInetGetProxy = (PFNINETGETPROXY)GetProcAddress(m_hInetCfg, "InetGetProxy")))
                break;
            if (NULL == (m_lpfnInetConfigClient = (PFNINETCONFIGCLIENT)GetProcAddress(m_hInetCfg, "InetConfigClient")))
                break;
            if (NULL == (m_lpfnInetGetAutodial = (PFNINETGETAUTODIAL)GetProcAddress(m_hInetCfg, "InetGetAutodial")))
                break;
            if (NULL == (m_lpfnInetSetAutodial = (PFNINETSETAUTODIAL)GetProcAddress(m_hInetCfg, "InetSetAutodial")))
                break;
            if (NULL == (m_lpfnInetSetClientInfo = (PFNINETSETCLIENTINFO)GetProcAddress(m_hInetCfg, "InetSetClientInfo")))
                break;
            if (NULL == (m_lpfnInetSetProxy = (PFNINETSETPROXY)GetProcAddress(m_hInetCfg, "InetSetProxy")))
                break;
#endif // UNICODE
        }
        else
        {
            break;
        }

        if( IsNT() )
        {
            // Load the RAS functions
            m_hRAS = LoadLibrary(TEXT("RASAPI32.DLL"));
            if (m_hRAS != NULL)
            {
#ifdef UNICODE
                if (NULL == (m_lpfnRasSetAutodialEnable = (PFNRASSETAUTODIALENABLE)GetProcAddress(m_hRAS, "RasSetAutodialEnableW")))
                    break;
                if (NULL == (m_lpfnRasSetAutodialAddress = (PFNRASSETAUTODIALADDRESS)GetProcAddress(m_hRAS, "RasSetAutodialAddressW")))
                    break;
#else
                if (NULL == (m_lpfnRasSetAutodialEnable = (PFNRASSETAUTODIALENABLE)GetProcAddress(m_hRAS, "RasSetAutodialEnableA")))
                    break;
                if (NULL == (m_lpfnRasSetAutodialAddress = (PFNRASSETAUTODIALADDRESS)GetProcAddress(m_hRAS, "RasSetAutodialAddressA")))
                    break;
#endif
            }
            else
            {
                break;
            }
        }

        // Success if we get to here
        bRet = TRUE;
        break;
    } while(1);

    return bRet;
}

//-----------------------------------------------------------------------------
//    OpenIcwRmindKey
//-----------------------------------------------------------------------------
BOOL CINSHandler::OpenIcwRmindKey(CMcRegistry &reg)
{
    // This method will open the IcwRmind key in the registry.  If the key
    // does not exist it will be created here.
    bool bRetCode = reg.OpenKey(HKEY_LOCAL_MACHINE, cszKeyIcwRmind);

    if (!bRetCode)
    {
         bRetCode = reg.CreateKey(HKEY_LOCAL_MACHINE, cszKeyIcwRmind);
        _ASSERT(bRetCode);
    }

    return bRetCode;
}

BOOL CINSHandler::ConfigureTrialReminder
(
    LPCTSTR  lpszFile
)
{
    USES_CONVERSION;
    
    TCHAR   szISPName[MAX_ISP_NAME];
    TCHAR   szISPMsg[MAX_ISP_MSG];
    TCHAR   szISPPhoneNumber[MAX_ISP_PHONENUMBER];
    int     iTrialDays;
    TCHAR   szConvertURL[INTERNET_MAX_URL_LENGTH];
    
    TCHAR   szExpiredISPFileURL[INTERNET_MAX_URL_LENGTH];
    TCHAR   szExpiredISPFileName[MAX_PATH]; // The fully qualified path to the final INS file
    TCHAR   szISPFile[MAX_PATH];            // The name we get in the INS
    
    TCHAR   szConnectoidName[MAXNAME];
    
    if (GetPrivateProfileString(cszTrialRemindSection,
                                cszEntryISPName,
                                cszNull,
                                szISPName,
                                MAX_ISP_NAME,
                                lpszFile) == 0)
    {
        return FALSE;
    }

    if (GetPrivateProfileString(cszTrialRemindSection,
                                cszEntryISPPhone,
                                cszNull,
                                szISPPhoneNumber,
                                MAX_ISP_PHONENUMBER,
                                lpszFile) == 0)
    {
        return FALSE;
    }

    if ((iTrialDays = GetPrivateProfileInt(cszTrialRemindSection,
                                           cszEntryTrialDays,
                                           0,
                                           lpszFile)) == 0)
    {
        return FALSE;
    }
           
    
    if (GetPrivateProfileString(cszTrialRemindSection,
                                cszEntrySignupURL,
                                cszNull,
                                szConvertURL,
                                INTERNET_MAX_URL_LENGTH,
                                lpszFile) == 0)
    {
        return FALSE;
    }

    //optional
    GetPrivateProfileString(cszTrialRemindSection,
                                cszEntryISPMsg,
                                cszNull,
                                szISPMsg,
                                MAX_ISP_MSG,
                                lpszFile);
    
    // Get the connectoid name from the [Entry] Section
    if (GetPrivateProfileString(cszEntrySection,
                                cszEntryName,
                                cszNull,
                                szConnectoidName,
                                MAXNAME,
                                lpszFile) == 0)
    {
        return FALSE;
    }    
    
    // If we get to here, we have everything to setup a trial, so let's do it.
    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        // Set the values we have
        reg.SetValue(cszEntryISPName, szISPName);
        reg.SetValue(cszEntryISPMsg, szISPMsg);
        reg.SetValue(cszEntryISPPhone, szISPPhoneNumber);
        reg.SetValue(cszEntryTrialDays, (DWORD)iTrialDays);
        reg.SetValue(cszEntrySignupURL, szConvertURL);
        reg.SetValue(cszEntryConnectoidName, szConnectoidName);
        
        // See if we have to create an ISP file        
        if (GetPrivateProfileString(cszTrialRemindSection,
                                    cszEntryExpiredISPFileName,
                                    cszNull,
                                    szISPFile,
                                    MAX_PATH,
                                    lpszFile) != 0)
        {
    
            // Set the fully qualified path for the ISP file name
            wsprintf(szExpiredISPFileName,TEXT("%s\\%s"),g_pszAppDir,szISPFile);
            
            if (GetPrivateProfileString(cszTrialRemindSection,
                                        cszSignupExpiredISPURL,
                                        cszNull,
                                        szExpiredISPFileURL,
                                        INTERNET_MAX_URL_LENGTH,
                                        lpszFile) != 0)
            {
                
                // Download the ISP file, and then copy its contents
                IWebGate    *pWebGate;
                CComBSTR    bstrURL;
                CComBSTR    bstrFname;
                BOOL        bRetVal;
                
                if (SUCCEEDED(CoCreateInstance (CLSID_WebGate, 
                                         NULL, 
                                         CLSCTX_INPROC_SERVER,
                                         IID_IWebGate, 
                                         (void **)&pWebGate)))
                {
                    // Setup the webGate object, and download the ISP file
                    bstrURL = A2BSTR(szExpiredISPFileURL);
                    pWebGate->put_Path(bstrURL);
                    pWebGate->FetchPage(1, 1, &bRetVal);
                    if (bRetVal)
                    {
                        pWebGate->get_DownloadFname(&bstrFname);                                
                
                        // Copy the file from the temp location, making sure one does not
                        // yet exist
                        DeleteFile(szExpiredISPFileName);
                        MoveFile(OLE2A(bstrFname), szExpiredISPFileName);
                    
                        // Write the new file to the registry
                        reg.SetValue(cszEntrySignupURLTrialOver, szExpiredISPFileName);
                    }                                
                    pWebGate->Release();
                }                    
            }                
        }        
    }
    
    return TRUE;
    
}

DWORD CINSHandler::ImportBrandingInfo
(
    LPCTSTR lpszFile,
    LPCTSTR lpszConnectoidName
)
{
    TCHAR szPath[_MAX_PATH + 1];
    Assert(m_lpfnBrandICW != NULL);

    GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
    NULL_TERM_TCHARS(szPath);

#ifdef WIN32
#ifdef UNICODE
    CHAR szEntry[RAS_MaxEntryName];
    CHAR szFile[_MAX_PATH + 1];
    CHAR szAsiPath[_MAX_PATH + 1];

    WideCharToMultiByte(CP_ACP, 0, lpszFile, -1, szFile, _MAX_PATH + 1, NULL, NULL);
    WideCharToMultiByte(CP_ACP, 0, szPath, -1, szAsiPath, _MAX_PATH + 1, NULL, NULL);
    WideCharToMultiByte(CP_ACP, 0, lpszConnectoidName, -1, szEntry, RAS_MaxEntryName, NULL, NULL);
    m_lpfnBrandICW(szFile, szAsiPath, m_dwBrandFlags, szEntry);


#else
    m_lpfnBrandICW(lpszFile, szPath, m_dwBrandFlags, lpszConnectoidName);
#endif
#endif

    return ERROR_SUCCESS;
}


DWORD CINSHandler::ReadClientInfo
(
    LPCTSTR lpszFile, 
    LPINETCLIENTINFO lpClientInfo, 
    LPCLIENT_TABLE lpClientTable
)
{
    LPCLIENT_TABLE lpTable;

    for (lpTable = lpClientTable; NULL != lpTable->lpszSection; ++lpTable)
    {
        GetPrivateProfileString(lpTable->lpszSection,
                lpTable->lpszValue,
                cszNull,
                (LPTSTR)((LPBYTE)lpClientInfo + lpTable->uOffset),
                lpTable->uSize / sizeof(TCHAR),
                lpszFile);
    }

    lpClientInfo->dwFlags = 0;
    if (*lpClientInfo->szPOPLogonName)
    {
        lpClientInfo->dwFlags |= INETC_LOGONMAIL;
    }
    if ((*lpClientInfo->szNNTPLogonName) || (*lpClientInfo->szNNTPServer))
    {
        lpClientInfo->dwFlags |= INETC_LOGONNEWS;
    }

    return ERROR_SUCCESS;
}

BOOL CINSHandler::WantsExchangeInstalled(LPCTSTR lpszFile)
{
    TCHAR szTemp[10];

    GetPrivateProfileString(cszEMailSection,
            cszUseExchange,
            cszNo,
            szTemp,
            10,
            lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}

BOOL CINSHandler::DisplayPassword(LPCTSTR lpszFile)
{
    TCHAR szTemp[10];

    GetPrivateProfileString(cszUserSection,
            cszDisplayPassword,
            cszNo,
            szTemp,
            10,
            lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}

DWORD CINSHandler::ImportClientInfo
(
    LPCTSTR lpszFile,
    LPINETCLIENTINFO lpClientInfo
)
{
    DWORD dwRet;

    lpClientInfo->dwSize = sizeof(INETCLIENTINFO);

    dwRet = ReadClientInfo(lpszFile, lpClientInfo, iniTable);

    return dwRet;
}

DWORD CINSHandler::ConfigureClient
(
    HWND hwnd,
    LPCTSTR lpszFile,
    LPBOOL lpfNeedsRestart,
    LPBOOL lpfConnectoidCreated,
    BOOL fHookAutodial,
    LPTSTR szConnectoidName,
    DWORD dwConnectoidNameSize   
)
{
    LPICONNECTION       pConn;
    LPINETCLIENTINFO    pClientInfo = NULL;
    DWORD               dwRet = ERROR_SUCCESS;
    UINT                cb = sizeof(ICONNECTION) + sizeof(INETCLIENTINFO);
    DWORD               dwfOptions = INETCFG_INSTALLTCP | INETCFG_WARNIFSHARINGBOUND;
    LPRASENTRY          pRasEntry = NULL;

    //
    // ChrisK Olympus 4756 5/25/97
    // Do not display busy animation on Win95
    //
    if (!m_bSilentMode && IsNT())
    {
        dwfOptions |=  INETCFG_SHOWBUSYANIMATION;
    }

    // Allocate a buffer for connection and clientinfo objects
    //
    if ((pConn = (LPICONNECTION)LocalAlloc(LPTR, cb)) == NULL)
    {
        return ERROR_OUTOFMEMORY;
    }

    if (WantsExchangeInstalled(lpszFile))
    {
        dwfOptions |= INETCFG_INSTALLMAIL;
    }

    // Create either a CM profile, or a connectoid
    if (CallCMConfig(lpszFile))
    {
        *lpfConnectoidCreated = TRUE;       // A dialup connection was created
    }
    else
    {
        dwRet = ImportConnection(lpszFile, pConn);
        if (ERROR_SUCCESS == dwRet)
        {
            pRasEntry = &pConn->RasEntry;
            dwfOptions |= INETCFG_SETASAUTODIAL |
                        INETCFG_INSTALLRNA |
                        INETCFG_INSTALLMODEM;
        }
        else if (ERROR_CANNOT_FIND_PHONEBOOK_ENTRY != dwRet)
        {
            return dwRet;
        }

        if (!m_bSilentMode && DisplayPassword(lpszFile))
        {
            if (*pConn->szPassword || *pConn->szUserName)
            {
                TCHAR szFmt[1024];
                TCHAR szMsg[1024];

                LoadString(_Module.GetModuleInstance(), IDS_PASSWORD, szFmt, 1024);
                wsprintf(szMsg, szFmt, pConn->szUserName, pConn->szPassword);

                ::MessageBox(hwnd, szMsg, GetSz(IDS_TITLE), MB_ICONINFORMATION | MB_OK);
            }
        }

        if (fHookAutodial &&
            ((0 == *pConn->RasEntry.szAutodialDll) ||
             (0 == *pConn->RasEntry.szAutodialFunc)))
        {
            lstrcpy(pConn->RasEntry.szAutodialDll, TEXT("isign32.dll"));
            lstrcpy(pConn->RasEntry.szAutodialFunc, TEXT("AutoDialLogon"));
        }
     
        // humongous hack for ISBU
        Assert(m_lpfnInetConfigClient);
        Assert(m_lpfnInetGetAutodial);

        dwRet = m_lpfnInetConfigClient(hwnd,
                                     NULL,
                                     pConn->szEntryName,
                                     pRasEntry,
                                     pConn->szUserName,
                                     pConn->szPassword,
                                     NULL,
                                     NULL,
                                     dwfOptions & ~INETCFG_INSTALLMAIL,
                                     lpfNeedsRestart);
        lstrcpy(szConnectoidName, pConn->szEntryName);

        LclSetEntryScriptPatch(pRasEntry->szScript,pConn->szEntryName);
        BOOL fEnabled = TRUE;
        DWORD dwResult = 0xba;
        dwResult = m_lpfnInetGetAutodial(&fEnabled, pConn->szEntryName, RAS_MaxEntryName);
        if ((ERROR_SUCCESS == dwRet) && lstrlen(pConn->szEntryName))
        {
            *lpfConnectoidCreated = (NULL != pRasEntry);
            PopulateNTAutodialAddress( lpszFile, pConn->szEntryName );
        }
        else
        {
            TraceMsg(TF_INSHANDLER, TEXT("ISIGNUP: ERROR: InetGetAutodial failed, will not be able to set NT Autodial\n"));
        }
    }

    // If we were successfull in creating the connectio, then see if the user wants a 
    // mail client installed       
    if (ERROR_SUCCESS == dwRet)
    {
        // Get the mail client info
        INETCLIENTINFO pClientInfo;

        ImportClientInfo(lpszFile, &pClientInfo);
    
        // use inet config to install the mail client
        dwRet = m_lpfnInetConfigClient(hwnd,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &pClientInfo, 
                                     dwfOptions & INETCFG_INSTALLMAIL,
                                     lpfNeedsRestart);
    }

    // cleanup
    LocalFree(pConn);
    return dwRet;
 }


//+----------------------------------------------------------------------------
//
//    Function:    PopulateNTAutodialAddress
//
//    Synopsis:    Take Internet addresses from INS file and load them into the
//                autodial database
//
//    Arguments:    pszFileName - pointer to INS file name
//
//    Returns:    Error code (ERROR_SUCCESS == success)
//
//    History:    8/29/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
#define AUTODIAL_ADDRESS_BUFFER_SIZE 2048
#define AUTODIAL_ADDRESS_SECTION_NAME TEXT("Autodial_Addresses_for_NT")
HRESULT CINSHandler::PopulateNTAutodialAddress(LPCTSTR pszFileName, LPCTSTR pszEntryName)
{
    HRESULT hr = ERROR_SUCCESS;
    LONG lRC = 0;
    LPLINETRANSLATECAPS lpcap = NULL;
    LPLINETRANSLATECAPS lpTemp = NULL;
    LPLINELOCATIONENTRY lpLE = NULL;
    LPRASAUTODIALENTRY rADE;
    INT idx = 0;
    LPTSTR lpszBuffer = NULL;
    LPTSTR lpszNextAddress = NULL;
    rADE = NULL;

    Assert(m_lpfnRasSetAutodialEnable);
    Assert(m_lpfnRasSetAutodialAddress);

    //RNAAPI *pRnaapi = NULL;

    // jmazner  10/8/96  this function is NT specific
    if( !IsNT() )
    {
        TraceMsg(TF_INSHANDLER, TEXT("ISIGNUP: Bypassing PopulateNTAutodialAddress for win95.\r\n"));
        return( ERROR_SUCCESS );
    }

    //Assert(pszFileName && pszEntryName);
    //dprintf("ISIGNUP: PopulateNTAutodialAddress "%s %s.\r\n",pszFileName, pszEntryName);
    TraceMsg(TF_INSHANDLER, pszFileName);
    TraceMsg(TF_INSHANDLER, TEXT(", "));
    TraceMsg(TF_INSHANDLER, pszEntryName);
    TraceMsg(TF_INSHANDLER, TEXT(".\r\n"));

    //
    // Get list of TAPI locations
    //
    lpcap = (LPLINETRANSLATECAPS)GlobalAlloc(GPTR,sizeof(LINETRANSLATECAPS));
    if (!lpcap)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto PopulateNTAutodialAddressExit;
    }
    lpcap->dwTotalSize = sizeof(LINETRANSLATECAPS);
    lRC = lineGetTranslateCaps(0,0x10004,lpcap);
    if (SUCCESS == lRC)
    {
        lpTemp = (LPLINETRANSLATECAPS)GlobalAlloc(GPTR,lpcap->dwNeededSize);
        if (!lpTemp)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto PopulateNTAutodialAddressExit;
        }
        lpTemp->dwTotalSize = lpcap->dwNeededSize;
        GlobalFree(lpcap);
        lpcap = (LPLINETRANSLATECAPS)lpTemp;
        lpTemp = NULL;
        lRC = lineGetTranslateCaps(0,0x10004,lpcap);
    }

    if (SUCCESS != lRC)
    {
        hr = (HRESULT)lRC; // REVIEW: not real sure about this.
        goto PopulateNTAutodialAddressExit;
    }

    //
    // Create an array of RASAUTODIALENTRY structs
    //
    rADE = (LPRASAUTODIALENTRY)GlobalAlloc(GPTR,
        sizeof(RASAUTODIALENTRY)*lpcap->dwNumLocations);
    if (!rADE)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto PopulateNTAutodialAddressExit;
    }
    

    //
    // Enable autodialing for all locations
    //
    idx = lpcap->dwNumLocations;
    lpLE = (LPLINELOCATIONENTRY)((DWORD_PTR)lpcap + (DWORD)lpcap->dwLocationListOffset);
    while (idx)
    {
        idx--;
        m_lpfnRasSetAutodialEnable(lpLE[idx].dwPermanentLocationID,TRUE);

        //
        // fill in array values
        //
        rADE[idx].dwSize = sizeof(RASAUTODIALENTRY);
        rADE[idx].dwDialingLocation = lpLE[idx].dwPermanentLocationID;
        lstrcpyn(rADE[idx].szEntry,pszEntryName,RAS_MaxEntryName);
    }

    //
    // Get list of addresses
    //
    lpszBuffer = (LPTSTR)GlobalAlloc(GPTR,AUTODIAL_ADDRESS_BUFFER_SIZE);
    if (!lpszBuffer)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto PopulateNTAutodialAddressExit;
    }

    if((AUTODIAL_ADDRESS_BUFFER_SIZE-2) == GetPrivateProfileSection(AUTODIAL_ADDRESS_SECTION_NAME,
        lpszBuffer,AUTODIAL_ADDRESS_BUFFER_SIZE/sizeof(TCHAR),pszFileName))
    {
        //AssertSz(0,"Autodial address section bigger than buffer.\r\n");
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto PopulateNTAutodialAddressExit;
    }

    //
    // Walk list of addresses and set autodialing for each one
    //
    lpszNextAddress = lpszBuffer;
    do
    {
        lpszNextAddress = MoveToNextAddress(lpszNextAddress);
        if (!(*lpszNextAddress))
            break;    // do-while
        m_lpfnRasSetAutodialAddress(lpszNextAddress,0,rADE,
            sizeof(RASAUTODIALENTRY)*lpcap->dwNumLocations,lpcap->dwNumLocations);
        lpszNextAddress = lpszNextAddress + lstrlen(lpszNextAddress);
    } while(1);

PopulateNTAutodialAddressExit:
    if (lpcap) 
        GlobalFree(lpcap);
    lpcap = NULL;
    if (rADE)
        GlobalFree(rADE);
    rADE = NULL;
    if (lpszBuffer)
        GlobalFree(lpszBuffer);
    lpszBuffer = NULL;
    //if( pRnaapi )
    //    delete pRnaapi;
    //pRnaapi = NULL;
    return hr;
}



//+----------------------------------------------------------------------------
//
//    Function:    MoveToNextAddress
//
//    Synopsis:    Given a pointer into the data bufffer, this function will move
//                through the buffer until it points to the begining of the next
//                address or it reaches the end of the buffer.
//
//    Arguements:    lpsz - pointer into buffer
//
//    Returns:    Pointer to the next address, return value will point to NULL
//                if there are no more addresses
//
//    History:    8/29/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
LPTSTR CINSHandler::MoveToNextAddress(LPTSTR lpsz)
{
    BOOL fLastCharWasNULL = FALSE;

    //AssertSz(lpsz,"MoveToNextAddress: NULL input\r\n");

    //
    // Look for an = sign
    //
    do
    {
        if (fLastCharWasNULL && '\0' == *lpsz)
            break; // are we at the end of the data?

        if ('\0' == *lpsz)
            fLastCharWasNULL = TRUE;
        else
            fLastCharWasNULL = FALSE;

        if ('=' == *lpsz)
            break;

        if (*lpsz)
            lpsz = CharNext(lpsz);
        else
            lpsz++;
    } while (1);
    
    //
    // Move to the first character beyond the = sign.
    //
    if (*lpsz)
        lpsz = CharNext(lpsz);

    return lpsz;
}


//+----------------------------------------------------------------------------
//
//    Function:    ImportCustomDialer
//
//    Synopsis:    Import custom dialer information from the specified file
//                and save the information in the RASENTRY
//
//    Arguments:    lpRasEntry - pointer to a valid RASENTRY structure
//                szFileName - text file (in .ini file format) containing the
//                Custom Dialer information
//
//    Returns:    ERROR_SUCCESS - success otherwise a Win32 error
//
//    History:    ChrisK    Created        7/11/96
//            8/12/96    ChrisK    Ported from \\trango
//
//-----------------------------------------------------------------------------
DWORD CINSHandler::ImportCustomDialer(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{

    // If there is an error reading the information from the file, or the entry
    // missing or blank, the default value (cszNull) will be used.
    GetPrivateProfileString(cszCustomDialerSection,
                            cszAutoDialDLL,
                            cszNull,
                            lpRasEntry->szAutodialDll,
                            MAX_PATH,
                            szFileName);

    GetPrivateProfileString(cszCustomDialerSection,
                            cszAutoDialFunc,
                            cszNull,
                            lpRasEntry->szAutodialFunc,
                            MAX_PATH,
                            szFileName);

    return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL StrToip (LPTSTR szIPAddress, LPDWORD lpdwAddr)
//
// This function converts a IP address string to an IP address structure.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Cloned from SMMSCRPT.
//****************************************************************************
LPCTSTR CINSHandler::StrToSubip (LPCTSTR szIPAddress, LPBYTE pVal)
{
    LPCTSTR  pszIP = szIPAddress;
    BYTE    val = 0;

    // skip separators (non digits)
    while (*pszIP && !myisdigit(*pszIP))
    {
          ++pszIP;
    }

    while (myisdigit(*pszIP))
    {
        val = (val * 10) + (BYTE)(*pszIP - '0');
        ++pszIP;
    }
   
    *pVal = val;

    return pszIP;
}


DWORD CINSHandler::StrToip (LPCTSTR szIPAddress, RASIPADDR *ipAddr)
{
    LPCTSTR pszIP = szIPAddress;

    pszIP = StrToSubip(pszIP, &ipAddr->a);
    pszIP = StrToSubip(pszIP, &ipAddr->b);
    pszIP = StrToSubip(pszIP, &ipAddr->c);
    pszIP = StrToSubip(pszIP, &ipAddr->d);

    return ERROR_SUCCESS;
}


//****************************************************************************
// DWORD NEAR PASCAL ImportPhoneInfo(PPHONENUM ppn, LPCTSTR szFileName)
//
// This function imports the phone number.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CINSHandler::ImportPhoneInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
    TCHAR   szYesNo[MAXNAME];

    if (GetPrivateProfileString(cszPhoneSection,
                               cszPhone,
                               cszNull,
                               lpRasEntry->szLocalPhoneNumber,
                               RAS_MaxPhoneNumber,
                               szFileName) == 0)
    {
        return ERROR_BAD_PHONE_NUMBER;
    }

    lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;

    GetPrivateProfileString(cszPhoneSection,
                            cszDialAsIs,
                            cszNo,
                            szYesNo,
                            MAXNAME,
                            szFileName);

    // Do we have to get country code and area code?
    if (!lstrcmpi(szYesNo, cszNo))
    {

        // If we cannot get the country ID or it is zero, default to dial as is
        //
        if ((lpRasEntry->dwCountryID = GetPrivateProfileInt(cszPhoneSection,
                                                 cszCountryID,
                                                 0,
                                                 szFileName)) != 0)
        {
            lpRasEntry->dwCountryCode = GetPrivateProfileInt(cszPhoneSection,
                                                cszCountryCode,
                                                1,
                                                szFileName);

            GetPrivateProfileString(cszPhoneSection,
                                      cszAreaCode,
                                      cszNull,
                                      lpRasEntry->szAreaCode,
                                      RAS_MaxAreaCode,
                                      szFileName);

            lpRasEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;

        }
  }
  else
  {
      // bug in RasSetEntryProperties still checks area codes
      // even when RASEO_UseCountryAndAreaCodes is not set
      lstrcpy(lpRasEntry->szAreaCode, TEXT("805"));
      lpRasEntry->dwCountryID = 1;
      lpRasEntry->dwCountryCode = 1;
  }
  return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportServerInfo(PSMMINFO psmmi, LPTSTR szFileName)
//
// This function imports the server type name and settings.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CINSHandler::ImportServerInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
    TCHAR   szYesNo[MAXNAME];
    TCHAR   szType[MAXNAME];
    DWORD  i;

    // Get the server type name
    GetPrivateProfileString(cszServerSection,
                          cszServerType,
                          cszNull,
                          szType,
                          MAXNAME,
                          szFileName);

    // need to convert the string into
    // one of the following values
    //   RASFP_Ppp
    //   RASFP_Slip  Note CSLIP is SLIP with IP compression on
    //   RASFP_Ras

    for (i = 0; i < NUM_SERVER_TYPES; ++i)
    {
        if (!lstrcmpi(aServerTypes[i].szType, szType))
        {
            lpRasEntry->dwFramingProtocol = aServerTypes[i].dwType;
            lpRasEntry->dwfOptions |= aServerTypes[i].dwfOptions;
            break;
        }
    }

    // Get the server type settings
    if (GetPrivateProfileString(cszServerSection,
                              cszSWCompress,
                              cszYes,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfOptions &= ~RASEO_SwCompression;
        }
        else
        {
            lpRasEntry->dwfOptions |= RASEO_SwCompression;
        }
    }

    if (GetPrivateProfileString(cszServerSection,
                              cszPWEncrypt,
                              cszNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfOptions &= ~RASEO_RequireEncryptedPw;
        }
        else
        {
            lpRasEntry->dwfOptions |= RASEO_RequireEncryptedPw;
        }
    }

    if (GetPrivateProfileString(cszServerSection,
                              cszNetLogon,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfOptions &= ~RASEO_NetworkLogon;
        }
        else
        {
            lpRasEntry->dwfOptions |= RASEO_NetworkLogon;
        }
    }

    if (GetPrivateProfileString(cszServerSection,
                              cszSWEncrypt,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {   
            lpRasEntry->dwfOptions &= ~RASEO_RequireDataEncryption;
        }
        else
        {
            lpRasEntry->dwfOptions |= RASEO_RequireDataEncryption;
        }
    }

    // Get the protocol settings
    if (GetPrivateProfileString(cszServerSection,
                              cszNetBEUI,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfNetProtocols &= ~RASNP_NetBEUI;
        }
        else
        {
            lpRasEntry->dwfNetProtocols |= RASNP_NetBEUI;
        }
    }

    if (GetPrivateProfileString(cszServerSection,
                              cszIPX,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfNetProtocols &= ~RASNP_Ipx;
        }
        else
        {
            lpRasEntry->dwfNetProtocols |= RASNP_Ipx;
        }
    }

    if (GetPrivateProfileString(cszServerSection,
                              cszIP,
                              cszYes,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfNetProtocols &= ~RASNP_Ip;
        }
        else
        {
            lpRasEntry->dwfNetProtocols |= RASNP_Ip;
        }
    }

    if (GetPrivateProfileString(cszServerSection,
                              cszDisableLcp,
                              cszNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszYes))
        {
            lpRasEntry->dwfOptions |= RASEO_DisableLcpExtensions;
        }
        else
        {
            lpRasEntry->dwfOptions &= ~RASEO_DisableLcpExtensions;
        }
    }

    return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportIPInfo(LPTSTR szEntryName, LPTSTR szFileName)
//
// This function imports the TCP/IP information
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CINSHandler::ImportIPInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
    TCHAR   szIPAddr[MAXIPADDRLEN];
    TCHAR   szYesNo[MAXNAME];

    // Import IP address information
    if (GetPrivateProfileString(cszIPSection,
                              cszIPSpec,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszYes))
        {
            // The import file has IP address specified, get the IP address
            lpRasEntry->dwfOptions |= RASEO_SpecificIpAddr;
            if (GetPrivateProfileString(cszIPSection,
                                  cszIPAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
            {
                StrToip (szIPAddr, &lpRasEntry->ipaddr);
            }
        }
        else
        {
            lpRasEntry->dwfOptions &= ~RASEO_SpecificIpAddr;
        }
    }

    // Import Server address information
    if (GetPrivateProfileString(cszIPSection,
                              cszServerSpec,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszYes))
        {
            // The import file has server address specified, get the server address
            lpRasEntry->dwfOptions |= RASEO_SpecificNameServers;
            if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
            {
                StrToip (szIPAddr, &lpRasEntry->ipaddrDns);
            }

            if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAltAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
            {
                StrToip (szIPAddr, &lpRasEntry->ipaddrDnsAlt);
            }

            if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
            {
                StrToip (szIPAddr, &lpRasEntry->ipaddrWins);
            }

            if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAltAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
            {
                StrToip (szIPAddr, &lpRasEntry->ipaddrWinsAlt);
            }
        }
        else
        {
            lpRasEntry->dwfOptions &= ~RASEO_SpecificNameServers;
        }
    }

    // Header compression and the gateway settings
    if (GetPrivateProfileString(cszIPSection,
                              cszIPCompress,
                              cszYes,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfOptions &= ~RASEO_IpHeaderCompression;
        }
        else
        {
            lpRasEntry->dwfOptions |= RASEO_IpHeaderCompression;
        }
    }

    if (GetPrivateProfileString(cszIPSection,
                              cszWanPri,
                              cszYes,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
          lpRasEntry->dwfOptions &= ~RASEO_RemoteDefaultGateway;
        }
        else
        {
          lpRasEntry->dwfOptions |= RASEO_RemoteDefaultGateway;
        }
    }
    return ERROR_SUCCESS;
}

DWORD CINSHandler::ImportScriptFile(
    LPCTSTR lpszImportFile,
    LPTSTR szScriptFile,
    UINT cbScriptFile)
{
    TCHAR szTemp[_MAX_PATH];
    DWORD dwRet = ERROR_SUCCESS;
    
    // Get the script filename
    //
    if (GetPrivateProfileString(cszScriptingSection,
                                cszScriptName,
                                cszNull,
                                szTemp,
                                _MAX_PATH,
                                lpszImportFile) != 0)
    {
 
//!!! commonize this code
//!!! make it DBCS compatible
//!!! check for overruns
//!!! check for absolute path name
        GetWindowsDirectory(szScriptFile, cbScriptFile);
        if (*CharPrev(szScriptFile, szScriptFile + lstrlen(szScriptFile)) != '\\')
        {
            lstrcat(szScriptFile, TEXT("\\"));
        }
        lstrcat(szScriptFile, szTemp);
  
        dwRet =ImportFile(lpszImportFile, cszScriptSection, szScriptFile);
    }

    return dwRet;
}
 
//****************************************************************************
// DWORD WINAPI RnaValidateImportEntry (LPTSTR)
//
// This function is called to validate an importable file
//
// History:
//  Wed 03-Jan-1996 09:45:01  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CINSHandler::RnaValidateImportEntry (LPCTSTR szFileName)
{
    TCHAR  szTmp[MAX_PATH+1];

    // Get the alias entry name
    //
    // 12/4/96    jmazner    Normandy #12373
    // If no such key, don't return ERROR_INVALID_PHONEBOOK_ENTRY,
    // since ConfigureClient always ignores that error code.

    return (GetPrivateProfileString(cszEntrySection,
                                  cszEntryName,
                                  cszNull,
                                  szTmp,
                                  MAX_PATH,
                                  szFileName) > 0 ?
            ERROR_SUCCESS : ERROR_UNKNOWN);
}

//****************************************************************************
// DWORD WINAPI RnaImportEntry (LPTSTR, LPBYTE, DWORD)
//
// This function is called to import an entry from a specified file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CINSHandler::ImportRasEntry (LPCTSTR szFileName, LPRASENTRY lpRasEntry)
{
    DWORD         dwRet;

    dwRet = ImportPhoneInfo(lpRasEntry, szFileName);
    if (ERROR_SUCCESS == dwRet)
    {
        // Get device type
        //
        GetPrivateProfileString(cszDeviceSection,
                              cszDeviceType,
                              cszNull,
                              lpRasEntry->szDeviceType,
                              RAS_MaxDeviceType,
                              szFileName);
        
        // Get Server Type settings
        //
        dwRet = ImportServerInfo(lpRasEntry, szFileName);
        if (ERROR_SUCCESS == dwRet)
        {
            // Get IP address
            //
            dwRet = ImportIPInfo(lpRasEntry, szFileName);
        }
    }

    return dwRet;
}


//****************************************************************************
// DWORD WINAPI RnaImportEntry (LPTSTR, LPBYTE, DWORD)
//
// This function is called to import an entry from a specified file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CINSHandler::ImportConnection (LPCTSTR szFileName, LPICONNECTION lpConn)
{
    DWORD   dwRet;

    lpConn->RasEntry.dwSize = sizeof(RASENTRY);

    dwRet = RnaValidateImportEntry(szFileName);
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    GetPrivateProfileString(cszEntrySection,
                          cszEntryName,
                          cszNull,
                          lpConn->szEntryName,
                          RAS_MaxEntryName,
                          szFileName);

    GetPrivateProfileString(cszUserSection,
                          cszUserName,
                          cszNull,
                          lpConn->szUserName,
                          UNLEN,
                          szFileName);
  
    GetPrivateProfileString(cszUserSection,
                          cszPassword,
                          cszNull,
                          lpConn->szPassword,
                          PWLEN,
                          szFileName);
  
    dwRet = ImportRasEntry(szFileName, &lpConn->RasEntry);
    if (ERROR_SUCCESS == dwRet)
    {
        dwRet = ImportCustomDialer(&lpConn->RasEntry, szFileName);
    }

    if (ERROR_SUCCESS == dwRet)
    {
        // Import the script file
        //
        dwRet = ImportScriptFile(szFileName,
                                 lpConn->RasEntry.szScript,
                                 sizeof(lpConn->RasEntry.szScript)/sizeof(TCHAR));
    }

    // Use an ISPImport object to Config The ras device
    CISPImport  ISPImport;

    ISPImport.set_hWndMain(GetActiveWindow());
    dwRet = ISPImport.ConfigRasEntryDevice(&lpConn->RasEntry);
    switch( dwRet )
    {
        case ERROR_SUCCESS:
            break;
        case ERROR_CANCELLED:
            if(!m_bSilentMode)
                InfoMsg1(NULL, IDS_SIGNUPCANCELLED, NULL);
            // Fall through
        default:
            goto ImportConnectionExit;
    }

ImportConnectionExit:
    return dwRet;
}

// Prototype for acct manager entry point we want
typedef HRESULT (WINAPI *PFNCREATEACCOUNTSFROMFILEEX)(LPTSTR szFile, CONNECTINFO *pCI, DWORD dwFlags);

// Regkeys for Acct manager
#define ACCTMGR_PATHKEY TEXT("SOFTWARE\\Microsoft\\Internet Account Manager")
#define ACCTMGR_DLLPATH TEXT("DllPath")


// ############################################################################
//
//    Name:    ImportMailAndNewsInfo
//
//    Description:    Import information from INS file and set the associated
//                        registry keys for Internet Mail and News (Athena)
//
//    Input:    lpszFile - Fully qualified filename of INS file
//
//    Return:    Error value
//
//    History:        6/27/96            Created
//
// ############################################################################
DWORD CINSHandler::ImportMailAndNewsInfo(LPCTSTR lpszFile, BOOL fConnectPhone)
{
    DWORD dwRet = ERROR_SUCCESS;
    
    TCHAR szAcctMgrPath[MAX_PATH + 1] = TEXT("");
    TCHAR szExpandedPath[MAX_PATH + 1] = TEXT("");
    DWORD dwAcctMgrPathSize = 0;
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    HINSTANCE hInst = NULL;
    CONNECTINFO connectInfo;
    TCHAR szConnectoidName[RAS_MaxEntryName] = TEXT("nogood\0");
    PFNCREATEACCOUNTSFROMFILEEX fp = NULL;


    // get path to the AcctMgr dll
    dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, ACCTMGR_PATHKEY,0, KEY_READ, &hKey);
    if ( (dwRet != ERROR_SUCCESS) || (NULL == hKey) )
    {
        TraceMsg(TF_INSHANDLER, TEXT("ImportMailAndNewsInfo couldn't open reg key %s\n"), ACCTMGR_PATHKEY);
        return( dwRet );
    }

    dwAcctMgrPathSize = sizeof (szAcctMgrPath);
    dwRet = RegQueryValueEx(hKey, ACCTMGR_DLLPATH, NULL, NULL, (LPBYTE) szAcctMgrPath, &dwAcctMgrPathSize);
    

    RegCloseKey( hKey );
    
    if ( dwRet != ERROR_SUCCESS )
    {
        TraceMsg(TF_INSHANDLER, TEXT("ImportMailAndNewsInfo: RegQuery failed with error %d\n"), dwRet);
        return( dwRet );
    }

    // 6/18/97 jmazner Olympus #6819
    TraceMsg(TF_INSHANDLER, TEXT("ImportMailAndNewsInfo: read in DllPath of %s\n"), szAcctMgrPath);
    ExpandEnvironmentStrings( szAcctMgrPath, szExpandedPath, ARRAYSIZE(szExpandedPath));
    NULL_TERM_TCHARS(szExpandedPath);

    //
    // 6/4/97 jmazner
    // if we created a connectoid, then get its name and use that as the
    // connection type.  Otherwise, assume we're supposed to connect via LAN
    //
    connectInfo.cbSize = sizeof(CONNECTINFO);
    connectInfo.type = CONNECT_LAN;

    if( fConnectPhone && m_lpfnInetGetAutodial )
    {
        BOOL fEnabled = FALSE;

        dwRet = m_lpfnInetGetAutodial(&fEnabled,szConnectoidName,RAS_MaxEntryName);

        if( ERROR_SUCCESS==dwRet && szConnectoidName[0] )
        {
            connectInfo.type = CONNECT_RAS;
#ifdef UNICODE
            wcstombs(connectInfo.szConnectoid, szConnectoidName, MAX_PATH);
#else
            lstrcpyn( connectInfo.szConnectoid, szConnectoidName, sizeof(connectInfo.szConnectoid) );
#endif
            TraceMsg(TF_INSHANDLER, TEXT("ImportMailAndNewsInfo: setting connection type to RAS with %s\n"), szConnectoidName);
        }
    }

    if( CONNECT_LAN == connectInfo.type )
    {
        TraceMsg(TF_INSHANDLER, TEXT("ImportMailAndNewsInfo: setting connection type to LAN\n"));
#ifdef UNICODE
        wcstombs(connectInfo.szConnectoid, TEXT("I said CONNECT_LAN!"), MAX_PATH);
#else
        lstrcpy( connectInfo.szConnectoid, TEXT("I said CONNECT_LAN!") );
#endif
    }



    hInst = LoadLibrary(szExpandedPath);
    if (hInst)
    {
        fp = (PFNCREATEACCOUNTSFROMFILEEX) GetProcAddress(hInst,"CreateAccountsFromFileEx");
        if (fp)
            hr = fp( (TCHAR *)lpszFile, &connectInfo, NULL );
    }
    else
    {
        TraceMsg(TF_INSHANDLER, TEXT("ImportMailAndNewsInfo unable to LoadLibrary on %s\n"), szAcctMgrPath);
    }

    //
    // Clean up and release resourecs
    //
    if( hInst)
    {
        FreeLibrary(hInst);
        hInst = NULL;
    }

    if( fp )
    {
        fp = NULL;
    }

    return dwRet;
}

// ############################################################################
//
//    Name:    WriteMailAndNewsKey
//
//    Description:    Read a string value from the given INS file and write it
//                    to the registry
//
//    Input:    hKey - Registry key where the data will be written
//            lpszSection - Section name inside of INS file where data is read
//                from
//            lpszValue -    Name of value to read from INS file
//            lpszBuff - buffer where data will be read into
//            dwBuffLen - size of lpszBuff
//            lpszSubKey - Value name where information will be written to
//            dwType - data type (Should always be REG_SZ)
//            lpszFileName - Fully qualified filename to INS file
//
//    Return:    Error value
//
//    Histroy:        6/27/96            Created
//
// ############################################################################
HRESULT CINSHandler::WriteMailAndNewsKey(HKEY hKey, LPCTSTR lpszSection, LPCTSTR lpszValue,
                            LPTSTR lpszBuff, DWORD dwBuffLen,LPCTSTR lpszSubKey,
                            DWORD dwType, LPCTSTR lpszFile)
{
    ZeroMemory(lpszBuff,dwBuffLen);
    GetPrivateProfileString(lpszSection,lpszValue,TEXT(""),lpszBuff,dwBuffLen,lpszFile);
    if (lstrlen(lpszBuff))
    {
        return RegSetValueEx(hKey,lpszSubKey,0,dwType,(CONST BYTE*)lpszBuff,
            sizeof(TCHAR)*(lstrlen(lpszBuff)+1));
    }
    else
    {
        TraceMsg(TF_INSHANDLER, TEXT("ISIGNUP: WriteMailAndNewsKey, missing value in INS file\n"));
        return ERROR_NO_MORE_ITEMS;
    }
}


// ############################################################################
//
//    Name:    PreparePassword
//
//    Description:    Encode given password and return value in place.  The
//                    encoding is done right to left in order to avoid having
//                    to allocate a copy of the data.  The encoding uses base64
//                    standard as specified in RFC 1341 5.2
//
//    Input:    szBuff - Null terminated data to be encoded
//            dwBuffLen - Full length of buffer, this should exceed the length of
//                the input data by at least 1/3
//
//    Return:    Error value
//
//    Histroy:        6/27/96            Created
//
// ############################################################################
HRESULT CINSHandler::PreparePassword(LPTSTR szBuff, DWORD dwBuffLen)
{
    DWORD   dwX;
    LPTSTR   szOut = NULL;
    LPTSTR   szNext = NULL;
    HRESULT hr = ERROR_SUCCESS;
    BYTE    bTemp = 0;
    DWORD   dwLen = 0;

    dwLen = lstrlen(szBuff);
    if (!dwLen)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto PreparePasswordExit;
    }

    // Calculate the size of the buffer that will be needed to hold
    // encoded data
    //

    szNext = &szBuff[dwLen-1];
    dwLen = (((dwLen % 3 ? (3-(dwLen%3)):0) + dwLen) * 4 / 3);

    if (dwBuffLen < dwLen+1)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto PreparePasswordExit;
    }

    szOut = &szBuff[dwLen];
    *szOut-- = '\0';

    // Add padding = characters
    //

    switch (lstrlen(szBuff) % 3)
    {
    case 0:
        // no padding
        break;
    case 1:
        *szOut-- = 64;
        *szOut-- = 64;
        *szOut-- = (*szNext & 0x3) << 4;
        *szOut-- = (*szNext-- & 0xFC) >> 2;
        break;
    case 2:
        *szOut-- = 64;
        *szOut-- = (*szNext & 0xF) << 2;
        *szOut = ((*szNext-- & 0xF0) >> 4);
        *szOut-- |= ((*szNext & 0x3) << 4);
        *szOut-- = (*szNext-- & 0xFC) >> 2;
    }

    // Encrypt data into indicies
    //

    while (szOut > szNext && szNext >= szBuff)
    {
        *szOut-- = *szNext & 0x3F;
        *szOut = ((*szNext-- & 0xC0) >> 6);
        *szOut-- |= ((*szNext & 0xF) << 2);
        *szOut = ((*szNext-- & 0xF0) >> 4);
        *szOut-- |= ((*szNext & 0x3) << 4);
        *szOut-- = (*szNext-- & 0xFC) >> 2;
    }

    // Translate indicies into printable characters
    //

    szNext = szBuff;

    // BUG OSR#10435--if there is a 0 in the generated string of base-64 
    // encoded digits (this can happen if the password is "Willypassword"
    // for example), then instead of encoding the 0 to 'A', we just quit
    // at this point, produces an invalid base-64 string.
    
    for(dwX=0; dwX < dwLen; dwX++)
        *szNext = arBase64[*szNext++];

PreparePasswordExit:
    return hr;
}

// ############################################################################
//
//    Name: FIsAthenaPresent
//
//    Description:    Determine if Microsoft Internet Mail And News client (Athena)
//                    is installed
//
//    Input:    none
//
//    Return:    TRUE - Athena is installed
//            FALSE - Athena is NOT installed
//
//    History:        7/1/96            Created
//
// ############################################################################
BOOL CINSHandler::FIsAthenaPresent()
{
    TCHAR       szBuff[MAX_PATH + 1];
    HRESULT     hr = ERROR_SUCCESS;
    HINSTANCE   hInst = NULL;
    DWORD       dwLen = 0;
    DWORD       dwType = REG_SZ;
    // Get path to Athena client
    //

    dwLen = sizeof(TCHAR)*MAX_PATH;
    hr = RegQueryValueEx(HKEY_CLASSES_ROOT,
                         MAIL_NEWS_INPROC_SERVER32,
                         NULL,
                         &dwType,
                         (LPBYTE) szBuff,
                         &dwLen);
    if (hr == ERROR_SUCCESS)
    {
        // Attempt to load client
        //

        hInst = LoadLibrary(szBuff);
        if (!hInst)
        {
            TraceMsg(TF_INSHANDLER, TEXT("ISIGNUP: Internet Mail and News server didn't load.\n"));
            hr = ERROR_FILE_NOT_FOUND;
        } 
        else 
        {
            FreeLibrary(hInst);
        }
        hInst = NULL;
    }

    return (hr == ERROR_SUCCESS);
}

// ############################################################################
//
//    Name:    FTurnOffBrowserDefaultChecking
//
//    Description:    Turn Off IE checking to see if it is the default browser
//
//    Input:    none
//
//    Output:    TRUE - success
//            FALSE - failed
//
//    History:        7/2/96            Created
//
// ############################################################################
BOOL CINSHandler::FTurnOffBrowserDefaultChecking()
{
    HKEY hKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    BOOL bRC = TRUE;

    //
    // Open IE settings registry key
    //
    if (RegOpenKey(HKEY_CURRENT_USER,cszDEFAULT_BROWSER_KEY,&hKey))
    {
        bRC = FALSE;
        goto FTurnOffBrowserDefaultCheckingExit;
    }

    //
    // Read current settings for check associations
    //
    dwType = 0;
    dwSize = sizeof(m_szCheckAssociations);
    ZeroMemory(m_szCheckAssociations,dwSize);
    RegQueryValueEx(hKey,
                    cszDEFAULT_BROWSER_VALUE,
                    0,
                    &dwType,
                    (LPBYTE)m_szCheckAssociations,
                    &dwSize);
    // ignore return value, even if the calls fails we are going to try
    // to change the setting to "NO"
    
    //
    // Set value to "no" to turn off checking
    //
    if (RegSetValueEx(hKey,
                      cszDEFAULT_BROWSER_VALUE,
                      0,
                      REG_SZ,
                      (LPBYTE)cszNo,
                      sizeof(TCHAR)*(lstrlen(cszNo)+1)))
    {
        bRC = FALSE;
        goto FTurnOffBrowserDefaultCheckingExit;
    }

    //
    // Clean up and return
    //
FTurnOffBrowserDefaultCheckingExit:
    if (hKey)
        RegCloseKey(hKey);
    if (bRC)
        m_fResforeDefCheck = TRUE;
    hKey = NULL;
    return bRC;
}

// ############################################################################
//
//    Name:    FRestoreBrowserDefaultChecking
//
//    Description:    Restore IE checking to see if it is the default browser
//
//    Input:    none
//
//    Output:    TRUE - success
//            FALSE - failed
//
//    History:        7/2/96            Created
//
// ############################################################################
BOOL CINSHandler::FRestoreBrowserDefaultChecking()
{
    HKEY hKey = NULL;
    BOOL bRC = TRUE;

    //
    // Open IE settings registry key
    //
    if (RegOpenKey(HKEY_CURRENT_USER,cszDEFAULT_BROWSER_KEY,&hKey))
    {
        bRC = FALSE;
        goto FRestoreBrowserDefaultCheckingExit;
    }

    //
    // Set value to original value
    //
    if (RegSetValueEx(hKey,
                      cszDEFAULT_BROWSER_VALUE,
                      0,
                      REG_SZ,
                      (LPBYTE)m_szCheckAssociations,
                      sizeof(TCHAR)*(lstrlen(m_szCheckAssociations)+1)))
    {
        bRC = FALSE;
        goto FRestoreBrowserDefaultCheckingExit;
    }

FRestoreBrowserDefaultCheckingExit:
    if (hKey)
        RegCloseKey(hKey);
    hKey = NULL;
    return bRC;
}



// This is the main entry point for processing an INS file.
// DJM: BUGBUG: TODO: Need to pass in branding flags
STDMETHODIMP CINSHandler::ProcessINS(BSTR bstrINSFilePath, BOOL * pbRetVal)
{
    USES_CONVERSION;

    BOOL        fConnectoidCreated = FALSE;
    BOOL        fClientSetup       = FALSE;
    BOOL        bKeepConnection    = FALSE;
    BOOL        fErrMsgShown       = FALSE;
    HRESULT     hr                 = E_FAIL;
    LPTSTR       lpszFile           = NULL;
    LPRASENTRY  lpRasEntry         = NULL;
    TCHAR        szTemp[3]          = TEXT("\0");
    TCHAR        szConnectoidName[RAS_MaxEntryName*2] = TEXT("");
    
    *pbRetVal = FALSE;

    // The Connection has not been killed yet
    m_fConnectionKilled = FALSE;
    m_fNeedsRestart = FALSE;

    Assert(bstrINSFilePath);

    lpszFile = OLE2A(bstrINSFilePath);
    do 
    {
        // Make sure we can load the necessary extern support functions
        if (!LoadExternalFunctions())
            break;

        // Convert EOL chars in the passed file.
        if (FAILED(MassageFile(lpszFile)))
        {
            if(!m_bSilentMode)
                ErrorMsg1(GetActiveWindow(), IDS_CANNOTPROCESSINS, NULL);
            break;
        }
        if(GetPrivateProfileString(cszURLSection,
                                    cszStartURL,
                                    szNull,
                                    m_szStartURL,
                                    MAX_PATH + 1,
                                    lpszFile) == 0)
        {
            m_szStartURL[0] = '\0';
        }

        if (GetPrivateProfileString(cszEntrySection,
                                    cszCancel,
                                    szNull,
                                    szTemp,
                                    3,
                                    lpszFile) != 0)
        {
            // We do not want to process a CANCEL.INS file
            // here.
            break;
        }

        // See if this INS has a client setup section
        if (GetPrivateProfileSection(cszClientSetupSection,
                                     szTemp,
                                     3,
                                     lpszFile) != 0)
            fClientSetup = TRUE;
        
        // Process the trial reminder section, if it exists.  this needs to be
        // done BEFORE we allow the connection to be closed
        if (ConfigureTrialReminder(lpszFile))
        {
            // We configured a trial, so we need to launch the remind app now
            SHELLEXECUTEINFO    sei;

            sei.cbSize = sizeof(sei);
            sei.fMask = SEE_MASK_NOCLOSEPROCESS;
            sei.hwnd = NULL;
            sei.lpVerb = cszOpen;
            sei.lpFile = cszReminderApp;
            sei.lpParameters = cszReminderParams;
            sei.lpDirectory = NULL;
            sei.nShow = SW_SHOWNORMAL;
            sei.hInstApp = NULL;
            // Optional members 
            sei.hProcess = NULL;

            ShellExecuteEx(&sei);
        }
        
        // Check to see if we should keep the connection open.  The custom section
        // might want this for processing stuff
        if (!fClientSetup && !KeepConnection(lpszFile))
        {
            Fire_KillConnection();
            m_fConnectionKilled = TRUE;
        }
    
        // Import the Custom Info
        ImportCustomInfo(lpszFile,
                         m_szRunExecutable,
                         MAX_PATH ,
                         m_szRunArgument,
                         MAX_PATH );

        ImportCustomFile(lpszFile);

        // configure the client.  
        hr = ConfigureClient(GetActiveWindow(),
                             lpszFile,
                             &m_fNeedsRestart,
                             &fConnectoidCreated,
                             FALSE,
                             szConnectoidName,
                             RAS_MaxEntryName);
        if( ERROR_SUCCESS != hr )
        {

            if(!m_bSilentMode)
                ErrorMsg1(GetActiveWindow(), IDS_INSTALLFAILED, NULL);
            fErrMsgShown = TRUE;
        }

        // If we created a connectoid, tell the world that ICW
        // has left the building...
        if(!m_bSilentMode)
            SetICWCompleted( (DWORD)1 );

        // Call IEAK branding dll

        ImportBrandingInfo(lpszFile, szConnectoidName);
        //::MessageBox(NULL, TEXT("Step 4"), TEXT("TEST"), MB_OK);

        // 2/19/97 jmazner    Olympus 1106
        // For SBS/SAM integration.
        DWORD dwSBSRet = 0;//CallSBSConfig(GetActiveWindow(), lpszFile);
        switch( dwSBSRet )
        {
            case ERROR_SUCCESS:
                break;
            case ERROR_MOD_NOT_FOUND:
            case ERROR_DLL_NOT_FOUND:
                TraceMsg(TF_INSHANDLER, TEXT("ISIGN32: SBSCFG DLL not found, I guess SAM ain't installed.\n"));
                break;
            default:
                if(!m_bSilentMode)
                    ErrorMsg1(GetActiveWindow(), IDS_SBSCFGERROR, NULL);
        }

        //
        // If the INS file contains the ClientSetup section, build the commandline
        // arguments for ICWCONN2.exe.
        //
        if (fClientSetup)
        {
            // Check to see if a REBOOT is needed and tell the next application to
            // handle it.
            if (m_fNeedsRestart)
            {
                wsprintf(m_szRunArgument,TEXT(" /INS:\"%s\" /REBOOT"),lpszFile);
                m_fNeedsRestart = FALSE;
            }
            else
            {       
                wsprintf(m_szRunArgument,TEXT(" /INS:\"%s\""),lpszFile);
            }
        }
        
        // humongous hack for ISBU
        if (ERROR_SUCCESS != hr && fConnectoidCreated)
        {
            if(!m_bSilentMode)
                InfoMsg1(GetActiveWindow(), IDS_MAILFAILED, NULL);
            hr = ERROR_SUCCESS;
        }

        //
        // Import settings for mail and new read from INS file (ChrisK, 7/1/96)
        //
        if (ERROR_SUCCESS == hr)
        {

            ImportMailAndNewsInfo(lpszFile, fConnectoidCreated);

            // If we did not create a connectiod, then restore
            // the autodial one
            if (!fConnectoidCreated)
            {
                RestoreAutoDial();
            }

            // Delete the INS file now
            if (m_szRunExecutable[0] == '\0')
            {
                DeleteFile(lpszFile);
            }
        }
        else
        {
            RestoreAutoDial();
            if( !fErrMsgShown )
                if(!m_bSilentMode)
                    ErrorMsg1(GetActiveWindow(), IDS_BADSETTINGS, NULL);
        }


        if (m_szRunExecutable[0] != '\0')
        {
            // Fire an event to the container telling it that we are
            // about to run a custom executable
            Fire_RunningCustomExecutable();
            if FAILED(RunExecutable())
            {
                if(!m_bSilentMode)
                    ErrorMsg1(NULL, IDS_EXECFAILED, m_szRunExecutable);
            }

            // If the Connection has not been killed yet
            // then tell the browser to do it now
            if (!m_fConnectionKilled)
            {
                Fire_KillConnection();
                m_fConnectionKilled = TRUE;
            }
        }


        // If we get to here, we are successful.
        if(fConnectoidCreated && SUCCEEDED(hr))
            *pbRetVal = TRUE;
        break;

    }   while(1);

    return S_OK;
}

// If this is true, then the user will need to reboot, so
// the finish page should indicate this.
STDMETHODIMP CINSHandler::get_NeedRestart(BOOL *pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    *pVal = m_fNeedsRestart;
    return S_OK;
}

STDMETHODIMP CINSHandler::put_BrandingFlags(long lFlags)
{
    m_dwBrandFlags = lFlags;
    return S_OK;
}

STDMETHODIMP CINSHandler::put_SilentMode(BOOL bSilent)
{
    m_bSilentMode = bSilent;
    return S_OK;
}

// If this is true, get the URL from the INS file
STDMETHODIMP CINSHandler::get_DefaultURL(BSTR *pszURL)
{
    if (pszURL == NULL)
        return E_POINTER;

    *pszURL = A2BSTR(m_szStartURL);;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\progress.cpp ===
/*-----------------------------------------------------------------------------
    progress.cpp

    Download thread and progress update.  Part of CRefDial

    History:
        1/11/98      DONALDM Moved to new ICW project and string
                     and nuked 16 bit stuff
-----------------------------------------------------------------------------*/

#include "stdafx.h"
#include "icwhelp.h"
#include "refdial.h"
#include "icwdl.h"

#define MAX_EXIT_RETRIES 10

extern BOOL MinimizeRNAWindowEx();

void WINAPI MyProgressCallBack
(
    HINTERNET hInternet,
    DWORD_PTR dwContext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
)
{
    CRefDial    *pRefDial = (CRefDial *)dwContext;
    int         prc;

    if (!dwContext) 
        return;

    switch(dwInternetStatus)
    {
        case CALLBACK_TYPE_PROGRESS:
            prc = *(int*)lpvStatusInformation;\
            // Set the status string ID
            pRefDial->m_DownloadStatusID = IDS_RECEIVING_RESPONSE;

            // Post a message to fire an event
            PostMessage(pRefDial->m_hWnd, WM_DOWNLOAD_PROGRESS, prc, 0);
            break;
            
        case CALLBACK_TYPE_URL:
            if (lpvStatusInformation)
                lstrcpy(pRefDial->m_szRefServerURL, (LPTSTR)lpvStatusInformation);
            break;            
            
        default:
            TraceMsg(TF_GENERAL, TEXT("CONNECT:Unknown Internet Status (%d).\n"),dwInternetStatus);
            pRefDial->m_DownloadStatusID = 0;
            break;
    }
}

DWORD WINAPI  DownloadThreadInit(LPVOID lpv)
{
    HRESULT     hr = ERROR_NOT_ENOUGH_MEMORY;
    CRefDial    *pRefDial = (CRefDial*)lpv;
    HINSTANCE   hDLDLL = NULL; // Download .DLL
    HINSTANCE   hADDll = NULL;
    FARPROC     fp;

    MinimizeRNAWindowEx();

    hDLDLL = LoadLibrary(DOWNLOAD_LIBRARY);
    if (!hDLDLL)
    {
        hr = ERROR_DOWNLOAD_NOT_FOUND;
        AssertMsg(0,TEXT("icwdl missing"));
        goto ThreadInitExit;
    }

    // Set up for download
    //
    fp = GetProcAddress(hDLDLL,DOWNLOADINIT);
    AssertMsg(fp != NULL,TEXT("DownLoadInit API missing"));
    hr = ((PFNDOWNLOADINIT)fp)(pRefDial->m_szUrl, (DWORD_PTR FAR *)pRefDial, &pRefDial->m_dwDownLoad, pRefDial->m_hWnd);
    if (hr != ERROR_SUCCESS) 
        goto ThreadInitExit;
    
    // Set up call back for progress dialog
    //
    fp = GetProcAddress(hDLDLL,DOWNLOADSETSTATUS);
    Assert(fp);
    hr = ((PFNDOWNLOADSETSTATUS)fp)(pRefDial->m_dwDownLoad,(INTERNET_STATUS_CALLBACK)MyProgressCallBack);

    // Download stuff MIME multipart
    //
    fp = GetProcAddress(hDLDLL,DOWNLOADEXECUTE);
    Assert(fp);
    hr = ((PFNDOWNLOADEXECUTE)fp)(pRefDial->m_dwDownLoad);
    if (hr)
    {
        goto ThreadInitExit;
    }

    fp = GetProcAddress(hDLDLL,DOWNLOADPROCESS);
    Assert(fp);
    hr = ((PFNDOWNLOADPROCESS)fp)(pRefDial->m_dwDownLoad);
    if (hr)
    {
        goto ThreadInitExit;
    }

    hr = ERROR_SUCCESS;

ThreadInitExit:

    // Clean up
    //
    if (pRefDial->m_dwDownLoad)
    {
        fp = GetProcAddress(hDLDLL,DOWNLOADCLOSE);
        Assert(fp);
        ((PFNDOWNLOADCLOSE)fp)(pRefDial->m_dwDownLoad);
        pRefDial->m_dwDownLoad = 0;
    }

    // Call the OnDownLoadCompelete method
    PostMessage(pRefDial->m_hWnd, WM_DOWNLOAD_DONE, 0, 0);

    // Free the libs used to do the download
    if (hDLDLL) 
        FreeLibrary(hDLDLL);
    if (hADDll) 
        FreeLibrary(hADDll);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\smstart.h ===
// SmStart.h : Declaration of the CSmartStart

#ifndef __SMARTSTART_H_
#define __SMARTSTART_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CSmartStart
class ATL_NO_VTABLE CSmartStart :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSmartStart,&CLSID_SmartStart>,
	public CComControl<CSmartStart>,
	public IDispatchImpl<ISmartStart, &IID_ISmartStart, &LIBID_ICWHELPLib>,
	public IPersistStreamInitImpl<CSmartStart>,
	public IOleControlImpl<CSmartStart>,
	public IOleObjectImpl<CSmartStart>,
	public IOleInPlaceActiveObjectImpl<CSmartStart>,
	public IViewObjectExImpl<CSmartStart>,
	public IOleInPlaceObjectWindowlessImpl<CSmartStart>,
    public IObjectSafetyImpl<CSmartStart>
{
public:
    CSmartStart()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SMARTSTART)

BEGIN_COM_MAP(CSmartStart) 
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISmartStart)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CSmartStart)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CSmartStart)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = 0;
		return S_OK;
	}

// ISmartStart
public:
	STDMETHOD(IsInternetCapable)(/*[out, retval]*/ BOOL *pbRetVal);
	HRESULT OnDraw(ATL_DRAWINFO& di);

};

#endif //__SMARTSTART_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\sources.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

GETCONN_DIR     = ..\..

MAJORCOMP       = ie4
MINORCOMP       = getconn
TARGET_BOTH     = 1
!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwhelp

PASS0_HEADERDIR   = $(O)
PASS0_SOURCEDIR   = $(O)
MIDL_TLBDIR       = $(O)
MIDL_UUIDDIR      = $(O)

TARGETNAME      = icwhelp
TARGETPATH      = obj
TARGETTYPE      = DYNLINK
TARGETLIBS      = $(LIBRARY_PATH)\gdi32.lib             \
                  $(LIBRARY_PATH)\kernel32.lib          \
                  $(LIBRARY_PATH)\user32.lib            \
                  $(LIBRARY_PATH)\advapi32.lib          \
                  $(LIBRARY_PATH)\shell32.lib           \
                  $(LIBRARY_PATH)\uuid.lib              \
                  $(LIBRARY_PATH)\ole32.lib             \
                  $(LIBRARY_PATH)\oleaut32.lib          \
                  $(LIBRARY_PATH)\wininet.lib           \
                  $(LIBRARY_PATH)\mpr.lib               \
                  $(SDK_LIB_PATH)\rasapi32.lib          \
                  $(SDK_LIB_PATH)\tapi32.lib            \
                  $(SDK_LIB_PATH)\version.lib           \
                  $(SDK_LIB_PATH)\urlmon.lib            \
!if defined(NOT_UNICODE)
                  $(GETCONN_DIR)\lib\ansi\$O\stocklib.lib    \
!else
                  $(GETCONN_DIR)\lib\unicode\$O\stocklib.lib    \
!endif

PRECOMPILED_CXX = 1
USE_STATIC_ATL  = 1
USE_MSVCRT      = 1

DLLDEF          = ..\icwhelp.def
DLLBASE         = 0x63A00000
DLLENTRY        = DllMain

SOURCES         =   ..\icwhelp.rc       \
                    ..\icwhelp.idl      \
                    ..\debug.cpp        \
                    ..\dialerr.cpp      \
                    ..\enumodem.cpp     \
                    ..\icwcfg.cpp       \
                    ..\icwhelp.cpp      \
                    ..\import.cpp       \
                    ..\misc.cpp         \
                    ..\progress.cpp     \
                    ..\refdial.cpp      \
                    ..\rnaapi.cpp       \
                    ..\smstart.cpp      \
                    ..\stdatl.cpp       \
                    ..\userinfo.cpp     \
                    ..\webgate.cpp      \
                    ..\tapiloc.cpp      \
                    ..\inshandler.cpp   \
                    ..\support.cpp      \
                    ..\icwerr.cpp       \
                    ..\mcreg.cpp

PRECOMPILED_INCLUDE = ..\stdafx.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\smstart.cpp ===
// SmStart.cpp : Implementation of CSmartStart
#include "stdafx.h"
#include "icwhelp.h"
#include "SmStart.h"

/////////////////////////////////////////////////////////////////////////////
// CSmartStart


HRESULT CSmartStart::OnDraw(ATL_DRAWINFO& di)
{
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//    Function:    DoSmartStart
//
//    Synopsis:    This function will determine if the ICW should be run.  The
//                decision is made based on the current state of the user's machine.
//                
//    Arguments:    none
//
//    Returns:    Sets m_bIsInternetCapable.
//
//    History:    1/12/98
//
//-----------------------------------------------------------------------------
#define INETCFG_ISSMARTSTART "IsSmartStart"
STDMETHODIMP CSmartStart::IsInternetCapable(BOOL *pbRetVal)
{
    TraceMsg(TF_SMARTSTART, TEXT("ICWHELP: DoSmartStart\n"));

    // Set the initial state.  Assume we are NOT internet capable
    *pbRetVal = FALSE;
    PFNISSMARTSTART fp = NULL;

    // Load the InetCfg library
    HINSTANCE hInetCfg = LoadLibrary(TEXT("inetcfg.dll"));
    if (!hInetCfg)
    {
        // Failure just means we run the wizard
        goto DoSmartStartExit;
    }


    // Load and call the smart start API
    if (NULL == (fp = (PFNISSMARTSTART)
        GetProcAddress(hInetCfg,INETCFG_ISSMARTSTART)))
    {
        goto DoSmartStartExit;
    }

    //
    // Call smart start
    //
    *pbRetVal = (BOOL)fp();
    
DoSmartStartExit:
    if (hInetCfg)
        FreeLibrary(hInetCfg);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\stdatl.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1E7949FE_86F4_11D1_ADD8_0000F87734F0__INCLUDED_)
#define AFX_STDAFX_H__1E7949FE_86F4_11D1_ADD8_0000F87734F0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

// Global Variables
extern BOOL g_fRasIsReady;
extern BOOL g_bProxy;

#define IF_NTONLY if(VER_PLATFORM_WIN32_NT == g_dwPlatform) {
#define ENDIF_NTONLY }
extern DWORD g_dwPlatform;
extern DWORD g_dwBuild;

extern LPTSTR    g_pszAppDir;

// Includes
#include <atlcom.h>
#include <atlctl.h>

#include <ccstock.h>

#include <commctrl.h>
#include <ras.h>
#include <raserror.h>
#include <tapi.h>

#include "icwunicd.h" // UNICODE specific information.

#include "resource.h"

// Common global include for ICWHELP
#include "icwglob.h"
#include "import.h"
#include "icwhelp.h"
#include "cpicwhelp.h"      // Connection point proxys
#include "support.h"

#include "mcreg.h"          // abstract class for registry operations

#ifdef  UNICODE
#undef  A2BSTR
#define A2BSTR(lpa)    SysAllocString((OLECHAR FAR*)(lpa))
#endif

#ifdef  UNICODE
#undef  OLE2A
#define OLE2A(lpw)     ((LPTSTR)lpw)
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1E7949FE_86F4_11D1_ADD8_0000F87734F0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\rnaapi.cpp ===
/*-----------------------------------------------------------------------------
    rnaapi.cpp

    Wrapper to softlink to RNAPH and RASAPI32.DLL

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

    Authors:
        ChrisK        ChrisKauffman

    History:
        1/29/96        ChrisK    Created
        7/22/96        ChrisK    Cleaned and formatted
        1/7/98      DONALDM Moved to new ICW project and string
                    16 bit stuff
-----------------------------------------------------------------------------*/

#include "stdafx.h"

static const TCHAR cszRASAPI32_DLL[] = TEXT("RASAPI32.DLL");
static const TCHAR cszRNAPH_DLL[] = TEXT("RNAPH.DLL");

static const CHAR cszRasValidateEntryNamePlain[] = "RasValidateEntryName";

#ifdef UNICODE
static const CHAR cszRasEnumDevices[]        = "RasEnumDevicesW";
static const CHAR cszRasValidateEntryName[]  = "RasValidateEntryNameW";
static const CHAR cszRasSetEntryProperties[] = "RasSetEntryPropertiesW";
static const CHAR cszRasGetEntryProperties[] = "RasGetEntryPropertiesW";
static const CHAR cszRasDeleteEntry[]        = "RasDeleteEntryW";
static const CHAR cszRasHangUp[]             = "RasHangUpW";
static const CHAR cszRasGetConnectStatus[]   = "RasGetConnectStatusW";
static const CHAR cszRasDial[]               = "RasDialW";
static const CHAR cszRasEnumConnections[]    = "RasEnumConnectionsW";
static const CHAR cszRasGetEntryDialParams[] = "RasGetEntryDialParamsW";
static const CHAR cszRasGetCountryInfo[]     = "RasGetCountryInfoW";
static const CHAR cszRasSetEntryDialParams[] = "RasSetEntryDialParamsW";
#else
static const CHAR cszRasEnumDevices[]        = "RasEnumDevicesA";
static const CHAR cszRasValidateEntryName[]  = "RasValidateEntryNameA";
static const CHAR cszRasSetEntryProperties[] = "RasSetEntryPropertiesA";
static const CHAR cszRasGetEntryProperties[] = "RasGetEntryPropertiesA";
static const CHAR cszRasDeleteEntry[]        = "RasDeleteEntryA";
static const CHAR cszRasHangUp[]             = "RasHangUpA";
static const CHAR cszRasGetConnectStatus[]   = "RasGetConnectStatusA";
static const CHAR cszRasDial[]               = "RasDialA";
static const CHAR cszRasEnumConnections[]    = "RasEnumConnectionsA";
static const CHAR cszRasGetEntryDialParams[] = "RasGetEntryDialParamsA";
static const CHAR cszRasGetCountryInfo[]     = "RasGetCountryInfoA";
static const CHAR cszRasSetEntryDialParams[] = "RasSetEntryDialParamsA";
#endif

// on NT we have to call RasGetEntryProperties with a larger buffer than RASENTRY.
// This is a bug in WinNT4.0 RAS, that didn't get fixed.
//
#define RASENTRY_SIZE_PATCH (7 * sizeof(DWORD))

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RNAAPI
//
//    Synopsis:    Initialize class members and load DLLs
//
//    Arguments:    None
//
//    Returns:    None
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
RNAAPI::RNAAPI()
{
    m_hInst = LoadLibrary(cszRASAPI32_DLL);

    if (FALSE == IsNT ())
    {
        //
        // we only load RNAPH.DLL if it is not NT
        // MKarki (5/4/97) - Fix for Bug #3378
        //
        m_hInst2 = LoadLibrary(cszRNAPH_DLL);
    }
    else
    {
        m_hInst2 =  NULL;
    }

    m_fnRasEnumDeviecs = NULL;
    m_fnRasValidateEntryName = NULL;
    m_fnRasSetEntryProperties = NULL;
    m_fnRasGetEntryProperties = NULL;
    m_fnRasDeleteEntry = NULL;
    m_fnRasHangUp = NULL;
    m_fnRasGetConnectStatus = NULL;
    m_fnRasEnumConnections = NULL;
    m_fnRasDial = NULL;
    m_fnRasGetEntryDialParams = NULL;
    m_fnRasGetCountryInfo = NULL;
    m_fnRasSetEntryDialParams = NULL;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::~RNAAPI
//
//    Synopsis:    release DLLs
//
//    Arguments:    None
//
//    Returns:    None
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
RNAAPI::~RNAAPI()
{
    //
    // Clean up
    //
    if (m_hInst) FreeLibrary(m_hInst);
    if (m_hInst2) FreeLibrary(m_hInst2);
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasEnumDevices
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasEnumDevices(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb,
                             LPDWORD lpcDevices)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasEnumDevices,(FARPROC*)&m_fnRasEnumDeviecs);

    if (m_fnRasEnumDeviecs)
        dwRet = (*m_fnRasEnumDeviecs) (lpRasDevInfo, lpcb, lpcDevices);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::LoadApi
//
//    Synopsis:    If the given function pointer is NULL, then try to load the API
//                from the first DLL, if that fails, try to load from the second
//                DLL
//
//    Arguments:    pszFName - the name of the exported function
//                pfnProc - point to where the proc address will be returned
//
//    Returns:    TRUE - success
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
BOOL RNAAPI::LoadApi(LPCSTR pszFName, FARPROC* pfnProc)
{
    if (*pfnProc == NULL)
    {
        // Look for the entry point in the first DLL
        if (m_hInst)
            *pfnProc = GetProcAddress(m_hInst,pszFName);
        
        // if that fails, look for the entry point in the second DLL
        if (m_hInst2 && !(*pfnProc))
            *pfnProc = GetProcAddress(m_hInst2,pszFName);
    }

    return (pfnProc != NULL);
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasGetConnectStatus
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        7/16/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetConnectStatus(HRASCONN hrasconn,LPRASCONNSTATUS lprasconnstatus)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasGetConnectStatus,(FARPROC*)&m_fnRasGetConnectStatus);

    if (m_fnRasGetConnectStatus)
        dwRet = (*m_fnRasGetConnectStatus) (hrasconn,lprasconnstatus);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasValidateEntryName
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasValidateEntryName(LPTSTR lpszPhonebook,LPTSTR lpszEntry)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasValidateEntryNamePlain,(FARPROC*)&m_fnRasValidateEntryName);

    LoadApi(cszRasValidateEntryName,(FARPROC*)&m_fnRasValidateEntryName);

    if (m_fnRasValidateEntryName)
        dwRet = (*m_fnRasValidateEntryName) (lpszPhonebook, lpszEntry);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasSetEntryProperties
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasSetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
                                    LPBYTE lpbEntryInfo,  DWORD dwEntryInfoSize,
                                    LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;
    RASENTRY FAR *lpRE = NULL;


    // Look for the API if we haven't already found it
    LoadApi(cszRasSetEntryProperties,(FARPROC*)&m_fnRasSetEntryProperties);

    Assert(
        (NULL != lpbDeviceInfo) && (NULL != dwDeviceInfoSize)
        ||
        (NULL == lpbDeviceInfo) && (NULL == dwDeviceInfoSize)
        );

#define RASGETCOUNTRYINFO_BUFFER_SIZE 256
    if (0 == ((LPRASENTRY)lpbEntryInfo)->dwCountryCode)
    {
        BYTE rasCI[RASGETCOUNTRYINFO_BUFFER_SIZE];
        LPRASCTRYINFO prasCI;
        DWORD dwSize;
        DWORD dw;
        prasCI = (LPRASCTRYINFO)rasCI;
        ZeroMemory(prasCI,sizeof(rasCI));
        prasCI->dwSize = sizeof(RASCTRYINFO);
        dwSize = sizeof(rasCI);

        Assert(((LPRASENTRY)lpbEntryInfo)->dwCountryID);
        prasCI->dwCountryID = ((LPRASENTRY)lpbEntryInfo)->dwCountryID;

        dw = RNAAPI::RasGetCountryInfo(prasCI,&dwSize);
        if (ERROR_SUCCESS == dw)
        {
            Assert(prasCI->dwCountryCode);
            ((LPRASENTRY)lpbEntryInfo)->dwCountryCode = prasCI->dwCountryCode;
        } 
        else
        {
            AssertMsg(0,TEXT("Unexpected error from RasGetCountryInfo.\r\n"));
        }
    }

#ifdef UNICODE
    LPRASENTRY lpRasEntry;
    DWORD      dwSave;

    lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR, dwEntryInfoSize + 512);
    dwSave = dwEntryInfoSize;
    if(lpRasEntry)
    {
        memcpy(lpRasEntry, lpbEntryInfo, dwEntryInfoSize);
        dwEntryInfoSize += 512;
    }
    else
        lpRasEntry = (LPRASENTRY)lpbEntryInfo;

    if (m_fnRasSetEntryProperties)
        dwRet = (*m_fnRasSetEntryProperties) (lpszPhonebook, lpszEntry,
                                    (LPBYTE)lpRasEntry, dwEntryInfoSize,
                                    lpbDeviceInfo, dwDeviceInfoSize);

    if(lpRasEntry && lpRasEntry != (LPRASENTRY)lpbEntryInfo)
    {
        memcpy(lpbEntryInfo, lpRasEntry, dwSave);
        GlobalFree(lpRasEntry);
    }

#else
    if (m_fnRasSetEntryProperties)
        dwRet = (*m_fnRasSetEntryProperties) (lpszPhonebook, lpszEntry,
                                    lpbEntryInfo, dwEntryInfoSize,
                                    lpbDeviceInfo, dwDeviceInfoSize);
#endif
    lpRE = (RASENTRY FAR*)lpbEntryInfo;
    LclSetEntryScriptPatch(lpRE->szScript,lpszEntry);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasGetEntryProperties
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//                jmazner    9/17/96 Modified to allow calls with buffers = NULL and InfoSizes = 0.
//                                (Based on earlier modification to the same procedure in icwdial)
//                                See RasGetEntryProperties docs to learn why this is needed.
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
                                    LPBYTE lpbEntryInfo,  LPDWORD lpdwEntryInfoSize,
                                    LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;
    LPBYTE lpbEntryInfoPatch = NULL;
    LPDWORD  lpdwEntryInfoPatchSize = 0;

#if (WINVER != 0x400)
#error This was built with WINVER not equal to 0x400.  The size of RASENTRY may not be valid.
#endif

    if( (NULL == lpbEntryInfo) && (NULL == lpbDeviceInfo) )
    {
        Assert( NULL != lpdwEntryInfoSize );
        Assert( NULL != lpdwDeviceInfoSize );

        Assert( 0 == *lpdwEntryInfoSize );
        Assert( 0 == *lpdwDeviceInfoSize );

        // we're here to ask RAS what size these buffers need to be, don't use the patch stuff
        // (see RasGetEntryProperties docs)
        lpbEntryInfoPatch = lpbEntryInfo;
        lpdwEntryInfoPatchSize = lpdwEntryInfoSize;
    }
    else
    {

        Assert((*lpdwEntryInfoSize) >= sizeof(RASENTRY));
        Assert(lpbEntryInfo && lpdwEntryInfoSize);

        //
        // We are going to fake out RasGetEntryProperties by creating a slightly larger
        // temporary buffer and copying the data in and out.
        //
        lpdwEntryInfoPatchSize = (LPDWORD) GlobalAlloc(GPTR, sizeof(DWORD));
        if (NULL == lpdwEntryInfoPatchSize)
            return ERROR_NOT_ENOUGH_MEMORY;

        *lpdwEntryInfoPatchSize = (*lpdwEntryInfoSize) + RASENTRY_SIZE_PATCH;
        lpbEntryInfoPatch = (LPBYTE)GlobalAlloc(GPTR,*lpdwEntryInfoPatchSize);
        if (NULL == lpbEntryInfoPatch)
            return ERROR_NOT_ENOUGH_MEMORY;

        // RAS expects the dwSize field to contain the size of the LPRASENTRY struct
        // (used to check which version of the struct we're using) rather than the amount
        // of memory actually allocated to the pointer.
        //((LPRASENTRY)lpbEntryInfoPatch)->dwSize = dwEntryInfoPatch;
        ((LPRASENTRY)lpbEntryInfoPatch)->dwSize = sizeof(RASENTRY);
    }

    // Look for the API if we haven't already found it
    LoadApi(cszRasGetEntryProperties,(FARPROC*)&m_fnRasGetEntryProperties);

    if (m_fnRasGetEntryProperties)
        dwRet = (*m_fnRasGetEntryProperties) (lpszPhonebook, lpszEntry,
                                    lpbEntryInfoPatch, lpdwEntryInfoPatchSize,
                                    lpbDeviceInfo, lpdwDeviceInfoSize);

    TraceMsg(TF_RNAAPI, TEXT("ICWHELP: RasGetEntryProperties returned %lu\r\n"), dwRet); 


    if( NULL != lpbEntryInfo )
    {
        //
        // Copy out the contents of the temporary buffer UP TO the size of the original buffer
        //
        Assert(lpbEntryInfoPatch);
        memcpy(lpbEntryInfo,lpbEntryInfoPatch,*lpdwEntryInfoSize);
        GlobalFree(lpbEntryInfoPatch);
        lpbEntryInfoPatch = NULL;

        if( lpdwEntryInfoPatchSize )
        {
            GlobalFree( lpdwEntryInfoPatchSize );
            lpdwEntryInfoPatchSize = NULL;
        }
        //
        // We are again faking Ras functionality here by over writing the size value;
        // This is neccesary due to a bug in the NT implementation of RasSetEntryProperties
        *lpdwEntryInfoSize = sizeof(RASENTRY);
    }

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasDeleteEntry
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasDeleteEntry(LPTSTR lpszPhonebook, LPTSTR lpszEntry)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasDeleteEntry,(FARPROC*)&m_fnRasDeleteEntry);

    if (m_fnRasDeleteEntry)
        dwRet = (*m_fnRasDeleteEntry) (lpszPhonebook, lpszEntry);
    
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasHangUp
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasHangUp(HRASCONN hrasconn)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasHangUp,(FARPROC*)&m_fnRasHangUp);

    if (m_fnRasHangUp)
    {
        dwRet = (*m_fnRasHangUp) (hrasconn);
        Sleep(3000);
    }

    return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasDial(LPRASDIALEXTENSIONS lpRasDialExtensions,LPTSTR lpszPhonebook,
                      LPRASDIALPARAMS lpRasDialParams, DWORD dwNotifierType,
                      LPVOID lpvNotifier, LPHRASCONN lphRasConn)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasDial,(FARPROC*)&m_fnRasDial);

    if (m_fnRasDial)
    {
        dwRet = (*m_fnRasDial) (lpRasDialExtensions,lpszPhonebook,lpRasDialParams,
                                dwNotifierType,lpvNotifier,lphRasConn);
    }
    return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasEnumConnections(LPRASCONN lprasconn,LPDWORD lpcb,LPDWORD lpcConnections)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasEnumConnections,(FARPROC*)&m_fnRasEnumConnections);

    if (m_fnRasEnumConnections)
    {
        dwRet = (*m_fnRasEnumConnections) (lprasconn,lpcb,lpcConnections);
    }
    return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasGetEntryDialParams(LPTSTR lpszPhonebook,LPRASDIALPARAMS lprasdialparams,
                                    LPBOOL lpfPassword)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasGetEntryDialParams,(FARPROC*)&m_fnRasGetEntryDialParams);

    if (m_fnRasGetEntryDialParams)
    {
        dwRet = (*m_fnRasGetEntryDialParams) (lpszPhonebook,lprasdialparams,lpfPassword);
    }
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasGetCountryInfo
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        8/16/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetCountryInfo(LPRASCTRYINFO lprci, LPDWORD lpdwSize)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasGetCountryInfo,(FARPROC*)&m_fnRasGetCountryInfo);

    if (m_fnRasGetCountryInfo)
    {
        dwRet = (*m_fnRasGetCountryInfo) (lprci,lpdwSize);
    }
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasSetEntryDialParams
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        8/20/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasSetEntryDialParams(LPTSTR lpszPhonebook,LPRASDIALPARAMS lprasdialparams,
                            BOOL fRemovePassword)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasSetEntryDialParams,(FARPROC*)&m_fnRasSetEntryDialParams);

    if (m_fnRasSetEntryDialParams)
    {
        dwRet = (*m_fnRasSetEntryDialParams) (lpszPhonebook,lprasdialparams,
                            fRemovePassword);
    }
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function    LclSetEntryScriptPatch
//
//    Synopsis    Softlink to RasSetEntryPropertiesScriptPatch
//
//    Arguments    see RasSetEntryPropertiesScriptPatch
//
//    Returns        see RasSetEntryPropertiesScriptPatch
//
//    Histroy        10/3/96    ChrisK Created
//
//-----------------------------------------------------------------------------
typedef BOOL (WINAPI* LCLSETENTRYSCRIPTPATCH)(LPTSTR, LPTSTR);
BOOL LclSetEntryScriptPatch(LPTSTR lpszScript,LPTSTR lpszEntry)
{
    HINSTANCE hinst = NULL;
    LCLSETENTRYSCRIPTPATCH fp = NULL;
    BOOL bRC = FALSE;

    hinst = LoadLibrary(TEXT("ICWDIAL.DLL"));
    if (hinst)
    {
        fp = (LCLSETENTRYSCRIPTPATCH)GetProcAddress(hinst,"RasSetEntryPropertiesScriptPatch");
        if (fp)
            bRC = (fp)(lpszScript,lpszEntry);
        FreeLibrary(hinst);
        hinst = NULL;
        fp = NULL;
    }
    return bRC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\support.cpp ===
//#--------------------------------------------------------------
//        
//  File:       support.cpp
//        
//  Synopsis:   holds the  member functions for the support
//              class
//
//  History:     5/8/97    MKarki Created
//
//    Copyright (C) 1996-97 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "stdafx.h"

//++--------------------------------------------------------------
//
//  Function:   GetSupportInfo
//
//  Synopsis:   This is the public member function used to get the 
//              support numbers
//
//  Returns:    BOOL - success/failure
//
//  Arguments:  PCHAR - returns the number
//
//  History:    MKarki      Created     5/8/97
//
//----------------------------------------------------------------
BOOL
CSupport :: GetSupportInfo 
(
    LPTSTR  pszNumber,
    DWORD   dwCountryID
)
{
    HINSTANCE hPHBKDll = NULL;
    DWORD   dwBufferSize = 0;
    BOOL    bRetVal = FALSE;
    PFNGETSUPPORTNUMBERS pfnSupport = NULL;
    HRESULT hr = ERROR_SUCCESS;
    DWORD   dwTotalNums = 0;
    DWORD   dwIndex = 0;

    
    TraceMsg (TF_GENERAL, TEXT("Entering CSupport :: GetSupportInfo\r\n"));
    
    if (NULL == pszNumber)
    {
        TraceMsg (TF_GENERAL, TEXT("NULL = pszNumber\r\n"));
        goto Cleanup;
    }
    

    
    if (NULL == m_pSupportNumList)
    {
        //
        // being called the first time so load the info
        //
        hPHBKDll = LoadLibrary(PHBK_LIB);
        if (NULL == hPHBKDll)
        {
            TraceMsg (TF_GENERAL, TEXT("Failed on LoadLibrary API call with error:%d\r\n"),
                GetLastError () );
            goto Cleanup;
        }

        pfnSupport = (PFNGETSUPPORTNUMBERS) 
                        GetProcAddress(hPHBKDll,PHBK_SUPPORTNUMAPI);
        if (NULL == pfnSupport)
        {
            TraceMsg (TF_GENERAL, TEXT("Failed on GetProcAddress API call with error:%d\r\n"),
                GetLastError () );
            goto Cleanup;
        }
        
        //
        //  call the first time to get the size needed
        //
        hr = pfnSupport ((PSUPPORTNUM)NULL, (PDWORD)&dwBufferSize);
        if (ERROR_SUCCESS != hr)
        {
            TraceMsg (TF_GENERAL, TEXT("Failed on GetSupportNumbers API call with error:%d\r\n"),
                hr);
           goto Cleanup; 
        }
    
        //
        // allocate the required memory
        //
        m_pSupportNumList = (PSUPPORTNUM) GlobalAlloc (  
                                            GPTR,
                                            dwBufferSize
                                            );
        if (NULL == m_pSupportNumList)
        {
            TraceMsg (TF_GENERAL, TEXT("Failed on GlobalAlloc API call with error:%d\r\n"),
                GetLastError ());
            goto Cleanup;                
        }


        //
        //  call second time for the info
        //
        hr = pfnSupport ((PSUPPORTNUM)m_pSupportNumList, (PDWORD)&dwBufferSize);
        if (ERROR_SUCCESS != hr)
        {
            TraceMsg (TF_GENERAL, TEXT("Failed on GetSupportNumbers API call with error:%d\r\n"),
                hr);
            goto Cleanup;
        }

    //
    // find out how many SUPPORTNUM structs we have in the
    // array
    m_dwTotalNums = dwBufferSize / sizeof (SUPPORTNUM);

    }
        
    
    //
    // get the current country code
    //
    for  (dwIndex = 0; dwIndex < m_dwTotalNums; dwIndex++)
    {
        //
        // this struct says countrycode but is actually countryID
        //
        if (m_pSupportNumList[dwIndex].dwCountryCode == dwCountryID)
        {
            //
            //   found a support phone number
            //
            CopyMemory (
                pszNumber, 
                m_pSupportNumList[dwIndex].szPhoneNumber,  
                sizeof (m_pSupportNumList[dwIndex].szPhoneNumber)
                );
            bRetVal = TRUE;
            goto Cleanup;
        }
    }

Cleanup:
    if (NULL != hPHBKDll)
         FreeLibrary (hPHBKDll); 

    TraceMsg (TF_GENERAL, TEXT("returning from CSupport :: GetSupportInfo function\r\n"));

    return (bRetVal);

}   //  end of CSupport :: GetSupportInfo function
                
//++--------------------------------------------------------------
//
//  Function:    ~CSupport
//
//  Synopsis:   This is the destructor of the CSupport class
//
//
//  Arguments:  VOID
//
//  History:    MKarki      Created     5/8/97
//
//----------------------------------------------------------------
CSupport :: ~CSupport (
        VOID
        )
{
    if (NULL != m_pSupportNumList)
        GlobalFree (m_pSupportNumList);

}   // end of ~CSupport function
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\support.h ===
//#--------------------------------------------------------------
//        
//  File:       support.h
//        
//  Synopsis:   holds the  Class declaration for the CSupport
//              class
//
//  History:     5/8/97    MKarki Created
//
//    Copyright (C) 1996-97 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------

#include "..\icwphbk\icwsupport.h"

const TCHAR PHBK_LIB[] = TEXT("icwphbk.dll");
const CHAR PHBK_SUPPORTNUMAPI[] = "GetSupportNumbers";

typedef HRESULT (WINAPI *PFNGETSUPPORTNUMBERS) (PSUPPORTNUM, PDWORD);

class CSupport
{
private:
    PSUPPORTNUM     m_pSupportNumList;
    DWORD           m_dwTotalNums;

    //
    // this function gets the countryID
    //
    BOOL GetCountryID (PDWORD pdwCountryID); 

public:
    CSupport (VOID)
    {
        m_pSupportNumList = NULL;
        m_dwTotalNums = 0;
    }

    ~CSupport (VOID);

    BOOL GetSupportInfo (LPTSTR, DWORD);

};  // end of CSupport class declaration
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\userinfo.h ===
// UserInfo.h : Declaration of the CUserInfo

#ifndef __USERINFO_H_
#define __USERINFO_H_

#include "resource.h"       // main symbols

#define REGSTR_PATH_USERINFO    TEXT("Software\\Microsoft\\User Information")

extern LPCTSTR lpcsz_FirstName;
extern LPCTSTR lpcsz_LastName;
extern LPCTSTR lpcsz_Company;
extern LPCTSTR lpcsz_Address1;
extern LPCTSTR lpcsz_Address2;
extern LPCTSTR lpcsz_City;
extern LPCTSTR lpcsz_State;
extern LPCTSTR lpcsz_ZIPCode;
extern LPCTSTR lpcsz_PhoneNumber;

#define NUM_USERINFO_ELEMENTS   9
typedef struct  userInfoQuery_tag
{
    LPCTSTR   lpcszRegVal;
    BSTR     *pbstrVal;
} USERINFOQUERY;


/////////////////////////////////////////////////////////////////////////////
// CUserInfo
class ATL_NO_VTABLE CUserInfo :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CUserInfo,&CLSID_UserInfo>,
	public CComControl<CUserInfo>,
	public IDispatchImpl<IUserInfo, &IID_IUserInfo, &LIBID_ICWHELPLib>,
	public IPersistStreamInitImpl<CUserInfo>,
	public IOleControlImpl<CUserInfo>,
	public IOleObjectImpl<CUserInfo>,
	public IOleInPlaceActiveObjectImpl<CUserInfo>,
	public IViewObjectExImpl<CUserInfo>,
	public IOleInPlaceObjectWindowlessImpl<CUserInfo>,
    public IObjectSafetyImpl<CUserInfo>
{
public:
	CUserInfo()
	{
        m_aUserInfoQuery[0].lpcszRegVal =  lpcsz_FirstName;
        m_aUserInfoQuery[0].pbstrVal    = &m_bstrFirstName;
        m_aUserInfoQuery[1].lpcszRegVal =  lpcsz_LastName;
        m_aUserInfoQuery[1].pbstrVal    = &m_bstrLastName;
        m_aUserInfoQuery[2].lpcszRegVal =  lpcsz_Address1;
        m_aUserInfoQuery[2].pbstrVal    = &m_bstrAddress1;
        m_aUserInfoQuery[3].lpcszRegVal =  lpcsz_Address2;
        m_aUserInfoQuery[3].pbstrVal    = &m_bstrAddress2;
        m_aUserInfoQuery[4].lpcszRegVal =  lpcsz_City;
        m_aUserInfoQuery[4].pbstrVal    = &m_bstrCity;
        m_aUserInfoQuery[5].lpcszRegVal =  lpcsz_State;
        m_aUserInfoQuery[5].pbstrVal    = &m_bstrState;
        m_aUserInfoQuery[6].lpcszRegVal =  lpcsz_ZIPCode;
        m_aUserInfoQuery[6].pbstrVal    = &m_bstrZIPCode;
        m_aUserInfoQuery[7].lpcszRegVal =  lpcsz_PhoneNumber; 
        m_aUserInfoQuery[7].pbstrVal    = &m_bstrPhoneNumber;
        m_aUserInfoQuery[8].lpcszRegVal =  lpcsz_Company; 
        m_aUserInfoQuery[8].pbstrVal    = &m_bstrCompany;
	
	}

DECLARE_REGISTRY_RESOURCEID(IDR_USERINFO)

BEGIN_COM_MAP(CUserInfo) 
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IUserInfo)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CUserInfo)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CUserInfo)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = 0;
		return S_OK;
	}

// IUserInfo
public:
	STDMETHOD(PersistRegisteredUserInfo)(/*[out, retval]*/ BOOL *pbRetVal);
	STDMETHOD(get_Lcid)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_PhoneNumber)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_PhoneNumber)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ZIPCode)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ZIPCode)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_State)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_State)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_City)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_City)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Address2)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Address2)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Address1)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Address1)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_LastName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_LastName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FirstName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FirstName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Company)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Company)(/*[in]*/ BSTR newVal);
    STDMETHOD(CollectRegisteredUserInfo)(/*[out, retval]*/ BOOL *pbRetVal);
	HRESULT OnDraw(ATL_DRAWINFO& di);

private:
    CComBSTR    m_bstrFirstName;
    CComBSTR    m_bstrLastName;
    CComBSTR    m_bstrCompany;
    CComBSTR    m_bstrAddress1;
    CComBSTR    m_bstrAddress2;
    CComBSTR    m_bstrCity;
    CComBSTR    m_bstrState;
    CComBSTR    m_bstrZIPCode;
    CComBSTR    m_bstrPhoneNumber;
	long        m_lLcid;

    USERINFOQUERY   m_aUserInfoQuery[NUM_USERINFO_ELEMENTS];


};

#endif //__USERINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\tapiloc.h ===
// tapiloc.h : Declaration of the CTapiLocationInfo

#ifndef __TAPILOCATIONINFO_H_
#define __TAPILOCATIONINFO_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CTapiLocationInfo
class ATL_NO_VTABLE CTapiLocationInfo :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CTapiLocationInfo,&CLSID_TapiLocationInfo>,
    public CComControl<CTapiLocationInfo>,
    public IDispatchImpl<ITapiLocationInfo, &IID_ITapiLocationInfo, &LIBID_ICWHELPLib>,
    public IPersistStreamInitImpl<CTapiLocationInfo>,
    public IOleControlImpl<CTapiLocationInfo>,
    public IOleObjectImpl<CTapiLocationInfo>,
    public IOleInPlaceActiveObjectImpl<CTapiLocationInfo>,
    public IViewObjectExImpl<CTapiLocationInfo>,
    public IOleInPlaceObjectWindowlessImpl<CTapiLocationInfo>,
    public IObjectSafetyImpl<CTapiLocationInfo>
{
public:
    CTapiLocationInfo()
    {
        m_wNumTapiLocations = 0;
        m_dwCountry = 0;
        m_dwCurrLoc = 0;
        m_hLineApp = NULL;
        m_pLineCountryList = NULL;
        m_rgNameLookUp = NULL;
        m_pTC = NULL;
    }

    ~CTapiLocationInfo()
    {
        if (m_pLineCountryList)
        {
            GlobalFree(m_pLineCountryList);
        }
        if (m_rgNameLookUp)
        {
            GlobalFree(m_rgNameLookUp);
        }
        if (m_pTC)
        {
            GlobalFree(m_pTC);
        }
    }


DECLARE_REGISTRY_RESOURCEID(IDR_TAPILOCATIONINFO)

BEGIN_COM_MAP(CTapiLocationInfo) 
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITapiLocationInfo)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CTapiLocationInfo)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CTapiLocationInfo)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = 0;
        return S_OK;
    }

// ITapiLocationInfo
public:
    STDMETHOD(GetTapiLocationInfo)(/*[out, retval]*/ BOOL *pbRetVal);

    STDMETHOD(get_lCountryCode)(/*[out, retval]*/ long *plVal);
    STDMETHOD(get_NumCountries)(/*[out, retval]*/ long *pNumOfCountry);
    STDMETHOD(get_CountryName)(/*[in]*/ long lCountryIndex, /*[out, retval]*/ BSTR * pszCountryName, /*[out, retval]*/ long * pCountryCode);
    STDMETHOD(get_DefaultCountry)(/*[out, retval]*/ BSTR * pszCountryName);
    STDMETHOD(get_bstrAreaCode)(/*[out, retval]*/ BSTR *pbstrAreaCode);
    STDMETHOD(put_bstrAreaCode)(/*[in]*/ BSTR bstrAreaCode);
    STDMETHOD(get_wNumberOfLocations)(/*[out]*/ short *psVal, /*[out, retval]*/ long *pCurrLoc);
    STDMETHOD(get_LocationName)(/*[in]*/ long lLocationIndex, /*[out, retval]*/ BSTR *pszLocationName);
    STDMETHOD(get_LocationInfo)(/*[in]*/ long lLocationIndex, /*[out, retval]*/ long *pLocationID, /*[out, retval]*/ BSTR * pszCountryName, /*[out, retval]*/ long *pCountryCode, /*[out, retval]*/ BSTR * pszAreaCode);
    STDMETHOD(put_LocationId)(/*[in]*/ long lLocationID);
    HRESULT OnDraw(ATL_DRAWINFO& di);

protected:
    HLINEAPP                    m_hLineApp;
    WORD                        m_wNumTapiLocations;
    DWORD                       m_dwCountry;
    DWORD                       m_dwCurrLoc;
    CComBSTR                    m_bstrAreaCode;
    CComBSTR                    m_bstrDefaultCountry;
    LPLINECOUNTRYLIST           m_pLineCountryList;
    LPCNTRYNAMELOOKUPELEMENT    m_rgNameLookUp;
    LPLINELOCATIONENTRY         m_plle;
    LPLINETRANSLATECAPS         m_pTC;
    TCHAR                       m_szCountryCode[8];
};

#endif //__TAPILOCATIONINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\tapiloc.cpp ===
// tapiloc.cpp : Implementation of CTapiLocationInfo
#include "stdafx.h"
#include "icwhelp.h"
#include "tapiloc.h"

/////////////////////////////////////////////////////////////////////////////
// CTapiLocationInfo


HRESULT CTapiLocationInfo::OnDraw(ATL_DRAWINFO& di)
{
	return S_OK;
}

STDMETHODIMP CTapiLocationInfo::get_wNumberOfLocations(short * psVal, long *pCurrLoc)
{
    if ((psVal == NULL) || (pCurrLoc == NULL))
        return E_POINTER;
    *psVal = m_wNumTapiLocations;
    *pCurrLoc = m_pTC ? (long) m_dwCurrLoc : 0;
	return S_OK;
}

STDMETHODIMP CTapiLocationInfo::get_bstrAreaCode(BSTR * pbstrAreaCode)
{
    USES_CONVERSION;
    if (pbstrAreaCode == NULL)
         return E_POINTER;
    *pbstrAreaCode = m_bstrAreaCode.Copy();	
	return S_OK;
}

STDMETHODIMP CTapiLocationInfo::put_bstrAreaCode(BSTR bstrAreaCode)
{
    USES_CONVERSION;
    m_bstrAreaCode = bstrAreaCode;
	return S_OK;
}

STDMETHODIMP CTapiLocationInfo::get_lCountryCode(long * plVal)
{
    *plVal = m_dwCountry;
	return S_OK;
}

STDMETHODIMP CTapiLocationInfo::get_NumCountries(long *pNumOfCountry)
{
    LPLINECOUNTRYLIST pLineCountryTemp = NULL;
    LPLINECOUNTRYENTRY pLCETemp;
    DWORD idx;
    DWORD dwCurLID = 0;
    //LPIDLOOKUPELEMENT m_rgIDLookUp;
    

    // Get TAPI country list
    if (m_pLineCountryList)
        GlobalFree(m_pLineCountryList);

    m_pLineCountryList = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,sizeof(LINECOUNTRYLIST));
    if (!m_pLineCountryList) 
        return S_FALSE;
    
    m_pLineCountryList->dwTotalSize = sizeof(LINECOUNTRYLIST);
    
    idx = lineGetCountry(0,0x10003,m_pLineCountryList);
    if (idx && idx != LINEERR_STRUCTURETOOSMALL)
        return S_FALSE;
    
    Assert(m_pLineCountryList->dwNeededSize);

    pLineCountryTemp = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,
                                                        (size_t)m_pLineCountryList->dwNeededSize);
    if (!pLineCountryTemp)
        return S_FALSE;
    
    pLineCountryTemp->dwTotalSize = m_pLineCountryList->dwNeededSize;
    GlobalFree(m_pLineCountryList);
    
    m_pLineCountryList = pLineCountryTemp;
    pLineCountryTemp = NULL;

    if (lineGetCountry(0,0x10003,m_pLineCountryList))

        return S_FALSE;

    // look up array
    pLCETemp = (LPLINECOUNTRYENTRY)((DWORD_PTR)m_pLineCountryList + 
        m_pLineCountryList->dwCountryListOffset);

    if(m_rgNameLookUp)
        GlobalFree(m_rgNameLookUp);

    m_rgNameLookUp = (LPCNTRYNAMELOOKUPELEMENT)GlobalAlloc(GPTR,
        (int)(sizeof(CNTRYNAMELOOKUPELEMENT) * m_pLineCountryList->dwNumCountries));

    if (!m_rgNameLookUp) return S_FALSE;

    DWORD  dwCID = atol((const char *)m_szCountryCode);

    for (idx=0;idx<m_pLineCountryList->dwNumCountries;idx++)
    {
        m_rgNameLookUp[idx].psCountryName = (LPTSTR)((LPBYTE)m_pLineCountryList + (DWORD)pLCETemp[idx].dwCountryNameOffset);
        m_rgNameLookUp[idx].pLCE = &pLCETemp[idx];
        if (m_rgNameLookUp[idx].pLCE->dwCountryCode == dwCID)
        {
            if (m_rgNameLookUp[idx].psCountryName)
                m_bstrDefaultCountry = A2BSTR(m_rgNameLookUp[idx].psCountryName);
        }
  }

    *pNumOfCountry = m_pLineCountryList->dwNumCountries;

    return S_OK;
}

STDMETHODIMP CTapiLocationInfo::get_CountryName(long lCountryIndex, BSTR* pszCountryName, long* pCountryCode)
{
    *pszCountryName = A2BSTR(m_rgNameLookUp[lCountryIndex].psCountryName);

    if (m_rgNameLookUp[lCountryIndex].pLCE)
    {
        *pCountryCode = m_rgNameLookUp[lCountryIndex].pLCE->dwCountryCode;
    }

    return S_OK;
}

STDMETHODIMP CTapiLocationInfo::get_DefaultCountry(BSTR * pszCountryName)
{
    USES_CONVERSION;
    if (pszCountryName == NULL)
         return E_POINTER;
    *pszCountryName = m_bstrDefaultCountry.Copy();	
	return S_OK;
}

STDMETHODIMP CTapiLocationInfo::GetTapiLocationInfo(BOOL * pbRetVal)
{
    HRESULT             hr = ERROR_SUCCESS;
    TCHAR               szAreaCode[MAX_AREACODE+1];
    DWORD               cDevices=0;
    DWORD               dwCurDev = 0;
    DWORD               dwAPI = 0;
    LONG                lrc = 0;
    LINEEXTENSIONID     leid;
    LPVOID              pv = NULL;
    DWORD               dwCurLoc = 0;
    
    USES_CONVERSION;
    m_hLineApp=NULL;
    // Assume Failure
    *pbRetVal = FALSE;
    if (m_pTC)
    {
        m_dwCountry = 0; // Reset country ID, re-read TAPI info
        GlobalFree(m_pTC);
        m_pTC = NULL;
    }

    // Get area code from TAPI
    if (!m_bstrAreaCode)
    {
        hr = tapiGetLocationInfo(m_szCountryCode,szAreaCode);
        if (hr)
        {
            TraceMsg(TF_TAPIINFO, TEXT("ICWHELP:tapiGetLocationInfo failed.  RUN FOR YOUR LIVES!!\n"));
#ifdef UNICODE
        // There is no lineInitializeW verion in TAPI. So use A version lineInitialize.
            hr = lineInitialize(&m_hLineApp,_Module.GetModuleInstance(),LineCallback,GetSzA(IDS_TITLE),&cDevices);
#else
            hr = lineInitialize(&m_hLineApp,_Module.GetModuleInstance(),LineCallback,GetSz(IDS_TITLE),&cDevices);
#endif
            if (hr == ERROR_SUCCESS)
            {
                lineTranslateDialog(m_hLineApp,0,0x10004,GetActiveWindow(),NULL);
                lineShutdown(m_hLineApp);
            }

            hr = tapiGetLocationInfo(m_szCountryCode,szAreaCode);
        }

        if (hr)
        {
            goto GetTapiInfoExit;
        }
        m_bstrAreaCode = A2BSTR(szAreaCode);
    }

    // Get the numeric Country code from TAPI for the current location
    if (m_dwCountry == 0)
    {
        // Get CountryID from TAPI
        m_hLineApp = NULL;

        // Get the handle to the line app
#ifdef UNICODE
        // There is no lineInitializeW verion in TAPI. So use A version lineInitialize.
        lineInitialize(&m_hLineApp,_Module.GetModuleInstance(),LineCallback,GetSzA(IDS_TITLE),&cDevices);
#else
        lineInitialize(&m_hLineApp,_Module.GetModuleInstance(),LineCallback,GetSz(IDS_TITLE),&cDevices);
#endif
        if (!m_hLineApp)
        {
            // if we can't figure it out because TAPI is messed up
            // just default to the US and bail out of here.
            // The user will still have the chance to pick the right answer.
            m_dwCountry = 1;
            goto GetTapiInfoExit;
        }
        if (cDevices)
        {

            // Get the TAPI API version
            //
            dwCurDev = 0;
            dwAPI = 0;
            lrc = -1;
            while (lrc && dwCurDev < cDevices)
            {
                // NOTE: device ID's are 0 based
                ZeroMemory(&leid,sizeof(leid));
                lrc = lineNegotiateAPIVersion(m_hLineApp,dwCurDev,0x00010004,0x00010004,&dwAPI,&leid);
                dwCurDev++;
            }
            if (lrc)
            {
                // TAPI and us can't agree on anything so nevermind...
                goto GetTapiInfoExit;
            }

            // Find the CountryID in the translate cap structure
            m_pTC = (LINETRANSLATECAPS *)GlobalAlloc(GPTR,sizeof(LINETRANSLATECAPS));
            if (!m_pTC)
            {
                // we are in real trouble here, get out!
                hr = ERROR_NOT_ENOUGH_MEMORY;
                goto GetTapiInfoExit;
            }

            // Get the needed size
            m_pTC->dwTotalSize = sizeof(LINETRANSLATECAPS);
            lrc = lineGetTranslateCaps(m_hLineApp,dwAPI,m_pTC);
            if(lrc)
            {
                goto GetTapiInfoExit;
            }

            pv = GlobalAlloc(GPTR, ((size_t)m_pTC->dwNeededSize));
            if (!pv)
            {
                hr = ERROR_NOT_ENOUGH_MEMORY;
                goto GetTapiInfoExit;
            }
            ((LINETRANSLATECAPS*)pv)->dwTotalSize = m_pTC->dwNeededSize;
            m_pTC = (LINETRANSLATECAPS*)pv;
            pv = NULL;
            lrc = lineGetTranslateCaps(m_hLineApp,dwAPI,m_pTC);
            if(lrc)
            {
                goto GetTapiInfoExit;
            }
        
            // sanity check
            Assert(m_pTC->dwLocationListOffset);

            // We have the Number of TAPI locations, so save it now
            m_wNumTapiLocations = (WORD)m_pTC->dwNumLocations;

            // Loop through the locations to find the correct country code
            m_plle = LPLINELOCATIONENTRY (LPSTR(m_pTC) + m_pTC->dwLocationListOffset);
            for (dwCurLoc = 0; dwCurLoc < m_pTC->dwNumLocations; dwCurLoc++)
            {
                if (m_pTC->dwCurrentLocationID == m_plle->dwPermanentLocationID)
                {
                    m_dwCountry = m_plle->dwCountryID;
                    m_dwCurrLoc = dwCurLoc;
                    break; // for loop
                }
                m_plle++;
            }

            // If we could not find it in the above loop, default to US
            if (!m_dwCountry)
            {
                m_dwCountry = 1;
                goto GetTapiInfoExit;
            }
        }
    }

    *pbRetVal = TRUE;           // Getting here means everything worked

GetTapiInfoExit:

    // Give the user an Error Message, and the wizard will bail.
    if (!*pbRetVal)
    {
        if( m_hLineApp )
        {
            lineShutdown(m_hLineApp);
            m_hLineApp = NULL;
        }
        MsgBox(IDS_CONFIGAPIFAILED,MB_MYERROR);
    }

    return S_OK;
}

STDMETHODIMP CTapiLocationInfo::get_LocationName(long lLocationIndex, BSTR* pszLocationName)
{
    if (m_pTC == NULL)
        return E_POINTER;

    m_plle = LPLINELOCATIONENTRY (LPSTR(m_pTC) + m_pTC->dwLocationListOffset);
    m_plle += lLocationIndex;
    *pszLocationName = A2BSTR( ((LPSTR) m_pTC) + m_plle->dwLocationNameOffset );   
    return S_OK;
}

STDMETHODIMP CTapiLocationInfo::get_LocationInfo(long lLocationIndex, long *pLocationID, BSTR* pszCountryName, long *pCountryCode, BSTR* pszAreaCode)
{
    DWORD idx;
    LPLINECOUNTRYLIST pLineCountryTemp = NULL;
    DWORD dwCurLID = 0;

    // Loop through the locations to find the correct country code
    m_plle = LPLINELOCATIONENTRY (LPSTR(m_pTC) + m_pTC->dwLocationListOffset);
    m_plle += lLocationIndex;

    // Assign country code and area code
    *pCountryCode = m_plle->dwCountryID;
    *pszAreaCode =  A2BSTR( ((LPSTR) m_pTC) + m_plle->dwCityCodeOffset );

    // Assign location ID
    *pLocationID = m_plle->dwPermanentLocationID;
   
    if (m_pLineCountryList)
    {
        GlobalFree(m_pLineCountryList);
        m_pLineCountryList = NULL;
    }

    // Get TAPI country name from country ID
    m_pLineCountryList = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,sizeof(LINECOUNTRYLIST));
    if (!m_pLineCountryList) 
        return E_POINTER;
    
    m_pLineCountryList->dwTotalSize = sizeof(LINECOUNTRYLIST);
    
    idx = lineGetCountry(m_plle->dwCountryID,0x10003,m_pLineCountryList);
    if (idx && idx != LINEERR_STRUCTURETOOSMALL)
        return E_POINTER;
    
    Assert(m_pLineCountryList->dwNeededSize);

    pLineCountryTemp = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,
                                                        (size_t)m_pLineCountryList->dwNeededSize);
    if (!pLineCountryTemp)
        return E_POINTER;
    
    pLineCountryTemp->dwTotalSize = m_pLineCountryList->dwNeededSize;
    GlobalFree(m_pLineCountryList);
    
    m_pLineCountryList = pLineCountryTemp;

    if (lineGetCountry(m_plle->dwCountryID,0x10003,m_pLineCountryList))

        return E_POINTER;

    LPLINECOUNTRYENTRY pLCETemp = (LPLINECOUNTRYENTRY)((DWORD_PTR)m_pLineCountryList + m_pLineCountryList->dwCountryListOffset);

    LPTSTR psCountryName = (LPTSTR)((LPBYTE)m_pLineCountryList + (DWORD)pLCETemp[0].dwCountryNameOffset);
    *pszCountryName = A2BSTR(psCountryName);

    return S_OK;
}


STDMETHODIMP CTapiLocationInfo::put_LocationId(long lLocationID)
{
    ASSERT(m_hLineApp);
    // Must call GetTapiLocationInfo to get the Tapi handle first
    if (m_hLineApp)
    {
        lineSetCurrentLocation(m_hLineApp, lLocationID);
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\userinfo.cpp ===
// UserInfo.cpp : Implementation of CUserInfo
#include "stdafx.h"
#include "icwhelp.h"
#include "UserInfo.h"
#include <regstr.h>
#include <winnls.h>

LPCTSTR lpcsz_FirstName   = TEXT("Default First Name");
LPCTSTR lpcsz_LastName    = TEXT("Default Last Name");
LPCTSTR lpcsz_Company     = TEXT("Default Company");
LPCTSTR lpcsz_Address1    = TEXT("Mailing Address");
LPCTSTR lpcsz_Address2    = TEXT("Additional Address");
LPCTSTR lpcsz_City        = TEXT("City");
LPCTSTR lpcsz_State       = TEXT("State");
LPCTSTR lpcsz_ZIPCode     = TEXT("ZIP Code");
LPCTSTR lpcsz_PhoneNumber = TEXT("Daytime Phone");

/////////////////////////////////////////////////////////////////////////////
// CUserInfo


HRESULT CUserInfo::OnDraw(ATL_DRAWINFO& di)
{
	return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Collect registered user information from the registry.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CUserInfo::CollectRegisteredUserInfo(BOOL * pbRetVal)
{
    USES_CONVERSION;            // We will be converting from ANSI to BSTR

    HKEY        hkey = NULL;
    TCHAR       szRegValue[REGSTR_MAX_VALUE_LENGTH];

    // Initialize the function return value.
    *pbRetVal = FALSE;
    
    //Try to get the info form the win98/NT5 location
    if (RegOpenKey(HKEY_LOCAL_MACHINE,REGSTR_PATH_USERINFO,&hkey) != ERROR_SUCCESS)
        //try to get it form the win95 spot
        RegOpenKey(HKEY_CURRENT_USER,REGSTR_PATH_USERINFO,&hkey);
    
    if(hkey != NULL)
	{
        DWORD   dwSize;
        DWORD   dwType = REG_SZ;
        for (int iX = 0; iX < NUM_USERINFO_ELEMENTS; iX ++)
        {
            // Set the size each time
            dwSize = sizeof(TCHAR)*REGSTR_MAX_VALUE_LENGTH; 
            if (RegQueryValueEx(hkey,
                                m_aUserInfoQuery[iX].lpcszRegVal,
                                NULL,
                                &dwType,
                                (LPBYTE)szRegValue,
                                &dwSize) == ERROR_SUCCESS)
            {
                *m_aUserInfoQuery[iX].pbstrVal = A2BSTR(szRegValue);
                *pbRetVal = TRUE;
            }
        }
        RegCloseKey(hkey);
    }

	LCID lcid;
	
	lcid = GetUserDefaultLCID();

	m_lLcid =	LOWORD(lcid); 

	return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Persist collected registered user information to the registry.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CUserInfo::PersistRegisteredUserInfo(BOOL * pbRetVal)
{
    USES_CONVERSION;            // We will be converting from ANSI to BSTR

    HKEY        hkey = NULL;

    // Initialize the function return value.
    *pbRetVal = TRUE;
    
    //Try to get the userinfo form the win98/NT5 location
    if (RegOpenKey(HKEY_LOCAL_MACHINE,REGSTR_PATH_USERINFO,&hkey) != ERROR_SUCCESS)
        
        //try to get it form the win95 spot
        if (RegOpenKey(HKEY_CURRENT_USER,REGSTR_PATH_USERINFO,&hkey) != ERROR_SUCCESS)
        {
            // Create the key
            RegCreateKey(HKEY_LOCAL_MACHINE,REGSTR_PATH_USERINFO,&hkey);
        }
    
    if(hkey != NULL)
	{
        LPTSTR  lpszRegVal;
        DWORD   cbData;
        // Loop for each of the values to be persisted
        for (int iX = 0; iX < NUM_USERINFO_ELEMENTS; iX ++)
        {
            if (NULL != *m_aUserInfoQuery[iX].pbstrVal)
            {
                // Convert the BSTR to an ANSI string.  the converted string will
                // be on the stack, so it will get freed when this function exits.
                lpszRegVal = OLE2A(*m_aUserInfoQuery[iX].pbstrVal);
                cbData = lstrlen(lpszRegVal);

                // Set the value
                if (RegSetValueEx(hkey, 
                              m_aUserInfoQuery[iX].lpcszRegVal,
                              0,
                              REG_SZ,
                              (LPBYTE) lpszRegVal,
                              sizeof(TCHAR)*(cbData+1)) != ERROR_SUCCESS)
                {
                    *pbRetVal = FALSE;
                }
            }                
        }
        RegCloseKey(hkey);
    }

	return S_OK;
}

STDMETHODIMP CUserInfo::get_FirstName(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    *pVal = m_bstrFirstName.Copy();
    return S_OK;
}

STDMETHODIMP CUserInfo::put_FirstName(BSTR newVal)
{
    m_bstrFirstName = newVal;
	return S_OK;
}

STDMETHODIMP CUserInfo::get_LastName(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    *pVal = m_bstrLastName.Copy();
	return S_OK;
}

STDMETHODIMP CUserInfo::put_LastName(BSTR newVal)
{
    m_bstrLastName = newVal;
    return S_OK;
}

STDMETHODIMP CUserInfo::get_Company(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    *pVal = m_bstrCompany.Copy();
	return S_OK;
}

STDMETHODIMP CUserInfo::put_Company(BSTR newVal)
{
    m_bstrCompany = newVal;
    return S_OK;
}

STDMETHODIMP CUserInfo::get_Address1(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    *pVal = m_bstrAddress1.Copy();
	return S_OK;
}

STDMETHODIMP CUserInfo::put_Address1(BSTR newVal)
{
    m_bstrAddress1 = newVal;
	return S_OK;
}

STDMETHODIMP CUserInfo::get_Address2(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    *pVal = m_bstrAddress2.Copy();
	return S_OK;
}

STDMETHODIMP CUserInfo::put_Address2(BSTR newVal)
{
    m_bstrAddress2 = newVal;
	return S_OK;
}

STDMETHODIMP CUserInfo::get_City(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    *pVal = m_bstrCity.Copy();
	return S_OK;
}

STDMETHODIMP CUserInfo::put_City(BSTR newVal)
{
    m_bstrCity = newVal;
	return S_OK;
}

STDMETHODIMP CUserInfo::get_State(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    *pVal = m_bstrState.Copy();
	return S_OK;
}

STDMETHODIMP CUserInfo::put_State(BSTR newVal)
{
    m_bstrState = newVal;
	return S_OK;
}

STDMETHODIMP CUserInfo::get_ZIPCode(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    *pVal = m_bstrZIPCode.Copy();
    return S_OK;
}

STDMETHODIMP CUserInfo::put_ZIPCode(BSTR newVal)
{
    m_bstrZIPCode = newVal;
	return S_OK;
}

STDMETHODIMP CUserInfo::get_PhoneNumber(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    *pVal = m_bstrPhoneNumber.Copy();
	return S_OK;
}

STDMETHODIMP CUserInfo::put_PhoneNumber(BSTR newVal)
{
    m_bstrPhoneNumber = newVal;
	return S_OK;
}


STDMETHODIMP CUserInfo::get_Lcid(long * pVal) //BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

	*pVal = m_lLcid;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\bmp.h ===
/****************************************************************************
 *
 * Bmp.H
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1993
 *  All rights reserved
 *
 *  Deals with painting bitmaps on the wizard pages
 *  FelixA 1994.
 ***************************************************************************/

// BMP functions
BOOL FAR PASCAL BMP_RegisterClass(HINSTANCE hInstance);
void FAR PASCAL BMP_DestroyClass(HINSTANCE hInstance);
void FAR PASCAL BMP_Paint(HWND hwnd);
LRESULT CALLBACK BMP_WndProc( HWND hWnd, UINT wMsg, WORD wParam, LONG lParam );

// Class name
#define SU_BMP_CLASS "ms_setup_bmp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\webgate.h ===
// webgate.h : Declaration of the CWebGate

#ifndef __WEBGATE_H_
#define __WEBGATE_H_

#include <windowsx.h>

// Start with a 16 KB read buffer
#define READ_BUFFER_SIZE    0x4000          

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CWebGate
class ATL_NO_VTABLE CWebGate :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CWebGate,&CLSID_WebGate>,
    public CComControl<CWebGate>,
    public IDispatchImpl<IWebGate, &IID_IWebGate, &LIBID_ICWHELPLib>,
    public IProvideClassInfo2Impl<&CLSID_WebGate, &DIID__WebGateEvents, &LIBID_ICWHELPLib>,
    public IPersistStreamInitImpl<CWebGate>,
    public IOleControlImpl<CWebGate>,
    public IOleObjectImpl<CWebGate>,
    public IOleInPlaceActiveObjectImpl<CWebGate>,
    public IViewObjectExImpl<CWebGate>,
    public IOleInPlaceObjectWindowlessImpl<CWebGate>,
    public CProxy_WebGateEvents<CWebGate>,
    public IConnectionPointContainerImpl<CWebGate>,
    public IObjectSafetyImpl<CWebGate>
{
public:
    CWebGate()
    {
        m_pmk = 0;
        m_pbc = 0;
        m_pbsc = 0;
        m_cbBuffer = 0;
        m_bKeepFile = FALSE;
        
        // setup and allocate a data buffer
        m_cbdata = READ_BUFFER_SIZE;
        m_lpdata = (LPSTR) GlobalAllocPtr(GHND, m_cbdata);
        
        m_hEventComplete = 0;
        
    }
    
    ~CWebGate()
    {

        USES_CONVERSION;
                
        m_bstrFormData.Empty();
        m_bstrBuffer.Empty();
        m_bstrPath.Empty();
        m_bstrCacheFileName.Empty();

        if (m_bstrDumpFileName)
        {
#ifdef UNICODE
            DeleteFile(m_bstrDumpFileName);
#else
            DeleteFile(OLE2A(m_bstrDumpFileName));
#endif
            m_bstrDumpFileName.Empty();
        }

        // Release the binding context callback
        if (m_pbsc && m_pbc)
        {
            RevokeBindStatusCallback(m_pbc, m_pbsc);
            m_pbsc->Release();
            m_pbsc = 0;
        }        
    
        // Release the binding context
        if (m_pbc)
        {
            m_pbc->Release();
            m_pbc = 0;
        }        
    
        // release the monikor
        if (m_pmk)
        {
            m_pmk->Release();
            m_pmk = 0;
        }       
        
        // free the data buffer
        if (m_lpdata)
            GlobalFreePtr(m_lpdata);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_WEBGATE)

BEGIN_COM_MAP(CWebGate) 
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IWebGate)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CWebGate)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()

BEGIN_CONNECTION_POINT_MAP(CWebGate)
    CONNECTION_POINT_ENTRY(DIID__WebGateEvents)
END_CONNECTION_POINT_MAP()


BEGIN_MSG_MAP(CWebGate)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = 0;
        return S_OK;
    }

// IWebGate
public:
    STDMETHOD(get_DownloadFname)(/*out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Buffer)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(FetchPage)(/*[in]*/ DWORD dwKeepFile, /*[in]*/ DWORD dwDoAsync, /*[out, retval]*/ BOOL *pbRetVal);
    STDMETHOD(DumpBufferToFile)(/*[out]*/ BSTR *pFileName, /*[out, retval]*/ BOOL *pbRetVal);
    
    STDMETHOD(put_FormData)(/*[in]*/ BSTR newVal);
    STDMETHOD(put_Path)(/*[in]*/ BSTR newVal);
    HRESULT OnDraw(ATL_DRAWINFO& di);

    // needs to be public, so the bindcallback can access it
    DWORD       m_cbBuffer;
    CComBSTR    m_bstrBuffer;
    CComBSTR    m_bstrCacheFileName;
    CComBSTR    m_bstrDumpFileName;
    BOOL        m_bKeepFile;
    LPSTR       m_lpdata;
    DWORD       m_cbdata;
    HANDLE      m_hEventComplete;
protected:
    CComBSTR m_bstrFormData;
    CComBSTR m_bstrPath;

 private:
   IMoniker*            m_pmk;
   IBindCtx*            m_pbc;
   IBindStatusCallback* m_pbsc;
    
};

#endif //__WEBGATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwhelp\webgate.cpp ===
// webgate.cpp : Implementation of CWebGate
#include "stdafx.h"
#include "icwhelp.h"
#include "webgate.h"
#include "appdefs.h"

#include <wininet.h>

#define MAX_DOWNLOAD_BLOCK 1024

extern BOOL MinimizeRNAWindowEx();

// ===========================================================================
//                     CWebGateBindStatusCallback Definition
//
// This class will be use to indicate download progress
//
// ===========================================================================

class CWebGateBindStatusCallback : public IBindStatusCallback
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef()    { return m_cRef++; }
    STDMETHODIMP_(ULONG)    Release()   { if (--m_cRef == 0) { delete this; return 0; } return m_cRef; }

    // IBindStatusCallback methods
    STDMETHODIMP    OnStartBinding(DWORD dwReserved, IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority);
    STDMETHODIMP    OnLowResource(DWORD dwReserved);
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
                        LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc,
                        STGMEDIUM* pstgmed);
    STDMETHODIMP    OnObjectAvailable(REFIID riid, IUnknown* punk);

    // constructors/destructors
    CWebGateBindStatusCallback(CWebGate * lpWebGate);
    ~CWebGateBindStatusCallback();

    // data members
    BOOL            m_bDoneNotification;
    DWORD           m_cRef;
    IBinding*       m_pbinding;
    IStream*        m_pstm;
    DWORD           m_cbOld;
    
    CWebGate        *m_lpWebGate;

private:    
   void ProcessBuffer(void);
    
};

UINT g_nICWFileCount = 0;


BOOL CALLBACK DisconnectDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
VOID CALLBACK IdleTimerProc (HWND hWnd, UINT uMsg, UINT idEvent, DWORD dwTime);

// ===========================================================================
//                     CBindStatusCallback Implementation
// ===========================================================================

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::CBindStatusCallback
// ---------------------------------------------------------------------------
CWebGateBindStatusCallback::CWebGateBindStatusCallback
(
    CWebGate    *lpWebGate
)
{
    m_pbinding = NULL;
    m_pstm = NULL;
    m_cRef = 1;
    m_cbOld = 0;

    m_lpWebGate = lpWebGate;
}  // CWebGateBindStatusCallback

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::~CWebGateBindStatusCallback
// ---------------------------------------------------------------------------
CWebGateBindStatusCallback::~CWebGateBindStatusCallback()
{
}  // ~CWebGateBindStatusCallback

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::QueryInterface
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGateBindStatusCallback::QueryInterface
(
    REFIID riid, 
    void** ppv
)
{
    *ppv = NULL;

    if (riid==IID_IUnknown || riid==IID_IBindStatusCallback)
    {
        *ppv = this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}  // CWebGateBindStatusCallback::QueryInterface

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::OnStartBinding
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGateBindStatusCallback::OnStartBinding
(
    DWORD dwReserved, 
    IBinding* pbinding
)
{
    if (m_pbinding != NULL)
        m_pbinding->Release();
    m_pbinding = pbinding;
    if (m_pbinding != NULL)
    {
        m_pbinding->AddRef();
    }
    
    return S_OK;
}  // CWebGateBindStatusCallback::OnStartBinding

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::GetPriority
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGateBindStatusCallback::GetPriority
(
    LONG* pnPriority
)
{
    return E_NOTIMPL;
}  // CWebGateBindStatusCallback::GetPriority

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::OnLowResource
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGateBindStatusCallback::OnLowResource
(
    DWORD dwReserved
)
{
    return E_NOTIMPL;
}  // CWebGateBindStatusCallback::OnLowResource

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::OnProgress
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGateBindStatusCallback::OnProgress
(
    ULONG ulProgress, 
    ULONG ulProgressMax, 
    ULONG ulStatusCode, 
    LPCWSTR szStatusText
)
{
    // If no progress, check for valid connection
    if (0 == ulProgress)
        m_lpWebGate->Fire_WebGateDownloadProgress(TRUE);
    return(NOERROR);
}  // CWebGateBindStatusCallback::OnProgress


void CWebGateBindStatusCallback::ProcessBuffer(void)
{
    m_bDoneNotification = TRUE;

    if (m_pstm)
        m_pstm->Release();

    m_lpWebGate->m_cbBuffer = m_cbOld;
    
    // Create a file, and copy the donwloaded content into it   
    if (m_lpWebGate->m_bKeepFile)        
    {       
        TCHAR   szTempFileFullName[MAX_PATH];
        TCHAR   szTempFileName[MAX_PATH];
        HANDLE  hFile; 
        DWORD   cbRet;
    
        // Make sure it is an htm extension, otherwise, IE will promp for download
        GetTempPath(MAX_PATH, szTempFileFullName);
        wsprintf( szTempFileName, TEXT("ICW%x.htm"), g_nICWFileCount++); 
        lstrcat(szTempFileFullName, szTempFileName);
    
        hFile = CreateFile(szTempFileFullName, 
                           GENERIC_WRITE, 
                           0, 
                           NULL, 
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL, 
                           NULL);
        if (hFile)                               
        {
            WriteFile(hFile, m_lpWebGate->m_lpdata, m_cbOld, (LPDWORD)&cbRet, NULL);
            CloseHandle(hFile);
        }
    
        // Copy the created file name into the webgate control
        m_lpWebGate->m_bstrCacheFileName = A2BSTR(szTempFileFullName);
    }

    // If the WebGate object has a complete event, then signal it, otherwise
    // fire an event
    if (m_lpWebGate->m_hEventComplete)
        SetEvent(m_lpWebGate->m_hEventComplete);
    else
    {
        // Notify the caller that we are done
        m_lpWebGate->Fire_WebGateDownloadComplete(TRUE);
    }        
}

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::OnStopBinding
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGateBindStatusCallback::OnStopBinding
(
    HRESULT hrStatus, 
    LPCWSTR pszError
)
{
    if (m_pbinding)
    {
        m_pbinding->Release();
        m_pbinding = NULL;
    }
       
    if (!m_bDoneNotification)
    {
        ProcessBuffer();
    
    }
    m_lpWebGate->Fire_WebGateDownloadProgress(TRUE);

    return S_OK;
}  // CWebGateBindStatusCallback::OnStopBinding

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::GetBindInfo
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGateBindStatusCallback::GetBindInfo
(
    DWORD* pgrfBINDF, 
    BINDINFO* pbindInfo
)
{
    *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | 
                 BINDF_PULLDATA | BINDF_GETNEWESTVERSION | 
                 BINDF_NOWRITECACHE;
    pbindInfo->cbSize = sizeof(BINDINFO);
    pbindInfo->szExtraInfo = NULL;
    memset(&pbindInfo->stgmedData, 0, sizeof(STGMEDIUM));
    pbindInfo->grfBindInfoF = 0;
    pbindInfo->dwBindVerb = BINDVERB_GET;
    pbindInfo->szCustomVerb = NULL;
    return S_OK;
}  // CWebGateBindStatusCallback::GetBindInfo

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::OnDataAvailable
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGateBindStatusCallback::OnDataAvailable
(
    DWORD grfBSCF, 
    DWORD dwSize, 
    FORMATETC* pfmtetc, 
    STGMEDIUM* pstgmed
)
{
    HRESULT hr = E_FAIL; //don't assume success

    // verify we have a read buffer
    if (!m_lpWebGate->m_lpdata)
        return(S_FALSE);
        
    // Get the Stream passed
    if (BSCF_FIRSTDATANOTIFICATION & grfBSCF)
    {
        m_bDoneNotification = FALSE;
        
        if (!m_pstm && pstgmed->tymed == TYMED_ISTREAM)
        {
            m_pstm = pstgmed->pstm;
            if (m_pstm)
                m_pstm->AddRef();
        }
    }

    // If there is some data to be read then go ahead and read them
    if (m_pstm && dwSize)
    {      
        DWORD dwActuallyRead = 0; // Placeholder for amount read during this pull

        do
        {  
           if (MAX_DOWNLOAD_BLOCK + m_cbOld > m_lpWebGate->m_cbdata)
           {
                m_lpWebGate->m_cbdata += READ_BUFFER_SIZE;
                // ::MessageBox(NULL, TEXT("reallov DumpBufferToFile"), TEXT("E R R O R"), MB_OK);
                LPSTR pBuffer = (LPSTR)GlobalReAllocPtr(m_lpWebGate->m_lpdata, m_lpWebGate->m_cbdata , GHND);
                if (pBuffer)
                    m_lpWebGate->m_lpdata  = pBuffer;
                else
                    return S_FALSE;
           }

            // Read what we can 
            hr = m_pstm->Read(m_lpWebGate->m_lpdata+m_cbOld, MAX_DOWNLOAD_BLOCK, &dwActuallyRead);
           
            // keep track of the running total
            m_cbOld += dwActuallyRead;          
           
        } while (hr == E_PENDING || hr != S_FALSE);
    }            

    if (BSCF_LASTDATANOTIFICATION & grfBSCF)
    {
        if (!m_bDoneNotification)
        {
            ProcessBuffer();
        }                    
    }

    return S_OK;
}  // CWebGateBindStatusCallback::OnDataAvailable

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::OnObjectAvailable
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGateBindStatusCallback::OnObjectAvailable
(
    REFIID riid, 
    IUnknown* punk
)
{
    return E_NOTIMPL;
}  // CWebGateBindStatusCallback::OnObjectAvailable

/////////////////////////////////////////////////////////////////////////////
// CWebGate


HRESULT CWebGate::OnDraw(ATL_DRAWINFO& di)
{
    return S_OK;
}

STDMETHODIMP CWebGate::put_Path(BSTR newVal)
{
    // TODO: Add your implementation code here
    USES_CONVERSION;
    m_bstrPath = newVal;
    return S_OK;
}

STDMETHODIMP CWebGate::put_FormData(BSTR newVal)
{
    // TODO: Add your implementation code here
    USES_CONVERSION;
    m_bstrFormData = newVal;
    return S_OK;
}


STDMETHODIMP CWebGate::FetchPage(DWORD dwKeepFile, DWORD dwDoWait, BOOL *pbRetVal)
{
    USES_CONVERSION;

    IStream *pstm = NULL;
    HRESULT hr;
    // Empty the buffer.
    m_bstrBuffer.Empty();
    
    // Clear the cache file name
    m_bstrCacheFileName.Empty();
    
    // Release the binding context callback
    if (m_pbsc && m_pbc)
    {
        RevokeBindStatusCallback(m_pbc, m_pbsc);
        m_pbsc->Release();
        m_pbsc = 0;
    }        
    
    // Release the binding context
    if (m_pbc)
    {
        m_pbc->Release();
        m_pbc = 0;
    }        
    
    // release the monikor
    if (m_pmk)
    {
        m_pmk->Release();
        m_pmk = 0;
    }        
    
    *pbRetVal = FALSE;

    if (dwDoWait)    
        m_hEventComplete = CreateEvent(NULL, TRUE, FALSE, NULL);
        
    m_bKeepFile = (BOOL) dwKeepFile;    
    hr = CreateURLMoniker(NULL, m_bstrPath, &m_pmk);
    if (FAILED(hr))
        goto LErrExit;

    m_pbsc = new CWebGateBindStatusCallback(this);
    if (m_pbsc == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto LErrExit;
    }

    hr = CreateBindCtx(0, &m_pbc);
    if (FAILED(hr))
        goto LErrExit;

    hr = RegisterBindStatusCallback(m_pbc,
            m_pbsc,
            0,
            0L);
    if (FAILED(hr))
        goto LErrExit;

    hr = m_pmk->BindToStorage(m_pbc, 0, IID_IStream, (void**)&pstm);
    if (FAILED(hr))
        goto LErrExit;

    // If we were requested to wait, then we wait for the m_hEventComplete to be
    // signaled
    if (dwDoWait && m_hEventComplete)    
    {
        MSG     msg;
        BOOL    bGotFile = FALSE;
        DWORD   dwRetCode;
        HANDLE  hEventList[1];
        hEventList[0] = m_hEventComplete;
    
        while (TRUE)
        {
                // We will wait on window messages and also the named event.
            dwRetCode = MsgWaitForMultipleObjects(1, 
                                                  &hEventList[0], 
                                                  FALSE, 
                                                  300000,            // 5 minutes
                                                  QS_ALLINPUT);

            // Determine why we came out of MsgWaitForMultipleObjects().  If
            // we timed out then let's do some TrialWatcher work.  Otherwise
            // process the message that woke us up.
            if (WAIT_TIMEOUT == dwRetCode)
            {
                bGotFile = FALSE;
                break;
            }
            else if (WAIT_OBJECT_0 == dwRetCode)
            {
                bGotFile = TRUE;
                break;
            }
            else if (WAIT_OBJECT_0 + 1 == dwRetCode)
            {
                // 0 is returned if no message retrieved.
                if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if (WM_QUIT == msg.message)
                    {
                        bGotFile = FALSE;
                        break;
                    }
                    else
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }
            }
        }
        *pbRetVal = bGotFile;
        CloseHandle(m_hEventComplete);
        m_hEventComplete = 0;
    }
    else
    {
        *pbRetVal = TRUE;
    }        
    return S_OK;

LErrExit:
    if (m_pbc != NULL)
    {
        m_pbc->Release();
        m_pbc = NULL;
    }
    if (m_pbsc != NULL)
    {
        m_pbsc->Release();
        m_pbsc = NULL;
    }
    if (m_pmk != NULL)
    {
        m_pmk->Release();
        m_pmk = NULL;
    }
    if (pstm)
    {
        pstm->Release();
        pstm = NULL;
    }
    
    *pbRetVal = FALSE;
    return S_OK;
    
}


STDMETHODIMP CWebGate::get_Buffer(BSTR * pVal)
{
    if (pVal == NULL)
         return E_POINTER;
    *pVal = m_bstrBuffer.Copy();

    return S_OK;
}

STDMETHODIMP CWebGate::DumpBufferToFile(BSTR *pFileName, BOOL *pbRetVal)
{
    USES_CONVERSION;
    
    TCHAR   szTempFileFullName[MAX_PATH];
    TCHAR   szTempFileName[MAX_PATH];
    DWORD   cbRet;
    HANDLE  hFile; 
    
    if (pFileName == NULL)
        return(E_POINTER);

    // Delete the previous temp file it it exists
    if (m_bstrDumpFileName)
    {
        DeleteFile(OLE2A(m_bstrDumpFileName));
        m_bstrDumpFileName.Empty();
    }
               
    // Make sure it is an htm extension, otherwise, IE will promp for download
    GetTempPath(MAX_PATH, szTempFileFullName);
    wsprintf( szTempFileName, TEXT("ICW%x.htm"), g_nICWFileCount++); 
    lstrcat(szTempFileFullName, szTempFileName);

    hFile = CreateFile(szTempFileFullName, 
                       GENERIC_WRITE, 
                       0, 
                       NULL, 
                       OPEN_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL, 
                       NULL);
    if (hFile)                               
    {
        WriteFile(hFile, m_lpdata, m_cbBuffer, (LPDWORD)&cbRet, NULL);
        CloseHandle(hFile);
    }

    // Copy the created file name into the webgate control
    m_bstrDumpFileName = A2BSTR(szTempFileFullName);
    *pFileName = m_bstrDumpFileName.Copy();
    
    *pbRetVal = TRUE;
    
    MinimizeRNAWindowEx();

    return S_OK;
}

STDMETHODIMP CWebGate::get_DownloadFname(BSTR *pVal)
{
    if (pVal == NULL)
        return(E_POINTER);
    
    *pVal = m_bstrCacheFileName.Copy();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\bmp.c ===
/****************************************************************************
 *
 * Bmp.C
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1993
 *  All rights reserved
 *
 *  Deals with painting bitmaps on the wizard pages
 *  FelixA 1994.
 ***************************************************************************/

#include <windows.h>
#include "bmp.h"

//***************************************************************************
//
// BMP_RegisterClass()
//      Registers the bitmap control class
//
// ENTRY:
//	hInstance
//
// EXIT:
//	NONE currently.
//
//***************************************************************************
BOOL FAR PASCAL BMP_RegisterClass(HINSTANCE hInstance)
{
    WNDCLASS wc;
    
    if (!GetClassInfo(hInstance, SU_BMP_CLASS, &wc)) {
	wc.lpszClassName = SU_BMP_CLASS;
	wc.style	 = 0;
	wc.lpfnWndProc	 = BMP_WndProc;
	wc.hInstance	 = hInstance;
	wc.hIcon	 = NULL;
	wc.hCursor	 = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = NULL;
	wc.lpszMenuName	 = NULL;
	wc.cbClsExtra	 = 0;
	wc.cbWndExtra	 = 5*sizeof(WORD);

	if (!RegisterClass(&wc))
	    return FALSE;
    }
    return TRUE;
}

//***************************************************************************
//
// BMP_DestroyClass()
//      Draws the bitmap control.
//
// ENTRY:
//	hInstance
//
// EXIT:
//	NONE currently.
//
//***************************************************************************
void FAR PASCAL BMP_DestroyClass( HINSTANCE hInst )
{
    WNDCLASS wndClass;
    
    if( GetClassInfo(hInst, SU_BMP_CLASS, &wndClass) )
        if( !FindWindow( SU_BMP_CLASS, NULL ) )
            UnregisterClass(SU_BMP_CLASS, hInst);
}

//***************************************************************************
//
// BMP_Draw()
//      Draws the bitmap control.
//
// ENTRY:
//	NONE
//
// EXIT:
//	NONE currently.
//
//***************************************************************************
void FAR PASCAL BMP_Paint(HWND hwnd)
{
    PAINTSTRUCT ps;
    HDC         hdc, hdcMem;
    int         idBmp;
    HBITMAP     hbm, hbmOld;
    HBRUSH      hbrOld;
    HINSTANCE   hInst;
    int         iDeleteBmp=TRUE;
    BITMAP      bm;
    
    // For independence.
    idBmp = GetDlgCtrlID( hwnd );
    hInst = (HINSTANCE)GetWindowWord( hwnd, GWW_HINSTANCE );

    // Paint.
    hdc = BeginPaint(hwnd,&ps);
    hbm = LoadBitmap(hInst, MAKEINTRESOURCE(idBmp));
    if (hbm)
    {
        GetObject(hbm, sizeof(bm), &bm);
        hdcMem = CreateCompatibleDC(hdc);
        hbmOld = SelectObject(hdcMem, hbm);

        // Draw the bitmap
        BitBlt(hdc, 0, 0, bm.bmWidth , bm.bmHeight, hdcMem, 0, 0, SRCCOPY);

        // Draw a frame around it.
        hbrOld = SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
        Rectangle( hdc, 0, 0, bm.bmWidth, bm.bmHeight );

        SelectObject(hdc, hbrOld);
        SelectObject(hdcMem, hbmOld);
        DeleteObject(hbm);
        DeleteDC(hdcMem);
    }
    EndPaint(hwnd,(LPPAINTSTRUCT)&ps);
}

// ****************************************************************************
//
// BMP_WndProc()
//      This routine handles all the message for the bitmap control.
//
// ENTRY:
//  hWnd    - Progress window handle.
//  wMsg    - Message.
//  wParam  - Message wParam data.
//  lParam  - Message lParam data.
//
// EXIT:
//  Returns depends on message being processed.
//
// NOTES:
//  None.
//
// ***************************************************************************/
LRESULT CALLBACK BMP_WndProc( HWND hWnd, UINT wMsg, WORD wParam, LONG lParam )
{
    switch (wMsg)
    {
//        case WM_NCCREATE:
//            dw = GetWindowLong( hWnd,GWL_STYLE );
//            SetWindowLong( hWnd, GWL_STYLE, dw | WS_BORDER );
//            return TRUE;
        
	case WM_PAINT:
	    BMP_Paint( hWnd );
        return 0L;
    }
    return DefWindowProc( hWnd, wMsg, wParam, lParam );
}

#if 0
// Cached?

//***************************************************************************
//
// zzzBMP_CacheBitmaps()
//      Loads and caches the bitmaps for setup
//
// NOTES:
//      You must free the bitmaps using zzzBMP_FreeBitmaps
//
//***************************************************************************
typedef struct tag_Bitmap
{
    int         iBmp;
    HBITMAP     hBmp;
} BMPCACHE;

static BMPCACHE BmpCache[] = { {IDB_WIZARD_NET, 0},
                               {IDB_WIZARD_SETUP, 0},
                               {0,0} };
                               
VOID FAR PASCAL zzzBMP_CacheBitmaps( )
{
   int i=0;
   while( BmpCache[i].iBmp )
       BmpCache[i++].hBmp = LoadBitmap(hinstExe, MAKEINTRESOURCE(BmpCache[i].iBmp));
}

//***************************************************************************
//
// zzzBMP_FreeBitmapCache()
//      Frees the cache of the bitmaps
//
// NOTES:
//  Uses IDS_MB to actually format this string.
//
//***************************************************************************
VOID FAR PASCAL zzzBMP_FreeBitmapCache( )
{
   int i=0;
   while( BmpCache[i].iBmp )
   {
       if( BmpCache[i].hBmp && DeleteObject(BmpCache[i].hBmp) )
           BmpCache[i].hBmp = 0;
       i++;
   }
}

//***************************************************************************
//
// zzzBMP_LoadCachedBitmaps()
//      Returns the HBMP for the iBitmap you wanted.
//
// NOTES:
//  Uses IDS_MB to actually format this string.
//
//***************************************************************************
HBITMAP FAR PASCAL zzzBMP_LoadCachedBitmaps(int iBitmap)
{
   int i=0;
   while( BmpCache[i].iBmp )
   {
       if( BmpCache[i].iBmp == iBitmap )
           return BmpCache[i].hBmp;
       i++;
   }
   SU_TRAP
   return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\ccsv.cpp ===
// ############################################################################
// INCLUDES
#include "pch.hpp"
#include "ccsv.h"
#include "debug.h"

// ############################################################################
// DEFINES
#define chComma ','
#define chNewline '\n'
#define chReturn '\r'

// ############################################################################
//
// CCSVFile - simple file i/o for CSV files
//
CCSVFile::CCSVFile()
{
    m_hFile = 0;
    m_iLastRead = 0;
    m_pchLast = m_pchBuf = NULL;
}

// ############################################################################
CCSVFile::~CCSVFile()
{
    AssertMsg(!m_hFile,"CCSV file is still open");
}

// ############################################################################
BOOLEAN CCSVFile::Open(LPCTSTR pszFileName)
{
    AssertMsg(!m_hFile, "a file is already open.");
        
    m_hFile = CreateFile((LPCTSTR)pszFileName, 
                            GENERIC_READ, FILE_SHARE_READ, 
                            0, OPEN_EXISTING, 0, 0);
    if (INVALID_HANDLE_VALUE == m_hFile)
    {
        return FALSE;
    }
    m_pchLast = m_pchBuf = NULL;
    return TRUE;
}

// ############################################################################
BOOLEAN CCSVFile::ReadToken(LPTSTR psz, DWORD cbMax)
{
    LPTSTR    pszLast;
    int        ch;

    ch = ChNext();
    if (-1 == ch)
        {
        return FALSE;
        }

    pszLast = psz + (cbMax - 1);
    while (psz < pszLast && chComma != ch && chNewline != ch && -1 != ch)
        {
       *psz++ = (TCHAR)ch;
        ch = ChNext(); //Read in the next character
        }

    *psz++ = '\0';

    return TRUE;
}

// ############################################################################
void CCSVFile::Close(void)
{
    if (m_hFile)
        CloseHandle(m_hFile);
#ifdef DEBUG
    if (!m_hFile) TraceMsg(TF_GENERAL, "CCSVFile::Close was called, but m_hFile was already 0\n");
#endif
    m_hFile = 0;
}

// ############################################################################
BOOL CCSVFile::FReadInBuffer(void)
{
    //Read another buffer
#ifdef WIN16
    if ((m_cchAvail = _read(m_hFile, m_rgchBuf, CCSVFILE_BUFFER_SIZE)) <= 0)
        return FALSE;
#else
    if (!ReadFile(m_hFile, m_rgchBuf, CCSVFILE_BUFFER_SIZE, &m_cchAvail, NULL) || !m_cchAvail)
        {
        return FALSE;     //nothing more to read
        }
#endif

    m_pchBuf = m_rgchBuf;
    m_pchLast = m_pchBuf + m_cchAvail;
    
    return TRUE; //success
}

// ############################################################################
inline int CCSVFile::ChNext(void)
{

LNextChar:
    if (m_pchBuf >= m_pchLast && !FReadInBuffer())  //implies that we finished reading the buffer. Read in some more.
        return -1;     //nothing more to read

    m_iLastRead = *m_pchBuf++;
    if (chReturn == m_iLastRead)
        goto LNextChar;        //faster to NOT make extra function call

    return m_iLastRead;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\icwsupport.h ===
//#--------------------------------------------------------------
//        
//  File:       icwsupport.h
//        
//  Synopsis:   holds the function declaration, etc 
//              for the support.cpp file
//
//  History:     5/8/97    MKarki Created
//
//    Copyright (C) 1996-97 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------

#ifndef _SUPPORT_H_
#define _SUPPORT_H_

#include "ccsv.h"
//
// size of Phone Number string
//
const DWORD PHONE_NUM_SIZE = 64;

//
// SUPPORTNUM struct declaration
//
typedef struct _SUPPORTNUM
{
    DWORD   dwCountryCode;
    CHAR    szPhoneNumber[PHONE_NUM_SIZE +4];
}
SUPPORTNUM, *PSUPPORTNUM;

//
// function gets the support phone number from the SUPPORT.ICW 
// file
//
HRESULT
GetSupportNumsFromFile (
    PSUPPORTNUM   pSupportNumList,
    PDWORD        pdwSize 
    );

//
// processes one line at a time from the file
//
HRESULT
ReadOneLine (
    PSUPPORTNUM pPhbk,
    CCSVFile *pcCSVFile
    );

#endif //_SUPPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\ccsv.h ===
#ifndef _CCSV
#define _CCSV

#include <windows.h>
#ifdef WIN16
#include <win16def.h>
#endif
#define CCSVFILE_BUFFER_SIZE 2*512

// simple file i/o for phone books
class CCSVFile 
{
	
	public: 
		void far * operator new( size_t cb ) { return GlobalAlloc(GPTR,cb); };
		void operator delete( void far * p ) {GlobalFree(p); };

		CCSVFile();
		~CCSVFile();
		BOOLEAN Open(LPCTSTR pszFileName);
		BOOLEAN ReadToken(LPTSTR pszDest, DWORD cbMax);	// reads up to comma or newline, returns fFalse on EOF
		void Close(void);
		inline int ILastRead(void)
			{
			return m_iLastRead;
			}

	private:
		BOOL 	FReadInBuffer(void);
		inline int 	ChNext(void);
		CHAR 	m_rgchBuf[CCSVFILE_BUFFER_SIZE]; //buffer
		LPSTR 	m_pchBuf;			//pointer to the next item in the buffer to read
		LPSTR	m_pchLast;			//pointer to the last item in the buffer
		int  	m_iLastRead;		//the character last read.
		DWORD 	m_cchAvail;
		HANDLE 	m_hFile;

}; // ccsv
#endif //_CCSV
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\pch.h ===
#if defined(WIN16)
#define WINVER 0x30a
#endif

#include <windows.h>

#if defined(WIN16)
#define WCHAR	WORD
#include <stdio.h>
#include <memory.h>
#include <ctype.h>
#endif

#include <tapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\misc.cpp ===
// ############################################################################
// Miscellaneous support routines
#include "pch.hpp"
#ifdef WIN16
#include <win16def.h>
#endif
#include "phbk.h"

#define irgMaxSzs 5
TCHAR szStrTable[irgMaxSzs][256];

// ############################################################################
LPTSTR GetSz(WORD wszID)
{
    static int iSzTable=0;
    LPTSTR psz = (LPTSTR)&szStrTable[iSzTable][0];
    
    iSzTable++;
    if (iSzTable >= irgMaxSzs)
        iSzTable = 0;
        
    if (!LoadString(g_hInstDll, wszID, psz, 256))
    {
        TraceMsg(TF_GENERAL,"LoadString failed %d\n", (DWORD) wszID);
        *psz = 0;
    }
        
    return (psz);
}

// ############################################################################
void SzCanonicalFromAE (LPTSTR psz, PACCESSENTRY pAE, LPLINECOUNTRYENTRY pLCE)
{
    if (NO_AREA_CODE == pAE->dwAreaCode)
    {
        wsprintf(psz, TEXT("+%ld %s"), pLCE->dwCountryCode, pAE->szAccessNumber);
    }
    else
    {
        wsprintf(psz, TEXT("+%ld (%s) %s"), pLCE->dwCountryCode, pAE->szAreaCode, pAE->szAccessNumber);
    }
    
    return;
}

// ############################################################################
int MyStrcmp(LPVOID pv1, LPVOID pv2)
{
    LPTSTR pc1 = (LPTSTR) pv1;
    LPTSTR pc2 = (LPTSTR) pv2;
    int iRC = 0;
    // loop while not pointed at the ending NULL character and no difference has been found
    while (*pc1 && *pc2 && !iRC)
    {
        iRC = (int)(*pc1 - *pc2);
        pc1++;
        pc2++;
    }

    // if we exited because we got to the end of one string before we found a difference
    // return -1 if pv1 is longer, else return the character pointed at by pv2.  If pv2
    // is longer than pv1 then the value at pv2 will be greater than 0.  If both strings
    // ended at the same time, then pv2 will point to 0.
    if (!iRC)
    {
        iRC = (*pc1) ? -1 : (*pc2);
    }
    return iRC;
}
// ############################################################################
int __cdecl Compare950Entry(const void*pv1, const void*pv2)
{
    return (((NPABLOCK *) pv1)->wAreaCode - ((NPABLOCK *) pv2)->wAreaCode);
}

// ############################################################################
int __cdecl CompareIDLookUpElements(const void *e1, const void *e2)
{
    if (((LPIDLOOKUPELEMENT)e1)->dwID > ((LPIDLOOKUPELEMENT)e2)->dwID)
        return 1;
    if (((LPIDLOOKUPELEMENT)e1)->dwID < ((LPIDLOOKUPELEMENT)e2)->dwID)
        return -1;
    return 0;
}

// ############################################################################
int __cdecl CompareCntryNameLookUpElements(const void *e1, const void *e2)
{
    LPCNTRYNAMELOOKUPELEMENT pCUE1 = (LPCNTRYNAMELOOKUPELEMENT)e1;
    LPCNTRYNAMELOOKUPELEMENT pCUE2 = (LPCNTRYNAMELOOKUPELEMENT)e2;

#ifdef WIN16
    return lstrcmpi(pCUE1->psCountryName, pCUE2->psCountryName);
#else        
    return CompareString(LOCALE_USER_DEFAULT,0,pCUE1->psCountryName,
        pCUE1->dwNameSize,pCUE2->psCountryName,
        pCUE2->dwNameSize) - 2;
//    return CompareString(LOCALE_USER_DEFAULT,0,((LPCNTRYNAMELOOKUPELEMENT)*e1)->psCountryName,
//        ((LPCNTRYNAMELOOKUPELEMENT)*e1)->dwNameSize,((LPCNTRYNAMELOOKUPELEMENT)*e2)->psCountryName,
//        ((LPCNTRYNAMELOOKUPELEMENT)*e2)->dwNameSize) - 2;
#endif
}

// ############################################################################
int __cdecl CompareIdxLookUpElements(const void *e1, const void *e2)
{
    if (((LPIDXLOOKUPELEMENT)e1)->dwIndex > ((LPIDXLOOKUPELEMENT)e2)->dwIndex)
        return 1;
    if (((LPIDXLOOKUPELEMENT)e1)->dwIndex < ((LPIDXLOOKUPELEMENT)e2)->dwIndex)
        return -1;
    return 0;
}

// ############################################################################
int __cdecl CompareIdxLookUpElementsFileOrder(const void *pv1, const void *pv2)
{
    PACCESSENTRY pae1, pae2;
    int iSort;

    pae1 = ((LPIDXLOOKUPELEMENT)pv1)->pAE;
    pae2 = ((LPIDXLOOKUPELEMENT)pv2)->pAE;

    // sort empty enteries to the end of the list
    if (!(pae1 && pae2))
    {
        return (pae1 ? -1 : (pae2 ? 1 : 0));
    }

    // country ASC, state ASC, city ASC, toll free DESC, flip DESC, con spd max DESC
    if (pae1->dwCountryID != pae2->dwCountryID)
    {
        return (int)(pae1->dwCountryID - pae2->dwCountryID);
    }
    
    if (pae1->wStateID != pae2->wStateID)
    {
        return (pae1->wStateID - pae2->wStateID);
    }

    iSort  = MyStrcmp((LPVOID)pae1->szCity, (LPVOID)pae2->szCity);
    if (iSort)
    {
        return (iSort);
    }

    if (pae1->fType != pae2->fType)
    {
        return ((int) (pae2->fType - pae1->fType));
    }

    if (pae1->bFlipFactor != pae2->bFlipFactor)
    {
        return (pae2->bFlipFactor - pae1->bFlipFactor);
    }

    if (pae1->dwConnectSpeedMax != pae2->dwConnectSpeedMax)
    {
        return (int)(pae2->dwConnectSpeedMax - pae1->dwConnectSpeedMax);
    }

    return 0;
}

// ############################################################################
//inline BOOL FSz2Dw(PCSTR pSz,DWORD *dw)
BOOL FSz2Dw(LPCTSTR pSz,DWORD far *dw)
{
    DWORD val = 0;
    while (*pSz)
    {
        if (*pSz >= '0' && *pSz <= '9')
        {
            val *= 10;
            val += *pSz++ - '0';
        }
        else
        {
            return FALSE;  //bad number
        }
    }
    *dw = val;
    return (TRUE);
}

// ############################################################################
//inline BOOL FSz2W(PCSTR pSz,WORD *w)
BOOL FSz2W(LPCTSTR pSz,WORD far *w)
{
    DWORD dw;
    if (FSz2Dw(pSz,&dw))
    {
        *w = (WORD)dw;
        return TRUE;
    }
    return FALSE;
}

// ############################################################################
//inline BOOL FSz2B(PCSTR pSz,BYTE *pb)
BOOL FSz2B(LPCTSTR pSz,BYTE far *pb)
{
    DWORD dw;
    if (FSz2Dw(pSz,&dw))
    {
        *pb = (BYTE)dw;
        return TRUE;
    }
    return FALSE;
}

// ############################################################################
HRESULT ReleaseBold(HWND hwnd)
{
    HFONT hfont = NULL;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (hfont) DeleteObject(hfont);
    return ERROR_SUCCESS;
}

// ############################################################################
HRESULT MakeBold (HWND hwnd)
{
    HRESULT hr = ERROR_SUCCESS;
    HFONT hfont = NULL;
    HFONT hnewfont = NULL;
    LOGFONT far * plogfont = NULL;

    if (!hwnd) goto MakeBoldExit;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (!hfont)
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }
    
    plogfont = (LOGFONT far *)GlobalAlloc(GPTR,sizeof(LOGFONT));
    if (!plogfont)
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    if (!GetObject(hfont,sizeof(LOGFONT),(LPVOID)plogfont))
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    if (plogfont->lfHeight < 24)
    {
        plogfont->lfHeight = plogfont->lfHeight + (plogfont->lfHeight / 4);
    }

    plogfont->lfWeight = FW_BOLD;

    if (!(hnewfont = CreateFontIndirect(plogfont)))
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    SendMessage(hwnd,WM_SETFONT,(WPARAM)hnewfont,MAKELPARAM(FALSE,0));

    GlobalFree(plogfont);
    plogfont = NULL;
    
MakeBoldExit:
    //if (hfont) DeleteObject(hfont);
    // BUG:? Do I need to delete hnewfont at some time?
    return hr;
}

#if !defined(WIN16)
//+----------------------------------------------------------------------------
//
//    Function:    DWGetWin32Platform
//
//    Synopsis:    Return a value to determine win32 platform
//
//    Arguements:    None
//
//    Returns:    platform enumeration (see GetVersionEx for details)
//
//    History:    8/8/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
DWORD DWGetWin32Platform()
{
    OSVERSIONINFO osver;
    ZeroMemory(&osver,sizeof(osver));
    osver.dwOSVersionInfoSize = sizeof(osver);
    if (GetVersionEx(&osver))
        return osver.dwPlatformId;
    AssertMsg(0,"GetVersionEx failed.\r\n");
    return 0;
}

//+----------------------------------------------------------------------------
//
//    Function:    DWGetWin32BuildNumber
//
//    Synopsis:    Return a value to determine win32 build
//
//    Arguements:    None
//
//    Returns:    build number
//
//    History:    9/26/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
DWORD DWGetWin32BuildNumber()
{
    OSVERSIONINFO osver;
    ZeroMemory(&osver,sizeof(osver));
    osver.dwOSVersionInfoSize = sizeof(osver);
    if (GetVersionEx(&osver))
        // dwBuildNumber
        // Identifies the build number of the operating system in the low-order
        // word. (The high-order word contains the major and minor version numbers.)
        return (osver.dwBuildNumber & 0xFFFF);
    AssertMsg(0,"GetVersionEx failed.\r\n");
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\misc.h ===
// ############################################################################
// PROTOTYPES
LPTSTR GetSz(WORD wszID);
void SzCanonicalFromAE (LPTSTR psz, PACCESSENTRY pAE, LPLINECOUNTRYENTRY pLCE);
int __cdecl CompareIDLookUpElements(const void *e1, const void *e2);
int __cdecl CompareCntryNameLookUpElements(const void*e1, const void*e2);
int __cdecl CompareIdxLookUpElements(const void*e1, const void*e2);
int __cdecl CompareIdxLookUpElementsFileOrder(const void *pv1, const void *pv2);
int __cdecl Compare950Entry(const void*e1, const void*e2);
BOOL FSz2Dw(LPCTSTR pSz,DWORD far *dw);
BOOL FSz2W(LPCTSTR pSz,WORD far *w);
BOOL FSz2B(LPCTSTR pSz,BYTE far *pb);
HRESULT MakeBold (HWND hwnd);
HRESULT ReleaseBold(HWND hwnd);
#if !defined(WIN16)
DWORD DWGetWin32Platform();
DWORD DWGetWin32BuildNumber();
#endif
/*
inline BOOL FSz2Dw(PCSTR pSz,DWORD *dw);
inline BOOL FSz2W(PCSTR pSz,WORD *w);
inline BOOL FSz2B(PCSTR pSz,BYTE *pb);
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\icwsupport.cpp ===
//#--------------------------------------------------------------
//        
//  File:       icwsupport.cpp
//        
//  Synopsis:   holds the function which gets the list of
//              support phone numbers for ICW 
//
//  History:     5/8/97    MKarki Created
//
//    Copyright (C) 1996-97 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "pch.hpp"  
#include <windows.h>
#ifdef WIN16
#include <win16def.h>
#include <win32fn.h>
#include <rasc.h>
#include <raserr.h>
#include <ietapi.h>
extern "C" {
#include "bmp.h"
}
#endif

#include "phbk.h"
#include "misc.h"
#include "phbkrc.h"
#include "suapi.h"
#include "icwsupport.h"



#include "ccsv.h"

const TCHAR SUPPORT_FILE[] = TEXT("support.icw");
const DWORD ALLOCATION_SIZE = 256;

//++--------------------------------------------------------------
//
//  Function:   GetSupportNumsFromFile
//
//  Synopsis:   This is the function used to get the support
//              numbers
//
//  Returns:    HRESULT - success or error info
//
//  Called By:  by the GetSupportNumbers API
//
//  History:    MKarki      Created     5/8/97
//
//----------------------------------------------------------------
HRESULT
GetSupportNumsFromFile (
    PSUPPORTNUM   pSupportNumList,
    PDWORD        pdwSize 
    )
{
    BOOL        bReturnMemNeeded = FALSE;
    LPTSTR      pszTemp = NULL;
    TCHAR       szFilePath[MAX_PATH];
    BOOL        bStatus = FALSE;
    CCSVFile    *pcCSVFile = NULL;
    DWORD       dwMemNeeded = 0;
    HRESULT     hRetVal = ERROR_SUCCESS;
    DWORD       dwCurrentIndex = 0;
    DWORD       dwIndexAllocated = 0;
    const DWORD INFOSIZE = sizeof (SUPPORTNUM);
    PSUPPORTNUM pPhbkArray = NULL;
    PSUPPORTNUM pTemp = NULL;

        TraceMsg(TF_GENERAL, "Entering GetSupportNumsFromFile function\r\n");


        //
        // atleast a place where the size can be returned
        //  should be provided
        //
        if (NULL == pdwSize)
        {

           TraceMsg (TF_GENERAL, "pdwSize == NULL\r\n");
           hRetVal = ERROR_INVALID_PARAMETER;
           goto Cleanup;
        }
 
        //
        //  check if the user has provided the buffers
        //
        if (NULL == pSupportNumList)
        {
            TraceMsg (TF_GENERAL, "User justs wants the buffer size\r\n");
            bReturnMemNeeded = TRUE;
        }

        //
        //  get the full path of the support.icw file
        //
        bStatus = SearchPath (
                        NULL, 
                        (PTCHAR)SUPPORT_FILE, 
                        NULL, 
                        MAX_PATH, 
                        (PTCHAR)&szFilePath,
                        (PTCHAR*)&pszTemp    
                        );
        if (FALSE == bStatus)
        {
            TraceMsg (TF_GENERAL,
                "Failed on SearchPath API call with error:%d\r\n",
                GetLastError ()
                );
            hRetVal = ERROR_FILE_NOT_FOUND;
            goto Cleanup;
        }

        //
        // now we can start processing the file
        //
        pcCSVFile = new CCSVFile;
        if (NULL == pcCSVFile)
        {
            TraceMsg (TF_GENERAL, "Could not allocate mem for CCSVFile\r\n");
            hRetVal = ERROR_OUTOFMEMORY;
           goto Cleanup;
        }

   
        //
        // open the file here
        //
        bStatus = pcCSVFile->Open (szFilePath);
        if (FALSE == bStatus)
        {
            TraceMsg (TF_GENERAL, "Filed on  CCSVFile :: Open call\r\n");
            hRetVal = GetLastError (); 
            goto Cleanup;
        }

       //
       // now we are ready to get the phone number out of the
       // file
       //
       dwCurrentIndex = 0;
       dwIndexAllocated = 0;

       do  
       {
            
            //
            // check if we ned to allocate memory
            //
            if (dwIndexAllocated == dwCurrentIndex)
            {
            
                //
                //  need to allocate memory
                //
                pTemp = (PSUPPORTNUM) GlobalAlloc (
                                    GPTR,
                                    (int)((dwIndexAllocated + ALLOCATION_SIZE)*INFOSIZE)
                                    );
                if (NULL == pTemp)
                {
                    TraceMsg (TF_GENERAL,
                        "Failed on GlobalAlloc API call with error:%d\r\n",
                        GetLastError ()
                        );
                    hRetVal = ERROR_OUTOFMEMORY;
                    goto Cleanup;
                }

                //
                //  now copy over already allocated memory to this buffer
                //
                if (NULL != pPhbkArray) 
                {
                    CopyMemory (
                        pTemp, 
                        pPhbkArray, 
                        (int)(dwIndexAllocated)*INFOSIZE
                        );
    
                    //
                    // free the earlier memory
                    //
                    GlobalFree(pPhbkArray);
                }
            
                pPhbkArray = pTemp;
                dwIndexAllocated += ALLOCATION_SIZE;
            }

            //
            // get the phone number info
            //
            hRetVal = ReadOneLine (&pPhbkArray[dwCurrentIndex], pcCSVFile);
            if (ERROR_NO_MORE_ITEMS == hRetVal)
            {
                TraceMsg (TF_GENERAL, "we have read all the items from the file\r\n");
                break;
            }
            else if (ERROR_SUCCESS != hRetVal)
            {
                goto Cleanup;
            }

            dwCurrentIndex++;
        }
        while (TRUE);


        //
        // get the memory needed  by the user
        //
         dwMemNeeded = (DWORD)(dwCurrentIndex)*INFOSIZE;
    
        //
        // check if the user wants the info, or just the size
        //
        if (FALSE == bReturnMemNeeded) 
        {
            if (*pdwSize >= dwMemNeeded) 
            {
                //
                // user wants us to copy over stuff to the memory 
                // and there is enough space in user buffers.
                //
                CopyMemory (
                    pSupportNumList,
                    pPhbkArray,
                    (int)dwMemNeeded
                    );
            }
            else
            {
                TraceMsg (TF_GENERAL, "Caller did not allocate enough memory\r\n");
                hRetVal = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
                
        }

    
        //
        //  if we reached here, then successfully got the info
        //
        hRetVal = ERROR_SUCCESS;
    

Cleanup:
        //
        // copy the memory used/required to the user size param
        //
        *pdwSize = dwMemNeeded; 
     
        if (NULL != pPhbkArray) 
            GlobalFree (pPhbkArray);

        if (NULL != pcCSVFile)
        {
            pcCSVFile->Close (); 
            delete pcCSVFile;
        }
         

        TraceMsg (TF_GENERAL, "Leaving GetSupportNumsFromFile function call\r\n");

        return (hRetVal);

}   //  end of  GetSupportNumsFromFile function

//++--------------------------------------------------------------
//
//  Function:   ReadOneLine
//
//  Synopsis:   This is the function used to put the info
//              into the buffer, line by line
//
//  Returns:    HRESULT - success or error info
//
//  Called By:  GetSupportNumsFromFile  function
//
//  History:    MKarki      Created     5/8/97
//
//----------------------------------------------------------------
HRESULT
ReadOneLine (
    PSUPPORTNUM pPhbk,
    CCSVFile    *pcCSVFile
    )
{
    TCHAR       szTempBuffer[PHONE_NUM_SIZE + 4];
    HRESULT     hResult = ERROR_SUCCESS; 
    BOOL        bRetVal = FALSE;

        if ((NULL == pcCSVFile) || (NULL == pPhbk))
        {
            TraceMsg (TF_GENERAL, "ReadOneLine: Did not correctly pass args\r\n");
            hResult = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        //  get the country code first
        //
        bRetVal = pcCSVFile->ReadToken (szTempBuffer, PHONE_NUM_SIZE);
        if (FALSE == bRetVal)
        {
            hResult = ERROR_NO_MORE_ITEMS;
            goto Cleanup;
        }

        //
        // Convert the string obtained into a number
        //
        bRetVal = FSz2Dw (szTempBuffer, (PDWORD)&pPhbk->dwCountryCode); 
        if (FALSE == bRetVal)
        {
            hResult = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // now get the phone number
        //
        bRetVal = pcCSVFile->ReadToken (szTempBuffer, PHONE_NUM_SIZE);
        if (FALSE == bRetVal)
        {
            hResult = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // copy this string into  our struct
        //
        CopyMemory (
                pPhbk->szPhoneNumber,
                szTempBuffer,
                (int)PHONE_NUM_SIZE
                );
        
        //
        // if we have reached here then success
        //
        hResult = ERROR_SUCCESS;

Cleanup:

    return (hResult);

}   //  end of ReadOneLine function
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\pch.hpp ===
#if defined(WIN16)
#define WINVER 0x30a
#endif

#include <windows.h>

#if defined(WIN16)
#define WCHAR	WORD
#include <stdio.h>
#include <memory.h>
#include <ctype.h>
#endif

#if !defined(WIN16)
#define TAPI_CURRENT_VERSION 0x00010004
#endif //!WIN16
#include <tapi.h>

#ifdef WIN16
#include <rasc.h>
#else
#include <ras.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\main.cpp ===
// ############################################################################
#include "pch.hpp"
#ifdef WIN16
#include <win16def.h>
#include <malloc.h>
#include <string.h>
#endif

extern "C" {
HINSTANCE g_hInstDll;	// instance for this DLL  
}


#ifdef WIN16

int CALLBACK LibMain(HINSTANCE hinst, 
						WORD wDataSeg, 
						WORD cbHeap,
						LPSTR lpszCmdLine )
{
	g_hInstDll = hinst;

	return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   PrivateMalloc()
//
//  Synopsis:   Allocate and initialize memory
//
//  Arguments:  [size	- Size of memory block to be allocated]
//
//	Returns:	pointer to memory block if successful
//				NULL otherwise
//
//  History:    7/9/96     VetriV    Created
//
//----------------------------------------------------------------------------
void far *PrivateMalloc(size_t size)
{
	void far * ReturnValue = NULL;
	
	ReturnValue = malloc(size);
	if (NULL != ReturnValue)
		memset(ReturnValue, 0, size);
		
	return ReturnValue;
}

//+---------------------------------------------------------------------------
//
//  Function:   PrivateReAlloc()
//
//  Synopsis:   Reallocate memory
//
//  Arguments:  [lpBlock 	- Block to be reallocated ]
//				[size		- Size of memory block to be allocated]
//
//	Returns:	pointer to memory block if successful
//				NULL otherwise
//
//  History:    7/25/96     ValdonB    Created
//
//----------------------------------------------------------------------------
void far *PrivateReAlloc(void far *lpBlock, size_t size)
{
	void far *lpRetBlock;
	
	lpRetBlock = PrivateMalloc(size);
	if (NULL == lpRetBlock)
		return NULL;
	
	if (NULL != lpBlock)
	{
		size_t OldBlockSize, MoveSize;
		
		OldBlockSize = _msize(lpBlock);
		MoveSize = min(OldBlockSize, size);
		memmove(lpRetBlock, lpBlock, MoveSize);  
		PrivateFree(lpBlock);
	}
	
	return lpRetBlock;
}


//+---------------------------------------------------------------------------
//
//  Function:   PrivateFree
//
//  Synopsis:   Free a block of memory
//
//  Arguments:  [lpBlock - Block to be freed]
//
//	Returns:	Nothing
//
//  History:    7/9/96     VetriV    Created
//
//----------------------------------------------------------------------------
void PrivateFree(void far *lpBlock)
{
	free(lpBlock);
}


//+---------------------------------------------------------------------------
//
//  Function:   SearchPath()
//
//  Synopsis:   Searchs for the specified file in the given path
//
//  Arguments:  [lpPath			- Address of search path]
//				[lpFileName		- Address of filename]
//				[lpExtension	- Address of Extension]
//				[nBufferLength	- size, in characters, of buffer]
//				[lpBuffer		- address of buffer for found filename]
//				[lpFilePart		- address of pointer to file component]
//
//	Returns:	Length of string copied to buffer (not including terminating
//					NULL character) if successful
//				0 otherwise
//
//  History:    7/9/96     VetriV    Created
//
//----------------------------------------------------------------------------
DWORD SearchPath(LPCTSTR lpPath,LPCTSTR lpFileName, LPCTSTR lpExtension,
					DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR *lpFilePart)
{ 
	
	BOOL bUseExtension = FALSE, bPathContainsFileName = FALSE;
	DWORD dwRequiredLength;
	LPSTR lpszPath = lpPath;
	char szFileName[MAX_PATH+1];
	OFSTRUCT OpenBuf;
		
	
	
	// Check if extension should be used
	//
	if ((NULL != lpExtension) && !strchr(lpFileName, '.'))
		bUseExtension = TRUE;

	//
	// Form Filename
	//
	lstrcpy(szFileName, lpFileName);
	if (bUseExtension)
		lstrcat(szFileName, lpExtension);
	
	
	//
	// If search path is NULL, then try to OpenFile using OF_SEARCH flag
	// get the full path in OpenBuf struct
	//
	if (NULL == lpszPath)
	{
		
		if (HFILE_ERROR != OpenFile(szFileName, &OpenBuf, OF_EXIST | OF_SEARCH))
		{ 
			//
			// This path contains the file name also
			//
			lpszPath = &OpenBuf.szPathName[0];
			bPathContainsFileName = TRUE;
		}
		else
			return 0;
	}
			
	//
	// Check if output buffer length is sufficient
	//
	dwRequiredLength = lstrlen(lpszPath) + 
						(bPathContainsFileName ? 0 :lstrlen(szFileName)) + 1;
	if (nBufferLength < dwRequiredLength)
		return 0;

	//
	// Copy the full name to buffer
	//
	if (bPathContainsFileName)
		lstrcpy(lpBuffer, lpszPath);
	else
		wsprintf(lpBuffer, "%s\\%s", lpszPath, szFileName);

	
	//
	// Do not include the terminating null character in return length
	//
	return dwRequiredLength - 1;
}


#else // WIN16

extern "C" BOOL WINAPI PHBKDllEntryPoint(
    HINSTANCE  hinstDLL,	// handle to DLL module 
    DWORD  fdwReason,		// reason for calling function 
    LPVOID  lpvReserved 	// reserved 
   )
{
	if (fdwReason == DLL_PROCESS_ATTACH)
		g_hInstDll = hinstDLL;
    
	return TRUE;
}

#endif // WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\phbk.cpp ===
// ############################################################################
// Phone book APIs
#include "pch.hpp"  
#ifdef WIN16
#include <win16def.h>
#include <win32fn.h>
#include <rasc.h>
#include <raserr.h>
#include <ietapi.h>
extern "C" {
#include "bmp.h"
}
#endif

#include "phbk.h"
#include "misc.h"
#include "phbkrc.h"
#include "suapi.h"

//#define ReadVerifyPhoneBookDW(x)    AssertMsg(ReadPhoneBookDW(&(x),pcCSVFile),"Invalid DWORD in phone book");
#define ReadVerifyPhoneBookDW(x)    if (!ReadPhoneBookDW(&(x),pcCSVFile))                \
                                        {    AssertMsg(0,"Invalid DWORD in phone book");    \
                                            goto ReadError; }
#define ReadVerifyPhoneBookW(x)        if (!ReadPhoneBookW(&(x),pcCSVFile))                \
                                        {    AssertMsg(0,"Invalid DWORD in phone book");    \
                                            goto ReadError; }
#define ReadVerifyPhoneBookB(x)        if (!ReadPhoneBookB(&(x),pcCSVFile))                \
                                        {    AssertMsg(0,"Invalid DWORD in phone book");    \
                                            goto ReadError; }
#define ReadVerifyPhoneBookSZ(x,y)    if (!ReadPhoneBookSZ(&x[0],y+sizeof('\0'),pcCSVFile))    \
                                        {    AssertMsg(0,"Invalid DWORD in phone book");        \
                                            goto ReadError; }

#define CHANGE_BUFFER_SIZE 50

#define TEMP_PHONE_BOOK_PREFIX TEXT("PBH")

#define ERROR_USERBACK 32766
#define ERROR_USERCANCEL 32767

TCHAR szTempBuffer[TEMP_BUFFER_LENGTH];
TCHAR szTempFileName[MAX_PATH];

#ifdef __cplusplus
extern "C" {
#endif
HWND g_hWndMain;
#ifdef __cplusplus
}
#endif

#if !defined(WIN16)
//+----------------------------------------------------------------------------
//
//    Function    IsMSDUN12Installed
//
//    Synopsis    Check if MSDUN 1.2 or higher is installed
//
//    Arguments    none
//
//    Returns        TRUE - MSDUN 1.2 is installed
//
//    History        5/28/97 ChrisK created for Olympus Bug 4392
//                8/7/97    ChrisK lifted from isign32
//
//-----------------------------------------------------------------------------
#define DUN_12_Version ((double)1.2)
BOOL IsMSDUN12Installed()
{
    TCHAR szBuffer[MAX_PATH] = {TEXT("\0")};
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = sizeof(szBuffer);
    FLOAT flVersion = 0e0f;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Services\\RemoteAccess"),
        &hkey))
    {
        goto IsMSDUN12InstalledExit;
    }

    if (ERROR_SUCCESS != RegQueryValueEx(hkey,
        TEXT("Version"),
        NULL,
        &dwType,
        (LPBYTE)szBuffer,
        &dwSize))
    {
        goto IsMSDUN12InstalledExit;
    }

#ifdef UNICODE
    CHAR  szTmp[MAX_PATH];
    wcstombs(szTmp, szBuffer, MAX_PATH);
    szTmp[MAX_PATH - 1] = '\0';
    bRC = DUN_12_Version <= atof(szTmp);
#else
    bRC = DUN_12_Version <= atof(szBuffer);
#endif
IsMSDUN12InstalledExit:
    if (hkey != NULL)
    {
        RegCloseKey(hkey);
        hkey = NULL;
    }
    return bRC;
}
#endif 

// ############################################################################
CPhoneBook::CPhoneBook()
{
    HINSTANCE hInst = NULL;
    LONG lrc;
#if !defined(WIN16)
    HKEY hkey;
#endif
    DWORD dwType;
    DWORD dwSize;
    TCHAR  szData[MAX_PATH+1];

    m_rgPhoneBookEntry = NULL;
    m_hPhoneBookEntry = NULL;
    m_cPhoneBookEntries =0;
    m_rgLineCountryEntry=NULL;
    m_rgState=NULL;
    m_cStates=0;
    m_rgIDLookUp = NULL;
    m_rgNameLookUp = NULL;
    m_pLineCountryList = NULL;

    ZeroMemory(&m_szINFFile[0],MAX_PATH);
    ZeroMemory(&m_szINFCode[0],MAX_INFCODE);
    ZeroMemory(&m_szPhoneBook[0],MAX_PATH);

#if !defined(WIN16)
    if (VER_PLATFORM_WIN32_NT == DWGetWin32Platform())
    {
        m_bScriptingAvailable = TRUE;
    }
    else if (IsMSDUN12Installed())
    {
        //
        // ChrisK 8/7/97 Olympus1 11814
        // Display scripted phone numbers on system with DUN 1.2 installed
        //
        m_bScriptingAvailable = TRUE;
    }
    else
    {
        //
        // Verify scripting by checking for smmscrpt.dll in RemoteAccess registry key
        //
        if (1111 <= DWGetWin32BuildNumber())
        {
            m_bScriptingAvailable = TRUE;
        }
        else
        {
            m_bScriptingAvailable = FALSE;
            hkey = NULL;
            lrc=RegOpenKey(HKEY_LOCAL_MACHINE,TEXT("System\\CurrentControlSet\\Services\\RemoteAccess\\Authentication\\SMM_FILES\\PPP"),&hkey);
            if (ERROR_SUCCESS == lrc)
            {
                dwSize = sizeof(TCHAR)*MAX_PATH;
                lrc = RegQueryValueEx(hkey,TEXT("Path"),0,&dwType,(LPBYTE)szData,&dwSize);
                if (ERROR_SUCCESS == lrc)
                {
                    if (0 == lstrcmpi(szData,TEXT("smmscrpt.dll")))
                        m_bScriptingAvailable = TRUE;
                }
            }
            if (hkey)
                RegCloseKey(hkey);
            hkey = NULL;
        }

        //
        // Verify that the DLL can be loaded
        //
        if (m_bScriptingAvailable)
        {
            hInst = LoadLibrary(TEXT("smmscrpt.dll"));
            if (hInst)
                FreeLibrary(hInst);
            else
                m_bScriptingAvailable = FALSE;
            hInst = NULL;
        }
    }
#endif // WIN16
}

// ############################################################################
CPhoneBook::~CPhoneBook()
{
#ifdef WIN16
    if (m_rgPhoneBookEntry)
        GlobalFree(m_rgPhoneBookEntry);
#else
    if (m_hPhoneBookEntry)
        GlobalUnlock(m_hPhoneBookEntry);

    if (m_hPhoneBookEntry)
        GlobalFree(m_hPhoneBookEntry);
#endif

    if (m_pLineCountryList) 
        GlobalFree(m_pLineCountryList);

    if (m_rgIDLookUp)
        GlobalFree(m_rgIDLookUp);

    if (m_rgNameLookUp)
        GlobalFree(m_rgNameLookUp);

    if (m_rgState)
        GlobalFree(m_rgState);
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookDW(DWORD far *pdw, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2Dw(szTempBuffer,pdw));
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookW(WORD far *pw, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2W(szTempBuffer,pw));
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookB(BYTE far *pb, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2B(szTempBuffer,pb));
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookSZ(LPTSTR psz, DWORD dwSize, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(psz,dwSize))
            return FALSE;
    return TRUE;
}

// ############################################################################
BOOL CPhoneBook::FixUpFromRealloc(PACCESSENTRY paeOld, PACCESSENTRY paeNew)
{
    BOOL bRC = FALSE;
    LONG_PTR lDiff = 0;
    DWORD idx = 0;

    //
    // No starting value or no move, therefore no fix-ups needed
    //
    if ((0 == paeOld) || (paeNew == paeOld))
    {
        bRC = TRUE;
        goto FixUpFromReallocExit;
    }

    Assert(paeNew);
    Assert(((LONG)paeOld) > 0);    // if these address look like negative numbers
    Assert(((LONG)paeNew) > 0); // I'm not sure the code would handle them

    lDiff = (LONG_PTR)paeOld - (LONG_PTR)paeNew;

    //
    // fix up STATES
    //
    for (idx = 0; idx < m_cStates; idx++)
    {
        if (m_rgState[idx].paeFirst)
            m_rgState[idx].paeFirst = (PACCESSENTRY )((LONG_PTR)m_rgState[idx].paeFirst - lDiff);
    }

    //
    // fix up ID look up array
    //
    for (idx = 0; idx < m_pLineCountryList->dwNumCountries ; idx++)
    {
        if (m_rgIDLookUp[idx].pFirstAE)
            m_rgIDLookUp[idx].pFirstAE = (PACCESSENTRY )((LONG_PTR)m_rgIDLookUp[idx].pFirstAE - lDiff);
    }

    bRC = TRUE;
FixUpFromReallocExit:
    return bRC;
}

// ############################################################################
HRESULT CPhoneBook::Init(LPCTSTR pszISPCode)
{
    LPLINECOUNTRYLIST pLineCountryTemp = NULL;
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    DWORD dwLastState = 0;
    DWORD dwLastCountry = 0;
    DWORD dwSizeAllocated;
    PACCESSENTRY pCurAccessEntry;
    PACCESSENTRY pAETemp;
    LPLINECOUNTRYENTRY pLCETemp;
    DWORD idx;
    LPTSTR pszTemp;
    CCSVFile far *pcCSVFile=NULL;
    LPSTATE    ps,psLast; //faster to use pointers.
    HGLOBAL hTemp = NULL;
    

/*#ifdef WIN16

    m_pLineCountryList = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR, sizeof(LINECOUNTRYLIST) + sizeof(LINECOUNTRYENTRY) + 10);
    if (!m_pLineCountryList)
        goto InitExit;
    
    m_pLineCountryList->dwTotalSize = sizeof(LINECOUNTRYLIST) + sizeof(LINECOUNTRYENTRY) + 3;
    m_pLineCountryList->dwNeededSize = m_pLineCountryList->dwUsedSize = m_pLineCountryList->dwTotalSize;
    m_pLineCountryList->dwNumCountries = 1;
    m_pLineCountryList->dwCountryListSize = sizeof(LINECOUNTRYENTRY);
    m_pLineCountryList->dwCountryListOffset = sizeof(LINECOUNTRYLIST);

    pLCETemp = (LPLINECOUNTRYENTRY)((DWORD) m_pLineCountryList + m_pLineCountryList->dwCountryListOffset);
    pLCETemp->dwCountryID = 1;
    pLCETemp->dwCountryCode = 1;
    pLCETemp->dwNextCountryID = 0;
    pLCETemp->dwCountryNameSize = 3;
    pLCETemp->dwCountryNameOffset = sizeof(LINECOUNTRYLIST) + sizeof(LINECOUNTRYENTRY);
    pLCETemp->dwSameAreaRuleSize = 0;
    pLCETemp->dwSameAreaRuleOffset = 0;
    pLCETemp->dwLongDistanceRuleSize = 0;
    pLCETemp->dwLongDistanceRuleOffset = 0;
    pLCETemp->dwInternationalRuleSize = 0;
    pLCETemp->dwInternationalRuleOffset = 0;
    lstrcpy ((LPTSTR)((DWORD)m_pLineCountryList + pLCETemp->dwCountryNameOffset), TEXT("USA"));
    pszTemp = (LPTSTR)((DWORD)m_pLineCountryList + pLCETemp->dwCountryNameOffset);

#else    // WIN16   */

    // Get TAPI country list
    m_pLineCountryList = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,sizeof(LINECOUNTRYLIST));
    if (!m_pLineCountryList) 
        goto InitExit;
    
    m_pLineCountryList->dwTotalSize = sizeof(LINECOUNTRYLIST);
    
#if defined(WIN16)
    idx = (DWORD) IETapiGetCountry(0, m_pLineCountryList);
#else
    idx = lineGetCountry(0,0x10003,m_pLineCountryList);
#endif
    if (idx && idx != LINEERR_STRUCTURETOOSMALL)
        goto InitExit;
    
    Assert(m_pLineCountryList->dwNeededSize);

    pLineCountryTemp = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,
                                                        (size_t)m_pLineCountryList->dwNeededSize);
    if (!pLineCountryTemp)
        goto InitExit;
    
    pLineCountryTemp->dwTotalSize = m_pLineCountryList->dwNeededSize;
    GlobalFree(m_pLineCountryList);
    
    m_pLineCountryList = pLineCountryTemp;
    pLineCountryTemp = NULL;

#if defined(WIN16)
    if (IETapiGetCountry(0, m_pLineCountryList))
#else
    if (lineGetCountry(0,0x10003,m_pLineCountryList))
#endif
        goto InitExit;

//#endif    // WIN16

    // Load Look Up arrays
#ifdef DEBUG
    m_rgIDLookUp = (LPIDLOOKUPELEMENT)GlobalAlloc(GPTR,
        (int)(sizeof(IDLOOKUPELEMENT)*m_pLineCountryList->dwNumCountries+5));
#else
    m_rgIDLookUp = (LPIDLOOKUPELEMENT)GlobalAlloc(GPTR,
        (int)(sizeof(IDLOOKUPELEMENT)*m_pLineCountryList->dwNumCountries));
#endif
    if (!m_rgIDLookUp) goto InitExit;

    pLCETemp = (LPLINECOUNTRYENTRY)((DWORD_PTR)m_pLineCountryList + 
        m_pLineCountryList->dwCountryListOffset);

    for (idx=0;idx<m_pLineCountryList->dwNumCountries;idx++)
    {
        m_rgIDLookUp[idx].dwID = pLCETemp[idx].dwCountryID;
        m_rgIDLookUp[idx].pLCE = &pLCETemp[idx];
    }

    qsort(m_rgIDLookUp,(int)m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),
        CompareIDLookUpElements);

    m_rgNameLookUp = (LPCNTRYNAMELOOKUPELEMENT)GlobalAlloc(GPTR,
        (int)(sizeof(CNTRYNAMELOOKUPELEMENT) * m_pLineCountryList->dwNumCountries));

    if (!m_rgNameLookUp) goto InitExit;

    for (idx=0;idx<m_pLineCountryList->dwNumCountries;idx++)
    {
        m_rgNameLookUp[idx].psCountryName = (LPTSTR)((LPBYTE)m_pLineCountryList + (DWORD)pLCETemp[idx].dwCountryNameOffset);
        m_rgNameLookUp[idx].dwNameSize = pLCETemp[idx].dwCountryNameSize;
        m_rgNameLookUp[idx].pLCE = &pLCETemp[idx];
    }

    qsort(m_rgNameLookUp,(int)m_pLineCountryList->dwNumCountries,sizeof(CNTRYNAMELOOKUPELEMENT),
        CompareCntryNameLookUpElements);
    
    // Load States
    if (!SearchPath(NULL,STATE_FILENAME,NULL,TEMP_BUFFER_LENGTH,szTempBuffer,&pszTemp))
    {
        AssertMsg(0,"STATE.ICW not found");
        hr = ERROR_FILE_NOT_FOUND;
        goto InitExit;
    }

    pcCSVFile = new CCSVFile;
    if (!pcCSVFile) goto InitExit;

    if (!pcCSVFile->Open(szTempBuffer))
    {
        AssertMsg(0,"Can not open STATE.ICW");
        delete pcCSVFile;
        pcCSVFile = NULL;
        goto InitExit;
    }

    // first token in state file is the number of states
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
        goto InitExit;

    if (!FSz2Dw(szTempBuffer,&m_cStates))
    {
        AssertMsg(0,"STATE.ICW count is invalid");
        goto InitExit;
    }

    m_rgState = (LPSTATE)GlobalAlloc(GPTR,(int)(sizeof(STATE)*m_cStates));
    if (!m_rgState)
        goto InitExit;

    for (ps = m_rgState, psLast = &m_rgState[m_cStates - 1]; ps <= psLast;++ps)
        {
        pcCSVFile->ReadToken(ps->szStateName,cbStateName);    
        }
    
    pcCSVFile->Close();

    // Locate ISP's INF file
    if (!SearchPath(NULL,(LPCTSTR) pszISPCode,INF_SUFFIX,MAX_PATH,
                        m_szINFFile,&pszTemp))
    {
        wsprintf(szTempBuffer,TEXT("Can not find:%s%s (%d)"),pszISPCode,INF_SUFFIX,GetLastError());
        AssertMsg(0,szTempBuffer);
        hr = ERROR_FILE_NOT_FOUND;
        goto InitExit;
    }

    //Load Phone Book
    if (!GetPrivateProfileString(INF_APP_NAME,INF_PHONE_BOOK,INF_DEFAULT,
        szTempBuffer,TEMP_BUFFER_LENGTH,m_szINFFile))
    {
        AssertMsg(0,"PhoneBookFile not specified in INF file");
        hr = ERROR_FILE_NOT_FOUND;
        goto InitExit;
    }
    
#ifdef DEBUG
    if (!lstrcmp(szTempBuffer,INF_DEFAULT))
    {
        wsprintf(szTempBuffer, TEXT("%s value not found in ISP file"), INF_PHONE_BOOK);
        AssertMsg(0,szTempBuffer);
    }
#endif

    
    if (!SearchPath(NULL,szTempBuffer,NULL,MAX_PATH,m_szPhoneBook,&pszTemp))
    {
        AssertMsg(0,"ISP phone book not found");
        hr = ERROR_FILE_NOT_FOUND;
        goto InitExit;
    }

    if (!pcCSVFile->Open(m_szPhoneBook))
    {
        AssertMsg(0,"Can not open phone book");
        hr = GetLastError();
        goto InitExit;
    }
    
    dwSizeAllocated = 0;
    do {
        Assert (dwSizeAllocated >= m_cPhoneBookEntries);
        // check that sufficient memory is allocated
        if (m_rgPhoneBookEntry)
        {
            if (dwSizeAllocated == m_cPhoneBookEntries)
            {
                //
                // we need more memory
                //
//                AssertMsg(0,"Out of memory originally allocated for phone book.\r\n");
//                goto InitExit;

                pAETemp = m_rgPhoneBookEntry;
#ifdef WIN16            
                dwSizeAllocated += PHONE_ENTRY_ALLOC_SIZE;
                m_rgPhoneBookEntry = (PACCESSENTRY)GlobalReAlloc(m_rgPhoneBookEntry,
                    (int)(dwSizeAllocated * sizeof(ACCESSENTRY)),GHND);
                if (NULL == m_rgPhoneBookEntry) 
                    goto InitExit;
#else

                // UNLOCK
                Assert(m_hPhoneBookEntry);
                if (FALSE == GlobalUnlock(m_hPhoneBookEntry))
                {
                    if (NO_ERROR != GetLastError())
                        goto InitExit;
                }

                // REALLOC
                dwSizeAllocated += PHONE_ENTRY_ALLOC_SIZE;
                hTemp = m_hPhoneBookEntry;
                m_hPhoneBookEntry = GlobalReAlloc(hTemp,
                    (int)(dwSizeAllocated * sizeof(ACCESSENTRY)),GHND);
                if (NULL == m_hPhoneBookEntry)
                {
                    GlobalFree(hTemp);
                    goto InitExit;
                }
                else
                {
                    hTemp = NULL;
                }

                // LOCK
                m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
                if (NULL == m_rgPhoneBookEntry) 
                    goto InitExit;
                
#endif
                FixUpFromRealloc(pAETemp, m_rgPhoneBookEntry); 
                TraceMsg(TF_GENERAL, "Grow phone book to %d entries\n",dwSizeAllocated);
                pCurAccessEntry = (PACCESSENTRY)((LONG_PTR)pCurAccessEntry - 
                    ((LONG_PTR)pAETemp - (LONG_PTR)(m_rgPhoneBookEntry)));

            }
        }
        else
        {
            //
            // Initialization for the first time through 
            //
            
            // ALLOC
#ifdef WIN16
            m_rgPhoneBookEntry = (PACCESSENTRY)GlobalAlloc(GHND,sizeof(ACCESSENTRY) * PHONE_ENTRY_ALLOC_SIZE);
            if(NULL == m_rgPhoneBookEntry) 
                goto InitExit;
#else
            m_hPhoneBookEntry = GlobalAlloc(GHND,sizeof(ACCESSENTRY) * PHONE_ENTRY_ALLOC_SIZE);
            if(NULL == m_hPhoneBookEntry) 
                goto InitExit;

            // LOCK
            m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
            if(NULL == m_rgPhoneBookEntry) 
                goto InitExit;
#endif
            dwSizeAllocated = PHONE_ENTRY_ALLOC_SIZE;
            pCurAccessEntry = m_rgPhoneBookEntry;
        }

        // Read a line from the phonebook
        hr = ReadOneLine(pCurAccessEntry,pcCSVFile);
        if (hr == ERROR_NO_MORE_ITEMS)
        {
            break;
        }
        else if (hr != ERROR_SUCCESS)
        {
            goto InitExit;
        }

        hr = ERROR_NOT_ENOUGH_MEMORY;

        // Check to see if this is the first phone number for a given country
        if (pCurAccessEntry->dwCountryID != dwLastCountry)
        {
            LPIDLOOKUPELEMENT lpIDLookupElement;
            // NOTE: Not sure about the first parameter here.
            lpIDLookupElement = (LPIDLOOKUPELEMENT)bsearch(&pCurAccessEntry->dwCountryID,
                m_rgIDLookUp,(int)m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),
                CompareIDLookUpElements);
            if (!lpIDLookupElement)
            {
                // bad country ID, but we can't assert here
                TraceMsg(TF_GENERAL,"Bad country ID in phone book %d\n",pCurAccessEntry->dwCountryID);
                continue;
            }
            else
            {
                // for a given country ID this is the first phone number
                lpIDLookupElement->pFirstAE = pCurAccessEntry;
                dwLastCountry = pCurAccessEntry->dwCountryID;
            }
        }

        // Check to see if this is the first phone number for a given state
        if (pCurAccessEntry->wStateID && (pCurAccessEntry->wStateID != dwLastState))
        {
            idx = pCurAccessEntry->wStateID - 1;
            m_rgState[idx].dwCountryID = pCurAccessEntry->dwCountryID;
            m_rgState[idx].paeFirst = pCurAccessEntry;
            dwLastState = pCurAccessEntry->wStateID;
        }

        pCurAccessEntry++;
        m_cPhoneBookEntries++;
    } while (TRUE);

    // Trim the phone book for unused memory
    Assert(m_rgPhoneBookEntry && m_cPhoneBookEntries);

    pAETemp = m_rgPhoneBookEntry;

#ifdef WIN16
    m_rgPhoneBookEntry = (PACCESSENTRY)GlobalReAlloc(m_rgPhoneBookEntry,(int)(m_cPhoneBookEntries * sizeof(ACCESSENTRY)),GHND);
    if (!m_rgPhoneBookEntry) goto InitExit;
#else

    // UNLOCK
    Assert(m_hPhoneBookEntry);
    if (FALSE != GlobalUnlock(m_hPhoneBookEntry))
    {
        if (NO_ERROR != GetLastError())
            goto InitExit;
    }

    // REALLOC
    hTemp = m_hPhoneBookEntry;
    m_hPhoneBookEntry = GlobalReAlloc(hTemp,(int)(m_cPhoneBookEntries * sizeof(ACCESSENTRY)),GHND);
    if (NULL == m_hPhoneBookEntry) 
    {
        GlobalFree(hTemp);
        goto InitExit;
    }
    else
    {
        hTemp = NULL;
    }

    // LOCK
    m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
    if (NULL == m_rgPhoneBookEntry) 
        goto InitExit;
#endif
    FixUpFromRealloc(pAETemp, m_rgPhoneBookEntry); 

    hr = ERROR_SUCCESS;
InitExit:
    // If something failed release everything
    if (hr != ERROR_SUCCESS)
    {
#ifdef WIN16
        GlobalFree(m_rgPhoneBookEntry);
#else
        GlobalUnlock(m_hPhoneBookEntry);
        GlobalFree(m_hPhoneBookEntry);
#endif
        GlobalFree(m_pLineCountryList);
        GlobalFree(m_rgIDLookUp);
        GlobalFree(m_rgNameLookUp);
        GlobalFree(m_rgState);

        m_cPhoneBookEntries = 0 ;
        m_cStates = 0;

        m_pLineCountryList = NULL;
        m_rgPhoneBookEntry = NULL;
        m_hPhoneBookEntry = NULL;
        m_rgIDLookUp=NULL;
        m_rgNameLookUp=NULL;
        m_rgState=NULL;
    }

    if (pcCSVFile) 
    {
        pcCSVFile->Close();
        delete pcCSVFile;
    }
    return hr;
}

// ############################################################################
HRESULT CPhoneBook::Merge(LPCTSTR pszChangeFile)
{
    CCSVFile far *pcCSVFile;
    ACCESSENTRY aeChange;
    LPIDXLOOKUPELEMENT rgIdxLookUp;
    LPIDXLOOKUPELEMENT pCurIdxLookUp;
    DWORD dwAllocated;
    DWORD dwUsed;
    DWORD dwOriginalSize;
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    DWORD    dwIdx;  
#if !defined(WIN16)
    HANDLE hTemp;
    HANDLE hIdxLookUp;
#else
    // Normandy 11746
    LPVOID rgTemp;  // 16-bit only
#endif
    DWORD cch, cchWritten;
    HANDLE hFile;

    // Pad the phonebook for new entries.
    dwAllocated = m_cPhoneBookEntries + CHANGE_BUFFER_SIZE;
#ifdef WIN16
    Assert(m_rgPhoneBookEntry);
    rgTemp = GlobalReAlloc(m_rgPhoneBookEntry, (int)(sizeof(ACCESSENTRY) * dwAllocated),GHND);
    Assert(rgTemp);
    if (!rgTemp) goto MergeExit;
    m_rgPhoneBookEntry = (PACCESSENTRY)rgTemp;
#else
    Assert(m_hPhoneBookEntry);
    GlobalUnlock(m_hPhoneBookEntry);
    hTemp = (HANDLE)GlobalReAlloc(m_hPhoneBookEntry, sizeof(ACCESSENTRY) * dwAllocated,GHND);
    Assert(hTemp);
    if (!hTemp)
        goto MergeExit;
    m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
    if (!m_rgPhoneBookEntry)
        goto MergeExit;
#endif

    // Create index to loaded phone book, sorted by index
#ifdef WIN16
    rgIdxLookUp = (LPIDXLOOKUPELEMENT)GlobalAlloc(GHND,(int)(sizeof(IDXLOOKUPELEMENT) * dwAllocated));
#else
    hIdxLookUp = (HANDLE)GlobalAlloc(GHND,sizeof(IDXLOOKUPELEMENT) * dwAllocated);
    rgIdxLookUp = (LPIDXLOOKUPELEMENT)GlobalLock(hIdxLookUp);
#endif
    Assert(rgIdxLookUp);
    if (!rgIdxLookUp)
        goto MergeExit;

    for (dwIdx = 0; dwIdx < m_cPhoneBookEntries; dwIdx++)
    {
        rgIdxLookUp[dwIdx].dwIndex = rgIdxLookUp[dwIdx].pAE->dwIndex;
        rgIdxLookUp[dwIdx].pAE = &m_rgPhoneBookEntry[dwIdx];
    }
    dwUsed = m_cPhoneBookEntries;
    dwOriginalSize = m_cPhoneBookEntries;

    qsort(rgIdxLookUp,(int)dwOriginalSize,sizeof(IDXLOOKUPELEMENT),CompareIdxLookUpElements);

    // Load changes to phone book
    pcCSVFile = new CCSVFile;
    Assert(pcCSVFile);
    if (!pcCSVFile)
        goto MergeExit;
    if (!pcCSVFile->Open(pszChangeFile))
        goto MergeExit;
    
    do {

        // Read a change record
        ZeroMemory(&aeChange,sizeof(ACCESSENTRY));
        hr = ReadOneLine(&aeChange, pcCSVFile);

        if(hr == ERROR_NO_MORE_ITEMS)
        {
            break; // no more enteries
        }
        else if (hr != ERROR_SUCCESS)
        {
            goto MergeExit;
        }

        hr = ERROR_NOT_ENOUGH_MEMORY;

/*        if (!ReadPhoneBookDW(&aeChange.dwIndex,pcCSVFile))
            break; // no more enteries
        ReadVerifyPhoneBookDW(aeChange.dwCountryID);
        ReadVerifyPhoneBookW(aeChange.wStateID);
        ReadVerifyPhoneBookSZ(aeChange.szCity,cbCity);
        ReadVerifyPhoneBookSZ(aeChange.szAreaCode,cbAreaCode);
        // NOTE: 0 is a valid area code and ,, is a valid entry for an area code
        if (!FSz2Dw(aeChange.szAreaCode,&aeChange.dwAreaCode))
            aeChange.dwAreaCode = NO_AREA_CODE;
        ReadVerifyPhoneBookSZ(aeChange.szAccessNumber,cbAccessNumber);
        ReadVerifyPhoneBookDW(aeChange.dwConnectSpeedMin);
        ReadVerifyPhoneBookDW(aeChange.dwConnectSpeedMax);
        ReadVerifyPhoneBookB(aeChange.bFlipFactor);
        ReadVerifyPhoneBookB(aeChange.fType);
        ReadVerifyPhoneBookSZ(aeChange.szDataCenter,cbDataCenter);
        */

        // Determine if this is a delete or add record
        if (aeChange.szAccessNumber[0] == '0' && aeChange.szAccessNumber[1] == '\0')
        {
            // This is a delete record, find matching record
            // NOTE: we only search the numbers that existed before the change file,
            // because they are the only ones that are sorted.
            pCurIdxLookUp = (LPIDXLOOKUPELEMENT)bsearch(&aeChange,rgIdxLookUp,(int)dwOriginalSize,
                sizeof(IDXLOOKUPELEMENT),CompareIdxLookUpElements);
            AssertMsg(pCurIdxLookUp,"Attempting to delete a record that does not exist.  The change file and phone book versions do not match.");
            if (pCurIdxLookUp)
                pCurIdxLookUp->pAE = NULL;  //Create a dead entry in the look up table
            m_cPhoneBookEntries--;
        }
        else
        {
            // This is an add entry
            m_cPhoneBookEntries++;
            dwUsed++;
            // Make sure we have enough room
            if (m_cPhoneBookEntries > dwAllocated)
            {
                // Grow phone book
                dwAllocated += CHANGE_BUFFER_SIZE;
#ifdef WIN16
                Assert(m_rgPhoneBookEntry);
                rgTemp = GlobalReAlloc(m_rgPhoneBookEntry,(int)(sizeof(ACCESSENTRY)*dwAllocated),GHND);
                Assert(rgTemp);
                if (!rgTemp)
                    goto MergeExit;
                m_rgPhoneBookEntry = (PACCESSENTRY)rgTemp;

                // Grow look up index
                Assert(rgIdxLookUp);
                rgTemp = GlobalReAlloc(rgIdxLookUp,(int)(sizeof(IDXLOOKUPELEMENT)*dwAllocated),GHND);
                Assert(rgTemp);
                if (!rgTemp)
                    goto MergeExit;
                rgIdxLookUp = (LPIDXLOOKUPELEMENT)rgTemp;
#else
                Assert(m_hPhoneBookEntry);
                GlobalUnlock(m_hPhoneBookEntry);
                hTemp = (HANDLE)GlobalReAlloc(m_hPhoneBookEntry,sizeof(ACCESSENTRY)*dwAllocated,GHND);
                Assert(hTemp);
                if (!hTemp)
                    goto MergeExit;
                m_hPhoneBookEntry = hTemp;
                m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
                Assert(m_rgPhoneBookEntry);
                if (!m_rgPhoneBookEntry)
                    goto MergeExit;

                // Grow look up index
                Assert(hIdxLookUp);
                GlobalUnlock(hIdxLookUp);
                hTemp = (HANDLE)GlobalReAlloc(hIdxLookUp,sizeof(IDXLOOKUPELEMENT)*dwAllocated,GHND);
                Assert(hTemp);
                if (!hTemp)
                    goto MergeExit;
                hIdxLookUp = hTemp;
                rgIdxLookUp = (LPIDXLOOKUPELEMENT)GlobalLock(hIdxLookUp);
                Assert(rgIdxLookUp);
                if (!rgIdxLookUp)
                    goto MergeExit;
#endif
            }

            //Add entry to the end of the phonebook and to end of look up index
            CopyMemory(&m_rgPhoneBookEntry[m_cPhoneBookEntries],&aeChange,sizeof(ACCESSENTRY));
            rgIdxLookUp[m_cPhoneBookEntries].dwIndex = m_rgPhoneBookEntry[m_cPhoneBookEntries].dwIndex;
            rgIdxLookUp[m_cPhoneBookEntries].pAE = &m_rgPhoneBookEntry[m_cPhoneBookEntries];
            // NOTE: because the entry is added to the end of the list, we can't add
            // and delete entries in the same change file.
        }
    } while (TRUE);

    // resort the IDXLookUp index to reflect the correct order of enteries
    // for the phonebook file, including all of the entries to be deleted.
    qsort(rgIdxLookUp,(int)dwUsed,sizeof(IDXLOOKUPELEMENT),CompareIdxLookUpElementsFileOrder);

    // Build a new phonebook file  
#ifdef WIN16
    GetTempFileName(0, TEMP_PHONE_BOOK_PREFIX, 0, szTempFileName);
#else
    if (!GetTempPath(TEMP_BUFFER_LENGTH,szTempBuffer))
        goto MergeExit;
    if (!GetTempFileName(szTempBuffer,TEMP_PHONE_BOOK_PREFIX,0,szTempFileName))
        goto MergeExit;
#endif
    hFile = CreateFile(szTempFileName,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,
        FILE_FLAG_WRITE_THROUGH,0);
    if (hFile == INVALID_HANDLE_VALUE)
        goto MergeExit;

    for (dwIdx = 0; dwIdx < m_cPhoneBookEntries; dwIdx++)
    {
        cch = wsprintf(szTempBuffer, TEXT("%lu,%lu,%lu,%s,%s,%s,%lu,%lu,%lu,%lu,%s\r\n"),
            rgIdxLookUp[dwIdx].pAE->dwIndex,
            rgIdxLookUp[dwIdx].pAE->dwCountryID,
            DWORD(rgIdxLookUp[dwIdx].pAE->wStateID),
            rgIdxLookUp[dwIdx].pAE->szCity,
            rgIdxLookUp[dwIdx].pAE->szAreaCode,
            rgIdxLookUp[dwIdx].pAE->szAccessNumber,
            rgIdxLookUp[dwIdx].pAE->dwConnectSpeedMin,
            rgIdxLookUp[dwIdx].pAE->dwConnectSpeedMax,
            DWORD(rgIdxLookUp[dwIdx].pAE->bFlipFactor),
            DWORD(rgIdxLookUp[dwIdx].pAE->fType),
            rgIdxLookUp[dwIdx].pAE->szDataCenter);

        if (!WriteFile(hFile,szTempBuffer,cch,&cchWritten,NULL))
        {
            // something went wrong, get rid of the temporary file
            CloseHandle(hFile);
            DeleteFile(szTempFileName);
            hr = GetLastError();
            goto MergeExit;
        }

        Assert(cch == cchWritten);
    }
    CloseHandle(hFile);
    hFile = NULL;

    // Move new phone book over old
    if (!MoveFileEx(szTempFileName,m_szPhoneBook,MOVEFILE_REPLACE_EXISTING))
    {
        hr = GetLastError();
        goto MergeExit;
    }

    // discard the phonebook in memory
#ifndef WIN16
    Assert(m_hPhoneBookEntry);
    GlobalUnlock(m_hPhoneBookEntry);
#endif
    m_rgPhoneBookEntry = NULL;
    m_cPhoneBookEntries = 0; 
    GlobalFree(m_pLineCountryList);
    GlobalFree(m_rgIDLookUp);
    GlobalFree(m_rgNameLookUp);
    GlobalFree(m_rgState);
    m_cStates = 0;

    lstrcpy(szTempBuffer,m_szINFCode);
    m_szINFFile[0] = '\0';
    m_szPhoneBook[0] = '\0';
    m_szINFCode[0] = '\0';

    //  Reload it (and rebuild look up arrays)
    hr = Init(szTempBuffer);

MergeExit:
    if (hr != ERROR_SUCCESS)
    { 
        GlobalFree(rgIdxLookUp);         
        if (pcCSVFile) delete pcCSVFile;
        CloseHandle(hFile);
    }
    return hr;
}

// ############################################################################
HRESULT CPhoneBook::ReadOneLine(PACCESSENTRY lpAccessEntry, CCSVFile far *pcCSVFile)
{
    HRESULT hr = ERROR_SUCCESS;

#if !defined(WIN16)
ReadOneLineStart:
#endif //WIN16
    if (!ReadPhoneBookDW(&lpAccessEntry->dwIndex,pcCSVFile))
    {
        hr = ERROR_NO_MORE_ITEMS; // no more enteries
        goto ReadExit;
    }
    ReadVerifyPhoneBookDW(lpAccessEntry->dwCountryID);
    ReadVerifyPhoneBookW(lpAccessEntry->wStateID);
    ReadVerifyPhoneBookSZ(lpAccessEntry->szCity,cbCity);
    ReadVerifyPhoneBookSZ(lpAccessEntry->szAreaCode,cbAreaCode);
    // NOTE: 0 is a valid area code and ,, is a valid entry for an area code
    if (!FSz2Dw(lpAccessEntry->szAreaCode,&lpAccessEntry->dwAreaCode))
        lpAccessEntry->dwAreaCode = NO_AREA_CODE;
    ReadVerifyPhoneBookSZ(lpAccessEntry->szAccessNumber,cbAccessNumber);
    ReadVerifyPhoneBookDW(lpAccessEntry->dwConnectSpeedMin);
    ReadVerifyPhoneBookDW(lpAccessEntry->dwConnectSpeedMax);
    ReadVerifyPhoneBookB(lpAccessEntry->bFlipFactor);
    ReadVerifyPhoneBookDW(lpAccessEntry->fType);
    ReadVerifyPhoneBookSZ(lpAccessEntry->szDataCenter,cbDataCenter);

    switch (lpAccessEntry->bFlipFactor)
    {
        case BOTH_ISDN_ANALOG:
            // This phone number supports both ISDN or Analog, return true
            // We want analog numbers, check the FlipFactor for zero
            lpAccessEntry->fType |= MASK_ISDN_BIT | MASK_ANALOG_BIT;
            break;
        case ANALOG_TYPE:
            // Analog only
            lpAccessEntry->fType |= MASK_ANALOG_BIT;
            break;
        case ISDN_TYPE:
            // We only want ISDN numbers
            lpAccessEntry->fType |= MASK_ISDN_BIT;
            break;
    }
#if !defined(WIN16)
    //
    // If scripting is not available and the phonebook entry has a dun file other than
    // icwip.dun, then ignore the entry and read the one after that.
    //
    if (!m_bScriptingAvailable)
    {
        if (0 != lstrcmpi(lpAccessEntry->szDataCenter,TEXT("icwip.dun")))
        {
            ZeroMemory(lpAccessEntry,sizeof(ACCESSENTRY));
            goto ReadOneLineStart;
        }
    }
#endif //WIN16

ReadExit:
    return hr;
ReadError:
    hr = ERROR_INVALID_DATA;
    goto ReadExit;
}

// ############################################################################
HRESULT CPhoneBook::Suggest(PSUGGESTINFO pSuggest)
{
    WORD        wNumFound = 0;
    HRESULT        hr = ERROR_NOT_ENOUGH_MEMORY;
//    char        szFileName[MAX_PATH];
//    char        *pszTemp;
//    HANDLE        hFile=NULL;
//    HANDLE        hMap=NULL;
//    DWORD        dwSize;
//    LPNPABLOCK    rg950Data = NULL;
//    NPABLOCK    *p950Data;

    
    // Validate parameters
    Assert(pSuggest);
    Assert(pSuggest->wNumber);

    if (wNumFound == pSuggest->wNumber)
        goto SuggestExit;

    LPIDLOOKUPELEMENT pCurLookUp;
    PACCESSENTRY lpAccessEntry;
    
    //REVIEW: double check this
    pCurLookUp = (LPIDLOOKUPELEMENT)bsearch(&pSuggest->dwCountryID,m_rgIDLookUp,
        (int)m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),
        CompareIDLookUpElements);

    // Check for invalid country
    if (!pCurLookUp)
        goto SuggestExit;

    // Check if there are any phone numbers for this country
    if (!pCurLookUp->pFirstAE) goto SuggestExit;

    lpAccessEntry = pCurLookUp->pFirstAE;
    do {
        // check for the right area code
        if (lpAccessEntry->dwAreaCode == pSuggest->wAreaCode)
        {
            // check for the right type of number
            if ((lpAccessEntry->fType & pSuggest->bMask) == pSuggest->fType)
            {
                pSuggest->rgpAccessEntry[wNumFound] = lpAccessEntry;
                wNumFound++;
            }
        }
        lpAccessEntry++;
    } while ((lpAccessEntry <= &m_rgPhoneBookEntry[m_cPhoneBookEntries-1]) && 
        (wNumFound < pSuggest->wNumber) &&
        (lpAccessEntry->dwCountryID == pSuggest->dwCountryID));



    //
    //  MKarki - Bug 340 no need to list more numbers if one already found
    //  in Area Code specified by user 
    //
    //    5/24/97 jmazner Olympus #340 and #71
    //    nope, this is wrong.  We always want to return as many applicable
    //    phone numbers as we find.  Just because the area code matches
    //  doesn't mean that we've found an ideal phone number.
    //if (wNumFound == 0)
    //{
    //
    
    // if we couldn't find enough numnbers, try something else
    //

    // 10/15/96  jmazner  ported fixes below from core\client\phbk

    // 
    // Do this only if area code is not 0 - Bug #9349 (VetriV)
    //     if ((pSuggest->wAreaCode != 0) && (wNumFound < pSuggest->wNumber))
    //
    // No, there are some places (Finland?  ChrisK knows) where 0 is a legit area code -- jmazner

    if (wNumFound < pSuggest->wNumber)
    {
        lpAccessEntry = pCurLookUp->pFirstAE;

        // Note: we are now only looking for Nationwide phone numbers (state = 0)

        // 8/13/96 jmazner MOS Normandy #4597
        // We want nationwide toll-free numbers to display last, so for this pass,
        // only consider numbers that are _not_ toll free  (fType bit #1 = 0)
        //
        // 5/24/97 jmazner Olympus #71
        // As per GeoffR's spec, the search passes should not be based on
        // the tollfree bit at all
        //
        // 5/28/97 jmazner Olympus #71
        // ahem...as per GeoffR's new spec, we _should_ consider the tollfree
        // bit and in this query only bring up toll free numbers.
        //
        // so, we will only return numbers whose area code match, or which are
        // tollfree
        //
    
        //
        // Tweak pSuggest->bMask to let through the toll/charge bit
        // 
        pSuggest->bMask |= MASK_TOLLFREE_BIT;

        // //Tweak pSuggest->ftype to be charge
        //pSuggest->fType &= TYPE_SET_TOLL;
        //
        // make that tollfree!
        pSuggest->fType |= TYPE_SET_TOLLFREE;

        do {

            // 8/13/96 jmazner MOS Normandy #4598
            // If this entry's area code matches pSuggest->wAreaCode, then we already
            // have included it in the previous pass, so don't duplicate it again here.
            if ((lpAccessEntry->fType & pSuggest->bMask) == pSuggest->fType &&
                 lpAccessEntry->wStateID == 0 &&
                 lpAccessEntry->dwAreaCode != pSuggest->wAreaCode)
            {
                pSuggest->rgpAccessEntry[wNumFound] = lpAccessEntry;
                wNumFound++;
            }
            lpAccessEntry++;
        } while ((lpAccessEntry <= &m_rgPhoneBookEntry[m_cPhoneBookEntries-1]) && 
            (wNumFound < pSuggest->wNumber) &&
            (lpAccessEntry->dwCountryID == pSuggest->dwCountryID) &&
            (lpAccessEntry->wStateID == 0) );
    }


    // 8/13/96 jmazner MOS Normandy #4597
    // if we STILL couldn't find enough numnbers, widen the search to include tollfree #s
    //
    // 5/24/97 jmazner Olympus #71
    // no need for this pass at all.  See earlier comments.

/****
    if (wNumFound < pSuggest->wNumber)
    {
        lpAccessEntry = pCurLookUp->pFirstAE;
    
        // Tweak pSuggest->bMask to let through the toll/charge bit
        // REDUNDANT? If we made it to this point, we _should_ have done this above...
        // Better safe than sorry!
        Assert(pSuggest->bMask & MASK_TOLLFREE_BIT);
        pSuggest->bMask |= MASK_TOLLFREE_BIT;

        // Tweak pSuggest->ftype to be tollfree
        pSuggest->fType |= TYPE_SET_TOLLFREE;

        do {

            // 8/13/96 jmazner MOS Normandy #4598
            // If this entry's area code matches pSuggest->wAreaCode, then we already
            // have included it in the first pass, so don't include it here.
            // Any entry that made it in in the 2nd pass will definitely not make it in here
            // (because of tollfree bit), so no need to worry about dups from there.
            if ((lpAccessEntry->fType & pSuggest->bMask) == pSuggest->fType &&
              lpAccessEntry->wStateID == 0 &&
              lpAccessEntry->dwAreaCode != pSuggest->wAreaCode)
            {
                pSuggest->rgpAccessEntry[wNumFound] = lpAccessEntry;
                wNumFound++;
            }
            lpAccessEntry++;
        } while ((lpAccessEntry <= &m_rgPhoneBookEntry[m_cPhoneBookEntries-1]) && 
            (wNumFound < pSuggest->wNumber) &&
            (lpAccessEntry->dwCountryID == pSuggest->dwCountryID) &&
            (lpAccessEntry->wStateID == 0) );
    }
****/
    //}  //   End of If for Bug - 340 -  MKarki

/*
    // Flip factoring
    if (wNumFound == 2)
    {
        SYSTEMTIME st;
        GetSystemTime(&st);
        srand((UINT)st.wMilliseconds);
        if ((rand() % 10) > pSuggest->rgLPACCESSENTRY[0]->bFlipFactor)
        {
            lpAccessEntry = pSuggest->rgLPACCESSENTRY[0];
            pSuggest->rgpAccessEntry[0] = pSuggest->rgpAccessEntry[1];
            pSuggest->rgpAccessEntry[1] = lpAccessEntry;
        }
    }
*/

    hr = ERROR_SUCCESS;
SuggestExit:
    pSuggest->wNumber = wNumFound;
    return hr;
}

// ############################################################################
HRESULT CPhoneBook::GetCanonical (PACCESSENTRY pAE, LPTSTR psOut)
{
    HRESULT hr = ERROR_SUCCESS;
    LPIDLOOKUPELEMENT pIDLookUp;

    pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(&pAE->dwCountryID,m_rgIDLookUp,
        (int)m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIdxLookUpElements);

    if (!pIDLookUp)
    {
        hr = ERROR_INVALID_PARAMETER;
    } else {
        SzCanonicalFromAE (psOut, pAE, pIDLookUp->pLCE);
    }

    return hr;
}

// ############################################################################
DllExportH PhoneBookLoad(LPCTSTR pszISPCode, DWORD_PTR far *pdwPhoneID)
{
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    CPhoneBook far *pcPhoneBook;

    if (!g_hInstDll)
        g_hInstDll = GetModuleHandle(NULL);

    // validate parameters
    Assert(pszISPCode && *pszISPCode && pdwPhoneID);
    *pdwPhoneID = NULL;

    // allocate phone book
    pcPhoneBook = new CPhoneBook;

    // initialize phone book
    if (pcPhoneBook)
        hr = pcPhoneBook->Init(pszISPCode);

    // in case of failure
    if (hr && pcPhoneBook)
    {
        delete pcPhoneBook;
    } else {
        *pdwPhoneID = (DWORD_PTR)pcPhoneBook;
    }

#if defined(WIN16)
    if (!hr)
        BMP_RegisterClass(g_hInstDll);
#endif    

    return hr;
}

// ############################################################################
DllExportH PhoneBookUnload(DWORD_PTR dwPhoneID)
{
    Assert(dwPhoneID);

    if (dwPhoneID)
    {
#if defined(WIN16)
        BMP_DestroyClass(g_hInstDll);
#endif
        // Release contents
        delete (CPhoneBook far*)dwPhoneID;
    }

    return ERROR_SUCCESS;
}

// ############################################################################
DllExportH PhoneBookMergeChanges(DWORD_PTR dwPhoneID, LPCTSTR pszChangeFile)
{
    return ((CPhoneBook far*)dwPhoneID)->Merge(pszChangeFile);
}

// ############################################################################
DllExportH PhoneBookSuggestNumbers(DWORD_PTR dwPhoneID, PSUGGESTINFO lpSuggestInfo)
{
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;

    // get suggested numbers 
    lpSuggestInfo->rgpAccessEntry = (PACCESSENTRY *)GlobalAlloc(GPTR,sizeof(PACCESSENTRY) * lpSuggestInfo->wNumber);
    if (lpSuggestInfo->rgpAccessEntry)
    {
        hr = ((CPhoneBook far *)dwPhoneID)->Suggest(lpSuggestInfo);
    }

    return hr;
}

// ############################################################################
DllExportH PhoneBookGetCanonical (DWORD_PTR dwPhoneID, PACCESSENTRY pAE, LPTSTR psOut)
{
    return ((CPhoneBook far*)dwPhoneID)->GetCanonical(pAE,psOut);
}

// ############################################################################
DllExportH PhoneBookDisplaySignUpNumbers (DWORD_PTR dwPhoneID,
                                                        LPTSTR far *ppszPhoneNumbers,
                                                        LPTSTR far *ppszDunFiles,
                                                        WORD far *pwPhoneNumbers,
                                                        DWORD far *pdwCountry,
                                                        WORD far *pwRegion,
                                                        BYTE fType,
                                                        BYTE bMask,
                                                        HWND hwndParent,
                                                        DWORD dwFlags)
{
    HRESULT hr;
    AssertMsg(ppszPhoneNumbers && pwPhoneNumbers && pdwCountry &&pwRegion,"invalid parameters");


    //CAccessNumDlg *pcDlg;
    CSelectNumDlg far *pcDlg;
    pcDlg = new CSelectNumDlg;
    if (!pcDlg)
    {
        hr = GetLastError();
        goto DisplayExit;
    }

    // Initialize information for dialog
    //

    pcDlg->m_dwPhoneBook = dwPhoneID;
    pcDlg->m_dwCountryID = *pdwCountry;
    pcDlg->m_wRegion = *pwRegion;
    pcDlg->m_fType = fType;
    pcDlg->m_bMask = bMask;
    pcDlg->m_dwFlags = dwFlags;

    // invoke the dialog
    //
    // BUG: NOT THREAD SAFE!!
    g_hWndMain = hwndParent;
    hr = (HRESULT)DialogBoxParam(g_hInstDll,MAKEINTRESOURCE(IDD_SELECTNUMBER),
                            g_hWndMain, PhbkGenericDlgProc,(LPARAM)pcDlg);
    g_hWndMain = NULL;

    if (hr == IDC_CMDNEXT) 
    {
        *pwRegion = pcDlg->m_wRegion;
        *pdwCountry = pcDlg->m_dwCountryID;

        Assert (ppszPhoneNumbers[0] && ppszDunFiles[0]);
        lstrcpy(ppszPhoneNumbers[0],&pcDlg->m_szPhoneNumber[0]);
        lstrcpy(ppszDunFiles[0],&pcDlg->m_szDunFile[0]);

        hr = ERROR_SUCCESS;
    }
    else if (hr == IDC_CMDBACK)
        hr = ERROR_USERBACK;
    else
        hr = ERROR_USERCANCEL;

    //    hr == -1;
DisplayExit:
    if (pcDlg) delete pcDlg;

    return hr;
}

//DllExportH TestBar()
//{
//    LPCSTR pszISPCode;
//    LPDWORD pdwPhoneID;
//
//    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
//    CPhoneBook FAR *pcPhoneBook;
//
//    if (!g_hInstDll)
//        g_hInstDll = GetModuleHandle(NULL);
//
//    // validate parameters
////1    Assert(pszISPCode && *pszISPCode && pdwPhoneID);
////1    *pdwPhoneID = NULL;
//
//    // allocate phone book
////1    pcPhoneBook = new CPhoneBook;
//
//    // initialize phone book
//    if (pcPhoneBook)
//        hr = pcPhoneBook->Init(pszISPCode);
//
//    // in case of failure
//    if (hr && pcPhoneBook)
//    {
//        delete pcPhoneBook;
//    } else {
//        *pdwPhoneID = (DWORD)pcPhoneBook;
//    }
//
////2#if defined(WIN16)
////2    if (!hr)
////2        BMP_RegisterClass(g_hInstDll);
////2#endif    
//
//    return hr;
//}
//

//++--------------------------------------------------------------
//
//  API :       GetSupportNumbers
//
//  Synopsis:   This is the API used to get the support
//              numbers
//
//  Returns:    HRESULT - success or error info
//  
//  Arguments:  [OUT]       PSUPPORTNUM - array of SUPPORTNUM structs
//              [IN/OUT]    PDWORD      - mem for buffersize
//              
//  Called By:  by the EXE using the ICWPHBK.DLL
//
//  History:    MKarki      Created     5/8/97
//
//----------------------------------------------------------------
DllExportH GetSupportNumbers (
        PSUPPORTNUM  pBuffer,
        PDWORD       pBufferSize
        )
{
    return (GetSupportNumsFromFile (pBuffer, pBufferSize));

}   // end of GetSupportNumbers API call
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\phbk.h ===
#ifndef _PHBK
#define _PHBK

#include "ccsv.h"
#include "debug.h"
#include "icwsupport.h"

#ifdef WIN16
#include <malloc.h>

#define DllExportH extern "C" HRESULT WINAPI __export
#else
#define DllExportH extern "C" HRESULT WINAPI __stdcall 
//#define DllExportH extern "C" __declspec(dllexport) HRESULT WINAPI
#endif

#define MsgBox(m,s) MessageBox(GetSz(m),GetSz(IDS_TITLE),s)

#define cbAreaCode    6            // maximum number of characters in an area code, not including \0
#define cbCity 19                // maximum number of chars in city name, not including \0
#define cbAccessNumber 15        // maximum number of chars in phone number, not including \0
#define cbStateName 31             // maximum number of chars in state name, not including \0
                                // check this against state.pbk delivered by mktg
#define cbBaudRate 6            // maximum number of chars in a baud rate, not including \0
#if defined(WIN16)
#define cbDataCenter 12            // max length of data center string
#else
#define cbDataCenter (MAX_PATH+1)            // max length of data center string
#endif
#define NO_AREA_CODE 0xFFFFFFFF

#define PHONE_ENTRY_ALLOC_SIZE    500
#define INF_SUFFIX        TEXT(".ISP")
#define INF_APP_NAME      TEXT("ISP INFO")
#define INF_PHONE_BOOK    TEXT("PhoneBookFile")
#define INF_DEFAULT      TEXT("SPAM SPAM SPAM SPAM SPAM SPAM EGGS AND SPAM")
#define STATE_FILENAME    TEXT("STATE.ICW")
#define FILE_NAME_800950  TEXT("800950.DAT")
#define TEMP_BUFFER_LENGTH 1024
#define MAX_INFCODE 9

#define TYPE_SIGNUP_TOLLFREE    0x83
#define TYPE_SIGNUP_TOLL        0x82
#define TYPE_REGULAR_USAGE        0x42

#define MASK_SIGNUP_TOLLFREE    0xB3
#define MASK_SIGNUP_TOLL        0xB3
#define MASK_REGULAR_USAGE        0x73

// 8/13/96 jmazner for Normandy bug #4597
// ported from core\client\phbk 10/15/96
#define MASK_TOLLFREE_BIT            0x01    // Bit #1: 1=tollfree, 0=charge
#define TYPE_SET_TOLLFREE            0x01    // usage: type |= TYPE_SET_TOLLFREE
// want TYPE_SET_TOLL to be a DWORD to match pSuggestInfo->fType
#define TYPE_SET_TOLL                ~((DWORD)TYPE_SET_TOLLFREE)    // usage: type &= TYPE_SET_TOLL

#define MASK_ISDN_BIT               0x04    // Bit #3: 1=ISDN, 0=Non-ISDN
#define MASK_ANALOG_BIT             0x08    // Bit #4: 1=Analog, 0=Non-Analog

#define clineMaxATT    16
#define NXXMin        200
#define NXXMax        999
#define cbgrbitNXX    ((NXXMax + 1 - NXXMin) / 8)

// Phone number select dialog flags
//

#define FREETEXT_SELECTION_METHOD  0x00000001
#define PHONELIST_SELECTION_METHOD 0x00000002
#define AUTODIAL_IN_PROGRESS       0x00000004
#define DIALERR_IN_PROGRESS        0x00000008

// Phone number type
//

#define ANALOG_TYPE        0
#define ISDN_TYPE          1
#define BOTH_ISDN_ANALOG   2

typedef struct
{
    DWORD    dwIndex;                                // index number
    BYTE    bFlipFactor;                            // for auto-pick
    DWORD    fType;                                    // phone number type
    WORD    wStateID;                                // state ID
    DWORD    dwCountryID;                            // TAPI country ID
    DWORD    dwAreaCode;                                // area code or NO_AREA_CODE if none
    DWORD    dwConnectSpeedMin;                        // minimum baud rate
    DWORD    dwConnectSpeedMax;                        // maximum baud rate
    TCHAR   szCity[cbCity + sizeof('\0')];            // city name
    TCHAR   szAccessNumber[cbAccessNumber + sizeof('\0')];    // access number
    TCHAR   szDataCenter[cbDataCenter + sizeof('\0')];                // data center access string
    TCHAR   szAreaCode[cbAreaCode + sizeof('\0')];                    //Keep the actual area code string around.
} ACCESSENTRY, far *PACCESSENTRY;     // ae

typedef struct {
    DWORD dwCountryID;                                // country ID that this state occurred in
    PACCESSENTRY paeFirst;                            // pointer to first access entry for this state
    TCHAR szStateName[cbStateName + sizeof('\0')];    // state name
} STATE, far *LPSTATE;

typedef struct tagIDLOOKUPELEMENT {
    DWORD dwID;
    LPLINECOUNTRYENTRY pLCE;
    PACCESSENTRY pFirstAE;
} IDLOOKUPELEMENT, far *LPIDLOOKUPELEMENT;

typedef struct tagCNTRYNAMELOOKUPELEMENT {
    LPTSTR psCountryName;
    DWORD dwNameSize;
    LPLINECOUNTRYENTRY pLCE;
} CNTRYNAMELOOKUPELEMENT, far *LPCNTRYNAMELOOKUPELEMENT;

typedef struct tagIDXLOOKUPELEMENT {
    DWORD dwIndex;
    PACCESSENTRY pAE;
} IDXLOOKUPELEMENT,far *LPIDXLOOKUPELEMENT;

typedef struct tagSUGGESTIONINFO
{
    DWORD    dwCountryID;
    DWORD    wAreaCode;
    DWORD    wExchange;
    WORD    wNumber;
    DWORD    fType;  // 9/6/96 jmazner  Normandy
    DWORD    bMask;  // make this struct look like the one in %msnroot%\core\client\phbk\phbk.h
    PACCESSENTRY *rgpAccessEntry;
} SUGGESTINFO, far *PSUGGESTINFO;

typedef struct tagNPABlock
{
    WORD wAreaCode;
    BYTE grbitNXX [cbgrbitNXX];
} NPABLOCK, far *LPNPABLOCK;



class CPhoneBook
{
    //friend HRESULT DllExport PhoneBookLoad(LPCTSTR pszISPCode, DWORD *pdwPhoneID);
    //friend class CDialog;
    
    // 1/9/96  jmazner Normandy #13185
    //friend class CAccessNumDlg;
    
    friend class CSelectNumDlg;

public:
    void far * operator new( size_t cb ) { return GlobalAlloc(GPTR,cb); };
    void operator delete( void far * p ) {GlobalFree(p); };

    CPhoneBook();
    ~CPhoneBook();

    HRESULT Init(LPCTSTR pszISPCode);
    HRESULT Merge(LPCTSTR pszChangeFilename);
    HRESULT Suggest(PSUGGESTINFO pSuggest);
    HRESULT GetCanonical(PACCESSENTRY pAE, LPTSTR psOut);

private:
    PACCESSENTRY            m_rgPhoneBookEntry;
    HANDLE                    m_hPhoneBookEntry;    
    DWORD                    m_cPhoneBookEntries;
    LPLINECOUNTRYENTRY        m_rgLineCountryEntry;
    LPLINECOUNTRYLIST         m_pLineCountryList;
    LPIDLOOKUPELEMENT        m_rgIDLookUp;
    LPCNTRYNAMELOOKUPELEMENT m_rgNameLookUp;
    LPSTATE                    m_rgState;
    DWORD                    m_cStates;
#if !defined(WIN16)
    BOOL              m_bScriptingAvailable;
#endif

    TCHAR                   m_szINFFile[MAX_PATH];
    TCHAR                   m_szINFCode[MAX_INFCODE];
    TCHAR                   m_szPhoneBook[MAX_PATH];

    BOOL ReadPhoneBookDW(DWORD far *pdw, CCSVFile far *pcCSVFile);
    BOOL ReadPhoneBookW(WORD far *pw, CCSVFile far *pcCSVFile);
    BOOL ReadPhoneBookSZ(LPTSTR psz, DWORD dwSize, CCSVFile far *pcCSVFile);
    BOOL ReadPhoneBookB(BYTE far *pb, CCSVFile far *pcCSVFile);
    HRESULT ReadOneLine(PACCESSENTRY pAccessEntry, CCSVFile far *pcCSVFile);
    BOOL FixUpFromRealloc(PACCESSENTRY paeOld, PACCESSENTRY paeNew);

};

#ifdef __cplusplus
extern "C" {
#endif
extern HINSTANCE g_hInstDll;    // instance for this DLL
extern HWND g_hWndMain;
#ifdef __cplusplus
}
#endif
#endif // _PHBK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\phbkex.h ===
#ifndef _PHBKEX
#define _PHBKEX

#define TYPE_SIGNUP_ANY            0x82
#define TYPE_SIGNUP_TOLLFREE    0x83
#define TYPE_SIGNUP_TOLL        0x82
#define TYPE_REGULAR_USAGE        0x42

#define MASK_SIGNUP_ANY            0xB2
#define MASK_SIGNUP_TOLLFREE    0xB3
#define MASK_SIGNUP_TOLL        0xB3
#define MASK_REGULAR_USAGE        0x73

#define cbAreaCode    6            // maximum number of characters in an area code, not including \0
#define cbCity 19                // maximum number of chars in city name, not including \0
#define cbAccessNumber 15        // maximum number of chars in phone number, not including \0
#define cbStateName 31             // maximum number of chars in state name, not including \0
                                // check this against state.pbk delivered by mktg
#define cbBaudRate 6            // maximum number of chars in a baud rate, not including \0
#define cbDataCenter 12            // max length of data center string

typedef struct
{
    DWORD    dwIndex;                                // index number
    BYTE    bFlipFactor;                            // for auto-pick
    BYTE    fType;                                    // phone number type
    WORD    wStateID;                                // state ID
    DWORD    dwCountryID;                            // TAPI country ID
    DWORD    dwAreaCode;                                // area code or NO_AREA_CODE if none
    DWORD    dwConnectSpeedMin;                        // minimum baud rate
    DWORD    dwConnectSpeedMax;                        // maximum baud rate
    TCHAR   szCity[cbCity + sizeof('\0')];            // city name
    TCHAR   szAccessNumber[cbAccessNumber + sizeof('\0')];    // access number
    TCHAR   szDataCenter[cbDataCenter + sizeof('\0')];                // data center access string
    TCHAR   szAreaCode[cbAreaCode + sizeof('\0')];                    //Keep the actual area code string around.
} ACCESSENTRY, FAR  *PACCESSENTRY;     // ae

typedef struct tagSUGGESTIONINFO
{
    DWORD    dwCountryID;
    DWORD    wAreaCode;
    DWORD    wExchange;
    WORD    wNumber;
    BYTE    fType;
    BYTE    bMask;
    PACCESSENTRY *rgpAccessEntry;
} SUGGESTINFO,FAR *PSUGGESTINFO;

#endif _PHBKEX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\rnaapi.h ===
//-----------------------------------------------------------------------------
// RNAAPI class
// 
// This class provides a series of cover function for the RNAPH/RASAPI32 dlls
//
//      Created 1-29-96	ChrisK

//-----------------------------------------------------------------------------
// TYPEDEF
typedef DWORD (WINAPI* PFNRASENUMDEVICES)(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb, LPDWORD lpcDevices);
typedef DWORD (WINAPI* PFNRASVALIDATEENTRYNAE)(LPTSTR lpszPhonebook, LPTSTR lpszEntry);
typedef DWORD (WINAPI* PFNRASSETENTRYPROPERTIES)(LPTSTR lpszPhonebook, LPTSTR lpszEntry, LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize, LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
typedef DWORD (WINAPI* PFNRASGETENTRYPROPERTIES)(LPTSTR lpszPhonebook, LPTSTR lpszEntry, LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);

//-----------------------------------------------------------------------------
// CLASS
// ############################################################################
class CRNAAPI
{
public: 
	void far * operator new( size_t cb ) { return GlobalAlloc(GPTR,cb); };
	void operator delete( void far * p ) {GlobalFree(p); };

	CRNAAPI();
	~CRNAAPI();

	DWORD RasEnumDevices(LPRASDEVINFO, LPDWORD, LPDWORD);
	DWORD RasValidateEntryName(LPTSTR,LPTSTR);
	DWORD RasSetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
								LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize,
								LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
	DWORD RasGetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
								LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize,
								LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);


private:
	BOOL LoadApi(LPSTR, FARPROC*);

	HINSTANCE m_hInst;
	HINSTANCE m_hInst2;

	PFNRASENUMDEVICES m_fnRasEnumDeviecs;
	PFNRASVALIDATEENTRYNAE m_fnRasValidateEntryName;
	PFNRASSETENTRYPROPERTIES m_fnRasSetEntryProperties;
	PFNRASGETENTRYPROPERTIES m_fnRasGetEntryProperties;
};

#ifndef WIN16
inline BOOL IsNT(void)
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\sources.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwphbk

MAJORCOMP=GETCONN
MINORCOMP=ICWPHBK

TARGETNAME=ICWPHBK
TARGETTYPE=DYNLINK
TARGETPATH=obj

DLLENTRY=PHBKDllEntryPoint
DLLBASE=0x60000000
DLLDEF=..\icwphbk.def

NOT_LEAN_AND_MEAN   =1
RCNOFONTMAP         =1
C_DEFINES           =-DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

USE_MSVCRT          = 1

SOURCES=                \
    ..\icwphbk.rc       \
    ..\ccsv.cpp         \
    ..\main.cpp         \
    ..\misc.cpp         \
    ..\phbk.cpp         \
    ..\rnaapi.cpp       \
    ..\suapi.cpp        \
    ..\icwsupport.cpp

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib      \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\tapi32.lib        \
    $(SDK_LIB_PATH)\advapi32.lib      \
    $(SDK_LIB_PATH)\gdi32.lib         \
!if defined(NOT_UNICODE)
    $(GETCONN_DIR)\lib\ansi\$O\stocklib.lib
!else
    $(GETCONN_DIR)\lib\unicode\$O\stocklib.lib
!endif

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pch.hpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\phbkrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by phbk.rc
//
#define IDS_950NUMBER                   1
#define IDS_WANTTOEXIT                  2
#define IDS_TITLE                       3
#define IDS_NOTENOUGHMEMORY             4
#define IDS_NATIONWIDE                  5
#define IDS_INVALIDPHONE                6
#define IDS_OK                          7
#define IDD_ACCESSNUMBERS               101
#define IDD_SELECTNUMBER                102
#define IDB_WORLD                       106
#define IDB_PHONE                       107
#define IDC_CMDHELP                     1000
#define IDC_TXTPRIMARY                  1001
#define IDC_TXTSECONDARY                1002
#define IDC_CMDCHANGEPRIMARY            1003
#define IDC_CMDCHANGESECONDARY          1004
#define IDC_CMDEXIT                     1005
#define IDC_CMDOK                       1006
#define IDC_CMBCOUNTRY                  1007
#define IDC_CMBREGION                   1008
#define IDC_LSTNUMBER                   1009
#define IDC_CMDCANCEL                   IDCANCEL
#define IDC_CMBNUMBER                   1011
#define IDC_CMDNEXT                     1012
#define IDC_CMDBACK                     1013
#define IDC_LBLTITLE                    1014
#define IDC_LBLAUTODIAL                 1015
#define IDC_LBLSIGNUP                   1016
#define IDC_LBLDIALERR                  1017
#define IDC_LBLCOUNTRY                  1018
#define IDC_LBLSTATEMSG				    1019
#define IDC_INSTRUCT_ACCESS_TEXT        1020
#define IDC_INSTRUCT_SELECT_TEXT        1021
#define IDC_COUNTRY_TEXT                1022
#define IDC_REGION_TEXT                 1023
#define IDC_PHONE_TEXT                  1024

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\rnaapi.cpp ===
//-----------------------------------------------------------------------------
// RNAAPI class
// 
// This class provides a series of cover function for the RNAPH/RASAPI32 dlls
//
// Created 1-29-96	ChrisK

// ############################################################################
// INCLUDES
#include "pch.hpp"
//#include "ras.h"
#ifdef WIN16
#include <win16def.h>
#include <rasc.h>
#include <raserr.h>
#else
#include <ras.h>
#endif
#pragma pack (4)
//#if !defined(WIN16)
//#include <rnaph.h>
//#endif
#pragma pack ()
#include "rnaapi.h"
#include "debug.h"

// ############################################################################
// RNAAPI class 
CRNAAPI::CRNAAPI()
{
#if defined WIN16
    m_hInst = LoadLibrary ("RAS16IE.DLL");
    m_hInst2 = NULL;
#else
	m_hInst = LoadLibrary(TEXT("RASAPI32.DLL"));
	
    if (FALSE == IsNT ())
    {
        //
        // we only load RNAPH.DLL if it is not NT
        // MKarki (5/4/97) - Fix for Bug #3378
        //
	    m_hInst2 = LoadLibrary(TEXT("RNAPH.DLL"));
    }
    else
    {
        m_hInst2 =  NULL;
    }
#endif
	m_fnRasEnumDeviecs = NULL;
	m_fnRasValidateEntryName = NULL;
	m_fnRasSetEntryProperties = NULL;
	m_fnRasGetEntryProperties = NULL;
}

// ############################################################################
CRNAAPI::~CRNAAPI()
{
	// Clean up
	if (m_hInst) FreeLibrary(m_hInst);
	if (m_hInst2) FreeLibrary(m_hInst2);
}

// ############################################################################
DWORD CRNAAPI::RasEnumDevices(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb,
							 LPDWORD lpcDevices)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi("RasEnumDevices",(FARPROC*)&m_fnRasEnumDeviecs);

	if (m_fnRasEnumDeviecs)
		dwRet = (*m_fnRasEnumDeviecs) (lpRasDevInfo, lpcb, lpcDevices);

	return dwRet;
}

// ############################################################################
BOOL CRNAAPI::LoadApi(LPSTR pszFName, FARPROC* pfnProc)
{
	if (*pfnProc == NULL)
	{
		// Look for the entry point in the first DLL
		if (m_hInst)
			*pfnProc = GetProcAddress(m_hInst,pszFName);
		
		// if that fails, look for the entry point in the second DLL
		if (m_hInst2 && !(*pfnProc))
			*pfnProc = GetProcAddress(m_hInst2,pszFName);
	}

	return (pfnProc != NULL);
}

// ############################################################################
DWORD CRNAAPI::RasValidateEntryName(LPTSTR lpszPhonebook,LPTSTR lpszEntry)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi("RasValidateEntryName",(FARPROC*)&m_fnRasValidateEntryName);

	if (m_fnRasValidateEntryName)
		dwRet = (*m_fnRasValidateEntryName) (lpszPhonebook, lpszEntry);

	return dwRet;
}

// ############################################################################
DWORD CRNAAPI::RasSetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
									LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize,
									LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi("RasSetEntryProperties",(FARPROC*)&m_fnRasSetEntryProperties);

	if (m_fnRasSetEntryProperties)
		dwRet = (*m_fnRasSetEntryProperties) (lpszPhonebook, lpszEntry,
									lpbEntryInfo, dwEntryInfoSize,
									lpbDeviceInfo, dwDeviceInfoSize);

	return dwRet;
}

// ############################################################################
DWORD CRNAAPI::RasGetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
									LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize,
									LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi("RasGetEntryProperties",(FARPROC*)&m_fnRasGetEntryProperties);

	if (m_fnRasGetEntryProperties)
		dwRet = (*m_fnRasGetEntryProperties) (lpszPhonebook, lpszEntry,
									lpbEntryInfo, lpdwEntryInfoSize,
									lpbDeviceInfo, lpdwDeviceInfoSize);

	return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\suapi.cpp ===
// ############################################################################
#include "pch.hpp" 
#include "phbk.h"
#include "debug.h"
#include "phbkrc.h"
#include "misc.h"
#ifdef WIN16
#include <win16def.h>
#include <rasc.h>
#include <raserr.h>
#include <ctl3d.h>
#define MB_SETFOREGROUND     0
#else
//#include "ras.h"
#include <ras.h>
#endif
#pragma pack (4)
//#if !defined(WIN16)
//#include <rnaph.h>
//#endif
#pragma pack ()
#include "suapi.h"
#include "rnaapi.h" //pick this up to get IsNT

#define ERROR_USER_EXIT 0x8b0bffff
#define MB_MYERROR (MB_APPLMODAL | MB_ICONERROR | MB_SETFOREGROUND)

#ifdef WIN16
#define NOTIFY_CODE (HIWORD(lParam))
#else
#define NOTIFY_CODE (HIWORD(wParam))
#endif

#define WM_SHOWSTATEMSG WM_USER+1

TCHAR szTemp[100];

TCHAR szValidPhoneCharacters[] = {TEXT("0123456789AaBbCcDdPpTtWw!@$ -.()+*#,&\0")};

//+---------------------------------------------------------------------------
//
//    Function:    ProcessDBCS
//
//    Synopsis:    Converts control to use DBCS compatible font
//                Use this at the beginning of the dialog procedure
//    
//                Note that this is required due to a bug in Win95-J that prevents
//                it from properly mapping MS Shell Dlg.  This hack is not needed
//                under winNT.
//
//    Arguments:    hwnd - Window handle of the dialog
//                cltID - ID of the control you want changed.
//
//    Returns:    ERROR_SUCCESS
// 
//    History:    4/31/97 a-frankh    Created
//                5/13/97    jmazner        Stole from CM to use here
//----------------------------------------------------------------------------
void ProcessDBCS(HWND hDlg, int ctlID)
{
#if defined(WIN16)
    return;
#else
    HFONT hFont = NULL;

    if( IsNT() )
    {
        return;
    }

    hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
    if (hFont == NULL)
        hFont = (HFONT) GetStockObject(SYSTEM_FONT);
    if (hFont != NULL)
        SendMessage(GetDlgItem(hDlg,ctlID), WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0));
#endif
}

// ############################################################################
BOOL CSelectNumDlg::FHasPhoneNumbers(LPLINECOUNTRYENTRY pLCE)
{
    LPIDLOOKUPELEMENT pIDLookUp;
    IDLOOKUPELEMENT LookUpTarget;
    CPhoneBook far *pcPBTemp;
    PACCESSENTRY pAE = NULL, pAELast = NULL;
    DWORD dwCountryID;

    pcPBTemp = ((CPhoneBook far*)m_dwPhoneBook);

    LookUpTarget.dwID = pLCE->dwCountryID;

    pIDLookUp = NULL;
    pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(&LookUpTarget,pcPBTemp->m_rgIDLookUp,
        (int)pcPBTemp->m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIDLookUpElements);

    if (!pIDLookUp) return FALSE; // no such country

    pAE = pIDLookUp->pFirstAE;
    if (!pAE) return FALSE; // no phone numbers at all

    dwCountryID = pAE->dwCountryID;

    pAELast = &(pcPBTemp->m_rgPhoneBookEntry[pcPBTemp->m_cPhoneBookEntries - 1]);
    while (pAELast > pAE && 
           pAE->dwCountryID == dwCountryID)
    {
        if ((pAE->fType & m_bMask) == m_fType)
            return TRUE;
        pAE++;
    }
    return FALSE; // no phone numbers of the right type

//    return ((BOOL)(pIDLookUp->pFirstAE));
}

// ############################################################################
LRESULT CSelectNumDlg::DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT lResult)
{
    LRESULT lRet = TRUE;
    unsigned int idx;
    int iCurIndex;
    int iLastIndex;
    PACCESSENTRY pAE = NULL;
    LPTSTR p, p2;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        CPhoneBook far *pcPBTemp;
        pcPBTemp = ((CPhoneBook far *)m_dwPhoneBook);
        m_hwndDlg = hwndDlg;

        // figure out if we are in the middle of an AUTODIAL
        //

        if (m_dwFlags & AUTODIAL_IN_PROGRESS)
        {
            EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDBACK),FALSE);
            ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLSIGNUP),SW_HIDE);
            ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLDIALERR),SW_HIDE);
        } else if (m_dwFlags& DIALERR_IN_PROGRESS){
            ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLSIGNUP),SW_HIDE);
            ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLAUTODIAL),SW_HIDE);
            ShowWindow(GetDlgItem(m_hwndDlg,IDC_CMDBACK),SW_HIDE);
            SetDlgItemText(m_hwndDlg,IDC_CMDNEXT,GetSz(IDS_OK));
        }else {
            ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLAUTODIAL),SW_HIDE);
            ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLDIALERR),SW_HIDE);
        }

        //
        // Set up fields to handle DBCS chars on win95-J
        ProcessDBCS(m_hwndDlg, IDC_LBLCOUNTRY);
        ProcessDBCS(m_hwndDlg, IDC_CMBCOUNTRY);
        ProcessDBCS(m_hwndDlg, IDC_CMBREGION);

        // Fill in country list and select current country
        //

        iCurIndex = -1;        // 0xFFFFFFFF
        // NOTE: it might be nice for INTL testing purposes to fill this combo box with
        // a list sorted by the country ID instead of the country name.
        for (idx=0;idx<pcPBTemp->m_pLineCountryList->dwNumCountries;idx++)
        {
            if (FHasPhoneNumbers(pcPBTemp->m_rgNameLookUp[idx].pLCE))
            {
                wsprintf(szTemp,TEXT("%s (%ld)"),
                            pcPBTemp->m_rgNameLookUp[idx].psCountryName,
                            pcPBTemp->m_rgNameLookUp[idx].pLCE->dwCountryID);
                iLastIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,
                                                        CB_ADDSTRING,0,
                                                        (LPARAM)((LPTSTR) &szTemp[0]));
                SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_SETITEMDATA,
                                    (WPARAM)iLastIndex,
                                    (LPARAM)pcPBTemp->m_rgNameLookUp[idx].pLCE->dwCountryID);
                if (pcPBTemp->m_rgNameLookUp[idx].pLCE->dwCountryID == m_dwCountryID)
                {
                    iCurIndex = iLastIndex;
                }
            }
        }

        if (iCurIndex != -1)    // 0xFFFFFFFF
        {
            SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_SETCURSEL,(WPARAM)iCurIndex,0);
        } else {
            SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_SETCURSEL,0,0);
            iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_GETITEMDATA,0,0);
            if (iCurIndex != CB_ERR) m_dwCountryID = iCurIndex;
        }

        // Copy country to label
        //
        if (GetDlgItemText(m_hwndDlg,IDC_CMBCOUNTRY,szTemp,100))
        {
            SetDlgItemText(m_hwndDlg,IDC_LBLCOUNTRY,szTemp);
        }

        // Initialize Last Selection Method
        //

        m_dwFlags &= (~FREETEXT_SELECTION_METHOD);
        m_dwFlags |= PHONELIST_SELECTION_METHOD;

        // Fill in region list and select current region
        //
        FillRegion();

        // Fill in phone numbers
        //
        FillNumber();

        SetFocus(GetDlgItem(m_hwndDlg,IDC_CMBCOUNTRY));
        lRet = FALSE;
        break;
    case WM_SHOWSTATEMSG:
        if (wParam)
        {
            ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLSTATEMSG),SW_SHOW);
        } else {
            ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLSTATEMSG),SW_HIDE);
        }
        break;
        // 1/9/96 jmazner  added for Normandy #13185
    case WM_CLOSE:
        if ((m_dwFlags & (AUTODIAL_IN_PROGRESS|DIALERR_IN_PROGRESS)) == 0) 
        {
            if (MessageBox(hwndDlg,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
                MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
                EndDialog(hwndDlg,IDC_CMDCANCEL);
        } else {
            EndDialog(hwndDlg,IDC_CMDCANCEL);
        }
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
            case IDC_CMBCOUNTRY:
                if (NOTIFY_CODE == CBN_SELCHANGE)
                {
                    iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_GETCURSEL,0,0);
                    if (iCurIndex == CB_ERR) break;

                    iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_GETITEMDATA,(WPARAM)iCurIndex,0);
                    if (iCurIndex == CB_ERR) break;
                    m_dwCountryID = iCurIndex;  //REVIEW: data type????

                    FillRegion();
                    m_wRegion = 0;

                    FillNumber();
                }
                break;
            case IDC_CMBREGION:
                if (NOTIFY_CODE == CBN_SELCHANGE)
                {
                    iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_GETCURSEL,0,0);
                    if (iCurIndex == CB_ERR) break;

                    iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_GETITEMDATA,(WPARAM)iCurIndex,0);
                    if (iCurIndex == CB_ERR) break;
                     m_wRegion = (USHORT)iCurIndex; //REVIEW: data type???

                    FillNumber();
                }
                break;
            case IDC_CMBNUMBER:
                if ((NOTIFY_CODE == CBN_SELCHANGE) || (NOTIFY_CODE == CBN_DROPDOWN))
                {
                    //iCurIndex = SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_GETCURSEL,0,0);
                    //if (iCurIndex == CB_ERR) break;

                    EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),TRUE);

                    //iCurIndex = SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_GETITEMDATA,(WPARAM)iCurIndex,0);
                    //if (iCurIndex == CB_ERR) break;
                    //if (!lstrcpy(&m_szDunFile[0],&((PACCESSENTRY)iCurIndex)->szDataCenter[0]))
                    //{
                    //    AssertMsg(0,"Failed to copy data center from AE\n");
                    //    break;
                    //}

                    // Set Last Selection Method
                    //

                    m_dwFlags &= (~FREETEXT_SELECTION_METHOD);
                    m_dwFlags |= PHONELIST_SELECTION_METHOD;

                } else if (NOTIFY_CODE == CBN_EDITCHANGE) {

                    if (SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,WM_GETTEXTLENGTH,0,0))
                    {
                        EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),TRUE);
                    } else {
                        EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),FALSE);
                    }

                    // Set Last Selection Method
                    //

                    m_dwFlags &= (~PHONELIST_SELECTION_METHOD);
                    m_dwFlags |= FREETEXT_SELECTION_METHOD;
                }

                break;
            case IDC_CMDNEXT:
                if ((m_dwFlags & PHONELIST_SELECTION_METHOD) == PHONELIST_SELECTION_METHOD)
                {
                    DWORD_PTR dwItemData;

                    iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_GETCURSEL,0,0);
                    if (iCurIndex == CB_ERR) break;

                    dwItemData = (DWORD_PTR)SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_GETITEMDATA,(WPARAM)iCurIndex,0);
                    if (iCurIndex == CB_ERR) break;

                    // Get the relavant information out of the AE structures
                    //

                    pAE = (PACCESSENTRY)dwItemData;
                    ((CPhoneBook far *)m_dwPhoneBook)->GetCanonical(pAE,m_szPhoneNumber);
                    lstrcpy(m_szDunFile,pAE->szDataCenter);
                } else {

                    // Parse the text that the user entered
                    //

                    if (GetDlgItemText(m_hwndDlg,IDC_CMBNUMBER,m_szPhoneNumber,RAS_MaxPhoneNumber))
                    {
                        m_szPhoneNumber[RAS_MaxPhoneNumber] = '\0';
                        for (p = m_szPhoneNumber;*p && *p != ':';p++);
                        if (*p)
                        {
                            *p = '\0';
                            p++;
                            lstrcpy(m_szDunFile,p);
                        } else {
                            m_szDunFile[0] = '\0';
                        }

                        // Check that the phone number on contains valid characters
                        //

                        for (p = m_szPhoneNumber;*p;p++)
                        {
                            for(p2 = szValidPhoneCharacters;*p2;p2++)
                            {
                                if (*p == *p2)
                                    break; // p2 for loop
                            }
                            if (!*p2) break; // p for loop
                        }

                        if (*p)
                        {
                            MessageBox(m_hwndDlg,GetSz(IDS_INVALIDPHONE),GetSz(IDS_TITLE),MB_MYERROR);
                            //MsgBox(IDS_INVALIDPHONE,MB_MYERROR);
                            break; // switch statement
                        }
                    } else {
                        AssertMsg(0,"You should never be able to hit NEXT with nothing in the phone number.\n");
                    }
                }
                EndDialog(m_hwndDlg,IDC_CMDNEXT);
                break;
            case IDC_CMDCANCEL:
                if ((m_dwFlags & (AUTODIAL_IN_PROGRESS|DIALERR_IN_PROGRESS)) == 0) 
                {
                    if (MessageBox(hwndDlg,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
                        MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
                        EndDialog(hwndDlg,IDC_CMDCANCEL);
                } else {
                    EndDialog(hwndDlg,IDC_CMDCANCEL);
                }
            break;
                EndDialog(m_hwndDlg,IDC_CMDCANCEL);
                break;
            case IDC_CMDBACK:
                EndDialog(m_hwndDlg,IDC_CMDBACK);
                break;
        }
    default:
        lRet = FALSE;
        break;
    }// switch

    return lRet;
}

// ############################################################################
/***** 1/9/96  jmazner  Normandy #13185
CAccessNumDlg::CAccessNumDlg()
{
    m_szDunPrimary[0] = '\0';
    m_szDunSecondary[0] = '\0';
    m_szPrimary[0] = '\0';
    m_szSecondary[0] = '\0';
    m_rgAccessEntry = NULL;
    m_wNumber = 0;
    m_dwPhoneBook=0;
}
*********/

// ############################################################################
/********* 1/9/96 jmazner  Normandy #13185
                           This was dead code, unused anywhere in icwphbk
LRESULT CAccessNumDlg::DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
                                        LRESULT lResult)
{
    LRESULT lRet = TRUE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        SendDlgItemMessage(hwnd,IDC_TXTPRIMARY,EM_SETLIMITTEXT,RAS_MaxPhoneNumber,0);
        SendDlgItemMessage(hwnd,IDC_TXTSECONDARY,EM_SETLIMITTEXT,RAS_MaxPhoneNumber,0);

/ *
        // turn AccessEntries into phone numbers
        if(m_szPrimary[0] == '\0')
        {
            LPIDLOOKUPELEMENT pIDLookUp;
            CPhoneBook *pcPBTemp;
            pcPBTemp = ((CPhoneBook far *)m_dwPhoneBook);

            AssertMsg(m_dwPhoneBook,"No phonebook set");

            //For the primary phone number
            pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(&m_rgAccessEntry[0]->dwCountryID,
                pcPBTemp->m_rgIDLookUp,pcPBTemp->m_pLineCountryList->dwNumCountries,
                sizeof(IDLOOKUPELEMENT),CompareIdxLookUpElements);
            SzCanonicalFromAE (m_szPrimary, m_rgAccessEntry[0], pIDLookUp->pLCE);

            if (m_rgAccessEntry[1])
            {
                if (m_rgAccessEntry[0]->dwCountryID != m_rgAccessEntry[1]->dwCountryID)
                {
                    pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(&m_rgAccessEntry[0]->dwCountryID,
                        pcPBTemp->m_rgIDLookUp,pcPBTemp->m_pLineCountryList->dwNumCountries,
                        sizeof(IDLOOKUPELEMENT),CompareIdxLookUpElements);
                }
                SzCanonicalFromAE (m_szSecondary, m_rgAccessEntry[1], pIDLookUp->pLCE);
            }
        }
* /
        SendDlgItemMessage(hwnd,IDC_TXTPRIMARY,WM_SETTEXT,0,(LPARAM)&m_szPrimary[0]);
        SendDlgItemMessage(hwnd,IDC_TXTSECONDARY,WM_SETTEXT,0,(LPARAM)&m_szSecondary[0]);
        break;

        
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_CMDOK:
            // Check that we have at least one phone number
            // Leave dialog
            GetDlgItemText(hwnd,IDC_TXTPRIMARY,&m_szPrimary[0],RAS_MaxPhoneNumber);
            GetDlgItemText(hwnd,IDC_TXTSECONDARY,&m_szSecondary[0],RAS_MaxPhoneNumber);

            if (m_szPrimary[0])
                m_wNumber=1;
            else
                m_wNumber=0;

            if (m_szSecondary[0])
                m_wNumber++;

            EndDialog(hwnd,IDC_CMDOK);
            break;
        case IDC_CMDEXIT:
            // Verify with user
            // Get out of Dodge
            if (MessageBox(hwnd,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
                MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
                EndDialog(hwnd,IDC_CMDEXIT);
            break;
        case IDC_CMDCHANGEPRIMARY:
            // hide dialog
            ShowWindow(hwnd,SW_HIDE);
            // show new dialog
            CSelectNumDlg far *pcSelectNumDlg;
            pcSelectNumDlg = new CSelectNumDlg;
            if (!pcSelectNumDlg)
            {
                MessageBox(hwnd,GetSz(IDS_NOTENOUGHMEMORY),GetSz(IDS_TITLE),MB_MYERROR);
//                MsgBox(IDS_NOTENOUGHMEMORY,MB_MYERROR);
                ShowWindow(hwnd,SW_SHOW);
                break;
            }
            int irc;
            pcSelectNumDlg->m_dwPhoneBook = m_dwPhoneBook;
            pcSelectNumDlg->m_dwCountryID = m_dwCountryID;
            pcSelectNumDlg->m_wRegion = m_wRegion;
            irc = DialogBoxParam(g_hInstDll,MAKEINTRESOURCE(IDD_SELECTNUMBER),
                                    g_hWndMain,PhbkGenericDlgProc,
                                    (LPARAM)pcSelectNumDlg);
            ShowWindow(hwnd,SW_SHOW);
            switch (irc)
            {
                case -1:
                    MessageBox(hwnd,GetSz(IDS_NOTENOUGHMEMORY),GetSz(IDS_TITLE),MB_MYERROR);
//                    MsgBox(IDS_NOTENOUGHMEMORY,MB_MYERROR);
                    goto DlgProcExit;
                    // break;
                case IDC_CMDOK:
                    m_dwCountryID = pcSelectNumDlg->m_dwCountryID;
                    m_wRegion = pcSelectNumDlg->m_wRegion;
                    lstrcpy(m_szDunPrimary,pcSelectNumDlg->m_szDunFile);
                    SetDlgItemText(hwnd,IDC_TXTPRIMARY,pcSelectNumDlg->m_szPhoneNumber);
                    break;
            }
            break;
        }
        break;
    default:
        lRet = FALSE;
        break;
    }
DlgProcExit:
    return lRet;
}

*********************/

#ifdef WIN16
// ############################################################################
// NAME: SetNonBoldDlg
//
//    Set all the child controls in a window to a non-bold version of the
//    current control font.
//
// Parameters: HWND hDlg    Handle to the dialog window
//
// Created 8/12/96    ValdonB (creatively borrowed from IE)
// ############################################################################

void
SetNonBoldDlg(HWND hDlg)
{
    HFONT hfontDlg = (HFONT) NULL;
    LOGFONT lFont;
    HWND hCtl;
    if ((hfontDlg = (HFONT) SendMessage(hDlg, WM_GETFONT, 0, 0L)))
    {
        if (GetObject(hfontDlg, sizeof(LOGFONT), (LPTSTR) &lFont))
        {
            lFont.lfWeight = FW_NORMAL;
            if (hfontDlg = CreateFontIndirect((LPLOGFONT) &lFont))
            {
                // apply the font to all the child controls
                for (hCtl = GetWindow(hDlg, GW_CHILD);
                        NULL != hCtl;
                        hCtl = GetWindow(hCtl, GW_HWNDNEXT))
                {
                    SendMessage(hCtl, WM_SETFONT, (WPARAM) hfontDlg, 0);
                }
            }
        }
    }
}


// ############################################################################
// NAME: SetNonBoldDlg
//
//     The dialog was modified earlier by unbolding the dialog font, and
//     getting each control in the dialog to use that font. This function
//     is called when the dialog is being destroyed so the font can be
//     deleted
//
// Parameters: HWND hDlg    Handle to the dialog window
//
// Created 8/12/96    ValdonB (creatively borrowed from IE)
// ############################################################################

void
DeleteDlgFont
(
    HWND hDlg
)
{
    HFONT hfont = NULL;

    hfont = (HFONT)SendMessage(hDlg,WM_GETFONT,0,0);
    if (hfont) DeleteObject(hfont);
}
#endif    // WIN16


// ############################################################################
#ifdef WIN16
extern "C" BOOL CALLBACK __export PhbkGenericDlgProc(
#else
extern "C" __declspec(dllexport) INT_PTR CALLBACK PhbkGenericDlgProc(
#endif
    HWND  hwndDlg,    // handle to dialog box
    UINT  uMsg,    // message
    WPARAM  wParam,    // first message parameter
    LPARAM  lParam     // second message parameter
   )
{
#if defined(WIN16)
    RECT    MyRect;
    RECT    DTRect;
#endif
//#ifdef DEBUG
//    DebugBreak();
//#endif
    CDialog far *pcDlg = NULL;
    LRESULT lRet;
    switch (uMsg)
    {
    case WM_DESTROY:
        ReleaseBold(GetDlgItem(hwndDlg,IDC_LBLTITLE));
        break;
    case WM_INITDIALOG:
        pcDlg = (CDialog far *)lParam;
        SetWindowLongPtr(hwndDlg,DWLP_USER,lParam);
        lRet = TRUE;
#if defined(WIN16)
        //
        // Move the window to the center of the screen
        //
        GetWindowRect(hwndDlg, &MyRect);
        if (0 == MyRect.left && 0 == MyRect.top)
        {
            GetWindowRect(GetDesktopWindow(), &DTRect);
            MoveWindow(hwndDlg, (DTRect.right - MyRect.right) / 2, (DTRect.bottom - MyRect.bottom) /2,
                                MyRect.right, MyRect.bottom, FALSE);
        }
        SetNonBoldDlg(hwndDlg);
#endif
        MakeBold(GetDlgItem(hwndDlg,IDC_LBLTITLE));
        break;
#if defined(WIN16)
    case WM_SYSCOLORCHANGE:
        Ctl3dColorChange();
        break;
#endif
    // 1/9/96  jmazner Normandy #13185, moved to CSelectNumDlg::DlgProc
    //case WM_CLOSE:
    //    if (MessageBox(hwndDlg,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
    //        MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
    //        EndDialog(hwndDlg,IDC_CMDCANCEL);
    //    lRet = TRUE;
    //    break;
//        //PostQuitMessage(0);
//        EndDialog(hwndDlg,FALSE);
//        lRet = TRUE;
//        break;
    default:
        // let the system process the message
        lRet = FALSE;
    }

    if (!pcDlg) pcDlg = (CDialog far*)GetWindowLongPtr(hwndDlg,DWLP_USER);
    if (pcDlg)
        lRet = pcDlg->DlgProc(hwndDlg,uMsg,wParam,lParam,lRet);

    return (BOOL)lRet;
}

// ############################################################################
HRESULT CSelectNumDlg::FillRegion()
{
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    int iCurIndex;
    int iLastIndex;
    unsigned int idx;
    CPhoneBook far *pcPBTemp;
    pcPBTemp = ((CPhoneBook far *)m_dwPhoneBook);
    int iDebugIdx;
    

    //
    // 5/16/97    jmazner    Olympus #4627
    // We don't care about Toll/tollfree at this point
    //
    m_bMask &= ~MASK_TOLLFREE_BIT;
    m_fType &= ~MASK_TOLLFREE_BIT;


    // Fill in region list
    //

    SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_RESETCONTENT,0,0);
    SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_ADDSTRING,0,(LPARAM)GetSz(IDS_NATIONWIDE));
    iCurIndex = -1;        // 0xFFFFFFFF;
    m_fHasRegions = FALSE;
    for (idx=0;idx<pcPBTemp->m_cStates;idx++)
    {
        if (pcPBTemp->m_rgState[idx].dwCountryID == m_dwCountryID)
        {
            PACCESSENTRY pAE = NULL, pAELast = NULL;
            pAE = pcPBTemp->m_rgState[idx].paeFirst;
            Assert(pAE);
            pAELast = &(pcPBTemp->m_rgPhoneBookEntry[pcPBTemp->m_cPhoneBookEntries - 1]);
            while (pAELast > pAE && 
                pAE->dwCountryID == m_dwCountryID &&
                pAE->wStateID == idx+1)
            {
                if ((pAE->fType & m_bMask) == m_fType)
                    goto AddRegion;
                pAE++;
            }
            continue;

AddRegion:
            m_fHasRegions = TRUE;

            iLastIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_ADDSTRING,0,(LPARAM)&pcPBTemp->m_rgState[idx].szStateName[0]);
            iDebugIdx = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_SETITEMDATA,(WPARAM)iLastIndex,(LPARAM)idx+1);
            if ((idx+1) == m_wRegion)
            {
                iCurIndex = iLastIndex;
            }
        }
    }

    // select current region or nation wide
    //

    if (iCurIndex != -1)    // 0xFFFFFFFF
    {
        SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_SETCURSEL,(WPARAM)iCurIndex,0);
    } else {
        m_wRegion = 0;    // Nationwide
        SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_SETCURSEL,0,0);
    }

    EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMBREGION),m_fHasRegions);
    PostMessage(m_hwndDlg,WM_SHOWSTATEMSG,m_fHasRegions,0);

    hr = ERROR_SUCCESS;
    return hr;
}

// ############################################################################
CSelectNumDlg::CSelectNumDlg()
{
    m_dwCountryID = 0;
    m_wRegion = 0;
    m_dwPhoneBook = 0;
    m_szPhoneNumber[0] = '\0';
    m_szDunFile[0] = '\0';
    m_fType = 0;
    m_bMask = 0;
    m_fHasRegions = FALSE;
    m_hwndDlg = NULL;
    m_dwFlags = 0;
}

// ############################################################################
HRESULT CSelectNumDlg::FillNumber()
{
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    PACCESSENTRY pAELast, pAE = NULL;
    PACCESSENTRY pAETemp = NULL;
    CPhoneBook far *pcPBTemp;
    unsigned int idx;
    pcPBTemp = ((CPhoneBook far *)m_dwPhoneBook);
    
    // Check if we need to look up the number from the region or from the country
    //

    if (m_fHasRegions && m_wRegion)
        pAE = pcPBTemp->m_rgState[m_wRegion-1].paeFirst;
    

    // Find the Access Entries for the country
    //

    if (!pAE)
    {
        LPIDLOOKUPELEMENT pIDLookUp, pLookUpTarget;

        pLookUpTarget = (LPIDLOOKUPELEMENT)GlobalAlloc(GPTR,sizeof(IDLOOKUPELEMENT));
        Assert(pLookUpTarget);
        if (!pLookUpTarget) goto FillNumberExit;
        pLookUpTarget->dwID = m_dwCountryID;

        pIDLookUp = NULL;
        pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(pLookUpTarget,pcPBTemp->m_rgIDLookUp,
            (int)pcPBTemp->m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIDLookUpElements);
        if (pIDLookUp)
            pAE = pIDLookUp->pFirstAE;
    }

    // Fill the list for whatever AE's we found
    //
    
    SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_RESETCONTENT,0,0);
    if (pAE)
    {
        //pAELast = pcPBTemp->m_rgPhoneBookEntry + pcPBTemp->m_cPhoneBookEntries;

        //
        // first time only get the toll numbers
        // MKarki (5/12/97) - Fix for Bug#71
        //

        
        m_bMask |= MASK_TOLLFREE_BIT;
        m_fType &= TYPE_SET_TOLL;
    
        //
        // save the start of the list as we will need to traverse
        // again later
        //
        pAETemp = pAE;
        pAELast = &(pcPBTemp->m_rgPhoneBookEntry[pcPBTemp->m_cPhoneBookEntries - 1]);
        while (pAELast > pAE && pAE->dwCountryID == m_dwCountryID && pAE->wStateID == m_wRegion)
        {
            if ((pAE->fType & m_bMask) == m_fType)
            {
                wsprintf(szTemp,TEXT("%s (%s) %s"),pAE->szCity,pAE->szAreaCode,
                            pAE->szAccessNumber);
                idx = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,
                                                CB_ADDSTRING,0,
                                                (LPARAM)((LPTSTR) &szTemp[0]));
                if (idx == -1) goto FillNumberExit;
                SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_SETITEMDATA,
                                    (WPARAM)idx,(LPARAM)pAE);
            }
            pAE++;
        }
        



        //
        // now get the toll free numbers
        // MKarki (5/12/97) - Fix for Bug#71
        //

        m_bMask |= MASK_TOLLFREE_BIT;
        m_fType |= TYPE_SET_TOLLFREE;
        pAE = pAETemp;
        pAELast = &(pcPBTemp->m_rgPhoneBookEntry[pcPBTemp->m_cPhoneBookEntries - 1]);
        while (pAELast > pAE && pAE->dwCountryID == m_dwCountryID && pAE->wStateID == m_wRegion)
        {
            if ((pAE->fType & m_bMask) == m_fType)
            {
                wsprintf(szTemp,TEXT("%s (%s) %s"),pAE->szCity,pAE->szAreaCode,
                            pAE->szAccessNumber);
            idx = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,
                                                CB_ADDSTRING,0,
                                                (LPARAM)((LPTSTR) &szTemp[0]));
                if (idx == -1) goto FillNumberExit;
                SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_SETITEMDATA,
                                    (WPARAM)idx,(LPARAM)pAE);
            }
            pAE++;
        }



        // Select the first item
        //

        if (SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_SETCURSEL,0,0) == CB_ERR)
                EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),FALSE);
        else
                EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),TRUE);
        hr = ERROR_SUCCESS;
    }
FillNumberExit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\suapi.h ===
// ############################################################################
//#include "ras.h"
#define cbDataCenter (MAX_PATH+1)    // max length of data center string

// ############################################################################
class CDialog
{
public:
    void far * operator new( size_t cb ) { return GlobalAlloc(GPTR,cb); };
    void operator delete( void far * p ) {GlobalFree(p); };

    CDialog() {};
    ~CDialog() {};
    virtual LRESULT DlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT)=0;
};

// ############################################################################
class CSelectNumDlg : public CDialog
{
public:
    CSelectNumDlg();
    LRESULT DlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT);
    DWORD m_dwCountryID;
    DWORD m_dwCountryIDOrg;
    WORD m_wRegion;
    DWORD_PTR m_dwPhoneBook;
    TCHAR m_szPhoneNumber[RAS_MaxPhoneNumber+1];
    TCHAR m_szDunFile[cbDataCenter];
    BYTE m_fType;
    BYTE m_bMask;
    DWORD m_dwFlags;
private:
    BOOL FHasPhoneNumbers(LPLINECOUNTRYENTRY pLCE);
    BOOL m_fHasRegions;
    HWND m_hwndDlg;
    HRESULT FillRegion();
    HRESULT FillNumber();
};

// ############################################################################
/********** 1/9/96 jmazner Normandy #13185
class CAccessNumDlg : public CDialog
{
public:
    CAccessNumDlg();
    ~CAccessNumDlg() {};
    LRESULT            DlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT);
    DWORD            m_dwPhoneBook;
    PACCESSENTRY    *m_rgAccessEntry;
    WORD            m_wNumber;
    DWORD            m_dwCountryID;
    WORD            m_wRegion;
    BYTE            m_fType;
    BYTE            m_bMask;
    TCHAR    m_szPrimary[RAS_MaxPhoneNumber];
    TCHAR    m_szSecondary[RAS_MaxPhoneNumber];
    TCHAR    m_szDunPrimary[cbDataCenter + sizeof('\0')];
    TCHAR    m_szDunSecondary[cbDataCenter + sizeof('\0')];
};    
**************/

// ############################################################################
#ifdef WIN16
extern "C" BOOL CALLBACK __export PhbkGenericDlgProc(
#else
extern "C" __declspec(dllexport) INT_PTR CALLBACK PhbkGenericDlgProc(
#endif
    HWND  hwndDlg,    // handle to dialog box
    UINT  uMsg,    // message
    WPARAM  wParam,    // first message parameter
    LPARAM  lParam     // second message parameter
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\win32fn.h ===
#ifndef _WIN32FN_H_

#define _WIN32FN_H_

#include <win16def.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// Defines for 32-bit file io
// 
//#define INVALID_HANDLE_VALUE			-1

#define GENERIC_READ                     (0x80000000L)
#define GENERIC_WRITE                    (0x40000000L)
#define GENERIC_EXECUTE                  (0x20000000L)
#define GENERIC_ALL                      (0x10000000L)

#define FILE_FLAG_WRITE_THROUGH         0x80000000
#define FILE_FLAG_OVERLAPPED            0x40000000
#define FILE_FLAG_NO_BUFFERING          0x20000000
#define FILE_FLAG_RANDOM_ACCESS         0x10000000
#define FILE_FLAG_SEQUENTIAL_SCAN       0x08000000
#define FILE_FLAG_DELETE_ON_CLOSE       0x04000000
#define FILE_FLAG_BACKUP_SEMANTICS      0x02000000
#define FILE_FLAG_POSIX_SEMANTICS       0x01000000

#define CREATE_NEW          1
#define CREATE_ALWAYS       2
#define OPEN_EXISTING       3
#define OPEN_ALWAYS         4
#define TRUNCATE_EXISTING   5

#define FILE_SHARE_READ                 0x00000001  
#define FILE_SHARE_WRITE                0x00000002  
#define FILE_SHARE_DELETE               0x00000004  

#define MOVEFILE_REPLACE_EXISTING		0x00000001
#define MOVEFILE_COPY_ALLOWED			0x00000002
#define MOVEFILE_DELAY_UNTIL_REBOOT		0x00000004
#define MOVEFILE_WRITE_THROUGH			0x00000008


	
HANDLE CreateFile(
    LPCTSTR lpFileName,	// pointer to name of the file 
    DWORD dwDesiredAccess,	// access (read-write) mode 
    DWORD dwShareMode,	// share mode 
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,	// pointer to security descriptor 
    DWORD dwCreationDistribution,	// how to create 
    DWORD dwFlagsAndAttributes,	// file attributes 
    HANDLE hTemplateFile 	// handle to file with attributes to copy  
   ); 

BOOL WriteFile(
    HANDLE hFile,	// handle to file to write to 
    LPCVOID lpBuffer,	// pointer to data to write to file 
    DWORD nNumberOfBytesToWrite,	// number of bytes to write 
    LPDWORD lpNumberOfBytesWritten,	// pointer to number of bytes written 
    LPOVERLAPPED lpOverlapped 	// pointer to structure needed for overlapped I/O
   );

BOOL MoveFileEx(
    LPCTSTR lpExistingFileName,	// address of name of the existing file  
    LPCTSTR lpNewFileName,	// address of new name for the file 
    DWORD dwFlags 	// flag to determine how to move file 
   );
   
BOOL CloseHandle(
    HANDLE hObject 	// handle to object to close  
   );


#ifdef __cplusplus
}
#endif // __cplusplus   
#endif // _WIN32FN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwphbk\win32fn.c ===
#include "pch.h"
#include <win16def.h>
#include <win32fn.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>

//extern LPSTR g_lpszCmdLine;   

HANDLE CreateFile(
    LPCTSTR lpFileName,	// pointer to name of the file 
    DWORD dwDesiredAccess,	// access (read-write) mode 
    DWORD dwShareMode,	// share mode 
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,	// pointer to security descriptor 
    DWORD dwCreationDistribution,	// how to create 
    DWORD dwFlagsAndAttributes,	// file attributes 
    HANDLE hTemplateFile 	// handle to file with attributes to copy  
   )
{
	int oflag = 0, pmode = 0, iHandle = -1;
	
    if ((dwDesiredAccess & GENERIC_READ) && (dwDesiredAccess & GENERIC_WRITE))
    	oflag = _O_RDWR;
    else if (dwDesiredAccess & GENERIC_WRITE)
    	oflag = _O_WRONLY;
    else
    	oflag = _O_RDONLY;							 
    
    switch (dwCreationDistribution)
    {
    	case CREATE_NEW:
    		oflag |= (_O_CREAT | _O_EXCL);
    		break;
    	case CREATE_ALWAYS:
    	case TRUNCATE_EXISTING:
    		oflag |= _O_TRUNC;
    		break;
    	case OPEN_ALWAYS:
    		oflag |= _O_CREAT;
    }
    
    if (dwShareMode & FILE_SHARE_READ)
    	pmode |= _S_IREAD;
    if (dwShareMode & FILE_SHARE_WRITE)
    	pmode |= _S_IWRITE;
	
	iHandle = _open(lpFileName, oflag, pmode);
	if (-1 == iHandle)
		return (HANDLE) INVALID_HANDLE_VALUE;
	else
		return (HANDLE) iHandle;
}


BOOL WriteFile(
    HANDLE hFile,	// handle to file to write to 
    LPCVOID lpBuffer,	// pointer to data to write to file 
    DWORD nNumberOfBytesToWrite,	// number of bytes to write 
    LPDWORD lpNumberOfBytesWritten,	// pointer to number of bytes written 
    LPOVERLAPPED lpOverlapped 	// pointer to structure needed for overlapped I/O
   )
{
	*lpNumberOfBytesWritten = (DWORD) _write(hFile, lpBuffer, 
												(unsigned int)nNumberOfBytesToWrite);
	return (*lpNumberOfBytesWritten == nNumberOfBytesToWrite);
}    


BOOL MoveFileEx(
    LPCTSTR lpExistingFileName,	// address of name of the existing file  
    LPCTSTR lpNewFileName,	// address of new name for the file 
    DWORD dwFlags 	// flag to determine how to move file 
   )
{
	//
	// BUGBUG: Try renaming first and then delete file
	//
	if (dwFlags & MOVEFILE_REPLACE_EXISTING)
	{
		if (_access(lpNewFileName, 0) == 0)
			remove(lpNewFileName);
	}
	
	return (rename(lpExistingFileName, lpNewFileName) == 0);
}
   


BOOL CloseHandle(
    HANDLE hObject 	// handle to object to close  
   )
{
	// We should check if this is really a file hande...
	
	return (!_close(hObject));
}



#if 0
DWORD SearchPath(
    LPCTSTR lpPath,	// address of search path 
    LPCTSTR lpFileName,	// address of filename 
    LPCTSTR lpExtension,	// address of extension 
    DWORD nBufferLength,	// size, in characters, of buffer 
    LPTSTR lpBuffer,	// address of buffer for found filename 
    LPTSTR far *lpFilePart 	// address of pointer to file component 
   )
{
	LPSTR pszPath;
	LPSTR pszFile;
	LPSTR pEnv;
	int len = 0, prevlen;
    
	pszPath = (LPSTR)_fcalloc(1, MAX_PATH*3);
	pszFile = (LPSTR)_fcalloc(1, MAX_PATH);

    //
    // Create an environment variable for searchenv to use.
    //
    strcpy(pszPath, ICW_PATH);
    strcat(pszPath, "=");
    len = strlen(pszPath);
	if (NULL == lpPath)
	{	
		//
		// Directory from which the application laoded
		//
/*		prevlen = len;
		_fstrcpy(szPath+len, g_lpszCmdLine);
		for ( ; szPath[len] != ' ' && szPath[len] != '\0'; len++) ;
		for ( ; len > prevlen+1 && szPath[len] != '\\'; len--) ;
		szPath[len++] = ';';
*/		
		//
		// Windows system directory
		//
	    len += GetSystemDirectory(pszPath+len, MAX_PATH);
	    pszPath[len++] = ';';
	    
	    //
	    // Windows directory
	    //
	    len += GetWindowsDirectory(pszPath+len, MAX_PATH);
	    
	    //
	    // PATH environment variable
	    //
	    if ((pEnv = getenv("PATH")) != NULL)
	    {
	    	pszPath[len++] = ';';
	    	for ( ; *pEnv; pEnv++) pszPath[len++] = *pEnv;
	    }
    	pszPath[len] = '\0';
	}
	else
	{
		lstrcpy(pszPath+len, lpPath);
	}
	
	//
	// Set the environment variable so _searchenv can use it
	//
	_putenv(pszPath);
	
	//
	// Append the extension to the file, if necessary
	//
	lstrcpy(pszFile, lpFileName);
	len = lstrlen(pszFile);
	if ((pszFile[len] != '.') && (lpExtension != NULL))
		lstrcat(pszFile, lpExtension);
		
    _searchenv(pszFile, ICW_PATH, lpBuffer);
	                
	//
	// Clear the temporary environment variable before freeing the memory
	//
	lstrcpy(pszFile, ICW_PATH);
	lstrcat(pszFile, "=");
	_putenv(pszFile);

	_ffree(pszFile);
	_ffree(pszPath);
	
	return (lstrlen(lpBuffer));
}

#endif //0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwrmind\icwrmind.h ===
#pragma once

LRESULT WINAPI	 MainWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK SignUpDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwrmind\mcreg.cpp ===
#define  STRICT
#include "mcReg.h"

//---------------------------------------------------------------------------

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//---------------------------------------------------------------------------
// ctor
//---------------------------------------------------------------------------
CMcRegistry::CMcRegistry()
 :	m_hkey(NULL)
{
}

//---------------------------------------------------------------------------
// dtor
//---------------------------------------------------------------------------
CMcRegistry::~CMcRegistry()
{
	if (m_hkey)
	{
		CloseKey();
	}
}


//---------------------------------------------------------------------------
// OpenKey
//---------------------------------------------------------------------------
bool
CMcRegistry::OpenKey(
	HKEY hkeyStart, LPCTSTR strKey, REGSAM sam /* = KEY_READ | KEY_WRITE */)
{
	long lErr = ::RegOpenKeyEx(hkeyStart, strKey, 0, sam, &m_hkey);
	if (ERROR_SUCCESS != lErr)
	{
		m_hkey = NULL;
	}

	return ERROR_SUCCESS == lErr;
}


//---------------------------------------------------------------------------
// CreateKey
//---------------------------------------------------------------------------
bool
CMcRegistry::CreateKey(HKEY hkeyStart, LPCTSTR strKey)
{
	// You shouldn't have opened now.
	if (m_hkey)
	{
		_ASSERT(!m_hkey);
		return false;
	}

	long lErr = ::RegCreateKey(hkeyStart, strKey, &m_hkey);
	if (ERROR_SUCCESS != lErr)
	{
		m_hkey = NULL;
		_ASSERT(false);
	}

	return ERROR_SUCCESS == lErr;
}


//---------------------------------------------------------------------------
// CloseKey
//---------------------------------------------------------------------------
bool
CMcRegistry::CloseKey()
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	long lErr = ::RegCloseKey(m_hkey);
	if (ERROR_SUCCESS != lErr)
	{
		m_hkey = NULL;
		_ASSERT(false);
	}

	return ERROR_SUCCESS == lErr;
	
}


//---------------------------------------------------------------------------
// GetValue
//---------------------------------------------------------------------------
bool
CMcRegistry::GetValue(LPCTSTR strValue, LPTSTR strData, ULONG nBufferSize)
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	DWORD dwType;
	ULONG cbData = nBufferSize;

	long lErr = ::RegQueryValueEx(
		m_hkey, strValue, NULL, &dwType,
		reinterpret_cast<PBYTE>(strData), &cbData);

	return ERROR_SUCCESS == lErr && REG_SZ == dwType;
}


//---------------------------------------------------------------------------
// GetValue
//---------------------------------------------------------------------------
bool
CMcRegistry::GetValue(LPCTSTR strValue, DWORD& rdw)
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	DWORD dwType;
	ULONG cbData = sizeof(rdw);
	long lErr = ::RegQueryValueEx(
		m_hkey, strValue, NULL, &dwType,
		reinterpret_cast<PBYTE>(&rdw), &cbData);

	return ERROR_SUCCESS == lErr && REG_DWORD == dwType;
}


//---------------------------------------------------------------------------
// SetValue
//---------------------------------------------------------------------------
bool
CMcRegistry::SetValue(LPCTSTR strValue, LPCTSTR strData)
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	long lErr = ::RegSetValueEx(
		m_hkey, strValue, 0, REG_SZ, 
		reinterpret_cast<const BYTE*>(strData), sizeof(TCHAR)*(lstrlen(strData) + 1));

	if (ERROR_SUCCESS != lErr)
	{
		_ASSERT(false);
	}

	return ERROR_SUCCESS == lErr;
}


//---------------------------------------------------------------------------
// SetValue
//---------------------------------------------------------------------------
bool
CMcRegistry::SetValue(LPCTSTR strValue, DWORD rdw)
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	long lErr = ::RegSetValueEx(
		m_hkey, strValue, 0, REG_DWORD,
		reinterpret_cast<PBYTE>(&rdw), sizeof(rdw));

	if (ERROR_SUCCESS != lErr)
	{
		_ASSERT(false);
	}

	return ERROR_SUCCESS == lErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwrmind\mcreg.h ===
#pragma once
#define  STRICT
#include <windows.h>
#include <crtdbg.h>

class CMcRegistry
{
public:
	CMcRegistry();
	~CMcRegistry();

public:
	bool OpenKey(HKEY hkeyStart, LPCTSTR strKey, REGSAM sam = KEY_READ | KEY_WRITE);
	bool CreateKey(HKEY hkeyStart, LPCTSTR strKey);
	bool CloseKey();

	bool GetValue(LPCTSTR strValue, LPTSTR strData, ULONG nBufferSize);
	bool GetValue(LPCTSTR strValue, DWORD& rdw);

	bool SetValue(LPCTSTR strValue, LPCTSTR strData);
	bool SetValue(LPCTSTR strValue, DWORD rdw);

private:
	HKEY	m_hkey;
};

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwrmind\regdata.h ===
#pragma once
#include "mcReg.h"
#define MAX_ISPMSGSTRING		    560

DWORD			GetWakeupInterval();
BOOL			IsApplicationVisible();
const TCHAR*		GetISPConnectionName();
const TCHAR*		GetISPSignupUrl();
const TCHAR*		GetISPSignupUrlTrialOver();
DWORD			GetDialogTimeout();
void			SetupRunOnce();
void			RemoveRunOnce();
const TCHAR*		GetISPName();
const TCHAR*		GetISPPhone();
const TCHAR*		GetISPMessage();
int				GetISPTrialDays();
time_t			GetTrialStartDate();
bool			OpenIcwRmindKey(CMcRegistry &reg);
void			ClearCachedData();
void			ResetCachedData();
int				GetTotalNotifications();
void			IncrementTotalNotifications();
void			ResetTrialStartDate(time_t timeNewStartDate);
void 			DeleteAllRegistryData();
BOOL 			IsSignupSuccessful();
void			RemoveTrialConvertedFlag();
void			SetStartDateString(time_t timeStartDate);
void			SetIERunOnce();
void			RemoveIERunOnce();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwrmind\icwrmind.cpp ===
//-----------------------------------------------------------------------------
//  This exe runs in the background and wakes up every so often to do it's work.
//  When it wakes up it checks to see how much time the user has left on their
//  free ISP subscription.  At certain intervals it will tell the user time
//  is running out and will give the user the chance to signup for rea.
//-----------------------------------------------------------------------------
#define  STRICT
#include <windows.h>
#include <stdlib.h>
#include <stdarg.h>
#include <crtdbg.h>
#include <winbase.h>
#include <ras.h>
#include <time.h>
#include "IcwRmind.h"
#include "resource.h"
#include "RegData.h"


//-----------------------------------------------------------------------------
//  Forward Declarations
//-----------------------------------------------------------------------------
BOOL            InitializeApp (void);
BOOL            CheckForRASConnection();
void            CheckForSignupAttempt();
int             GetISPTrialDaysLeft();
void            ShutDownForGood();
void            PerformTheSignup();
void            CenterTheWindow(HWND hWnd);
DWORD           GetTickDelta();
void            AttemptTrialOverSignup();


//-----------------------------------------------------------------------------
//  Defines
//-----------------------------------------------------------------------------
#define TIMER_DIALOG_STAYUP         319     // Wake up timer to do work.
#define TIMER_RUNONCE_SETUP         320
#define TIME_RUNONCE_INTERVAL       30000   // 30 seconds
#define MAXRASCONNS                 8
#define MAX_DIALOGTEXT              512
#define MAX_ATTEMPTCOUNTER          20
#define LONG_WAKEUP_INTERVAL        3600000 // 1 hour

//-----------------------------------------------------------------------------
//  Global Handles and other defines
//-----------------------------------------------------------------------------
HINSTANCE   g_hModule;              // Process Instance handle
HWND        g_hwndMain;             // Main window handle
bool        g_bDoNotRemindAgain;    // Used by signup dialog.
time_t      g_timeAppStartUp;
DWORD       g_dwTickAppStartUp;
int         g_nAttemptCounter;
DWORD       g_dwMasterWakeupInterval;
bool        g_bDialogExpiredMode = false;
static const TCHAR* g_szTrialStartEvent = TEXT("_319IcwTrialStart913_");
static const TCHAR* g_szRunOnceEvent = TEXT("_319IcwRunOnce913_");


//-----------------------------------------------------------------------------
//  WinMain
//-----------------------------------------------------------------------------
int WINAPI WinMainT(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine,
                    int nCmdShow)
{
    MSG msg;
    HANDLE hEventTrialStart = NULL;
    HANDLE hEventRunOnce = NULL;
    DWORD dwRetCode;
    bool bStartedViaWizard = false;

        // If there is a command line then see who started us.
    if (lstrlen(lpCmdLine))
    {
            // The RunOnce registry stuff will freeze up until we return.  Hence
            // the RunOnce setting in the registry must have some value for the
            // command line.  If we see any data we will spawn a second instance
            // of ourselves and exit this instance.
        if (0 == lstrcmpi(TEXT("-R"), lpCmdLine))
        {
            LPTSTR lpszFileName = new TCHAR[_MAX_PATH + 1];

            if (GetModuleFileName(GetModuleHandle(NULL), lpszFileName, _MAX_PATH + 1))
            {
                STARTUPINFO          sui;
                PROCESS_INFORMATION  pi;
                
                sui.cb               = sizeof (STARTUPINFO);
                sui.lpReserved       = 0;
                sui.lpDesktop        = NULL;
                sui.lpTitle          = NULL;
                sui.dwX              = 0;
                sui.dwY              = 0;
                sui.dwXSize          = 0;
                sui.dwYSize          = 0;
                sui.dwXCountChars    = 0;
                sui.dwYCountChars    = 0;
                sui.dwFillAttribute  = 0;
                sui.dwFlags          = 0;
                sui.wShowWindow      = 0;
                sui.cbReserved2      = 0;
                sui.lpReserved2      = 0;

                BOOL ret = CreateProcess (lpszFileName, NULL, NULL, NULL,
                        FALSE, DETACHED_PROCESS,
                        NULL, NULL, &sui, &pi );
                _ASSERT(ret);

                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
            }

            delete [] lpszFileName;
            return 0;
        }
            // See if this is the start of a new trial.
        else if (0 == lstrcmpi(TEXT("-T"), lpCmdLine))
        {
            bStartedViaWizard = true;
            RemoveTrialConvertedFlag();
        }
    }

        // If we got this far let's create the named event and find out if we
        // are the first instance to run or if there is another instance already
        // running.
    hEventTrialStart = CreateEvent(NULL, FALSE, FALSE, g_szTrialStartEvent);
    if (hEventTrialStart)
    {
            // See if the named event already exists.  If it does then another 
            // instance of the IcwRmind exe is already running.  Signal the event
            // and exit.
        if (ERROR_ALREADY_EXISTS == GetLastError())
        {
                // If we were started via the wizard tell the other instance
                // to reset it's trial start data.
            if (bStartedViaWizard)
            {
                SetEvent(hEventTrialStart);
            }
                // Otherwise assume that RunOnce started us again.  In this case
                // Open the existing RunOnce named event and signal it.  This
                // tells the running instance to place us back into RunOnce key.
            else
            {
                hEventRunOnce = OpenEvent(EVENT_MODIFY_STATE, false, g_szRunOnceEvent);
                if (hEventRunOnce)
                {
                    SetEvent(hEventRunOnce);
                    CloseHandle(hEventRunOnce);
                }
            }

            CloseHandle(hEventTrialStart);
            return 0;
        }
    }
    else
    {
        _ASSERT(FALSE);
        return 0;
    }

    hEventRunOnce = CreateEvent(NULL, FALSE, FALSE, g_szRunOnceEvent);
    if (!hEventRunOnce)
    {
        CloseHandle(hEventTrialStart);
        return 0;
    }

        // If this flag is true and we got this far then we are the first
        // instance to run after being started by the wizard.  Let's clear
        // registry data just in case there is old stuff in there.
    if (bStartedViaWizard)
    {
        ResetCachedData();
    }

        // Check the registry and see if the user has successfully signed up.
        // If so then shut down for good.
    if (IsSignupSuccessful())
    {
        ShutDownForGood();
        CloseHandle(hEventTrialStart);
        CloseHandle(hEventRunOnce);
        return 0;
    }

    g_hModule = hInstance;
    ClearCachedData();  // This initializes cache data to zero.
    g_nAttemptCounter = 0;

    time(&g_timeAppStartUp);
    g_dwTickAppStartUp = GetTickCount();

        // If the connectoid entry name does not exist in the registry then
        // we will shut down for good.
    const TCHAR* pcszConnectName = GetISPConnectionName();
    if (NULL == pcszConnectName || 0 == lstrlen(pcszConnectName))
    {
        ShutDownForGood();
        CloseHandle(hEventTrialStart);
        CloseHandle(hEventRunOnce);
        return 0;
    }

        // If we cannot get or create the start time then something is really
        // bad.  We will stop never to be run again.
    if (0 == GetTrialStartDate())
    {
        ShutDownForGood();
        CloseHandle(hEventTrialStart);
        CloseHandle(hEventRunOnce);
        return 0;
    }

        // Initialize and create the window class and window.
    if (!InitializeApp())
    {
        _ASSERT(FALSE);
        CloseHandle(hEventTrialStart);
        CloseHandle(hEventRunOnce);
        return 0;
    }

        // Testers can make the application visible via the registry.
    if (IsApplicationVisible())
    {
        ShowWindow(g_hwndMain, nCmdShow);
    }

        // Let's initialize the wake up interval.  If we are in the first half
        // of the trial then we don't want to wake up very often.  As we get
        // closer to the half way point we want to wake up more ofter to do
        // our polling.
    if (GetISPTrialDaysLeft() > (int)((GetISPTrialDays() / 2) + 1))
    {
            // Don't start polling more often until the day before the
            // half way point.
        g_dwMasterWakeupInterval = LONG_WAKEUP_INTERVAL;
    }
    else
    {
            // Use this method because the wake up interval may be in the
            // registry for testing.
        g_dwMasterWakeupInterval = GetWakeupInterval();
    }

        // Set a timer to re-setup the run once data in the registry.
        // If we do this too soon the intial run once startup will create
        // us multiple times.
    SetTimer(g_hwndMain, TIMER_RUNONCE_SETUP, TIME_RUNONCE_INTERVAL, NULL);

    HANDLE hEventList[2];
    hEventList[0] = hEventTrialStart;
    hEventList[1] = hEventRunOnce;

    while (TRUE)
    {
            // We will wait on window messages and also the named event.
        dwRetCode = MsgWaitForMultipleObjects(2, &hEventList[0], FALSE, g_dwMasterWakeupInterval, QS_ALLINPUT);

            // Determine why we came out of MsgWaitForMultipleObjects().  If
            // we timed out then let's do some TrialWatcher work.  Otherwise
            // process the message that woke us up.
        if (WAIT_TIMEOUT == dwRetCode)
        {
                // If we are still in the long wake up interval do a quick check
                // to see if we should switch to the shorter interval.
            if (LONG_WAKEUP_INTERVAL == g_dwMasterWakeupInterval)
            {
                if (GetISPTrialDaysLeft() <= (int)((GetISPTrialDays() / 2) + 1))
                {
                    g_dwMasterWakeupInterval = GetWakeupInterval();
                }
            }

            CheckForSignupAttempt();
        }
        else if (WAIT_OBJECT_0 == dwRetCode)
        {
                // If we get in here then the named event was signaled meaning
                // a second instance started up.  This means the user has 
                // signed up for a new trial with somebody else.  Clear
                // all persistant registry data.
            ResetCachedData();

                // Reset the trial start date.  If this fails then something
                // is really messed up in the registry.
            if (0 == GetTrialStartDate())
            {
                ShutDownForGood();
                break;
            }
        }
        else if (WAIT_OBJECT_0 + 1== dwRetCode)
        {
                // Signaled by the RunOnce event.  We must reset the timer to
                // place ourselves back into RunOnce.
            KillTimer(g_hwndMain, TIMER_RUNONCE_SETUP); // In case it is already running.
            SetTimer(g_hwndMain, TIMER_RUNONCE_SETUP, TIME_RUNONCE_INTERVAL, NULL);
        }
        else if (WAIT_OBJECT_0 + 2 == dwRetCode)
        {
                // 0 is returned if no message retrieved.
            if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if (WM_QUIT == msg.message)
                {
                    break;
                }
                else
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }
    }

    CloseHandle(hEventTrialStart);
    CloseHandle(hEventRunOnce);
    return 1;

    UNREFERENCED_PARAMETER(lpCmdLine);
    UNREFERENCED_PARAMETER(hPrevInstance);
}


//-----------------------------------------------------------------------------
//  InitializeApp
//-----------------------------------------------------------------------------
BOOL InitializeApp(void)
{
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = MainWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_hModule;
    wc.hIcon            = NULL;
    wc.hCursor          = LoadCursor(g_hModule, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = TEXT("IcwRmindClass");

    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }

        // Create the main window.  This window will stay hidden during the
        // life of the application.
    g_hwndMain = CreateWindow(TEXT("IcwRmindClass"),
                            TEXT("IcwRmind"),
                            WS_OVERLAPPEDWINDOW,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            100,
                            100,
                            HWND_DESKTOP,
                            NULL,
                            g_hModule,
                            NULL);

    if (g_hwndMain == NULL)
    {
        _ASSERT(FALSE);
        return(FALSE);
    }

    return(TRUE);
}


//-----------------------------------------------------------------------------
//  MainWndProc
//-----------------------------------------------------------------------------
LRESULT WINAPI MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_CREATE:
        {
            return 0;
        }
        
        case WM_TIMER:
        {
            KillTimer(g_hwndMain, TIMER_RUNONCE_SETUP);
            SetupRunOnce();

                // Wait for trial days left to drop below -1.  The trail to
                // do the trial over sign up.
            if (GetISPTrialDaysLeft() < -1)
            {
                AttemptTrialOverSignup();
            }

            return 1;
        }

        case WM_TIMECHANGE:
        {
                // Calculate the relative current time.  We do not want to 
                // grab the system time because that is the new time after
                // the time change.  Tick count is in milleseconds so we
                // convert that to seconds by dividing by 1000.
            DWORD dwTickDelta = GetTickDelta();
            
                // If tick count rolls around GetTickDelta() will modify app 
                // start date, so get the tick delta before actually using it.
            time_t timeRelativeCurrent = g_timeAppStartUp + (dwTickDelta / 1000);

                // Determine the delta in seconds between the relative
                // system time and the new time set by the user.
            time_t timeCurrent;
            time(&timeCurrent);

                // Delta seconds will be negative if the user has turned
                // the clock back.
            time_t timeDeltaSeconds = timeCurrent - timeRelativeCurrent;
            time_t timeNewTrialStartDate = GetTrialStartDate() + timeDeltaSeconds;

#ifdef _DEBUG
            TCHAR buf[255];
            OutputDebugString(TEXT("-------------------\n"));
            time_t timeOldStart = GetTrialStartDate();
            wsprintf(buf, TEXT("Old Start:  %s\n"), ctime(&timeOldStart));
            OutputDebugString(buf);
            wsprintf(buf, TEXT("New Start:  %s\n"), ctime(&timeNewTrialStartDate));
            OutputDebugString(buf);
            OutputDebugString(TEXT("-------------------\n"));
#endif

                // Now reset the trial start date and the application start
                // date.  Also reset the app start date and app start tick
                // count.  This will be our new frame of reference for 
                // calculating relative dates.
            ResetTrialStartDate(timeNewTrialStartDate);
            g_timeAppStartUp = timeCurrent;
            g_dwTickAppStartUp = GetTickCount();

            return 1;
        }

        case WM_DESTROY:
        {
            PostQuitMessage(0);
            return 1;
        }

        default:
        {
            return DefWindowProc(hwnd, message, wParam, lParam);
        }
    }
}


//-----------------------------------------------------------------------------
//  SignUpDialogProc
//-----------------------------------------------------------------------------
INT_PTR CALLBACK SignUpDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HICON hIcon = NULL;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            TCHAR bufOut[MAX_DIALOGTEXT];
            TCHAR bufFormat[MAX_DIALOGTEXT];
            TCHAR *bufAll = new TCHAR[MAX_DIALOGTEXT * 2 + MAX_ISPMSGSTRING];

            g_bDoNotRemindAgain = false;

                // This dialog has two modes.  Set the text the correct way.
            if (g_bDialogExpiredMode)
            {
                if (LoadString(g_hModule, IDS_EXPIRED_DLG_TITLE, bufFormat, MAX_DIALOGTEXT))
                {
                    SendMessage(hDlg, WM_SETTEXT, 0, (LPARAM) bufFormat);
                }

                if (bufAll)
                {
                    if (LoadString(g_hModule, IDS_EXPIRED_TEXT1, bufFormat, MAX_DIALOGTEXT))
                    {
                        wsprintf(bufOut, bufFormat, GetISPName());
                        lstrcpy(bufAll, bufOut);
                        lstrcat(bufAll, TEXT("\n\n"));
                    }

                    if(*GetISPMessage() != '\0')
                    {
                        lstrcat(bufAll, GetISPMessage());
                        lstrcat(bufAll, TEXT("\n\n"));
                    }

                    if (LoadString(g_hModule, IDS_EXPIRED_TEXT2, bufFormat, MAX_DIALOGTEXT))
                    {
                        wsprintf(bufOut, bufFormat, GetISPName(), GetISPName(), GetISPPhone());
                        lstrcat(bufAll, bufOut);
                    }

                    SetDlgItemText(hDlg, IDC_TEXT1, bufAll);

                    ShowWindow(GetDlgItem(hDlg, IDC_DONTREMIND), SW_HIDE);

                    if (LoadString(g_hModule, IDS_DONOTSIGNUP, bufOut, MAX_DIALOGTEXT))
                    {
                        SetDlgItemText(hDlg, IDCANCEL, bufOut);
                    }
                }
                
            }
            else
            {
                    // Set up the text in the dialog box.
                if (LoadString(g_hModule, IDS_DLG_TITLE, bufFormat, MAX_DIALOGTEXT))
                {
                    wsprintf(bufOut, bufFormat, GetISPTrialDaysLeft());
                    SendMessage(hDlg, WM_SETTEXT, 0, (LPARAM) bufOut);
                }

                if (bufAll)
                {
                    if (LoadString(g_hModule, IDS_TEXT1, bufFormat, MAX_DIALOGTEXT))
                    {
                        wsprintf(bufOut, bufFormat, GetISPName(), GetISPTrialDaysLeft());
                        lstrcpy(bufAll, bufOut);
                        lstrcat(bufAll, TEXT("\n\n"));
                    }

                    if(*GetISPMessage() != '\0')
                    {
                        lstrcat(bufAll, GetISPMessage());
                        lstrcat(bufAll, TEXT("\n\n"));
                    }

                    if (LoadString(g_hModule, IDS_TEXT2, bufFormat, MAX_DIALOGTEXT))
                    {
                        wsprintf(bufOut, bufFormat, GetISPName(), GetISPName(), GetISPPhone());
                        lstrcat(bufAll, bufOut);
                    }
                    SetDlgItemText(hDlg, IDC_TEXT1, bufAll);
                }

                    // If there are 0 days left then don't give user a change
                    // to say remind me later.
                if (0 == GetISPTrialDaysLeft())
                {
                    ShowWindow(GetDlgItem(hDlg, IDC_DONTREMIND), SW_HIDE);

                    if (LoadString(g_hModule, IDS_DONOTSIGNUP, bufOut, MAX_DIALOGTEXT))
                    {
                        SetDlgItemText(hDlg, IDCANCEL, bufOut);
                    }
                }
            }

                // Set the timer for how long the dialog will stay up before
                // removing itself.
            SetTimer(hDlg, TIMER_DIALOG_STAYUP, GetDialogTimeout(), NULL);
            CenterTheWindow(hDlg);
            if (bufAll)
            {
                delete [] bufAll;
            }


            return TRUE;
        }

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                    // IDOK is the Sign up now button.
                case IDOK:
                {
                    KillTimer(hDlg, TIMER_DIALOG_STAYUP);
                    EndDialog(hDlg, wParam);
                    break;
                }

                    // If the checkbox is clicked then toggle the button text for the
                    // signup later button.
                case IDC_DONTREMIND:
                {
                    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_DONTREMIND))
                    {
                        TCHAR bufOut[MAX_DIALOGTEXT];
                        if (LoadString(g_hModule, IDS_DONOTREMIND, bufOut, MAX_DIALOGTEXT))
                        {
                            SetDlgItemText(hDlg, IDCANCEL, bufOut);
                        }
                    }
                    else
                    {
                        TCHAR bufOut[MAX_DIALOGTEXT];
                        if (LoadString(g_hModule, IDS_SIGNUPLATER, bufOut, MAX_DIALOGTEXT))
                        {
                            SetDlgItemText(hDlg, IDCANCEL, bufOut);
                        }
                    }

                    break;
                }

                    // Otherwise assume they hit the close button or the sign up later
                    // button.
                default:
                {
                        // See if the user never wants reminded again.
                    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_DONTREMIND))
                    {
                        g_bDoNotRemindAgain = true;
                    }

                    KillTimer(hDlg, TIMER_DIALOG_STAYUP);
                    EndDialog(hDlg, wParam);
                    break;
                }
            }

            break;
        }

            // No user interaction has occurred.  remove the dialog but do not count
            // this as an attempt to sign up.
        case WM_TIMER:
        {
            KillTimer(hDlg, TIMER_DIALOG_STAYUP);
            EndDialog(hDlg, IDABORT);
            break;
        }

        case WM_PAINT:
        {
            HDC             hDC;
            PAINTSTRUCT     ps;
            HICON           hIcon;
            HWND            hWndRect;
            RECT            rect;
            POINT           ptUpperLeft;

            hDC = BeginPaint(hDlg, &ps);

            hIcon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_QUESTION));

            if (hIcon)
            {
                hWndRect = GetDlgItem(hDlg, IDC_ICON1);
                GetWindowRect(hWndRect, &rect);

                ptUpperLeft.x = rect.left;
                ptUpperLeft.y = rect.top;
                ScreenToClient(hDlg, &ptUpperLeft);

                DrawIcon(hDC, ptUpperLeft.x, ptUpperLeft.y, hIcon);
            }

            EndPaint(hDlg, &ps);
            break;
        }
    }

    return FALSE;

    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(hDlg);
}


//-----------------------------------------------------------------------------
//  CheckForRASConnection
//-----------------------------------------------------------------------------
BOOL CheckForRASConnection()
{
    RASCONNSTATUS rascs;
    RASCONN rasConn[MAXRASCONNS];
    DWORD dwEntries = MAXRASCONNS;
    DWORD dwSize = sizeof(rasConn);
    DWORD dwRet;
    BOOL bRetCode = FALSE;
    
        // This is the connection name of the ISP the user has signed up
        // with.  We will look for a connectiod with this same name.
    const TCHAR* pszConnectionName = GetISPConnectionName();
    if (NULL == pszConnectionName || 0 == lstrlen(pszConnectionName))
    {
        return FALSE;
    }

    for (int i = 0; i < MAXRASCONNS; ++i)
    {
        rasConn[i].dwSize = sizeof(RASCONN);
    }

    dwRet = RasEnumConnections(rasConn, &dwSize, &dwEntries);

    if (dwRet == 0)
    {
        for (dwRet = 0; dwRet < dwEntries; dwRet++)
        {
                // If this is the connection we are looking for let's make
                // sure the connection is all set to go.
            if (0 == lstrcmpi(pszConnectionName, rasConn[dwRet].szEntryName))
            {
                rascs.dwSize = sizeof(RASCONNSTATUS);
                dwRet = RasGetConnectStatus(rasConn[dwRet].hrasconn, 
                                            &rascs);
                if (dwRet == 0 && rascs.rasconnstate == RASCS_Connected)
                {
                    bRetCode = TRUE;
                }
            }
        }
    }

    return bRetCode;
}


//-----------------------------------------------------------------------------
//  CheckForSignupAttempt
//
//  This method contains the logic that check to see if we should make an attempt
//  to pop up the sign up dialog.  If we should make an attempt will will then
//  enum the RAS connections to see if the user is connected before popping
//  up the dialog.
//-----------------------------------------------------------------------------
void CheckForSignupAttempt()
{
    int nDaysLeft = GetISPTrialDaysLeft();
    int nRetValue = 0;
            
        // Every some many signup attempts lets read the registry and see if
        // a successful signup happened.
    ++g_nAttemptCounter;

    if (MAX_ATTEMPTCOUNTER == g_nAttemptCounter)
    {
        g_nAttemptCounter = 0;

        if (IsSignupSuccessful())
        {
            ShutDownForGood();
            return;
        }

            // If the trial is expired then set the IE run once key.
        if (nDaysLeft < -1)
        {
            SetIERunOnce();
        }
    }

        // If we are in negative days left then do not do anything.  This means
        // the trail is over and the user has not signed up.  We will give
        // them one more signup attempt on application start up.
    if (nDaysLeft < 0)
    {
        return;
    }

    bool bAttemptSignup = false;

        // Based on the total signup notificaiton attempts we will determine
        // if the days left requires another attempt.
    switch (GetTotalNotifications())
    {
            // If we have not made any attempts yet then if we are at the half
            // way point in the trial or past the half way point we will make
            // a signup attempt.
        case 0:
        {
            if (nDaysLeft <= (int)(GetISPTrialDays() / 2))
            {
                bAttemptSignup = true;
            }
            break;
        }

            // If we have already perfomed 1 attempt then the second attempt
            // will come on the next to last day or the last day.
        case 1:
        {
            if (nDaysLeft <= 1)
            {
                bAttemptSignup = true;
            }
            break;
        }

            // The 3rd attempt will not come until the last day.
        case 2:
        {
            if (nDaysLeft == 0)
            {
                bAttemptSignup = true;
            }
            break;
        }

        default:
        {
            break;
        }
    }

    if (bAttemptSignup)
    {
        if (CheckForRASConnection())
        {
                // Before actually showing the dialog do a quick check to see
                // if a previous signup was successful.  If so we will shut 
                // down for good.
            if (IsSignupSuccessful())
            {
                ShutDownForGood();
                return;
            }

            g_bDialogExpiredMode = false;
            //if we have an isp message we need the right dlg template
            if(*GetISPMessage() != '\0')
                nRetValue = (int)DialogBox(g_hModule, MAKEINTRESOURCE(IDD_SIGNUP_ISPMSG), g_hwndMain, SignUpDialogProc);
            else 
                nRetValue = (int)DialogBox(g_hModule, MAKEINTRESOURCE(IDD_SIGNUP), g_hwndMain, SignUpDialogProc);

            switch (nRetValue)
            {
                    // The user wants to try and signup.
                case IDOK:
                {
                    PerformTheSignup();
                    break;
                }

                    // The user said signup later.  Check to see if the don't remind
                    // me button was pressed.  If so then shut down for good.
                case IDCANCEL:
                {
                        // If this is the last day of the trial then the remind
                        // me later button is not the Don't signup button.  In
                        // this case shut down for good.
                    if (0 == nDaysLeft)
                    {
                        ShutDownForGood();
                    }
                    else
                    {
                        IncrementTotalNotifications();
                        
                        if (g_bDoNotRemindAgain)
                        {
                            ShutDownForGood();
                        }
                    }

                    break;
                }

                    // The dialog timed out.  Don't do anything.  The does not
                    // count as an attempt.
                case IDABORT:
                {
                    break;
                }

                    // No work in here, in fact we should not get here.
                default:
                {
                    _ASSERT(false);
                    break;
                }
            }

                // If there is 1 day left let's make sure that total notifications
                // is 2.  If not the dialog may pop up multiple times.  Oh yea,
                // if dialog timed out then don't do this.
            if (IDABORT != nRetValue && 1 == nDaysLeft && 1 == GetTotalNotifications())
            {
                IncrementTotalNotifications();
            }
        }
    }
}


//-----------------------------------------------------------------------------
//  GetISPTrialDaysLeft
//-----------------------------------------------------------------------------
int GetISPTrialDaysLeft()
{
        // Calculate the relative current time.  The current system time cannot
        // be trusted if the System date/time dialog is up.  That dialog will
        // change the actual system time when every the user pokes around even
        // before hitting OK or Apply!!!
    time_t timeRelativeCurrent = g_timeAppStartUp + (GetTickDelta() / 1000);

        // The relative time and the trial start date are both time_t type
        // variables which are in seconds.
    int nSecondsSinceStart = (int)(timeRelativeCurrent - GetTrialStartDate());

        // Now convert seconds into days.  There are 86400 seconds in a day.
        // Note that we will always round up one more day if there is any 
        // remainder.
    div_t divResult = div(nSecondsSinceStart, 86400);
    int nDaysSinceStart = divResult.quot;
    if (divResult.rem)
    {
        ++nDaysSinceStart;
    }

#ifdef _DEBUG
    TCHAR buf[255];
    wsprintf(buf, TEXT("Days Since = %i\n"), nDaysSinceStart);
    OutputDebugString(buf);
    wsprintf(buf, TEXT("Check:  %s\n"), ctime(&timeRelativeCurrent));
    OutputDebugString(buf);
    time_t tt = GetTrialStartDate();
    wsprintf(buf, TEXT("Start:  %s\n"), ctime(&tt));
    OutputDebugString(buf);
#endif

    int nDaysLeft = GetISPTrialDays() - nDaysSinceStart;

#ifdef _DEBUG
    wsprintf(buf, TEXT("Days Left = %i\r\n"), nDaysLeft);
    OutputDebugString(buf);
#endif

    return nDaysLeft;
}


//-----------------------------------------------------------------------------
//  ShutDownForGood
//-----------------------------------------------------------------------------
void ShutDownForGood()
{
    RemoveRunOnce();
    RemoveIERunOnce();
    DeleteAllRegistryData();
    PostMessage(g_hwndMain, WM_CLOSE, 0, 0);
}


//-----------------------------------------------------------------------------
//  PerformTheSignup
//-----------------------------------------------------------------------------
void PerformTheSignup()
{
        // Note that we do not shut down for good.  The sign up may fail so 
        // simply increment the notification count.
    const TCHAR* pcszSignupUrl = GetISPSignupUrl();
    ShellExecute(g_hwndMain, TEXT("open"), pcszSignupUrl, TEXT(""), TEXT(""), SW_SHOW);
    IncrementTotalNotifications();
}


//-----------------------------------------------------------------------------
//  CenterTheWindow
//-----------------------------------------------------------------------------
void CenterTheWindow(HWND hWnd)
{
    HDC hDC = GetDC(hWnd);

    if (hDC)
    {
        int nScreenWidth = GetDeviceCaps(hDC, HORZRES);
        int nScreenHeight = GetDeviceCaps(hDC, VERTRES);
    
        RECT rect;
        GetWindowRect(hWnd, &rect);
        
            // Also make the window "always on top".
        SetWindowPos(hWnd, HWND_TOPMOST, 
                    (nScreenWidth / 2) - ((rect.right - rect.left) / 2), 
                    (nScreenHeight / 2) - ((rect.bottom - rect.top) / 2), 
                    rect.right - rect.left, 
                    rect.bottom - rect.top, 
                    SWP_SHOWWINDOW);

        ReleaseDC(hWnd, hDC);
    }
}


//-----------------------------------------------------------------------------
//  GetTickDelta
//-----------------------------------------------------------------------------
DWORD GetTickDelta()
{
        // This function returns the delta between the startup tick count and
        // the current tick count.  Note that we must watch for a rollover in 
        // the tick count.
    DWORD dwTickDelta;
    DWORD dwTickCurrent = GetTickCount();

        // If tick count rolls over we need to reset the app start up date
        // and the app tick count in case we roll over a second time.
    if (dwTickCurrent < g_dwTickAppStartUp)
    {
            // Calculate the delta by finding out how many ticks to the MAX 
            // tick count a DWORD can handle and then add the wrap around amount.
        DWORD dwDeltaToMax =  0xFFFFFFFF - g_dwTickAppStartUp;
        dwTickDelta = dwDeltaToMax + dwTickCurrent;

            // Modify the application startup by the delta in seconds that have
            // passed since it was last set.  Also reset startup tick count
            // to current tick for our new frame of reference.
        g_timeAppStartUp += (dwTickDelta / 1000);   // Convert to seconds.
        g_dwTickAppStartUp = dwTickCurrent;

            // Since we have modified the application start up date relative
            // to the current tick count and changed the app start up tick
            // count to the current tick count, the delta is zero.
        dwTickDelta = 0;
    }
    else
    {
        dwTickDelta = dwTickCurrent - g_dwTickAppStartUp;
    }

    return dwTickDelta;
}


//-----------------------------------------------------------------------------
//  AttemptTrialOverSignup
//-----------------------------------------------------------------------------
void AttemptTrialOverSignup()
{ 
    int nRetValue = 0;

    // Setup the run once data for IE.
    g_bDialogExpiredMode = true;

    if(*GetISPMessage() != '\0')
        nRetValue = (int)DialogBox(g_hModule, MAKEINTRESOURCE(IDD_SIGNUP_ISPMSG), g_hwndMain, SignUpDialogProc);
    else 
        nRetValue = (int)DialogBox(g_hModule, MAKEINTRESOURCE(IDD_SIGNUP), g_hwndMain, SignUpDialogProc);

    
    RemoveIERunOnce();

    switch (nRetValue)
    {
            // The user wants to try and signup.
        case IDOK:
        {
            const TCHAR* pcszSignupUrl = GetISPSignupUrlTrialOver();
            ShellExecute(g_hwndMain, TEXT("open"), pcszSignupUrl, TEXT(""), TEXT(""), SW_SHOW);
            ShutDownForGood();
            break;
        }

        case IDCANCEL:
        {
            ShutDownForGood();
            break;
        }

            // If we get IDABORT the dialog timed out so don't do anything.
        case IDABORT:
        {
            break;
        }

            // No work in here, in fact we should not get here.
        default:
        {
            _ASSERT(false);
            ShutDownForGood();
            break;
        }
    }
}

extern "C" void _stdcall ModuleEntry (void)
{
    LPTSTR      pszCmdLine = GetCommandLine();
    
    if ( *pszCmdLine == TEXT('\"') ) 
    {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != TEXT('\"')) )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else 
    {
        while (*pszCmdLine > TEXT(' '))
        pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) 
    {
        pszCmdLine++;
    }

    int i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine, SW_SHOWDEFAULT);
    
    ExitProcess(i); // Were outa here....  
}   /*  ModuleEntry() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwrmind\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by icwrmind.rc
//
#define IDS_TEXT1                       1
#define IDS_TEXT2                       2
#define IDS_DLG_TITLE                   3
#define IDS_SIGNUPLATER                 4
#define IDS_DONOTREMIND                 5
#define IDS_EXPIRED_TEXT1               6
#define IDS_EXPIRED_TEXT2               7
#define IDS_DONOTSIGNUP                 8
#define IDS_EXPIRED_DLG_TITLE           9
#define IDD_SIGNUP                      101
#define IDD_SIGNUP_ISPMSG               102
#define IDC_DONTREMIND                  1000
#define IDC_ICON1                       1002
#define IDC_TEXT1                       1003
#define IDC_ISP_MESSAGE                 1004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwrmind\sources.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

GETCONN_DIR     = ..\..

#
# Cross-compiler macros for unique naming
#

MAJORCOMP       = ie4
MINORCOMP       = getconn


#
# Defines for common.inc
#

TARGET_BOTH     = 1
USE_MSVCRT      = 1


#
# Include our common makefile
#

!include $(GETCONN_DIR)\common.inc

# USE cdecl calling
386_STDCALL = 0

#
# Common settings required by build.exe and makefile.def
#

TARGETNAME      = ICWRMIND
TARGETPATH      = obj
TARGETTYPE      = PROGRAM
TARGETLIBS      =

LINKLIBS        = $(LIBRARY_PATH)\gdi32.lib         \
                  $(LIBRARY_PATH)\kernel32.lib      \
                  $(LIBRARY_PATH)\advapi32.lib      \
                  $(LIBRARY_PATH)\shell32.lib       \
                  $(LIBRARY_PATH)\user32.lib        \
                  $(LIBRARY_PATH)\rasapi32.lib

# bugbug: scousens.
#         @0 needed because ModuleEntry is _stdcall.
#         On mips _stdcall is mapped to nothing
!if $(386)
UMENTRYABS      = ModuleEntry@0
!else
UMENTRYABS      = ModuleEntry
!endif


#
# List of sources
#
SOURCES=                        \
            ..\IcwRmind.rc      \
            ..\IcwRmind.cpp     \
            ..\mcReg.cpp        \
            ..\RegData.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwtutor\sources.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

GETCONN_DIR     = ..\..

#
# Cross-compiler macros for unique naming
#

MAJORCOMP       = GETCONN
MINORCOMP       = icwtutor.exe


#
# Defines for common.inc
#

TARGET_BOTH     = 1
USE_LIBCMT	= 1

#
# Include our common makefile
#

!include $(GETCONN_DIR)\common.inc

# USE cdecl calling
386_STDCALL = 0
#
# Common settings required by build.exe and makefile.def
#

TARGETNAME      = icwtutor
TARGETPATH      = obj
TARGETTYPE      = PROGRAM
TARGETLIBS      =

UMENTRY		= winmain

LINKLIBS    =                                   \
    $(LIBRARY_PATH)\kernel32.lib                \
    $(LIBRARY_PATH)\user32.lib                  \
    $(LIBRARY_PATH)\gdi32.lib                   \
    $(LIBRARY_PATH)\comdlg32.lib                \
    $(LIBRARY_PATH)\advapi32.lib                \
    $(LIBRARY_PATH)\shell32.lib                 \
    $(LIBRARY_PATH)\ole32.lib                   \
    $(LIBRARY_PATH)\comctl32.lib                \
    $(LIBRARY_PATH)\urlmon.lib                  \
    $(LIBRARY_PATH)\uuid.lib                    \
    $(LIBRARY_PATH)\comctl32.lib                \
    $(SDK_LIB_PATH)\oleaut32.lib                \
!if defined(NOT_UNICODE)
    $(GETCONN_DIR)\lib\ansi\$O\stocklib.lib     \
!else
    $(GETCONN_DIR)\lib\unicode\$O\stocklib.lib  \
!endif


#
# List of sources
#
SOURCES =               \
    ..\icwtutor.rc      \
	..\icwtutor.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwrmind\regdata.cpp ===
#define  STRICT
#include <windows.h>
#include <stdlib.h>
#include <stdarg.h>
#include <crtdbg.h>
#include <winbase.h>
#include <ras.h>
#include <time.h>
#include "icwunicd.h"
#include "RegData.h"


//-----------------------------------------------------------------------------
//  Defines
//-----------------------------------------------------------------------------
#define MAX_REGSTRING               150
#define DEFAULT_DIALOGTIMEOUT       1800000     // half hour
#define DEFAULT_SLEEPDURATION       30000       // 30 seconds


//-----------------------------------------------------------------------------
//  Global Handles and other defines
//-----------------------------------------------------------------------------
time_t g_tStartDate = 0;
int g_nISPTrialDays = 0;
int g_nTotalNotifications = -1;
DWORD g_dwDialogTimeOut = 0;
DWORD g_dwWakeupInterval = 0;
TCHAR g_szISPName[MAX_REGSTRING];
TCHAR g_szISPPhone[MAX_REGSTRING];
TCHAR g_szSignupURL[MAX_REGSTRING];
TCHAR g_szISPMsg[MAX_ISPMSGSTRING];
TCHAR g_szSignupURLTrialOver[MAX_REGSTRING];
TCHAR g_szConnectoidName[MAX_REGSTRING];


//-----------------------------------------------------------------------------
//  Registry entry strings.
//-----------------------------------------------------------------------------
static const TCHAR* g_szKeyRunOnce = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
static const TCHAR* g_szEntryRunOnce = TEXT("IcwRmind");

    // Key for IE run once stuff
static const TCHAR* g_szKeyIERunOnce = TEXT("Software\\Microsoft\\Internet Explorer\\Main");
static const TCHAR* g_szEntryIERunOnce = TEXT("First Home Page");
static const TCHAR* g_szHtmlFile = TEXT("TrialExp.html");

    // This is the key where all the application data will be stored.
static const TCHAR* g_szKeyIcwRmind = TEXT("Software\\Microsoft\\Internet Connection Wizard\\IcwRmind");

    // These entries will be created by the connection wizard.
static const TCHAR* g_szEntryISPName = TEXT("ISP_Name");
static const TCHAR* g_szEntryISPPhone = TEXT("ISP_Phone");
static const TCHAR* g_szEntryISPMsg = TEXT("ISP_Message");
static const TCHAR* g_szEntryTrialDays = TEXT("Trial_Days");
static const TCHAR* g_szEntrySignupURL = TEXT("Signup_URL");
static const TCHAR* g_szEntrySignupURLTrialOver = TEXT("Expired_URL");
static const TCHAR* g_szEntryConnectoidName = TEXT("Entry_Name");
static const TCHAR* g_szSignupSuccessfuly = TEXT("TrialConverted");

    // These entries will be created by this application.
static const TCHAR* g_szEntryTrialStart = TEXT("Trial_Start");
static const TCHAR* g_szEntryTrialStartString = TEXT("Trial_Start_String");
static const TCHAR* g_szEntryAppIsVisible = TEXT("App_IsVisible");
static const TCHAR* g_szEntryWakeupInterval = TEXT("Wakeup_Interval");
static const TCHAR* g_szEntryTotalNotifications = TEXT("Total_Notifications");
static const TCHAR* g_szEntryDialogTimeOut = TEXT("Dialog_TimeOut");


//-----------------------------------------------------------------------------
//  GetWakeupInterval
//-----------------------------------------------------------------------------
DWORD GetWakeupInterval()
{
    if (g_dwWakeupInterval)
    {
        return g_dwWakeupInterval;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.GetValue(g_szEntryWakeupInterval, g_dwWakeupInterval);

            // If not in the registry then set the default value.
        if (!bRetCode)
        {
            g_dwWakeupInterval = DEFAULT_SLEEPDURATION;
        }
    }

    return g_dwWakeupInterval;
}


//-----------------------------------------------------------------------------
//  GetDialogTimeout
//-----------------------------------------------------------------------------
DWORD GetDialogTimeout()
{
    if (g_dwDialogTimeOut)
    {
        return g_dwDialogTimeOut;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.GetValue(g_szEntryDialogTimeOut, g_dwDialogTimeOut);

            // If not in the registry then set the default value.
        if (!bRetCode)
        {
            g_dwDialogTimeOut = DEFAULT_DIALOGTIMEOUT;
        }
    }

    return g_dwDialogTimeOut;
}


//-----------------------------------------------------------------------------
//  IsApplicationVisible
//-----------------------------------------------------------------------------
BOOL IsApplicationVisible()
{
        // This data is debug data so it is not cached.  Default value is
        // FALSE if not found in registry.
    BOOL bVisible = FALSE;
    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        DWORD dwData = 0;
        bool bRetCode = reg.GetValue(g_szEntryAppIsVisible, dwData);

        if (bRetCode)
        {
            bVisible = (BOOL) dwData;
        }
    }

    return bVisible;
}


//-----------------------------------------------------------------------------
//  GetConnectionName
//-----------------------------------------------------------------------------
const TCHAR* GetISPConnectionName()
{
        // If we already retrieved this then simply pass it back.
    if (lstrlen(g_szConnectoidName))
    {
        return g_szConnectoidName;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.GetValue(g_szEntryConnectoidName, g_szConnectoidName, sizeof(TCHAR)*MAX_REGSTRING);
        _ASSERT(bRetCode);
    }

    return g_szConnectoidName;
}


//-----------------------------------------------------------------------------
//  GetISPSignupUrl
//-----------------------------------------------------------------------------
const TCHAR* GetISPSignupUrl()
{
        // If we already retrieved this then simply pass it back.
    if (lstrlen(g_szSignupURL))
    {
        return g_szSignupURL;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.GetValue(g_szEntrySignupURL, g_szSignupURL, sizeof(TCHAR)*MAX_REGSTRING);
        _ASSERT(bRetCode);
    }

    return g_szSignupURL;
}


//-----------------------------------------------------------------------------
//  GetISPSignupUrlTrialOver
//-----------------------------------------------------------------------------
const TCHAR* GetISPSignupUrlTrialOver()
{
        // If we already retrieved this then simply pass it back.
    if (lstrlen(g_szSignupURLTrialOver))
    {
        return g_szSignupURLTrialOver;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.GetValue(g_szEntrySignupURLTrialOver, g_szSignupURLTrialOver, sizeof(TCHAR)*MAX_REGSTRING);
        _ASSERT(bRetCode);
    }

    return g_szSignupURLTrialOver;
}


//-----------------------------------------------------------------------------
//  SetupRunOnce
//-----------------------------------------------------------------------------
void SetupRunOnce()
{
    CMcRegistry reg;

    bool bRetCode = reg.OpenKey(HKEY_LOCAL_MACHINE, g_szKeyRunOnce);
    _ASSERT(bRetCode);

    if (bRetCode)
    {
        LPTSTR lpszFileName = new TCHAR[_MAX_PATH + 23];

        if (GetModuleFileName(GetModuleHandle(NULL), lpszFileName, _MAX_PATH + 20))
        {
                // Add a command line parameter.
            lstrcat(lpszFileName, TEXT(" -R"));
            bRetCode = reg.SetValue(g_szEntryRunOnce, lpszFileName);
            _ASSERT(bRetCode);
        }

        delete [] lpszFileName;
    }
}


//-----------------------------------------------------------------------------
//  RemoveRunOnce
//-----------------------------------------------------------------------------
void RemoveRunOnce()
{
    CMcRegistry reg;

    bool bRetCode = reg.OpenKey(HKEY_LOCAL_MACHINE, g_szKeyRunOnce);
    _ASSERT(bRetCode);

    if (bRetCode)
    {
         bRetCode = reg.SetValue(g_szEntryRunOnce, TEXT(""));
        _ASSERT(bRetCode);
    }
}


//-----------------------------------------------------------------------------
//  GetISPName
//-----------------------------------------------------------------------------
const TCHAR* GetISPName()
{
        // If we already retrieved this then simply pass it back.
    if (lstrlen(g_szISPName))
    {
        return g_szISPName;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.GetValue(g_szEntryISPName, g_szISPName, sizeof(TCHAR)*MAX_REGSTRING);
        _ASSERT(bRetCode);
    }

    return g_szISPName;
}


//-----------------------------------------------------------------------------
//  GetISPPhone
//-----------------------------------------------------------------------------
const TCHAR* GetISPPhone()
{
        // If we already retrieved this then simply pass it back.
    if (lstrlen(g_szISPPhone))
    {
        return g_szISPPhone;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.GetValue(g_szEntryISPPhone, g_szISPPhone, sizeof(TCHAR)*MAX_REGSTRING);
        _ASSERT(bRetCode);
    }

    return g_szISPPhone;
}

//-----------------------------------------------------------------------------
//  GetISPMessage
//-----------------------------------------------------------------------------
const TCHAR* GetISPMessage()
{
        // If we already retrieved this then simply pass it back.
    if (lstrlen(g_szISPMsg))
    {
        return g_szISPMsg;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.GetValue(g_szEntryISPMsg, g_szISPMsg, sizeof(TCHAR)*MAX_ISPMSGSTRING);
        _ASSERT(bRetCode);
    }

    return g_szISPMsg;
}

//-----------------------------------------------------------------------------
//  GetISPTrialDays
//-----------------------------------------------------------------------------
int GetISPTrialDays()
{
        // If we already retrieved this then simply pass it back.
    if (g_nISPTrialDays)
    {
        return g_nISPTrialDays;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        DWORD dwData = 0;
        bool bRetCode = reg.GetValue(g_szEntryTrialDays, dwData);
        _ASSERT(bRetCode);

        if (bRetCode)
        {
            g_nISPTrialDays = (int) dwData;
        }
    }

    return g_nISPTrialDays;
}


//-----------------------------------------------------------------------------
//  GetTrialStartDate
//-----------------------------------------------------------------------------
time_t GetTrialStartDate()
{
        // If we already retrieved this then simply pass it back.
    if (g_tStartDate)
    {
        return g_tStartDate;
    }

        // If the trial start date entry does not exist in the registry then
        // this is the first we have been executed so the trial start date
        // is today's date.  Put this back in the registry.
    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        DWORD dwData = 0;
        bool bRetCode = reg.GetValue(g_szEntryTrialStart, dwData);

        if (bRetCode && 0 != dwData)
        {
            g_tStartDate = (time_t) dwData;
        }
        else
        {
            time_t tTime;
            time(&tTime);

            if (reg.SetValue(g_szEntryTrialStart, (DWORD) tTime))
            {
                g_tStartDate = tTime;
                SetStartDateString(tTime);
            }
        }
    }

    return g_tStartDate;
}


//-----------------------------------------------------------------------------
//  OpenIcwRmindKey
//-----------------------------------------------------------------------------
bool OpenIcwRmindKey(CMcRegistry &reg)
{
        // This method will open the IcwRmind key in the registry.  If the key
        // does not exist it will be created here.
    bool bRetCode = reg.OpenKey(HKEY_LOCAL_MACHINE, g_szKeyIcwRmind);

    if (!bRetCode)
    {
         bRetCode = reg.CreateKey(HKEY_LOCAL_MACHINE, g_szKeyIcwRmind);
        _ASSERT(bRetCode);
    }

    return bRetCode;
}


//-----------------------------------------------------------------------------
//  ClearCachedData
//-----------------------------------------------------------------------------
void ClearCachedData()
{
        // Clear all the global data so that it will be reread out of the
        // registry.
    g_tStartDate = 0;
    g_nISPTrialDays = 0;
    g_dwDialogTimeOut = 0;
    g_dwWakeupInterval = 0;
    g_szISPName[0] = 0;
    g_szISPMsg[0] = 0;
    g_szISPPhone[0] = 0;
    g_szSignupURL[0] = 0;
    g_szSignupURLTrialOver[0] = 0;
    g_szConnectoidName[0] = 0;
    g_nTotalNotifications = -1;
}


//-----------------------------------------------------------------------------
//  ResetCachedData
//-----------------------------------------------------------------------------
void ResetCachedData()
{
        // Clear all the global data so that it will be reread out of the
        // registry.
    g_tStartDate = 0;
    g_nISPTrialDays = 0;
    g_dwDialogTimeOut = 0;
    g_dwWakeupInterval = 0;
    g_szISPName[0] = 0;
    g_szISPMsg[0] = 0;
    g_szISPPhone[0] = 0;
    g_szSignupURL[0] = 0;
    g_szSignupURLTrialOver[0] = 0;
    g_szConnectoidName[0] = 0;
    g_nTotalNotifications = -1;

        // We must also clear the start date and total notifications out
        // of the registry.
    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.SetValue(g_szEntryTrialStart, (DWORD) 0);
        _ASSERT(bRetCode);
        bRetCode = reg.SetValue(g_szEntryTotalNotifications, (DWORD) 0);
        _ASSERT(bRetCode);
    }
}


//-----------------------------------------------------------------------------
//  GetTotalNotifications
//-----------------------------------------------------------------------------
int GetTotalNotifications()
{
        // This is the number of times we have notified the user and the user
        // has responded to us.  We will only notify them 3 times.
    if (-1 != g_nTotalNotifications)
    {
        _ASSERT(g_nTotalNotifications <= 3);
        return g_nTotalNotifications;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        DWORD dwData = 0;
        bool bRetCode = reg.GetValue(g_szEntryTotalNotifications, dwData);

        if (bRetCode)
        {
            g_nTotalNotifications = (int) dwData;
        }
        else
        {
            g_nTotalNotifications = 0;
        }
    }

    return g_nTotalNotifications;
}


//-----------------------------------------------------------------------------
//  IncrementTotalNotifications
//-----------------------------------------------------------------------------
void IncrementTotalNotifications()
{
    _ASSERT(g_nTotalNotifications < 3 && -1 != g_nTotalNotifications);

    if (g_nTotalNotifications < 3 && -1 != g_nTotalNotifications)
    {
        ++g_nTotalNotifications;

            // Let's put it back into the registry now.
        CMcRegistry reg;

        if (OpenIcwRmindKey(reg))
        {
            DWORD dwData = 0;
            bool bRetCode = reg.SetValue(g_szEntryTotalNotifications, (DWORD) g_nTotalNotifications);
            _ASSERT(bRetCode);
        }
    }
}


//-----------------------------------------------------------------------------
//  ResetTrialStartDate
//-----------------------------------------------------------------------------
void ResetTrialStartDate(time_t timeNewStartDate)
{
    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        if (reg.SetValue(g_szEntryTrialStart, (DWORD) timeNewStartDate))
        {
            g_tStartDate = timeNewStartDate;
            SetStartDateString(timeNewStartDate);
        }
        else
        {
            _ASSERT(false);
        }
    }
    else
    {
        _ASSERT(false);
    }
}


//-----------------------------------------------------------------------------
//  DeleteAllRegistryData
//-----------------------------------------------------------------------------
void DeleteAllRegistryData()
{
        // Delete the Run Once data.  We do this by setting the value
        // to nothing.
    CMcRegistry reg;

    bool bRetCode = reg.OpenKey(HKEY_LOCAL_MACHINE, g_szKeyRunOnce);
    _ASSERT(bRetCode);

    if (bRetCode)
    {
        bRetCode = reg.SetValue(g_szEntryRunOnce, TEXT(""));
        _ASSERT(bRetCode);
    }

        // Delete the Remind Key and all it's values.
    RegDeleteKey(HKEY_LOCAL_MACHINE, g_szKeyIcwRmind);
}


//-----------------------------------------------------------------------------
//  IsSignupSuccessful
//-----------------------------------------------------------------------------
BOOL IsSignupSuccessful()
{
    BOOL bSuccess = FALSE;
    CMcRegistry reg;

        // Do not cache this data.  Some other app will write this entry
        // once the user has successfully signed up.
    if (OpenIcwRmindKey(reg))
    {
        DWORD dwData = 0;
        bool bRetCode = reg.GetValue(g_szSignupSuccessfuly, dwData);

        if (bRetCode)
        {
            bSuccess = (BOOL) dwData;
        }
    }

    return bSuccess;
}


//-----------------------------------------------------------------------------
//  RemoveTrialConvertedFlag
//-----------------------------------------------------------------------------
void RemoveTrialConvertedFlag()
{
    BOOL bSuccess = FALSE;
    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.SetValue(g_szSignupSuccessfuly, (DWORD) 0);
        _ASSERT(bRetCode);
    }
}

//-----------------------------------------------------------------------------
//  SetStartDateString
//-----------------------------------------------------------------------------
void SetStartDateString(time_t timeStartDate)
{
    CMcRegistry reg;
    TCHAR buf[255];

    wsprintf(buf, TEXT("%s"), ctime(&timeStartDate));

    if (OpenIcwRmindKey(reg))
    {
        reg.SetValue(g_szEntryTrialStartString, buf);
    }
}


//-----------------------------------------------------------------------------
//  SetIERunOnce
//-----------------------------------------------------------------------------
void SetIERunOnce()
{
    CMcRegistry reg;

    bool bRetCode = reg.OpenKey(HKEY_CURRENT_USER, g_szKeyIERunOnce);

        // The html page for the IE run once is in the same directory as
        // the IcwRmind exe.  Create the full qualified path.
    if (bRetCode)
    {
        TCHAR* pszBuf = new TCHAR[_MAX_PATH];

        if (pszBuf)
        {
            if (GetModuleFileName(GetModuleHandle(NULL), pszBuf, _MAX_PATH))
            {
                TCHAR* pszBufPath = new TCHAR[_MAX_PATH];

                if (pszBufPath)
                {
                    TCHAR* pszDrive = new TCHAR[_MAX_DRIVE];
                    
                    if (pszDrive)
                    {
                        _tsplitpath(pszBuf, pszDrive, pszBufPath, NULL, NULL);
                        lstrcpy(pszBuf, pszDrive);
                        lstrcat(pszBuf, pszBufPath);
                        lstrcat(pszBuf, g_szHtmlFile);
                        reg.SetValue(g_szEntryIERunOnce, pszBuf);

                        delete [] pszDrive;
                    }

                    delete [] pszBufPath;
                }
            }

            delete [] pszBuf;
        }
    }
}


//-----------------------------------------------------------------------------
//  RemoveIERunOnce
//-----------------------------------------------------------------------------
void RemoveIERunOnce()
{
    HKEY hkey;
    long lErr = ::RegOpenKeyEx(HKEY_CURRENT_USER, g_szKeyIERunOnce, 0, KEY_READ | KEY_WRITE, &hkey);

    if (ERROR_SUCCESS == lErr)
    {
        RegDeleteValue(hkey, g_szEntryIERunOnce);
        RegCloseKey(hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwtutor\icwtutor.cpp ===
// icwtutor.cpp : Defines the entry point for the application.
//
#include <windows.h>
#include <urlmon.h>
#include <mshtmhst.h>
#include <locale.h>

#define STR_BSTR      0
#define STR_OLESTR    1
#define ARRAYSIZE(a)  (sizeof(a)/sizeof((a)[0]))
#define A2B(x)        (BSTR)A2W((LPSTR)(x), STR_BSTR)

LPWSTR A2W			      (LPSTR psz, BYTE bType);
BSTR  GetHtmFileFromCommandLine (HINSTANCE hInst, LPSTR lpCmdLine);
    
BOOL bFileFromCmdLine = FALSE;
     
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    HINSTANCE hinstMSHTML = NULL;

#ifdef UNICODE
        // Initialize the C runtime locale to the system locale.
    setlocale(LC_ALL, "");
#endif

    hinstMSHTML = LoadLibrary(TEXT("MSHTML.DLL"));

    if(hinstMSHTML)
    {
        SHOWHTMLDIALOGFN  *pfnShowHTMLDialog = NULL;
      
        pfnShowHTMLDialog = (SHOWHTMLDIALOGFN*)GetProcAddress(hinstMSHTML, "ShowHTMLDialog");

        if(pfnShowHTMLDialog)
        {
            IMoniker *pmk             = NULL;
            BSTR     bstrHtmFilePath  = NULL;
            
            bstrHtmFilePath = GetHtmFileFromCommandLine(hInstance, lpCmdLine);

            CreateURLMoniker(NULL, bstrHtmFilePath, &pmk);

            SysFreeString(bstrHtmFilePath); 

            if(pmk)
            {
                if(bFileFromCmdLine)
                    (*pfnShowHTMLDialog)(NULL, pmk, NULL, A2B("help: no"), NULL);
                else
                    (*pfnShowHTMLDialog)(NULL, pmk, NULL, A2B("dialogWidth:  36.5em; dialogHeight: 25.5em; help: no"), NULL);

                pmk->Release();
            }
        }
        FreeLibrary(hinstMSHTML);
    }
    return 0;
}

BSTR GetHtmFileFromCommandLine(HINSTANCE hInst, LPSTR lpCmdLine)
{
    CHAR szTemp [MAX_PATH*2] = "\0";

    if (*lpCmdLine == '\"')
    {
        lstrcpynA(szTemp,
                  lpCmdLine + 1, 
                  lstrlenA(lpCmdLine) - 1);
    }
    else
    {
        lstrcpyA(szTemp,
                 lpCmdLine);
    }
    
    if (GetFileAttributesA(szTemp) != 0xFFFFFFFF)
    {
       bFileFromCmdLine = TRUE;
       return A2B(szTemp);
    }

    lstrcpyA(szTemp, "res://");
    GetModuleFileNameA(hInst, szTemp + lstrlenA(szTemp), ARRAYSIZE(szTemp) - lstrlenA(szTemp));
    lstrcatA(szTemp, "/Default.htm");

    return A2B(szTemp);
}

LPWSTR A2W(LPSTR psz, BYTE bType)
{
    int i;
    LPWSTR pwsz;

    if (!psz)
        return(NULL);
    // compute the length of the required BSTR
    if ((i = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0)) <= 0)    
        return NULL;                                                                                            
    switch (bType) 
	{                                                   
        case STR_BSTR:                           
			// SysAllocStringLen adds 1
			pwsz = (LPWSTR)SysAllocStringLen(NULL, (i - 1));            
            break;
        case STR_OLESTR:
            pwsz = (LPWSTR)CoTaskMemAlloc(i * sizeof(WCHAR));
            break;
        default:
            return(NULL);
    }
    if (!pwsz)
        return(NULL);
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return(pwsz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\gifcon.cpp ===
// GifConv.cpp : Implementation of CICWGifConvert

#include "pre.h"
#include "webvwids.h"

/////////////////////////////////////////////////////////////////////////////
// CICWGifConvert

//+----------------------------------------------------------------------------
//
//  Function    CICWGifConvert:CICWGifConvert
//
//  Synopsis    This is the constructor, nothing fancy
//
//-----------------------------------------------------------------------------
CICWGifConvert::CICWGifConvert
(
    CServer* pServer
) 
{
    TraceMsg(TF_CWEBVIEW, "CICWGifConvert constructor called");
    m_lRefCount = 0;
    
    // Assign the pointer to the server control object.
    m_pServer = pServer;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWGifConvert::QueryInterface
//
//  Synopsis    This is the standard QI, with support for
//              IID_Unknown, IICW_Extension and IID_ICWApprentice
//              (stolen from Inside COM, chapter 7)
//
//
//-----------------------------------------------------------------------------
HRESULT CICWGifConvert::QueryInterface( REFIID riid, void** ppv )
{
    TraceMsg(TF_CWEBVIEW, "CICWGifConvert::QueryInterface");
    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    // IID_IICWGifConvert
    if (IID_IICWGifConvert == riid)
        *ppv = (void *)(IICWGifConvert *)this;
    // IID_IUnknown
    else if (IID_IUnknown == riid)
        *ppv = (void *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function    CICWGifConvert::AddRef
//
//  Synopsis    This is the standard AddRef
//
//
//-----------------------------------------------------------------------------
ULONG CICWGifConvert::AddRef( void )
{
    TraceMsg(TF_CWEBVIEW, "CICWGifConvert::AddRef %d", m_lRefCount + 1);
    return InterlockedIncrement(&m_lRefCount) ;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWGifConvert::Release
//
//  Synopsis    This is the standard Release
//
//
//-----------------------------------------------------------------------------
ULONG CICWGifConvert::Release( void )
{
    ASSERT( m_lRefCount > 0 );

    InterlockedDecrement(&m_lRefCount);

    TraceMsg(TF_CWEBVIEW, "CICWGifConvert::Release %d", m_lRefCount);
    if( 0 == m_lRefCount )
    {
        if (NULL != m_pServer)
            m_pServer->ObjectsDown();
    
        delete this;
        return 0;
    }
    return( m_lRefCount );
}

void  CALLBACK ImgCtx_Callback(void * pIImgCtx, void* pfDone);

HRESULT CICWGifConvert::GifToBitmap(TCHAR * pszFile, HBITMAP* phBitmap)
{
    HRESULT hr  = E_FAIL; //don't assume success
    ULONG fState;
    SIZE sz;
    IImgCtx* pIImgCtx;

    BSTR bstrFile = A2W(pszFile);

    hr = CoCreateInstance(CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER,
                          IID_IImgCtx, (void**)&pIImgCtx);

    BOOL bCoInit = FALSE;

    if ((CO_E_NOTINITIALIZED == hr || REGDB_E_IIDNOTREG == hr) &&
        SUCCEEDED(CoInitialize(NULL)))
    {
        bCoInit = TRUE;
        hr = CoCreateInstance(CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER,
                              IID_IImgCtx, (void**)&pIImgCtx);
    }

    if (SUCCEEDED(hr))
    {
        ASSERT(pIImgCtx);

        hr = SynchronousDownload(pIImgCtx, bstrFile);
        pIImgCtx->GetStateInfo(&fState, &sz, TRUE);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIImgCtx);

            HDC hdcScreen = GetDC(NULL);

            if (hdcScreen)
            {
                *phBitmap = CreateCompatibleBitmap(hdcScreen, sz.cx, sz.cy);

                if (*phBitmap)
                {
                    HDC hdcImgDst = CreateCompatibleDC(NULL);
                    if (hdcImgDst)
                    {
                        HGDIOBJ hbmOld = SelectObject(hdcImgDst, *phBitmap);
                        if (hbmOld)
                        {
                            hr = StretchBltImage(pIImgCtx, &sz, hdcImgDst);
                            SelectObject(hdcImgDst, hbmOld);
                        }
                        DeleteDC(hdcImgDst);
                    }
                }
                ReleaseDC(NULL, hdcScreen);
            }
        }

        pIImgCtx->Release();
    }

    if (bCoInit)
        CoUninitialize();

    return hr;
}


HRESULT CICWGifConvert::GifToIcon(TCHAR * pszFile, UINT nIconSize, HICON* phIcon)
{
    HRESULT hr  = E_FAIL; //don't assume success
    
    SIZE Size;
    if (0 != nIconSize)
    {
        Size.cx = nIconSize;
        Size.cy = nIconSize;
    }
    
    IImgCtx* pIImgCtx;

    ULONG fState;

    BSTR bstrFile = A2W(pszFile);

    hr = CoCreateInstance(CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER,
                          IID_IImgCtx, (void**)&pIImgCtx);

    BOOL bCoInit = FALSE;

    if ((CO_E_NOTINITIALIZED == hr || REGDB_E_IIDNOTREG == hr) &&
        SUCCEEDED(CoInitialize(NULL)))
    {
        bCoInit = TRUE;
        hr = CoCreateInstance(CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER,
                              IID_IImgCtx, (void**)&pIImgCtx);
    }

    if (SUCCEEDED(hr))
    {
        ASSERT(pIImgCtx);

        hr = SynchronousDownload(pIImgCtx, bstrFile);
        if (0 == nIconSize)
        {
            pIImgCtx->GetStateInfo(&fState, &Size, TRUE);
        }

        if (SUCCEEDED(hr))
        {

            *phIcon = ExtractImageIcon(&Size, pIImgCtx);

        }

        pIImgCtx->Release();
    }

    if (bCoInit)
        CoUninitialize();

    return hr;
}

HRESULT CICWGifConvert::SynchronousDownload(IImgCtx* pIImgCtx, BSTR bstrFile)
{
    ASSERT(pIImgCtx);

    HRESULT hr;

    hr = pIImgCtx->Load(bstrFile, 0);

    if (SUCCEEDED(hr))
    {
        ULONG fState;
        SIZE  sz;

        pIImgCtx->GetStateInfo(&fState, &sz, TRUE);

        if (!(fState & (IMGLOAD_COMPLETE | IMGLOAD_ERROR)))
        {
            BOOL fDone = FALSE;

            hr = pIImgCtx->SetCallback(ImgCtx_Callback, &fDone);

            if (SUCCEEDED(hr))
            {
                hr = pIImgCtx->SelectChanges(IMGCHG_COMPLETE, 0, TRUE);

                if (SUCCEEDED(hr))
                {
                    MSG msg;
                    BOOL fMsg;

                    // HACK: restrict the message pump to those messages we know that URLMON and
                    // HACK: the imageCtx stuff needs, otherwise we will be pumping messages for
                    // HACK: windows we shouldn't be pumping right now...
                    while(!fDone )
                    {
                        fMsg = PeekMessage(&msg, NULL, WM_USER + 1, WM_USER + 4, PM_REMOVE );

                        if (!fMsg)
                            fMsg = PeekMessage( &msg, NULL, WM_APP + 2, WM_APP + 2, PM_REMOVE );
                        if (!fMsg)
                        {
                            // go to sleep until we get a new message....
                            WaitMessage();
                            continue;
                        }
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }
            }
            pIImgCtx->Disconnect();
        }
        hr = pIImgCtx->GetStateInfo(&fState, &sz, TRUE);

        if (SUCCEEDED(hr))
            hr = (fState & IMGLOAD_COMPLETE) ? S_OK : E_FAIL;
    }
    return hr;
}

HICON CICWGifConvert::ExtractImageIcon(SIZE* pSize, IImgCtx * pIImgCtx)
{
    ASSERT(pIImgCtx);

    HICON hiconRet = NULL;

    HDC hdcScreen = GetDC(NULL);

    if (hdcScreen)
    {
        HBITMAP hbmImage = CreateCompatibleBitmap(hdcScreen, pSize->cx, pSize->cy);

        if (hbmImage)
        {
            HBITMAP hbmMask = CreateBitmap(pSize->cx, pSize->cy, 1, 1, NULL);

            if (hbmMask)
            {
                SIZE sz;
                sz.cx = pSize->cx;
                sz.cy = pSize->cy;

                if (SUCCEEDED(CreateImageAndMask(pIImgCtx, hdcScreen, &sz,
                                                 &hbmImage, &hbmMask)))
                {
                    ICONINFO ii;

                    ii.fIcon    = TRUE;
                    ii.hbmMask  = hbmMask;
                    ii.hbmColor = hbmImage;

                    hiconRet = CreateIconIndirect(&ii); 
                }
                DeleteObject(hbmMask);
            }
            DeleteObject(hbmImage);
        }
        ReleaseDC(NULL, hdcScreen);
    }
    return hiconRet;
}

HRESULT CICWGifConvert::CreateImageAndMask(IImgCtx * pIImgCtx, 
                                     HDC hdcScreen, 
                                     SIZE * pSize, 
                                     HBITMAP * phbmImage, 
                                     HBITMAP * phbmMask)
{
    ASSERT(pIImgCtx);
    ASSERT(phbmImage);
    ASSERT(phbmMask);

    HRESULT hr = E_FAIL;

    HDC hdcImgDst = CreateCompatibleDC(NULL);
    if (hdcImgDst)
    {
        HGDIOBJ hbmOld = SelectObject(hdcImgDst, *phbmImage);
        if (hbmOld)
        {
            if (ColorFill(hdcImgDst, pSize, COLOR1))
            {
                hr = StretchBltImage(pIImgCtx, pSize, hdcImgDst);

                if (SUCCEEDED(hr))
                {
                    hr = CreateMask(pIImgCtx, hdcScreen, hdcImgDst, pSize,
                                    phbmMask); 
                }
            }
            SelectObject(hdcImgDst, hbmOld);
        }
        DeleteDC(hdcImgDst);
    }
    return hr;
}


HRESULT CICWGifConvert::StretchBltImage(IImgCtx * pIImgCtx, const SIZE * pSize, HDC hdcDst)
{
    ASSERT(pIImgCtx);
    ASSERT(hdcDst);

    HRESULT hr;

    SIZE    sz;
    ULONG   fState;

    hr = pIImgCtx->GetStateInfo(&fState, &sz, FALSE);

    if (SUCCEEDED(hr))
    {
        hr = pIImgCtx->StretchBlt(hdcDst, 0, 0, pSize->cx, pSize->cy, 0, 0,
                                  sz.cx, sz.cy, SRCCOPY);
        ASSERT(SUCCEEDED(hr) && "Icon extraction pIImgCtx->StretchBlt failed!");
    }

    return hr;
}

HRESULT CICWGifConvert::CreateMask(IImgCtx * pIImgCtx, HDC hdcScreen, HDC hdc1, const SIZE * pSize, HBITMAP * phbMask)
{
    ASSERT(hdc1);
    ASSERT(pSize);
    ASSERT(phbMask);

    HRESULT hr = E_FAIL;

    HDC hdc2 = CreateCompatibleDC(NULL);
    if (hdc2)
    {
        HBITMAP hbm2 = CreateCompatibleBitmap(hdcScreen, pSize->cx, pSize->cy);
        if (hbm2)
        {
            HGDIOBJ hbmOld2 = SelectObject(hdc2, hbm2);
            if (hbmOld2)
            {
                ColorFill(hdc2, pSize, COLOR2);

                hr = StretchBltImage(pIImgCtx, pSize, hdc2);

                if (SUCCEEDED(hr) &&
                    BitBlt(hdc2, 0, 0, pSize->cx, pSize->cy, hdc1, 0, 0,
                           SRCINVERT))
                {
                    if (GetDeviceCaps(hdcScreen, BITSPIXEL) <= 8)
                    {
                        //
                        // 6 is the XOR of the index for COLOR1 and the index
                        // for COLOR2.
                        //
                        SetBkColor(hdc2, PALETTEINDEX(6));
                    }
                    else
                    {
                        SetBkColor(hdc2, (COLORREF)(COLOR1 ^ COLOR2));
                    }

                    HDC hdcMask = CreateCompatibleDC(NULL);
                    if (hdcMask)
                    {
                        HGDIOBJ hbmOld = SelectObject(hdcMask, *phbMask);
                        if (hbmOld)
                        {
                            if (BitBlt(hdcMask, 0, 0, pSize->cx, pSize->cy, hdc2, 0,
                                       0, SRCCOPY))
                            {
                                //
                                // RasterOP 0x00220326 does a copy of the ~mask bits
                                // of hdc1 and sets everything else to 0 (Black).
                                //

                                if (BitBlt(hdc1, 0, 0, pSize->cx, pSize->cy, hdcMask,
                                           0, 0, 0x00220326))
                                {
                                    hr = S_OK;
                                }
                            }
                            SelectObject(hdcMask, hbmOld);
                        }
                        DeleteDC(hdcMask);
                    }
                }
                SelectObject(hdc2, hbmOld2);
            }
            DeleteObject(hbm2);
        }
        DeleteDC(hdc2);
    }
    return hr;
}

BOOL CICWGifConvert::ColorFill(HDC hdc, const SIZE * pSize, COLORREF clr)
{
    ASSERT(hdc);

    BOOL fRet = FALSE;

    HBRUSH hbSolid = CreateSolidBrush(clr);
    if (hbSolid)
    {
        HGDIOBJ hbOld = SelectObject(hdc, hbSolid);
        if (hbOld)
        {
            PatBlt(hdc, 0, 0, pSize->cx, pSize->cy, PATCOPY);
            fRet = TRUE;

            SelectObject(hdc, hbOld);
        }
        DeleteObject(hbSolid);
    }
    return fRet;
}

void CALLBACK ImgCtx_Callback(void* pIImgCtx,void* pfDone)
{
    ASSERT(pfDone);

    *(BOOL*)pfDone = TRUE;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\factory.h ===
//**********************************************************************
// File name: factory.h
//
//
// Copyright (c) 1993-1996 Microsoft Corporation. All rights reserved.
//**********************************************************************


#if !defined(FACTORY_H)
#define FACTORY_H

#ifdef __cplusplus

/**********************************************************************
  ObjectClass: ClassFactory

  Summary:     
  Interfaces:  IUnknown
                 Standard interface providing COM object features.
               IClassFactory
                 Standard interface providing COM Class Factory features.

  Aggregation: 
**********************************************************************/
class ClassFactory : public IClassFactory
{
    public:
        // Main Object Constructor & Destructor.
        ClassFactory(CServer* pServer, CLSID const *);
        ~ClassFactory(void);

        // IUnknown methods. Main object, non-delegating.
        virtual STDMETHODIMP            QueryInterface(REFIID, void **);
        virtual STDMETHODIMP_(ULONG)    AddRef(void);
        virtual STDMETHODIMP_(ULONG)    Release(void);

        // Interface IClassFactory
        virtual STDMETHODIMP            CreateInstance(IUnknown* pUnknownOuter,
                                                         const IID& iid,
                                                         void** ppv);
        virtual STDMETHODIMP            LockServer(BOOL bLock); 

    private:
        // Main Object reference count.
        LONG              m_cRefs;

        // Pointer to this component server's control object.
        CServer*          m_pServer;
        
        // CLSID of the COM object to create
        CLSID const*        m_pclsid;
};

typedef ClassFactory* PClassFactory;

#endif // __cplusplus


#endif // FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\factory.cpp ===
/*****************************************************************/
/**          Microsoft                                          **/
/**          Copyright (C) Microsoft Corp., 1991-1998           **/
/*****************************************************************/ 

//
//  FACTORY.CPP - 
//

//  HISTORY:
//  
//  07/28/98  donaldm   created
//

#include "pre.h"
#include "webvwids.h"

/*---------------------------------------------------------------------------
  Implementation the ClassFactory Class Factory.  CFWebView is the COM
  object class for the Class Factory that can manufacture CLSID_ICWWEBVIEW
  COM Components.
---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
  Method:   ClassFactory::ClassFactory

  Summary:  
  Args:     
            CServer* pServer)
              Pointer to the server's control object.

  Modifies: m_cRefs

  Returns:  void
---------------------------------------------------------------------------*/
ClassFactory::ClassFactory
(
    CServer *       pServer,
    CLSID const*    pclsid
)
{
    // Zero the COM object's reference count.
    m_cRefs = 0;

    // Init the pointer to the server control object.
    m_pServer = pServer;

    // Keep track of the class type we need to create
    m_pclsid = pclsid;
    return;
}


/*---------------------------------------------------------------------------
  Method:   ClassFactory::~ClassFactory

  Summary:  ClassFactory Destructor.

  Args:     void

  Modifies: .

  Returns:  void
---------------------------------------------------------------------------*/
ClassFactory::~ClassFactory(void)
{
    return;
}


/*---------------------------------------------------------------------------
  Method:   ClassFactory::QueryInterface

  Summary:  QueryInterface of the ClassFactory non-delegating
            IUnknown implementation.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            void ** ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
---------------------------------------------------------------------------*/
STDMETHODIMP ClassFactory::QueryInterface
(
    REFIID riid,
    void ** ppv
)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if (IID_IUnknown == riid)
    {
        *ppv = this;
    }
    else if (IID_IClassFactory == riid)
    {
        *ppv = static_cast<IClassFactory*>(this);
    }

    if (NULL != *ppv)
    {
        // We've handed out a pointer to the interface so obey the COM rules
        // and AddRef the reference count.
        ((LPUNKNOWN)*ppv)->AddRef();
        hr = NOERROR;
    }

    return (hr);
}


/*---------------------------------------------------------------------------
  Method:   ClassFactory::AddRef

  Summary:  AddRef of the ClassFactory non-delegating IUnknown implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
---------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) ClassFactory::AddRef(void)
{
    return InterlockedIncrement(&m_cRefs);
    return m_cRefs;
}


/*---------------------------------------------------------------------------
  Method:   ClassFactory::Release

  Summary:  Release of the ClassFactory non-delegating IUnknown implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
---------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) ClassFactory::Release(void)
{
    if (InterlockedDecrement(&m_cRefs) == 0)
    {
        // We've reached a zero reference count for this COM object.
        // So we tell the server housing to decrement its global object
        // count so that the server will be unloaded if appropriate.
        if (NULL != m_pServer)
            m_pServer->ObjectsDown();
    
        delete this;
        return 0 ;
    }
    TraceMsg(TF_CLASSFACTORY, "CFactory::Release %d", m_cRefs);
    return m_cRefs;
}

/*---------------------------------------------------------------------------
  Method:   ClassFactory::CreateInstance

  Summary:  The CreateInstance member method of this IClassFactory interface
            implementation.  Creates an instance of the CICWWebView COM
            component.

  Args:     IUnknown* pUnkOuter,
              [in] Pointer to the controlling IUnknown.
            REFIID riid,
              [in] GUID of the Interface being requested.
            void ** ppvCob)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code.
---------------------------------------------------------------------------*/
STDMETHODIMP ClassFactory::CreateInstance
(
    IUnknown* pUnkOuter,
    REFIID riid,
    void ** ppv
)
{
    HRESULT         hr = E_FAIL;
    IUnknown    *   pCob = NULL;

    // NULL the output pointer.
    *ppv = NULL;

    // We don't support aggregation
    if (NULL != pUnkOuter)
        hr = CLASS_E_NOAGGREGATION;
    else
    {
        // Instantiate a COM Object, based on the clsid requsted by GetClassObject
        if (IsEqualGUID(CLSID_ICWWEBVIEW, *m_pclsid))
            pCob = (IUnknown *) new CICWWebView(m_pServer);
        else if (IsEqualGUID(CLSID_ICWWALKER, *m_pclsid))
            pCob = (IUnknown *) new CICWWalker(m_pServer);
        else if (IsEqualGUID(CLSID_ICWGIFCONVERT, *m_pclsid))
            pCob = (IUnknown *) new CICWGifConvert(m_pServer);
        else if (IsEqualGUID(CLSID_ICWISPDATA, *m_pclsid))
            pCob = (IUnknown *) new CICWISPData(m_pServer);
        else
            pCob = NULL;
                    
        if (NULL != pCob)
        {
            // We initially created the new COM object so tell the server
            // to increment its global server object count to help ensure
            // that the server remains loaded until this partial creation
            // of a COM component is completed.
            m_pServer->ObjectsUp();

            // We QueryInterface this new COM Object not only to deposit the
            // main interface pointer to the caller's pointer variable, but to
            // also automatically bump the Reference Count on the new COM
            // Object after handing out this reference to it.
            hr = pCob->QueryInterface(riid, (void **)ppv);
            if (FAILED(hr))
            {
                m_pServer->ObjectsDown();
                delete pCob;
            }
        }
        else
             hr = E_OUTOFMEMORY;
    }

    return hr;
}


/*---------------------------------------------------------------------------
  Method:   ClassFactory::LockServer

  Summary:  The LockServer member method of this IClassFactory interface
            implementation.

  Args:     BOOL fLock)
              [in] Flag determining whether to Lock or Unlock the server.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code.
---------------------------------------------------------------------------*/
STDMETHODIMP ClassFactory::LockServer
(
    BOOL fLock
)
{
    HRESULT hr = NOERROR;
    if (fLock)
        m_pServer->Lock();
    else
        m_pServer->Unlock();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\bkgndbmp.cpp ===
#include "pre.h"


PBITMAPINFO CreateBitmapInfoStruct
(
    HBITMAP hBmp
)
{ 
    BITMAP      bmp; 
    PBITMAPINFO pbmi; 
    WORD        cClrBits; 

    // Retrieve the bitmap's color format, width, and height. 
    if (!GetObject(hBmp, sizeof(BITMAP), (LPSTR)&bmp)) 
        return NULL;

    // Convert the color format to a count of bits. 
    cClrBits = (WORD)(bmp.bmPlanes * bmp.bmBitsPixel); 
    if (cClrBits == 1) 
        cClrBits = 1; 
    else if (cClrBits <= 4) 
        cClrBits = 4; 
    else if (cClrBits <= 8) 
        cClrBits = 8; 
    else if (cClrBits <= 16) 
        cClrBits = 16; 
    else if (cClrBits <= 24) 
        cClrBits = 24; 
    else cClrBits = 32; 

    // Allocate memory for the BITMAPINFO structure. (This structure 
    // contains a BITMAPINFOHEADER structure and an array of RGBQUAD 
    // data structures.) 
    if (cClrBits != 24) 
    {
        pbmi = (PBITMAPINFO) LocalAlloc(LPTR, 
                                        sizeof(BITMAPINFOHEADER) + 
                                        sizeof(RGBQUAD) * (1<< cClrBits)); 
    }
    else 
    {
        // There is no RGBQUAD array for the 24-bit-per-pixel format. 
        pbmi = (PBITMAPINFO) LocalAlloc(LPTR, sizeof(BITMAPINFOHEADER)); 
    }

    if (pbmi)
    {
        // Initialize the fields in the BITMAPINFO structure. 
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER); 
        pbmi->bmiHeader.biWidth = bmp.bmWidth; 
        pbmi->bmiHeader.biHeight = bmp.bmHeight; 
        pbmi->bmiHeader.biPlanes = bmp.bmPlanes; 
        pbmi->bmiHeader.biBitCount = bmp.bmBitsPixel; 
        if (cClrBits < 24) 
            pbmi->bmiHeader.biClrUsed = (1<<cClrBits); 

        // If the bitmap is not compressed, set the BI_RGB flag. 
        pbmi->bmiHeader.biCompression = BI_RGB; 

        // Compute the number of bytes in the array of color 
        // indices and store the result in biSizeImage. 
        pbmi->bmiHeader.biSizeImage = (pbmi->bmiHeader.biWidth + 7) /8 
                                      * pbmi->bmiHeader.biHeight 
                                      * cClrBits; 
                                      
        // Set biClrImportant to 0, indicating that all of the 
        // device colors are important. 
        pbmi->bmiHeader.biClrImportant = 0;
    }
    
    return pbmi; 
} 
 
BOOL CreateBMPFile
(
    LPTSTR      pszFile, 
    PBITMAPINFO pbi, 
    HBITMAP     hBMP, 
    HDC         hDC
) 
{ 
    HANDLE              hf;                 // file handle 
    BITMAPFILEHEADER    hdr;                // bitmap file-header 
    PBITMAPINFOHEADER   pbih;               // bitmap info-header 
    LPBYTE              lpBits;             // memory pointer 
    DWORD               dwTotal;            // total count of bytes 
    DWORD               cb;                 // incremental count of bytes 
    BYTE                *hp;                // byte pointer 
    DWORD               dwTmp; 

    pbih = (PBITMAPINFOHEADER) pbi; 
    lpBits = (LPBYTE) GlobalAlloc(GMEM_FIXED, pbih->biSizeImage);

    if (!lpBits) 
        return FALSE;

    // Retrieve the color table (RGBQUAD array) and the bits 
    // (array of palette indices) from the DIB. 
    if (!GetDIBits(hDC, hBMP, 0, (WORD) pbih->biHeight, lpBits, pbi, DIB_RGB_COLORS)) 
    {
        return FALSE;
    }

    // Create the .BMP file. 
    hf = CreateFile(pszFile, 
                    GENERIC_READ | GENERIC_WRITE, 
                    (DWORD) 0, 
                    NULL, 
                    CREATE_ALWAYS, 
                    FILE_ATTRIBUTE_NORMAL, 
                    (HANDLE) NULL); 
    if (hf == INVALID_HANDLE_VALUE) 
        return FALSE;
        
    hdr.bfType = 0x4d42;        // 0x42 = "B" 0x4d = "M" 
    // Compute the size of the entire file. 
    hdr.bfSize = (DWORD) (sizeof(BITMAPFILEHEADER) + 
                 pbih->biSize + pbih->biClrUsed 
                 * sizeof(RGBQUAD) + pbih->biSizeImage); 
    hdr.bfReserved1 = 0; 
    hdr.bfReserved2 = 0; 

    // Compute the offset to the array of color indices. 
    hdr.bfOffBits = (DWORD) sizeof(BITMAPFILEHEADER) + 
                    pbih->biSize + pbih->biClrUsed 
                    * sizeof (RGBQUAD); 

    // Copy the BITMAPFILEHEADER into the .BMP file. 
    if (!WriteFile(hf, (LPVOID) &hdr, sizeof(BITMAPFILEHEADER), 
        (LPDWORD) &dwTmp,  NULL)) 
    {
       return FALSE;
    }

    // Copy the BITMAPINFOHEADER and RGBQUAD array into the file. 
    if (!WriteFile(hf, (LPVOID) pbih, sizeof(BITMAPINFOHEADER) 
                  + pbih->biClrUsed * sizeof (RGBQUAD), 
                  (LPDWORD) &dwTmp, ( NULL))) 
    {                  
        return FALSE;
    }
    
    // Copy the array of color indices into the .BMP file. 
    dwTotal = cb = pbih->biSizeImage; 
    hp = lpBits; 
    if (!WriteFile(hf, (LPSTR) hp, (int) cb, (LPDWORD) &dwTmp,NULL)) 
    {
        return FALSE;
    }
    
    // Close the .BMP file. 
     if (!CloseHandle(hf)) 
     {
        return FALSE;
     }
     
    // Free memory. 
    GlobalFree((HGLOBAL)lpBits);
    
    return TRUE;
}
 
 
BOOL CopyBitmapRectToFile
(
    HBITMAP hbm, 
    LPRECT  lpRect,
    LPTSTR  lpszFileName
)
{
    HDC         hSrcDC, hDestDC;         // screen DC and memory DC
    HDC         hScreenDC;
    HBITMAP     hBitmap, hOldBitmap, hOldSrcBitmap; 
    PBITMAPINFO pbmi; 
    BOOL        bRet;
        
    // check for an empty rectangle
    if (IsRectEmpty(lpRect))
      return FALSE;

    // get the Source Window DC and create
    // a memory DC compatible to screen DC
    hScreenDC = GetDC(NULL);
    hSrcDC = CreateCompatibleDC(hScreenDC);
    hDestDC = CreateCompatibleDC(hScreenDC);
    
    // create a dest bitmap
    hBitmap = CreateCompatibleBitmap(hScreenDC, RECTWIDTH(*lpRect), RECTHEIGHT(*lpRect));

    // select new bitmap into memory DC
    hOldBitmap = (HBITMAP)SelectObject(hDestDC, hBitmap);

    // Select the passed in BMP into the SrcDC
    hOldSrcBitmap = (HBITMAP)SelectObject(hSrcDC, hbm);
    
    // bitblt screen DC to memory DC
    BitBlt(hDestDC, 
           0, 
           0, 
           RECTWIDTH(*lpRect), 
           RECTHEIGHT(*lpRect), 
           hSrcDC, 
           lpRect->left, 
           lpRect->top, 
           SRCCOPY);

    pbmi =  CreateBitmapInfoStruct(hBitmap);
    if (pbmi)
    {
        bRet = CreateBMPFile(lpszFileName,  pbmi,  hBitmap, hDestDC);
        LocalFree(pbmi);
        pbmi = NULL;
    }
    
    // clean up 
    DeleteObject(SelectObject(hDestDC, hOldBitmap));
    SelectObject(hSrcDC, hOldSrcBitmap);

    DeleteDC(hSrcDC);
    DeleteDC(hDestDC);

    ReleaseDC(NULL, hScreenDC);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\dllentry.cpp ===
/*****************************************************************/
/**          Microsoft                                          **/
/**          Copyright (C) Microsoft Corp., 1991-1998           **/
/*****************************************************************/ 

//
//  DLLENTRY.CPP - 
//

//  HISTORY:
//  
//  05/14/98  donaldm   created
//

#include "pre.h"
#include "registry.h"
#include "webvwids.h"

// We encapsulate the control of this COM server (eg, lock and object
// counting) in a server control C++ object.  Here is it's pointer.
CServer* g_pServer = NULL;

const CLSID * aClassObjects[] = 
{
    &CLSID_ICWWEBVIEW,
    &CLSID_ICWWALKER,
    &CLSID_ICWGIFCONVERT,
    &CLSID_ICWISPDATA
};
#define NUM_CLASS_OBJECTS   sizeof(aClassObjects) / sizeof(aClassObjects[0])
#define MAX_ID_SIZE    100

const TCHAR acszFriendlyNames[][MAX_ID_SIZE] = 
{
    TEXT("CLSID_ICWWebView"),
    TEXT("CLSID_ICWWalker"),
    TEXT("CLSID_ICWGifConvert"),
    TEXT("CLSID_ICWISPData")
};

const TCHAR acszIndProgIDs[][MAX_ID_SIZE] = 
{
    TEXT("ICWCONN.WebView"),
    TEXT("ICWCONN.Walker"),
    TEXT("ICWCONN.GifConvert"),
    TEXT("ICWCONN.ISPData")
};

const TCHAR acszProgIDs[][MAX_ID_SIZE] = 
{
    TEXT("ICWCONN.WebView.1"),
    TEXT("ICWCONN.Walker.1"),
    TEXT("ICWCONN.GifConvert.1"),
    TEXT("ICWCONN.ISPData.1")
};

// instance handle must be in per-instance data segment
HINSTANCE           ghInstance=NULL;
INT                 _convert;               // For string conversion
const VARIANT       c_vaEmpty = {0};

void RegWebOCClass();

typedef UINT RETERR;

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

  BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);

#ifdef __cplusplus
}
#endif // __cplusplus

/*******************************************************************

  NAME:    DllEntryPoint

  SYNOPSIS:  Entry point for DLL.

  NOTES:    Initializes thunk layer to WIZ16.DLL

********************************************************************/
BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
{
    BOOL    bRet = TRUE;
    
    if(fdwReason == DLL_PROCESS_ATTACH)
    {
        bRet = FALSE;
        // Instantiate the CServer utility class.
        g_pServer = new CServer;
        if (NULL != g_pServer)
        {
            // Remember the DLL Instance handle.
            g_pServer->m_hDllInst = hInstDll;
    
            ghInstance = hInstDll;
        
            // Register the window class that will be used to embed web browser object into dialogs
            RegWebOCClass();
            
            bRet = TRUE;
        }            
    }
    if (fdwReason == DLL_PROCESS_DETACH)
    {
        if(g_pServer)
        {
            // We return S_OK of there are no longer any living objects AND
            // there are no outstanding client locks on this server.
            HRESULT hr = (0L==g_pServer->m_cObjects && 0L==g_pServer->m_cLocks) ? S_OK : S_FALSE;

            if(hr == S_OK)
                DELETE_POINTER(g_pServer);
        }        
    }
    return bRet;
}


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

void __cdecl main() {};

#ifdef __cplusplus
}
#endif // __cplusplus



///////////////////////////////////////////////////////////
//
// Exported functions
//
// These are the functions that COM expects to find
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    HRESULT hr = S_OK;

    if(g_pServer)
    {
        // We return S_OK of there are no longer any living objects AND
        // there are no outstanding client locks on this server.
        hr = (0L==g_pServer->m_cObjects && 0L==g_pServer->m_cLocks) ? S_OK : S_FALSE;

        if(hr == S_OK)
            DELETE_POINTER(g_pServer);
    }
    return hr;
}

//
// Get class factory
//
STDAPI DllGetClassObject
(   
    const CLSID& rclsid,
    const IID& riid,
    void** ppv
)
{
    TraceMsg(TF_CLASSFACTORY, "DllGetClassObject:\tCreate class factory.") ;

    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;
    IUnknown* pCob = NULL;

    hr = E_OUTOFMEMORY;
    pCob = new ClassFactory(g_pServer, &rclsid);
    
    if (NULL != pCob)
    {
        g_pServer->ObjectsUp();
        hr = pCob->QueryInterface(riid, ppv);
        if (FAILED(hr))
        {
            g_pServer->ObjectsDown();
            DELETE_POINTER(pCob);
        }
    }

    return hr;
}


// The following two exported functions are what regsvr32 uses to
// self-register and unregister the dll.  See REGISTRY.CPP for
// actual implementation

//
// Server registration
//
STDAPI DllRegisterServer()
{
    BOOL    bRet = TRUE;
    
    for (int i = 0; i < NUM_CLASS_OBJECTS; i++)
    {    
        bRet = RegisterServer(ghInstance, 
                            *aClassObjects[i],
                            (LPTSTR)acszFriendlyNames[i],
                            (LPTSTR)acszIndProgIDs[i],
                            (LPTSTR)acszProgIDs[i]);
    }
    
    return (bRet ? S_OK : E_FAIL);                        
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    BOOL    bRet = TRUE;

    for (int i = 0; i < NUM_CLASS_OBJECTS; i++)
    {    
        bRet = UnregisterServer(*aClassObjects[i],
                              (LPTSTR)acszIndProgIDs[i],
                              (LPTSTR)acszProgIDs[i]);
    }
    return (bRet ? S_OK : E_FAIL);                        
}


//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\gifcon.h ===
// GifConv.h : Declaration of the CGifConv
#ifndef __GIFCONV_H_
#define __GIFCONV_H_

#include <iimgctx.h>

#define     COLOR1              (RGB(0,0,255))
#define     COLOR2              (RGB(0,255,0))

struct ThreadData
{
    HANDLE hEvent;
    HANDLE hExitThreadEvent;
    IImgCtx * pImgCtx;
    LPCWSTR pszBuffer;
    HRESULT * pHr;
};

class CICWGifConvert : public IICWGifConvert
{

    public:
        // IICWGifConvert
        virtual HRESULT STDMETHODCALLTYPE GifToIcon(TCHAR * pszFile, UINT nIconSize, HICON* phIcon);
        virtual HRESULT STDMETHODCALLTYPE GifToBitmap(TCHAR * pszFile, HBITMAP* phBitmap);

        // IUNKNOWN
        virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID theGUID, void** retPtr );
        virtual ULONG   STDMETHODCALLTYPE AddRef( void );
        virtual ULONG   STDMETHODCALLTYPE Release( void );

        CICWGifConvert(CServer * pServer);
        ~CICWGifConvert() {};
    
    
    private:
        DWORD  m_dwClrDepth;
        HRESULT SynchronousDownload (IImgCtx* pIImgCtx, BSTR bstrFile);
        HICON   ExtractImageIcon    (SIZE* pSize, IImgCtx* pIImgCtx);
        HRESULT CreateImageAndMask  (IImgCtx* pIImgCtx, HDC hdcScreen, SIZE * pSize, HBITMAP * phbmImage, HBITMAP * phbmMask);
        HRESULT StretchBltImage     (IImgCtx* pIImgCtx, const SIZE* pSize, HDC hdcDst);
        BOOL    ColorFill           (HDC hdc, const SIZE* pSize, COLORREF clr);
        HRESULT CreateMask          (IImgCtx* pIImgCtx, HDC hdcScreen, HDC hdc1, const SIZE * pSize, HBITMAP * phbMask);
        
        // Class object stuff
        LONG                m_lRefCount;
        // Pointer to this component server's control object.
        CServer*         m_pServer;
};

#endif //__GIFCONV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\icwutil.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  WIZARD.H - central header file for ICWCONN
//

//  HISTORY:
//  
//  05/14/98    donaldm     created it
//

#ifndef _ICWUTIL_H_
#define _ICWUTIL_H_

//Defs for tweaking HTML
#define MAX_COLOR_NAME  100
#define HTML_DEFAULT_BGCOLOR         TEXT("THREEDFACE")
#define HTML_DEFAULT_SPECIALBGCOLOR  TEXT("WINDOW")
#define HTML_DEFAULT_COLOR           TEXT("WINDOWTEXT")

//JACOB -- BUGBUG: duplicate defs. clean-up
#define MAX_RES_LEN         255 

extern HINSTANCE    ghInstance;
extern INT          _convert;               // For string conversion

extern const TCHAR cszEquals[];
extern const TCHAR cszAmpersand[];
extern const TCHAR cszPlus[];
extern const TCHAR cszQuestion[];

// Trace flags
#define TF_CLASSFACTORY     0x00000010
#define TF_CWEBVIEW         0x00000020

extern const VARIANT c_vaEmpty;
//
// BUGBUG: Remove this ugly const to non-const casting if we can
//  figure out how to put const in IDL files.
//
#define PVAREMPTY ((VARIANT*)&c_vaEmpty)

// String conversion in UTIL.CPP
LPWSTR WINAPI A2WHelper(LPWSTR lpw, LPCTSTR lpa, int nChars);
LPTSTR WINAPI W2AHelper(LPTSTR lpa, LPCWSTR lpw, int nChars);

#define A2WHELPER A2WHelper
#define W2AHELPER W2AHelper

#ifdef UNICODE
#define A2W(lpa) (LPTSTR)(lpa)
#define W2A(lpw) (lpw)
#else  // UNICODE
#define A2W(lpa) (\
        ((LPCTSTR)lpa == NULL) ? NULL : (\
                _convert = (lstrlenA((LPTSTR)lpa)+1),\
                A2WHELPER((LPWSTR) alloca(_convert*2), (LPTSTR)lpa, _convert)))

#define W2A(lpw) (\
        ((LPCWSTR)lpw == NULL) ? NULL : (\
                _convert = (lstrlenW(lpw)+1)*2,\
                W2AHELPER((LPTSTR) alloca(_convert), lpw, _convert)))
#endif // UNICODE

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCTSTR)W2A(lpw))

HRESULT ConnectToConnectionPoint
(
    IUnknown            *punkThis, 
    REFIID              riidEvent, 
    BOOL                fConnect, 
    IUnknown            *punkTarget, 
    DWORD               *pdwCookie, 
    IConnectionPoint    **ppcpOut
);


#define DELETE_POINTER(p)\
{\
  if (NULL != p)\
  {\
    delete p;\
    p = NULL;\
  }\
}

void WINAPI URLEncode(TCHAR* pszUrl, size_t bsize);
void WINAPI URLAppendQueryPair
(
    LPTSTR   lpszQuery, 
    LPTSTR   lpszName, 
    LPTSTR   lpszValue
);


#endif // _ICWUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\icwwebvw.h ===
class CICWWebView : public IICWWebView
{
    public:
        CICWWebView (CServer* pServer);
       ~CICWWebView (void);
        
        // IICWWebView
        virtual HRESULT STDMETHODCALLTYPE HandleKey               (LPMSG lpMsg);
        virtual HRESULT STDMETHODCALLTYPE SetFocus                (void);
        virtual HRESULT STDMETHODCALLTYPE ConnectToWindow         (HWND hWnd, DWORD dwHtmPageType);
#ifndef UNICODE
        virtual HRESULT STDMETHODCALLTYPE DisplayHTML             (TCHAR * lpszURL);
#endif
        virtual HRESULT STDMETHODCALLTYPE DisplayHTML             (BSTR bstrURL);
        virtual HRESULT STDMETHODCALLTYPE SetHTMLColors           (LPTSTR lpszForeground, LPTSTR lpszBackground);
        virtual HRESULT STDMETHODCALLTYPE SetHTMLBackgroundBitmap (HBITMAP hbm, LPRECT lpRC);
        virtual HRESULT STDMETHODCALLTYPE get_BrowserObject       (IWebBrowser2 **lpWebBrowser);
        
        // IUNKNOWN
        virtual HRESULT STDMETHODCALLTYPE QueryInterface (REFIID theGUID, void** retPtr );
        virtual ULONG   STDMETHODCALLTYPE AddRef         (void);
        virtual ULONG   STDMETHODCALLTYPE Release        (void);

        //public members
        COleSite FAR* m_lpOleSite; // Each instance of the ICWWebView object will need an OLE site
     
    private:
        LONG      m_lRefCount;
        IUnknown* m_pUnkOuter;       // Outer unknown (aggregation & delegation).
        CServer*  m_pServer;         // Pointer to this component server's control object.
        BOOL      m_bUseBkGndBitmap;
        HBITMAP   m_hBkGrndBitmap;
        RECT      m_rcBkGrnd;
        TCHAR     m_szBkGrndColor   [MAX_COLOR_NAME];
        TCHAR     m_szForeGrndColor [MAX_COLOR_NAME];

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\icwwebvw.cpp ===
/****************************************************************************
 *
 *  ICWWEBVW.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1997
 *  All rights reserved
 *
 *  This module provides the implementation of the methods for
 *  the CICWApprentice class.
 *
 *  07/22/98     donaldm     adapted from ICWCONNN
 *
 ***************************************************************************/

#include "pre.h"
#include "initguid.h"
#include "webvwids.h"

#define VK_N 'N'
#define VK_P 'P'

HRESULT CICWWebView::get_BrowserObject
(
    IWebBrowser2 **lpWebBrowser
)
{
    ASSERT(m_lpOleSite);

    *lpWebBrowser = m_lpOleSite->m_lpWebBrowser;
    
    return S_OK;
}

HRESULT CICWWebView::ConnectToWindow
(
    HWND    hWnd,
    DWORD   dwHtmPageType
)
{
    ASSERT(m_lpOleSite);
    
    // Set the window long to be this object pointer, since it will be used by the 
    // wnd proc, assuming it is a WebOC class window attaching
    SetWindowLongPtr(hWnd,GWLP_USERDATA,(LPARAM) this);

    m_lpOleSite->ConnectBrowserObjectToWindow(hWnd, 
                                              dwHtmPageType, 
                                              m_bUseBkGndBitmap,
                                              m_hBkGrndBitmap,
                                              &m_rcBkGrnd,
                                              m_szBkGrndColor,
                                              m_szForeGrndColor);
    
    return S_OK;
}

#ifndef UNICODE
HRESULT CICWWebView::DisplayHTML
(
    TCHAR * lpszURL
)
{
    BSTR            bstrURL;
    
    ASSERT(m_lpOleSite);

    // Convert to a BSTR for the call to the web browser object
    bstrURL = A2W(lpszURL);

    // Navigate the Webbrowser object to the requested page
    return (m_lpOleSite->m_lpWebBrowser->Navigate(bstrURL, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY));
}
#endif

HRESULT CICWWebView::DisplayHTML
(
    BSTR            bstrURL
)
{
    ASSERT(m_lpOleSite);


    // Navigate the Webbrowser object to the requested page
    return (m_lpOleSite->m_lpWebBrowser->Navigate(bstrURL, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY));
}

HRESULT CICWWebView::SetHTMLColors
(
    LPTSTR  lpszForeground,
    LPTSTR  lpszBackground
)
{
    if (NULL == lpszForeground || ('\0' == lpszForeground[0]))
    {
        lstrcpyn(m_szForeGrndColor, HTML_DEFAULT_COLOR, MAX_COLOR_NAME);
    }
    else
    {
        lstrcpyn(m_szForeGrndColor, lpszForeground, MAX_COLOR_NAME);
    }   
    
    if (NULL == lpszBackground || ('\0' == lpszBackground[0]))
    {
        lstrcpyn(m_szBkGrndColor, HTML_DEFAULT_BGCOLOR, MAX_COLOR_NAME);
    }
    else
    {
        lstrcpyn(m_szBkGrndColor, lpszBackground, MAX_COLOR_NAME);
    }   
         
    return S_OK;
}

HRESULT CICWWebView::SetHTMLBackgroundBitmap
(
    HBITMAP hbm, 
    LPRECT lpRC
)
{
    if (NULL != hbm)
    {
        m_hBkGrndBitmap = hbm;
        CopyRect(&m_rcBkGrnd, lpRC);
        m_bUseBkGndBitmap = TRUE;
    }
    else
    {
        m_hBkGrndBitmap = NULL;
        m_bUseBkGndBitmap = FALSE;
    }  
    return S_OK;              
}

HRESULT CICWWebView::HandleKey
(
    LPMSG lpMsg
)
{
    HRESULT hr = E_FAIL;
    ASSERT(m_lpOleSite);

    switch(lpMsg->message)
    {
        case WM_KEYDOWN:
        {
            //needed to disable certain default IE hot key combos. like launching a new browser window.
            if  ((lpMsg->wParam == VK_RETURN) || (lpMsg->wParam == VK_F5) || (((lpMsg->wParam == VK_N) || (lpMsg->wParam == VK_P) ) && (GetKeyState(VK_CONTROL) & 0x1000)))
                break;
        }
        default:
        {
            if(m_lpOleSite->m_lpWebBrowser)
            {
                IOleInPlaceActiveObject* lpIPA;
       
                if(SUCCEEDED(m_lpOleSite->m_lpWebBrowser->QueryInterface(IID_IOleInPlaceActiveObject,(void**)&lpIPA)))
                {
                    hr = lpIPA->TranslateAccelerator(lpMsg);
           
                    lpIPA->Release();
               }
            }
            break;
        }
    }
    return (hr);
}

HRESULT CICWWebView::SetFocus
(
    void
)       
{ 
    if(m_lpOleSite->m_lpInPlaceObject && !m_lpOleSite->m_fInPlaceActive)
    {
        m_lpOleSite->InPlaceActivate();
        m_lpOleSite->UIActivate();
    }

    m_lpOleSite->SetFocusToHtmlPage();       

    return S_OK;
}    

//+----------------------------------------------------------------------------
//
//  Function    CICWWebView::QueryInterface
//
//  Synopsis    This is the standard QI, with support for
//              IID_Unknown, IICW_Extension and IID_ICWApprentice
//              (stolen from Inside COM, chapter 7)
//
//
//-----------------------------------------------------------------------------
HRESULT CICWWebView::QueryInterface( REFIID riid, void** ppv )
{
    TraceMsg(TF_CWEBVIEW, "CICWWebView::QueryInterface");
    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    // IID_IICWWebView
    if (IID_IICWWebView == riid)
        *ppv = (void *)(IICWWebView *)this;
    // IID_IUnknown
    else if (IID_IUnknown == riid)
        *ppv = (void *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function    CICWWebView::AddRef
//
//  Synopsis    This is the standard AddRef
//
//
//-----------------------------------------------------------------------------
ULONG CICWWebView::AddRef( void )
{
    TraceMsg(TF_CWEBVIEW, "CICWWebView::AddRef %d", m_lRefCount + 1);
    return InterlockedIncrement(&m_lRefCount) ;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWWebView::Release
//
//  Synopsis    This is the standard Release
//
//
//-----------------------------------------------------------------------------
ULONG CICWWebView::Release( void )
{
    ASSERT( m_lRefCount > 0 );

    InterlockedDecrement(&m_lRefCount);

    TraceMsg(TF_CWEBVIEW, "CICWWebView::Release %d", m_lRefCount);
    if( 0 == m_lRefCount )
    {
        if (NULL != m_pServer)
            m_pServer->ObjectsDown();
    
        delete this;
        return 0;
    }
    return( m_lRefCount );
}

//+----------------------------------------------------------------------------
//
//  Function    CICWWebView::CICWWebView
//
//  Synopsis    This is the constructor, nothing fancy
//
//-----------------------------------------------------------------------------
CICWWebView::CICWWebView
(
    CServer* pServer
) 
{
    TraceMsg(TF_CWEBVIEW, "CICWWebView constructor called");
    m_lRefCount = 0;
    
    // Assign the pointer to the server control object.
    m_pServer = pServer;
    
    m_bUseBkGndBitmap = FALSE;
    lstrcpyn(m_szBkGrndColor, HTML_DEFAULT_BGCOLOR, MAX_COLOR_NAME);
    lstrcpyn(m_szForeGrndColor, HTML_DEFAULT_COLOR, MAX_COLOR_NAME);
    
    // Create a new OLE site, which will create an instance of the WebBrowser
    m_lpOleSite = new COleSite();
    if (m_lpOleSite)
        m_lpOleSite->CreateBrowserObject();
}


//+----------------------------------------------------------------------------
//
//  Function    CICWWebView::~CICWWebView
//
//  Synopsis    This is the destructor.  We want to clean up all the memory
//              we allocated in ::Initialize
//
//-----------------------------------------------------------------------------
CICWWebView::~CICWWebView( void )
{
    TraceMsg(TF_CWEBVIEW, "CICWWebView destructor called with ref count of %d", m_lRefCount);
    
    if (m_lpOleSite)
    {
        m_lpOleSite->Release();
        delete m_lpOleSite;
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\icwwalk.cpp ===
/****************************************************************************
 *
 *  ICWWALK.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1997
 *  All rights reserved
 *
 *  This module provides the implementation of the methods for
 *  the CICWWalker class.
 *
 *  07/22/98     donaldm     adapted from ICWCONNN
 *
 ***************************************************************************/

#include "pre.h"
#include "webvwids.h"

HRESULT CICWWalker::Walk()
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->Walk();
        
    return (hr);        
}

HRESULT CICWWalker::AttachToDocument(IWebBrowser2 *lpWebBrowser)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->AttachToDocument(lpWebBrowser);
        
    return (hr);        
}

HRESULT CICWWalker::ExtractUnHiddenText(BSTR* pbstrText)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->ExtractUnHiddenText(pbstrText);
        
    return (hr);        
}

HRESULT CICWWalker::AttachToMSHTML(BSTR bstrURL)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->AttachToMSHTML(bstrURL);
        
    return (hr);        
}

HRESULT CICWWalker::Detach()
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->Detach();
        
    return (hr);        
}

HRESULT CICWWalker::InitForMSHTML()
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->InitForMSHTML();
        
    return (hr);        
}

HRESULT CICWWalker::TermForMSHTML()
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->TermForMSHTML();
        
    return (hr);        
}

HRESULT CICWWalker::LoadURLFromFile(BSTR bstrURL)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->LoadURLFromFile(bstrURL);
        
    return (hr);        
}

HRESULT CICWWalker::get_IsQuickFinish(BOOL* pbIsQuickFinish)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->get_IsQuickFinish(pbIsQuickFinish);
        
    return (hr);        
}

HRESULT CICWWalker::get_PageType(LPDWORD pdwPageType)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->get_PageType(pdwPageType);
        
    return (hr);        
}

HRESULT CICWWalker::get_PageFlag(LPDWORD pdwPageFlag)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->get_PageFlag(pdwPageFlag);
        
    return (hr);        
}

HRESULT CICWWalker::get_PageID(BSTR *pbstrPageID)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->get_PageID(pbstrPageID);
        
    return (hr);        
}

HRESULT CICWWalker::get_URL(LPTSTR lpszURL, BOOL bForward)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->get_URL(lpszURL, bForward);
        
    return (hr);        
}

HRESULT CICWWalker::get_IeakIspFile(LPTSTR lpszIspFile)
{
    ASSERT(m_pHTMLWalker);

    m_pHTMLWalker->get_IeakIspFile(lpszIspFile);
    
    return S_OK;
}

HRESULT CICWWalker::ProcessOLSFile(IWebBrowser2* lpWebBrowser)
{
    ASSERT(m_pHTMLWalker);

    m_pHTMLWalker->ProcessOLSFile(lpWebBrowser);
    
    return S_OK;
}



HRESULT CICWWalker::get_FirstFormQueryString(LPTSTR  lpszQuery)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->get_FirstFormQueryString(lpszQuery);
        
    return (hr);        
}

//+----------------------------------------------------------------------------
//
//  Function    CICWWalker::QueryInterface
//
//  Synopsis    This is the standard QI, with support for
//              IID_Unknown, ...
//
//
//-----------------------------------------------------------------------------
HRESULT CICWWalker::QueryInterface
( 
    REFIID riid, void** ppv 
)
{
    TraceMsg(TF_CWEBVIEW, "CICWWalker::QueryInterface");
    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    // IID_IICWWalker
    if (IID_IICWWalker == riid)
        *ppv = (void *)(IICWWalker *)this;
    // IID_IUnknown
    else if (IID_IUnknown == riid)
        *ppv = (void *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function    CICWWalker::AddRef
//
//  Synopsis    This is the standard AddRef
//
//
//-----------------------------------------------------------------------------
ULONG CICWWalker::AddRef( void )
{
    TraceMsg(TF_CWEBVIEW, "CICWWalker::AddRef %d", m_lRefCount + 1);
    return InterlockedIncrement(&m_lRefCount) ;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWWalk::Release
//
//  Synopsis    This is the standard Release
//
//
//-----------------------------------------------------------------------------
ULONG CICWWalker::Release( void )
{
    ASSERT( m_lRefCount > 0 );

    InterlockedDecrement(&m_lRefCount);

    TraceMsg(TF_CWEBVIEW, "CICWWalker::Release %d", m_lRefCount);
    if( 0 == m_lRefCount )
    {
        if (NULL != m_pServer)
            m_pServer->ObjectsDown();
    
        delete this;
        return 0;
    }
    return( m_lRefCount );
}

//+----------------------------------------------------------------------------
//
//  Function    CICWWalker::CICWWalker
//
//  Synopsis    This is the constructor, nothing fancy
//
//-----------------------------------------------------------------------------
CICWWalker::CICWWalker
(
    CServer* pServer
) 
{
    TraceMsg(TF_CWEBVIEW, "CICWWalker constructor called");
    m_lRefCount = 0;
    
    // Assign the pointer to the server control object.
    m_pServer = pServer;
    
    // Create a new Walker object
    m_pHTMLWalker = new CWalker();
}


//+----------------------------------------------------------------------------
//
//  Function    CICWWalker::~CICWWalker
//
//  Synopsis    This is the destructor.  We want to clean up all the memory
//              we allocated in ::Initialize
//
//-----------------------------------------------------------------------------
CICWWalker::~CICWWalker( void )
{
    TraceMsg(TF_CWEBVIEW, "CICWWalker destructor called with ref count of %d", m_lRefCount);
    
    if (m_pHTMLWalker)
    {
        m_pHTMLWalker->Release();
        m_pHTMLWalker = NULL;
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\iocs.h ===
//**********************************************************************
// File name: IOCS.H
//
//      Definition of COleClientSite
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOCS_H_ )
#define _IOCS_H_

#include <assert.h>

class COleSite;

interface COleClientSite : public IOleClientSite
{
    int m_nCount;
    COleSite FAR * m_pSite;

    COleClientSite(COleSite FAR * pSite) {
        m_pSite = pSite;
        m_nCount = 0;
        }

    ~COleClientSite() {
        assert(m_nCount == 0);
        }

    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** IOleClientSite methods ***
    STDMETHODIMP SaveObject();
    STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk);
    STDMETHODIMP GetContainer(LPOLECONTAINER FAR* ppContainer);
    STDMETHODIMP ShowObject();
    STDMETHODIMP OnShowWindow(BOOL fShow);
    STDMETHODIMP RequestNewObjectLayout();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\iocs.cpp ===
//**********************************************************************
// File name: IOCS.CPP
//
//      Implementation file for COleClientSite
//
// Functions:
//
//      See IOCS.H for class definition
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"


//**********************************************************************
//
// COleClientSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at this interface
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK                -   The interface is supported.
//      E_NOINTERFACE       -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      COleClientSite::QueryInterface SITE.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleClientSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TraceMsg(TF_GENERAL, "In IOCS::QueryInterface\r\n");

    // delegate to the container Site
    return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CConnWizApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the interface level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//********************************************************************
STDMETHODIMP_(ULONG) COleClientSite::AddRef()
{
    TraceMsg(TF_GENERAL, "In IOCS::AddRef\r\n");

    // increment the interface reference count (for debugging only)
    ++m_nCount;

    // delegate to the container Site
    return m_pSite->AddRef();
}


//**********************************************************************
//
// CConnWizApp::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface.
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//********************************************************************
STDMETHODIMP_(ULONG) COleClientSite::Release()
{
    TraceMsg(TF_GENERAL, "In IOCS::Release\r\n");

    // decrement the interface reference count (for debugging only)
    --m_nCount;

    // delegate to the container Site
    return m_pSite->Release();
}

//**********************************************************************
//
// COleClientSite::SaveObject
//
// Purpose:
//
//      Called by the object when it wants to be saved to persistant
//      storage
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
//********************************************************************
STDMETHODIMP COleClientSite::SaveObject()
{
    TraceMsg(TF_GENERAL, "In IOCS::SaveObject\r\n");
    return (S_OK);
}

//**********************************************************************
//
// COleClientSite::GetMoniker
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
    TraceMsg(TF_GENERAL, "In IOCS::GetMoniker\r\n");

    // need to null the out pointer
    *ppmk = NULL;

    return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::GetContainer
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleClientSite::GetContainer(LPOLECONTAINER FAR* ppContainer)
{
    TraceMsg(TF_GENERAL, "In IOCS::GetContainer\r\n");

    // NULL the out pointer
    *ppContainer = NULL;

    return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::ShowObject
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::ShowObject()
{
    TraceMsg(TF_GENERAL, "In IOCS::ShowObject\r\n");
    return NOERROR;
}

//**********************************************************************
//
// COleClientSite::OnShowWindow
//
// Purpose:
//
//      Object calls this method when it is opening/closing non-InPlace
//      Window
//
// Parameters:
//
//      BOOL fShow  - TRUE if Window is opening, FALSE if closing
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      InvalidateRect              Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleClientSite::OnShowWindow(BOOL fShow)
{
    TraceMsg(TF_GENERAL, "In IOCS::OnShowWindow\r\n");
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleClientSite::RequestNewObjectLayout
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleClientSite::RequestNewObjectLayout()
{
    TraceMsg(TF_GENERAL, "In IOCS::RequestNewObjectLayout\r\n");
    return ResultFromScode(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\icwwalk.h ===
class CICWWalker : public IICWWalker
{
    public:
        // IICWWalker
        virtual HRESULT STDMETHODCALLTYPE Walk();
        virtual HRESULT STDMETHODCALLTYPE AttachToDocument         (IWebBrowser2* lpWebBrowser);
        virtual HRESULT STDMETHODCALLTYPE AttachToMSHTML           (BSTR bstrURL);
        virtual HRESULT STDMETHODCALLTYPE ExtractUnHiddenText      (BSTR* pbstrText);
        virtual HRESULT STDMETHODCALLTYPE Detach                   ();
        virtual HRESULT STDMETHODCALLTYPE InitForMSHTML            ();
        virtual HRESULT STDMETHODCALLTYPE TermForMSHTML            ();
        virtual HRESULT STDMETHODCALLTYPE LoadURLFromFile          (BSTR bstrURL);
        virtual HRESULT STDMETHODCALLTYPE ProcessOLSFile           (IWebBrowser2* lpWebBrowser);
        virtual HRESULT STDMETHODCALLTYPE get_PageType             (LPDWORD pdwPageType);
        virtual HRESULT STDMETHODCALLTYPE get_IsQuickFinish        (BOOL* pbIsQuickFinish);
        virtual HRESULT STDMETHODCALLTYPE get_PageFlag             (LPDWORD pdwPageFlag);
        virtual HRESULT STDMETHODCALLTYPE get_PageID               (BSTR* pbstrPageID);
        virtual HRESULT STDMETHODCALLTYPE get_URL                  (LPTSTR lpszURL, BOOL bForward);
        virtual HRESULT STDMETHODCALLTYPE get_FirstFormQueryString (LPTSTR lpszQuery);
        virtual HRESULT STDMETHODCALLTYPE get_IeakIspFile          (LPTSTR lpszIspFile);

        // IUNKNOWN
        virtual HRESULT STDMETHODCALLTYPE QueryInterface (REFIID theGUID, void** retPtr);
        virtual ULONG   STDMETHODCALLTYPE AddRef         (void);
        virtual ULONG   STDMETHODCALLTYPE Release        (void);

        CICWWalker  (CServer* pServer);
        ~CICWWalker (void);

        // Each instance of the ICWWalker object will need a walker object (it does the work)
        CWalker* m_pHTMLWalker;
        
    private:
        LONG      m_lRefCount;        
        IUnknown* m_pUnkOuter; // Outer unknown (aggregation & delegation).
        CServer*  m_pServer;   // Pointer to this component server's control object.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\ioipf.h ===
//**********************************************************************
// File name: IOIPF.H
//
//      Definition of COleInPlaceFrame
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOIPF_H_ )
#define _IOIPF_H_


// Use the SITE as the frame
class COleSite;

interface COleInPlaceFrame : public IOleInPlaceFrame
{
    int m_nCount;
    COleSite FAR * m_pSite;

    COleInPlaceFrame(COleSite FAR * pSite) {
        m_pSite = pSite;
        m_nCount = 0;
        };

    ~COleInPlaceFrame() {
        assert(m_nCount == 0);
        };

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP GetWindow (HWND FAR* lphwnd);
    STDMETHODIMP ContextSensitiveHelp (BOOL fEnterMode);

    // *** IOleInPlaceUIWindow methods ***
    STDMETHODIMP GetBorder (LPRECT lprectBorder);
    STDMETHODIMP RequestBorderSpace (LPCBORDERWIDTHS lpborderwidths);
    STDMETHODIMP SetBorderSpace (LPCBORDERWIDTHS lpborderwidths);
  //@@WTK WIN32, UNICODE
    //STDMETHODIMP SetActiveObject (LPOLEINPLACEACTIVEOBJECT lpActiveObject,LPCSTR lpszObjName);
    STDMETHODIMP SetActiveObject (LPOLEINPLACEACTIVEOBJECT lpActiveObject,LPCOLESTR lpszObjName);

    // *** IOleInPlaceFrame methods ***
    STDMETHODIMP InsertMenus (HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHODIMP SetMenu (HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHODIMP RemoveMenus (HMENU hmenuShared);
  //@@WTK WIN32, UNICODE
    //STDMETHODIMP SetStatusText (LPCSTR lpszStatusText);
    STDMETHODIMP SetStatusText (LPCOLESTR lpszStatusText);
    STDMETHODIMP EnableModeless (BOOL fEnable);
    STDMETHODIMP TranslateAccelerator (LPMSG lpmsg, WORD wID);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\ioipf.cpp ===
//**********************************************************************
// File name: IOIPF.CPP
//
//      Implementation file for COleInPlaceFrame
//
// Functions:
//
//      See IOIPF.H for class definition
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"


//**********************************************************************
//
// CConnWizApp::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the Interface level.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      CConnWizApp::QueryInterface  APP.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
        TraceMsg(TF_GENERAL, "In IOIPF::QueryInterface\r\n");

// delegate to the document Object
        return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CConnWizApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the interface level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface.
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceFrame::AddRef()
{
    TraceMsg(TF_GENERAL, "In IOIPF::AddRef\r\n");

    // delegate to the document Object
    m_pSite->AddRef();
    
    // increment the interface reference count
    return ++m_nCount;
}

//**********************************************************************
//
// CConnWizApp::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface.
//
// Function Calls:
//      Function                    Location
//
//      CConnWizApp::Release         APP.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceFrame::Release()
{
    TraceMsg(TF_GENERAL, "In IOIPF::Release\r\n");

    // delegate to the document object
    m_pSite->Release();

    // decrement the interface reference count
    return --m_nCount;
}

//**********************************************************************
//
// COleInPlaceFrame::GetWindow
//
// Purpose:
//
//      Returns the frame window handle
//
// Parameters:
//
//      HWND FAR* lphwnd    - Location to return the window handle
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::GetWindow (HWND FAR* lphwnd)
{
    TraceMsg(TF_GENERAL, "In IOIPF::GetWindow\r\n");
    
    *lphwnd = m_pSite->m_hWnd;
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::ContextSensitiveHelp
//
// Purpose:
//
//      Used in implementing Context sensitive help
//
// Parameters:
//
//      BOOL fEnterMode -   TRUE if starting Context Sensitive help mode
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//      Be sure to read the technotes in the OLE toolkit.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::ContextSensitiveHelp (BOOL fEnterMode)
{
    TraceMsg(TF_GENERAL, "In IOIPF::ContextSensitiveHelp\r\n");

    return ResultFromScode(S_OK);
}
//**********************************************************************
//
// COleInPlaceFrame::GetBorder
//
// Purpose:
//
//      Returns the outermost border that frame adornments can be attached
//      during InPlace Activation.
//
// Parameters:
//
//      LPRECT lprectBorder - return parameter to contain the outermost
//                            rect for frame adornments
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CopyRect                    Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::GetBorder (LPRECT lprectBorder)
{
    RECT rect;

    TraceMsg(TF_GENERAL, "In IOIPF::GetBorder\r\n");

    // get the rect for the entire frame.
    GetClientRect(m_pSite->m_hWnd, &rect);

    CopyRect(lprectBorder, &rect);

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::RequestBorderSpace
//
// Purpose:
//
//      Approves/Denies requests for border space during InPlace
//      negotiation.
//
// Parameters:
//
//      LPCBORDERWIDTHS lpborderwidths  - The width in pixels needed on
//                                        each side of the frame.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//      This implementation doesn't care about how much border space
//      is used.  It always returns S_OK.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::RequestBorderSpace (LPCBORDERWIDTHS lpborderwidths)
{
    TraceMsg(TF_GENERAL, "In IOIPF::RequestBorderSpace\r\n");

    // always approve the request
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::SetBorderSpace
//
// Purpose:
//
//      The object calls this method when it is actually going to
//      start using the border space.
//
// Parameters:
//
//      LPCBORDERWIDTHS lpborderwidths  - Border space actually being used
//                                        by the object
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                        Location
//
//      CConnWizApp::AddFrameLevelTools  APP.CPP
//      GetClientRect                   Windows API
//      MoveWindow                      Windows API
//      ResultFromScode                 Windows API
//
// Comments:
//
//      This routine could be a little smarter and check to see if
//      the object is requesting the entire client area of the
//      window.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetBorderSpace (LPCBORDERWIDTHS lpborderwidths)
{

    TraceMsg(TF_GENERAL, "In IOIPF::SetBorderSpace\r\n");
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::SetActiveObject
//
// Purpose:
//
//
// Parameters:
//
//      LPOLEINPLACEACTIVEOBJECT lpActiveObject     -   Pointer to the
//                                                      objects
//                                                      IOleInPlaceActiveObject
//                                                      interface
//
//@@WTK WIN32, UNICODE
//      //LPCSTR lpszObjName                          -   Name of the object
//      LPCOLESTR lpszObjName                          -   Name of the object
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      IOleInPlaceActiveObject::AddRef     Object
//      IOleInPlaceActiveObject::Release    Object
//      ResultFromScode                     OLE API
//
// Comments:
//
//********************************************************************

//@@WTK WIN32, UNICODE
//STDMETHODIMP COleInPlaceFrame::SetActiveObject (LPOLEINPLACEACTIVEOBJECT lpActiveObject,LPCSTR lpszObjName)
STDMETHODIMP COleInPlaceFrame::SetActiveObject (
LPOLEINPLACEACTIVEOBJECT lpActiveObject,
LPCOLESTR lpszObjName)
{
    TraceMsg(TF_GENERAL, "In IOIPF::SetActiveObject\r\n");
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::InsertMenus
//
// Purpose:
//
//      Inserts the container menu into the combined menu
//
// Parameters:
//
//      HMENU hmenuShared                   -   Menu Handle to be set.
//      LPOLEMENUGROUPWIDTHS lpMenuWidths   -   Width of menus
//
// Return Value:
//
// Function Calls:
//      Function                    Location
//
//      AppendMenu                  Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::InsertMenus (HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
        TraceMsg(TF_GENERAL, "In IOIPF::InsertMenus\r\n");
        return ResultFromScode(S_OK);
}


//**********************************************************************
//
// COleInPlaceFrame::SetMenu
//
// Purpose:
//
//      Sets the application menu to the combined menu
//
// Parameters:
//
//      HMENU hmenuShared       - The combined menu
//
//      HOLEMENU holemenu       - Used by OLE
//
//      HWND hwndActiveObject   - Used by OLE
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      SetMenu                     Windows API
//      OleSetMenuDescriptor        OLE API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetMenu (HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{

        TraceMsg(TF_GENERAL, "In IOIPF::SetMenu\r\n");
        return ResultFromScode(S_OK);
}


//**********************************************************************
//
// COleInPlaceFrame::RemoveMenus
//
// Purpose:
//
//      Removes the container menus from the combined menu
//
// Parameters:
//
//      HMENU hmenuShared   - Handle to the combined menu.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      GetMenuItemCount            Windows API
//      RemoveMenu                  Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::RemoveMenus (HMENU hmenuShared)
{
        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::SetStatusText
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      This function is not implemented due to the fact
//      that this application does not have a status bar.
//
//********************************************************************

//@@WTK WIN32, UNICODE
//STDMETHODIMP COleInPlaceFrame::SetStatusText (LPCSTR lpszStatusText)
STDMETHODIMP COleInPlaceFrame::SetStatusText (LPCOLESTR lpszStatusText)
{
        return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceFrame::EnableModeless
//
// Purpose:
//
//      Enables/Disables container modeless dialogs
//
// Parameters:
//
//      BOOL fEnable    - Enable/Disable
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      There are no modeless dialogs in this application, so the
//      implementation of this method is trivial.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::EnableModeless (BOOL fEnable)
{
        TraceMsg(TF_GENERAL, "In IOIPF::EnableModeless\r\n");
        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::TranslateAccelerator
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::TranslateAccelerator (LPMSG lpmsg, WORD wID)
{
        TraceMsg(TF_GENERAL, "In IOIPF::TranslateAccelerator\r\n");
        return ResultFromScode(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\ioips.h ===
//**********************************************************************
// File name: IOIPS.H
//
//      Definition of COleInPlaceSite
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOIPS_H_ )
#define _IOIPS_H_


class COleSite;

interface COleInPlaceSite : public IOleInPlaceSite
{
    int m_nCount;
    COleSite FAR * m_pSite;

    COleInPlaceSite(COleSite FAR *pSite) {
        m_pSite = pSite;
        m_nCount = 0;
        };

    ~COleInPlaceSite() {
        assert(m_nCount == 0);
        };

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP GetWindow (HWND FAR* lphwnd);
    STDMETHODIMP ContextSensitiveHelp (BOOL fEnterMode);

    // *** IOleInPlaceSite methods ***
    STDMETHODIMP CanInPlaceActivate ();
    STDMETHODIMP OnInPlaceActivate ();
    STDMETHODIMP OnUIActivate ();
    STDMETHODIMP GetWindowContext (LPOLEINPLACEFRAME FAR* lplpFrame,
                                   LPOLEINPLACEUIWINDOW FAR* lplpDoc,
                                   LPRECT lprcPosRect,
                                   LPRECT lprcClipRect,
                                   LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHODIMP Scroll (SIZE scrollExtent);
    STDMETHODIMP OnUIDeactivate (BOOL fUndoable);
    STDMETHODIMP OnInPlaceDeactivate ();
    STDMETHODIMP DiscardUndoState ();
    STDMETHODIMP DeactivateAndUndo ();
    STDMETHODIMP OnPosRectChange (LPCRECT lprcPosRect);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\ispdata.h ===
#ifndef   _ISPDATA_H
#define  _ISPDATA_H

#include "icwhelp.h"
#include "appdefs.h"


typedef BOOL (* VALIDATECONTENT)    (LPCTSTR lpData);

enum IPSDataContentValidators
{
    ValidateCCNumber = 0,
    ValidateCCExpire
};    

typedef struct tag_ISPDATAELEMENT
{
    LPCTSTR         lpQueryElementName;             // Static name to put in query string
    LPTSTR          lpQueryElementValue;            // data for element
    WORD            idContentValidator;             // id of content validator 
    WORD            wValidateNameID;                // validation element name string ID
    DWORD           dwValidateFlag;                 // validation bit flag for this element
}ISPDATAELEMENT, *LPISPDATAELEMENT;

class CICWISPData : public IICWISPData
{
    public:

        // IICWISPData
        virtual BOOL    STDMETHODCALLTYPE   PutDataElement(WORD wElement, LPCTSTR lpValue, WORD wValidateLevel);
        virtual HRESULT STDMETHODCALLTYPE   GetQueryString(BSTR bstrBaseURL, BSTR *lpReturnURL);
        virtual LPCTSTR STDMETHODCALLTYPE   GetDataElement(WORD wElement)
        {
            ASSERT(wElement < ISPDATAELEMENTS_LEN);
            return (m_ISPDataElements[wElement].lpQueryElementValue);
        };
        
        virtual void STDMETHODCALLTYPE      PutValidationFlags(DWORD dwFlags)
        {
            m_dwValidationFlags = dwFlags;
        };
        
        virtual void STDMETHODCALLTYPE      Init(HWND   hWndParent)
        {
            m_hWndParent = hWndParent;
        };
        
        // IUNKNOWN
        virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID theGUID, void** retPtr );
        virtual ULONG   STDMETHODCALLTYPE AddRef( void );
        virtual ULONG   STDMETHODCALLTYPE Release( void );

        CICWISPData(CServer* pServer );
        ~CICWISPData();

private:
        BOOL    bValidateContent(WORD   wFunctionID, LPCTSTR  lpData);
        
        LPISPDATAELEMENT    m_ISPDataElements;

        HWND                m_hWndParent;       // parent for messages
        DWORD               m_dwValidationFlags;
        // For class object management
        LONG                m_lRefCount;
        CServer*            m_pServer;    // Pointer to this component server's control object.
};
#endif //_ISPDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\ioips.cpp ===
//**********************************************************************
// File name: IOIPS.CPP
//
//      Implementation file for COleInPlaceSite
//
// Functions:
//
//      See IOIPS.H for class Definition
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"

//**********************************************************************
//
// CConnWizSite::COleInPlaceSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the interface level.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      CConnWizSite::QueryInterface SITE.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
        TraceMsg(TF_GENERAL, "In IOIPS::QueryInterface\r\n");

        // delegate to the container Site
        return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CConnWizSite::COleInPlaceSite::AddRef
//
// Purpose:
//
//      Adds to the reference count at the interface level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface.
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceSite::AddRef()
{
        TraceMsg(TF_GENERAL, "In IOIPS::AddRef\r\n");

        // increment the interface reference count (for debugging only)
        ++m_nCount;

        // delegate to the container Site
        return m_pSite->AddRef();
}

//**********************************************************************
//
// CConnWizSite::COleInPlaceSite::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface.
//
// Function Calls:
//      Function                    Location
//
//      CConnWizSite::Release        SITE.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceSite::Release()
{
        TraceMsg(TF_GENERAL, "In IOIPS::Release\r\n");
        // decrement the interface reference count (for debugging only)
        m_nCount--;

        // delegate to the container Site
        return m_pSite->Release();
}

//**********************************************************************
//
// COleInPlaceSite::GetWindow
//
// Purpose:
//
//      Returns the Window Handle of the client site
//
// Parameters:
//
//      HWND FAR* lphwnd    - place to return the handle
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::GetWindow (HWND FAR* lphwnd)
{
        TraceMsg(TF_GENERAL, "In IOIPS::GetWindow\r\n");

        // return the handle to our editing window.
        *lphwnd = m_pSite->m_hWnd;

        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::ContextSensitiveHelp
//
// Purpose:
//
//
// Parameters:
//
//      BOOL fEnterMode - TRUE for entering Context Sensitive help mode
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//      Be sure to read the technotes included with the OLE toolkit.
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::ContextSensitiveHelp (BOOL fEnterMode)
{
        TraceMsg(TF_GENERAL, "In IOIPS::ContextSensitiveHelp\r\n");

        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::CanInPlaceActivate
//
// Purpose:
//
//      Object calls to find out if the container can InPlace activate
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::CanInPlaceActivate ()
{
        TraceMsg(TF_GENERAL, "In IOIPS::CanInPlaceActivate\r\n");
        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::OnInPlaceActivate
//
// Purpose:
//
//      Called by the object on InPlace Activation
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnInPlaceActivate ()
{
        HRESULT hrErr;
        TraceMsg(TF_GENERAL, "In IOIPS::OnInPlaceActivate\r\n");

        hrErr = m_pSite->m_lpOleObject->QueryInterface(
                        IID_IOleInPlaceObject, (LPVOID FAR *)&m_pSite->m_lpInPlaceObject);
        if (hrErr != NOERROR)
                return ResultFromScode(E_FAIL);

        // return S_OK to indicate we can in-place activate.
        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::OnUIActivate
//
// Purpose:
//
//      Object calls this method when it displays it's UI.
//
// Parameters:
//
//      None.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnUIActivate ()
{
        TraceMsg(TF_GENERAL, "In IOIPS::OnUIActivate\r\n");

//        m_pSite->m_lpDoc->m_fAddMyUI=FALSE;
//        m_pSite->m_lpDoc->m_fInPlaceActive = TRUE;
        m_pSite->m_fInPlaceActive = TRUE;

        m_pSite->m_lpInPlaceObject->GetWindow((HWND FAR*)&m_pSite->m_hwndIPObj);

        // return S_OK to continue in-place activation
        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::GetWindowContext
//
// Purpose:
//
//      Called by the object to get information for InPlace Negotiation.
//
// Parameters:
//
//      LPOLEINPLACEFRAME FAR* lplpFrame    - Location to return a pointer
//                                            to IOleInPlaceFrame.
//
//      LPOLEINPLACEUIWINDOW FAR* lplpDoc   - Location to return a pointer
//                                            to IOleInPlaceUIWindow.
//
//      LPRECT lprcPosRect                  - The rect that the object
//                                            occupies
//
//      LPRECT lprcClipRect                 - The clipping rect
//
//      LPOLEINPLACEFRAMEINFO lpFrameInfo   - Pointer to FRAMEINFO
//
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      COleInPlaceFrame::AddRef    IOIPF.CPP
//      CConnWizSite::GetObjRect     SITE.CPP
//      SetMapMode                  Windows API
//      GetDC                       Windows API
//      ReleaseDC                   Windows API
//      CopyRect                    Windows API
//      GetClientRect               Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::GetWindowContext (LPOLEINPLACEFRAME FAR* lplpFrame,
                                                           LPOLEINPLACEUIWINDOW FAR* lplpDoc,
                                                           LPRECT lprcPosRect,
                                                           LPRECT lprcClipRect,
                                                           LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
        RECT rect;

        TraceMsg(TF_GENERAL, "In IOIPS::GetWindowContext\r\n");

        // the frame is associated with the application object.
        // need to AddRef() it...
        m_pSite->m_OleInPlaceFrame.AddRef();
        *lplpFrame = &m_pSite->m_OleInPlaceFrame;
        *lplpDoc = NULL;  // must be NULL, cause we're SDI.

        // get the size of the object in pixels
        m_pSite->GetObjRect(&rect);

        // Copy this to the passed buffer
        CopyRect(lprcPosRect, &rect);

        // fill the clipping region
        GetClientRect(m_pSite->m_hWnd, &rect);
        CopyRect(lprcClipRect, &rect);

        // fill the FRAMEINFO
        lpFrameInfo->fMDIApp = FALSE;
        lpFrameInfo->hwndFrame = m_pSite->m_hWnd;
        lpFrameInfo->haccel = NULL;
        lpFrameInfo->cAccelEntries = 0;

        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::Scroll
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::Scroll (SIZE scrollExtent)
{
        TraceMsg(TF_GENERAL, "In IOIPS::Scroll\r\n");
        return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceSite::OnUIDeactivate
//
// Purpose:
//
//      Called by the object when its UI goes away
//
// Parameters:
//
//       BOOL fUndoable
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      CConnWizAPP::AddFrameLevelUI APP.CPP
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnUIDeactivate (BOOL fUndoable)
{
        // need to clear this flag first
        m_pSite->m_fInPlaceActive = FALSE;

        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::OnInPlaceDeactivate
//
// Purpose:
//
//      Called when the inplace session is over
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnInPlaceDeactivate ()
{
        if (m_pSite->m_lpInPlaceObject) {
                m_pSite->m_lpInPlaceObject->Release();
                m_pSite->m_lpInPlaceObject = NULL;
        }
        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::DiscardUndoState
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::DiscardUndoState ()
{
        TraceMsg(TF_GENERAL, "In IOIPS::DiscardUndoState\r\n");
        return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceSite::DeactivateAndUndo
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::DeactivateAndUndo ()
{
        TraceMsg(TF_GENERAL, "In IOIPS::DeactivateAndUndo\r\n");
        return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceSite::OnPosRectChange
//
// Purpose:
//
//      The object calls this method when it's size changes during an
//      InPlace Session
//
// Parameters:
//
//      LPCRECT lprcPosRect -   The new object rect
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      GetClientRect                       Windows API
//      IOleObject::GetExtent               Object
//      IOleObject::QueryInterface          Object
//      IOleInPlaceObject::SetObjectRects   Object
//      IOleInPlaceObject::Release          Object
//      ResultFromScode                     OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnPosRectChange (LPCRECT lprcPosRect)
{
    return ResultFromScode(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\ispdata.cpp ===
#include "pre.h"
#include "tchar.h"
#include "webvwids.h"

#pragma data_seg(".data")

// The following are the names for the name/value pairs that will be passed as a query string to the
// ISP signup server
const TCHAR csz_USER_FIRSTNAME[]        = TEXT("USER_FIRSTNAME");
const TCHAR csz_USER_LASTNAME[]         = TEXT("USER_LASTNAME");
const TCHAR csz_USER_ADDRESS[]          = TEXT("USER_ADDRESS");
const TCHAR csz_USER_MOREADDRESS[]      = TEXT("USER_MOREADDRESS");
const TCHAR csz_USER_CITY[]             = TEXT("USER_CITY");
const TCHAR csz_USER_STATE[]            = TEXT("USER_STATE");
const TCHAR csz_USER_ZIP[]              = TEXT("USER_ZIP");
const TCHAR csz_USER_PHONE[]            = TEXT("USER_PHONE");
const TCHAR csz_AREACODE[]              = TEXT("AREACODE");
const TCHAR csz_COUNTRYCODE[]           = TEXT("COUNTRYCODE");
const TCHAR csz_USER_FE_NAME[]          = TEXT("USER_FE_NAME");
const TCHAR csz_PAYMENT_TYPE[]          = TEXT("PAYMENT_TYPE");
const TCHAR csz_PAYMENT_BILLNAME[]      = TEXT("PAYMENT_BILLNAME");
const TCHAR csz_PAYMENT_BILLADDRESS[]   = TEXT("PAYMENT_BILLADDRESS");
const TCHAR csz_PAYMENT_BILLEXADDRESS[] = TEXT("PAYMENT_BILLEXADDRESS");
const TCHAR csz_PAYMENT_BILLCITY[]      = TEXT("PAYMENT_BILLCITY");
const TCHAR csz_PAYMENT_BILLSTATE[]     = TEXT("PAYMENT_BILLSTATE");
const TCHAR csz_PAYMENT_BILLZIP[]       = TEXT("PAYMENT_BILLZIP");
const TCHAR csz_PAYMENT_BILLPHONE[]     = TEXT("PAYMENT_BILLPHONE");
const TCHAR csz_PAYMENT_DISPLAYNAME[]   = TEXT("PAYMENT_DISPLAYNAME");
const TCHAR csz_PAYMENT_CARDNUMBER[]    = TEXT("PAYMENT_CARDNUMBER");
const TCHAR csz_PAYMENT_EXMONTH[]       = TEXT("PAYMENT_EXMONTH");
const TCHAR csz_PAYMENT_EXYEAR[]        = TEXT("PAYMENT_EXYEAR");
const TCHAR csz_PAYMENT_CARDHOLDER[]    = TEXT("PAYMENT_CARDHOLDER");
const TCHAR csz_SIGNED_PID[]            = TEXT("SIGNED_PID");
const TCHAR csz_GUID[]                  = TEXT("GUID");
const TCHAR csz_OFFERID[]               = TEXT("OFFERID");
const TCHAR csz_USER_COMPANYNAME[]      = TEXT("USER_COMPANYNAME");
const TCHAR csz_ICW_VERSION[]           = TEXT("ICW_Version");

// NOTE: This order of this table is dependant on the order ot the ENUM in WEBVIEW.H for ISPDATA element.
// DO NOT CHANGE 1 without CHANGING the other!!!!!
ISPDATAELEMENT aryISPDataElements[] = 
{
    { csz_USER_FIRSTNAME,       NULL,   0,                  IDS_USERINFO_FIRSTNAME,     REQUIRE_FIRSTNAME          },
    { csz_USER_LASTNAME,        NULL,   0,                  IDS_USERINFO_LASTNAME,      REQUIRE_LASTNAME           },
    { csz_USER_ADDRESS,         NULL,   0,                  IDS_USERINFO_ADDRESS1,      REQUIRE_ADDRESS            },
    { csz_USER_MOREADDRESS,     NULL,   0,                  IDS_USERINFO_ADDRESS2,      REQUIRE_MOREADDRESS        },
    { csz_USER_CITY,            NULL,   0,                  IDS_USERINFO_CITY,          REQUIRE_CITY               },
    { csz_USER_STATE,           NULL,   0,                  IDS_USERINFO_STATE,         REQUIRE_STATE              },
    { csz_USER_ZIP,             NULL,   0,                  IDS_USERINFO_ZIP,           REQUIRE_ZIP                },
    { csz_USER_PHONE,           NULL,   0,                  IDS_USERINFO_PHONE,         REQUIRE_PHONE              },
    { csz_AREACODE,             NULL,   0,                  0,                          0                          },
    { csz_COUNTRYCODE,          NULL,   0,                  0,                          0                          },
    { csz_USER_FE_NAME,         NULL,   0,                  IDS_USERINFO_FE_NAME,       REQUIRE_FE_NAME            },
    { csz_PAYMENT_TYPE,         NULL,   0,                  0,                          0                          },
    { csz_PAYMENT_BILLNAME,     NULL,   0,                  IDS_PAYMENT_PBNAME,         REQUIRE_PHONEIV_BILLNAME   },
    { csz_PAYMENT_BILLADDRESS,  NULL,   0,                  IDS_PAYMENT_CCADDRESS,      REQUIRE_CCADDRESS          },
    { csz_PAYMENT_BILLEXADDRESS,NULL,   0,                  IDS_USERINFO_ADDRESS2,      REQUIRE_IVADDRESS2         },
    { csz_PAYMENT_BILLCITY,     NULL,   0,                  IDS_USERINFO_CITY,          REQUIRE_IVCITY             },
    { csz_PAYMENT_BILLSTATE,    NULL,   0,                  IDS_USERINFO_STATE,         REQUIRE_IVSTATE            },
    { csz_PAYMENT_BILLZIP,      NULL,   0,                  IDS_USERINFO_ZIP,           REQUIRE_IVZIP              },
    { csz_PAYMENT_BILLPHONE,    NULL,   0,                  IDS_PAYMENT_PBNUMBER,       REQUIRE_PHONEIV_ACCNUM     },
    { csz_PAYMENT_DISPLAYNAME,  NULL,   0,                  0,                          0                          },
    { csz_PAYMENT_CARDNUMBER,   NULL,   ValidateCCNumber,   IDS_PAYMENT_CCNUMBER,       REQUIRE_CCNUMBER           },
    { csz_PAYMENT_EXMONTH,      NULL,   0,                  0,                          0                          },
    { csz_PAYMENT_EXYEAR,       NULL,   ValidateCCExpire,   0,                          0                          },
    { csz_PAYMENT_CARDHOLDER,   NULL,   0,                  IDS_PAYMENT_CCNAME,         REQUIRE_CCNAME             },
    { csz_SIGNED_PID,           NULL,   0,                  0,                          0                          },
    { csz_GUID,                 NULL,   0,                  0,                          0                          },
    { csz_OFFERID,              NULL,   0,                  0,                          0                          },
    { NULL,                     NULL,   0,                  0,                          0                          },
    { NULL,                     NULL,   0,                  0,                          0                          },
    { csz_USER_COMPANYNAME,     NULL,   0,                  IDS_USERINFO_COMPANYNAME,   REQUIRE_COMPANYNAME        },
    { csz_ICW_VERSION,          NULL,   0,                  0,                          0                          }
}; 

#define ISPDATAELEMENTS_LEN sizeof(aryISPDataElements) / sizeof(ISPDATAELEMENT)

#pragma data_seg()

//+----------------------------------------------------------------------------
//
//  Function    CICWISPData:CICWISPData
//
//  Synopsis    This is the constructor, nothing fancy
//
//-----------------------------------------------------------------------------
CICWISPData::CICWISPData
(
    CServer* pServer
) 
{
    TraceMsg(TF_CWEBVIEW, "CICWISPData constructor called");
    m_lRefCount = 0;
    
    // Initialize the data elements array
    m_ISPDataElements = aryISPDataElements;
    
    // Assign the pointer to the server control object.
    m_pServer = pServer;
}

CICWISPData::~CICWISPData()
{
    // Walk through and free any allocated values in m_ISPDataElements
    for (int i = 0; i < ISPDATAELEMENTS_LEN; i ++)
    {
        if (m_ISPDataElements[i].lpQueryElementValue)
            free(m_ISPDataElements[i].lpQueryElementValue);
    }
}

// BUGBUG need a destructor to walk the array and free the lpQueryElementValue members

//+----------------------------------------------------------------------------
//
//  Function    CICWISPData::QueryInterface
//
//  Synopsis    This is the standard QI, with support for
//              IID_Unknown, IICW_Extension and IID_ICWApprentice
//              (stolen from Inside COM, chapter 7)
//
//
//-----------------------------------------------------------------------------
HRESULT CICWISPData::QueryInterface( REFIID riid, void** ppv )
{
    TraceMsg(TF_CWEBVIEW, "CICWISPData::QueryInterface");
    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    // IID_IICWISPData
    if (IID_IICWISPData == riid)
        *ppv = (void *)(IICWISPData *)this;
    // IID_IUnknown
    else if (IID_IUnknown == riid)
        *ppv = (void *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function    CICWISPData::AddRef
//
//  Synopsis    This is the standard AddRef
//
//
//-----------------------------------------------------------------------------
ULONG CICWISPData::AddRef( void )
{
    TraceMsg(TF_CWEBVIEW, "CICWISPData::AddRef %d", m_lRefCount + 1);
    return InterlockedIncrement(&m_lRefCount) ;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWISPData::Release
//
//  Synopsis    This is the standard Release
//
//
//-----------------------------------------------------------------------------
ULONG CICWISPData::Release( void )
{
    ASSERT( m_lRefCount > 0 );

    InterlockedDecrement(&m_lRefCount);

    TraceMsg(TF_CWEBVIEW, "CICWISPData::Release %d", m_lRefCount);
    if( 0 == m_lRefCount )
    {
        if (NULL != m_pServer)
            m_pServer->ObjectsDown();
    
        delete this;
        return 0;
    }
    return( m_lRefCount );
}


BOOL CICWISPData::PutDataElement
(
    WORD wElement, 
    LPCTSTR lpValue, 
    WORD wValidateLevel
)
{
    ASSERT(wElement < ISPDATAELEMENTS_LEN);
    
    BOOL                bValid = TRUE;
    LPISPDATAELEMENT    lpElement = &m_ISPDataElements[wElement];
    
    ASSERT(lpElement);
        
    if (wValidateLevel > ISPDATA_Validate_None)
    {
        // See if we even need to validate.  A validateflag of 0 means we always validate
        if ((0 == lpElement->dwValidateFlag) || m_dwValidationFlags & lpElement->dwValidateFlag)
        {
            // process based on validation level
            switch (wValidateLevel)
            {
                case ISPDATA_Validate_DataPresent:
                {
                    bValid = IsValid(lpValue, m_hWndParent, lpElement->wValidateNameID);
                    break;
                }
                
                case ISPDATA_Validate_Content:
                {
                    bValid = bValidateContent(lpElement->idContentValidator, lpValue);
                    break;
                }
            }
        }            
    }   
     
    // If the element is valid, then store it.
    if (bValid)
    {
        // If this elemement has been previously set the free it
        if (lpElement->lpQueryElementValue)
            free(lpElement->lpQueryElementValue);
        
        // lpValue can be NULL
        if (lpValue)    
            lpElement->lpQueryElementValue = _tcsdup(lpValue);
        else
            lpElement->lpQueryElementValue = NULL;
                    
    }        
    return (bValid);
}

// This funtion will form the query string to be sent to the ISP signup server
// 
HRESULT CICWISPData::GetQueryString
(
    BSTR    bstrBaseURL,
    BSTR    *lpReturnURL    
)
{
    LPTSTR              lpWorkingURL;
    WORD                cbBuffer = 0;
    LPISPDATAELEMENT    lpElement;
    LPTSTR              lpszBaseURL = W2A(bstrBaseURL);
    int                 i;
       
    ASSERT(lpReturnURL);
    if (!lpReturnURL)
        return E_FAIL;
                
    // Calculate how big of a buffer we will need
    cbBuffer += (WORD)lstrlen(lpszBaseURL);
    cbBuffer += 1;                      // For the & or the ?
    for (i = 0; i < ISPDATAELEMENTS_LEN; i ++)
    {
        lpElement = &m_ISPDataElements[i];
        ASSERT(lpElement);
        if (lpElement->lpQueryElementName)
        {
            cbBuffer += (WORD)lstrlen(lpElement->lpQueryElementName);
            cbBuffer += (WORD)lstrlen(lpElement->lpQueryElementValue) * 3;       // *3 for encoding
            cbBuffer += 3;              // For the = and & and the terminator (because we copy
                                        // lpQueryElementValue into a new buffer for encoding
        }
        else
        {
            cbBuffer += (WORD)lstrlen(lpElement->lpQueryElementValue);
            cbBuffer += 1;              // for the trailing &
        }        
    }
    cbBuffer += 1;                     // Terminator
    
    // Allocate a buffer large enough
    if (NULL == (lpWorkingURL = (LPTSTR)GlobalAllocPtr(GPTR, sizeof(TCHAR)*cbBuffer)))
        return E_FAIL;
        
    lstrcpy(lpWorkingURL, lpszBaseURL);
    
    // See if this ISP provided URL is already a Query String.
    if (NULL != _tcschr(lpWorkingURL, TEXT('?')))
        lstrcat(lpWorkingURL, cszAmpersand);      // Append our params
    else
        lstrcat(lpWorkingURL, cszQuestion);       // Start with our params

    for (i = 0; i < ISPDATAELEMENTS_LEN; i ++)
    {
        lpElement = &m_ISPDataElements[i];
        ASSERT(lpElement);
            
        if (lpElement->lpQueryElementName)
        {
            // If there is a query value, then encode it
            if (lpElement->lpQueryElementValue)
            {
                // Allocate a buffer to encode into
                size_t size = (sizeof(TCHAR)* lstrlen(lpElement->lpQueryElementValue))*3;
                LPTSTR lpszVal = (LPTSTR) malloc(size+sizeof(TCHAR));

                //
                // If allocation fails, the error is ignored. The URL may
                // or may not work.
                //
                if (lpszVal)
                {                
                    lstrcpy(lpszVal, lpElement->lpQueryElementValue);
                    URLEncode(lpszVal, size);
            
                    URLAppendQueryPair(lpWorkingURL, 
                                       (LPTSTR)lpElement->lpQueryElementName,
                                       lpszVal);
                    free(lpszVal);
                }

            }   
            else
            {
                URLAppendQueryPair(lpWorkingURL, 
                                   (LPTSTR)lpElement->lpQueryElementName,
                                   NULL);
            }             
        }                                   
        else
        {
            if (lpElement->lpQueryElementValue)
            {
                lstrcat(lpWorkingURL, lpElement->lpQueryElementValue);
                lstrcat(lpWorkingURL, cszAmpersand);                                        
            }                
        }    
    }    
    
    // Terminate the working URL properly, by removing the trailing ampersand
    lpWorkingURL[lstrlen(lpWorkingURL)-1] = '\0';
    
    
    // Set the return VALUE.  We must allocate here, since the caller will free
    // this returned string, and A2W only puts the string in the stack
    *lpReturnURL = SysAllocString(A2W(lpWorkingURL));
    
    // Free the buffer
    GlobalFreePtr(lpWorkingURL);
    
    return (S_OK);
}


// Dispatch functioin to handle content specific validation
BOOL    CICWISPData::bValidateContent
(
    WORD        wFunctionID,
    LPCTSTR     lpData
)
{
    BOOL    bValid = FALSE;
    
    switch (wFunctionID)
    {
        case ValidateCCNumber:
            bValid = validate_cardnum(m_hWndParent, lpData);
            break;

        case ValidateCCExpire:
        {
            int iMonth = _ttoi(m_ISPDataElements[ISPDATA_PAYMENT_EXMONTH].lpQueryElementValue);
            int iYear = _ttoi(lpData);
    
            bValid = validate_cardexpdate(m_hWndParent, iMonth, iYear);

            //Because of Y2K we are going to work with this pointer
            //we will assume year is 5 char in len
            if (bValid)
            {
                TCHAR szY2KYear [3] = TEXT("\0");
               
                ASSERT(lstrlen(lpData) == 5);

                lstrcpyn(szY2KYear, lpData + 2, 3);
                lstrcpy((TCHAR*)lpData, szY2KYear);
            }
        }        
    }
    
    return bValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\registry.h ===
/****************************************************************************
 *
 *  REGISTRY.h
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1997
 *  All rights reserved
 *
 *  The code comes almost verbatim from Chapter 7 of Dale Rogerson's
 *  "Inside COM", and thus is minimally commented.
 *
 *  4/24/97 jmazner Created
 *
 ***************************************************************************/

#ifndef __Registry_H__
#define __Registry_H__
//
// Registry.h
//   - Helper functions registering and unregistering a component.
//

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
BOOL WINAPI RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const LPTSTR szFriendlyName,
                       const LPTSTR szVerIndProgID,
                       const LPTSTR szProgID) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
BOOL WINAPI UnregisterServer(const CLSID& clsid,
                         const LPTSTR szVerIndProgID,
                         const LPTSTR szProgID) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\pre.h ===
//**********************************************************************
// File name: pre.h
//
//      Used for precompiled headers
//
// Copyright (c) 1993-1996 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _PRE_H_)
#define _PRE_H_

#include <windows.h>
#include <windowsx.h>
#include <wchar.h>
#include <ole2.h>
#include <assert.h>
#include <string.h>
#include <ccstock.h>

#include <malloc.h>
#include <wininet.h>
#include <regstr.h>
#include <shlwapi.h>
#include <commctrl.h>
#include <exdisp.h>
#include <mshtmdid.h>

#include "icwunicd.h"
#include "resource.h"
#include "walker.h"
#include "icwutil.h"
#include "server.h"
#include "factory.h"
#include "iocs.h"
#include "ioipf.h"
#include "ioips.h"
#include "site.h"
#include "..\inc\debug.h"
#include "webview.h"
#include "icwwebvw.h"
#include "icwwalk.h"
#include "validate.h"
#include "ispdata.h"
#include "gifcon.h"
#include "appdefs.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\resource.h ===
//{{NO_DEPENDENCIES}}
// Used by icwutil.rc
//

#define IDS_HTML_DEFAULT_FONTFACE   500
#define IDS_HTML_DEFAULT_FONTSIZE   501
#define IDS_APPNAME                 503

#define IDS_ERR_INVALID_INTRO       504
#define IDS_ERR_INVALID_MSG         505

#define IDS_PAYMENT_CC_LUHNCHK      506
#define IDS_PAYMENT_CCEXPDATE       507 

#define IDS_USERINFO_FE_NAME        510
#define IDS_USERINFO_FIRSTNAME      511
#define IDS_USERINFO_LASTNAME       512
#define IDS_USERINFO_COMPANYNAME    513
#define IDS_USERINFO_ADDRESS1       514
#define IDS_USERINFO_ADDRESS2       515
#define IDS_USERINFO_CITY           516
#define IDS_USERINFO_STATE          517
#define IDS_USERINFO_ZIP            518
#define IDS_USERINFO_PHONE          519
#define IDS_PAYMENT_CCNUMBER        520
#define IDS_PAYMENT_CCNAME          521
#define IDS_PAYMENT_CCADDRESS       522
#define IDS_PAYMENT_CCZIP           523
#define IDS_PAYMENT_PBNAME          524
#define IDS_PAYMENT_PBNUMBER        525
#define IDS_USERINFO_FURIGANA       526
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\registry.cpp ===
/****************************************************************************
 *
 *  REGISTRY.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1997
 *  All rights reserved
 *
 *  This module provides functionality for self-registering/unregistering via
 *  the regsvr32.exe
 *
 *  The code comes almost verbatim from Chapter 7 of Dale Rogerson's
 *  "Inside COM", and thus is minimally commented.
 *
 *  05/14/98    donaldm     copied from INETCFG
 *
 ***************************************************************************/

#include "pre.h"
#include "registry.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//
BOOL setKeyAndValue(const LPTSTR pszPath,
                    const LPTSTR szSubkey,
                    const LPTSTR szValue,
                    const LPTSTR szName = NULL) ;
// Convert a CLSID into a tchar string.
void CLSIDtochar(const CLSID& clsid, 
                 LPTSTR szCLSID,
                 int length) ;

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const LPTSTR szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
BOOL WINAPI RegisterServer(HMODULE hModule,            // DLL module handle
                           const CLSID& clsid,         // Class ID
                           const LPTSTR szFriendlyName, // Friendly Name
                           const LPTSTR szVerIndProgID, // Programmatic
                           const LPTSTR szProgID)       //   IDs
{
    BOOL    bRet = FALSE;
    
    // Get server location.
    TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule, 
                            szModule,
                            sizeof(szModule)/sizeof(TCHAR)) ;
    if (0 != dwResult )
    {

        while (1)
        {
            // Convert the CLSID into a TCHAR.
            TCHAR szCLSID[CLSID_STRING_SIZE] ;
            CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;

            // Build the key CLSID\\{...}
            TCHAR szKey[CLSID_STRING_SIZE + 10] ;
            lstrcpy(szKey, TEXT("CLSID\\")) ;
            lstrcat(szKey, szCLSID) ;
          
            // Add the CLSID to the registry.
            bRet = setKeyAndValue(szKey, NULL, szFriendlyName) ;
            if (!bRet)
                break;

            // Add the server filename subkey under the CLSID key.
            bRet = setKeyAndValue(szKey, TEXT("InprocServer32"), szModule) ;
            if (!bRet)
                break;

            // 7/2/97 jmazner IE bug #41852
            // Add Threading Model
            bRet = setKeyAndValue(szKey,
                           TEXT("InprocServer32"),
                           TEXT("Apartment"),
                           TEXT("ThreadingModel")) ; 
            if (!bRet)
                break;

            // Add the ProgID subkey under the CLSID key.
            bRet = setKeyAndValue(szKey, TEXT("ProgID"), szProgID) ;
            if (!bRet)
                break;

            // Add the version-independent ProgID subkey under CLSID key.
            bRet = setKeyAndValue(szKey, TEXT("VersionIndependentProgID"),
                           szVerIndProgID) ;
            if (!bRet)
                break;

            // Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
            bRet = setKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ; 
            if (!bRet)
                break;
            
            bRet = setKeyAndValue(szVerIndProgID, TEXT("CLSID"), szCLSID) ;
            if (!bRet)
                break;
            
            bRet = setKeyAndValue(szVerIndProgID, TEXT("CurVer"), szProgID) ;
            if (!bRet)
                break;

            // Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
            bRet = setKeyAndValue(szProgID, NULL, szFriendlyName) ; 
            if (!bRet)
                break;
                
            bRet = setKeyAndValue(szProgID, TEXT("CLSID"), szCLSID) ;
            break;
        }                
    }
    
    return bRet ;
}

//
// Remove the component from the registry.
//
BOOL WINAPI UnregisterServer(const CLSID& clsid,         // Class ID
                      const LPTSTR szVerIndProgID, // Programmatic
                      const LPTSTR szProgID)       //   IDs
{
    // Convert the CLSID into a TCHAR.
    TCHAR szCLSID[CLSID_STRING_SIZE] ;
    CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;

    // Build the key CLSID\\{...}
    TCHAR szKey[64] ;
    lstrcpy(szKey, TEXT("CLSID\\")) ;
    lstrcat(szKey, szCLSID) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    ASSERT((lResult == ERROR_SUCCESS) ||
           (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Delete the version-independent ProgID Key.
    lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;
    ASSERT((lResult == ERROR_SUCCESS) ||
           (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Delete the ProgID key.
    lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;
    ASSERT((lResult == ERROR_SUCCESS) ||
           (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    return TRUE;
}

///////////////////////////////////////////////////////////
//
// Internal helper functions
//

// Convert a CLSID to a TCHAR string.
void CLSIDtochar(const CLSID& clsid,
                 LPTSTR szCLSID,
                 int length)
{
    ASSERT(length >= CLSID_STRING_SIZE) ;
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    ASSERT(SUCCEEDED(hr)) ;

    if (SUCCEEDED(hr))
    {
    // Covert from wide characters to non-wide.
#ifdef UNICODE
    lstrcpyn(szCLSID, wszCLSID, length / sizeof(WCHAR)) ;
#else
    wcstombs(szCLSID, wszCLSID, length) ;
#endif

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    }
    else
    {
        szCLSID[0] = TEXT('\0');
    }

}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const LPTSTR lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
                             KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME    time ;
    TCHAR       szBuffer[256] ;
    DWORD       dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
                        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const LPTSTR szKey,
                    const LPTSTR szSubkey,
                    const LPTSTR szValue,
                    const LPTSTR szName)
{
    HKEY    hKey;
    TCHAR   szKeyBuf[1024] ;

    // Copy keyname into buffer.
    lstrcpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        lstrcat(szKeyBuf, TEXT("\\")) ;
        lstrcat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
                                  szKeyBuf, 
                                  0, NULL, REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS, NULL, 
                                  &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ, 
                      (BYTE *)szValue, 
                      sizeof(TCHAR)*(lstrlen(szValue)+1)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\server.h ===
//**********************************************************************
// File name: server.h
//
//      
//
// Copyright (c) 1993-1996 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined(SERVER_H)
#define SERVER_H

// String Macros.
#define ABOUT_TITLE_STR "DLLSERVE: OLE Tutorial Code Sample"

// Dialog IDs.
#define IDD_ABOUTBOX                1000

// Error-related String Identifiers.
#define IDS_ASSERT_FAIL             2200


#ifdef __cplusplus

//**********************************************************************
//  Class:    CServer
//
//  Summary:  Class to encapsulate control of this COM server (eg, handle
//            Lock and Object counting, encapsulate otherwise global data).
//
//  Methods:  none
//**********************************************************************
class CServer
{
    public:
        CServer(void);
        ~CServer(void);

        void Lock(void);
        void Unlock(void);
        void ObjectsUp(void);
        void ObjectsDown(void);

        // A place to store the handle to loaded instance of this DLL module.
        HINSTANCE m_hDllInst;

        // Global DLL Server living Object count.
        LONG m_cObjects;

        // Global DLL Server Client Lock count.
        LONG m_cLocks;
};

#endif // __cplusplus

// Allow other internal ICWUTIL modules to get at the globals.
extern CServer* g_pServer;


#endif // SERVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\server.cpp ===
/****************************************************************************
 *
 *  SERVER.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1997
 *  All rights reserved
 *
 *
 ***************************************************************************/

#include "pre.h"


/*---------------------------------------------------------------------------
  Implementation the internal CServer C++ object.  Used to encapsulate
  some server data and the methods for Lock and Object count incrementing
  and decrementing.
---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
  Method:   CServer::CServer

  Summary:  CServer Constructor.

  Args:     void

  Modifies: .

  Returns:  void
---------------------------------------------------------------------------*/
CServer::CServer(void)
{
    // Zero the Object and Lock counts for this attached process.
    m_cObjects = 0;
    m_cLocks = 0;

    return;
}


/*---------------------------------------------------------------------------
  Method:   CServer::~CServer

  Summary:  CServer Destructor.

  Args:     void

  Modifies: .

  Returns:  void
---------------------------------------------------------------------------*/
CServer::~CServer(void)
{
    return;
}


/*---------------------------------------------------------------------------
  Method:   CServer::Lock

  Summary:  Increment the Server's Lock count.

  Args:     void

  Modifies: .

  Returns:  void
---------------------------------------------------------------------------*/
void CServer::Lock(void)
{
    InterlockedIncrement((PLONG) &m_cLocks);
    return;
}


/*---------------------------------------------------------------------------
  Method:   CServer::Unlock

  Summary:  Decrement the Server's Lock count.

  Args:     void

  Modifies: .

  Returns:  void
---------------------------------------------------------------------------*/
void CServer::Unlock(void)
{
    InterlockedDecrement((PLONG) &m_cLocks);
    return;
}


/*---------------------------------------------------------------------------
  Method:   CServer::ObjectsUp

  Summary:  Increment the Server's living Object count.

  Args:     void

  Modifies: .

  Returns:  void
---------------------------------------------------------------------------*/
void CServer::ObjectsUp(void)
{
    InterlockedIncrement((PLONG) &m_cObjects);
    return;
}


/*---------------------------------------------------------------------------
  Method:   CServer::ObjectsDown

  Summary:  Decrement the Server's living object count.

  Args:     void

  Modifies: .

  Returns:  void
---------------------------------------------------------------------------*/
void CServer::ObjectsDown(void)
{
    InterlockedDecrement((PLONG) &m_cObjects);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\site.cpp ===
//**********************************************************************
// File name: SITE.CPP
//
//      Implementation file for COleSite
//
// Functions:
//
//      See SITE.H for class definition
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"

extern BOOL CopyBitmapRectToFile
(
    HBITMAP hbm, 
    LPRECT  lpRect,
    LPTSTR  lpszFileName
);

#include "exdispid.h"

#define SETDefFormatEtc(fe, cf, med) \
{\
(fe).cfFormat=cf;\
(fe).dwAspect=DVASPECT_CONTENT;\
(fe).ptd=NULL;\
(fe).tymed=med;\
(fe).lindex=-1;\
};

#define MAX_DISP_NAME         50
#define DISPID_RunIcwTutorApp 12345

typedef struct  dispatchList_tag 
{
    WCHAR   szName[MAX_DISP_NAME];
    int     cName;
    DWORD   dwDispID;

}  DISPATCHLIST;

DISPATCHLIST ExternalInterface[] = 
{
    {L"RunIcwTutorApplication", 22, DISPID_RunIcwTutorApp }
};

const TCHAR  cszOLSNewText[] = TEXT("g_spnOlsNewText");
const TCHAR  cszOLSOldText[] = TEXT("g_spnOlsOldText");

//**********************************************************************
//
// OleFree
//
// Purpose:
//
//      free memory using the currently active IMalloc* allocator
//
// Parameters:
//
//      LPVOID pmem - pointer to memory allocated using IMalloc
//
// Return Value:
//
//      None
//
// Comments:
//
//********************************************************************
void OleFree(LPVOID pmem)
{
    LPMALLOC pmalloc;

    if (pmem == NULL)
        return;

    if (FAILED(CoGetMalloc(MEMCTX_TASK, &pmalloc)))
        return;

    pmalloc->Free(pmem);
    pmalloc->Release();
}

//**********************************************************************
//
// COleSite::COleSite
//
// Purpose:
//
//      Constructor for COleSite
//
// Parameters:
//
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
// Comments:
//
//********************************************************************
#pragma warning(disable : 4355)  // turn off this warning.  This warning
                                                                // tells us that we are passing this in
                                                                // an initializer, before "this" is through
                                                                // initializing.  This is ok, because
                                                                // we just store the ptr in the other
                                                                // constructors

COleSite::COleSite (void) :     m_OleClientSite(this) , 
                                m_OleInPlaceSite(this), 
                                m_OleInPlaceFrame(this)
#pragma warning (default : 4355)  // Turn the warning back on
{
    TCHAR   szTempPath[MAX_PATH];
    
    // Init member vars
    m_lpInPlaceObject    = NULL;
    m_lpOleObject        = NULL;
    m_hwndIPObj          = NULL;
    m_hWnd               = NULL;
    m_fInPlaceActive     = FALSE;
    
    m_dwHtmPageType      = 0;
    m_hbmBkGrnd          = NULL;
    lstrcpyn(m_szForeGrndColor, HTML_DEFAULT_COLOR, MAX_COLOR_NAME);
    lstrcpyn(m_szBkGrndColor, HTML_DEFAULT_BGCOLOR, MAX_COLOR_NAME);
    
    m_bUseBkGndBitmap    = FALSE;
    m_dwDrawAspect       = DVASPECT_CONTENT; // clear the reference count
    m_cRef               = 0;                // Init the ref count

    // Create a temp file for storing the background bitmap
    if (GetTempPath(sizeof(szTempPath)/sizeof(TCHAR), szTempPath))
    {
        GetTempFileName(szTempPath, TEXT("ICW"), 0, m_szBkGndBitmapFile);
    }
    
    // Create a storage file for creating/embedding an OLE oject into this site
    StgCreateDocfile (NULL, 
                      STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE | STGM_DELETEONRELEASE, 
                      0, 
                      &m_lpStorage);
}

//**********************************************************************
//
// COleSite::~COleSite
//
// Purpose:
//
//      Destructor for COleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      IOleObject::Release                     Object
//      IStorage::Release                       OLE API
//
// Comments:
//
//********************************************************************

COleSite::~COleSite ()
{
    TraceMsg(TF_GENERAL, "In COleSite's Destructor \r\n");

    ASSERT( m_cRef == 0 );

    if (m_lpOleObject)
       m_lpOleObject->Release();

    if (m_lpWebBrowser)   
        m_lpWebBrowser->Release();
        
    if (m_lpStorage) 
    {
        m_lpStorage->Release();
        m_lpStorage = NULL;
    }
    
    DeleteFile(m_szBkGndBitmapFile);
}


//**********************************************************************
//
// COleSite::CloseOleObject
//
// Purpose:
//
//      Call IOleObject::Close on the object of the COleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      IOleObject::QueryInterface              Object
//      IOleObject::Close                       Object
//      IOleInPlaceObject::UIDeactivate         Object
//      IOleInPlaceObject::InPlaceDeactivate    Object
//      IOleInPlaceObject::Release              Object
//
// Comments:
//
//********************************************************************

void COleSite::CloseOleObject (void)
{
    TraceMsg(TF_GENERAL, "In COleSite::CloseOleObject \r\n");

    if (m_lpOleObject)
    {
       if (m_fInPlaceActive)
       {
            LPOLEINPLACEOBJECT lpObject;
            LPVIEWOBJECT lpViewObject = NULL;
            
            m_lpOleObject->QueryInterface(IID_IOleInPlaceObject, (LPVOID FAR *)&lpObject);
            lpObject->UIDeactivate();
            // don't need to worry about inside-out because the object
            // is going away.
            lpObject->InPlaceDeactivate();
            lpObject->Release();
       }
    
       m_lpOleObject->Close(OLECLOSE_NOSAVE);
       m_hWnd = NULL;
    }
}


//**********************************************************************
//
// COleSite::UnloadOleObject
//
// Purpose:
//
//      Close and release all pointers to the object of the COleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      COleSite::CloseOleObject             SITE.CPP
//      IOleObject::QueryInterface              Object
//      IViewObject::SetAdvise                  Object
//      IViewObject::Release                    Object
//      IStorage::Release                       OLE API
//
// Comments:
//
//********************************************************************

void COleSite::UnloadOleObject (void)
{
    TraceMsg(TF_GENERAL, "In COleSite::UnloadOleObject \r\n");

    if (m_lpOleObject)
    {
        LPVIEWOBJECT lpViewObject;
        CloseOleObject();    // ensure object is closed; NOP if already closed

        m_lpOleObject->QueryInterface(IID_IViewObject, (LPVOID FAR *)&lpViewObject);

        if (lpViewObject)
        {
            // Remove the view advise
            lpViewObject->SetAdvise(m_dwDrawAspect, 0, NULL);
            lpViewObject->Release();
        }

        m_lpOleObject->Release();
        m_lpOleObject = NULL;
    }
}

//**********************************************************************
//
// COleSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation of the container Site.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      IsEqualIID                  OLE API
//      ResultFromScode             OLE API
//      COleSite::AddRef          OBJ.CPP
//      COleClientSite::AddRef      IOCS.CPP
//      CAdviseSink::AddRef         IAS.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TraceMsg(TF_GENERAL, "In COleSite::QueryInterface\r\n");

    *ppvObj = NULL;     // must set out pointer parameters to NULL

    if ( riid == IID_IDocHostUIHandler)
    {
        AddRef();
        *ppvObj = this;
        return ResultFromScode(S_OK);
    }
    
    if ( riid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = this;
        return ResultFromScode(S_OK);
    }

    if ( riid == IID_IOleClientSite)
    {
        m_OleClientSite.AddRef();
        *ppvObj = &m_OleClientSite;
        return ResultFromScode(S_OK);
    }
            
    if ( riid == IID_IOleInPlaceSite)
    {
        m_OleInPlaceSite.AddRef();
        *ppvObj = &m_OleInPlaceSite;
        return ResultFromScode(S_OK);
    }
       
    if( (riid == DIID_DWebBrowserEvents) ||
        (riid == IID_IDispatch))
    {
        AddRef();
        *ppvObj = (LPVOID)(IUnknown*)(DWebBrowserEvents*)this;
        return ResultFromScode(S_OK);
    }     

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// COleSite::AddRef
//
// Purpose:
//
//      Increments the reference count of the container Site.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the site.
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleSite::AddRef()
{
    TraceMsg(TF_GENERAL, "In COleSite::AddRef\r\n");
    return ++m_cRef;
}

//**********************************************************************
//
// COleSite::Release
//
// Purpose:
//
//      Decrements the reference count of the container Site
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the Site.
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleSite::Release()
{
    TraceMsg(TF_GENERAL, "In COleSite::Release\r\n");

    return --m_cRef;
}


//**********************************************************************
//
// COleSite::CreateBrowserObject
//
// Purpose:
//
//      Used to Create a new WebBrowser object (can't be done in the
//      constructor).
//
// Parameters:
//
// Return Value:
//
//      None
//
// Function Calls:
//
// Comments:
//
//********************************************************************

void COleSite::CreateBrowserObject()
{
        
    HRESULT         hr;
            
    SETDefFormatEtc(m_fe, 0, TYMED_NULL);
            
    hr = OleCreate(CLSID_WebBrowser,
                   IID_IWebBrowser2,
                   OLERENDER_DRAW,
                   &m_fe,
                   &m_OleClientSite,
                   m_lpStorage,
                   (LPVOID FAR *)&m_lpWebBrowser);
                
    if (SUCCEEDED(hr))                       
        InitBrowserObject();
        
    IUnknown    *pOleSite;
    // Get an IUnknow pointer to the site, so I can attach an event sink
    QueryInterface(IID_IUnknown, (LPVOID *)&pOleSite);

    // Setup to get WebBrowserEvents
    ConnectToConnectionPoint(pOleSite, 
                             DIID_DWebBrowserEvents,
                             TRUE,
                             (IUnknown *)m_lpWebBrowser, 
                             &m_dwcpCookie, 
                             NULL);     
    // We can release this instance now, since we have attached the event sink
    pOleSite->Release();
        
}


void COleSite::DestroyBrowserObject()
{

    UnloadOleObject();
    
    if (m_lpWebBrowser)
    {
        m_lpWebBrowser->Release();
        m_lpWebBrowser = NULL;
    }        
}

//**********************************************************************
//
// COleSite::InitBrowserObject
//
// Purpose:
//
//      Used to initialize a newly create object (can't be done in the
//      constructor).
//
// Parameters:
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      IOleObject::SetHostNames        Object
//      IOleObject::QueryInterface      Object
//      IViewObject2::GetExtent         Object
//      IOleObject::DoVerb              Object
//      IViewObject::SetAdvise          Object
//      IViewObject::Release            Object
//      GetClientRect                   Windows API
//      OleSetContainedObject           OLE API
//
// Comments:
//
//********************************************************************

void COleSite::InitBrowserObject()
{
    // If we don't have a WebBrowser object to initialize, then bail
    if (!m_lpWebBrowser)
        return;
            
    // Get An OleObject from the WebBrowser Interface
    m_lpWebBrowser->QueryInterface(IID_IOleObject, (LPVOID FAR *)&m_lpOleObject);

    // inform object handler/DLL object that it is used in the embedding container's context
    OleSetContainedObject(m_lpOleObject, TRUE);
    
    // setup the client setup
    m_lpOleObject->SetClientSite(&m_OleClientSite);
}

void COleSite::ConnectBrowserObjectToWindow
(
    HWND hWnd, 
    DWORD dwHtmPageType, 
    BOOL bUseBkGndBitmap,
    HBITMAP hbmBkGrnd,
    LPRECT lprcBkGrnd,
    LPTSTR lpszclrBkGrnd,
    LPTSTR lpszclrForeGrnd
)
{
    if (m_hWnd)
    {
        // Close the OLE Object, which will deactivate it, so we can then reactivate it
        // with the new window
        CloseOleObject(); 
    }
    
    // Remeber this window handle for later
    m_hWnd              = hWnd; 
    m_dwHtmPageType     = dwHtmPageType;
    m_bUseBkGndBitmap   = bUseBkGndBitmap;
    m_hbmBkGrnd         = hbmBkGrnd;
    if (NULL != lpszclrForeGrnd)
        lstrcpyn(m_szForeGrndColor, lpszclrForeGrnd, MAX_COLOR_NAME);
    if (NULL != lpszclrBkGrnd)
        lstrcpyn(m_szBkGrndColor, lpszclrBkGrnd, MAX_COLOR_NAME);
    
    CopyRect(&m_rcBkGrnd, lprcBkGrnd);
    InPlaceActivate();
}

void COleSite::ShowHTML()
{
    RECT    rect;
    
    // we only want to DoVerb(SHOW) if this is an InsertNew object.
    // we should NOT DoVerb(SHOW) if the object is created FromFile.
    m_lpOleObject->DoVerb( OLEIVERB_SHOW,
                           NULL,
                           &m_OleClientSite,
                           -1,
                           m_hWnd,
                           &rect);
}

void COleSite::InPlaceActivate()
{
    RECT    rect;
    m_lpOleObject->DoVerb( OLEIVERB_INPLACEACTIVATE,
                           NULL,
                           &m_OleClientSite,
                           -1,
                           m_hWnd,
                           &rect);
}

void COleSite::UIActivate()
{
    RECT    rect;
    m_lpOleObject->DoVerb( OLEIVERB_UIACTIVATE,
                           NULL,
                           &m_OleClientSite,
                           -1,
                           m_hWnd,
                           &rect);
}

HRESULT COleSite::TweakHTML( TCHAR*     pszFontFace,
                             TCHAR*     pszFontSize,
                             TCHAR*     pszBgColor,
                             TCHAR*     pszForeColor)
{
    ASSERT(m_lpWebBrowser);
    
    IWebBrowser2*  pwb   = m_lpWebBrowser;
    HRESULT        hr    = E_FAIL;
    IDispatch*     pDisp = NULL;

    hr = pwb->get_Document(&pDisp);

    // Call might succeed but that dosen't guarantee a valid ptr
    if (SUCCEEDED(hr) && pDisp)
    {
        IHTMLDocument2* pDoc = NULL;

        hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc);
        if (SUCCEEDED(hr) && pDoc)
        {
            VARIANT var;
            VariantInit(&var);
            V_VT(&var) = VT_BSTR;
            if (m_bUseBkGndBitmap)
            {
                // Use A background bitmap
                SetHTMLBackground(pDoc, m_hbmBkGrnd, &m_rcBkGrnd);
            }
            else
            {
                //Setup the background solid color
                var.bstrVal = A2W(pszBgColor);
                pDoc->put_bgColor(var);
            }
           
            //Setup the Foreground (text) color
            var.bstrVal = A2W(pszForeColor);
            pDoc->put_fgColor(var);
           
            //now we'll try for the font-face/size
            if((NULL != pszFontFace))
            {
                IHTMLElement* pBody;
                //Get the <BODY> from the document
                hr = pDoc->get_body(&pBody);
                if((SUCCEEDED(hr)) && pBody)
                {
                    IHTMLStyle* pStyle = NULL;
                    //Cool, now the inline style sheet
                    hr = pBody->get_style(&pStyle);
                   
                    if (SUCCEEDED(hr) && pStyle)
                    {
                        //Great, now the font-family
                        hr = pStyle->put_fontFamily(A2W(pszFontFace));
                   
                        if(SUCCEEDED(hr))
                        {
                            //Setup for the font-size
                            var.bstrVal = A2W(pszFontSize);
                            //And finally the font-size
                            hr = pStyle->put_fontSize(var);  
                        }
                        pStyle->Release();
                    }
                    pBody->Release();
                }
            }
            pDoc->Release();
        }
        pDisp->Release();
    }
    else
        hr = E_FAIL;

    return hr;
}

HRESULT COleSite::SetHTMLBackground
( 
    IHTMLDocument2  *pDoc,
    HBITMAP hbm,
    LPRECT  lpRC
)    
{
    HRESULT         hr    = E_FAIL;
    IDispatch*      pDisp = NULL;
    TCHAR           szBmpURL[MAX_PATH+10];
    
    // Get the portion of the Bitmap we are interested into a file
    if (CopyBitmapRectToFile(hbm, lpRC, m_szBkGndBitmapFile))
    {
        wsprintf (szBmpURL, TEXT("file://%s"), m_szBkGndBitmapFile);    
        
        IHTMLElement* pBody;
        //Get the <BODY> from the document
        hr = pDoc->get_body(&pBody);
        if((SUCCEEDED(hr)) && pBody)
        {
             IHTMLBodyElement* pBodyElt = NULL;
                    
             pBody->QueryInterface(IID_IHTMLBodyElement, (void**)&pBodyElt);
                    
             // Set the Background bitmap
             hr = pBodyElt->put_background(A2W(szBmpURL));
             pBodyElt->Release();
        }
    }        
    return (hr);
}

//**********************************************************************
//
// COleSite::GetObjRect
//
// Purpose:
//
//      Retrieves the rect of the object in pixels
//
// Parameters:
//
//      LPRECT lpRect - Rect structure filled with object's rect in pixels
//
//********************************************************************
void COleSite::GetObjRect(LPRECT lpRect)
{
    GetClientRect(m_hWnd, lpRect);
}

// * CConWizSite::GetHostInfo
// *
// * Purpose: Called at initialisation of every instance of Trident.
// *
HRESULT COleSite::GetHostInfo( DOCHOSTUIINFO* pInfo )
{
    BSTR wbLoc = NULL;
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;

    // Adjust the HTML properties to our liking based on the offer type
    // pagetype defs in appdefs.h   
    switch(m_dwHtmPageType)
    {
        //YES 3D
        case PAGETYPE_BILLING: 
        case PAGETYPE_ISP_TOS:
        case PAGETYPE_MARKETING:
        case PAGETYPE_CUSTOMPAY:
        {
            pInfo->dwFlags = DOCHOSTUIFLAG_DIALOG | DOCHOSTUIFLAG_DISABLE_HELP_MENU;       
            break;
        }
        //NO 3D
        case PAGETYPE_BRANDED:
        case PAGETYPE_ISP_NORMAL:
        case PAGETYPE_NOOFFERS:
        case PAGETYPE_ISP_FINISH:
        case PAGETYPE_ISP_CUSTOMFINISH:
        case PAGETYPE_OLS_FINISH:
        default:
        {
           
            pInfo->dwFlags = DOCHOSTUIFLAG_NO3DBORDER | DOCHOSTUIFLAG_DIALOG | DOCHOSTUIFLAG_SCROLL_NO |
                             DOCHOSTUIFLAG_DISABLE_HELP_MENU;
        
            break;
        }
    }    
    return S_OK;
}

// * CConWizSite::ShowUI
// *
// * Purpose: Called when MSHTML.DLL shows its UI
// *
HRESULT COleSite::ShowUI
(
    DWORD dwID, 
    IOleInPlaceActiveObject * /*pActiveObject*/,
    IOleCommandTarget * pCommandTarget,
    IOleInPlaceFrame * /*pFrame*/,
    IOleInPlaceUIWindow * /*pDoc*/
)
{
    // We've already got our own UI in place so just return S_OK
    return S_OK;
}

// * CConWizSite::HideUI
// *
// * Purpose: Called when MSHTML.DLL hides its UI
// *
HRESULT COleSite::HideUI(void)
{
    return S_OK;
}

// * CConWizSite::UpdateUI
// *
// * Purpose: Called when MSHTML.DLL updates its UI
// *
HRESULT COleSite::UpdateUI(void)
{
    return S_OK;
}

// * CConWizSite::EnableModeless
// *
// * Purpose: Called from MSHTML.DLL's IOleInPlaceActiveObject::EnableModeless
// *
HRESULT COleSite::EnableModeless(BOOL /*fEnable*/)
{
    return E_NOTIMPL;
}

// * CConWizSite::OnDocWindowActivate
// *
// * Purpose: Called from MSHTML.DLL's IOleInPlaceActiveObject::OnDocWindowActivate
// *
HRESULT COleSite::OnDocWindowActivate(BOOL /*fActivate*/)
{
    return E_NOTIMPL;
}

// * CConWizSite::OnFrameWindowActivate
// *
// * Purpose: Called from MSHTML.DLL's IOleInPlaceActiveObject::OnFrameWindowActivate
// *
HRESULT COleSite::OnFrameWindowActivate(BOOL /*fActivate*/)
{
    return E_NOTIMPL;
}

// * CConWizSite::ResizeBorder
// *
// * Purpose: Called from MSHTML.DLL's IOleInPlaceActiveObject::ResizeBorder
// *
HRESULT COleSite::ResizeBorder(
                LPCRECT /*prcBorder*/, 
                IOleInPlaceUIWindow* /*pUIWindow*/,
                BOOL /*fRameWindow*/)
{
    return E_NOTIMPL;
}

// * CConWizSite::ShowContextMenu
// *
// * Purpose: Called when MSHTML.DLL would normally display its context menu
// *
HRESULT COleSite::ShowContextMenu(
                DWORD /*dwID*/, 
                POINT* /*pptPosition*/,
                IUnknown* /*pCommandTarget*/,
                IDispatch* /*pDispatchObjectHit*/)
{
    return S_OK; // We've shown our own context menu. MSHTML.DLL will no longer try to show its own.
}

// * CConWizSite::TranslateAccelerator
// *
// * Purpose: Called from MSHTML.DLL's TranslateAccelerator routines
// *
HRESULT COleSite::TranslateAccelerator(LPMSG lpMsg,
            /* [in] */ const GUID __RPC_FAR *pguidCmdGroup,
            /* [in] */ DWORD nCmdID)
{
    return ResultFromScode(S_FALSE);
}

// * CConWizSite::GetOptionKeyPath
// *
// * Purpose: Called by MSHTML.DLL to find where the host wishes to store 
// *    its options in the registry
// *
HRESULT COleSite::GetOptionKeyPath(BSTR* pbstrKey, DWORD)
{
    return E_NOTIMPL;
}

STDMETHODIMP COleSite::GetDropTarget( 
            /* [in] */ IDropTarget __RPC_FAR *pDropTarget,
            /* [out] */ IDropTarget __RPC_FAR *__RPC_FAR *ppDropTarget)
{
    return E_NOTIMPL;
}

STDMETHODIMP COleSite::GetExternal( 
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch)
{
    // return the IDispatch we have for extending the object Model
    ASSERT(this);
    *ppDispatch = (IDispatch*)this; 
    return S_OK;
}

STDMETHODIMP COleSite::GetIDsOfNames(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ OLECHAR** rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID* rgDispId)
{
    HRESULT hr = ResultFromScode(DISP_E_UNKNOWNNAME);
    
    rgDispId[0] = DISPID_UNKNOWN;

    for (int iX = 0; iX < sizeof(ExternalInterface)/sizeof(DISPATCHLIST); iX++)
    {
         if ( 2 == CompareString( lcid, 
                                 NORM_IGNORECASE | NORM_IGNOREWIDTH, 
                                 (LPCTSTR)ExternalInterface[iX].szName, 
                                 ExternalInterface[iX].cName,
                                 (LPCTSTR)rgszNames[0], 
                                 wcslen(rgszNames[0])))
        {
            rgDispId[0] = ExternalInterface[iX].dwDispID;
            hr = NOERROR;
            break;
        }
    }
    
    // Set the disid's for the parameters
    if (cNames > 1)
    {
        // Set a DISPID for function parameters
        for (UINT i = 1; i < cNames ; i++)
            rgDispId[i] = DISPID_UNKNOWN;
    }      
          
    return hr;
}

    
STDMETHODIMP COleSite::TranslateUrl( 
            /* [in] */ DWORD dwTranslate,
            /* [in] */ OLECHAR __RPC_FAR *pchURLIn,
            /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *ppchURLOut)
{
    return E_NOTIMPL;
}
        
STDMETHODIMP COleSite::FilterDataObject( 
            /* [in] */ IDataObject __RPC_FAR *pDO,
            /* [out] */ IDataObject __RPC_FAR *__RPC_FAR *ppDORet)
{
    return E_NOTIMPL;
}

HRESULT COleSite::ActivateOLSText(void )
{   
    LPDISPATCH      pDisp = NULL; 
    // Get the document pointer from this webbrowser.
    if (SUCCEEDED(m_lpWebBrowser->get_Document(&pDisp)) && pDisp)  
    {
        IHTMLDocument2* pDoc = NULL;
        if (SUCCEEDED(pDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc)) && pDoc)
        {
            IHTMLElementCollection* pColl = NULL;

            // retrieve a reference to the ALL collection
            if (SUCCEEDED(pDoc->get_all( &pColl )))
            {
                // Get the two spans we are interested in from the all collection
                VARIANT varName;
                VariantInit(&varName);
                V_VT(&varName) = VT_BSTR;
                varName.bstrVal = A2W(cszOLSNewText);

                VARIANT varIdx;
                varIdx.vt = VT_UINT;
                varIdx.lVal = 0;

                LPDISPATCH pDispElt = NULL; 
                
                // Get the IDispatch for NewText SPAN, and set it to visible
                if (SUCCEEDED(pColl->item(varName, varIdx, &pDispElt)) && pDispElt)
                {
                    IHTMLElement* pElt = NULL;
                    if (SUCCEEDED(pDispElt->QueryInterface( IID_IHTMLElement, (LPVOID*)&pElt )) && pElt)
                    {                            
                        IHTMLStyle  *pStyle = NULL;
                                        
                        // Get the style interface for this element, so we can tweak it
                        if (SUCCEEDED(pElt->get_style(&pStyle)))
                        {
                            pStyle->put_visibility(A2W(TEXT("visible")));
                            pStyle->Release();
                        }                                        
                        pElt->Release();
                    }                    
                    pDispElt->Release();
                }
                
                pDispElt = NULL;
                varName.bstrVal = A2W(cszOLSOldText);
                // Get the IDispatch for OldText SPAN, and set it to hidden
                if (SUCCEEDED(pColl->item(varName, varIdx, &pDispElt)) && pDispElt)
                {
                    IHTMLElement* pElt = NULL;
                    if (SUCCEEDED(pDispElt->QueryInterface( IID_IHTMLElement, (LPVOID*)&pElt )) && pElt)
                    {                            
                        IHTMLStyle  *pStyle = NULL;
                                        
                        // Get the style interface for this element, so we can tweak it
                        if (SUCCEEDED(pElt->get_style(&pStyle)))
                        {
                            pStyle->put_visibility(A2W(TEXT("hidden")));
                            pStyle->Release();
                        }                                        
                        pElt->Release();
                    }                    
                    pDispElt->Release();
                }
                pColl->Release();
            } // get_all
            pDoc->Release();
        }
        pDisp->Release();
    }        
    return S_OK;
}    


//returns true if focus was sucessfully set
BOOL COleSite::TrySettingFocusOnHtmlElement(IUnknown* pUnk)
{   
    IHTMLControlElement* pControl = NULL;
    
    BOOL bFocusWasSet = FALSE;

    if(SUCCEEDED(pUnk->QueryInterface(IID_IHTMLControlElement, (LPVOID*)&pControl)) && pControl)
    {
        if(SUCCEEDED(pControl->focus()))
            bFocusWasSet = TRUE;
        pControl->Release();
    }
    return bFocusWasSet;
}                        

BOOL COleSite::SetFocusToFirstHtmlInputElement()
{
    VARIANT                   vIndex;
    IDispatch*                pDisp         = NULL;
    IDispatch*                pDispElement  = NULL;
    IHTMLDocument2*           pDoc          = NULL;
    IHTMLElementCollection*   pColl         = NULL;    
    IHTMLButtonElement*       pButton       = NULL;
    IHTMLInputButtonElement*  pInputButton  = NULL;
    IHTMLInputFileElement*    pInputFile    = NULL;
    IHTMLInputTextElement*    pInputText    = NULL;
    IHTMLSelectElement*       pSelect       = NULL;
    IHTMLTextAreaElement*     pTextArea     = NULL;
    IHTMLOptionButtonElement* pOptionButton = NULL;
    VARIANT                   varNull       = { 0 };
    long                      lLen          = 0;
    BOOL                      bFocusWasSet  = FALSE;

    vIndex.vt = VT_UINT;
    
    if (SUCCEEDED(m_lpWebBrowser->get_Document(&pDisp)) && pDisp)
    {
        if (SUCCEEDED(pDisp->QueryInterface(IID_IHTMLDocument2,(LPVOID*)&pDoc)) && pDoc)
        {   
            if (SUCCEEDED(pDoc->get_all(&pColl)) && pColl)
            {
                pColl->get_length(&lLen);
    
                for (int i = 0; i < lLen; i++)
                {      
                    vIndex.lVal = i;
                    pDispElement = NULL;     

                    if(SUCCEEDED(pColl->item(vIndex, varNull, &pDispElement)) && pDispElement)
                    {
                        pButton      = NULL;
                        pInputButton = NULL;
                        pInputFile   = NULL;
                        pInputText   = NULL;
                        pSelect      = NULL;
                        
                        if(SUCCEEDED(pDispElement->QueryInterface(IID_IHTMLButtonElement, (LPVOID*)&pButton)) && pButton)
                        {
                            bFocusWasSet = TrySettingFocusOnHtmlElement((IUnknown*)pButton);
                            pButton->Release();
                        }
                        else if (SUCCEEDED(pDispElement->QueryInterface(IID_IHTMLInputButtonElement, (LPVOID*)&pInputButton)) && pInputButton)
                        {
                            bFocusWasSet = TrySettingFocusOnHtmlElement((IUnknown*)pInputButton);
                            pInputButton->Release();
                        }
                        else if (SUCCEEDED(pDispElement->QueryInterface(IID_IHTMLInputFileElement, (LPVOID*)&pInputFile)) && pInputFile)
                        {
                            bFocusWasSet = TrySettingFocusOnHtmlElement((IUnknown*)pInputFile);
                            pInputFile->Release();
                        }
                        else if (SUCCEEDED(pDispElement->QueryInterface(IID_IHTMLInputTextElement, (LPVOID*)&pInputText)) && pInputText)
                        {
                            bFocusWasSet = TrySettingFocusOnHtmlElement((IUnknown*)pInputText);
                            pInputText->Release();
                        }
                        else if (SUCCEEDED(pDispElement->QueryInterface(IID_IHTMLSelectElement, (LPVOID*)&pSelect)) && pSelect)
                        {
                            bFocusWasSet = TrySettingFocusOnHtmlElement((IUnknown*)pSelect);
                            pSelect->Release();
                        }
                        else if (SUCCEEDED(pDispElement->QueryInterface(IID_IHTMLTextAreaElement, (LPVOID*)&pTextArea)) && pTextArea)
                        {
                            bFocusWasSet = TrySettingFocusOnHtmlElement((IUnknown*)pTextArea);
                            pTextArea->Release();
                        }
                        else if (SUCCEEDED(pDispElement->QueryInterface(IID_IHTMLOptionButtonElement, (LPVOID*)&pOptionButton)) && pOptionButton)
                        {
                            bFocusWasSet = TrySettingFocusOnHtmlElement((IUnknown*)pOptionButton);
                            pOptionButton->Release();
                        }
                        pDispElement->Release();
                    }
                    if(bFocusWasSet)
                        break;
                }
                pColl->Release();
            }
            pDoc->Release();
        }
        pDisp->Release();
    }
    return bFocusWasSet;
}

BOOL COleSite::SetFocusToHtmlPage()
{
    IDispatch*                pDisp         = NULL;
    IHTMLDocument2*           pDoc          = NULL;
    IHTMLElement*             pElement      = NULL;
    BOOL                      bFocusWasSet  = FALSE;

    DOCHOSTUIINFO pInfo;
    pInfo.cbSize = sizeof(DOCHOSTUIINFO);

    if(SUCCEEDED(GetHostInfo(&pInfo)))
    {
        if(!(pInfo.dwFlags & DOCHOSTUIFLAG_SCROLL_NO))
        {    
            if (SUCCEEDED(m_lpWebBrowser->get_Document(&pDisp)) && pDisp)
            {
                if (SUCCEEDED(pDisp->QueryInterface(IID_IHTMLDocument2,(LPVOID*)&pDoc)) && pDoc)
                {   
                    if (SUCCEEDED(pDoc->get_body(&pElement)) && pElement)
                    {
                        bFocusWasSet = TrySettingFocusOnHtmlElement((IUnknown*)pElement);
                        pElement->Release();
                    }
                    pDoc->Release();
                }
                pDisp->Release();
            }
        }
    }

    return bFocusWasSet;
}

HRESULT COleSite::Invoke
( 
    DISPID dispidMember, 
    REFIID riid, 
    LCID lcid, 
    WORD wFlags, 
    DISPPARAMS FAR* pdispparams, 
    VARIANT FAR* pvarResult,  
    EXCEPINFO FAR* pexcepinfo, 
    UINT FAR* puArgErr
)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    
    // Either one of these is good, since we just want to make sure the DOCUMENT pointer is
    // available.
    
    switch(dispidMember)
    {
    
        case DISPID_DOCUMENTCOMPLETE:
        case DISPID_NAVIGATECOMPLETE:
        {
            TCHAR szFontFace [MAX_RES_LEN] = TEXT("\0");
            TCHAR szFontSize [MAX_RES_LEN] = TEXT("\0");

            LoadString(ghInstance, IDS_HTML_DEFAULT_FONTFACE, szFontFace, MAX_RES_LEN);                
            LoadString(ghInstance, IDS_HTML_DEFAULT_FONTSIZE, szFontSize, MAX_RES_LEN);    
            ASSERT(strlen(szFontFace) != 0);
            ASSERT(strlen(szFontSize) != 0);

            // Adjust the HTML properties to our liking based on the offer type
            // html default defs in icwutil.h and icwutil.rc
            // pagetype defs in appdefs.h
            switch(m_dwHtmPageType)
            {
                case PAGETYPE_BILLING:  
                case PAGETYPE_CUSTOMPAY:
                case PAGETYPE_ISP_TOS:
                case PAGETYPE_ISP_NORMAL:
                {
                    TweakHTML(szFontFace,  
                              szFontSize, 
                              m_szBkGrndColor, 
                              m_szForeGrndColor);
                    if(!SetFocusToFirstHtmlInputElement())
                        SetFocusToHtmlPage(); 
                    break;                              
                }
            
                // For the OLS finish page, we need to tweak it's display by
                // invoking the SetNewText script function
                case PAGETYPE_OLS_FINISH:
                {
                    TweakHTML(szFontFace, 
                              szFontSize, 
                              HTML_DEFAULT_BGCOLOR, 
                              HTML_DEFAULT_COLOR);
                              
                    ActivateOLSText();
                    break;
                }
            
                case PAGETYPE_ISP_FINISH:
                case PAGETYPE_ISP_CUSTOMFINISH:
                case PAGETYPE_NOOFFERS:
                {
                    TweakHTML(szFontFace, 
                              szFontSize, 
                              HTML_DEFAULT_SPECIALBGCOLOR, 
                              HTML_DEFAULT_COLOR);
                              
                    break;
                }
                case PAGETYPE_MARKETING:
                case PAGETYPE_BRANDED:
                default:
                {
                    //Do just the background bitmap if necessary
                    if (m_bUseBkGndBitmap)
                    {
                        TweakHTML(NULL, 
                                  NULL, 
                                  HTML_DEFAULT_BGCOLOR, 
                                  HTML_DEFAULT_COLOR);
                    }                                  
                    break;
                }
            }
        
            DisableHyperlinksInDocument();
          
            // Show the Page
            ShowHTML();
            break;
        }
        case DISPID_RunIcwTutorApp: 
        {
            PostMessage(GetParent(m_hWnd), WM_RUNICWTUTORAPP, 0, 0); 
            break;
        }
        default:
        {
           hr = DISP_E_MEMBERNOTFOUND;
           break;
        }
    }
    return hr;
}

void  COleSite::DisableHyperlinksInDocument()
{
    VARIANT                 vIndex;
    IHTMLAnchorElement*     pAnchor;
    IHTMLElement*           pElement;
    IDispatch*              pDisp         = NULL;
    IDispatch*              pDispElement  = NULL;
    IDispatch*              pDispElement2 = NULL;
    IHTMLDocument2*         pDoc          = NULL;
    IHTMLElementCollection* pColl         = NULL;
    BSTR                    bstrInnerHtml = NULL;
    BSTR                    bstrOuterHtml = NULL;
    VARIANT                 varNull       = { 0 };
    long                    lLen          = 0;

    vIndex.vt     = VT_UINT;
    bstrOuterHtml = SysAllocString(A2W(TEXT("&nbsp<SPAN></SPAN>&nbsp")));

    if (SUCCEEDED(m_lpWebBrowser->get_Document(&pDisp)) && pDisp)
    {
        if (SUCCEEDED(pDisp->QueryInterface(IID_IHTMLDocument2,(LPVOID*)&pDoc)) && pDoc)
        {
            if (SUCCEEDED(pDoc->get_all(&pColl)) && pColl)
            {
                pColl->get_length(&lLen);
    
                for (int i = 0; i < lLen; i++)
                {      
                    vIndex.lVal = i;
                    pDispElement = NULL;     

                    if(SUCCEEDED(pColl->item(vIndex, varNull, &pDispElement)) && pDispElement)
                    {
                        pAnchor = NULL;
            
                        if(SUCCEEDED(pDispElement->QueryInterface(IID_IHTMLAnchorElement, (LPVOID*)&pAnchor)) && pAnchor)
                        {       
                            pAnchor->Release();  
                            pElement = NULL;

                            if(SUCCEEDED(pDispElement->QueryInterface(IID_IHTMLElement, (LPVOID*)&pElement)) && pElement)
                            {
                                pElement->get_innerHTML(&bstrInnerHtml);
                                pElement->put_outerHTML(bstrOuterHtml);
                                pElement->Release();

                                if(bstrInnerHtml)
                                {
                                    pDispElement2 = NULL;;
                                    
                                    if(SUCCEEDED(pColl->item(vIndex, varNull, &pDispElement2)) && pDispElement2)
                                    {
                                        pElement = NULL;

                                        if(SUCCEEDED(pDispElement2->QueryInterface(IID_IHTMLElement, (LPVOID*)&pElement)) && pElement)
                                        {
                                            pElement->put_innerHTML(bstrInnerHtml);
                                            SysFreeString(bstrInnerHtml);
                                            bstrInnerHtml = NULL;
                                            pElement->Release();
                                        }
                                        pDispElement2->Release();
                                    }
                                }                          
                            }
                        } 
                        pDispElement->Release();
                    }
                }
                pColl->Release();
            }
            pDoc->Release();
        }
        pDisp->Release();
    }
    
    if(bstrInnerHtml)
        SysFreeString(bstrInnerHtml);
    
    SysFreeString(bstrOuterHtml);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\site.h ===
//**********************************************************************
// File name: SITE.H
//
//      Definition of COleSite
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _SITE_H_ )
#define _SITE_H_

#include <mshtmhst.h>

class COleSite : public IDocHostUIHandler, public DWebBrowserEvents
{
    private:        
        ULONG               m_cRef;     //Reference count        

    public:
        LPSTORAGE           m_lpStorage;
        LPOLEOBJECT         m_lpOleObject;
        LPOLEINPLACEOBJECT  m_lpInPlaceObject;
        HWND                m_hwndIPObj;
        
        IWebBrowser2        *m_lpWebBrowser;
        DWORD               m_dwDrawAspect;
        FORMATETC           m_fe;
        BOOL                m_fInPlaceActive;
        COleClientSite      m_OleClientSite;
        COleInPlaceSite     m_OleInPlaceSite;
        COleInPlaceFrame    m_OleInPlaceFrame;
        
        HWND                m_hWnd;
        DWORD               m_dwHtmPageType;
        BOOL                m_bUseBkGndBitmap;
        HBITMAP             m_hbmBkGrnd;
        RECT                m_rcBkGrnd;
        TCHAR               m_szForeGrndColor[MAX_COLOR_NAME];
        TCHAR               m_szBkGrndColor[MAX_COLOR_NAME];
        DWORD               m_dwcpCookie;
        TCHAR               m_szBkGndBitmapFile[MAX_PATH];
                                
        // IUnknown Interfaces
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        // IDocHostUIHandler
        HRESULT STDMETHODCALLTYPE ShowContextMenu( 
            DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
        HRESULT STDMETHODCALLTYPE GetHostInfo(DOCHOSTUIINFO *pInfo);
        HRESULT STDMETHODCALLTYPE ShowUI( 
            DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
            IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame,
            IOleInPlaceUIWindow *pDoc);
        HRESULT STDMETHODCALLTYPE HideUI(void);
        HRESULT STDMETHODCALLTYPE UpdateUI(void);
        HRESULT STDMETHODCALLTYPE EnableModeless(BOOL fEnable);
        HRESULT STDMETHODCALLTYPE OnDocWindowActivate(BOOL fActivate);
        HRESULT STDMETHODCALLTYPE OnFrameWindowActivate(BOOL fActivate);
        HRESULT STDMETHODCALLTYPE ResizeBorder( 
            LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
        HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
        HRESULT STDMETHODCALLTYPE GetOptionKeyPath(BSTR *pbstrKey, DWORD dw);
        HRESULT STDMETHODCALLTYPE GetDropTarget( 
            IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
        HRESULT STDMETHODCALLTYPE GetExternal(IDispatch **ppDisp);
        HRESULT STDMETHODCALLTYPE TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
        HRESULT STDMETHODCALLTYPE FilterDataObject(IDataObject *pDO, IDataObject **ppDORet);

        // DWebBrowserEvents        
        STDMETHOD(GetTypeInfoCount)(UINT FAR* pcInfo) { return E_NOTIMPL; }
        STDMETHOD(GetTypeInfo)( UINT, LCID, ITypeInfo** ) { return E_NOTIMPL; }
        STDMETHOD(GetIDsOfNames)( REFIID, OLECHAR**, UINT, LCID, DISPID* );
        STDMETHOD(Invoke)( DISPID dispidMember, 
                           REFIID riid, 
                           LCID lcid, 
                           WORD wFlags, 
                           DISPPARAMS FAR* pdispparams, 
                           VARIANT FAR* pvarResult, 
                           EXCEPINFO FAR* pexcepinfo, 
                           UINT FAR* puArgErr);
        
        HRESULT TweakHTML ( TCHAR* pszFontFace,
                            TCHAR* pszFontSize,
                            TCHAR* pszBgColor,
                            TCHAR* pszForeColor);

        HRESULT ActivateOLSText(void );
        HRESULT SetHTMLBackground(IHTMLDocument2  *pDoc, HBITMAP hbm, LPRECT  lpRC);
        void CreateBrowserObject(void);
        void DestroyBrowserObject(void);
        
        void InitBrowserObject(void);
        void ConnectBrowserObjectToWindow(HWND hWnd, 
                                          DWORD dwHtmPageType, 
                                          BOOL bUseBkGndBitmap,
                                          HBITMAP hbmBkGrnd,
                                          LPRECT lprcBkGrnd,
                                          LPTSTR lpszclrBkGrnd,
                                          LPTSTR lpszclrForeGrnd);
        void DisableHyperlinksInDocument();
        void ShowHTML();
        void InPlaceActivate();
        void UIActivate();
        BOOL TrySettingFocusOnHtmlElement    (IUnknown* pUnk);
        BOOL SetFocusToFirstHtmlInputElement (void);
        BOOL SetFocusToHtmlPage              (void);

        COleSite();
        ~COleSite();
        void GetObjRect(LPRECT lpRect);
        void CloseOleObject(void);
        void UnloadOleObject(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\sources.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwutil

MAJORCOMP=GETCONN
MINORCOMP=ICWCONN


TARGETNAME=ICWUTIL
TARGETTYPE=DYNLINK
TARGETPATH=obj

DLLENTRY=DllEntryPoint
DLLBASE=0x60000000
DLLDEF=..\icwutil.def

NOT_LEAN_AND_MEAN   =1
RCNOFONTMAP         =1
C_DEFINES           =-DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

USE_MSVCRT          = 1

BROWSER_INFO="yes"

# Make sure this is built before we continue
SYNCHRONIZE_BLOCK = 1

# Conditional compilation

SOURCES= \
    ..\icwutil.rc          \
    ..\dllentry.cpp        \
    ..\server.cpp          \
    ..\factory.cpp         \
    ..\ioips.cpp           \
    ..\ioipf.cpp           \
    ..\iocs.cpp            \
    ..\site.cpp            \
    ..\icwwebvw.cpp        \
    ..\icwwalk.cpp         \
    ..\util.cpp            \
    ..\registry.cpp        \
    ..\weboc.cpp           \
    ..\walker.cpp          \
    ..\gifcon.cpp          \
    ..\validate.cpp        \
    ..\ispdata.cpp         \
    ..\bkgndbmp.cpp

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib      \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\gdi32.lib         \
    $(SDK_LIB_PATH)\tapi32.lib        \
    $(SDK_LIB_PATH)\advapi32.lib      \
    $(SDK_LIB_PATH)\comctl32.lib      \
    $(SDK_LIB_PATH)\shell32.lib       \
    $(SDK_LIB_PATH)\comdlg32.lib      \
    $(SDK_LIB_PATH)\mpr.lib           \
    $(SDK_LIB_PATH)\ole32.lib         \
    $(SDK_LIB_PATH)\oleaut32.lib      \
    $(SDK_LIB_PATH)\uuid.lib          \
    $(SHELL_LIB_PATH)\shlwapip.lib    \
    $(SDK_LIB_PATH)\version.lib

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pre.h
PRECOMPILED_PCH=pre.pch
PRECOMPILED_OBJ=pre.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\util.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  UTIL.C - common utility functions
//

//  HISTORY:
//  

#include "pre.h"


LPWSTR WINAPI A2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
    ASSERT(lpa != NULL);
    ASSERT(lpw != NULL);\
    
    // verify that no illegal character present
    // since lpw was allocated based on the size of lpa
    // don't worry about the number of chars
    lpw[0] = '\0';
    MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
    return lpw;
}

LPSTR WINAPI W2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
    ASSERT(lpw != NULL);
    ASSERT(lpa != NULL);
    
    // verify that no illegal character present
    // since lpa was allocated based on the size of lpw
    // don't worry about the number of chars
    lpa[0] = '\0';
    WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
    return lpa;
}


HRESULT ConnectToConnectionPoint
(
    IUnknown            *punkThis, 
    REFIID              riidEvent, 
    BOOL                fConnect, 
    IUnknown            *punkTarget, 
    DWORD               *pdwCookie, 
    IConnectionPoint    **ppcpOut
)
{
    // We always need punkTarget, we only need punkThis on connect
    if (!punkTarget || (fConnect && !punkThis))
    {
        return E_FAIL;
    }

    if (ppcpOut)
        *ppcpOut = NULL;

    HRESULT hr;
    IConnectionPointContainer *pcpContainer;

    if (SUCCEEDED(hr = punkTarget->QueryInterface(IID_IConnectionPointContainer, (void **)&pcpContainer)))
    {
        IConnectionPoint *pcp;
        if(SUCCEEDED(hr = pcpContainer->FindConnectionPoint(riidEvent, &pcp)))
        {
            if(fConnect)
            {
                // Add us to the list of people interested...
                hr = pcp->Advise(punkThis, pdwCookie);
                if (FAILED(hr))
                    *pdwCookie = 0;
            }
            else
            {
                // Remove us from the list of people interested...
                hr = pcp->Unadvise(*pdwCookie);
                *pdwCookie = 0;
            }

            if (ppcpOut && SUCCEEDED(hr))
                *ppcpOut = pcp;
            else
                pcp->Release();
                pcp = NULL;    
        }
        pcpContainer->Release();
        pcpContainer = NULL;
    }
    return hr;
}


void WINAPI URLEncode(TCHAR* pszUrl, size_t bsize)
{   
    ASSERT(pszUrl);
    TCHAR* pszEncode = NULL;   
    TCHAR* pszEStart = NULL;   
#ifdef UNICODE
    TCHAR* pszEEnd   = (TCHAR*)wmemchr( pszUrl, TEXT('\0'), bsize );
#else
    TCHAR* pszEEnd   = (TCHAR*)memchr( pszUrl, '\0', bsize );
#endif
    int   iChr      = sizeof(TCHAR);
    int   iUrlLen   = (int)(pszEEnd-pszUrl);
    pszEEnd = pszUrl;
    
    TCHAR  c;

    if ((size_t)((iChr*iUrlLen)*3) <= bsize)
    {
        
        pszEncode = (TCHAR*)malloc(sizeof(TCHAR)*(iChr *iUrlLen)*3);
        if(pszEncode)
        {
            pszEStart = pszEncode;
            ZeroMemory(pszEncode, sizeof(TCHAR)*(iChr *iUrlLen)*3);
            
            for(; c = *(pszUrl); pszUrl++)
            {
                switch(c)
                {
                    case ' ': //SPACE
                        memcpy(pszEncode, TEXT("+"), sizeof(TCHAR)*1);
                        pszEncode+=1;
                        break;
                    case '#':
                        memcpy(pszEncode, TEXT("%23"), sizeof(TCHAR)*3);
                        pszEncode+=3;
                        break;
                    case '&':
                        memcpy(pszEncode, TEXT("%26"), sizeof(TCHAR)*3);
                        pszEncode+=3;
                        break;
                    case '%':
                        memcpy(pszEncode, TEXT("%25"), sizeof(TCHAR)*3);
                        pszEncode+=3;
                        break;
                    case '=':
                        memcpy(pszEncode, TEXT("%3D"), sizeof(TCHAR)*3);
                        pszEncode+=3;
                        break;
                    case '<':
                        memcpy(pszEncode, TEXT("%3C"), sizeof(TCHAR)*3);
                        pszEncode+=3;
                        break;
                    case '+':
                        memcpy(pszEncode, TEXT("%2B"), sizeof(TCHAR)*3);
                        pszEncode += 3;
                        break;
                        
                    default:
                        *pszEncode++ = c; 
                        break;          
                }
            }
            *pszEncode++ = '\0';
            memcpy(pszEEnd ,pszEStart, (size_t)(pszEncode - pszEStart));
            free(pszEStart);
        }
    }
}


//BUGBUG:  Need to turn spaces into "+" 
void WINAPI URLAppendQueryPair
(
    LPTSTR   lpszQuery, 
    LPTSTR   lpszName, 
    LPTSTR   lpszValue
)
{
    // Append the Name
    lstrcat(lpszQuery, lpszName);
    lstrcat(lpszQuery, cszEquals);
                    
    // Append the Value
    lstrcat(lpszQuery, lpszValue);
    
    // Append an Ampersand if this is NOT the last pair
    lstrcat(lpszQuery, cszAmpersand);                                        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\validate.h ===
#ifndef   _VALIDATE_H
#define  _VALIDATE_H

BOOL IsValid(LPCTSTR pszText, HWND hWndParent, WORD wNameID);
BOOL validate_cardnum(HWND hWndParent, LPCTSTR lpszRawCardNum);
BOOL validate_cardexpdate(HWND hWndParent, int month, int year);
    
void DoValidErrMsg(HWND hWndParent, int iNameId);
void DoSpecificErrMsg(HWND hWndParent, int iErrId);
    
#endif //_VALIDATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\validate.cpp ===
#include "pre.h"
#include "tchar.h"
#define LCID_JPN    1041  //JAPANESE

// BUGBUG - This function is not very effecient since it requires a alloc/free for each validation
// plus strtok will tokenize the fill string requring a full search of the string.
BOOL IsValid(LPCTSTR pszText, HWND hWndParent, WORD wNameID)
{
    ASSERT(pszText);

    TCHAR* pszTemp = NULL;
    BOOL   bRetVal = FALSE;

    pszTemp = _tcsdup (pszText);    

    if (pszTemp)
    {
        
        if (_tcslen(pszTemp))
        {
            TCHAR seps[]   = TEXT(" ");
            TCHAR* token   = NULL;
            token = _tcstok( pszTemp, seps );
            if (token)
            {
                bRetVal = TRUE;
            }
        }
          
        free(pszTemp);

    }
    
    // If not valid, give the user the error message
    if (!bRetVal)
        DoValidErrMsg(hWndParent, wNameID);
        
    return bRetVal;
    
}

// ============================================================================
// Credit card number validation
// ============================================================================

// Takes a credit card number in the form of 1111-1111-1111-11
// and pads converts it to:
// 11111111111111
// **IMPORTANT** :: This code is multibyte safe but ONLY because we care ONLY about
//                  ANSI #'s
BOOL PadCardNum
(
    LPCTSTR lpszRawCardNum, 
    LPTSTR  szPaddedCardNum,
    UINT    uLenOfRaw
)
{
    LPTSTR lpszTmp = CharPrev(lpszRawCardNum, lpszRawCardNum);    
    UINT  uIndex  = 0;

    for (UINT i =  0; i < uLenOfRaw; i++)
    {
        if( *lpszTmp == '\0' )
            break;
        if((*lpszTmp != '-') && (*lpszTmp != ' '))
        {
            //make sure it's not some other than ansi char.
            if ((*lpszTmp < '0') || (*lpszTmp > '9')) 
                return(FALSE);
            szPaddedCardNum[uIndex] = *lpszTmp;    
            uIndex++;
        }
        
        // Get the prev char
        lpszTmp = CharNext(lpszRawCardNum + i);
    }
    
    szPaddedCardNum[uIndex] = '\0';

    return(TRUE);
} 


/*
    mod_chk()
    performs "Double-Add-Double MOD 10 Check Digit Routine"
    on card number
*/
BOOL mod_chk
(
    LPTSTR credit_card,
    UINT   uCardNumLen
)
{ 
    TCHAR *cp; 
    int dbl       = 0; 
    int check_sum = 0;
    /* 
    * This checksum algorithm has a name, 
    * but I can't think of it. 
    */ 
    cp = credit_card + lstrlen(credit_card) - 1; 
   
    while (cp >= credit_card) 
    { 
        int c; 
        c = *cp-- - '0'; 
        if (dbl) 
        {       
            c *= 2; 
            if (c >= 10) 
                c -= 9; 
        } 
        check_sum += c; 
        dbl = !dbl; 
    } 
    
    return (BOOL)((check_sum % 10) == 0); 
}

BOOL validate_cardnum(HWND hWndParent, LPCTSTR lpszRawCardNum)
// performs:
// a) card type prefix check
// b) Double-Add-Double MOD 10 check digit routine via mod_chk()
//    on the card number.
// The card_num parameter is assumed to have been pre-checked for
// numeric characters and right-justified with '0' padding on the
// left.
{
    BOOL   bRet             = FALSE;
    UINT   uRawLen          = lstrlen(lpszRawCardNum);
    TCHAR* pszPaddedCardNum = (TCHAR*)malloc((uRawLen + 1)*sizeof(TCHAR)); 
    
    if (!pszPaddedCardNum)
        return FALSE;
    
    ZeroMemory(pszPaddedCardNum ,(uRawLen + 1)*sizeof(TCHAR));

    if (PadCardNum(lpszRawCardNum, pszPaddedCardNum, uRawLen))
    {
        UINT  i       = 0;
        LPTSTR tmp_pt = pszPaddedCardNum;
        UINT  uPadLen = lstrlen(pszPaddedCardNum);

        /* find the first non-zero number in card_num */
        while (*tmp_pt == '0' && ++i < uPadLen)
            ++tmp_pt;

        /* all valid  card types are at least 13 characters in length */
        if (uPadLen < 13)
            bRet = FALSE;

        /* check for OK VISA prefix - 4 */
        if ((uPadLen == 16 || uPadLen == 13) && *tmp_pt == '4')
                bRet = mod_chk(pszPaddedCardNum, uPadLen);

        /* check for OK MasterCard prefix - 51 to 55 */
        if (uPadLen == 16) {
            if (*tmp_pt == '5' &&
                *(tmp_pt + 1) >= '1' && *(tmp_pt + 1) <= '5')
                bRet = mod_chk(pszPaddedCardNum, uPadLen);
        }

        /* check for OK American Express prefix - 37 and 34 */
        if (uPadLen == 15 && *tmp_pt == '3' &&
            (*(tmp_pt + 1) == '7' || *(tmp_pt + 1) == '4'))
            bRet = mod_chk(pszPaddedCardNum, uPadLen);

        /* check for OK Discovery prefix - 6011 */
        if (uPadLen == 16 &&
            *tmp_pt == '6' && *(tmp_pt + 1) == '0' &&
            *(tmp_pt + 2) == '1' && *(tmp_pt + 3) == '1')
            bRet = mod_chk(pszPaddedCardNum, uPadLen); 
    }
    
    if (!bRet)
    {
        DoSpecificErrMsg(hWndParent, IDS_PAYMENT_CC_LUHNCHK);
    }

    free(pszPaddedCardNum);
    
    return bRet;
}

BOOL validate_cardexpdate(HWND hWndParent, int month, int year)
{
    BOOL        bRet = FALSE;
    SYSTEMTIME  SystemTime;  
    GetLocalTime(&SystemTime);
    if (year > SystemTime.wYear)
    {
        bRet = TRUE;
    }
    else if (year == SystemTime.wYear)
    {
        if (month >= SystemTime.wMonth)
        {
            bRet = TRUE;
        }
    }

    if (!bRet)
    {
        DoSpecificErrMsg(hWndParent, IDS_PAYMENT_CCEXPDATE);
    }
    return bRet;
}

// ============================================================================
// Error message handlers
// ============================================================================
void DoValidErrMsg(HWND hWndParent, int iNameId)
{
    TCHAR       szCaption     [MAX_RES_LEN+1] = TEXT("\0");
    TCHAR       szErrMsgFmt   [MAX_RES_LEN+1] = TEXT("\0");
    TCHAR       szErrMsgName  [MAX_RES_LEN+1] = TEXT("\0");
    TCHAR       szErrMsg      [2*MAX_RES_LEN];

    if (!LoadString(ghInstance, IDS_APPNAME, szCaption, ARRAYSIZE(szCaption)))
        return;

    if ((IDS_USERINFO_ADDRESS2 == iNameId) && (LCID_JPN == GetUserDefaultLCID())) 
        iNameId = IDS_USERINFO_FURIGANA;

    if (!LoadString(ghInstance, iNameId, szErrMsgName, ARRAYSIZE(szErrMsgName)))
        return;
        
    if (!LoadString(ghInstance, IDS_ERR_INVALID_MSG, szErrMsgFmt, ARRAYSIZE(szErrMsgFmt)))
        return;
        
    wsprintf(szErrMsg, szErrMsgFmt, szErrMsgName);
    
    MessageBox(hWndParent, szErrMsg, szCaption, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);       
}

void DoSpecificErrMsg(HWND hWndParent, int iErrId)
{
    TCHAR szCaption     [MAX_RES_LEN+1] = TEXT("\0");
    TCHAR szErrMsg      [MAX_RES_LEN+1] = TEXT("\0");

    if (!LoadString(ghInstance, IDS_APPNAME, szCaption, ARRAYSIZE(szCaption) ))
        return;
    
    if (!LoadString(ghInstance, iErrId, szErrMsg, ARRAYSIZE(szErrMsg)  ))
        return;
    
    MessageBox(hWndParent, szErrMsg, szCaption, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);       
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\walker.h ===
//**********************************************************************
// File name: WALKER.H
//
//      Definition of COleSite
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _WALKER_H_ )
#define _WALKER_H_

#include <mshtml.h>

class CWalker : public IPropertyNotifySink, IOleClientSite, IDispatch
{
    private:
        ULONG               m_cRef;     //Reference count        
    
    public:
        CWalker()
        {
            m_cRef = 1;
            m_hrConnected = CONNECT_E_CANNOTCONNECT;
            m_dwCookie = 0;
            m_pCP = NULL;
            m_pMSHTML = NULL;
            m_pPageIDForm = NULL;
            m_pBackForm = NULL;
            m_pPageTypeForm = NULL;
            m_pNextForm = NULL;
            m_pPageFlagForm = NULL;
            m_hEventTridentDone = 0;
        }
            
        ~CWalker()
        {
            if (m_pMSHTML)
                m_pMSHTML->Release();
            if (m_pPageIDForm)
                m_pPageIDForm->Release();
            if (m_pBackForm)
                m_pBackForm->Release();
            if (m_pPageTypeForm)
                m_pPageTypeForm->Release();
            if (m_pNextForm)
                m_pNextForm->Release();
            if (m_pPageFlagForm)
                m_pPageFlagForm->Release();
        }

        // IUnknown methods
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppv);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)(); 

        // IPropertyNotifySink methods
        STDMETHOD(OnChanged)(DISPID dispID);
        STDMETHOD(OnRequestEdit)(DISPID dispID)
            { return NOERROR; }

        // IOleClientSite methods
        STDMETHOD(SaveObject)(void) { return E_NOTIMPL; }

        STDMETHOD(GetMoniker)(DWORD dwAssign,
                              DWORD dwWhichMoniker,
                             IMoniker** ppmk)
                { return E_NOTIMPL; }

        STDMETHOD(GetContainer)(IOleContainer** ppContainer)
                { return E_NOTIMPL; }

        STDMETHOD(ShowObject)(void)
                { return E_NOTIMPL; }

        STDMETHOD(OnShowWindow)(BOOL fShow)
                { return E_NOTIMPL; }

        STDMETHOD(RequestNewObjectLayout)(void)
                { return E_NOTIMPL; }

        // IDispatch method
        STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
                { return E_NOTIMPL; }

        STDMETHOD(GetTypeInfo)(UINT iTInfo,
                LCID lcid,
                ITypeInfo** ppTInfo)
                { return E_NOTIMPL; }

        STDMETHOD(GetIDsOfNames)(REFIID riid,
                LPOLESTR* rgszNames,
                UINT cNames,
                LCID lcid,
                DISPID* rgDispId)
                { return E_NOTIMPL; }
            
        STDMETHOD(Invoke)(DISPID dispIdMember,
                REFIID riid,
                LCID lcid,
                WORD wFlags,
                DISPPARAMS __RPC_FAR *pDispParams,
                VARIANT __RPC_FAR *pVarResult,
                EXCEPINFO __RPC_FAR *pExcepInfo,
                UINT __RPC_FAR *puArgErr);

        // Additional class methods
        HRESULT Walk                     ();
        HRESULT AttachToDocument         (IWebBrowser2* lpWebBrowser);
        HRESULT AttachToMSHTML           (BSTR bstrURL);
        HRESULT ExtractUnHiddenText      (BSTR* pbstrText);
        HRESULT Detach                   ();
        HRESULT InitForMSHTML            ();
        HRESULT TermForMSHTML            ();
        HRESULT LoadURLFromFile          (BSTR bstrURL);
        HRESULT ProcessOLSFile           (IWebBrowser2* lpWebBrowser);
        HRESULT get_PageType             (LPDWORD pdwPageType);
        HRESULT get_IsQuickFinish        (BOOL* pbIsQuickFinish);
        HRESULT get_PageFlag             (LPDWORD pdwPageFlag);
        HRESULT get_PageID               (BSTR* pbstrPageID);
        HRESULT get_URL                  (LPTSTR lpszURL, BOOL bForward);
        HRESULT get_IeakIspFile          (LPTSTR lpszIspFile);
        HRESULT get_FirstFormQueryString (LPTSTR lpszQuery);

        DWORD               m_dwCookie;
        LPCONNECTIONPOINT   m_pCP;
        HRESULT             m_hrConnected;

        IHTMLFormElement* get_pNextForm() { return m_pNextForm; }
        IHTMLFormElement* get_pBackForm() { return m_pBackForm; }
        
private:
        HRESULT getQueryString(IHTMLFormElement    *pForm,
                               LPTSTR              lpszQuery);  
        void GetInputValue(LPTSTR lpszName, BSTR *pVal, UINT index, IHTMLFormElement *pForm);

protected:
        IHTMLDocument2* m_pTrident;             // An instance of MSHTML that we CoCreated
        IHTMLDocument2* m_pMSHTML;              // A ref of m_pTrident, OR a QI for the WebBrowser's Document
        
        // These elements will contain the navigation information we need
        IHTMLFormElement* m_pPageIDForm;
        IHTMLFormElement* m_pBackForm;
        IHTMLFormElement* m_pPageTypeForm;
        IHTMLFormElement* m_pNextForm;
        IHTMLFormElement* m_pPageFlagForm;
        
        HANDLE            m_hEventTridentDone;
        
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\weboc.cpp ===
//**********************************************************************
// File name: CebOC.cpp
//
//      WndProc for Hosting a WebOC in a dialog
//
// Functions:
//
// Copyright (c) 1992 - 1998 Microsoft Corporation. All rights reserved.
//**********************************************************************
 
#include "pre.h"

LRESULT CALLBACK WebOCWndProc (HWND hwnd, UINT mMsg, WPARAM wParam, LPARAM lParam)
{ 
    CICWWebView *pICWWebView = (CICWWebView *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch (mMsg)
    {
        case WM_SETFOCUS:
        {
            ASSERT(pICWWebView);
            if (pICWWebView)
                pICWWebView->SetFocus();
            return TRUE;
        }
        
        default:
            return (DefWindowProc (hwnd, mMsg, wParam, lParam));
           
     }
}

void RegWebOCClass()
{
    WNDCLASSEX wc; 

    //Register the WebOC class and bind to dummy proc
    ZeroMemory (&wc, sizeof(WNDCLASSEX));
    wc.style         = CS_GLOBALCLASS;
    wc.cbSize        = sizeof(wc);
    wc.lpszClassName = TEXT("WebOC");
    wc.hInstance     = ghInstance;
    wc.lpfnWndProc   = WebOCWndProc;
    wc.lpszMenuName  = NULL;
    
    RegisterClassEx (&wc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\appdefs.h ===
#ifndef __APPDEFS_H_
#define __APPDEFS_H_

//This file is for application wide definitions
//e.g. defs that are in common between the exe and various dlls

#define RECTWIDTH(rc) ((rc).right - (rc).left)
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)

#define ICW_DOWNLOADABLE_COMPONENT_NAME        TEXT("ICWCONN.DLL")
#define ICW_DOWNLOADABLE_COMPONENT_GETVERFUNC  "GetICWCONNVersion"
#define ICW_DOWNLOADABLE_COMPONENT_VERSION     500
#define ICW_OS_VER                             TEXT("01")

#define ID_BUSY_ANIMATION_WINDOW               10000

#define ICW_UTIL                               TEXT("icwutil.dll")
#define ICW_RESOURCE_ONLY_DLL                  TEXT("icwres.dll")
#define ICW_HTML_HELP_FILE                     TEXT("icwdial.chm")
#define ICW_HTML_HELP_TROUBLE_TOPIC            TEXT("icwdial.chm::/icw_trb.htm")

#define MAX_TITLE                              150
#define MAX_MESSAGE                            255
#define MAX_MESSAGE_LEN                        MAX_RES_LEN * 4
#define MAX_INFO_LEN                           MAX_RES_LEN * 3

#define LCID_CHT                               1028  //CHINESE TRADITIONAL
#define LCID_S_KOR                             1042  //SOUTH KOREAN
#define LCID_N_KOR                             2066  //NORTH KOREAN
#define LCID_CHS                               2052  //CHINESE SIMPLIFIED
#define LCID_JPN                               1041  //JAPANESE

//various flags for the icw including branding stuff
#define ICW_CFGFLAG_OFFERS                     0x00000001  // 0 = No offer;        1 = offers
#define ICW_CFGFLAG_AUTOCONFIG                 0x00000002  // 0 = No;              1 = Yes
#define ICW_CFGFLAG_CNS                        0x00000004  // 0 = No star;         1 = Star
#define ICW_CFGFLAG_SIGNUP_PATH                0x00000008  // 0 = Jump to Finish;  1 = Continue down sign up path
#define ICW_CFGFLAG_USERINFO                   0x00000010  // 0 = Hide name/addr;  1 = Show name/addr page
#define ICW_CFGFLAG_BILL                       0x00000020  // 0 = Hide bill        1 = Show bill page
#define ICW_CFGFLAG_PAYMENT                    0x00000040  // 0 = Hide payment;    1 = Show payment page
#define ICW_CFGFLAG_SECURE                     0x00000080  // 0 = Not secure;      1 = Secure
#define ICW_CFGFLAG_IEAKMODE                   0x00000100  // 0 = No IEAK;         1 = IEAK
#define ICW_CFGFLAG_BRANDED                    0x00000200  // 0 = No branding;     1 = Branding
#define ICW_CFGFLAG_SBS                        0x00000400  // 0 = No SBS           1 = SBS
#define ICW_CFGFLAG_ALLOFFERS                  0x00000800  // 0 = Not all offers   1 = All offers
#define ICW_CFGFLAG_USE_COMPANYNAME            0x00001000  // 0 = Not use          1 = Use company name
#define ICW_CFGFLAG_ISDN_OFFER                 0x00002000  // 0 = Non-ISDN offer   1 = ISDN offer
#define ICW_CFGFLAG_OEM_SPECIAL                0x00004000  // 0 = non OEM special offer    1 = OEM special offer
#define ICW_CFGFLAG_OEM                        0x00008000  // 0 = non OEM offer    1 = OEM offer
#define ICW_CFGFLAG_MODEMOVERRIDE              0x00010000  
#define ICW_CFGFLAG_ISPURLOVERRIDE             0x00020000
#define ICW_CFGFLAG_PRODCODE_FROM_CMDLINE      0x00040000
#define ICW_CFGFLAG_PROMOCODE_FROM_CMDLINE     0x00080000
#define ICW_CFGFLAG_OEMCODE_FROM_CMDLINE       0x00100000
#define ICW_CFGFLAG_SMARTREBOOT_NEWISP         0x00200000
#define ICW_CFGFLAG_SMARTREBOOT_AUTOCONFIG     0x00400000  // this is seperate from ICW_CFGFLAG_AUTOCONFIG so as not to confuse function of flag
#define ICW_CFGFLAG_SMARTREBOOT_MANUAL         0x00800000
#define ICW_CFGFLAG_DO_NOT_OVERRIDE_ALLOFFERS  0x01000000
#define ICW_CFGFLAG_SMARTREBOOT_LAN            0x02000000

//Info required flags
// 1 -- required
// 0 -- optional

//User Info
#define REQUIRE_FE_NAME                        0x00000001
#define REQUIRE_FIRSTNAME                      0x00000002
#define REQUIRE_LASTNAME                       0x00000004
#define REQUIRE_ADDRESS                        0x00000008
#define REQUIRE_MOREADDRESS                    0x00000010
#define REQUIRE_CITY                           0x00000020
#define REQUIRE_STATE                          0x00000040
#define REQUIRE_ZIP                            0x00000080
#define REQUIRE_PHONE                          0x00000100
#define REQUIRE_COMPANYNAME                    0x00000200
//Credit Card
#define REQUIRE_CCNAME                         0x00000400
#define REQUIRE_CCADDRESS                      0x00000800
#define REQUIRE_CCNUMBER                       0x00001000
#define REQUIRE_CCZIP                          REQUIRE_ZIP
//Invoice
#define REQUIRE_IVADDRESS1                     REQUIRE_ADDRESS
#define REQUIRE_IVADDRESS2                     REQUIRE_MOREADDRESS
#define REQUIRE_IVCITY                         REQUIRE_CITY
#define REQUIRE_IVSTATE                        REQUIRE_STATE
#define REQUIRE_IVZIP                          REQUIRE_ZIP
//Phone
#define REQUIRE_PHONEIV_BILLNAME               0x00002000
#define REQUIRE_PHONEIV_ACCNUM                 REQUIRE_PHONE

//Htm pagetype flags
#define PAGETYPE_UNDEFINED                     E_FAIL
#define PAGETYPE_NOOFFERS                      0x00000001
#define PAGETYPE_MARKETING                     0x00000002
#define PAGETYPE_BRANDED                       0x00000004
#define PAGETYPE_BILLING                       0x00000008
#define PAGETYPE_CUSTOMPAY                     0x00000010
#define PAGETYPE_ISP_NORMAL                    0x00000020
#define PAGETYPE_ISP_TOS                       0x00000040
#define PAGETYPE_ISP_FINISH                    0x00000080
#define PAGETYPE_ISP_CUSTOMFINISH              0x00000100
#define PAGETYPE_OLS_FINISH                    0x00000200

//Htm page flags
#define PAGEFLAG_SAVE_CHKBOX                   0x00000001  // Display ISP HTML with checkbox to save info at the bottom

//IEAK ICW isp/htm section info
#define ICW_IEAK_SECTION                       TEXT("ICW_IEAK")
#define ICW_IEAK_USEICW                        TEXT("Use_ICW")
#define ICW_IEAK_ISPNAME                       TEXT("Isp_Display_Name")
#define ICW_IEAK_HTML                          TEXT("Html_Page")
#define ICW_IEAK_TITLE                         TEXT("TitleBar")
#define ICW_IEAK_HEADER_BMP                    TEXT("Header_Bitmap")
#define ICW_IEAK_WATERMARK_BMP                 TEXT("Watermark_Bitmap")
#define ICW_IEAK_USERINFO                      TEXT("Get_UserInfo")
#define ICW_IEAK_BILLING                       TEXT("Get_BillingInfo")
#define ICW_IEAK_PAYMENT                       TEXT("Get_PaymentInfo")
#define ICW_IEAK_BILLINGHTM                    TEXT("Billing_Options_Page")
#define ICW_IEAK_PAYMENTCSV                    TEXT("Payment_Csv_File")
#define ICW_IEAK_TUTORCMDLN                    TEXT("Tutorial_Application_Command_Line")
#define ICW_IEAK_USECOMPANYNAME                TEXT("UseCompanyName")
#define ICW_IEAK_VALIDATEFLAGS                 TEXT("ValidationFlags")

//OEMINFO ICW section info
#define ICW_OEMINFO_FILENAME                   TEXT("oeminfo.ini")
#define ICW_OEMINFO_OEMSECTION                 TEXT("General")
#define ICW_OEMINFO_OEMKEY                     TEXT("Manufacturer")
#define ICW_OEMINFO_ICWSECTION                 TEXT("ICW")
#define ICW_OEMINFO_PRODUCTCODE                TEXT("Product")
#define ICW_OEMINFO_PROMOCODE                  TEXT("Promo")
#define ICW_OEMINFO_ALLOFFERS                  TEXT("AllOffers")
#define ICW_OEMINFO_OFFLINEOFFERS              TEXT("OfflineOffers")
#define ICW_OEMINFO_TUTORCMDLN                 ICW_IEAK_TUTORCMDLN
#define ICW_ISPINFOPath                        TEXT("download\\ispinfo.csv")
#define ICW_OEMINFOPath                        TEXT("offline\\oeminfo.csv")

#define ICW50_PATHKEY                          TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\ICWCONN1.EXE")

#define SPECIAL_VAL_NOOFFER                    0
#define SPECIAL_VAL_OLS                        -1

#define EXTERNAL_DLG_START                     2300

#ifdef ICWDEBUG
//page index defines for ICWDEBUG.EXE
#define ORD_PAGE_ICWDEBUG_OFFER                0
#define ORD_PAGE_ICWDEBUG_SETTINGS             1
#define ORD_PAGE_END                           2
#define EXE_MAX_PAGE_INDEX                     2
#define EXE_NUM_WIZARD_PAGES                   3       // total number of pages in wizard
#else
// page index defines for ICWCONN1.EXE
#define ORD_PAGE_INTRO                         0
#define ORD_PAGE_MANUALOPTIONS                 1
#define ORD_PAGE_AREACODE                      2
#define ORD_PAGE_REFSERVDIAL                   3
#define ORD_PAGE_END                           4
#define ORD_PAGE_ENDOEMCUSTOM                  5
#define ORD_PAGE_ENDOLS                        6
#define ORD_PAGE_REFDIALERROR                  7
#define ORD_PAGE_MULTINUMBER                   8
#define ORD_PAGE_REFSERVERR                    9
#define ORD_PAGE_BRANDEDINTRO                  10
#define ORD_PAGE_INTRO2                        11
#define ORD_PAGE_DEFAULT                       12
#define ORD_PAGE_SBSINTRO                      13
#define EXE_MAX_PAGE_INDEX                     13
#define EXE_NUM_WIZARD_PAGES                   14      // total number of pages in wizard
#endif //ICWDEBUG

// page index defines for ICWCONN.DLL
#define ORD_PAGE_ISPSELECT                     0
#define ORD_PAGE_NOOFFER                       1
#define ORD_PAGE_USERINFO                      2
#define ORD_PAGE_BILLINGOPT                    3
#define ORD_PAGE_PAYMENT                       4
#define ORD_PAGE_ISPDIAL                       5
#define ORD_PAGE_ISPDATA                       6
#define ORD_PAGE_OLS                           7
#define ORD_PAGE_DIALERROR                     8
#define ORD_PAGE_SERVERR                       9
#define ORD_PAGE_ISP_AUTOCONFIG                10
#define ORD_PAGE_ISP_AUTOCONFIG_NOOFFER        11
#define ORD_PAGE_ISDN_NOOFFER                  12
#define ORD_PAGE_OEMOFFER                      13

// Definitions for command line parameters
#define OEMCODE_CMD                            TEXT("/oem")
#define PRODCODE_CMD                           TEXT("/prod")
#define PROMO_CMD                              TEXT("/promo")
#define SHELLNEXT_CMD                          TEXT("/shellnext")
#define SMARTSTART_CMD                         TEXT("/smartstart")
#define STARTURL_CMD                           TEXT("/starturl")
#define UPDATEDESKTOP_CMD                      TEXT("/desktop")
#define RESTOREDESKTOP_CMD                     TEXT("/restoredesktop")
#define ICW_IEAK_CMD                           TEXT("/ieak")
#define BRANDED_CMD                            TEXT("/branded")          // Allow branding
#define RUNONCE_CMD                            TEXT("/runonce")          // Run once only
#define SMARTREBOOT_CMD                        TEXT("/smartreboot")
#define SHORTCUTENTRY_CMD                      TEXT("/icon")             //changed from /shortcut per simons
#define SKIPINTRO_CMD                          TEXT("/skipintro")        // simulate "next" click right away on intro page
#ifdef DEBUG
#define ICON_CMD                               TEXT("/puticon")           // Debug only
#endif
#define DEBUG_OEMCUSTOM                        TEXT("/checkoemcustini")

#define PRODCODE_SBS                           TEXT("sbs")               // for /prod sbs
#define NEWISP_SR                              TEXT("new")               // for /smartreboot new
#define AUTO_SR                                TEXT("auto")              // for /smartreboot auto
#define MANUAL_SR                              TEXT("manual")            // for /smartreboot manual
#define LAN_SR                                 TEXT("lan")               // for /smartreboot LAN
// Default strings for oem, prod, and promo code
#define DEFAULT_OEMCODE                        TEXT("Default")
#define DEFAULT_PRODUCTCODE                    TEXT("Desktop")
#define DEFAULT_PROMOCODE                      TEXT("Default")

#define WM_RUNICWTUTORAPP                      ((WM_USER) + 300)

// This takes into account the inital dial for a total of three
#define NUM_MAX_REDIAL 2 

// handler proc for OK, cancel, etc button handlers
typedef BOOL (CALLBACK* INITPROC)(HWND,BOOL, UINT *);
typedef BOOL (CALLBACK* POSTINITPROC)(HWND,BOOL, UINT *);
typedef BOOL (CALLBACK* OKPROC)(HWND,BOOL,UINT *,BOOL *);
typedef BOOL (CALLBACK* CANCELPROC)(HWND);
typedef BOOL (CALLBACK* CMDPROC)(HWND,WPARAM,LPARAM);
typedef BOOL (CALLBACK* NOTIFYPROC)(HWND, WPARAM, LPARAM);

#define SetPropSheetResult( hwnd, result ) SetWindowLongPtr(hwnd, DWLP_MSGRESULT, result)

// structure with information for each wizard page
typedef struct tagPAGEINFO
{
  UINT          uDlgID;            // dialog ID to use for page
  BOOL          bIsHostingWebOC;
  
  // handler procedures for each page-- any of these can be
  // NULL in which case the default behavior is used
  INITPROC      InitProc;
  POSTINITPROC  PostInitProc;
  OKPROC        OKProc;
  CMDPROC       CmdProc;
  CANCELPROC    CancelProc;
  NOTIFYPROC    NotifyProc;
    
  int           nIdTitle;
  int           nIdSubTitle;
  
  int           idAccel;        // ID of the accelerator table
  HACCEL        hAccel;         // Accelerator table
  HACCEL        hAccelNested;   // Accelerator table for nested dialog
} PAGEINFO;

// These are contol defines for controls that have accelerator access. 
// They must be defined here, instead of in the DLL, so that the app 
// can access the defines

#define IDC_ISPLIST                     3000
#define IDC_ISPMARKETING                3001
#define IDC_ISPLIST_INFO                3002
#define IDC_USERINFO_FIRSTNAME          3008
#define IDC_USERINFO_LASTNAME           3009
#define IDC_USERINFO_COMPANYNAME        3068
#define IDC_USERINFO_ADDRESS1           3010
#define IDC_USERINFO_ADDRESS2           3011
#define IDC_USERINFO_CITY               3012
#define IDC_USERINFO_STATE              3013
#define IDC_USERINFO_ZIP                3014
#define IDC_USERINFO_PHONE              3015
#define IDC_USERINFO_FE_NAME            3007
#define IDC_BILLINGOPT_HTML             3017
#define IDC_PAYMENTTYPE                 3018
#define IDC_PAYMENT_CCNUMBER            3019
#define IDC_PAYMENT_EXPIREMONTH         3020
#define IDC_PAYMENT_EXPIREYEAR          3021
#define IDC_PAYMENT_CCNAME              3022
#define IDC_PAYMENT_CCADDRESS           3023
#define IDC_PAYMENT_CCZIP               3024
#define IDC_PAYMENT_IVADDRESS1          3040
#define IDC_PAYMENT_IVADDRESS2          3042
#define IDC_PAYMENT_IVCITY              3044
#define IDC_PAYMENT_IVSTATE             3046
#define IDC_PAYMENT_IVZIP               3048
#define IDC_PAYMENT_PHONEIV_BILLNAME    3050
#define IDC_PAYMENT_PHONEIV_ACCNUM      3052
#define IDC_ISPDATA_TOSACCEPT           3037
#define IDC_ISPDATA_TOSDECLINE          3038
#define IDC_ISPDATA_TOSSAVE             3065
#define IDC_DIALERR_PHONENUMBER         3062
#define IDC_DIALERR_PROPERTIES          3088
#define IDC_DIAL_HELP                   3071
#define IDC_OEMOFFER_MORE               3202
                                        
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\icwcfg.h ===
/********************************************************************

  ICWCFG.H

  Copyright(c) Microsoft Corporation, 1996 - 97

  *** N O T   F O R   E X T E R N A L   R E L E A S E *******
  *
  * This header file is not intended for distribution outside Microsoft.
  *
  ***********************************************************

  Header file for Internet Connection Wizard external configuration
  routines found in INETCFG.DLL.

  Routines:

  CheckConnectionWizard - Checks which parts of ICW are installed
        and if it has been run before.  It optionally will start
        either the full or manual path of ICW if it is insalled
        but has not been run before.

  History:  10/22/96    Created
        10/24/96    Added defines and typedefs
        2/25/97     Added CreateDirectoryService -- jmazner
        4/24/97     Removed InetCreate*, these are now owned
                    by the Account Manager -- jmazner

  Support:  This header file (and INETCFG.DLL) is supported by the
            Internet Connection Wizard team (alias icwcore).  Please
            do not modify this directly.

*********************************************************************/

#ifndef _ICWCFG_H_

//
// defines
//

// ICW registry settings

// HKEY_CURRENT_USER
#define ICW_REGPATHSETTINGS TEXT("Software\\Microsoft\\Internet Connection Wizard")
#define ICW_REGKEYCOMPLETED TEXT("Completed")
#define ICW_REGKEYERROR     TEXT("ICWError")

// Maximum field lengths
#define ICW_MAX_ACCTNAME    256
#define ICW_MAX_PASSWORD    256 // PWLEN
#define ICW_MAX_LOGONNAME   256 // UNLEN
#define ICW_MAX_SERVERNAME  64
#define ICW_MAX_RASNAME     256 // RAS_MaxEntryName
#define ICW_MAX_EMAILNAME   64
#define ICW_MAX_EMAILADDR   128

// Bit-mapped flags

// CheckConnectionWizard input flags
#define ICW_CHECKSTATUS     0x0001

#define ICW_LAUNCHFULL      0x0100
#define ICW_LAUNCHMANUAL    0x0200
#define ICW_USE_SHELLNEXT   0x0400
#define ICW_FULL_SMARTSTART 0x0800

// CheckConnectionWizard output flags
#define ICW_FULLPRESENT     0x0001
#define ICW_MANUALPRESENT   0x0002
#define ICW_ALREADYRUN      0x0004

#define ICW_LAUNCHEDFULL    0x0100
#define ICW_LAUNCHEDMANUAL  0x0200

// InetCreateMailNewsAccount input flags
#define ICW_USEDEFAULTS     0x0001

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


//
// external function typedefs
//
typedef DWORD   (WINAPI *PFNCHECKCONNECTIONWIZARD) (DWORD, LPDWORD);
typedef DWORD   (WINAPI *PFNSETSHELLNEXT) (CHAR *);

//
// external function declarations
//
DWORD   WINAPI CheckConnectionWizard(DWORD, LPDWORD);
DWORD   WINAPI SetShellNextA(CHAR *);
DWORD   WINAPI SetShellNextW(WCHAR *);

#ifdef UNICODE
#define SetShellNext  SetShellNextW
#else
#define SetShellNext  SetShellNextA
#endif


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _ICWCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\ccstock.h ===
//
// CCSHELL stock definition and declaration header
//


#ifndef __CCSTOCK_H__
#define __CCSTOCK_H__

#ifndef RC_INVOKED

// NT and Win95 environments set warnings differently.  This makes
// our project consistent across environments.

#pragma warning(3:4101)   // Unreferenced local variable

//
// Sugar-coating
//

#define PUBLIC
#define PRIVATE
#define IN
#define OUT
#define BLOCK

#ifndef DECLARE_STANDARD_TYPES

/*
 * For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
 */

#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;

#endif

#ifndef DECLARE_STANDARD_TYPES_U

/*
 * For a type "FOO", define the standard derived UNALIGNED types PFOO, CFOO, and PCFOO.
 *  WINNT: RISC boxes care about ALIGNED, intel does not.
 */

#define DECLARE_STANDARD_TYPES_U(type)    typedef UNALIGNED type *P##type; \
                                          typedef UNALIGNED const type C##type; \
                                          typedef UNALIGNED const type *PC##type;

#endif

// For string constants that are always wide
#define __TEXTW(x)    L##x
#define TEXTW(x)      __TEXTW(x)

// Count of characters to count of bytes
//
#define CbFromCchW(cch)             ((cch)*sizeof(WCHAR))
#define CbFromCchA(cch)             ((cch)*sizeof(CHAR))
#ifdef UNICODE
#define CbFromCch                   CbFromCchW
#else  // UNICODE
#define CbFromCch                   CbFromCchA
#endif // UNICODE

// General flag macros
//
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))

// String macros
//
#define IsSzEqual(sz1, sz2)         (BOOL)(lstrcmpi(sz1, sz2) == 0)
#define IsSzEqualC(sz1, sz2)        (BOOL)(lstrcmp(sz1, sz2) == 0)

#define lstrnicmpA(sz1, sz2, cch)   StrCmpNIA(sz1, sz2, cch)
#define lstrnicmpW(sz1, sz2, cch)   StrCmpNIW(sz1, sz2, cch)
#define lstrncmpA(sz1, sz2, cch)    StrCmpNA(sz1, sz2, cch)
#define lstrncmpW(sz1, sz2, cch)    StrCmpNW(sz1, sz2, cch)

#ifdef UNICODE
#define lstrnicmp       lstrnicmpW
#define lstrncmp        lstrncmpW
#else
#define lstrnicmp       lstrnicmpA
#define lstrncmp        lstrncmpA
#endif

#ifndef SIZEOF
#define SIZEOF(a)                   sizeof(a)
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif
#define SIZECHARS(sz)               (sizeof(sz)/sizeof(sz[0]))

#ifndef NULL_TERM_TCHARS
#define NULL_TERM_TCHARS(sz);       {sz[ARRAYSIZE(sz)-1] = TEXT('\0');}
#endif

#define InRange(id, idFirst, idLast)      ((UINT)((id)-(idFirst)) <= (UINT)((idLast)-(idFirst)))

#define ZeroInit(pv, cb)            (memset((pv), 0, (cb)))

#ifdef DEBUG
// This macro is especially useful for cleaner looking code in
// declarations or for single lines.  For example, instead of:
//
//   {
//       DWORD dwRet;
//   #ifdef DEBUG
//       DWORD dwDebugOnlyVariable;
//   #endif
//
//       ....
//   }
//
// You can type:
//
//   {
//       DWORD dwRet;
//       DEBUG_CODE( DWORD dwDebugOnlyVariable; )
//
//       ....
//   }

#define DEBUG_CODE(x)               x
#else
#define DEBUG_CODE(x)

#endif  // DEBUG


//
// SAFECAST(obj, type)
//
// This macro is extremely useful for enforcing strong typechecking on other
// macros.  It generates no code.
//
// Simply insert this macro at the beginning of an expression list for
// each parameter that must be typechecked.  For example, for the
// definition of MYMAX(x, y), where x and y absolutely must be integers,
// use:
//
//   #define MYMAX(x, y)    (SAFECAST(x, int), SAFECAST(y, int), ((x) > (y) ? (x) : (y)))
//
//
#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))


//
// Bitfields don't get along too well with bools,
// so here's an easy way to convert them:
//
#define BOOLIFY(expr)           (!!(expr))


// BUGBUG (scotth): we should probably make this a 'bool', but be careful
// because the Alpha compiler might not recognize it yet.  Talk to AndyP.

// This isn't a BOOL because BOOL is signed and the compiler produces 
// sloppy code when testing for a single bit.

typedef DWORD   BITBOOL;


#endif // RC_INVOKED

#endif // __CCSTOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwutil\walker.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  WALKER.CPP - Functions for walking an HTML input file
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"
#include <urlmon.h>
#include <mshtmdid.h>
#include <mshtml.h>
#include <shlobj.h>

const TCHAR cszEquals[]               = TEXT("=");
const TCHAR cszAmpersand[]            = TEXT("&");
const TCHAR cszPlus[]                 = TEXT("+");
const TCHAR cszQuestion[]             = TEXT("?");
const TCHAR cszFormNamePAGEID[]       = TEXT("PAGEID");
const TCHAR cszFormNameBACK[]         = TEXT("BACK");
const TCHAR cszFormNamePAGETYPE[]     = TEXT("PAGETYPE");
const TCHAR cszFormNameNEXT[]         = TEXT("NEXT");
const TCHAR cszFormNamePAGEFLAG[]     = TEXT("PAGEFLAG");
const TCHAR cszPageTypeTERMS[]        = TEXT("TERMS");
const TCHAR cszPageTypeCUSTOMFINISH[] = TEXT("CUSTOMFINISH");
const TCHAR cszPageTypeFINISH[]       = TEXT("FINISH");
const TCHAR cszPageTypeNORMAL[]       = TEXT("");
const TCHAR cszOLSRegEntries[]        = TEXT("regEntries");
const TCHAR cszKeyName[]              = TEXT("KeyName");
const TCHAR cszEntryName[]            = TEXT("EntryName"); 
const TCHAR cszEntryValue[]           = TEXT("EntryValue");
const TCHAR cszOLSDesktopShortcut[]   = TEXT("DesktopShortcut");
const TCHAR cszSourceName[]           = TEXT("SourceName");
const TCHAR cszTargetName[]           = TEXT("TargetName"); 

#define HARDCODED_IEAK_ISPFILE_ELEMENT_ID TEXT("g_IspFilePath")

// COM interfaces
STDMETHODIMP CWalker::QueryInterface(REFIID riid, LPVOID* ppv)
{
    *ppv = NULL;

    if (IID_IUnknown == riid || IID_IPropertyNotifySink == riid)
    {
        *ppv = (LPUNKNOWN)(IPropertyNotifySink*)this;
        AddRef();
        return NOERROR;
    }
    else if (IID_IOleClientSite == riid)
    {
        *ppv = (IOleClientSite*)this;
        AddRef();
        return NOERROR;
    }
    else if (IID_IDispatch == riid)
    {
        *ppv = (IDispatch*)this;
        AddRef();
        return NOERROR;
    }
    else
    {
        return E_NOTIMPL;
    }
}

STDMETHODIMP_(ULONG) CWalker::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CWalker::Release()
{
    if (!(--m_cRef)) 
    { 
        delete this; 
    }
    return m_cRef;
}

// Fired on change of the value of a 'bindable' property
STDMETHODIMP CWalker::OnChanged(DISPID dispID)
{
    HRESULT hr;

    if (DISPID_READYSTATE == dispID)
    {
        // check the value of the readystate property
        assert(m_pMSHTML);

        VARIANT vResult = {0};
        EXCEPINFO excepInfo;
        UINT uArgErr;

        DISPPARAMS dp = {NULL, NULL, 0, 0};
        if (SUCCEEDED(hr = m_pMSHTML->Invoke(DISPID_READYSTATE, IID_NULL, LOCALE_SYSTEM_DEFAULT, 
            DISPATCH_PROPERTYGET, &dp, &vResult, &excepInfo, &uArgErr)))
        {
            assert(VT_I4 == V_VT(&vResult));
            if (READYSTATE_COMPLETE == (READYSTATE)V_I4(&vResult))
                SetEvent(m_hEventTridentDone);
            VariantClear(&vResult);
        }
    }
    return NOERROR;
}

// MSHTML Queries for the IDispatch interface of the host through the IOleClientSite
// interface that MSHTML is passed through its implementation of IOleObject::SetClientSite()
STDMETHODIMP CWalker::Invoke(DISPID dispIdMember,
            REFIID riid,
            LCID lcid,
            WORD wFlags,
            DISPPARAMS __RPC_FAR *pDispParams,
            VARIANT __RPC_FAR *pVarResult,
            EXCEPINFO __RPC_FAR *pExcepInfo,
            UINT __RPC_FAR *puArgErr)
{
    if (!pVarResult)
    {
        return E_POINTER;
    }

    switch(dispIdMember)
    {
        case DISPID_AMBIENT_DLCONTROL: 
            // respond to this ambient to indicate that we only want to
            // download the page, but we don't want to run scripts,
            // Java applets, or ActiveX controls
            V_VT(pVarResult) = VT_I4;
            V_I4(pVarResult) =  DLCTL_DOWNLOADONLY | 
                                DLCTL_NO_SCRIPTS | 
                                DLCTL_NO_JAVA |
                                DLCTL_NO_DLACTIVEXCTLS |
                                DLCTL_NO_RUNACTIVEXCTLS;
            break;
            
        default:
            return DISP_E_MEMBERNOTFOUND;
    }
    return NOERROR;
}

// A more traditional form of persistence. 
// MSHTML performs this asynchronously as well.
HRESULT CWalker::LoadURLFromFile(BSTR   bstrURL)
{
    HRESULT hr;

    LPPERSISTFILE  pPF;
    // MSHTML supports file persistence for ordinary files.
    if ( SUCCEEDED(hr = m_pMSHTML->QueryInterface(IID_IPersistFile, (LPVOID*) &pPF)))
    {
        hr = pPF->Load(bstrURL, 0);
        pPF->Release();
    }

    return hr;
}


// Local interfaces

// This function will attached trient to a location FILE: URL, and ensure that it is ready
// to be walked
HRESULT CWalker::InitForMSHTML()
{
    HRESULT hr;
    LPCONNECTIONPOINTCONTAINER pCPC = NULL;
    LPOLEOBJECT pOleObject = NULL;
    LPOLECONTROL pOleControl = NULL;

    // Create an instance of an dynamic HTML document
    if (FAILED(hr = CoCreateInstance( CLSID_HTMLDocument, NULL, 
                    CLSCTX_INPROC_SERVER, IID_IHTMLDocument2, 
                    (LPVOID*)&m_pTrident )))
    {
        goto Error;
    }

    
    if (FAILED(hr = m_pTrident->QueryInterface(IID_IOleObject, (LPVOID*)&pOleObject)))
    {
        goto Error;
    }
    hr = pOleObject->SetClientSite((IOleClientSite*)this);
    pOleObject->Release();

    if (FAILED(hr = m_pTrident->QueryInterface(IID_IOleControl, (LPVOID*)&pOleControl)))
    {
        goto Error;
    }
    hr = pOleControl->OnAmbientPropertyChange(DISPID_AMBIENT_DLCONTROL);
    pOleControl->Release();

    // Hook up sink to catch ready state property change
    if (FAILED(hr = m_pTrident->QueryInterface(IID_IConnectionPointContainer, (LPVOID*)&pCPC)))
    {
        goto Error;
    }

    if (FAILED(hr = pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &m_pCP)))
    {
        goto Error;
    }

    m_hrConnected = m_pCP->Advise((LPUNKNOWN)(IPropertyNotifySink*)this, &m_dwCookie);
    
Error:
    if (pCPC) 
        pCPC->Release();

    return hr;
}

// Clean up connection point
HRESULT CWalker::TermForMSHTML()
{
    HRESULT hr = NOERROR;

    // Disconnect from property change notifications
    if (SUCCEEDED(m_hrConnected))
    {
        hr = m_pCP->Unadvise(m_dwCookie);
    }

    // Release the connection point
    if (m_pCP) 
        m_pCP->Release();

    if (m_pTrident)
        m_pTrident->Release();
        
    return hr;
}

HRESULT CWalker::ExtractUnHiddenText(BSTR* pbstrText)
{
    VARIANT                  vIndex;
    LPDISPATCH               pDisp; 
    IHTMLInputHiddenElement* pHidden;
    IHTMLElement*            pElement;
    BSTR                     bstrValue;
    VARIANT                  var2   = { 0 };
    long                     lLen   = 0;
          
    vIndex.vt = VT_UINT;
    bstrValue = SysAllocString(A2W(TEXT("\0")));

    
    Walk();

    if (!m_pNextForm)
        return E_UNEXPECTED;
    
    m_pNextForm->get_length(&lLen);
       
    for (int i = 0; i < lLen; i++)
    {
        vIndex.lVal = i;
        pDisp = NULL;     

        if(SUCCEEDED(m_pNextForm->item(vIndex, var2, &pDisp)) && pDisp)
        {
            pHidden = NULL;
            
            if(SUCCEEDED(pDisp->QueryInterface(IID_IHTMLInputHiddenElement, (LPVOID*)&pHidden)) && pHidden)
            {
                pHidden->put_value(bstrValue);
                pHidden->Release();    
            }
            pDisp->Release();
        }
    }
    
    if (SUCCEEDED(m_pNextForm->QueryInterface(IID_IHTMLElement, (LPVOID*)&pElement)) && pElement) 
        pElement->get_innerHTML(pbstrText);

    SysFreeString(bstrValue);
    
    return S_OK;
}

HRESULT CWalker::AttachToMSHTML(BSTR bstrURL)
{
    HRESULT hr;
    
    // Release any previous instance of the HTML document pointer we might be holding on to
    if(m_pMSHTML)
    {
        m_pMSHTML->Release();
        m_pMSHTML = NULL;
    }
    
    m_pMSHTML = m_pTrident;
    m_pMSHTML->AddRef();
    
    m_hEventTridentDone = CreateEvent(NULL, TRUE, FALSE, NULL);
    
    hr = LoadURLFromFile(bstrURL);
    if (SUCCEEDED(hr) || (E_PENDING == hr))
    {
        if (m_hEventTridentDone)
        {
            MSG     msg;
            DWORD   dwRetCode;
            HANDLE  hEventList[1];
            hEventList[0] = m_hEventTridentDone;
    
            while (TRUE)
            {
                // We will wait on window messages and also the named event.
                dwRetCode = MsgWaitForMultipleObjects(1, 
                                                  &hEventList[0], 
                                                  FALSE, 
                                                  300000,            // 5 minutes
                                                  QS_ALLINPUT);

                // Determine why we came out of MsgWaitForMultipleObjects().  If
                // we timed out then let's do some TrialWatcher work.  Otherwise
                // process the message that woke us up.
                if (WAIT_TIMEOUT == dwRetCode)
                {
                    break;
                }
                else if (WAIT_OBJECT_0 == dwRetCode)
                {
                    break;
                }
                else if (WAIT_OBJECT_0 + 1 == dwRetCode)
                {
                    // Process all messages in the Queue, since MsgWaitForMultipleObjects
                    // will not do this for us
                    while (TRUE)
                    {   
                        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                        {
                            if (WM_QUIT == msg.message)
                            {
                                break;
                            }
                            else
                            {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }                                
                        } 
                        else
                        {
                            break;
                        }                   
                    }
                }
            }
            
            CloseHandle(m_hEventTridentDone);
            m_hEventTridentDone = 0;
        }            
        else
        {
            // If we were pending, and we could not wait, we got a problem...
            if(E_PENDING == hr)
                hr = E_FAIL;
        }
    }
    return (hr);
}

HRESULT CWalker::AttachToDocument(IWebBrowser2 *lpWebBrowser)
{
    HRESULT     hr;
    LPDISPATCH  pDisp; 
   
    // Release any previous instance of the HTML document pointer we might be holding on to
    if(m_pMSHTML)
    {
        // If the m_pMSHMTL is NOT our internal Trident object (for walking files)
        // then sombody did not do a detach, so we need to release the previous
        // MSHTML object
        if (m_pMSHTML != m_pTrident)
            m_pMSHTML->Release();
        m_pMSHTML = NULL;
    }
       
    // Make sure we have a webbrowser to grab onto      
    ASSERT(lpWebBrowser);

    // Get the document pointer from this webbrowser.
    if (SUCCEEDED(hr = lpWebBrowser->get_Document(&pDisp)))  
    {
        if (pDisp)
        {
            hr = pDisp->QueryInterface( IID_IHTMLDocument2, (LPVOID*)&m_pMSHTML );
            // Paranoia, but trident/shdocvw might say OK, but really not give us a document
            if (!m_pMSHTML)
                hr = E_FAIL;
                
            pDisp->Release();                
        }
        else
        {
            hr = E_FAIL;                
        }            
    }
    return (hr);    
}

HRESULT CWalker::Detach()
{
    if (m_pPageIDForm)
    {
        m_pPageIDForm->Release();
        m_pPageIDForm = NULL;
    }       
    if (m_pBackForm)
    {
        m_pBackForm->Release();
        m_pBackForm = NULL;
    }        
    if (m_pPageTypeForm)
    {
        m_pPageTypeForm->Release();
        m_pPageTypeForm = NULL;
    }        
    if (m_pNextForm)
    {
        m_pNextForm->Release();
        m_pNextForm = NULL;
    }        
    if (m_pPageFlagForm)
    {
        m_pPageFlagForm->Release();
        m_pPageFlagForm = NULL;
    }        
    if(m_pMSHTML)
    {
        // If the m_pMSHMTL is NOT our internal Trident object (for walking files)
        // then sombody did not do a detach, so we need to release the previous
        // MSHTML object
        if (m_pMSHTML != m_pTrident)
            m_pMSHTML->Release();
        m_pMSHTML = NULL;
    }
    return S_OK;
}

// Walk the object model.
HRESULT CWalker::Walk()
{
    HRESULT hr;
    IHTMLElementCollection* pColl = NULL;

    assert(m_pMSHTML);
    if (!m_pMSHTML)
    {
        return E_UNEXPECTED;
    }

    // retrieve a reference to the ALL collection
    if (SUCCEEDED(hr = m_pMSHTML->get_all( &pColl )))
    {
        long cElems;

        assert(pColl);

        // retrieve the count of elements in the collection
        if (SUCCEEDED(hr = pColl->get_length( &cElems )))
        {
            // for each element retrieve properties such as TAGNAME and HREF
            for ( int i=0; i<cElems; i++ )
            {
                VARIANT vIndex;
                vIndex.vt = VT_UINT;
                vIndex.lVal = i;
                VARIANT var2 = { 0 };
                LPDISPATCH pDisp; 

                if (SUCCEEDED(hr = pColl->item( vIndex, var2, &pDisp )))
                {
                    // Look for <FORM> tags
                    IHTMLFormElement* pForm = NULL;
                    if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLFormElement, (LPVOID*)&pForm )))
                    {
                        BSTR    bstrName;
                                                    
                        assert(pForm);

                        // Get the Name
                        hr = pForm->get_name(&bstrName);
                        if (SUCCEEDED(hr))
                        {
                            LPTSTR   lpszName = W2A(bstrName);
                            
                            // See what kind it is
                            if (lstrcmpi(lpszName, cszFormNamePAGEID) == 0)
                            {
                                m_pPageIDForm = pForm;
                                m_pPageIDForm->AddRef();
                            }                                    
                            else if (lstrcmpi(lpszName, cszFormNameBACK) == 0)
                            {
                                m_pBackForm = pForm;
                                m_pBackForm->AddRef();
                            }
                            else if (lstrcmpi(lpszName, cszFormNamePAGETYPE) == 0)
                            {
                                m_pPageTypeForm = pForm;
                                m_pPageTypeForm->AddRef();
                            }
                            else if (lstrcmpi(lpszName, cszFormNameNEXT) == 0)
                            {
                                m_pNextForm = pForm;
                                m_pNextForm->AddRef();
                            }
                            else if (lstrcmpi(lpszName, cszFormNamePAGEFLAG) == 0)
                            {
                                m_pPageFlagForm = pForm;
                                m_pPageFlagForm->AddRef();
                            }
                            
                            SysFreeString(bstrName);
                        }
                        pForm->Release();
                    }
                    pDisp->Release();
                } // item
            } // for
        } // get_length
        pColl->Release();
    } // get_all

    return hr;
}



HRESULT CWalker::get_IsQuickFinish(BOOL* pbIsQuickFinish)
{
    if (!m_pPageTypeForm)
        return (E_FAIL);

    IHTMLElement* pElement = NULL;
    VARIANT       varValue;
    VariantInit(&varValue);

    V_VT(&varValue) = VT_BSTR;    
    *pbIsQuickFinish = FALSE;

    if (SUCCEEDED(m_pPageTypeForm->QueryInterface(IID_IHTMLElement, (void**)&pElement)))
    {
        if (SUCCEEDED(pElement->getAttribute(A2W(TEXT("QUICKFINISH")), FALSE, &varValue)))
        {   
            if (VT_NULL != varValue.vt)
            {
                if(lstrcmpi(W2A(varValue.bstrVal), TEXT("TRUE")) == 0)
                    *pbIsQuickFinish = TRUE;
            }                    
        }
        pElement->Release();
    }
    return S_OK;
}

HRESULT CWalker::get_PageType(LPDWORD pdwPageType)
{
    BSTR    bstr;
    HRESULT hr;
    
    if (!m_pPageTypeForm)
        return (E_FAIL);
                                                          
    // Get the Action for the PageType Form
    hr = m_pPageTypeForm->get_action(&bstr);
    if (SUCCEEDED(hr))
    {
        LPTSTR   lpszType = W2A(bstr);
  
        // See what kind it is
        if (lstrcmpi(lpszType, cszPageTypeTERMS) == 0)
            *pdwPageType = PAGETYPE_ISP_TOS;
        else if (lstrcmpi(lpszType, cszPageTypeCUSTOMFINISH) == 0)
            *pdwPageType = PAGETYPE_ISP_CUSTOMFINISH;
        else if (lstrcmpi(lpszType, cszPageTypeFINISH) == 0)
            *pdwPageType = PAGETYPE_ISP_FINISH;
        else if (lstrcmpi(lpszType, cszPageTypeNORMAL) == 0)
            *pdwPageType = PAGETYPE_ISP_NORMAL;
        else
            *pdwPageType = PAGETYPE_UNDEFINED;
            
        SysFreeString(bstr);            
    }
        
    return (hr);    
}

HRESULT CWalker::get_PageFlag(LPDWORD pdwPageFlag)
{
    BSTR    bstr;
    HRESULT hr;
    
    *pdwPageFlag = 0;

    if (!m_pPageFlagForm)
        return (E_FAIL);
                                                   
    // Get the Action for the PageFlag Form
    hr = m_pPageFlagForm->get_action(&bstr);
    if (SUCCEEDED(hr))
    {
        LPTSTR   lpszType = W2A(bstr);
                            
        // See what kind it is
        *pdwPageFlag = _ttol(lpszType);
            
        SysFreeString(bstr);            
    }
        
    return (hr);    
}

HRESULT CWalker::get_PageID(BSTR    *pbstrPageID)
{
    HRESULT hr;
    
    if (!m_pPageIDForm)
        return (E_FAIL);
    
    if (!pbstrPageID)
        return (E_FAIL);
                                                              
    // Get the Action for the PageType Form
    hr = m_pPageIDForm->get_action(pbstrPageID);
        
    return (hr);    
}

HRESULT CWalker::getQueryString
(
    IHTMLFormElement    *pForm,
    LPTSTR               lpszQuery
)    
{
    HRESULT hr;
    long    lFormLength;

    if (SUCCEEDED(pForm->get_length(&lFormLength)))
    {
        for (int i = 0; i < lFormLength; i++)
        {
            VARIANT vIndex;
            vIndex.vt = VT_UINT;
            vIndex.lVal = i;
            VARIANT var2 = { 0 };
            LPDISPATCH pDisp; 

            if (SUCCEEDED(hr = pForm->item( vIndex, var2, &pDisp )))
            {
                // See if the Item is a Input button
                IHTMLButtonElement* pButton = NULL;
                IHTMLInputButtonElement* pInputButton = NULL;
                IHTMLInputFileElement* pInputFile = NULL;
                IHTMLInputHiddenElement* pInputHidden = NULL;
                IHTMLInputTextElement* pInputText = NULL;
                IHTMLSelectElement* pSelect = NULL;
                IHTMLTextAreaElement* pTextArea = NULL;
                IHTMLOptionButtonElement* pOptionButton = NULL;
                
                // First check to see if this is an OptionButton.
                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLOptionButtonElement, (LPVOID*)&pOptionButton )))
                {
                    BSTR    bstr = NULL;
                    
                    // See if it is a Radio or a CheckBox
                    if (SUCCEEDED(pOptionButton->get_type(&bstr)))
                    {
                        LPTSTR   lpszType = W2A(bstr);
                        
                        if ((lstrcmpi(lpszType, TEXT("radio")) == 0) || (lstrcmpi(lpszType, TEXT("checkbox")) == 0))
                        {
                            short    bChecked;
                            // See if the button is checked. If it is, then it needs to be
                            // added to the query string
                            if (SUCCEEDED(pOptionButton->get_checked(&bChecked)))
                            {
                                if(bChecked)
                                {
                                    BSTR    bstrName;
                                    BSTR    bstrValue;
                                    
            
                                    if ( SUCCEEDED(pOptionButton->get_name(&bstrName)) &&
                                         SUCCEEDED(pOptionButton->get_value(&bstrValue)) )
                                    {
                                        if (bstrValue)
                                        {
                                            size_t size = sizeof(TCHAR)*(lstrlen(W2A(bstrValue)) + 1);
                                            TCHAR* szVal = (TCHAR*)malloc(size * 3);
                                            if (szVal)
                                            {
                                                memcpy(szVal, W2A(bstrValue), size);
                                                URLEncode(szVal, size * 3);
                                                URLAppendQueryPair(lpszQuery, W2A(bstrName), szVal);                
                                                // Cleanup
                                                free(szVal);
                                            }
                                            SysFreeString(bstrName);
                                            SysFreeString(bstrValue);
                                        }
                                    }

                                }
                            }
                        }
                        SysFreeString(bstr);
                        
                    }
                    
                    // Release the interface
                    pOptionButton->Release();
                    continue;
                }                                
                
                // For the rest we need to form Name=Value pairs
                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLButtonElement, (LPVOID*)&pButton )))
                {
                    BSTR    bstrName;
                    BSTR    bstrValue;
                                    
                    if (SUCCEEDED(pButton->get_name(&bstrName)) &&
                        SUCCEEDED(pButton->get_value(&bstrValue)) )
                    {
                        if (bstrValue)
                        {
                            size_t size = sizeof(TCHAR) * (lstrlen(W2A(bstrValue)) + 1 );
                            TCHAR* szVal = (TCHAR*)malloc(size * 3);
                            if (szVal)
                            {
                                memcpy(szVal, W2A(bstrValue), size);
                                URLEncode(szVal, size * 3);
                                URLAppendQueryPair(lpszQuery, W2A(bstrName), szVal);                
                                // Cleanup
                                free(szVal);
                            }
                            SysFreeString(bstrName);
                            SysFreeString(bstrValue);
                        }
                    }
                    
                    // Release the interface pointer                    
                    pButton->Release();
                    continue;
                }
                
                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLInputFileElement, (LPVOID*)&pInputFile )))
                {
                    BSTR    bstrName;
                    BSTR    bstrValue;
                                    
                    if (SUCCEEDED(pInputFile->get_name(&bstrName)) &&
                        SUCCEEDED(pInputFile->get_value(&bstrValue)) )
                    {
                        if (bstrValue)
                        {
                            size_t size = sizeof(TCHAR)*(lstrlen(W2A(bstrValue)) + 1);
                            TCHAR* szVal = (TCHAR*)malloc(size * 3);
                            if (szVal)
                            {
                                memcpy(szVal, W2A(bstrValue), size);
                                URLEncode(szVal, size * 3);
                                URLAppendQueryPair(lpszQuery, W2A(bstrName), szVal);                
                                // Cleanup
                                free(szVal);
                            }
                            SysFreeString(bstrName);
                            SysFreeString(bstrValue);
                        }
                    }
                    
                    // Release the interface pointer                    
                    pInputFile->Release();
                    continue;
                }
                
                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLInputHiddenElement, (LPVOID*)&pInputHidden )))
                {
                    BSTR    bstrName;
                    BSTR    bstrValue;
                                    
                    if (SUCCEEDED(pInputHidden->get_name(&bstrName)) &&
                        SUCCEEDED(pInputHidden->get_value(&bstrValue)) )
                    {
                        if (bstrValue)
                        {
                            size_t size = sizeof(TCHAR)*(lstrlen(W2A(bstrValue)) + 1);
                            TCHAR* szVal = (TCHAR*)malloc(size * 3);
                            if (szVal)
                            {
                                memcpy(szVal, W2A(bstrValue), size);
                                URLEncode(szVal, size * 3);
                                URLAppendQueryPair(lpszQuery, W2A(bstrName), szVal);                
                                // Cleanup
                                free(szVal);
                            }
                            SysFreeString(bstrName);
                            SysFreeString(bstrValue);
                        }
                    }
                    
                    // Release the interface pointer                    
                    pInputHidden->Release();
                    continue;
                }

                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLInputTextElement, (LPVOID*)&pInputText )))
                {
                    BSTR    bstrName;
                    BSTR    bstrValue;
                                    
                    if (SUCCEEDED(pInputText->get_name(&bstrName)) &&
                        SUCCEEDED(pInputText->get_value(&bstrValue)) )
                    {
                        if (bstrValue)
                        {
                            size_t size = sizeof(TCHAR)*(lstrlen(W2A(bstrValue)) + 1);
                            TCHAR* szVal = (TCHAR*)malloc(size * 3);
                            if (szVal)
                            {
                                memcpy(szVal, W2A(bstrValue), size);
                                URLEncode(szVal, size * 3);
                                URLAppendQueryPair(lpszQuery, W2A(bstrName), szVal);                
                                // Cleanup
                                free(szVal);
                            }
                            SysFreeString(bstrName);
                            SysFreeString(bstrValue);
                        }
                    }
                    
                    // Release the interface pointer                    
                    pInputText->Release();
                    continue;
                }

                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLSelectElement, (LPVOID*)&pSelect )))
                {
                    BSTR    bstrName;
                    BSTR    bstrValue;
                                    
                    if (SUCCEEDED(pSelect->get_name(&bstrName)) &&
                        SUCCEEDED(pSelect->get_value(&bstrValue)) )
                    {
                        if (bstrValue)
                        {
                            size_t size = sizeof(TCHAR)*(lstrlen(W2A(bstrValue)) + 1);
                            TCHAR* szVal = (TCHAR*)malloc(size * 3);
                            if (szVal)
                            {
                                memcpy(szVal, W2A(bstrValue), size);
                                URLEncode(szVal, size * 3);
                                URLAppendQueryPair(lpszQuery, W2A(bstrName), szVal);                
                                // Cleanup
                                free(szVal);
                            }
                            SysFreeString(bstrName);
                            SysFreeString(bstrValue);
                        }
                    }
                    
                    // Release the interface pointer                    
                    pSelect->Release();
                    continue;
                }

                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLTextAreaElement, (LPVOID*)&pTextArea )))
                {
                    BSTR    bstrName;
                    BSTR    bstrValue;
                                    
                    if (SUCCEEDED(pTextArea->get_name(&bstrName)) &&
                        SUCCEEDED(pTextArea->get_value(&bstrValue)) )
                    {
                         if (bstrValue)
                        {
                            size_t size = sizeof(TCHAR)*(lstrlen(W2A(bstrValue)) + 1);
                            TCHAR* szVal = (TCHAR*)malloc(size * 3);
                            if (szVal)
                            {
                                memcpy(szVal, W2A(bstrValue), size);
                                URLEncode(szVal, size * 3);
                                URLAppendQueryPair(lpszQuery, W2A(bstrName), szVal);                
                                // Cleanup
                                free(szVal);
                            }
                            SysFreeString(bstrName);
                            SysFreeString(bstrValue);
                        }
                    }
                    
                    // Release the interface pointer                    
                    pTextArea->Release();
                }
                pDisp->Release();
            }                
        }
    }
    
    // Null out the last Ampersand, since we don't know when we added the last pair, so we got
    // a trailing ampersand
    lpszQuery[lstrlen(lpszQuery)-1] = '\0';
    
    return S_OK;
}

HRESULT CWalker::get_FirstFormQueryString
(
    LPTSTR  lpszQuery
)
{
    HRESULT                 hr;
    IHTMLElementCollection  *pColl = NULL;
    BOOL                    bDone = FALSE;

    assert(m_pMSHTML);
    if (!m_pMSHTML)
    {
        return E_UNEXPECTED;
    }

    // retrieve a reference to the ALL collection
    if (SUCCEEDED(hr = m_pMSHTML->get_all( &pColl )))
    {
        long cElems;

        assert(pColl);

        // retrieve the count of elements in the collection
        if (SUCCEEDED(hr = pColl->get_length( &cElems )))
        {
            // for each element retrieve properties such as TAGNAME and HREF
            for ( int i=0; (i<cElems) && !bDone; i++ )
            {
                VARIANT vIndex;
                vIndex.vt = VT_UINT;
                vIndex.lVal = i;
                VARIANT var2 = { 0 };
                LPDISPATCH pDisp; 

                if (SUCCEEDED(hr = pColl->item( vIndex, var2, &pDisp )))
                {
                    // Look for <FORM> tags
                    IHTMLFormElement* pForm = NULL;
                    if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLFormElement, (LPVOID*)&pForm )))
                    {
                        assert(pForm);
                        
                        if (SUCCEEDED(getQueryString(pForm, lpszQuery)))
                        {
                            hr = ERROR_SUCCESS;
                        }   
                        else
                        {
                            hr = E_FAIL;
                        }
                        
                        pForm->Release();
                        bDone = TRUE;
                    }
                    pDisp->Release();
                }
            }
        }
        pColl->Release();
    }                                                                                

    // If we fall out of the loop, that is bad, so return a failure code
    if (!bDone)
        hr = E_FAIL;
    
    return (hr);    
}

// For the URL for the next page
HRESULT CWalker::get_URL
(        
    LPTSTR  lpszURL,
    BOOL    bForward
)
{

    HRESULT             hr = S_OK;
    BSTR                bstrURL;
    TCHAR               szQuery[INTERNET_MAX_URL_LENGTH];
    IHTMLFormElement    * pForm =  bForward ? get_pNextForm() : get_pBackForm();
        
    if (!pForm)
        return (E_FAIL);
        
                                                    
    // Get the Action for the Next Form
    hr = pForm->get_action(&bstrURL);
    if (SUCCEEDED(hr))
    {
        memset(szQuery, 0, sizeof(szQuery));
        lstrcpy(szQuery, cszQuestion);
    
        // Get the Query String
        if (SUCCEEDED(getQueryString(pForm, szQuery)))
        {
            // Catenate the two together into the dest buffer
            lstrcpy(lpszURL, W2A(bstrURL));
            lstrcat(lpszURL, szQuery);
        }   
        
        SysFreeString(bstrURL);            
    }    
    
    return hr;
}

HRESULT CWalker::get_IeakIspFile(LPTSTR lpszIspFile)
{
    ASSERT(m_pMSHTML);

    IHTMLElementCollection* pColl = NULL;

    // retrieve a reference to the ALL collection
    if (SUCCEEDED(m_pMSHTML->get_all( &pColl )))
    {
        LPDISPATCH pDisp   = NULL; 
        VARIANT    varName;
        VARIANT    varIdx;

        VariantInit(&varName);
        V_VT(&varName)  = VT_BSTR;
        varName.bstrVal = A2W(HARDCODED_IEAK_ISPFILE_ELEMENT_ID);
        varIdx.vt       = VT_UINT;
        varIdx.lVal     = 0;

        if (SUCCEEDED(pColl->item(varName, varIdx, &pDisp)) && pDisp)
        {
            IHTMLElement* pElement = NULL;
            if (SUCCEEDED(pDisp->QueryInterface(IID_IHTMLElement, (void**)&pElement)))
            {
                BSTR bstrVal;
                if (SUCCEEDED(pElement->get_innerHTML(&bstrVal)))
                {
                    lstrcpy(lpszIspFile, W2A(bstrVal));
                    SysFreeString(bstrVal);
                }
                pElement->Release();
            }    
            pDisp->Release();
        }
        pColl->Release();
    }
    return S_OK;
}


void CWalker::GetInputValue
(
    LPTSTR              lpszName, 
    BSTR                *pVal,
    UINT                index,
    IHTMLFormElement    *pForm
)
{
    VARIANT varName;
    VariantInit(&varName);
    V_VT(&varName) = VT_BSTR;
    varName.bstrVal = A2W(lpszName);

    VARIANT varIdx;
    varIdx.vt = VT_UINT;
    varIdx.lVal = index;

    LPDISPATCH pDispElt = NULL; 
    // Get the IDispatch for the named element, from the collection of elements in the
    // passed in form object.
    if (SUCCEEDED(pForm->item(varName, varIdx, &pDispElt)) && pDispElt)
    {
        IHTMLInputElement *pInput = NULL;
        // Get the HTMLInputElement interface, so we can get the value associated with
        // this element
        if (SUCCEEDED(pDispElt->QueryInterface(IID_IHTMLInputElement,(LPVOID*) &pInput)) && pInput)
        {
            pInput->get_value(pVal);
            pInput->Release();
        }
        pDispElt->Release();
    }
}

// Grovel through the OLS HTML and update the registry, and make any desktop shortcuts
HRESULT CWalker::ProcessOLSFile(IWebBrowser2* lpWebBrowser)
{   
    LPDISPATCH      pDisp; 
    
    // Get the document pointer from this webbrowser.
    if (SUCCEEDED(lpWebBrowser->get_Document(&pDisp)))  
    {
         // Call might succeed but that dosen't guarantee a valid ptr
        if(pDisp)
        {
            IHTMLDocument2* pDoc;
            if (SUCCEEDED(pDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc)))
            {
                IHTMLElementCollection* pColl = NULL;
                // retrieve a reference to the ALL collection
                if (SUCCEEDED(pDoc->get_all( &pColl )))
                {
                    long cElems;
                    assert(pColl);

                    // retrieve the count of elements in the collection
                    if (SUCCEEDED(pColl->get_length( &cElems )))
                    {
                        VARIANT vIndex;
                        vIndex.vt = VT_UINT;
                        VARIANT var2 = { 0 };
                        
                        for ( int i=0; i<cElems; i++ )
                        {
                            vIndex.lVal = i;
                            LPDISPATCH pElementDisp; 

                            if (SUCCEEDED(pColl->item( vIndex, var2, &pElementDisp )))
                            {
                                IHTMLFormElement* pForm = NULL;
                                if (SUCCEEDED(pElementDisp->QueryInterface( IID_IHTMLFormElement, (LPVOID*)&pForm )))
                                {
                                    BSTR        bstrName = NULL;
                                    
                                    // Get the name of the form, and see if it is the regEntries form
                                    if (SUCCEEDED(pForm->get_name(&bstrName)))
                                    {
                                        if (lstrcmpi(W2A(bstrName), cszOLSRegEntries) == 0)
                                        {
                                            BSTR    bstrAction = NULL;                                        
                                            // The Action value for this form contains the number of
                                            // reg entries we need to process
                                            if (SUCCEEDED(pForm->get_action(&bstrAction)))
                                            {
                                                int iNumEntries  = _ttoi(W2A(bstrAction));
                                                for (int x = 0; x < iNumEntries; x++)
                                                {
                                                    BSTR    bstrKeyName = NULL;
                                                    BSTR    bstrEntryName = NULL;
                                                    BSTR    bstrEntryValue = NULL;
                                                    HKEY    hkey;
                                                    HKEY    hklm;
                                                                                                        
                                                    // For each entry we need to get the
                                                    // following values:
                                                    // KeyName, EntryName, EntryValue
                                                    GetInputValue((LPTSTR)cszKeyName, &bstrKeyName, x, pForm);
                                                    GetInputValue((LPTSTR)cszEntryName, &bstrEntryName, x, pForm);
                                                    GetInputValue((LPTSTR)cszEntryValue, &bstrEntryValue, x, pForm);
                                                    
                                                    if (bstrKeyName && bstrEntryName && bstrEntryValue)
                                                    {
                                                        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                                                         NULL,
                                                                         0,
                                                                         KEY_ALL_ACCESS,
                                                                         &hklm) == ERROR_SUCCESS)
                                                        {
                                                                    
                                                            DWORD dwDisposition;
                                                            if (ERROR_SUCCESS == RegCreateKeyEx(hklm,
                                                                                                W2A(bstrKeyName),
                                                                                                0,
                                                                                                NULL,
                                                                                                REG_OPTION_NON_VOLATILE, 
                                                                                                KEY_ALL_ACCESS, 
                                                                                                NULL, 
                                                                                                &hkey, 
                                                                                                &dwDisposition))
                                                            {
                                                                LPTSTR   lpszValue = W2A(bstrEntryValue);
                                                                RegSetValueEx(hkey,
                                                                              W2A(bstrEntryName),
                                                                              0,
                                                                              REG_SZ,
                                                                              (LPBYTE) lpszValue,
                                                                              sizeof(TCHAR)*(lstrlen(lpszValue)+1));

                                                                RegCloseKey(hkey);
                                                            }       
                                                            RegCloseKey(hklm);
                                                        }        
                                                                                    
                                                        SysFreeString(bstrKeyName);
                                                        SysFreeString(bstrEntryName);
                                                        SysFreeString(bstrEntryValue);
                                                    }                                        
                                                }
                                                SysFreeString(bstrAction);
                                            }
                                        }
                                        else if (lstrcmpi(W2A(bstrName), cszOLSDesktopShortcut) == 0)
                                        {
                                            // Need to create a desktop shortcut
                                            BSTR    bstrSourceName = NULL;
                                            BSTR    bstrTargetName = NULL;
                                                                                                        
                                            // For each entry we need to get the
                                            // following values:
                                            // KeyName, EntryName, EntryValue
                                            GetInputValue((LPTSTR)cszSourceName, &bstrSourceName, 0, pForm);
                                            GetInputValue((LPTSTR)cszTargetName, &bstrTargetName, 0, pForm);
                                                    
                                            if (bstrSourceName && bstrTargetName)
                                            {
                                                TCHAR           szLinkPath[MAX_PATH];
                                                TCHAR           szDestPath[MAX_PATH];
                                                LPITEMIDLIST    lpItemDList = NULL;
                                                IMalloc         *pMalloc = NULL;
                                                   
                                                // Get a reference to the shell allocator
                                                if (SUCCEEDED (SHGetMalloc (&pMalloc)))
                                                {
                                                    if (SUCCEEDED(SHGetSpecialFolderLocation( NULL, CSIDL_PROGRAMS, &lpItemDList)))
                                                    {
                                                    
                                                        SHGetPathFromIDList(lpItemDList, szLinkPath);
                                                        lstrcat(szLinkPath, TEXT("\\"));
                                                        lstrcat(szLinkPath, W2A(bstrSourceName));
                                                        
                                                        pMalloc->Free (lpItemDList);
                                                        lpItemDList = NULL;
                                                        // Form the name where we will copy to
                                                        if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOP,&lpItemDList)))
                                                        {
                                                            SHGetPathFromIDList(lpItemDList, szDestPath);
                                                            pMalloc->Free (lpItemDList);
                                                        
                                                            lstrcat(szDestPath, TEXT("\\"));
                                                            lstrcat(szDestPath, W2A(bstrTargetName));
                                                            
                                                            CopyFile(szLinkPath, szDestPath, FALSE);
                                                        }
                                                    }
                                                    // Release the allocator
                                                    pMalloc->Release ();
                                                }
                                                SysFreeString(bstrSourceName);
                                                SysFreeString(bstrTargetName);
                                            }
                                        }
                                        
                                        SysFreeString(bstrName);
                                    }   
                                    pForm->Release();                                     
                                }
                                pElementDisp->Release();
                            } // item
                        } // for
                    } // get_length
                    pColl->Release();
                } // get_all
                pDoc->Release();
            }
            pDisp->Release();
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\cfgapi.h ===
//*******************************************************************
//
//  Copyright(c) Microsoft Corporation, 1996
//
//  FILE: CFGAPI.H
//
//  PURPOSE:  Contains API's exported from icfg32.dll and structures
//            required by those functions. 
//
//*******************************************************************

#ifndef _CFGAPI_H_
#define _CFGAPI_H_

// Maximum buffer size for error messages.
#define MAX_ERROR_TEXT  512

// Flags for dwfOptions

// install TCP (if needed)
#define ICFG_INSTALLTCP            0x00000001

// install RAS (if needed)
#define ICFG_INSTALLRAS            0x00000002

// install exchange and internet mail
#define ICFG_INSTALLMAIL           0x00000004

//
// ChrisK 5/8/97
// Note: the next three switches are only valid for IcfgNeedInetComponet
// check to see if a LAN adapter with TCP bound is installed
//
#define ICFG_INSTALLLAN            0x00000008

//
// Check to see if a DIALUP adapter with TCP bound is installed
//
#define ICFG_INSTALLDIALUP         0x00000010

//
// Check to see if TCP is installed
//
#define ICFG_INSTALLTCPONLY        0x00000020

// DRIVERTYPE_ defines for TCP/IP configuration apis
#define DRIVERTYPE_NET  0x0001
#define DRIVERTYPE_PPP  0x0002


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


//*******************************************************************
//
//  FUNCTION:   IcfgNeedInetComponents
//
//  PURPOSE:    Detects whether the specified system components are
//              installed or not.
//
//  PARAMETERS: dwfOptions - a combination of ICFG_ flags that specify
//              which components to detect as follows:
//
//                ICFG_INSTALLTCP - is TCP/IP needed?
//                ICFG_INSTALLRAS - is RAS needed?
//                ICFG_INSTALLMAIL - is exchange or internet mail needed?
//
//              lpfNeedComponents - TRUE if any specified component needs
//              to be installed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgNeedInetComponents(DWORD dwfOptions, LPBOOL lpfNeedComponents);


//*******************************************************************
//
//  FUNCTION:   IcfgInstallInetComponents
//
//  PURPOSE:    Install the specified system components.
//
//  PARAMETERS: hwndParent - Parent window handle.
//              dwfOptions - a combination of ICFG_ flags that controls
//              the installation and configuration as follows:
//
//                ICFG_INSTALLTCP - install TCP/IP (if needed)
//                ICFG_INSTALLRAS - install RAS (if needed)
//                ICFG_INSTALLMAIL - install exchange and internet mail
//              
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgInstallInetComponents(HWND hwndParent, DWORD dwfOptions,
  LPBOOL lpfNeedsRestart);


//*******************************************************************
//
//  FUNCTION:   IcfgGetLastInstallErrorText
//
//  PURPOSE:    Get a text string that describes the last installation
//              error that occurred.  The string should be suitable
//              for display in a message box with no further formatting.
//
//  PARAMETERS: lpszErrorDesc - points to buffer to receive the string.
//              cbErrorDesc - size of buffer.
//
//  RETURNS:    The length of the string returned.
//
//*******************************************************************

DWORD WINAPI IcfgGetLastInstallErrorText(LPSTR lpszErrorDesc, DWORD cbErrorDesc);


//*******************************************************************
//
//  FUNCTION:   IcfgSetInstallSourcePath
//
//  PURPOSE:    Sets the path where windows looks when installing files.
//
//  PARAMETERS: lpszSourcePath - full path of location of files to install.
//              If this is NULL, default path is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgSetInstallSourcePath(LPCSTR lpszSourcePath);


//*******************************************************************
//              
//  FUNCTION:   IcfgIsGlobalDNS
//
//  PURPOSE:    Determines whether there is Global DNS set.
//
//  PARAMETERS: lpfGlobalDNS - TRUE if global DNS is set, FALSE otherwise.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and 
//              should always return ERROR_SUCCESS and set lpfGlobalDNS
//              to FALSE in Windows NT.
//
//*******************************************************************

HRESULT WINAPI IcfgIsGlobalDNS(LPBOOL lpfGlobalDNS);


//*******************************************************************
//
//  FUNCTION:   IcfgRemoveGlobalDNS
//
//  PURPOSE:    Removes global DNS info from registry.
//
//  PARAMETERS: None.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and 
//              should always return ERROR_SUCCESS in Windows NT.
//
//*******************************************************************

HRESULT WINAPI IcfgRemoveGlobalDNS(void);


//*******************************************************************
//
//  FUNCTION:   IcfgIsFileSharingTurnedOn
//
//  PURPOSE:    Determines if file server (VSERVER) is bound to TCP/IP
//              for specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to check server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP        - PPPMAC
//
//              lpfSharingOn - TRUE if bound once or more, FALSE if not bound
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgIsFileSharingTurnedOn(DWORD dwfDriverType, LPBOOL lpfSharingOn);


//*******************************************************************
//
//  FUNCTION:   IcfgTurnOffFileSharing
//
//  PURPOSE:    Unbinds file server (VSERVER) from TCP/IP for 
//              specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to remove server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP        - PPPMAC
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgTurnOffFileSharing(DWORD dwfDriverType, HWND hwndParent);



VOID   GetSETUPXErrorText(DWORD dwErr,LPSTR pszErrorDesc,DWORD cbErrorDesc);
RETERR DoGenInstall(HWND hwndParent,LPCSTR lpszInfFile,LPCSTR lpszInfSect);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //_CFGAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\helpids.h ===
/* Help ID mapping for Internet Connection Wizard Help topics */
/* Help file = connect.hlp */
/* Last saved 4/28/97 a-cynthw */

#define ICW_OVERVIEW            1000
#define icw_trb                 1001
#define ICW_TRB                 1001
#define ICW_SETUP_OPTIONS       1010
#define ICW_USE_EXISTING        1020
#define ICW_SETUP_AUTOMATIC     1030
#define ICW_LOCATION_INFO       1040
#define ICW_CHOOSE_NUMBER       1045
#define ICW_CONNECTING          1050
#define ICW_SETUP_MANUAL        1070
#define ICW_DIALUP_CONNECTION   1080
#define ICW_DIALUP_NAME         1090
#define ICW_PHONE_NUMBER        2000
#define ICW_NAME_PASSWORD       2010
#define ICW_ADVANCED            2020
#define ICW_CONNECTION_TYPE     2030
#define ICW_LOGON_PROCEDURE     2040
#define ICW_IP_ADDRESS          2050
#define ICW_DNS_ADDRESS         2060
#define ICW_LCP_EXTENSIONS      2070
#define ICW_DIALUP_SETTINGS     2080
#define ICW_USE_PROXY           2090
#define ICW_PROXY_SERVERS       3000
#define ICW_PROXY_EXCEPTIONS    3010
#define ICW_CHOOSE_MODEM        3020
#define ICW_COMPLETE            3030
#define ICW_SETUP_PROXY         3040
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\debug.h ===
//====== Assertion/Debug output APIs =================================

#undef CDECL
#define CDECL   _cdecl

#if defined(DECLARE_DEBUG) && defined(DEBUG)

//
// Declare module-specific debug strings
//
//   When including this header in your private header file, do not
//   define DECLARE_DEBUG.  But do define DECLARE_DEBUG in one of the
//   source files in your project, and then include this header file.
//
//   You may also define the following:
//
//      SZ_DEBUGINI     - the .ini file used to set debug flags
//      SZ_DEBUGSECTION - the section in the .ini file specific to
//                        the module component.
//      SZ_MODULE       - ansi version of the name of your module.
//
//

// (These are deliberately CHAR)
EXTERN_C const CHAR FAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR FAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;

EXTERN_C const WCHAR FAR c_wszTrace[] = L"t " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszErrorDbg[] = L"err " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszWarningDbg[] = L"wn " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszAssertMsg[] = TEXTW(SZ_MODULE) L"  Assert: ";
EXTERN_C const WCHAR FAR c_wszAssertFailed[] = TEXTW(SZ_MODULE) L"  Assert %s, line %d: (%s)\r\n";

// (These are deliberately CHAR)
EXTERN_C const CHAR  FAR c_szTrace[] = "t " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szErrorDbg[] = "err " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szWarningDbg[] = "wn " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szAssertMsg[] = SZ_MODULE "  Assert: ";
EXTERN_C const CHAR  FAR c_szAssertFailed[] = SZ_MODULE "  Assert %s, line %d: (%s)\r\n";

#endif  // DECLARE_DEBUG && DEBUG

#if defined(DECLARE_DEBUG) && defined(PRODUCT_PROF)
EXTERN_C const CHAR FAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR FAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;
#endif



#ifdef __cplusplus
extern "C" {
#endif

#if !defined(DECLARE_DEBUG)

//
// Debug macros and validation code
//

#undef Assert
#undef AssertE
#undef AssertMsg
#undef AssertStrLen
#undef DebugMsg
#undef FullDebugMsg
#undef ASSERT
#undef EVAL

// Access these globals to determine which debug flags are set.
// These globals are modified by CcshellGetDebugFlags(), which
// reads an .ini file and sets the appropriate flags.
//
//   g_dwDumpFlags  - bits are application specific.  Typically 
//                    used for dumping structures.
//   g_dwBreakFlags - uses BF_* flags.  The remaining bits are
//                    application specific.  Used to determine
//                    when to break into the debugger.
//   g_dwTraceFlags - uses TF_* flags.  The remaining bits are
//                    application specific.  Used to display
//                    debug trace messages.
//   g_dwFuncTraceFlags - bits are application specific.  When
//                    TF_FUNC is set, CcshellFuncMsg uses this
//                    value to determine which function traces
//                    to display.
//   g_dwProtoype   - bits are application specific.  Use it for
//                    anything.
//   g_dwProfileCAP - bits are application specific. Used to
//                    control ICECAP profiling. 
//

extern DWORD g_dwDumpFlags;
extern DWORD g_dwBreakFlags;
extern DWORD g_dwTraceFlags;
#ifdef DEBUG
extern DWORD g_dwPrototype;
#else
#define g_dwPrototype   0
#endif
extern DWORD g_dwFuncTraceFlags;

#if defined(DEBUG) || defined(PRODUCT_PROF)
BOOL CcshellGetDebugFlags(void);
#else
#define CcshellGetDebugFlags()  0
#endif

// Break flags for g_dwBreakFlags
#define BF_ONVALIDATE       0x00000001      // Break on assertions or validation
#define BF_ONAPIENTER       0x00000002      // Break on entering an API
#define BF_ONERRORMSG       0x00000004      // Break on TF_ERROR
#define BF_ONWARNMSG        0x00000008      // Break on TF_WARNING

// Trace flags for g_dwTraceFlags
#define TF_ALWAYS           0xFFFFFFFF
#define TF_NEVER            0x00000000
#define TF_WARNING          0x00000001
#define TF_ERROR            0x00000002
#define TF_GENERAL          0x00000004      // Standard messages
#define TF_FUNC             0x00000008      // Trace function calls
// (Upper 28 bits reserved for custom use per-module)

// Old, archaic debug flags.  
// BUGBUG (scotth): the following flags will be phased out over time.
#ifdef DM_TRACE
#undef DM_TRACE
#undef DM_WARNING
#undef DM_ERROR
#endif
#define DM_TRACE            TF_GENERAL      // OBSOLETE Trace messages
#define DM_WARNING          TF_WARNING      // OBSOLETE Warning
#define DM_ERROR            TF_ERROR        // OBSOLETE Error


// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)      /* ;Internal */ \
    static const TCHAR sz[] = msg;


#ifndef NOSHELLDEBUG    // Others have own versions of these.
#ifdef DEBUG

#ifdef WIN16
#define DEBUG_BREAK         { _asm int 3 }
#else
#ifdef _X86_
// Use int 3 so we stop immediately in the source
#define DEBUG_BREAK        { _asm int 3 }
#else
#define DEBUG_BREAK        DebugBreak();
#endif
#endif
// Prototypes for debug functions

void CcshellStackEnter(void);
void CcshellStackLeave(void);

BOOL CDECL CcshellAssertFailedA(LPCSTR szFile, int line, LPCSTR pszEval, BOOL bBreak);
BOOL CDECL CcshellAssertFailedW(LPCWSTR szFile, int line, LPCWSTR pwszEval, BOOL bBreak);

void CDECL CcshellDebugMsgW(DWORD mask, LPCWSTR pszMsg, ...);
void CDECL CcshellDebugMsgA(DWORD mask, LPCSTR  pszMsg, ...);
void CDECL CcshellFuncMsgW(DWORD mask, LPCWSTR pszMsg, ...);
void CDECL CcshellFuncMsgA(DWORD mask, LPCSTR  pszMsg, ...);
void CDECL CcshellAssertMsgW(BOOL bAssert, LPCWSTR pszMsg, ...);
void CDECL CcshellAssertMsgA(BOOL bAssert, LPCSTR  pszMsg, ...);

void CDECL _AssertMsgA(BOOL f, LPCSTR pszMsg, ...);
void CDECL _AssertMsgW(BOOL f, LPCWSTR pszMsg, ...);
void CDECL _DebugMsgA(DWORD flag, LPCSTR psz, ...);
void CDECL _DebugMsgW(DWORD flag, LPCWSTR psz, ...);

void _AssertStrLenA(LPCSTR pszStr, int iLen);
void _AssertStrLenW(LPCWSTR pwzStr, int iLen);


#ifdef UNICODE
#define CcshellAssertFailed     CcshellAssertFailedW
#define CcshellDebugMsg         CcshellDebugMsgW
#define CcshellFuncMsg          CcshellFuncMsgW
#define CcshellAssertMsg        CcshellAssertMsgW
#define _AssertMsg              _AssertMsgW
#define _AssertStrLen           _AssertStrLenW
#define _DebugMsg               _DebugMsgW
#else
#define CcshellAssertFailed     CcshellAssertFailedA
#define CcshellDebugMsg         CcshellDebugMsgA
#define CcshellFuncMsg          CcshellFuncMsgA
#define CcshellAssertMsg        CcshellAssertMsgA
#define _AssertMsg              _AssertMsgA
#define _AssertStrLen           _AssertStrLenA
#define _DebugMsg               _DebugMsgA
#endif



// Explanation of debug macros:
//
// ----
// Assert(f)
// ASSERT(f)
//
//   Generates a "Assert file.c, line x (eval)" message if f is NOT true.
//   The g_dwBreakFlags global governs whether the function DebugBreaks.
//
// ----
// AssertE(f)
//
//   Works like Assert, except (f) is also executed in the retail 
//   version as well.
//
// ----
// EVAL(f)
//
//   Evaluates the expression (f).  The expression is always evaluated,
//   even in retail builds.  But the macro only asserts in the debug
//   build.  This macro may only be used on logical expressions, eg:
//
//          if (EVAL(exp))
//              // do something
//
// ----
// TraceMsg(mask, sz, args...) 
//
//   Generate wsprintf-formatted msg using specified trace mask.  
//   The g_dwTraceFlags global governs whether message is displayed.
//
//   The sz parameter is always ANSI; TraceMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
// ----
// DebugMsg(mask, sz, args...) 
//
//   OBSOLETE!  
//   Like TraceMsg, except you must wrap the sz parameter with TEXT().
//
// ----
// AssertMsg(bAssert, sz, args...)
//
//   Generate wsprintf-formatted msg if the assertion is false.  
//   The g_dwBreakFlags global governs whether the function DebugBreaks.
//
//   The sz parameter is always ANSI; AssertMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//


#define ASSERT(f)                                 \
    {                                             \
        DEBUGTEXT(szFile, TEXT(__FILE__));              \
        if (!(f) && CcshellAssertFailed(szFile, __LINE__, TEXT(#f), FALSE)) \
            DEBUG_BREAK;       \
    }

#ifdef DISALLOW_Assert
#define Assert(f)        Dont_use_Assert___Use_ASSERT
#else
#define Assert(f)           ASSERT(f)
#endif


#define AssertE(f)          ASSERT(f)
#define EVAL(exp)   \
    ((exp) || (CcshellAssertFailed(TEXT(__FILE__), __LINE__, TEXT(#exp), TRUE), 0))

// Use TraceMsg instead of DebugMsg.  DebugMsg is obsolete.
#define AssertMsg           _AssertMsg
#define AssertStrLen        _AssertStrLen
#define AssertStrLenA       _AssertStrLenA
#define AssertStrLenW       _AssertStrLenW

#ifdef DISALLOW_DebugMsg
#define DebugMsg            Dont_use_DebugMsg___Use_TraceMsg
#else
#define DebugMsg            _DebugMsg
#endif

#ifdef FULL_DEBUG
#define FullDebugMsg        _DebugMsg
#else
#define FullDebugMsg        1 ? (void)0 : (void)
#endif

#define Dbg_SafeStrA(psz)   (SAFECAST(psz, LPCSTR), (psz) ? (psz) : "NULL string")
#ifndef WIN16
#define Dbg_SafeStrW(psz)   (SAFECAST(psz, LPCWSTR), (psz) ? (psz) : L"NULL string")
#else
#define Dbg_SafeStrW(psz)   (SAFECAST(psz, LPCWSTR), (psz) ? (psz) : TEXT("NULL string"))
#endif
#ifdef UNICODE
#define Dbg_SafeStr         Dbg_SafeStrW
#else
#define Dbg_SafeStr         Dbg_SafeStrA
#endif

#define ASSERT_MSGW         CcshellAssertMsgW
#define ASSERT_MSGA         CcshellAssertMsgA
#define ASSERT_MSG          CcshellAssertMsg

#define TraceMsgW           CcshellDebugMsgW
#define TraceMsgA           CcshellDebugMsgA
#define TraceMsg            CcshellDebugMsg

#define FUNC_MSG            CcshellFuncMsg

// Debug function enter


// DBG_ENTER(flag, fn)  -- Generates a function entry debug spew for
//                          a function
//
#define DBG_ENTER(flagFTF, fn)                  \
        (FUNC_MSG(flagFTF, " > " #fn "()"), \
         CcshellStackEnter())

// DBG_ENTER_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function entry debug
//                          spew for functions that accept <type>.
//
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (FUNC_MSG(flagFTF, " < " #fn "(..., %s, ...)", (LPCTSTR)pfnStrFromType(dw)), \
         CcshellStackEnter())

// DBG_ENTER_SZ(flag, fn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(flagFTF, fn, sz)                  \
        (FUNC_MSG(flagFTF, " > " #fn "(..., \"%s\",...)", Dbg_SafeStr(sz)), \
         CcshellStackEnter())


// Debug function exit


// DBG_EXIT(flag, fn)  -- Generates a function exit debug spew
//
#define DBG_EXIT(flagFTF, fn)                              \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "()"))

// DBG_EXIT_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function exit debug
//                          spew for functions that return <type>.
//
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (LPCTSTR)pfnStrFromType(dw)))

// DBG_EXIT_INT(flag, fn, us)  -- Generates a function exit debug spew for
//                          functions that return an INT.
//
#define DBG_EXIT_INT(flagFTF, fn, n)                       \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %d", (int)(n)))

// DBG_EXIT_BOOL(flag, fn, b)  -- Generates a function exit debug spew for
//                          functions that return a boolean.
//
#define DBG_EXIT_BOOL(flagFTF, fn, b)                      \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (b) ? (LPTSTR)TEXT("TRUE") : (LPTSTR)TEXT("FALSE")))

// DBG_EXIT_UL(flag, fn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %#08lx", (ULONG)(ul)))

#define DBG_EXIT_DWORD      DBG_EXIT_UL

// DBG_EXIT_HRES(flag, fn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(flagFTF, fn, hres)     DBG_EXIT_TYPE(flagFTF, fn, hres, Dbg_GetHRESULTName)



#else   // DEBUG


#define Assert(f)
#define AssertE(f)      (f)
#define ASSERT(f)
#define AssertMsg       1 ? (void)0 : (void)
#define AssertStrLen(lpStr, iLen)
#define DebugMsg        1 ? (void)0 : (void)
#define FullDebugMsg    1 ? (void)0 : (void)
#define EVAL(exp)       ((exp) != 0)


#define Dbg_SafeStr     1 ? (void)0 : (void)

#define TraceMsgA       1 ? (void)0 : (void)
#define TraceMsgW       1 ? (void)0 : (void)
#ifdef UNICODE
#define TraceMsg        TraceMsgW
#else
#define TraceMsg        TraceMsgA
#endif

#define FUNC_MSG        1 ? (void)0 : (void)

#define ASSERT_MSGA     TraceMsgA
#define ASSERT_MSGW     TraceMsgW
#define ASSERT_MSG      TraceMsg

#define DBG_ENTER(flagFTF, fn)
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfn)
#define DBG_ENTER_SZ(flagFTF, fn, sz)
#define DBG_EXIT(flagFTF, fn)
#define DBG_EXIT_INT(flagFTF, fn, n)
#define DBG_EXIT_BOOL(flagFTF, fn, b)
#define DBG_EXIT_UL(flagFTF, fn, ul)
#define DBG_EXIT_DWORD      DBG_EXIT_UL
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfn)
#define DBG_EXIT_HRES(flagFTF, fn, hres)

#endif  // DEBUG
#endif  // NOSHELLDEBUG


// 
// Debug dump helper functions
//

#ifdef DEBUG

LPCTSTR Dbg_GetCFName(UINT ucf);
LPCTSTR Dbg_GetHRESULTName(HRESULT hr);
LPCTSTR Dbg_GetREFIIDName(REFIID riid);
LPCTSTR Dbg_GetVTName(VARTYPE vt);

#else

#define Dbg_GetCFName(ucf)          (void)0
#define Dbg_GetHRESULTName(hr)      (void)0
#define Dbg_GetREFIIDName(riid)     (void)0
#define Dbg_GetVTName(vt)           (void)0

#endif // DEBUG


// Parameter validation macros
#include "validate.h"

#endif // DECLARE_DEBUG

#ifdef PRODUCT_PROF 
int __stdcall StartCAP(void);   // start profiling
int __stdcall StopCAP(void);    // stop profiling until StartCAP
int __stdcall SuspendCAP(void); // suspend profiling until ResumeCAP
int __stdcall ResumeCAP(void);  // resume profiling
int __stdcall StartCAPAll(void);    // process-wide start profiling
int __stdcall StopCAPAll(void);     // process-wide stop profiling
int __stdcall SuspendCAPAll(void);  // process-wide suspend profiling
int __stdcall ResumeCAPAll(void);   // process-wide resume profiling
void __stdcall MarkCAP(long lMark);  // write mark to MEA
extern DWORD g_dwProfileCAP;
#else
#define StartCAP()      0
#define StopCAP()       0
#define SuspendCAP()    0
#define ResumeCAP()     0
#define StartCAPAll()   0
#define StopCAPAll()    0
#define SuspendCAPAll() 0
#define ResumeCAPAll()  0
#define MarkCAP(n)      0

#define g_dwProfileCAP  0
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\icwacct.h ===
#ifndef _INC_ICWACCT_H
#define _INC_ICWACCT_H

#include "icwcmn.h"

#ifndef MAC

#ifndef APPRENTICE_DEF
#define APPRENTICE_DEF
#define EXTERNAL_DIALOGID_MINIMUM   2000
#define EXTERNAL_DIALOGID_MAXIMUM   3000
typedef enum
    {
    CANCEL_PROMPT = 0,
    CANCEL_SILENT,
    CANCEL_REBOOT
    } CANCELTYPE;
#endif

// {796AD8F0-B2B7-11d0-8D69-00A0C9A06E1F}
DEFINE_GUID(IID_IICWExtension, 0x796ad8f0, 0xb2b7, 0x11d0, 0x8d, 0x69, 0x0, 0xa0, 0xc9, 0xa0, 0x6e, 0x1f);

interface IICWExtension : public IUnknown
    {
    public:
        virtual BOOL STDMETHODCALLTYPE AddExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID) = 0;
        virtual BOOL STDMETHODCALLTYPE RemoveExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID) = 0;
        virtual BOOL STDMETHODCALLTYPE ExternalCancel(CANCELTYPE type) = 0;
        virtual BOOL STDMETHODCALLTYPE SetFirstLastPage(UINT uFirstPageDlgID, UINT uLastPageDlgID) = 0;
    };

typedef enum
    {
    CONNECT_LAN = 0,
    CONNECT_MANUAL,
    CONNECT_RAS
    };

typedef struct tagCONNECTINFO
    {
    DWORD   cbSize;
    DWORD   type;
    char   szConnectoid[MAX_PATH];
    } CONNECTINFO;

// IICWApprentice::Save error values
#define ERR_MAIL_ACCT       0x0001
#define ERR_NEWS_ACCT       0x0002
#define ERR_DIRSERV_ACCT    0x0004

// IICWApprentice::AddWizardPages flags
#define WIZ_NO_MAIL_ACCT    0x0001
#define WIZ_NO_NEWS_ACCT    0x0002
#define WIZ_NO_LDAP_ACCT    0x0004
#define WIZ_USE_WIZARD97    0x0008
#define WIZ_HOST_ICW_LAN    0x0010
#define WIZ_HOST_ICW_PHONE  0x0020
#define WIZ_HOST_ICW_MPHONE 0x0040 // Show multi modem page id necessary

// {1438E820-B6D2-11D0-8D86-00C04FD6202B}
DEFINE_GUID(IID_IICWApprentice, 0x1438E820L, 0xB6D2, 0x11D0, 0x8D, 0x86, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

interface IICWApprentice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize(IICWExtension *pExt) = 0;
        virtual HRESULT STDMETHODCALLTYPE AddWizardPages(DWORD dwFlags) = 0;
        virtual HRESULT STDMETHODCALLTYPE GetConnectionInformation(CONNECTINFO *pInfo) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetConnectionInformation(CONNECTINFO *pInfo) = 0;
        virtual HRESULT STDMETHODCALLTYPE Save(HWND hwnd, DWORD *pdwError) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetPrevNextPage(UINT uPrevPageDlgID, UINT uNextPageDlgID) = 0;
    };

// {ced77e0e-53d7-11d2-9ab6-00a0c9b81d84}
DEFINE_GUID(IID_IICWApprenticeEx, 0xced77e0e, 0x53d7, 0x11d2, 0x9A, 0xB6, 0x00, 0xA0, 0xC9, 0xB8, 0x1D, 0x84);

interface IICWApprenticeEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize               (IICWExtension *pExt)                      = 0;
        virtual HRESULT STDMETHODCALLTYPE AddWizardPages           (DWORD dwFlags)                            = 0;
        virtual HRESULT STDMETHODCALLTYPE GetConnectionInformation (CONNECTINFO *pInfo)                       = 0;
        virtual HRESULT STDMETHODCALLTYPE SetDlgHwnd               (HWND hDlg)                                = 0;
        virtual HRESULT STDMETHODCALLTYPE SetConnectionInformation (CONNECTINFO *pInfo)                       = 0;
        virtual HRESULT STDMETHODCALLTYPE Save                     (HWND hwnd, DWORD *pdwError)               = 0;
        virtual HRESULT STDMETHODCALLTYPE SetPrevNextPage          (UINT uPrevPageDlgID, UINT uNextPageDlgID) = 0;
        virtual HRESULT STDMETHODCALLTYPE ProcessCustomFlags       (DWORD dwFlags)                            = 0;
        virtual HRESULT STDMETHODCALLTYPE SetStateDataFromExeToDll (LPCMNSTATEDATA lpData)                    = 0;
        virtual HRESULT STDMETHODCALLTYPE SetStateDataFromDllToExe (LPCMNSTATEDATA lpData)                    = 0;
    };


// Athena's CLSID
// {1438E821-B6D2-11D0-8D86-00C04FD6202B}
DEFINE_GUID(CLSID_ApprenticeAcctMgr, 0x1438E821L, 0xB6D2, 0x11D0, 0x8D, 0x86, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

//ICW's CLSID
// {8EE42293-C315-11d0-8D6F-00A0C9A06E1F}
DEFINE_GUID(CLSID_ApprenticeICW, 0x8ee42293L, 0xc315, 0x11d0, 0x8d, 0x6f, 0x0, 0xa0, 0xc9, 0xa0, 0x6e, 0x1f);

HRESULT WINAPI CreateAccountsFromFile(LPSTR lpFile, DWORD dwFlags);
HRESULT WINAPI CreateAccountsFromFileEx(LPSTR lpFile, CONNECTINFO *pci, DWORD dwFlags);

#endif  // !MAC
#endif // _INC_ICWACCT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\icwdial.h ===
// ############################################################################
#ifndef WIN16
#include <ras.h>
#endif

#ifndef _ICWDIAL
#define _ICWDIAL
// ############################################################################
typedef HRESULT(WINAPI *PFNSTATUSCALLBACK)(DWORD dwStatus, LPTSTR pszBuffer, DWORD dwBufferSize);

typedef struct tagDIALDLGDATA
{
    DWORD dwSize;
    LPTSTR pszMessage;
    LPTSTR pszRasEntryName;
    LPTSTR pszMultipartMIMEUrl;
    HRASCONN *phRasConn;
    PFNSTATUSCALLBACK pfnStatusCallback;
    HINSTANCE hInst;
    HWND hParentHwnd;
    LPTSTR pszDunFile;
    BOOL bSkipDial;
    RASDIALFUNC1 pfnRasDialFunc1;
}DIALDLGDATA,*PDIALDLGDATA, FAR* LPDIALDLGDATA;

typedef struct tagERRORDLGDATA
{
    DWORD dwSize;
    LPTSTR pszMessage;
    LPTSTR pszRasEntryName;
    LPDWORD pdwCountryID;
    LPWORD pwStateID;
    BYTE bType;
    BYTE bMask;
    LPTSTR pszHelpFile;
    DWORD dwHelpID;
    HINSTANCE hInst;
    HWND hParentHwnd;
    DWORD dwPhonebook;
    LPTSTR pszDunFile;
} ERRORDLGDATA, *PERRORDLGDATA, FAR* LPERRORDLGDATA;

#define WM_RegisterHWND (WM_USER + 1000)
// ############################################################################ 
#ifdef WIN16
extern "C" HRESULT WINAPI __export ICWGetRasEntry(LPRASENTRY *ppRasEntry, LPDWORD lpdwRasEntrySize, LPRASDEVINFO *ppDevInfo, LPDWORD lpdwDevInfoSize, LPTSTR pszEntryName);
extern "C" HRESULT WINAPI __export DialingDownloadDialog(PDIALDLGDATA pDD);
extern "C" HRESULT WINAPI __export DialingErrorDialog(PERRORDLGDATA pED);
#else
extern "C"  HRESULT WINAPI ICWGetRasEntry(LPRASENTRY *ppRasEntry, LPDWORD lpdwRasEntrySize, LPRASDEVINFO *ppDevInfo, LPDWORD lpdwDevInfoSize, LPTSTR pszEntryName);
extern "C"  HRESULT WINAPI DialingDownloadDialog(PDIALDLGDATA pDD);
extern "C"  HRESULT WINAPI DialingErrorDialog(PERRORDLGDATA pED);
#endif

typedef HRESULT (WINAPI *PFNICWGetRasEntry)(LPRASENTRY, LPDWORD, LPRASDEVINFO, LPDWORD, LPTSTR);
typedef HRESULT (WINAPI *PFNDDDlg)(PDIALDLGDATA);
typedef HRESULT (WINAPI *PFNDEDlg)(PERRORDLGDATA);
#endif // _ICWDIAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\icwcmn.h ===
#ifndef _INC_ICWCMN_H
#define _INC_ICWCMN_H

#include "icwhelp.h"

// Data types and things that are common to both ICWCONN1.EXE and ICWCONN.DLL
#define MAX_AREA_CODE       10
#define MAX_COLOR_NAME      100

#define WUM_SETTITLE        (WM_USER + 100)

typedef struct ISPINFO_tag
{
    TCHAR   szISPName       [MAX_PATH*2];
    TCHAR   szSupportNumber [MAX_PATH+1];
    TCHAR   szISPFile       [MAX_PATH+1];
    TCHAR   szBillHtm       [MAX_PATH*2];
    TCHAR   szPayCsv        [MAX_PATH*2];
    TCHAR   szStartURL      [MAX_PATH+1];
    TCHAR   szIspURL        [MAX_PATH+1];
    DWORD   dwValidationFlags;
    BOOL    bFailedIns;
}ISPINFO;

typedef BOOL (WINAPI *PFConfigSys)(HWND hDlg);
typedef void (*PFCompleteOLS)();
typedef void (WINAPI *PFFillWindowWithAppBackground)(HWND hWnd, HDC hdc);

typedef struct CMNSTATEDATA_tag
{
    IICWSystemConfig                *pICWSystemConfig;
    ISPINFO                         ispInfo;
    PFConfigSys                     lpfnConfigSys;
    PFCompleteOLS                   lpfnCompleteOLS;
    DWORD                           dwFlags;
    DWORD                           dwCountryCode;
    TCHAR                           szAreaCode[MAX_AREA_CODE];
    BOOL                            bSystemChecked;
    BOOL                            bPhoneManualWiz;
    BOOL                            bParseIspinfo;
    BOOL                            bOEMOffline;
    BOOL                            bOEMEntryPt;
    BOOL                            bIsISDNDevice;
    HBITMAP                         hbmWatermark;
    TCHAR                           szWizTitle[MAX_PATH*2];
    
    BOOL                            bOEMCustom;        
    HWND                            hWndApp;
    HWND                            hWndWizardPages;
    HBITMAP                         hbmBkgrnd;
    TCHAR                           szHTMLBackgroundColor[MAX_COLOR_NAME];
    TCHAR                           szclrHTMLText[MAX_COLOR_NAME];
    TCHAR                           szBusyAnimationFile[MAX_PATH];
    int                             xPosBusy;
    COLORREF                        clrText;
    PFFillWindowWithAppBackground   lpfnFillWindowWithAppBackground;
    BOOL                            bHideProgressAnime;
} CMNSTATEDATA, FAR *LPCMNSTATEDATA;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\icwdl.h ===
// ############################################################################
#ifndef _ICWDL_H
#define _ICWDL_H

// These are the types of info that are passed back through the callback
#define CALLBACK_TYPE_URL       100
#define CALLBACK_TYPE_PROGRESS  99

// ############################################################################
#define DOWNLOAD_LIBRARY     TEXT("icwdl.dll")
#define DOWNLOADINIT         "DownLoadInit"
#define DOWNLOADEXECUTE      "DownLoadExecute"
#define DOWNLOADCLOSE        "DownLoadClose"
#define DOWNLOADSETSTATUS    "DownLoadSetStatusCallback"
#define DOWNLOADPROCESS      "DownLoadProcess"
#define DOWNLOADCANCEL       "DownLoadCancel"

// ############################################################################
typedef HRESULT (CALLBACK *PFNDOWNLOADINIT)(LPTSTR pszURL, DWORD_PTR FAR *lpCDialingDlg, DWORD_PTR FAR *pdwDownLoad, HWND hwndParent);
typedef HRESULT (CALLBACK *PFNDOWNLOADCANCEL)(DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK *PFNDOWNLOADEXECUTE)(DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK *PFNDOWNLOADCLOSE)(DWORD_PTR dwDownLoad);

// jmazner  10/2/96  Normandy #8493
// WRONG PROTOTYPE!! This should match icwdl/download.cpp:DownLoadSetStatusCallBack!!
//typedef HRESULT (CALLBACK *PFNDOWNLOADSETSTATUS)(DWORD dwDownLoad,INTERNET_STATUS_CALLBACK pfnCallback, DWORD dwContext);
typedef HRESULT (CALLBACK *PFNDOWNLOADSETSTATUS)(DWORD_PTR dwDownLoad,INTERNET_STATUS_CALLBACK pfnCallback);

typedef HRESULT (CALLBACK *PFNDOWNLOADPROCESS)(DWORD_PTR dwDownLoad);

#endif // _ICWDL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\icwconn.h ===
#ifndef _INC_ICWCONN_H
#define _INC_ICWCONN_H


#ifndef APPRENTICE_DEF
#define APPRENTICE_DEF
#define EXTERNAL_DIALOGID_MINIMUM   2000
#define EXTERNAL_DIALOGID_MAXIMUM   3000
typedef enum
{
    CANCEL_PROMPT = 0,
    CANCEL_SILENT,
    CANCEL_REBOOT
} CANCELTYPE;
#endif

// {7D857593-EAAE-11D1-AE03-0000F87734F0}
DEFINE_GUID(IID_IICW50Extension, 0x7d857593, 0xeaae, 0x11d1, 0xae, 0x3, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

interface IICW50Extension : public IUnknown
{
    public:
        virtual BOOL STDMETHODCALLTYPE AddExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID) = 0;
        virtual BOOL STDMETHODCALLTYPE RemoveExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID) = 0;
        virtual BOOL STDMETHODCALLTYPE ExternalCancel(CANCELTYPE type) = 0;
        virtual BOOL STDMETHODCALLTYPE SetFirstLastPage(UINT uFirstPageDlgID, UINT uLastPageDlgID) = 0;
        virtual HWND STDMETHODCALLTYPE GetWizardHwnd(void) = 0;
};

// IICW50Apprentice::Save error values

// IICW50Apprentice::AddWizardPages flags

// {7D857594-EAAE-11D1-AE03-0000F87734F0}
DEFINE_GUID(IID_IICW50Apprentice, 0x7d857594, 0xeaae, 0x11d1, 0xae, 0x3, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

interface IICW50Apprentice : public IUnknown
{
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize(IICW50Extension *pExt) = 0;
        virtual HRESULT STDMETHODCALLTYPE AddWizardPages(DWORD dwFlags) = 0;
        virtual HRESULT STDMETHODCALLTYPE Save(HWND hwnd, DWORD *pdwError) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetPrevNextPage(UINT uPrevPageDlgID, UINT uNextPageDlgID) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetStateDataFromExeToDll(LPCMNSTATEDATA lpData) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetStateDataFromDllToExe(LPCMNSTATEDATA lpData) = 0;
        virtual HRESULT STDMETHODCALLTYPE ProcessCustomFlags(DWORD dwFlags) = 0;
};

// ICWCONN's Apprentice CLSID
// This is used to import wizard pages from an external entity.
// {7D857595-EAAE-11D1-AE03-0000F87734F0}
DEFINE_GUID(CLSID_ApprenticeICWCONN, 0x7d857595, 0xeaae, 0x11d1, 0xae, 0x3, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

//ICWCONN1's Apprentice CLSID
// This is used to share ICWCONN1's wizard pages with an external entity.
// {7D857596-EAAE-11D1-AE03-0000F87734F0}
DEFINE_GUID(CLSID_ApprenticeICWCONN1, 0x7d857596, 0xeaae, 0x11d1, 0xae, 0x3, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

#endif // _INC_ICWCONN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\inc\icwhelp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0221 */
/* at Tue Dec 22 23:42:06 1998
 */
/* Compiler settings for icwhelp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __icwhelp_h__
#define __icwhelp_h__

/* Forward Declarations */ 

#ifndef __IRefDial_FWD_DEFINED__
#define __IRefDial_FWD_DEFINED__
typedef interface IRefDial IRefDial;
#endif 	/* __IRefDial_FWD_DEFINED__ */


#ifndef __IDialErr_FWD_DEFINED__
#define __IDialErr_FWD_DEFINED__
typedef interface IDialErr IDialErr;
#endif 	/* __IDialErr_FWD_DEFINED__ */


#ifndef __ISmartStart_FWD_DEFINED__
#define __ISmartStart_FWD_DEFINED__
typedef interface ISmartStart ISmartStart;
#endif 	/* __ISmartStart_FWD_DEFINED__ */


#ifndef __IICWSystemConfig_FWD_DEFINED__
#define __IICWSystemConfig_FWD_DEFINED__
typedef interface IICWSystemConfig IICWSystemConfig;
#endif 	/* __IICWSystemConfig_FWD_DEFINED__ */


#ifndef __ITapiLocationInfo_FWD_DEFINED__
#define __ITapiLocationInfo_FWD_DEFINED__
typedef interface ITapiLocationInfo ITapiLocationInfo;
#endif 	/* __ITapiLocationInfo_FWD_DEFINED__ */


#ifndef __IUserInfo_FWD_DEFINED__
#define __IUserInfo_FWD_DEFINED__
typedef interface IUserInfo IUserInfo;
#endif 	/* __IUserInfo_FWD_DEFINED__ */


#ifndef __IWebGate_FWD_DEFINED__
#define __IWebGate_FWD_DEFINED__
typedef interface IWebGate IWebGate;
#endif 	/* __IWebGate_FWD_DEFINED__ */


#ifndef __IINSHandler_FWD_DEFINED__
#define __IINSHandler_FWD_DEFINED__
typedef interface IINSHandler IINSHandler;
#endif 	/* __IINSHandler_FWD_DEFINED__ */


#ifndef ___RefDialEvents_FWD_DEFINED__
#define ___RefDialEvents_FWD_DEFINED__
typedef interface _RefDialEvents _RefDialEvents;
#endif 	/* ___RefDialEvents_FWD_DEFINED__ */


#ifndef __RefDial_FWD_DEFINED__
#define __RefDial_FWD_DEFINED__

#ifdef __cplusplus
typedef class RefDial RefDial;
#else
typedef struct RefDial RefDial;
#endif /* __cplusplus */

#endif 	/* __RefDial_FWD_DEFINED__ */


#ifndef __DialErr_FWD_DEFINED__
#define __DialErr_FWD_DEFINED__

#ifdef __cplusplus
typedef class DialErr DialErr;
#else
typedef struct DialErr DialErr;
#endif /* __cplusplus */

#endif 	/* __DialErr_FWD_DEFINED__ */


#ifndef __SmartStart_FWD_DEFINED__
#define __SmartStart_FWD_DEFINED__

#ifdef __cplusplus
typedef class SmartStart SmartStart;
#else
typedef struct SmartStart SmartStart;
#endif /* __cplusplus */

#endif 	/* __SmartStart_FWD_DEFINED__ */


#ifndef __ICWSystemConfig_FWD_DEFINED__
#define __ICWSystemConfig_FWD_DEFINED__

#ifdef __cplusplus
typedef class ICWSystemConfig ICWSystemConfig;
#else
typedef struct ICWSystemConfig ICWSystemConfig;
#endif /* __cplusplus */

#endif 	/* __ICWSystemConfig_FWD_DEFINED__ */


#ifndef __TapiLocationInfo_FWD_DEFINED__
#define __TapiLocationInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class TapiLocationInfo TapiLocationInfo;
#else
typedef struct TapiLocationInfo TapiLocationInfo;
#endif /* __cplusplus */

#endif 	/* __TapiLocationInfo_FWD_DEFINED__ */


#ifndef __UserInfo_FWD_DEFINED__
#define __UserInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class UserInfo UserInfo;
#else
typedef struct UserInfo UserInfo;
#endif /* __cplusplus */

#endif 	/* __UserInfo_FWD_DEFINED__ */


#ifndef ___WebGateEvents_FWD_DEFINED__
#define ___WebGateEvents_FWD_DEFINED__
typedef interface _WebGateEvents _WebGateEvents;
#endif 	/* ___WebGateEvents_FWD_DEFINED__ */


#ifndef __WebGate_FWD_DEFINED__
#define __WebGate_FWD_DEFINED__

#ifdef __cplusplus
typedef class WebGate WebGate;
#else
typedef struct WebGate WebGate;
#endif /* __cplusplus */

#endif 	/* __WebGate_FWD_DEFINED__ */


#ifndef ___INSHandlerEvents_FWD_DEFINED__
#define ___INSHandlerEvents_FWD_DEFINED__
typedef interface _INSHandlerEvents _INSHandlerEvents;
#endif 	/* ___INSHandlerEvents_FWD_DEFINED__ */


#ifndef __INSHandler_FWD_DEFINED__
#define __INSHandler_FWD_DEFINED__

#ifdef __cplusplus
typedef class INSHandler INSHandler;
#else
typedef struct INSHandler INSHandler;
#endif /* __cplusplus */

#endif 	/* __INSHandler_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_icwhelp_0000 */
/* [local] */ 

#pragma once



extern RPC_IF_HANDLE __MIDL_itf_icwhelp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_icwhelp_0000_v0_0_s_ifspec;

#ifndef __IRefDial_INTERFACE_DEFINED__
#define __IRefDial_INTERFACE_DEFINED__

/* interface IRefDial */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRefDial;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1E794A09-86F4-11D1-ADD8-0000F87734F0")
    IRefDial : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoConnect( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DownloadStatusString( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetupForDialing( 
            BSTR bstrISPFILE,
            DWORD dwCountry,
            BSTR bstrAreaCode,
            DWORD dwFlag,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_QuitWizard( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UserPickNumber( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DialPhoneNumber( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DialPhoneNumber( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_URL( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PromoCode( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PromoCode( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProductCode( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ProductCode( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoOfferDownload( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DialStatusString( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoHangup( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ProcessSignedPID( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SignedPID( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FormReferralServerURL( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SignupURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TryAgain( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DialErrorMsg( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ModemEnum_Reset( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ModemEnum_Next( 
            /* [retval][out] */ BSTR __RPC_FAR *pDeviceName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModemEnum_NumDevices( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SupportNumber( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ShowDialingProperties( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ShowPhoneBook( 
            /* [in] */ DWORD dwCountryCode,
            /* [in] */ long newVal,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ValidatePhoneNumber( 
            /* [in] */ BSTR bstrPhoneNumber,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HavePhoneBook( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BrandingFlags( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BrandingFlags( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentModem( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CurrentModem( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ISPSupportPhoneNumber( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ISPSupportPhoneNumber( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LoggingStartUrl( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LoggingEndUrl( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectedPhoneNumber( 
            /* [in] */ long newVal,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PhoneNumberEnum_Reset( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PhoneNumberEnum_Next( 
            /* [retval][out] */ BSTR __RPC_FAR *pNumber) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PhoneNumberEnum_NumDevices( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DialError( 
            /* [retval][out] */ HRESULT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Redial( 
            /* [in] */ BOOL newbVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AutoConfigURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoInit( void) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OemCode( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllOfferCode( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ISDNURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ISDNAutoConfigURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_bIsISDNDevice( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ModemOverride( 
            /* [in] */ BOOL newbVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveConnectoid( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ISPSupportNumber( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RasGetConnectStatus( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRefDialVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRefDial __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRefDial __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRefDial __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoConnect )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DownloadStatusString )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetupForDialing )( 
            IRefDial __RPC_FAR * This,
            BSTR bstrISPFILE,
            DWORD dwCountry,
            BSTR bstrAreaCode,
            DWORD dwFlag,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QuitWizard )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UserPickNumber )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DialPhoneNumber )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DialPhoneNumber )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_URL )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PromoCode )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PromoCode )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProductCode )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ProductCode )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoOfferDownload )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DialStatusString )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoHangup )( 
            IRefDial __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessSignedPID )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SignedPID )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FormReferralServerURL )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SignupURL )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TryAgain )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DialErrorMsg )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModemEnum_Reset )( 
            IRefDial __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModemEnum_Next )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pDeviceName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ModemEnum_NumDevices )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SupportNumber )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowDialingProperties )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowPhoneBook )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ DWORD dwCountryCode,
            /* [in] */ long newVal,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValidatePhoneNumber )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ BSTR bstrPhoneNumber,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HavePhoneBook )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BrandingFlags )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BrandingFlags )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentModem )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CurrentModem )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ISPSupportPhoneNumber )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ISPSupportPhoneNumber )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LoggingStartUrl )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LoggingEndUrl )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectedPhoneNumber )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ long newVal,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PhoneNumberEnum_Reset )( 
            IRefDial __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PhoneNumberEnum_Next )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pNumber);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PhoneNumberEnum_NumDevices )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DialError )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ HRESULT __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Redial )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ BOOL newbVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AutoConfigURL )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoInit )( 
            IRefDial __RPC_FAR * This);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OemCode )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AllOfferCode )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ISDNURL )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ISDNAutoConfigURL )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bIsISDNDevice )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ModemOverride )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ BOOL newbVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveConnectoid )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ISPSupportNumber )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RasGetConnectStatus )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        END_INTERFACE
    } IRefDialVtbl;

    interface IRefDial
    {
        CONST_VTBL struct IRefDialVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRefDial_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRefDial_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRefDial_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRefDial_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRefDial_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRefDial_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRefDial_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRefDial_DoConnect(This,pbRetVal)	\
    (This)->lpVtbl -> DoConnect(This,pbRetVal)

#define IRefDial_get_DownloadStatusString(This,pVal)	\
    (This)->lpVtbl -> get_DownloadStatusString(This,pVal)

#define IRefDial_SetupForDialing(This,bstrISPFILE,dwCountry,bstrAreaCode,dwFlag,pbRetVal)	\
    (This)->lpVtbl -> SetupForDialing(This,bstrISPFILE,dwCountry,bstrAreaCode,dwFlag,pbRetVal)

#define IRefDial_get_QuitWizard(This,pVal)	\
    (This)->lpVtbl -> get_QuitWizard(This,pVal)

#define IRefDial_get_UserPickNumber(This,pVal)	\
    (This)->lpVtbl -> get_UserPickNumber(This,pVal)

#define IRefDial_get_DialPhoneNumber(This,pVal)	\
    (This)->lpVtbl -> get_DialPhoneNumber(This,pVal)

#define IRefDial_put_DialPhoneNumber(This,newVal)	\
    (This)->lpVtbl -> put_DialPhoneNumber(This,newVal)

#define IRefDial_get_URL(This,pVal)	\
    (This)->lpVtbl -> get_URL(This,pVal)

#define IRefDial_get_PromoCode(This,pVal)	\
    (This)->lpVtbl -> get_PromoCode(This,pVal)

#define IRefDial_put_PromoCode(This,newVal)	\
    (This)->lpVtbl -> put_PromoCode(This,newVal)

#define IRefDial_get_ProductCode(This,pVal)	\
    (This)->lpVtbl -> get_ProductCode(This,pVal)

#define IRefDial_put_ProductCode(This,newVal)	\
    (This)->lpVtbl -> put_ProductCode(This,newVal)

#define IRefDial_DoOfferDownload(This,pbRetVal)	\
    (This)->lpVtbl -> DoOfferDownload(This,pbRetVal)

#define IRefDial_get_DialStatusString(This,pVal)	\
    (This)->lpVtbl -> get_DialStatusString(This,pVal)

#define IRefDial_DoHangup(This)	\
    (This)->lpVtbl -> DoHangup(This)

#define IRefDial_ProcessSignedPID(This,pbRetVal)	\
    (This)->lpVtbl -> ProcessSignedPID(This,pbRetVal)

#define IRefDial_get_SignedPID(This,pVal)	\
    (This)->lpVtbl -> get_SignedPID(This,pVal)

#define IRefDial_FormReferralServerURL(This,pbRetVal)	\
    (This)->lpVtbl -> FormReferralServerURL(This,pbRetVal)

#define IRefDial_get_SignupURL(This,pVal)	\
    (This)->lpVtbl -> get_SignupURL(This,pVal)

#define IRefDial_get_TryAgain(This,pVal)	\
    (This)->lpVtbl -> get_TryAgain(This,pVal)

#define IRefDial_get_DialErrorMsg(This,pVal)	\
    (This)->lpVtbl -> get_DialErrorMsg(This,pVal)

#define IRefDial_ModemEnum_Reset(This)	\
    (This)->lpVtbl -> ModemEnum_Reset(This)

#define IRefDial_ModemEnum_Next(This,pDeviceName)	\
    (This)->lpVtbl -> ModemEnum_Next(This,pDeviceName)

#define IRefDial_get_ModemEnum_NumDevices(This,pVal)	\
    (This)->lpVtbl -> get_ModemEnum_NumDevices(This,pVal)

#define IRefDial_get_SupportNumber(This,pVal)	\
    (This)->lpVtbl -> get_SupportNumber(This,pVal)

#define IRefDial_ShowDialingProperties(This,pbRetVal)	\
    (This)->lpVtbl -> ShowDialingProperties(This,pbRetVal)

#define IRefDial_ShowPhoneBook(This,dwCountryCode,newVal,pbRetVal)	\
    (This)->lpVtbl -> ShowPhoneBook(This,dwCountryCode,newVal,pbRetVal)

#define IRefDial_ValidatePhoneNumber(This,bstrPhoneNumber,pbRetVal)	\
    (This)->lpVtbl -> ValidatePhoneNumber(This,bstrPhoneNumber,pbRetVal)

#define IRefDial_get_HavePhoneBook(This,pVal)	\
    (This)->lpVtbl -> get_HavePhoneBook(This,pVal)

#define IRefDial_get_BrandingFlags(This,pVal)	\
    (This)->lpVtbl -> get_BrandingFlags(This,pVal)

#define IRefDial_put_BrandingFlags(This,newVal)	\
    (This)->lpVtbl -> put_BrandingFlags(This,newVal)

#define IRefDial_get_CurrentModem(This,pVal)	\
    (This)->lpVtbl -> get_CurrentModem(This,pVal)

#define IRefDial_put_CurrentModem(This,newVal)	\
    (This)->lpVtbl -> put_CurrentModem(This,newVal)

#define IRefDial_get_ISPSupportPhoneNumber(This,pVal)	\
    (This)->lpVtbl -> get_ISPSupportPhoneNumber(This,pVal)

#define IRefDial_put_ISPSupportPhoneNumber(This,newVal)	\
    (This)->lpVtbl -> put_ISPSupportPhoneNumber(This,newVal)

#define IRefDial_get_LoggingStartUrl(This,pVal)	\
    (This)->lpVtbl -> get_LoggingStartUrl(This,pVal)

#define IRefDial_get_LoggingEndUrl(This,pVal)	\
    (This)->lpVtbl -> get_LoggingEndUrl(This,pVal)

#define IRefDial_SelectedPhoneNumber(This,newVal,pbRetVal)	\
    (This)->lpVtbl -> SelectedPhoneNumber(This,newVal,pbRetVal)

#define IRefDial_PhoneNumberEnum_Reset(This)	\
    (This)->lpVtbl -> PhoneNumberEnum_Reset(This)

#define IRefDial_PhoneNumberEnum_Next(This,pNumber)	\
    (This)->lpVtbl -> PhoneNumberEnum_Next(This,pNumber)

#define IRefDial_get_PhoneNumberEnum_NumDevices(This,pVal)	\
    (This)->lpVtbl -> get_PhoneNumberEnum_NumDevices(This,pVal)

#define IRefDial_get_DialError(This,pVal)	\
    (This)->lpVtbl -> get_DialError(This,pVal)

#define IRefDial_put_Redial(This,newbVal)	\
    (This)->lpVtbl -> put_Redial(This,newbVal)

#define IRefDial_get_AutoConfigURL(This,pVal)	\
    (This)->lpVtbl -> get_AutoConfigURL(This,pVal)

#define IRefDial_DoInit(This)	\
    (This)->lpVtbl -> DoInit(This)

#define IRefDial_put_OemCode(This,newVal)	\
    (This)->lpVtbl -> put_OemCode(This,newVal)

#define IRefDial_put_AllOfferCode(This,newVal)	\
    (This)->lpVtbl -> put_AllOfferCode(This,newVal)

#define IRefDial_get_ISDNURL(This,pVal)	\
    (This)->lpVtbl -> get_ISDNURL(This,pVal)

#define IRefDial_get_ISDNAutoConfigURL(This,pVal)	\
    (This)->lpVtbl -> get_ISDNAutoConfigURL(This,pVal)

#define IRefDial_get_bIsISDNDevice(This,pVal)	\
    (This)->lpVtbl -> get_bIsISDNDevice(This,pVal)

#define IRefDial_put_ModemOverride(This,newbVal)	\
    (This)->lpVtbl -> put_ModemOverride(This,newbVal)

#define IRefDial_RemoveConnectoid(This,pbRetVal)	\
    (This)->lpVtbl -> RemoveConnectoid(This,pbRetVal)

#define IRefDial_get_ISPSupportNumber(This,pVal)	\
    (This)->lpVtbl -> get_ISPSupportNumber(This,pVal)

#define IRefDial_get_RasGetConnectStatus(This,pVal)	\
    (This)->lpVtbl -> get_RasGetConnectStatus(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_DoConnect_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_DoConnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_DownloadStatusString_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_DownloadStatusString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_SetupForDialing_Proxy( 
    IRefDial __RPC_FAR * This,
    BSTR bstrISPFILE,
    DWORD dwCountry,
    BSTR bstrAreaCode,
    DWORD dwFlag,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_SetupForDialing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_QuitWizard_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_QuitWizard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_UserPickNumber_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_UserPickNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_DialPhoneNumber_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_DialPhoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_DialPhoneNumber_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IRefDial_put_DialPhoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_URL_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_PromoCode_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_PromoCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_PromoCode_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IRefDial_put_PromoCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_ProductCode_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_ProductCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_ProductCode_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IRefDial_put_ProductCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_DoOfferDownload_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_DoOfferDownload_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_DialStatusString_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_DialStatusString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_DoHangup_Proxy( 
    IRefDial __RPC_FAR * This);


void __RPC_STUB IRefDial_DoHangup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_ProcessSignedPID_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_ProcessSignedPID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_SignedPID_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_SignedPID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_FormReferralServerURL_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_FormReferralServerURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_SignupURL_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_SignupURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_TryAgain_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_TryAgain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_DialErrorMsg_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_DialErrorMsg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_ModemEnum_Reset_Proxy( 
    IRefDial __RPC_FAR * This);


void __RPC_STUB IRefDial_ModemEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_ModemEnum_Next_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pDeviceName);


void __RPC_STUB IRefDial_ModemEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_ModemEnum_NumDevices_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_ModemEnum_NumDevices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_SupportNumber_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_SupportNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_ShowDialingProperties_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_ShowDialingProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_ShowPhoneBook_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ DWORD dwCountryCode,
    /* [in] */ long newVal,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_ShowPhoneBook_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_ValidatePhoneNumber_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ BSTR bstrPhoneNumber,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_ValidatePhoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_HavePhoneBook_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_HavePhoneBook_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_BrandingFlags_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_BrandingFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_BrandingFlags_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IRefDial_put_BrandingFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_CurrentModem_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_CurrentModem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_CurrentModem_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IRefDial_put_CurrentModem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_ISPSupportPhoneNumber_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_ISPSupportPhoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_ISPSupportPhoneNumber_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IRefDial_put_ISPSupportPhoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_LoggingStartUrl_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_LoggingStartUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_LoggingEndUrl_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_LoggingEndUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_SelectedPhoneNumber_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ long newVal,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_SelectedPhoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_PhoneNumberEnum_Reset_Proxy( 
    IRefDial __RPC_FAR * This);


void __RPC_STUB IRefDial_PhoneNumberEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_PhoneNumberEnum_Next_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pNumber);


void __RPC_STUB IRefDial_PhoneNumberEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_PhoneNumberEnum_NumDevices_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_PhoneNumberEnum_NumDevices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_DialError_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ HRESULT __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_DialError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_Redial_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ BOOL newbVal);


void __RPC_STUB IRefDial_put_Redial_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_AutoConfigURL_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_AutoConfigURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_DoInit_Proxy( 
    IRefDial __RPC_FAR * This);


void __RPC_STUB IRefDial_DoInit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_OemCode_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IRefDial_put_OemCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_AllOfferCode_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IRefDial_put_AllOfferCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_ISDNURL_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_ISDNURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_ISDNAutoConfigURL_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_ISDNAutoConfigURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_bIsISDNDevice_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_bIsISDNDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_ModemOverride_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ BOOL newbVal);


void __RPC_STUB IRefDial_put_ModemOverride_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_RemoveConnectoid_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_RemoveConnectoid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_ISPSupportNumber_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_ISPSupportNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_RasGetConnectStatus_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_RasGetConnectStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRefDial_INTERFACE_DEFINED__ */


#ifndef __IDialErr_INTERFACE_DEFINED__
#define __IDialErr_INTERFACE_DEFINED__

/* interface IDialErr */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDialErr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("462F7757-8848-11D1-ADD8-0000F87734F0")
    IDialErr : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDialErrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDialErr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDialErr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDialErr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDialErr __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDialErr __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDialErr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDialErr __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IDialErrVtbl;

    interface IDialErr
    {
        CONST_VTBL struct IDialErrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDialErr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDialErr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDialErr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDialErr_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDialErr_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDialErr_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDialErr_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDialErr_INTERFACE_DEFINED__ */


#ifndef __ISmartStart_INTERFACE_DEFINED__
#define __ISmartStart_INTERFACE_DEFINED__

/* interface ISmartStart */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISmartStart;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5D8D8F19-8B89-11D1-ADDB-0000F87734F0")
    ISmartStart : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsInternetCapable( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISmartStartVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISmartStart __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISmartStart __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISmartStart __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISmartStart __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISmartStart __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISmartStart __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISmartStart __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsInternetCapable )( 
            ISmartStart __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        END_INTERFACE
    } ISmartStartVtbl;

    interface ISmartStart
    {
        CONST_VTBL struct ISmartStartVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISmartStart_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISmartStart_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISmartStart_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISmartStart_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISmartStart_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISmartStart_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISmartStart_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISmartStart_IsInternetCapable(This,pbRetVal)	\
    (This)->lpVtbl -> IsInternetCapable(This,pbRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISmartStart_IsInternetCapable_Proxy( 
    ISmartStart __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB ISmartStart_IsInternetCapable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISmartStart_INTERFACE_DEFINED__ */


#ifndef __IICWSystemConfig_INTERFACE_DEFINED__
#define __IICWSystemConfig_INTERFACE_DEFINED__

/* interface IICWSystemConfig */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IICWSystemConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7954DD9A-8C2A-11D1-ADDB-0000F87734F0")
    IICWSystemConfig : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConfigSystem( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NeedsReboot( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_QuitWizard( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE VerifyRASIsRunning( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NeedsRestart( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CheckPasswordCachingPolicy( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IICWSystemConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IICWSystemConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IICWSystemConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConfigSystem )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NeedsReboot )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QuitWizard )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *VerifyRASIsRunning )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NeedsRestart )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckPasswordCachingPolicy )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        END_INTERFACE
    } IICWSystemConfigVtbl;

    interface IICWSystemConfig
    {
        CONST_VTBL struct IICWSystemConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IICWSystemConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IICWSystemConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IICWSystemConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IICWSystemConfig_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IICWSystemConfig_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IICWSystemConfig_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IICWSystemConfig_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IICWSystemConfig_ConfigSystem(This,pbRetVal)	\
    (This)->lpVtbl -> ConfigSystem(This,pbRetVal)

#define IICWSystemConfig_get_NeedsReboot(This,pVal)	\
    (This)->lpVtbl -> get_NeedsReboot(This,pVal)

#define IICWSystemConfig_get_QuitWizard(This,pVal)	\
    (This)->lpVtbl -> get_QuitWizard(This,pVal)

#define IICWSystemConfig_VerifyRASIsRunning(This,pbRetVal)	\
    (This)->lpVtbl -> VerifyRASIsRunning(This,pbRetVal)

#define IICWSystemConfig_get_NeedsRestart(This,pVal)	\
    (This)->lpVtbl -> get_NeedsRestart(This,pVal)

#define IICWSystemConfig_CheckPasswordCachingPolicy(This,pbRetVal)	\
    (This)->lpVtbl -> CheckPasswordCachingPolicy(This,pbRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IICWSystemConfig_ConfigSystem_Proxy( 
    IICWSystemConfig __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IICWSystemConfig_ConfigSystem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IICWSystemConfig_get_NeedsReboot_Proxy( 
    IICWSystemConfig __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IICWSystemConfig_get_NeedsReboot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IICWSystemConfig_get_QuitWizard_Proxy( 
    IICWSystemConfig __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IICWSystemConfig_get_QuitWizard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IICWSystemConfig_VerifyRASIsRunning_Proxy( 
    IICWSystemConfig __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IICWSystemConfig_VerifyRASIsRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IICWSystemConfig_get_NeedsRestart_Proxy( 
    IICWSystemConfig __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IICWSystemConfig_get_NeedsRestart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IICWSystemConfig_CheckPasswordCachingPolicy_Proxy( 
    IICWSystemConfig __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IICWSystemConfig_CheckPasswordCachingPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IICWSystemConfig_INTERFACE_DEFINED__ */


#ifndef __ITapiLocationInfo_INTERFACE_DEFINED__
#define __ITapiLocationInfo_INTERFACE_DEFINED__

/* interface ITapiLocationInfo */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITapiLocationInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CB632C75-8DD4-11D1-ADDF-0000F87734F0")
    ITapiLocationInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_wNumberOfLocations( 
            /* [out] */ short __RPC_FAR *psVal,
            /* [retval][out] */ long __RPC_FAR *pCurrLoc) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_bstrAreaCode( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrAreaCode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_bstrAreaCode( 
            /* [in] */ BSTR bstrAreaCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_lCountryCode( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTapiLocationInfo( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumCountries( 
            /* [retval][out] */ long __RPC_FAR *pNumOfCountry) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountryName( 
            /* [in] */ long lCountryIndex,
            /* [out] */ BSTR __RPC_FAR *pszCountryName,
            /* [retval][out] */ long __RPC_FAR *pCountryCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultCountry( 
            /* [retval][out] */ BSTR __RPC_FAR *pszCountryName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LocationName( 
            /* [in] */ long lLocationIndex,
            /* [out] */ BSTR __RPC_FAR *pszLocationName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LocationInfo( 
            /* [in] */ long lLocationIndex,
            /* [out] */ long __RPC_FAR *pLocationID,
            /* [out] */ BSTR __RPC_FAR *pszCountryName,
            /* [out] */ long __RPC_FAR *pCountryCode,
            /* [retval][out] */ BSTR __RPC_FAR *pszAreaCode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LocationId( 
            /* [in] */ long lLocationID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITapiLocationInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITapiLocationInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITapiLocationInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_wNumberOfLocations )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [out] */ short __RPC_FAR *psVal,
            /* [retval][out] */ long __RPC_FAR *pCurrLoc);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bstrAreaCode )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrAreaCode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_bstrAreaCode )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [in] */ BSTR bstrAreaCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lCountryCode )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTapiLocationInfo )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumCountries )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pNumOfCountry);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CountryName )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [in] */ long lCountryIndex,
            /* [out] */ BSTR __RPC_FAR *pszCountryName,
            /* [retval][out] */ long __RPC_FAR *pCountryCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultCountry )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pszCountryName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocationName )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [in] */ long lLocationIndex,
            /* [out] */ BSTR __RPC_FAR *pszLocationName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocationInfo )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [in] */ long lLocationIndex,
            /* [out] */ long __RPC_FAR *pLocationID,
            /* [out] */ BSTR __RPC_FAR *pszCountryName,
            /* [out] */ long __RPC_FAR *pCountryCode,
            /* [retval][out] */ BSTR __RPC_FAR *pszAreaCode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LocationId )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [in] */ long lLocationID);
        
        END_INTERFACE
    } ITapiLocationInfoVtbl;

    interface ITapiLocationInfo
    {
        CONST_VTBL struct ITapiLocationInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITapiLocationInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITapiLocationInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITapiLocationInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITapiLocationInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITapiLocationInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITapiLocationInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITapiLocationInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITapiLocationInfo_get_wNumberOfLocations(This,psVal,pCurrLoc)	\
    (This)->lpVtbl -> get_wNumberOfLocations(This,psVal,pCurrLoc)

#define ITapiLocationInfo_get_bstrAreaCode(This,pbstrAreaCode)	\
    (This)->lpVtbl -> get_bstrAreaCode(This,pbstrAreaCode)

#define ITapiLocationInfo_put_bstrAreaCode(This,bstrAreaCode)	\
    (This)->lpVtbl -> put_bstrAreaCode(This,bstrAreaCode)

#define ITapiLocationInfo_get_lCountryCode(This,plVal)	\
    (This)->lpVtbl -> get_lCountryCode(This,plVal)

#define ITapiLocationInfo_GetTapiLocationInfo(This,pbRetVal)	\
    (This)->lpVtbl -> GetTapiLocationInfo(This,pbRetVal)

#define ITapiLocationInfo_get_NumCountries(This,pNumOfCountry)	\
    (This)->lpVtbl -> get_NumCountries(This,pNumOfCountry)

#define ITapiLocationInfo_get_CountryName(This,lCountryIndex,pszCountryName,pCountryCode)	\
    (This)->lpVtbl -> get_CountryName(This,lCountryIndex,pszCountryName,pCountryCode)

#define ITapiLocationInfo_get_DefaultCountry(This,pszCountryName)	\
    (This)->lpVtbl -> get_DefaultCountry(This,pszCountryName)

#define ITapiLocationInfo_get_LocationName(This,lLocationIndex,pszLocationName)	\
    (This)->lpVtbl -> get_LocationName(This,lLocationIndex,pszLocationName)

#define ITapiLocationInfo_get_LocationInfo(This,lLocationIndex,pLocationID,pszCountryName,pCountryCode,pszAreaCode)	\
    (This)->lpVtbl -> get_LocationInfo(This,lLocationIndex,pLocationID,pszCountryName,pCountryCode,pszAreaCode)

#define ITapiLocationInfo_put_LocationId(This,lLocationID)	\
    (This)->lpVtbl -> put_LocationId(This,lLocationID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_get_wNumberOfLocations_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [out] */ short __RPC_FAR *psVal,
    /* [retval][out] */ long __RPC_FAR *pCurrLoc);


void __RPC_STUB ITapiLocationInfo_get_wNumberOfLocations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_get_bstrAreaCode_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrAreaCode);


void __RPC_STUB ITapiLocationInfo_get_bstrAreaCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_put_bstrAreaCode_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [in] */ BSTR bstrAreaCode);


void __RPC_STUB ITapiLocationInfo_put_bstrAreaCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_get_lCountryCode_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB ITapiLocationInfo_get_lCountryCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_GetTapiLocationInfo_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB ITapiLocationInfo_GetTapiLocationInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_get_NumCountries_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pNumOfCountry);


void __RPC_STUB ITapiLocationInfo_get_NumCountries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_get_CountryName_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [in] */ long lCountryIndex,
    /* [out] */ BSTR __RPC_FAR *pszCountryName,
    /* [retval][out] */ long __RPC_FAR *pCountryCode);


void __RPC_STUB ITapiLocationInfo_get_CountryName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_get_DefaultCountry_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pszCountryName);


void __RPC_STUB ITapiLocationInfo_get_DefaultCountry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_get_LocationName_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [in] */ long lLocationIndex,
    /* [out] */ BSTR __RPC_FAR *pszLocationName);


void __RPC_STUB ITapiLocationInfo_get_LocationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_get_LocationInfo_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [in] */ long lLocationIndex,
    /* [out] */ long __RPC_FAR *pLocationID,
    /* [out] */ BSTR __RPC_FAR *pszCountryName,
    /* [out] */ long __RPC_FAR *pCountryCode,
    /* [retval][out] */ BSTR __RPC_FAR *pszAreaCode);


void __RPC_STUB ITapiLocationInfo_get_LocationInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_put_LocationId_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [in] */ long lLocationID);


void __RPC_STUB ITapiLocationInfo_put_LocationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITapiLocationInfo_INTERFACE_DEFINED__ */


#ifndef __IUserInfo_INTERFACE_DEFINED__
#define __IUserInfo_INTERFACE_DEFINED__

/* interface IUserInfo */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IUserInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9E12E76C-94D6-11D1-ADE2-0000F87734F0")
    IUserInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CollectRegisteredUserInfo( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Company( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Company( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FirstName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FirstName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LastName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LastName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address1( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Address1( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address2( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Address2( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_City( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_City( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_State( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ZIPCode( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ZIPCode( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PhoneNumber( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PhoneNumber( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Lcid( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PersistRegisteredUserInfo( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUserInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUserInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUserInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IUserInfo __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CollectRegisteredUserInfo )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Company )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Company )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FirstName )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FirstName )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LastName )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LastName )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Address1 )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Address1 )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Address2 )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Address2 )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_City )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_City )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_State )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ZIPCode )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ZIPCode )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PhoneNumber )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PhoneNumber )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Lcid )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PersistRegisteredUserInfo )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        END_INTERFACE
    } IUserInfoVtbl;

    interface IUserInfo
    {
        CONST_VTBL struct IUserInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUserInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUserInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUserInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUserInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IUserInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IUserInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IUserInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IUserInfo_CollectRegisteredUserInfo(This,pbRetVal)	\
    (This)->lpVtbl -> CollectRegisteredUserInfo(This,pbRetVal)

#define IUserInfo_get_Company(This,pVal)	\
    (This)->lpVtbl -> get_Company(This,pVal)

#define IUserInfo_put_Company(This,newVal)	\
    (This)->lpVtbl -> put_Company(This,newVal)

#define IUserInfo_get_FirstName(This,pVal)	\
    (This)->lpVtbl -> get_FirstName(This,pVal)

#define IUserInfo_put_FirstName(This,newVal)	\
    (This)->lpVtbl -> put_FirstName(This,newVal)

#define IUserInfo_get_LastName(This,pVal)	\
    (This)->lpVtbl -> get_LastName(This,pVal)

#define IUserInfo_put_LastName(This,newVal)	\
    (This)->lpVtbl -> put_LastName(This,newVal)

#define IUserInfo_get_Address1(This,pVal)	\
    (This)->lpVtbl -> get_Address1(This,pVal)

#define IUserInfo_put_Address1(This,newVal)	\
    (This)->lpVtbl -> put_Address1(This,newVal)

#define IUserInfo_get_Address2(This,pVal)	\
    (This)->lpVtbl -> get_Address2(This,pVal)

#define IUserInfo_put_Address2(This,newVal)	\
    (This)->lpVtbl -> put_Address2(This,newVal)

#define IUserInfo_get_City(This,pVal)	\
    (This)->lpVtbl -> get_City(This,pVal)

#define IUserInfo_put_City(This,newVal)	\
    (This)->lpVtbl -> put_City(This,newVal)

#define IUserInfo_get_State(This,pVal)	\
    (This)->lpVtbl -> get_State(This,pVal)

#define IUserInfo_put_State(This,newVal)	\
    (This)->lpVtbl -> put_State(This,newVal)

#define IUserInfo_get_ZIPCode(This,pVal)	\
    (This)->lpVtbl -> get_ZIPCode(This,pVal)

#define IUserInfo_put_ZIPCode(This,newVal)	\
    (This)->lpVtbl -> put_ZIPCode(This,newVal)

#define IUserInfo_get_PhoneNumber(This,pVal)	\
    (This)->lpVtbl -> get_PhoneNumber(This,pVal)

#define IUserInfo_put_PhoneNumber(This,newVal)	\
    (This)->lpVtbl -> put_PhoneNumber(This,newVal)

#define IUserInfo_get_Lcid(This,pVal)	\
    (This)->lpVtbl -> get_Lcid(This,pVal)

#define IUserInfo_PersistRegisteredUserInfo(This,pbRetVal)	\
    (This)->lpVtbl -> PersistRegisteredUserInfo(This,pbRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IUserInfo_CollectRegisteredUserInfo_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IUserInfo_CollectRegisteredUserInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_Company_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_Company_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IUserInfo_put_Company_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IUserInfo_put_Company_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_FirstName_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_FirstName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IUserInfo_put_FirstName_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IUserInfo_put_FirstName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_LastName_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_LastName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IUserInfo_put_LastName_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IUserInfo_put_LastName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_Address1_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_Address1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IUserInfo_put_Address1_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IUserInfo_put_Address1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_Address2_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_Address2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IUserInfo_put_Address2_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IUserInfo_put_Address2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_City_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_City_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IUserInfo_put_City_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IUserInfo_put_City_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_State_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IUserInfo_put_State_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IUserInfo_put_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_ZIPCode_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_ZIPCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IUserInfo_put_ZIPCode_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IUserInfo_put_ZIPCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_PhoneNumber_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_PhoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IUserInfo_put_PhoneNumber_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IUserInfo_put_PhoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_Lcid_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_Lcid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IUserInfo_PersistRegisteredUserInfo_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IUserInfo_PersistRegisteredUserInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUserInfo_INTERFACE_DEFINED__ */


#ifndef __IWebGate_INTERFACE_DEFINED__
#define __IWebGate_INTERFACE_DEFINED__

/* interface IWebGate */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWebGate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3724B9A0-9503-11D1-B86A-00A0C90DC849")
    IWebGate : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FormData( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FetchPage( 
            /* [in] */ DWORD dwKeepPage,
            /* [in] */ DWORD dwDoWait,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Buffer( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DownloadFname( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DumpBufferToFile( 
            /* [out] */ BSTR __RPC_FAR *pFileName,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebGateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWebGate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWebGate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWebGate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWebGate __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWebGate __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWebGate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWebGate __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Path )( 
            IWebGate __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FormData )( 
            IWebGate __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FetchPage )( 
            IWebGate __RPC_FAR * This,
            /* [in] */ DWORD dwKeepPage,
            /* [in] */ DWORD dwDoWait,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Buffer )( 
            IWebGate __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DownloadFname )( 
            IWebGate __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DumpBufferToFile )( 
            IWebGate __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pFileName,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        END_INTERFACE
    } IWebGateVtbl;

    interface IWebGate
    {
        CONST_VTBL struct IWebGateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebGate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebGate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebGate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebGate_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWebGate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWebGate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWebGate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWebGate_put_Path(This,newVal)	\
    (This)->lpVtbl -> put_Path(This,newVal)

#define IWebGate_put_FormData(This,newVal)	\
    (This)->lpVtbl -> put_FormData(This,newVal)

#define IWebGate_FetchPage(This,dwKeepPage,dwDoWait,pbRetVal)	\
    (This)->lpVtbl -> FetchPage(This,dwKeepPage,dwDoWait,pbRetVal)

#define IWebGate_get_Buffer(This,pVal)	\
    (This)->lpVtbl -> get_Buffer(This,pVal)

#define IWebGate_get_DownloadFname(This,pVal)	\
    (This)->lpVtbl -> get_DownloadFname(This,pVal)

#define IWebGate_DumpBufferToFile(This,pFileName,pbRetVal)	\
    (This)->lpVtbl -> DumpBufferToFile(This,pFileName,pbRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWebGate_put_Path_Proxy( 
    IWebGate __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWebGate_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWebGate_put_FormData_Proxy( 
    IWebGate __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWebGate_put_FormData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebGate_FetchPage_Proxy( 
    IWebGate __RPC_FAR * This,
    /* [in] */ DWORD dwKeepPage,
    /* [in] */ DWORD dwDoWait,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IWebGate_FetchPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebGate_get_Buffer_Proxy( 
    IWebGate __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IWebGate_get_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebGate_get_DownloadFname_Proxy( 
    IWebGate __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IWebGate_get_DownloadFname_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebGate_DumpBufferToFile_Proxy( 
    IWebGate __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pFileName,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IWebGate_DumpBufferToFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebGate_INTERFACE_DEFINED__ */


#ifndef __IINSHandler_INTERFACE_DEFINED__
#define __IINSHandler_INTERFACE_DEFINED__

/* interface IINSHandler */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IINSHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6342E1B5-94DB-11D1-ADE2-0000F87734F0")
    IINSHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ProcessINS( 
            BSTR bstrINSFilePath,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NeedRestart( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BrandingFlags( 
            /* [in] */ long lFlags) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pszURL) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SilentMode( 
            /* [in] */ BOOL bSilent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IINSHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IINSHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IINSHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IINSHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IINSHandler __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IINSHandler __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IINSHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IINSHandler __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessINS )( 
            IINSHandler __RPC_FAR * This,
            BSTR bstrINSFilePath,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NeedRestart )( 
            IINSHandler __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BrandingFlags )( 
            IINSHandler __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultURL )( 
            IINSHandler __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pszURL);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SilentMode )( 
            IINSHandler __RPC_FAR * This,
            /* [in] */ BOOL bSilent);
        
        END_INTERFACE
    } IINSHandlerVtbl;

    interface IINSHandler
    {
        CONST_VTBL struct IINSHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IINSHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IINSHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IINSHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IINSHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IINSHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IINSHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IINSHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IINSHandler_ProcessINS(This,bstrINSFilePath,pbRetVal)	\
    (This)->lpVtbl -> ProcessINS(This,bstrINSFilePath,pbRetVal)

#define IINSHandler_get_NeedRestart(This,pVal)	\
    (This)->lpVtbl -> get_NeedRestart(This,pVal)

#define IINSHandler_put_BrandingFlags(This,lFlags)	\
    (This)->lpVtbl -> put_BrandingFlags(This,lFlags)

#define IINSHandler_get_DefaultURL(This,pszURL)	\
    (This)->lpVtbl -> get_DefaultURL(This,pszURL)

#define IINSHandler_put_SilentMode(This,bSilent)	\
    (This)->lpVtbl -> put_SilentMode(This,bSilent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IINSHandler_ProcessINS_Proxy( 
    IINSHandler __RPC_FAR * This,
    BSTR bstrINSFilePath,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IINSHandler_ProcessINS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IINSHandler_get_NeedRestart_Proxy( 
    IINSHandler __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IINSHandler_get_NeedRestart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IINSHandler_put_BrandingFlags_Proxy( 
    IINSHandler __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IINSHandler_put_BrandingFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IINSHandler_get_DefaultURL_Proxy( 
    IINSHandler __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pszURL);


void __RPC_STUB IINSHandler_get_DefaultURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IINSHandler_put_SilentMode_Proxy( 
    IINSHandler __RPC_FAR * This,
    /* [in] */ BOOL bSilent);


void __RPC_STUB IINSHandler_put_SilentMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IINSHandler_INTERFACE_DEFINED__ */



#ifndef __ICWHELPLib_LIBRARY_DEFINED__
#define __ICWHELPLib_LIBRARY_DEFINED__

/* library ICWHELPLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_ICWHELPLib;

#ifndef ___RefDialEvents_DISPINTERFACE_DEFINED__
#define ___RefDialEvents_DISPINTERFACE_DEFINED__

/* dispinterface _RefDialEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__RefDialEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("07DB96D0-91D8-11D1-ADE1-0000F87734F0")
    _RefDialEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _RefDialEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _RefDialEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _RefDialEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _RefDialEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _RefDialEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _RefDialEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _RefDialEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _RefDialEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _RefDialEventsVtbl;

    interface _RefDialEvents
    {
        CONST_VTBL struct _RefDialEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _RefDialEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _RefDialEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _RefDialEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _RefDialEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _RefDialEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _RefDialEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _RefDialEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult