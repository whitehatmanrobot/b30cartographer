 *lpunk = ( _IWbemRefresherMgr * ) new CServerObject_ProviderRefresherManager ( *ProviderSubSystem_Globals :: s_Allocator );
		if ( lpunk )
		{
			HRESULT t_Result = lpunk->QueryInterface ( a_Riid , a_Interface ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
			}
			else
			{
				delete lpunk ;		
			}	

			return t_Result ;		
		}
		else
		{
			return E_OUTOFMEMORY ;
		}
	}
	else
	{
		return CLASS_E_CLASSNOTAVAILABLE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_Host :: GetProcessIdentifier ( DWORD *a_ProcessIdentifier )
{
	HRESULT t_Result = S_OK ;

	if ( a_ProcessIdentifier ) 
	{
		*a_ProcessIdentifier = GetCurrentProcessId () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_Host :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provfact.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <stdio.h>

#include <HelperFuncs.h>
#include <Logging.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvSubS.h"
#include "ProvAggr.h"
#include "ProvFact.h"
#include "ProvLoad.h"
#include "ProvWsv.h"
#include "ProvWsvS.h"
#include "ProvResv.h"
#include "ProvInSk.h"
#include "ProvRegDeCoupled.h"
#include "ProvRegInfo.h"
#include "ProvCache.h"
#include "ProvHost.h"
#include "ProvObSk.h"
#include "Guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CServerObject_BindingFactory :: CServerObject_BindingFactory (

	WmiAllocator &a_Allocator

) :	CWbemGlobal_IWmiProviderController ( a_Allocator ) ,
	m_Internal ( this ) ,
	m_Allocator ( a_Allocator ) ,
	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_NamespacePath ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SubSystem ( NULL )
{
	CWbemGlobal_IWmiProviderController :: AddRef () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_BindingFactory_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_BindingFactory :: CServerObject_BindingFactory (

	WmiAllocator &a_Allocator ,
	CWbemGlobal_IWmiFactoryController *a_Controller ,
	const BindingFactoryCacheKey &a_Key ,
	const ULONG &a_Period 

) : BindingFactoryCacheElement (

		a_Controller ,
		a_Key ,
		a_Period
	) ,
	CWbemGlobal_IWmiProviderController ( a_Allocator ) ,
	m_Internal ( this ) ,
	m_Allocator ( a_Allocator ) ,
	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_NamespacePath ( NULL ) ,
	m_Repository ( NULL ) ,
	m_SubSystem ( NULL )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_BindingFactory_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_BindingFactory::~CServerObject_BindingFactory ()
{
#if 0
wchar_t t_Buffer [ 128 ] ;
wsprintf ( t_Buffer , L"\n%lx - ~CServerObject_BindingFactory ( %lx ) " , GetTickCount () , this ) ;
OutputDebugString ( t_Buffer ) ;
#endif

	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace ) 
	{
		delete [] m_Namespace ;
	}

	if ( m_NamespacePath ) 
	{
		m_NamespacePath->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}

	if ( m_SubSystem ) 
	{
		m_SubSystem->Release () ;
	}

	CWbemGlobal_IWmiProviderController :: UnInitialize () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_BindingFactory_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Initialize (

	_IWmiProvSS *a_SubSys ,
	_IWmiProviderFactory *a_Factory ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Namespace ,
	IWbemServices *a_Repository ,
	IWbemServices *a_Service	
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		if ( a_Namespace ) 
		{
			m_Namespace = new wchar_t [ wcslen ( a_Namespace ) + 1 ] ;
			if ( m_Namespace ) 
			{
				wcscpy ( m_Namespace , a_Namespace ) ;
			}
			else
			{	
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = CoCreateInstance (

					CLSID_WbemDefPath ,
					NULL ,
					CLSCTX_INPROC_SERVER ,
					IID_IWbemPath ,
					( void ** )  & m_NamespacePath
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = m_NamespacePath->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Namespace ) ;
				}
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			m_SubSystem = a_SubSys ;
			m_Flags = a_Flags ;
			m_Context = a_Context ;
			
			if ( m_Context ) 
			{
				m_Context->AddRef () ;
			}

			if ( m_SubSystem ) 
			{
				m_SubSystem->AddRef () ;
			}

			WmiStatusCode t_StatusCode = CWbemGlobal_IWmiProviderController :: Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success ) 
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_BindingFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiProviderFactory )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderFactory * ) this ;		
	}	
	else if ( iid == IID__IWmiProviderFactoryInitialize )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderFactoryInitialize * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	
	else if ( iid == IID__IWmiProviderConfiguration )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderConfiguration * ) this ;		
	}	
	else if ( iid == IID_CWbemGlobal_IWmiProviderController )
	{
		*iplpv = ( LPVOID ) & ( this->m_Internal ) ;
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_BindingFactory :: AddRef ()
{
	return BindingFactoryCacheElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_BindingFactory :: Release ()
{	
	return BindingFactoryCacheElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: CacheProvider (

	_IWmiProviderSubsystemRegistrar *a_Registrar ,
	IWbemContext *a_Context ,
	CServerObject_DecoupledClientRegistration_Element &a_Element ,
	IUnknown *a_Unknown 
)
{
	HRESULT t_Result = S_OK ;

	GUID t_Identity ;
	t_Result = CLSIDFromString ( a_Element.GetClsid () , & t_Identity ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_Registrar->Register (

			0 ,
			a_Context ,
			a_Element.GetUser () ,
			a_Element.GetLocale () ,
			a_Element.GetScope () ,
			a_Element.GetProvider () ,
			a_Element.GetProcessIdentifier () ,
			a_Unknown ,
			t_Identity
		) ;
	}	

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Load (

	_IWmiProviderSubsystemRegistrar *a_Registrar ,
	IWbemContext *a_Context ,
	CServerObject_DecoupledClientRegistration_Element &a_Element
)
{
	HRESULT t_Result = S_OK ;

	BYTE *t_MarshaledProxy = a_Element.GetMarshaledProxy () ;
	DWORD t_MarshaledProxyLength = a_Element.GetMarshaledProxyLength () ;

	if ( t_MarshaledProxy )
	{
		IUnknown *t_Unknown = NULL ;
		t_Result = ProviderSubSystem_Common_Globals :: UnMarshalRegistration ( & t_Unknown , t_MarshaledProxy , t_MarshaledProxyLength ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CacheProvider ( 

				a_Registrar ,
				a_Context ,
				a_Element ,
				t_Unknown 	
			) ;

			t_Unknown->Release () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Load (

	CDecoupledAggregator_IWbemProvider *a_Aggregator ,
	IWbemContext *a_Context ,
	BSTR a_Provider ,
	BSTR a_User ,
	BSTR a_Locale ,
	BSTR a_Scope
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		_IWmiProviderSubsystemRegistrar *t_Registrar = NULL ;
		t_Result = a_Aggregator->QueryInterface ( IID__IWmiProviderSubsystemRegistrar , ( void ** ) & t_Registrar ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( ProviderSubSystem_Globals :: GetDecoupledRegistrySection () ) ;

			CServerObject_DecoupledClientRegistration t_Elements ( m_Allocator ) ;
			HRESULT t_TempResult = t_Elements.Load (

				a_Provider ,
				a_User ,
				a_Locale ,
				a_Scope
			) ;
							
			t_StatusCode = WmiHelper :: LeaveCriticalSection ( ProviderSubSystem_Globals :: GetDecoupledRegistrySection () ) ;

			if ( SUCCEEDED ( t_TempResult ) )
			{
				WmiQueue < CServerObject_DecoupledClientRegistration_Element , 8 > &t_Queue = t_Elements.GetQueue () ;
				
				CServerObject_DecoupledClientRegistration_Element t_Top ;

				WmiStatusCode t_StatusCode ;
				while ( ( t_StatusCode = t_Queue.Top ( t_Top ) ) == e_StatusCode_Success )
				{
					HRESULT t_TempResult = Load (

						t_Registrar ,
						a_Context , 
						t_Top
					) ;

					t_StatusCode = t_Queue.DeQueue () ;
				}
			}
			else
			{
			}

			t_Registrar->Release () ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: GetHosting ( 

	CServerObject_ProviderRegistrationV1 &a_Registration ,
	IWbemContext *a_Context ,
	Enum_Hosting &a_Hosting ,
	LPCWSTR &a_HostingGroup
)
{
	HRESULT t_Result = S_OK ;

	a_Hosting = e_Hosting_Undefined ;
	
	if ( a_Context )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		HRESULT t_TResult = a_Context->GetValue ( L"Hosting" , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( t_TResult ) )
		{
			if ( t_Variant.vt == VT_I4 )	
			{
				a_Hosting = ( Enum_Hosting ) t_Variant.lVal ;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	a_Hosting = ( a_Hosting == e_Hosting_Undefined ) ? a_Registration.GetHosting () : a_Hosting ;
	switch ( a_Hosting )
	{
		case e_Hosting_SharedNetworkServiceHost:
		case e_Hosting_SharedLocalSystemHostOrSelfHost:
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalServiceHost:
		case e_Hosting_SharedUserHost:
		{
			a_HostingGroup = a_Registration.GetHostingGroup () ;
		}
		break ;

		default:
		{
			a_HostingGroup = NULL ;
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Create ( 

	CServerObject_ProviderRegistrationV1 &a_Registration ,
	Enum_Hosting a_Hosting ,
	LPCWSTR a_HostingGroup ,
	LPCWSTR a_User ,
	_IWmiProviderHost **a_Host ,
	_IWmiProviderFactory **a_Factory 
)
{
	HRESULT t_Result = S_OK ;

	switch ( a_Hosting )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_WmiCoreOrSelfHost:
		case e_Hosting_SelfHost:
		case e_Hosting_ClientHost:
		case e_Hosting_NonCom:
		{
			t_Result = ProviderSubSystem_Common_Globals :: CreateInstance	(

				CLSID_WmiProviderInProcFactory ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID__IWmiProviderFactory ,
				( void ** ) a_Factory 
			) ;
		}
		break ;

		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalSystemHostOrSelfHost:
		{
			try
			{
				HostCacheKey t_Key ( 

					HostCacheKey :: e_HostDesignation_Shared ,
					a_HostingGroup ,
					HostCacheKey :: e_IdentityDesignation_LocalSystem ,
					NULL
				) ;

				t_Result = CServerObject_HostInterceptor :: CreateUsingToken (

					t_Key ,
					a_Host ,
					a_Factory 
				) ;
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		break ;

		case e_Hosting_SharedUserHost:
		{
			t_Result = CoImpersonateClient () ;

			if ( SUCCEEDED ( t_Result ) )
			{
				try
				{
					HostCacheKey t_Key ( 

						HostCacheKey :: e_HostDesignation_Shared ,
						a_HostingGroup ,
						HostCacheKey :: e_IdentityDesignation_User ,
						a_User
					) ;

					t_Result = CServerObject_HostInterceptor :: CreateUsingToken (

						t_Key ,
						a_Host ,
						a_Factory 
					) ;
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
		}
		break ;

		case e_Hosting_Decoupled:
		{
			t_Result = WBEM_E_PROVIDER_NOT_FOUND ;
		}
		break ;

		case e_Hosting_SharedLocalServiceHost:
		{
			try
			{
				HostCacheKey t_Key ( 

					HostCacheKey :: e_HostDesignation_Shared ,
					a_HostingGroup ,
					HostCacheKey :: e_IdentityDesignation_LocalService ,
					NULL
				) ;

				t_Result = CServerObject_HostInterceptor :: CreateUsingAccount (

					t_Key ,
					L"LocalService" ,
					L"NT AUTHORITY" ,
					a_Host ,
					a_Factory 
				) ;
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		break ;

		case e_Hosting_SharedNetworkServiceHost:
		{
			try
			{
				HostCacheKey t_Key ( 

					HostCacheKey :: e_HostDesignation_Shared ,
					a_HostingGroup ,
					HostCacheKey :: e_IdentityDesignation_NetworkService ,
					NULL
				) ;

				t_Result = CServerObject_HostInterceptor :: CreateUsingAccount (

					t_Key ,
					L"NetworkService" ,
					L"NT AUTHORITY" ,
					a_Host ,
					a_Factory 
				) ;
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		break ;

		default:
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: InitializeHostedService (

	CInterceptor_IWbemProvider *a_Interceptor ,
	IUnknown *a_Unknown
)
{
	HRESULT t_Result = S_OK ;

	IUnknown *t_InterceptorUnknown = NULL ;
	t_Result = a_Interceptor->QueryInterface ( IID_IUnknown , ( void ** ) & t_InterceptorUnknown ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiProviderSite *t_Site = NULL ;
		t_Result = a_Unknown->QueryInterface ( IID__IWmiProviderSite , ( void ** ) & t_Site ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Site->SetContainer ( a_Interceptor->GetQuota () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				DWORD t_ProcessIdentifier = 0 ;
				t_Result = t_Site->GetSite ( & t_ProcessIdentifier ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_HostedProviderController *t_HostedController = ProviderSubSystem_Globals :: GetHostedProviderController () ;

					t_HostedController->Lock () ;

					CWbemGlobal_HostedProviderController_Container_Iterator t_Iterator ;

					WmiStatusCode t_StatusCode = t_HostedController->Find ( t_ProcessIdentifier , t_Iterator ) ;
					switch ( t_StatusCode )
					{
						case e_StatusCode_Success:
						{
							ProviderController *t_ProviderController = NULL ;
							t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_ProviderController , ( void ** ) & t_ProviderController ) ;
							if ( SUCCEEDED ( t_Result ) ) 
							{
								t_ProviderController->Lock () ;

								ProviderController :: Container_Iterator t_Iterator ;
								t_StatusCode = t_ProviderController->Insert ( a_Interceptor , t_Iterator ) ;
								if ( t_StatusCode != e_StatusCode_Success )
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								t_ProviderController->UnLock () ;

								t_ProviderController->Release () ;
							}
						}
						break ;

						default:
						{
							ProviderController *t_ProviderController = new ProviderController ( 

								m_Allocator , 
								t_HostedController , 
								t_ProcessIdentifier
							) ;

							if ( t_ProviderController )
							{
								t_ProviderController->AddRef () ;

								t_StatusCode = t_ProviderController->Initialize () ;
								if ( t_StatusCode == e_StatusCode_Success ) 
								{
									t_StatusCode = t_HostedController->Insert ( *t_ProviderController , t_Iterator ) ;
									if ( t_StatusCode == e_StatusCode_Success ) 
									{
										t_ProviderController->AddRef () ;

										t_ProviderController->Lock () ;

										ProviderController :: Container_Iterator t_Iterator ;
										t_StatusCode = t_ProviderController->Insert ( a_Interceptor , t_Iterator ) ;
										if ( t_StatusCode == e_StatusCode_Success )
										{
										}
										else
										{
											t_Result = WBEM_E_OUT_OF_MEMORY ;
										}

										if ( FAILED ( t_Result ) )
										{
											t_StatusCode = t_HostedController->Delete ( t_ProcessIdentifier ) ;
										}

										t_ProviderController->UnLock () ;
									}
									else
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							t_ProviderController->Release () ;
						}
						break ;
					}

					t_HostedController->UnLock () ;
				}
			}

			t_Site->Release () ;
		}

		t_InterceptorUnknown->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: InternalFindAggregatedDecoupledProvider ( 

	IWbemServices *a_RepositoryService ,
	IWbemServices *a_FullService ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	ProviderCacheKey &a_Key ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope,
	LPCWSTR a_Name ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		Lock () ;

		CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator ;

		WmiStatusCode t_StatusCode = Find ( a_Key , t_Iterator ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			ServiceCacheElement *t_Element = t_Iterator.GetElement () ;

			UnLock () ;

			CDecoupledAggregator_IWbemProvider *t_Aggregator = NULL ;

			t_Result = t_Element->QueryInterface (

				IID_CDecoupledAggregator_IWbemProvider ,
				( void ** ) & t_Aggregator
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Aggregator->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Result == S_FALSE )
					{
						t_Result = t_Element->QueryInterface (

							a_RIID ,
							a_Interface
						) ;

						t_Aggregator->Release () ;
						t_Element->Release () ;
						return t_Result ;
					}

					if ( SUCCEEDED ( t_Result = t_Aggregator->GetInitializeResult () ) )
					{
						t_Result = t_Element->QueryInterface (

							a_RIID ,
							a_Interface
						) ;

						if ( FAILED ( t_Result ) )
						{
							t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
						}
					}
					else
					{
						t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
					}
				}

				t_Aggregator->Release () ;
			}
			else
			{
				t_Result = WBEM_E_UNEXPECTED ;
			}

			t_Element->Release () ;
		}
		else
		{
			BOOL t_ReEntrancy = ( a_Registration.GetInitializationReentrancy () == e_InitializationReentrancy_Clsid ) ;
			t_ReEntrancy = t_ReEntrancy || ( a_Registration.GetInitializationReentrancy () == e_InitializationReentrancy_Namespace ) ;

			CDecoupledAggregator_IWbemProvider *t_InitializingAggregator = NULL ;

			BOOL t_IndependantCall = TRUE ;

			if ( t_ReEntrancy )
			{
				CWbemGlobal_IWmiProviderController_Cache *t_Cache = NULL ;
				GetCache ( t_Cache ) ;

				CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator = t_Cache->Begin ();

				while ( ! t_Iterator.Null () )
				{
					ServiceCacheElement *t_Element = t_Iterator.GetElement () ;

					BOOL t_Equivalent = ( a_Key.m_Provider ) && ( t_Iterator.GetKey ().m_Provider ) && ( wcscmp ( a_Key.m_Provider , t_Iterator.GetKey ().m_Provider ) == 0 ) ;
					if ( t_Equivalent )
					{
						t_Result = t_Element->QueryInterface (

							IID_CDecoupledAggregator_IWbemProvider ,
							( void ** ) & t_InitializingAggregator
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_InitializingAggregator->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_Result == S_FALSE )
								{
									t_IndependantCall = FALSE ;
								}
							}

							break ;
						}
					}

					t_Iterator.Increment () ;
				}
			}

			wchar_t *t_NamespacePath = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: GetNamespacePath ( 

				Direct_GetNamespacePath () , 
				t_NamespacePath
			) ;

			if ( SUCCEEDED ( t_Result ) ) 
			{
				CInterceptor_IWbemServices_Interceptor *t_RepositoryStub = new CInterceptor_IWbemServices_Interceptor ( m_Allocator , a_RepositoryService ) ;
				if ( t_RepositoryStub )
				{
					t_RepositoryStub->AddRef () ;

					CInterceptor_IWbemServices_Interceptor *t_FullStub = new CInterceptor_IWbemServices_Interceptor ( m_Allocator , a_FullService ) ;
					if ( t_FullStub )
					{
						t_FullStub->AddRef () ;

						CDecoupledAggregator_IWbemProvider *t_Aggregator = NULL ;

						try
						{
							t_Aggregator = new CDecoupledAggregator_IWbemProvider ( 

								m_Allocator , 
								this , 
								this ,
								t_RepositoryStub ,
								t_FullStub ,
								a_Key ,
								ProviderSubSystem_Globals :: s_InternalCacheTimeout ,
								a_Context ,
								a_Registration
							) ;

							if ( t_Aggregator == NULL ) 
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						catch ( Wmi_Heap_Exception &a_Exception )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Aggregator->AddRef () ;

							_IWmiProviderInitialize *t_AggregatorInit = NULL ;
							t_Result = t_Aggregator->QueryInterface ( IID__IWmiProviderInitialize , ( void ** ) & t_AggregatorInit ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
								if ( t_ProviderInitSink )
								{
									t_ProviderInitSink->AddRef () ;

									t_Result = t_ProviderInitSink->SinkInitialize () ;
									if ( SUCCEEDED ( t_Result ) ) 
									{
										CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
										if ( t_Sink )
										{
											t_Sink->AddRef () ;

											t_Result = t_AggregatorInit->Initialize (

												0 ,
												a_Context ,
												NULL ,
												( const BSTR ) a_User ,
												( const BSTR ) a_Locale ,
												( const BSTR ) t_NamespacePath ,
												t_RepositoryStub ,
												t_FullStub ,
												t_Sink
											) ;

											if ( SUCCEEDED ( t_Result ) )
											{
												t_ProviderInitSink->Wait () ;

												t_Result = t_ProviderInitSink->GetResult () ;
												if ( SUCCEEDED ( t_Result ) )
												{
												}
											}

											t_Sink->Release () ; 
										}
										else
										{
											t_Result = WBEM_E_OUT_OF_MEMORY ;
										}
									}

									t_ProviderInitSink->Release () ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}


								t_AggregatorInit->Release () ;
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_IndependantCall )
								{
									WmiStatusCode t_StatusCode = Insert ( 

										*t_Aggregator ,
										t_Iterator
									) ;

									if ( t_StatusCode == e_StatusCode_Success ) 
									{
										UnLock () ;

										if ( t_InitializingAggregator )
										{
											t_Result = t_InitializingAggregator->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
											if ( SUCCEEDED ( t_Result ) )
											{
												if ( t_Result == S_FALSE )
												{
												}
												else
												{
													if ( SUCCEEDED ( t_Result = t_InitializingAggregator->GetInitializeResult () ) )
													{
													}
													else
													{
														t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
													}	
												}
											}
										}

										if ( SUCCEEDED ( t_Result ) )
										{
											t_Result = Load (

												t_Aggregator ,
												a_Context ,
												( BSTR ) a_Name ,
												( BSTR ) ( a_Registration.PerUserInitialization () ? a_User : NULL ) ,
												( BSTR ) ( a_Registration.PerLocaleInitialization () ? a_Locale : NULL ) ,
												( BSTR ) t_NamespacePath
											) ;

											if ( SUCCEEDED ( t_Result ) )
											{
												t_Result = t_Aggregator->QueryInterface (

													a_RIID ,
													a_Interface
												) ;
											}

											if ( FAILED ( t_Result ) )
											{
												WmiStatusCode t_StatusCode = CWbemGlobal_IWmiProviderController :: Shutdown ( a_Key ) ; 

												t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
											}
										}

										t_Aggregator->SetInitialized ( t_Result ) ;
									}
									else
									{
										UnLock () ;
									}
								}
								else
								{
									UnLock () ;

									t_Result = t_Aggregator->QueryInterface (

										a_RIID ,
										a_Interface
									) ;
								}
							}
							else
							{
								UnLock () ;
							}

							t_Aggregator->Release () ;
						}
						else
						{
							UnLock () ;
						}

						t_FullStub->Release () ;
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					t_RepositoryStub->Release () ;
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				delete [] t_NamespacePath ;
			}
			else
			{
				UnLock () ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			if ( t_InitializingAggregator )
			{
				t_InitializingAggregator->Release () ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: GetDecoupledProvider (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope,
	LPCWSTR a_Name ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		IWbemPath *t_Scope = NULL ;

		if ( a_Scope ) 
		{
			t_Result = CoCreateInstance (

				CLSID_WbemDefPath ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IWbemPath ,
				( void ** )  & t_Scope
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Scope->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Scope ) ;
			}
		}

		CServerObject_ProviderSubSystem *t_SubSystem = NULL ;
		IWbemServices *t_RepositoryService = NULL ;
		IWbemServices *t_FullService = NULL ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = Direct_GetSubSystem ()->QueryInterface ( IID_CWbemProviderSubSystem , ( void ** ) & t_SubSystem ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_SubSystem->GetWmiRepositoryService ( 
				
					Direct_GetNamespacePath () , 
					( const BSTR ) a_User ,
					( const BSTR ) a_Locale ,
					t_RepositoryService
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = t_SubSystem->GetWmiService ( 
					
						Direct_GetNamespacePath () , 
						( const BSTR ) a_User ,
						( const BSTR ) a_Locale ,
						t_FullService
					) ;
				}
			}
		}

		CServerObject_ProviderRegistrationV1 *t_Registration = new CServerObject_ProviderRegistrationV1 ;
		if ( t_Registration )
		{
			t_Registration->AddRef () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Registration->SetContext ( 

				a_Context ,
				Direct_GetNamespacePath () , 
				t_RepositoryService
			) ;
			
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_InternalCacheTimeout ) ;

				t_Result = t_Registration->Load ( 

					e_All ,
					t_Scope , 
					a_Name
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Registration->GetComRegistration ().Enabled () ) 
					{
						if ( ProviderSubSystem_Globals :: CheckGuidTag ( t_Registration->GetClsid () ) )
						{
							t_Result = WBEM_E_PROVIDER_DISABLED ;
						}
					}
					else
					{
						t_Result = WBEM_E_PROVIDER_DISABLED ;
					}
				}
				else
				{
					if ( t_Result == WBEM_E_NOT_FOUND )
					{
						t_Result = WBEM_E_PROVIDER_NOT_FOUND ;
					}	
					else
					{
						t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
					}
				}
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			try
			{
				ProviderCacheKey t_Key ( 

					a_Name , 
					e_Hosting_Decoupled ,
					NULL ,
					true ,
					NULL ,
					a_User ,
					a_Locale 
				) ;

				t_Result = InternalFindAggregatedDecoupledProvider ( 

					t_RepositoryService ,
					t_FullService ,
					*t_Registration ,
					t_Key ,
					a_Flags ,
					a_Context ,
					a_User ,
					a_Locale ,
					a_Scope,
					a_Name ,
					a_RIID , 
					a_Interface 
				) ;
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( t_Scope )
		{
			t_Scope->Release () ;
		}

		if ( t_RepositoryService )
		{
			t_RepositoryService->Release () ;
		}

		if ( t_FullService )
		{
			t_FullService->Release () ;
		}

		if ( t_SubSystem )
		{
			t_SubSystem->Release () ;
		}

		if ( t_Registration )
		{
			t_Registration->Release () ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: InternalGetProvider ( 

	IWbemServices *a_RepositoryService ,
	IWbemServices *a_FullService ,
	_IWmiProviderHost *a_Host ,
	_IWmiProviderFactory *a_Factory ,
	CInterceptor_IWbemProvider *a_Interceptor ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	ProviderCacheKey &a_Key ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	LPCWSTR a_Name ,
	void **a_Unknown ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		DWORD t_ProcessIdentifier = 0 ;
		if ( a_Host )
		{
			t_Result = a_Host->GetProcessIdentifier ( & t_ProcessIdentifier ) ;
		}

		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				HANDLE t_IdentifyHandle = NULL ;

				switch ( a_Registration.GetHosting () )
				{
					case e_Hosting_SharedLocalSystemHost:
					case e_Hosting_SharedLocalSystemHostOrSelfHost:
					{
						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
						
							IID__IWmiProviderFactory , 
							a_Factory , 
							t_Proxy , 
							t_Revert , 
							t_ProcessIdentifier , 
							t_IdentifyHandle ,
							ProviderSubSystem_Common_Globals :: s_Token_All_Access_System_ACE ,
							ProviderSubSystem_Common_Globals :: s_System_ACESize
						) ;
					}
					break ;

					case e_Hosting_SharedLocalServiceHost:
					{
						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
						
							IID__IWmiProviderFactory , 
							a_Factory , 
							t_Proxy , 
							t_Revert , 
							t_ProcessIdentifier , 
							t_IdentifyHandle ,
							ProviderSubSystem_Common_Globals :: s_Token_All_Access_LocalService_ACE ,
							ProviderSubSystem_Common_Globals :: s_LocalService_ACESize
						) ;
					}
					break ;

					case e_Hosting_SharedNetworkServiceHost:
					{
						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
						
							IID__IWmiProviderFactory , 
							a_Factory , 
							t_Proxy , 
							t_Revert , 
							t_ProcessIdentifier , 
							t_IdentifyHandle ,
							ProviderSubSystem_Common_Globals :: s_Token_All_Access_NetworkService_ACE ,
							ProviderSubSystem_Common_Globals :: s_NetworkService_ACESize
	 					) ;
					}
					break ;

					default:
					{
						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
						
							IID__IWmiProviderFactory , 
							a_Factory , 
							t_Proxy , 
							t_Revert
						) ;
					}
					break ;
				}

				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					WmiInternalContext t_InternalContext ;
					ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

					t_Result = a_Factory->GetProvider ( 

						t_InternalContext ,
						a_Flags ,
						a_Context ,
						a_TransactionIdentifier ,
						a_User ,
						a_Locale ,
						a_Scope ,
						a_Name ,
						IID_IUnknown , 
						a_Unknown
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						_IWmiProviderFactory *t_FactoryProxy = ( _IWmiProviderFactory * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_FactoryProxy ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							IUnknown *t_Unknown = NULL ;

							WmiInternalContext t_InternalContext ;
							t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyHandle ;
							t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

							t_Result = t_FactoryProxy->GetProvider ( 

								t_InternalContext ,
								a_Flags ,
								a_Context ,
								a_TransactionIdentifier ,
								a_User ,
								a_Locale ,
								a_Scope ,
								a_Name ,
								IID_IUnknown , 
								a_Unknown
							) ;
						}

						if ( t_IdentifyHandle )
						{
							HRESULT t_Result = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 
							
								t_Proxy , 
								t_Revert ,
								t_ProcessIdentifier , 
								t_IdentifyHandle
							) ;
						}
						else
						{
							HRESULT t_Result = ProviderSubSystem_Common_Globals :: RevertProxyState ( 
							
								t_Proxy , 
								t_Revert
							) ;
						}
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: InternalGetProviderViaProxyRoute ( 

	IWbemServices *a_RepositoryService ,
	IWbemServices *a_FullService ,
	CInterceptor_IWbemProvider *a_Interceptor ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	Enum_Hosting a_Hosting ,
	LPCWSTR a_HostingGroup ,
	ProviderCacheKey &a_Key ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	LPCWSTR a_Name ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		_IWmiProviderHost *t_Host = NULL ;
		_IWmiProviderFactory *t_Factory = NULL ;

		t_Result = Create (

			a_Registration ,
			a_Hosting ,
			a_HostingGroup ,
			a_User ,
			& t_Host ,
			& t_Factory 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			_IWmiProviderFactoryInitialize *t_Initializer = NULL ;

			t_Result = t_Factory->QueryInterface ( IID__IWmiProviderFactoryInitialize , ( void ** ) & t_Initializer ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
#ifdef INTERNAL_IDENTIFY
				CInterceptor_IWbemServices_Stub *t_RepositoryStub = new CInterceptor_IWbemServices_Stub (
				
					NULL ,
					m_Allocator , 
					a_RepositoryService
				) ;
#else
				CInterceptor_IWbemServices_Interceptor *t_RepositoryStub = new CInterceptor_IWbemServices_Interceptor (
				
					m_Allocator , 
					a_RepositoryService
				) ;
#endif

				if ( t_RepositoryStub )
				{
					t_RepositoryStub->AddRef () ;

					t_Result = t_RepositoryStub->ServiceInitialize () ;
					if ( SUCCEEDED ( t_Result ) )
					{
#ifdef INTERNAL_IDENTIFY
						CInterceptor_IWbemServices_Stub *t_FullStub = new CInterceptor_IWbemServices_Stub (
						
							NULL ,
							m_Allocator , 
							a_FullService
						) ;
#else
						CInterceptor_IWbemServices_Interceptor *t_FullStub = new CInterceptor_IWbemServices_Interceptor (
						
							m_Allocator , 
							a_FullService
						) ;
#endif

						if ( t_FullStub )
						{
							t_FullStub->AddRef () ;

							t_Result = t_FullStub->ServiceInitialize () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Initializer->Initialize (

									NULL ,
									this ,
									a_Flags ,
									a_Context ,
									Direct_GetNamespace () ,
									t_RepositoryStub ,
									t_FullStub 
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									IUnknown *t_Unknown = NULL ;

									t_Result = InternalGetProvider ( 

										t_RepositoryStub ,
										t_FullStub ,
										t_Host ,
										t_Factory ,
										a_Interceptor ,
										a_Registration ,
										a_Key ,
										a_Flags ,
										a_Context ,
										a_TransactionIdentifier ,
										a_User ,
										a_Locale ,
										a_Scope ,
										a_Name ,
										( void ** ) & t_Unknown ,
										a_RIID , 
										a_Interface 
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										t_Result = a_Interceptor->SetProvider ( t_Host , t_Unknown ) ;
										if ( SUCCEEDED ( t_Result )	)
										{
											t_Result = InitializeHostedService (

												a_Interceptor ,
												t_Unknown
											) ;

											if ( SUCCEEDED ( t_Result ) )
											{
												t_Result = a_Interceptor->QueryInterface (

													a_RIID ,
													a_Interface
												) ;

												if ( FAILED ( t_Result ) )
												{
													t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
												}
											}
										}

										t_Unknown->Release () ;
									}
								}
							}

							t_FullStub->Release () ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_RepositoryStub->Release () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				t_Initializer->Release () ;
			}

			if ( t_Host )
			{
				t_Host->Release () ;
			}

			t_Factory->Release () ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: InternalFindProvider ( 

	IWbemServices *a_RepositoryService ,
	IWbemServices *a_FullService ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	Enum_Hosting a_Hosting ,
	LPCWSTR a_HostingGroup ,
	ProviderCacheKey &a_Key ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	LPCWSTR a_Name ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Find ( a_Key , t_Iterator ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			ServiceCacheElement *t_Element = t_Iterator.GetElement () ;

			UnLock () ;

			CInterceptor_IWbemProvider *t_Interceptor = NULL ;

			t_Result = t_Element->QueryInterface (

				IID_CInterceptor_IWbemProvider ,
				( void ** ) & t_Interceptor
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interceptor->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Result == S_FALSE )
					{
						t_Result = t_Element->QueryInterface (

							a_RIID ,
							a_Interface
						) ;

						t_Interceptor->Release () ;
						t_Element->Release () ;

						return t_Result ;
					}

					if ( SUCCEEDED ( t_Result = t_Interceptor->GetInitializeResult () ) )
					{
						t_Result = t_Element->QueryInterface (

							a_RIID ,
							a_Interface
						) ;

						if ( FAILED ( t_Result ) )
						{
							t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
						}
					}
					else
					{
						t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
					}
				}

				t_Interceptor->Release () ;
			}
			else
			{
				t_Result = WBEM_E_UNEXPECTED ;
			}

			t_Element->Release () ;
		}
		else
		{
			BOOL t_ReEntrancy = ( a_Registration.GetInitializationReentrancy () == e_InitializationReentrancy_Clsid ) ;
			t_ReEntrancy = t_ReEntrancy || ( a_Registration.GetInitializationReentrancy () == e_InitializationReentrancy_Namespace ) ;

			CInterceptor_IWbemProvider *t_InitializingInterceptor = NULL ;

			BOOL t_IndependantCall = TRUE ;

			if ( t_ReEntrancy )
			{
				CWbemGlobal_IWmiProviderController_Cache *t_Cache = NULL ;
				GetCache ( t_Cache ) ;

				CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator = t_Cache->Begin ();

				while ( ! t_Iterator.Null () )
				{
					ServiceCacheElement *t_Element = t_Iterator.GetElement () ;

					BOOL t_Equivalent = ( a_Key.m_Provider ) && ( t_Iterator.GetKey ().m_Provider ) && ( wcscmp ( a_Key.m_Provider , t_Iterator.GetKey ().m_Provider ) == 0 ) ;
					if ( t_Equivalent )
					{
						t_Result = t_Element->QueryInterface (

							IID_CInterceptor_IWbemProvider ,
							( void ** ) & t_InitializingInterceptor
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_InitializingInterceptor->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_Result == S_FALSE )
								{
									t_IndependantCall = FALSE ;
								}
							}

							break ;
						}
					}

					t_Iterator.Increment () ;
				}
			}

			CInterceptor_IWbemProvider *t_Interceptor = NULL ;

			try
			{
				t_Interceptor = new CInterceptor_IWbemProvider ( 

					m_Allocator , 
					this , 
					a_Key ,
					a_Registration.GetUnloadTimeoutMilliSeconds () ,
					a_Context ,
					a_Registration
				) ;

				if ( t_Interceptor ) 
				{
					t_Interceptor->AddRef () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemProviderInit *t_InterceptorInit = NULL ;

				t_Result = t_Interceptor->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & t_InterceptorInit ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
					if ( t_ProviderInitSink )
					{
						t_ProviderInitSink->AddRef () ;

						t_Result = t_ProviderInitSink->SinkInitialize () ;
						if ( SUCCEEDED ( t_Result ) ) 
						{
							CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
							if ( t_Sink )
							{
								t_Sink->AddRef () ;

								t_Result = t_InterceptorInit->Initialize (

									NULL ,
									0 ,
									m_Namespace ,
									NULL ,
									NULL ,
									NULL ,
									t_Sink    
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_ProviderInitSink->Wait () ;

									t_Result = t_ProviderInitSink->GetResult () ;
								}

								t_Sink->Release () ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}

						t_ProviderInitSink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					t_InterceptorInit->Release () ;
				}
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IndependantCall )
				{
					WmiStatusCode t_StatusCode = Insert ( 

						*t_Interceptor ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

#if 0 
DebugMacro0(

	WmiDebugLog :: s_WmiDebugLog->Write (

		L"CServerObject_BindingFactory :: InternalFindProvider, inserted provider (%s,%s),(%lx)\n" , 
		m_Namespace , 
		a_Key.m_Provider ? a_Key.m_Provider : L"" , 
		t_Interceptor
	) ;
)
#endif

						t_Result = InternalGetProviderViaProxyRoute ( 

							a_RepositoryService ,
							a_FullService ,
							t_Interceptor ,
							a_Registration ,
							a_Hosting ,
							a_HostingGroup ,
							a_Key ,
							a_Flags ,
							a_Context ,
							a_TransactionIdentifier ,
							a_User ,
							a_Locale ,
							a_Scope ,
							a_Name ,
							a_RIID , 
							a_Interface 
						) ;

						if ( FAILED ( t_Result ) )
						{
							WmiStatusCode t_StatusCode = CWbemGlobal_IWmiProviderController :: Shutdown ( a_Key ) ; 
						}

						t_Interceptor->SetInitialized ( t_Result ) ;
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = t_Interceptor->QueryInterface (

						a_RIID ,
						a_Interface
					) ;
				}
			}
			else
			{
				UnLock () ;
			}

			if ( t_Interceptor )
			{
				t_Interceptor->Release () ;
			}

			if ( t_InitializingInterceptor )
			{
				t_InitializingInterceptor->Release () ;
			}
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: GetProvider ( 

	WmiInternalContext a_InternalContext ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	LPCWSTR a_Name ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		ProviderCacheKey t_Key ( 

			a_Name , 
			e_Hosting_SharedNetworkServiceHost ,
			CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedNetworkServiceHost ,
			true ,
			a_TransactionIdentifier ,
			NULL ,
			NULL
		) ;

		t_Result = FindProvider (

			a_Context ,
			t_Key , 
			FALSE ,
			a_RIID , 
			a_Interface ,
			a_User ,
			a_Locale
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
		}
		else
		{
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				CServerObject_ProviderSubSystem *t_SubSystem = NULL ;
				IWbemServices *t_RepositoryService = NULL ;
				IWbemServices *t_FullService = NULL ;

				t_Result = Direct_GetSubSystem ()->QueryInterface ( IID_CWbemProviderSubSystem , ( void ** ) & t_SubSystem ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_SubSystem->GetWmiRepositoryService (
					
						Direct_GetNamespacePath () , 
						( const BSTR ) a_User ,
						( const BSTR ) a_Locale ,
						t_RepositoryService
					) ;

					if ( SUCCEEDED ( t_Result ) ) 
					{
						t_Result = t_SubSystem->GetWmiService (
						
							Direct_GetNamespacePath () ,
							( const BSTR ) a_User ,
							( const BSTR ) a_Locale ,
							t_FullService
						) ;
					}
				}

				IWbemContext *t_Context = NULL ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_Context == NULL )
					{
						t_Result = CoCreateInstance (

							CLSID_WbemContext ,
							NULL ,
							CLSCTX_INPROC_SERVER ,
							IID_IWbemContext ,
							( void ** )  & t_Context
						) ;
					}
				}

				IWbemPath *t_Scope = NULL ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_Scope ) 
					{
						t_Result = CoCreateInstance (

							CLSID_WbemDefPath ,
							NULL ,
							CLSCTX_INPROC_SERVER ,
							IID_IWbemPath ,
							( void ** )  & t_Scope
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Scope->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Scope ) ;
						}
					}
				}

				CServerObject_ProviderRegistrationV1 *t_Registration = new CServerObject_ProviderRegistrationV1 ;
				if ( t_Registration )
				{
					t_Registration->AddRef () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
					
				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = t_Registration->SetContext ( 

						a_Context ? a_Context : t_Context ,
						Direct_GetNamespacePath () , 
						t_RepositoryService
					) ;
					
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Registration->Load ( 

							e_All ,
							t_Scope , 
							a_Name
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_Registration->GetComRegistration ().Enabled () ) 
							{
								if ( ProviderSubSystem_Globals :: CheckGuidTag ( t_Registration->GetClsid () ) )
								{
									t_Result = WBEM_E_PROVIDER_DISABLED ;
								}
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND )
							{
								t_Result = WBEM_E_PROVIDER_NOT_FOUND ;
							}	
							else
							{
								t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
							}
						}

						if ( t_Registration->ObjectProvider () )
						{
							if ( t_Registration->EventProvider () )
							{
								t_Registration->SetUnloadTimeoutMilliSeconds (
								
									ProviderSubSystem_Globals :: s_ObjectCacheTimeout < ProviderSubSystem_Globals :: s_EventCacheTimeout ? 
									
										ProviderSubSystem_Globals :: s_EventCacheTimeout :	ProviderSubSystem_Globals :: s_ObjectCacheTimeout
								) ;
							}
							else
							{
								t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_ObjectCacheTimeout ) ;
							}
						}
						else
						{
							if ( t_Registration->EventProvider () )
							{
								t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_EventCacheTimeout ) ;
							}
						}
					}
				}

				if ( t_Scope ) 
				{
					t_Scope->Release () ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					LPCWSTR t_HostingGroup = NULL ;
					Enum_Hosting t_Hosting = e_Hosting_Undefined ;
					t_Result = GetHosting ( *t_Registration , a_Context ? a_Context : t_Context , t_Hosting , t_HostingGroup ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						try
						{
							ProviderCacheKey t_Key ( 

								a_Name , 
								t_Hosting ,
								t_HostingGroup ,
								true ,
								a_TransactionIdentifier ,
								t_Registration->PerUserInitialization () ? a_User : NULL ,
								t_Registration->PerLocaleInitialization () ? a_Locale : NULL
							) ;

							switch ( t_Hosting )
							{
								case e_Hosting_Decoupled:
								{
									t_Result = InternalFindAggregatedDecoupledProvider ( 

										t_RepositoryService ,
										t_FullService ,
										*t_Registration ,
										t_Key ,
										a_Flags ,
										a_Context ? a_Context : t_Context ,
										a_User ,
										a_Locale ,
										a_Scope,
										a_Name ,
										a_RIID , 
										a_Interface 
									) ;
								}
								break ;

								default:
								{
									t_Result = InternalFindProvider ( 

										t_RepositoryService ,
										t_FullService ,
										*t_Registration ,
										t_Hosting ,
										t_HostingGroup ,
										t_Key ,
										a_Flags ,
										a_Context ? a_Context : t_Context ,
										a_TransactionIdentifier ,
										a_User ,
										a_Locale ,
										a_Scope ,
										a_Name ,
										a_RIID , 
										a_Interface 
									) ;
								}
								break;
							}
						}
						catch ( Wmi_Heap_Exception &a_Exception )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
						catch ( Wmi_Structured_Exception t_StructuredException )
						{
							t_Result = WBEM_E_FAILED ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
						}
						catch ( ... )
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
				}

				if ( t_RepositoryService )
				{
					t_RepositoryService->Release () ;
				}

				if ( t_FullService )
				{
					t_FullService->Release () ;
				}

				if ( t_SubSystem )
				{
					t_SubSystem->Release () ;
				}

				if ( t_Registration )
				{
					t_Registration->Release () ;
				}

				if ( t_Context )
				{
					t_Context->Release () ;
				}
			}
		}
	}
	catch ( Wmi_Heap_Exception &a_Exception )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_FAILED ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: GetHostedProvider ( 

	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	LPCWSTR a_Name ,
	ULONG a_Host ,
	LPCWSTR a_HostingGroup ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		ProviderCacheKey t_Key ( 

			a_Name , 
			a_Host ,
			a_HostingGroup ,
			true ,
			a_TransactionIdentifier ,
			NULL ,
			NULL
		) ;

		t_Result = FindProvider (

			a_Context ,
			t_Key , 
			TRUE ,
			a_RIID , 
			a_Interface ,
			a_User ,
			a_Locale
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
		}
		else
		{
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				CServerObject_ProviderSubSystem *t_SubSystem = NULL ;
				IWbemServices *t_RepositoryService = NULL ;
				IWbemServices *t_FullService = NULL ;

				t_Result = Direct_GetSubSystem ()->QueryInterface ( IID_CWbemProviderSubSystem , ( void ** ) & t_SubSystem ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_SubSystem->GetWmiRepositoryService (
					
						Direct_GetNamespacePath () , 
						( const BSTR ) a_User ,
						( const BSTR ) a_Locale ,
						t_RepositoryService
					) ;

					if ( SUCCEEDED ( t_Result ) ) 
					{
						t_Result = t_SubSystem->GetWmiService (
						
							Direct_GetNamespacePath () ,
							( const BSTR ) a_User ,
							( const BSTR ) a_Locale ,
							t_FullService
						) ;
					}
				}

				IWbemPath *t_Scope = NULL ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_Scope ) 
					{
						t_Result = CoCreateInstance (

							CLSID_WbemDefPath ,
							NULL ,
							CLSCTX_INPROC_SERVER ,
							IID_IWbemPath ,
							( void ** )  & t_Scope
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Scope->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Scope ) ;
						}
					}
				}

				CServerObject_ProviderRegistrationV1 *t_Registration = new CServerObject_ProviderRegistrationV1 ;
				if ( t_Registration )
				{
					t_Registration->AddRef () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
					
				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = t_Registration->SetContext ( 

						a_Context ,
						Direct_GetNamespacePath () , 
						t_RepositoryService
					) ;
					
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Registration->Load ( 

							e_All ,
							t_Scope , 
							a_Name
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_Registration->GetComRegistration ().Enabled () ) 
							{
								if ( ProviderSubSystem_Globals :: CheckGuidTag ( t_Registration->GetClsid () ) )
								{
									t_Result = WBEM_E_PROVIDER_DISABLED ;
								}
							}

							if ( t_Registration->ObjectProvider () )
							{
								if ( t_Registration->EventProvider () )
								{
									t_Registration->SetUnloadTimeoutMilliSeconds (
									
										ProviderSubSystem_Globals :: s_ObjectCacheTimeout < ProviderSubSystem_Globals :: s_EventCacheTimeout ? 
										
											ProviderSubSystem_Globals :: s_EventCacheTimeout :	ProviderSubSystem_Globals :: s_ObjectCacheTimeout
									) ;
								}
								else
								{
									t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_ObjectCacheTimeout ) ;
								}
							}
							else
							{
								if ( t_Registration->EventProvider () )
								{
									t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_EventCacheTimeout ) ;
								}
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND )
							{
								t_Result = WBEM_E_PROVIDER_NOT_FOUND ;
							}	
							else
							{
								t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
							}
						}
					}
				}

				if ( t_Scope ) 
				{
					t_Scope->Release () ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					try
					{
						ProviderCacheKey t_Key ( 

							a_Name , 
							a_Host ,
							a_HostingGroup ,
							true ,
							a_TransactionIdentifier ,
							t_Registration->PerUserInitialization () ? a_User : NULL ,
							t_Registration->PerLocaleInitialization () ? a_Locale : NULL
						) ;

						switch ( a_Host )
						{
							case e_Hosting_Decoupled:
							{
								t_Result = InternalFindAggregatedDecoupledProvider ( 

									t_RepositoryService ,
									t_FullService ,
									*t_Registration ,
									t_Key ,
									a_Flags ,
									a_Context ,
									a_User ,
									a_Locale ,
									a_Scope,
									a_Name ,
									a_RIID , 
									a_Interface 
								) ;
							}
							break ;

							default:
							{
								t_Result = InternalFindProvider ( 

									t_RepositoryService ,
									t_FullService ,
									*t_Registration ,
									( Enum_Hosting ) a_Host ,
									a_HostingGroup ,
									t_Key ,
									a_Flags ,
									a_Context ,
									a_TransactionIdentifier ,
									a_User ,
									a_Locale ,
									a_Scope ,
									a_Name ,
									a_RIID	 , 
									a_Interface 
								) ;
							}
							break;
						}
					}
					catch ( Wmi_Heap_Exception &a_Exception )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
					catch ( Wmi_Structured_Exception t_StructuredException )
					{
						t_Result = WBEM_E_FAILED ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
					}
					catch ( ... )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}

				if ( t_RepositoryService )
				{
					t_RepositoryService->Release () ;
				}

				if ( t_FullService )
				{
					t_FullService->Release () ;
				}

				if ( t_SubSystem )
				{
					t_SubSystem->Release () ;
				}

				if ( t_Registration )
				{
					t_Registration->Release () ;
				}
			}
		}
	}
	catch ( Wmi_Heap_Exception &a_Exception )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_FAILED ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: GetAggregatedClassProvider ( 

	IWbemServices *a_RepositoryService ,
	IWbemServices *a_FullService ,
	ProviderCacheKey &a_Key ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	IWbemClassObject *a_Class ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		Lock () ;

		CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator ;

		WmiStatusCode t_StatusCode = Find ( a_Key , t_Iterator ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			ServiceCacheElement *t_Element = t_Iterator.GetElement () ;

			UnLock () ;

			CAggregator_IWbemProvider *t_Aggregator = NULL ;

			t_Result = t_Element->QueryInterface (

				IID_CAggregator_IWbemProvider ,
				( void ** ) & t_Aggregator
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
#if 0
DebugMacro0(

	WmiDebugLog :: s_WmiDebugLog->Write (

		L"CServerObject_BindingFactory :: GetAggregatedClassProvider, found class aggregator,(%s,%lx)\n" , 
		m_Namespace , 
		t_Aggregator
	) ;
)
#endif


				t_Result = t_Aggregator->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Result == S_FALSE )
					{
						t_Result = t_Element->QueryInterface (

							a_RIID ,
							a_Interface
						) ;

						t_Aggregator->Release () ;
						t_Element->Release () ;

						return t_Result ;
					}

					if ( SUCCEEDED ( t_Result = t_Aggregator->GetInitializeResult () ) )
					{
						t_Result = t_Element->QueryInterface (

							a_RIID ,
							a_Interface
						) ;

						if ( FAILED ( t_Result ) )
						{
							t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
						}
					}
					else
					{
						t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
					}
				}

				t_Aggregator->Release () ;
			}
			else
			{
				t_Result = WBEM_E_UNEXPECTED ;
			}

			t_Element->Release () ;
		}
		else
		{
			CAggregator_IWbemProvider *t_Aggregator = NULL ;

			CInterceptor_IWbemServices_Interceptor *t_RepositoryStub = new CInterceptor_IWbemServices_Interceptor ( m_Allocator , a_RepositoryService ) ;
			if ( t_RepositoryStub )
			{
				t_RepositoryStub->AddRef () ;

				CInterceptor_IWbemServices_Interceptor *t_FullStub = new CInterceptor_IWbemServices_Interceptor ( m_Allocator , a_FullService ) ;
				if ( t_FullStub )
				{
					t_FullStub->AddRef () ;

					t_Aggregator = new CAggregator_IWbemProvider ( 

						m_Allocator , 
						this , 
						this ,
						t_RepositoryStub ,
						t_FullStub ,
						a_Key ,
						ProviderSubSystem_Globals :: s_InternalCacheTimeout ,
						a_Context 
					) ;

					if ( t_Aggregator ) 
					{
						t_Aggregator->AddRef () ;

						wchar_t *t_NamespacePath = NULL ;

						t_Result = ProviderSubSystem_Common_Globals :: GetNamespacePath ( 

							Direct_GetNamespacePath () , 
							t_NamespacePath
						) ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							_IWmiProviderInitialize *t_AggregatorInit = NULL ;
							t_Result = t_Aggregator->QueryInterface ( IID__IWmiProviderInitialize , ( void ** ) & t_AggregatorInit ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
								if ( t_ProviderInitSink )
								{
									t_ProviderInitSink->AddRef () ;

									t_Result = t_ProviderInitSink->SinkInitialize () ;
									if ( SUCCEEDED ( t_Result ) ) 
									{
										CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
										if ( t_Sink )
										{
											t_Sink->AddRef () ;

											t_Result = t_AggregatorInit->Initialize (

												0 ,
												a_Context ,
												NULL ,
												( const BSTR ) a_User ,
												( const BSTR ) a_Locale ,
												( const BSTR ) t_NamespacePath ,
												t_RepositoryStub ,
												t_FullStub ,
												t_Sink
											) ;

											if ( SUCCEEDED ( t_Result ) )
											{
												t_ProviderInitSink->Wait () ;

												t_Result = t_ProviderInitSink->GetResult () ;
											}

											t_Sink->Release () ;
										}
										else
										{
											t_Result = WBEM_E_OUT_OF_MEMORY ;
										}
									}

									t_ProviderInitSink->Release () ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								t_AggregatorInit->Release () ;
							}

							delete [] t_NamespacePath ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					t_FullStub->Release () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				t_RepositoryStub->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				WmiStatusCode t_StatusCode = Insert ( 

					*t_Aggregator ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

#if 0
DebugMacro0(

	WmiDebugLog :: s_WmiDebugLog->Write (

		L"CServerObject_BindingFactory :: GetAggregatedClassProvider, inserted class aggregator,(%s,%lx)\n" , 
		m_Namespace , 
		t_Aggregator
	) ;
)
#endif

					t_Result = t_Aggregator->Enum_ClassProviders ( a_Context ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Aggregator->QueryInterface (

							a_RIID ,
							a_Interface
						) ;

						if ( FAILED ( t_Result ) )
						{
							t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
						}
					}

					t_Aggregator->SetInitialized ( t_Result ) ;
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				UnLock () ;
			}

			if ( t_Aggregator )
			{
				t_Aggregator->Release () ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: WaitProvider ( 

	IWbemContext *a_Context ,
	REFIID a_RIID , 
	void **a_Interface ,
	ServiceCacheElement *a_Element ,
	_IWmiProviderInitialize *a_Initializer 
)
{
	HRESULT t_Result = a_Initializer->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Result == S_FALSE )
		{
			t_Result = a_Element->QueryInterface (

				a_RIID ,
				a_Interface
			) ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result = a_Initializer->GetInitializeResult () ) )
			{
				t_Result = a_Element->QueryInterface (

					a_RIID ,
					a_Interface
				) ;

				if ( FAILED ( t_Result ) )
				{
					t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
				}
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: SearchSpecificProvider ( 

	IWbemContext *a_Context ,
	ProviderCacheKey &a_Key ,
	REFIID a_RIID , 
	void **a_Interface ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProviderController_Cache *t_Cache = NULL ;
	GetCache ( t_Cache ) ;

	CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator ;

	try
	{
		ProviderCacheKey t_Key ( 

			a_Key.m_Provider , 
			e_Hosting_Undefined ,
			NULL ,
			false ,
			NULL ,
			NULL ,
			NULL
		) ;

		WmiStatusCode t_StatusCode = t_Cache->FindNext ( t_Key , t_Iterator ) ;
		if ( t_StatusCode != e_StatusCode_Success )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}
	catch ( Wmi_Heap_Exception &a_Exception )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		BOOL t_Equal = FALSE ;

		if ( t_Iterator.GetKey ().m_Provider )
		{
			if ( a_Key.m_Provider ) 
			{
				if ( _wcsicmp ( t_Iterator.GetKey ().m_Provider , a_Key.m_Provider ) == 0 ) 
				{
					t_Equal = TRUE ;
				}
			}
		}

		if ( t_Equal )
		{
			ServiceCacheElement *t_Element = t_Iterator.GetElement () ;

			_IWmiProviderInitialize *t_Initializer = NULL ;

			t_Result = t_Element->QueryInterface (

				IID__IWmiProviderInitialize	,
				( void ** ) & t_Initializer
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_PerUser ;
				t_Initializer->IsPerUserInitialization ( & t_PerUser ) ;

				BOOL t_PerLocale ;
				t_Initializer->IsPerLocaleInitialization ( & t_PerLocale ) ;

				DWORD t_Hosting ;
				t_Initializer->GetHosting ( & t_Hosting ) ;

				BSTR t_HostingGroup ;
				t_Initializer->GetHostingGroup ( & t_HostingGroup ) ;

				BOOL t_Internal ;
				t_Initializer->IsInternal ( & t_Internal ) ;

				try
				{
					ProviderCacheKey t_SpecificKey ( 

						a_Key.m_Provider , 
						t_Hosting ,
						t_HostingGroup ,
						t_Internal ? false : true ,
						NULL ,
						t_PerUser ? a_User : NULL ,
						t_PerLocale ? a_Locale : NULL 
					) ;

					SysFreeString ( t_HostingGroup ) ;

					WmiStatusCode t_StatusCode = Find ( t_SpecificKey , t_Iterator ) ;
					if ( t_StatusCode != e_StatusCode_Success )
					{
						t_Result = WBEM_E_NOT_FOUND ;
					}
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					ServiceCacheElement *t_Element = t_Iterator.GetElement () ;

					UnLock () ;

					_IWmiProviderInitialize *t_SpecificInitializer = NULL ;

					t_Result = t_Element->QueryInterface (

						IID__IWmiProviderInitialize	,
						( void ** ) & t_SpecificInitializer
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = WaitProvider ( 

							a_Context ,
							a_RIID , 
							a_Interface ,
							t_Element ,
							t_SpecificInitializer
						) ;

						t_SpecificInitializer->Release () ;
					}
					else
					{
						t_Result = WBEM_E_UNEXPECTED ;
					}

					t_Element->Release () ;
				}
				else
				{
					UnLock () ;
				}

				t_Initializer->Release () ;
			}
			else
			{
				UnLock () ;
			}
		}
		else
		{
			UnLock () ;

			t_Result = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		UnLock () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: FindProvider ( 

	IWbemContext *a_Context ,
	ProviderCacheKey &a_Key ,
	BOOL a_SpecificProvider ,
	REFIID a_RIID , 
	void **a_Interface ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale
)
{
	HRESULT t_Result = S_OK;

	Lock () ;

	CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator ;

	WmiStatusCode t_StatusCode = Find ( a_Key , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		ServiceCacheElement *t_Element = t_Iterator.GetElement () ;

		UnLock () ;

		_IWmiProviderInitialize *t_Initializer = NULL ;

		t_Result = t_Element->QueryInterface (

			IID__IWmiProviderInitialize	,
			( void ** ) & t_Initializer
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_PerUser ;
			t_Initializer->IsPerUserInitialization ( & t_PerUser ) ;
			BOOL t_PerLocale ;
			t_Initializer->IsPerLocaleInitialization ( & t_PerLocale ) ;

			if ( t_PerUser || t_PerLocale )
			{
				t_Result = WBEM_E_NOT_FOUND ;
			}
			else
			{
				t_Result = WaitProvider ( 

					a_Context ,
					a_RIID , 
					a_Interface ,
					t_Element ,
					t_Initializer 
				) ;
			}

			t_Initializer->Release () ;
		}
		else
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}

		t_Element->Release () ;
	}
	else
	{
		t_Result = WBEM_E_NOT_FOUND ;

		UnLock () ;
	}	

	if ( t_Result == WBEM_E_NOT_FOUND )
	{
		if ( ! a_SpecificProvider )
		{ 
		    Lock();
			t_Result = SearchSpecificProvider (

				a_Context ,
				a_Key ,
				a_RIID , 
				a_Interface ,
				a_User ,
				a_Locale
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: GetClassProvider (

    LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	IWbemClassObject *a_Class ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		ProviderCacheKey t_Key ( 

			NULL , 
			e_Hosting_WmiCore ,
			NULL ,
			false ,
			NULL ,
			a_User ,
			a_Locale 
		) ;

		t_Result = FindProvider (

			a_Context ,
			t_Key , 
			TRUE ,
			a_RIID , 
			a_Interface ,
			a_User ,
			a_Locale
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
		}
		else
		{
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				CServerObject_ProviderSubSystem *t_SubSystem = NULL ;
				IWbemServices *t_RepositoryService = NULL ;
				IWbemServices *t_FullService = NULL ;

				t_Result = Direct_GetSubSystem ()->QueryInterface ( IID_CWbemProviderSubSystem , ( void ** ) & t_SubSystem ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_SubSystem->GetWmiRepositoryService (
					
						Direct_GetNamespacePath () ,
						( const BSTR ) a_User ,
						( const BSTR ) a_Locale ,
						t_RepositoryService
					) ;
					if ( SUCCEEDED ( t_Result ) ) 
					{
						t_Result = t_SubSystem->GetWmiService (
						
							Direct_GetNamespacePath () , 
							( const BSTR ) a_User ,
							( const BSTR ) a_Locale ,
							t_FullService
						) ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = GetAggregatedClassProvider ( 

						t_RepositoryService ,
						t_FullService ,
						t_Key ,
						a_Flags ,
						a_Context ,
						a_User ,
						a_Locale ,
						a_Scope ,
						a_Class ,
						a_RIID , 
						a_Interface 
					) ;
				}

				if ( t_RepositoryService )
				{
					t_RepositoryService->Release () ;
				}

				if ( t_FullService )
				{
					t_FullService->Release () ;
				}

				if ( t_SubSystem )
				{
					t_SubSystem->Release () ;
				}
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: GetDynamicPropertyResolver (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif
	
	HRESULT t_Result = S_OK ;

	try 
	{
		CServerObject_ProviderSubSystem *t_SubSystem = NULL ;
		t_Result = Direct_GetSubSystem ()->QueryInterface ( IID_CWbemProviderSubSystem , ( void ** ) & t_SubSystem ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemServices *t_FullService = NULL ;
			t_Result = t_SubSystem->GetWmiService ( 
			
				Direct_GetNamespacePath () , 
				( const BSTR ) a_User ,
				( const BSTR ) a_Locale ,
				t_FullService
			) ;

			if ( SUCCEEDED ( t_Result ) ) 
			{
#ifdef INTERNAL_IDENTIFY

				CInterceptor_IWbemServices_Stub *t_Stub = new CInterceptor_IWbemServices_Stub (
				
					NULL ,
					m_Allocator , 
					t_FullService
				) ;
#else
				CInterceptor_IWbemServices_Interceptor *t_Stub = new CInterceptor_IWbemServices_Interceptor (
				
					m_Allocator , 
					t_FullService
				) ;

#endif

				if ( t_Stub )
				{
					t_Stub->AddRef () ;

					t_Result = t_Stub->ServiceInitialize () ;
					if ( SUCCEEDED ( t_Result ) )
					{
						CServerObject_DynamicPropertyProviderResolver *t_Resolver = new CServerObject_DynamicPropertyProviderResolver (

							m_Allocator ,
							this ,
							t_Stub
						) ;

						if ( t_Resolver ) 
						{
							t_Resolver->AddRef () ;

							wchar_t *t_NamespacePath = NULL ;

							t_Result = ProviderSubSystem_Common_Globals :: GetNamespacePath ( 

								Direct_GetNamespacePath () , 
								t_NamespacePath
							) ;

							if ( SUCCEEDED ( t_Result ) ) 
							{
								IWbemProviderInit *t_ProviderInit = NULL ;

								t_Result = t_Resolver->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & t_ProviderInit ) ;
								if ( SUCCEEDED ( t_Result ) )
								{
									CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
									if ( t_ProviderInitSink )
									{
										t_ProviderInitSink->AddRef () ;

										t_Result = t_ProviderInitSink->SinkInitialize () ;
										if ( SUCCEEDED ( t_Result ) ) 
										{
											CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
											if ( t_Sink )
											{
												t_Sink->AddRef () ;

												t_Result = t_ProviderInit->Initialize (

													( const BSTR ) a_User ,
													0 ,
													( const BSTR ) t_NamespacePath ,
													( const BSTR ) a_Locale ,
													t_Stub ,
													a_Context ,
													t_Sink    
												) ;

												if ( SUCCEEDED ( t_Result ) )
												{
													t_ProviderInitSink->Wait () ;

													t_Result = t_ProviderInitSink->GetResult () ;
													if ( SUCCEEDED ( t_Result ) )
													{
														t_Result = t_Resolver->QueryInterface ( a_RIID , a_Interface ) ;
													}
												}

												t_Sink->Release () ;
											}
											else
											{
												t_Result = WBEM_E_OUT_OF_MEMORY ;
											}
										}

										t_ProviderInitSink->Release () ;
									}
									else
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}

									t_ProviderInit->Release () ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								delete [] t_NamespacePath ;
							}

							t_Resolver->Release () ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_Stub->Release () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				t_FullService->Release () ;

			}

			t_SubSystem->Release () ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Get (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemObjectSink *a_Sink
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		if ( _wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
		{
			wchar_t *t_Locale = NULL ; 
			wchar_t *t_User = NULL ; 
			wchar_t *t_Namespace = NULL ; 
			GUID *t_TransactionIdentifier = NULL ; 
			wchar_t *t_Provider = NULL ; 
			wchar_t *t_HostingGroup = NULL ;
			DWORD t_HostingSpecification = 0 ;

			IWbemPath *t_PathObject = NULL ;

			t_Result = CoCreateInstance (

				CLSID_WbemDefPath ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IWbemPath ,
				( void ** )  & t_PathObject
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_PathObject->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_Path ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					IWbemPathKeyList *t_Keys = NULL ;

					t_Result = t_PathObject->GetKeyList (

						& t_Keys 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						ULONG t_KeyCount = 0 ;
						t_Result = t_Keys->GetCount (

							& t_KeyCount 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_KeyCount == 7 )
							{
								for ( ULONG t_Index = 0 ; ( t_Index < t_KeyCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
								{
									wchar_t t_Key [ 32 ] ; 
									ULONG t_KeyLength = 32 ;
									ULONG t_KeyValueLength = 0 ;
									ULONG t_KeyType = 0 ;

									t_Result = t_Keys->GetKey (

										t_Index ,
										0 ,
										& t_KeyLength ,
										t_Key ,
										& t_KeyValueLength ,
										NULL ,
										& t_KeyType
									) ;

									if ( SUCCEEDED ( t_Result ) ) 
									{
										if ( t_KeyType == CIM_STRING )
										{
											wchar_t *t_KeyValue = new wchar_t [ t_KeyValueLength ] ;
											if ( t_KeyValue )
											{
												t_Result = t_Keys->GetKey (

													t_Index ,
													0 ,
													& t_KeyLength ,
													t_Key ,
													& t_KeyValueLength ,
													t_KeyValue ,
													& t_KeyType
												) ;

												if ( SUCCEEDED ( t_Result ) )
												{
													if ( _wcsicmp ( L"Namespace" , t_Key ) == 0 )
													{
														t_Namespace = t_KeyValue ;
													}
													else if ( _wcsicmp ( L"Provider" , t_Key ) == 0 )
													{
														t_Provider = t_KeyValue ;
													}
													else if ( _wcsicmp ( L"HostingGroup" , t_Key ) == 0 )
													{
														if ( _wcsicmp ( t_KeyValue , L"" ) != 0 ) 
														{
															t_HostingGroup = t_KeyValue ;
														}
														else
														{
															delete [] t_KeyValue ;
														}
													}
													else if ( _wcsicmp ( L"Locale" , t_Key ) == 0 )
													{
														if ( _wcsicmp ( t_KeyValue , L"" ) != 0 ) 
														{
															t_Locale = t_KeyValue ;
														}
														else
														{
															delete [] t_KeyValue ;
														}
													}
													else if ( _wcsicmp ( L"User" , t_Key ) == 0 )
													{
														if ( _wcsicmp ( t_KeyValue , L"" ) != 0 ) 
														{
															t_User = t_KeyValue ;
														}
														else
														{
															delete [] t_KeyValue ;
														}
													}
													else if ( _wcsicmp ( L"TransactionIdentifier" , t_Key ) == 0 )
													{
														if ( _wcsicmp ( t_KeyValue , L"" ) != 0 ) 
														{
															t_TransactionIdentifier = new GUID ;
															if ( t_TransactionIdentifier )
															{
																t_Result = CLSIDFromString (

																	t_KeyValue ,
																	t_TransactionIdentifier
																) ;

																if ( FAILED ( t_Result ) )
																{
																	t_Result = WBEM_E_INVALID_OBJECT_PATH ;
																}
															}
														}
														else
														{
															delete [] t_KeyValue ;
														}
													}
													else
													{
														delete [] t_KeyValue ;

														t_Result = WBEM_E_INVALID_OBJECT_PATH ;
													}
												}
												else
												{
													t_Result = WBEM_E_CRITICAL_ERROR ;
												}
											}
											else
											{
												t_Result = WBEM_E_OUT_OF_MEMORY ;
											}	
										}
										else if ( t_KeyType == CIM_SINT32 )
										{
											DWORD t_KeyValue = 0 ;
											t_Result = t_Keys->GetKey (

												t_Index ,
												0 ,
												& t_KeyLength ,
												t_Key ,
												& t_KeyValueLength ,
												& t_KeyValue ,
												& t_KeyType
											) ;

											if ( SUCCEEDED ( t_Result ) )
											{
												if ( _wcsicmp ( L"HostingSpecification" , t_Key ) == 0 )
												{
													t_HostingSpecification = t_KeyValue ;
												}
												else
												{
													t_Result = WBEM_E_INVALID_OBJECT_PATH ;
												}
											}
											else
											{
												t_Result = WBEM_E_CRITICAL_ERROR ;
											}
										}
										else
										{
											t_Result = WBEM_E_INVALID_OBJECT_PATH ;
										}
									}
									else
									{
										t_Result = WBEM_E_CRITICAL_ERROR ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_INVALID_OBJECT_PATH ;
							}
						}
                        t_Keys->Release();
                    }
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				t_PathObject->Release () ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		
			if ( SUCCEEDED ( t_Result ) ) 
			{
				ProviderCacheKey t_Key ( 

					t_Provider , 
					t_HostingSpecification ,
					t_HostingGroup ,
					true ,
					t_TransactionIdentifier ,
					t_User ,
					t_Locale
				) ;

				CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Find ( t_Key , t_Iterator ) ;

				if ( t_StatusCode == e_StatusCode_Success )
				{
					ServiceCacheElement *t_Service = t_Iterator.GetElement () ;

					UnLock () ;

					_IWmiProviderConfiguration *t_Configuration = NULL ;
					t_Result = t_Service->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_Configuration ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						_IWmiProviderInitialize *t_Initialize = NULL ;
						t_Result = t_Service->QueryInterface ( IID__IWmiProviderInitialize , ( void ** ) & t_Initialize ) ;
						if ( SUCCEEDED ( t_Result ) ) 
						{
							HRESULT t_TempResult = 	t_Initialize->WaitProvider ( 
							
								a_Context , 
								DEFAULT_PROVIDER_LOAD_TIMEOUT
							) ;

							if ( ( t_TempResult == S_OK ) && ( SUCCEEDED ( t_Initialize->GetInitializeResult () ) ) )
							{
								t_Result = t_Configuration->Get ( 

									a_Service ,
									a_Flags, 
									a_Context,
 									a_Class, 
									a_Path,
									a_Sink 
								) ;
							}
							else
							{
								t_Result = WBEM_E_NOT_FOUND ;
							}

							t_Initialize->Release () ;
						}

						t_Configuration->Release () ;
					}
					else
					{
						t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
					}

					t_Service->Release () ;
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_NOT_FOUND ;
				}
			}

			if ( t_Locale )
			{
				delete [] t_Locale ;
			}

			if ( t_User )
			{
				delete [] t_User ;
			}

			if ( t_Namespace ) 
			{
				delete [] t_Namespace ;
			} 

			if ( t_TransactionIdentifier ) 
			{
				delete [] t_TransactionIdentifier ;
			}

			if ( t_Provider )
			{
				delete [] t_Provider ;
			}
		}
		else
		{
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Set (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_OldObject ,
	IWbemClassObject *a_NewObject  

)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		Lock () ;

		CWbemGlobal_IWmiProviderController_Cache *t_Cache = NULL ;
		GetCache ( t_Cache ) ;

		if ( t_Cache->Size () )
		{
			_IWmiProviderCache **t_Elements = new _IWmiProviderCache * [ t_Cache->Size () ] ;
			if ( t_Elements )
			{
				for ( ULONG t_Index = 0 ; t_Index < t_Cache->Size () ; t_Index ++ )
				{
					t_Elements [ t_Index ] = NULL ;
				}

				CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator = t_Cache->Begin ();

				ULONG t_Count = 0 ;
				while ( SUCCEEDED ( t_Result ) && ( ! t_Iterator.Null () ) )
				{
					try
					{
						ProviderCacheKey t_Key = t_Iterator.GetKey () ;
						ServiceCacheElement *t_Element = t_Iterator.GetElement () ;

						t_Iterator.Increment () ;

						if ( t_Key.m_Provider && ( _wcsicmp ( a_Provider , t_Key.m_Provider ) == 0 ) )
						{
							t_Result = t_Element->QueryInterface ( 

								IID__IWmiProviderCache , 
								( void ** ) & t_Elements [ t_Count ]
							) ;

							WmiStatusCode t_StatusCode = CWbemGlobal_IWmiProviderController :: Shutdown ( t_Key ) ; 
						} 

						t_Count ++ ;
					}
					catch ( Wmi_Heap_Exception &a_Exception )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}

				UnLock () ;

				for ( t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_Elements [ t_Index ] ) 
					{
						t_Result = t_Elements [ t_Index ]->ForceReload () ;

						t_Elements [ t_Index ]->Release () ;
					}
				}
	
				delete [] t_Elements ;
			}
			else
			{
				UnLock () ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			Lock () ;

			CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator = t_Cache->Begin ();
			while ( SUCCEEDED ( t_Result ) && ( ! t_Iterator.Null () ) )
			{
				try
				{
					ProviderCacheKey t_Key = t_Iterator.GetKey () ;

					t_Iterator.Increment () ;

					if ( t_Key.m_Provider == NULL )
					{
						WmiStatusCode t_StatusCode = CWbemGlobal_IWmiProviderController :: Shutdown ( t_Key ) ; 
					} 
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
		}

		UnLock () ;

		if ( a_OldObject )
		{
			GUID t_Clsid ;

			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;

			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			t_Result = a_OldObject->Get ( L"Clsid" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Variant.vt == VT_BSTR )
				{
					t_Result = CLSIDFromString ( t_Variant.bstrVal , & t_Clsid ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						ProviderSubSystem_Globals :: DeleteGuidTag ( t_Clsid ) ;
					}
				}

				VariantClear ( & t_Variant ) ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Deleted (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_Object  
) 
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		Lock () ;

		CWbemGlobal_IWmiProviderController_Cache *t_Cache = NULL ;
		GetCache ( t_Cache ) ;

		if ( t_Cache->Size () )
		{
			CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator = t_Cache->Begin ();

			while ( SUCCEEDED ( t_Result ) && ( ! t_Iterator.Null () ) )
			{
				try
				{
					ProviderCacheKey t_Key = t_Iterator.GetKey () ;

					t_Iterator.Increment () ;

					if ( t_Key.m_Provider && (_wcsicmp ( a_Provider , t_Key.m_Provider ) == 0 ) )
					{
						WmiStatusCode t_StatusCode = CWbemGlobal_IWmiProviderController :: Shutdown ( t_Key ) ; 
					} 
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
		}

		UnLock () ;

		GUID t_Clsid ;

		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		t_Result = a_Object->Get ( L"Clsid" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BSTR )
			{
				t_Result = CLSIDFromString ( t_Variant.bstrVal , & t_Clsid ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					ProviderSubSystem_Globals :: DeleteGuidTag ( t_Clsid ) ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Enumerate (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	if ( _wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
	{
		Lock () ;

		CWbemGlobal_IWmiProviderController_Cache *t_Cache = NULL ;
		GetCache ( t_Cache ) ;

		if ( t_Cache->Size () )
		{
			CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator = t_Cache->Begin ();

			_IWmiProviderConfiguration **t_ControllerElements = new _IWmiProviderConfiguration * [ t_Cache->Size () ] ;
			if ( t_ControllerElements )
			{
				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				UnLock () ;

				try
				{
					BindingFactoryCacheKey t_Key = BindingFactoryCacheElement :: GetKey () ;
					VARIANT t_Variant ;
					VariantInit ( & t_Variant ) ;

					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( t_Key.m_Namespace ) ;

					for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
					{
						if ( t_ControllerElements [ t_Index ] )
						{
							_IWmiProviderInitialize *t_Initialize = NULL ;
							t_Result = t_ControllerElements [ t_Index ]->QueryInterface ( IID__IWmiProviderInitialize , ( void ** ) & t_Initialize ) ;
							if ( SUCCEEDED ( t_Result ) ) 
							{
								HRESULT t_TempResult = 	t_Initialize->WaitProvider ( 
								
									a_Context , 
									DEFAULT_PROVIDER_LOAD_TIMEOUT
								) ;

								if ( ( t_TempResult == S_OK ) && ( SUCCEEDED ( t_Initialize->GetInitializeResult () ) ) )
								{
									CWaitingObjectSink *t_Sink = new CWaitingObjectSink ( m_Allocator ) ;
									if ( t_Sink )
									{
										t_Sink->AddRef () ;

										t_Result = t_Sink->SinkInitialize () ;
										if ( SUCCEEDED ( t_Result ) )
										{
											t_Result = t_ControllerElements [ t_Index ]->Enumerate ( 

												a_Service ,
												a_Flags, 
												a_Context,
 												a_Class, 
												t_Sink 
											) ;

											t_Result = t_Sink->Wait ( INFINITE ) ;

											if ( SUCCEEDED ( t_Result ) )
											{
												t_Result = t_Sink->GetResult () ;
												if ( FAILED ( t_Result ) )
												{
												}
											}

											WmiQueue <IWbemClassObject *,8> &t_Queue = t_Sink->GetQueue () ;

											WmiStatusCode t_StatusCode = e_StatusCode_Success ;

											IWbemClassObject *t_Object = NULL ;
											while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
											{
												if ( SUCCEEDED ( t_Result ) )
												{
													t_Object->Put ( L"Namespace" , 0 , & t_Variant , 0 ) ;

													a_Sink->Indicate ( 1, & t_Object ) ;
												}

												t_Object->Release () ;
												t_StatusCode = t_Queue.DeQueue () ;
											}

											t_Sink->Release () ;
										}
									}
									else
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}	
								}

								t_Initialize->Release () ;
							}

							t_ControllerElements [ t_Index ]->Release () ;
						}
					}

					VariantClear ( & t_Variant ) ;
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				delete [] t_ControllerElements ;
			}
			else
			{
				UnLock () ;
			}
		}
		else
		{
			UnLock () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Shutdown (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	ULONG a_MilliSeconds
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Call (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,		
	LPCWSTR a_Method ,
	IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		if ( _wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
		{
			wchar_t *t_Locale = NULL ; 
			wchar_t *t_User = NULL ; 
			wchar_t *t_Namespace = NULL ; 
			GUID *t_TransactionIdentifier = NULL ; 
			wchar_t *t_HostingGroup = NULL ; 
			wchar_t *t_Provider = NULL ; 
			DWORD t_HostingSpecification = 0 ;

			IWbemPath *t_PathObject = NULL ;

			t_Result = CoCreateInstance (

				CLSID_WbemDefPath ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IWbemPath ,
				( void ** )  & t_PathObject
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_PathObject->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_Path ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					IWbemPathKeyList *t_Keys = NULL ;

					t_Result = t_PathObject->GetKeyList (

						& t_Keys 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						ULONG t_KeyCount = 0 ;
						t_Result = t_Keys->GetCount (

							& t_KeyCount 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_KeyCount == 7 )
							{
								for ( ULONG t_Index = 0 ; ( t_Index < t_KeyCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
								{
									wchar_t t_Key [ 32 ] ; 
									ULONG t_KeyLength = 32 ;
									ULONG t_KeyValueLength = 0 ;
									ULONG t_KeyType = 0 ;

									t_Result = t_Keys->GetKey (

										t_Index ,
										0 ,
										& t_KeyLength ,
										t_Key ,
										& t_KeyValueLength ,
										NULL ,
										& t_KeyType
									) ;

									if ( SUCCEEDED ( t_Result ) ) 
									{
										if ( t_KeyType == CIM_STRING )
										{
											wchar_t *t_KeyValue = new wchar_t [ t_KeyValueLength ] ;
											if ( t_KeyValue )
											{
												t_Result = t_Keys->GetKey (

													t_Index ,
													0 ,
													& t_KeyLength ,
													t_Key ,
													& t_KeyValueLength ,
													t_KeyValue ,
													& t_KeyType
												) ;

												if ( SUCCEEDED ( t_Result ) )
												{
													if ( _wcsicmp ( L"Namespace" , t_Key ) == 0 )
													{
														t_Namespace = t_KeyValue ;
													}
													else if ( _wcsicmp ( L"Provider" , t_Key ) == 0 )
													{
														t_Provider = t_KeyValue ;
													}
													else if ( _wcsicmp ( L"HostingGroup" , t_Key ) == 0 )
													{
														t_HostingGroup = t_KeyValue ;
													}
													else if ( _wcsicmp ( L"Locale" , t_Key ) == 0 )
													{
														if ( _wcsicmp ( t_KeyValue , L"" ) != 0 ) 
														{
															t_Locale = t_KeyValue ;
														}
														else
														{
															delete [] t_KeyValue ;
														}
													}
													else if ( _wcsicmp ( L"User" , t_Key ) == 0 )
													{
														if ( _wcsicmp ( t_KeyValue , L"" ) != 0 ) 
														{
															t_User = t_KeyValue ;
														}
														else
														{
															delete [] t_KeyValue ;
														}
													}
													else if ( _wcsicmp ( L"TransactionIdentifier" , t_Key ) == 0 )
													{
														if ( _wcsicmp ( t_KeyValue , L"" ) != 0 ) 
														{
															t_TransactionIdentifier = new GUID ;
															if ( t_TransactionIdentifier )
															{
																t_Result = CLSIDFromString (

																	t_KeyValue ,
																	t_TransactionIdentifier
																) ;

																if ( FAILED ( t_Result ) )
																{
																	t_Result = WBEM_E_INVALID_OBJECT_PATH ;
																}
															}
														}
														else
														{
															delete [] t_KeyValue ;
														}
													}
													else
													{
														delete [] t_KeyValue ;

														t_Result = WBEM_E_INVALID_OBJECT_PATH ;
													}
												}
												else
												{
													t_Result = WBEM_E_CRITICAL_ERROR ;
												}
											}
											else
											{
												t_Result = WBEM_E_OUT_OF_MEMORY ;
											}	
										}
										else if ( t_KeyType == CIM_SINT32 )
										{
											DWORD t_KeyValue = 0 ;
											t_Result = t_Keys->GetKey (

												t_Index ,
												0 ,
												& t_KeyLength ,
												t_Key ,
												& t_KeyValueLength ,
												& t_KeyValue ,
												& t_KeyType
											) ;

											if ( SUCCEEDED ( t_Result ) )
											{
												if ( _wcsicmp ( L"HostingSpecification" , t_Key ) == 0 )
												{
													t_HostingSpecification = t_KeyValue ;
												}
												else
												{
													t_Result = WBEM_E_INVALID_OBJECT_PATH ;
												}
											}
											else
											{
												t_Result = WBEM_E_CRITICAL_ERROR ;
											}
										}
										else
										{
											t_Result = WBEM_E_INVALID_OBJECT_PATH ;
										}
									}
									else
									{
										t_Result = WBEM_E_CRITICAL_ERROR ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_INVALID_OBJECT_PATH ;
							}
						}
                        t_Keys->Release();
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				t_PathObject->Release () ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		
			if ( SUCCEEDED ( t_Result ) ) 
			{
				try
				{
					ProviderCacheKey t_Key ( 

						t_Provider , 
						t_HostingSpecification ,
						t_HostingGroup ,
						true ,
						t_TransactionIdentifier ,
						t_User ,
						t_Locale
					) ;

					CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Find ( t_Key , t_Iterator ) ;

					if ( t_StatusCode == e_StatusCode_Success )
					{
						ServiceCacheElement *t_Service = t_Iterator.GetElement () ;

						if ( _wcsicmp ( a_Method , L"UnLoad" ) == 0 )
						{
							UnLock () ;

							_IWmiProviderLoad *t_Load = NULL ;

							t_Result = t_Service->QueryInterface ( IID__IWmiProviderLoad , ( void ** ) & t_Load ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								WmiStatusCode t_StatusCode = CWbemGlobal_IWmiProviderController :: Shutdown ( t_Key ) ; 

								t_Result = t_Load->Unload ( 

									0 ,
									a_Context
								) ;

								t_Load->Release () ;
							}
							else
							{
								t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
							}
						}
						else if ( ( _wcsicmp ( a_Method , L"Suspend" ) == 0 ) || ( _wcsicmp ( a_Method , L"Resume" ) == 0 ) )
						{
							UnLock () ;

							_IWmiProviderConfiguration *t_Configuration = NULL ;
							t_Result = t_Service->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_Configuration ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								_IWmiProviderInitialize *t_Initialize = NULL ;
								t_Result = t_Service->QueryInterface ( IID__IWmiProviderInitialize , ( void ** ) & t_Initialize ) ;
								if ( SUCCEEDED ( t_Result ) ) 
								{
									HRESULT t_TempResult = 	t_Initialize->WaitProvider ( 
									
										a_Context , 
										DEFAULT_PROVIDER_LOAD_TIMEOUT
									) ;

									if ( ( t_TempResult == S_OK ) && ( SUCCEEDED ( t_Initialize->GetInitializeResult () ) ) )
									{
										t_Result = t_Configuration->Call ( 

											a_Service ,
											a_Flags, 
											a_Context,
 											a_Class, 
											a_Path,
											a_Method,
											a_InParams,
											a_Sink 
										) ;
									}
									else
									{
										t_Result = WBEM_E_NOT_FOUND ;
									}

									t_Initialize->Release () ;
								}

								t_Configuration->Release () ;
							}
							else
							{
								t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
							}
						}
						else
						{
							UnLock () ;
						}

						t_Service->Release () ;
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_NOT_FOUND ;
					}
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}

			if ( t_Locale )
			{
				delete [] t_Locale ;
			}

			if ( t_User )
			{
				delete [] t_User ;
			}

			if ( t_Namespace ) 
			{
				delete [] t_Namespace ;
			} 

			if ( t_TransactionIdentifier ) 
			{
				delete [] t_TransactionIdentifier ;
			}

			if ( t_Provider )
			{
				delete [] t_Provider ;
			}
		}
		else
		{
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Query (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
	WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
	VARIANT *a_Value 
)
{
	return WBEM_E_NOT_SUPPORTED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_BindingFactory :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		Lock () ;

		CWbemGlobal_IWmiProviderController_Cache *t_Cache = NULL ;
		GetCache ( t_Cache ) ;

		if ( t_Cache->Size () )
		{
			IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Cache->Size () ] ;
			if ( t_ShutdownElements )
			{
				CWbemGlobal_IWmiProviderController_Cache_Iterator t_Iterator = t_Cache->Begin ();

				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ShutdownElements [ t_Index ] ) 
					{
						t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;

						t_ShutdownElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ShutdownElements ;
			}
			else
			{
				UnLock () ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			UnLock () ;
		}

		CWbemGlobal_IWmiProviderController :: Shutdown () ;
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CServerObject_BindingFactory :: Strobe ( ULONG &a_NextStrobeDelta )
{
	return CWbemGlobal_IWmiProviderController :: Strobe ( a_NextStrobeDelta ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CServerObject_BindingFactory :: StrobeBegin ( const ULONG &a_Period )
{
	ULONG t_Timeout = ProviderSubSystem_Globals :: GetStrobeThread ().GetTimeout () ;
	ProviderSubSystem_Globals :: GetStrobeThread ().SetTimeout ( t_Timeout < a_Period ? t_Timeout : a_Period ) ;
	return e_StatusCode_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provload.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include <PreComp.h>
#include <wbemint.h>
#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvResv.h"
#include "ProvFact.h"
#include "ProvSubS.h"
#include "ProvRegInfo.h"
#include "ProvLoad.h"
#include "ProvWsv.h"
#include "ProvWsvS.h"
#include "ProvInSk.h"
#include "StaThread.h"
#include "Guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_RawFactory :: CServerObject_RawFactory (

	WmiAllocator &a_Allocator 

) : 
	m_Allocator ( a_Allocator ) ,
	m_ReferenceCount ( 0 ) ,
	m_Flags ( 0 ) ,
	m_Context ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_NamespacePath ( NULL ) ,
	m_Repository ( NULL )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_RawFactory_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_RawFactory::~CServerObject_RawFactory ()
{
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Namespace )
	{
		delete [] m_Namespace ;
	}

	if ( m_NamespacePath ) 
	{
		m_NamespacePath->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}

	if ( m_Service ) 
	{
		m_Service->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_RawFactory_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_RawFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiProviderFactory )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderFactory * ) this ;		
	}	
	else if ( iid == IID__IWmiProviderFactoryInitialize )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderFactoryInitialize * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * )this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_RawFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_RawFactory :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: CheckInterfaceConformance (

	CServerObject_ProviderRegistrationV1 &a_Registration ,
	IUnknown *a_Unknown
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Registration.GetClassProviderRegistration ().Supported () && ( a_Registration.GetClassProviderRegistration ().InteractionType () != e_InteractionType_Push ) )
	{
		IWbemServices *t_Services = NULL ;

		t_Result = a_Unknown->QueryInterface ( IID_IWbemServices , ( void ** ) & t_Services ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Services->Release () ;
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_LOAD_FAILURE  ;
		}
	}

	if (	a_Registration.GetInstanceProviderRegistration ().Supported () ||
			a_Registration.GetMethodProviderRegistration ().Supported () )
	{
		IWbemServices *t_Services = NULL ;

		t_Result = a_Unknown->QueryInterface ( IID_IWbemServices , ( void ** ) & t_Services ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Services->Release () ;
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_LOAD_FAILURE  ;
		}
	}

	if (	a_Registration.GetEventProviderRegistration ().Supported () )
	{
		IWbemEventProvider *t_EventProvider = NULL ;

		t_Result = a_Unknown->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & t_EventProvider ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_EventProvider->Release () ;
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_LOAD_FAILURE  ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if (	a_Registration.GetPropertyProviderRegistration ().Supported () )
		{
			IWbemPropertyProvider *t_PropertyProvider = NULL ;

			t_Result = a_Unknown->QueryInterface ( IID_IWbemPropertyProvider , ( void ** ) & t_PropertyProvider ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_PropertyProvider->Release () ;
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_LOAD_FAILURE  ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: CreateInstance ( 

	CServerObject_ProviderRegistrationV1 &a_Registration ,
	const CLSID &a_ReferenceClsid ,
	LPUNKNOWN a_OuterUnknown ,
	const DWORD &a_ClassContext ,
	const UUID &a_ReferenceInterfaceId ,
	void **a_ObjectInterface
)
{
	HRESULT t_Result = S_OK ;

	COAUTHIDENTITY t_AuthenticationIdentity ;
	ZeroMemory ( & t_AuthenticationIdentity , sizeof ( t_AuthenticationIdentity ) ) ;

	t_AuthenticationIdentity.User = NULL ; 
	t_AuthenticationIdentity.UserLength = 0 ;
	t_AuthenticationIdentity.Domain = NULL ; 
	t_AuthenticationIdentity.DomainLength = 0 ; 
	t_AuthenticationIdentity.Password = NULL ; 
	t_AuthenticationIdentity.PasswordLength = 0 ; 
	t_AuthenticationIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE ; 

	COAUTHINFO t_AuthenticationInfo ;
	ZeroMemory ( & t_AuthenticationInfo , sizeof ( t_AuthenticationInfo ) ) ;

    t_AuthenticationInfo.dwAuthnSvc = RPC_C_AUTHN_DEFAULT ;
    t_AuthenticationInfo.dwAuthzSvc = RPC_C_AUTHZ_DEFAULT ;
    t_AuthenticationInfo.pwszServerPrincName = NULL ;
    t_AuthenticationInfo.dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT ;
    t_AuthenticationInfo.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE  ;
    t_AuthenticationInfo.dwCapabilities = EOAC_NONE ;
    t_AuthenticationInfo.pAuthIdentityData = NULL ;

	COSERVERINFO t_ServerInfo ;
	ZeroMemory ( & t_ServerInfo , sizeof ( t_ServerInfo ) ) ;

	t_ServerInfo.pwszName = NULL ;
    t_ServerInfo.dwReserved2 = 0 ;
    t_ServerInfo.pAuthInfo = & t_AuthenticationInfo ;

	IClassFactory *t_ClassFactory = NULL ;

	t_Result = CoGetClassObject (

		a_ReferenceClsid ,
		a_ClassContext ,
		& t_ServerInfo ,
		IID_IClassFactory ,
		( void ** )  & t_ClassFactory
	) ;
 
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_ClassFactory->CreateInstance (

			a_OuterUnknown ,
			a_ReferenceInterfaceId ,
			a_ObjectInterface 
		);	

		t_ClassFactory->Release () ;
	}
	else
	{
#if 0
		switch ( t_Result )
		{
			case REGDB_E_CLASSNOTREG:
			{
				ERRORTRACE((LOG_WBEMCORE, "Failed to CoGetClassObject provider %S: "
						"error code 0x%X (Class not registered)\n",
						(LPCWSTR)m_wsProviderName, hres));
				dwStringId = WBEM_MC_MOF_PROV_CLASSNOTREG;
			}
			break;

			case E_NOINTERFACE:
			{
				ERRORTRACE((LOG_WBEMCORE, "Failed to CoGetClassObject provider %S: "
						"error code 0x%X (No class factory available)\n",
						(LPCWSTR)m_wsProviderName, hres));
				dwStringId = WBEM_MC_MOF_PROV_NOINTERFACE;
			}
			break;

			case REGDB_E_READREGDB:
			{
				ERRORTRACE((LOG_WBEMCORE, "Failed to CoGetClassObject provider %S: "
						"error code 0x%X (Error reading the registration database)\n",
						(LPCWSTR)m_wsProviderName, hres));
				dwStringId = WBEM_MC_MOF_PROV_READREGDB;
			}
			break;

			case CO_E_DLLNOTFOUND:
			{
				ERRORTRACE((LOG_WBEMCORE, "Failed to CoGetClassObject provider %S: "
						"error code 0x%X (DLL not found)\n",
						(LPCWSTR)m_wsProviderName, hres));
				dwStringId = WBEM_MC_MOF_PROV_DLLNOTFOUND;
			}
			break;

			case CO_E_APPNOTFOUND:
			{
				ERRORTRACE((LOG_WBEMCORE, "Failed to CoGetClassObject provider %S: "
						"error code 0x%X (EXE not found)\n",
						(LPCWSTR)m_wsProviderName, hres));
				dwStringId = WBEM_MC_MOF_PROV_APPNOTFOUND;
			}
			break;

			case E_ACCESSDENIED:
			{
				ERRORTRACE((LOG_WBEMCORE, "Failed to CoGetClassObject provider %S: "
						"error code 0x%X (Access denied)\n",
						(LPCWSTR)m_wsProviderName, hres));
				dwStringId = WBEM_MC_MOF_PROV_ACCESSDENIED;
			}
			break;

			case CO_E_ERRORINDLL:
			{
				ERRORTRACE((LOG_WBEMCORE, "Failed to CoGetClassObject provider %S: "
						"error code 0x%X (EXE has error in image)\n",
						(LPCWSTR)m_wsProviderName, hres));
				dwStringId = WBEM_MC_MOF_PROV_ERRORINDLL;
			}
			break;

			case CO_E_APPDIDNTREG:
			{
				ERRORTRACE((LOG_WBEMCORE, "Failed to CoGetClassObject provider %S: "
						"error code 0x%X "
						"(EXE was launched, but it didn't register class object)\n",
						(LPCWSTR)m_wsProviderName, hres));
				dwStringId = WBEM_MC_MOF_PROV_APPDIDNTREG;
			}
			break;

			default:
			{
				ERRORTRACE((LOG_WBEMCORE, "Failed to CoGetClassObject provider %S: "
						"error code 0x%X\n", (LPCWSTR)m_wsProviderName, hres));
				dwStringId = WBEM_MC_MOF_PROV_UNKNOWNERR;
			}
			break;
		}
#endif
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: CreateServerSide ( 

	CServerObject_ProviderRegistrationV1 &a_Registration ,
	GUID *a_TransactionIdentifier ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	wchar_t *a_NamespacePath ,
	IUnknown **a_ProviderInterface
)
{
	HRESULT t_Result = S_OK ;

	wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;

	if ( a_TransactionIdentifier )
	{
		StringFromGUID2 ( *a_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
	}

	switch ( a_Registration.GetHosting () )
	{
		case e_Hosting_WmiCoreOrSelfHost:
		{
			if ( a_Registration.GetComRegistration ().GetClsidServer ().Loaded () == e_True )
			{
				t_Result = CreateInstance (

					a_Registration ,
					a_Registration.GetClsid () ,
					NULL ,
					CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
					IID_IUnknown ,
					( void ** ) a_ProviderInterface 
				) ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;

				*a_ProviderInterface = NULL ;
			}
		}
		break ;

		case e_Hosting_WmiCore:
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedNetworkServiceHost:
		case e_Hosting_SharedLocalServiceHost:
		case e_Hosting_ClientHost:
		case e_Hosting_SharedUserHost:
		{
			if ( a_Registration.GetComRegistration ().GetClsidServer ().Loaded () == e_True )
			{
				t_Result = CreateInstance (

					a_Registration ,
					a_Registration.GetClsid () ,
					NULL ,
					CLSCTX_INPROC_SERVER ,
					IID_IUnknown ,
					( void ** ) a_ProviderInterface 
				) ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;

				*a_ProviderInterface = NULL ;
			}
		}
		break ;

		case e_Hosting_SharedLocalSystemHostOrSelfHost:
		{
			if ( a_Registration.GetComRegistration ().GetClsidServer ().Loaded () == e_True )
			{
				t_Result = CreateInstance (

					a_Registration ,
					a_Registration.GetClsid () ,
					NULL ,
					CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_ENABLE_AAA ,
					IID_IUnknown ,
					( void ** ) a_ProviderInterface 
				) ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;

				*a_ProviderInterface = NULL ;
			}
		}
		break ;

		case e_Hosting_NonCom:
		{
			t_Result = CreateInstance	(

				a_Registration ,
				CLSID_NCProvider ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IUnknown ,
				( void ** ) a_ProviderInterface 
			) ;
		}
		break ;

		case e_Hosting_SelfHost:
		{
			if ( a_Registration.GetComRegistration ().GetClsidServer ().Loaded () == e_True )
			{
				t_Result = CreateInstance	(

					a_Registration ,
					a_Registration.GetClsid () ,
					NULL ,
					CLSCTX_LOCAL_SERVER | CLSCTX_ENABLE_AAA ,
					IID_IUnknown ,
					( void ** ) a_ProviderInterface 
				) ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;

				*a_ProviderInterface = NULL ;
			}
		}
		break ;

		default:
		{
			t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;

			*a_ProviderInterface = NULL ;
		}
		break ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ComServerLoadOperationEvent ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			a_NamespacePath,
			a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
			a_User ,
			a_Locale ,
			a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
			a_Registration.GetComRegistration ().GetClsidServer ().GetProviderClsid () ,
			a_Registration.GetComRegistration ().GetClsidServer ().GetServer_Name () ,
			a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
			a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
			a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetInProcServer32_Path () : NULL ,
			a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetLocalServer32_Path () : NULL
		) ;
	}
	else
	{
		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ComServerOperationFailureEvent ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			a_NamespacePath,
			a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
			a_User ,
			a_Locale ,
			a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
			a_Registration.GetComRegistration ().GetClsidServer ().GetProviderClsid () ,
			a_Registration.GetComRegistration ().GetClsidServer ().GetServer_Name () ,
			a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
			a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
			a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetInProcServer32_Path () : NULL ,
			a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetLocalServer32_Path () : NULL ,
			t_Result 
		);
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: GetApartmentInstanceProvider ( 

	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	REFIID a_RIID , 
	void **a_Interface ,
	CServerObject_ProviderRegistrationV1 &a_Registration
)
{
	wchar_t *t_NamespacePath = NULL ;

	HRESULT t_Result = ProviderSubSystem_Common_Globals :: GetNamespacePath ( 

		Direct_GetNamespacePath () , 
		t_NamespacePath
	) ;

	if ( SUCCEEDED ( t_Result ) ) 
	{
		CServerObject_StaThread *t_StaThread = new CServerObject_StaThread ( m_Allocator ) ;
		if ( t_StaThread )
		{
			t_StaThread->AddRef () ;

			t_Result = t_StaThread->SetProviderName ( a_Registration.GetProviderName () ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				WmiStatusCode t_StatusCode = t_StaThread-> WmiThread <ULONG> :: Initialize () ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					IWbemProviderInit *t_ThreadInit = NULL ;

					t_Result = t_StaThread->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & t_ThreadInit ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
						if ( t_ProviderInitSink )
						{
							t_ProviderInitSink->AddRef () ;

							t_Result = t_ProviderInitSink->SinkInitialize () ;
							if ( SUCCEEDED ( t_Result ) ) 
							{
								CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
								if ( t_Sink )
								{
									t_Sink->AddRef () ;

									t_Result = t_ThreadInit->Initialize (

										NULL ,
										0 ,
										NULL ,
										NULL ,
										NULL ,
										NULL ,
										t_Sink    
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										t_ProviderInitSink->Wait ( a_Registration.GetInitializationTimeoutMilliSeconds () ) ;

										if ( SUCCEEDED ( t_Result = t_ProviderInitSink->GetResult () ) )
										{
#ifdef INTERNAL_IDENTIFY
											CInterceptor_IWbemServices_Proxy *t_Proxy = new CInterceptor_IWbemServices_Proxy ( 

												NULL , 
												m_Allocator , 
												Direct_GetService () ,
												a_Registration
											) ;
#else
											CInterceptor_IWbemServices_Interceptor *t_Proxy = new CInterceptor_IWbemServices_Interceptor ( 

												m_Allocator , 
												Direct_GetService ()
											) ;
#endif

											if ( t_Proxy )
											{
												t_Proxy->AddRef () ;

												t_Result = t_Proxy->ServiceInitialize () ;
												if ( SUCCEEDED ( t_Result ) ) 
												{
													t_Result = t_StaThread->GetApartmentInstanceProvider (

														a_TransactionIdentifier ,
														a_Registration.GetComRegistration ().PerUserInitialization () ? a_User : NULL ,
														a_Registration.GetComRegistration ().PerLocaleInitialization () ? a_Locale : NULL ,
														Direct_GetNamespace () ,
														Direct_GetNamespacePath () ,
														t_Proxy ,
														a_Flags ,
														a_Context ,
														a_Scope ,
														a_Registration
													) ;

													if ( SUCCEEDED ( t_Result ) )
													{
														IUnknown *t_Unknown = NULL ;
														t_Result = t_StaThread->QueryInterface ( IID_IUnknown , ( void ** ) & t_Unknown ) ;
														if ( SUCCEEDED ( t_Result ) )
														{
															GUID t_Guid ;
															t_Result = CoCreateGuid ( & t_Guid ) ;
															if ( SUCCEEDED ( t_Result ) )
															{
																CInterceptor_IWbemSyncProvider *t_Interceptor = new CInterceptor_IWbemSyncProvider (

																	m_Allocator ,
																	t_Unknown , 
																	t_Proxy ,
																	ProviderSubSystem_Globals :: GetSyncProviderController () , 
																	a_Context ,
																	a_Registration ,
																	t_Guid 
																) ;

																if ( t_Interceptor ) 
																{
																	t_Interceptor->AddRef () ;

																	CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator ;

																	ProviderSubSystem_Globals :: GetSyncProviderController ()->Lock () ;

																	WmiStatusCode t_StatusCode = ProviderSubSystem_Globals :: GetSyncProviderController ()->Insert ( 

																		*t_Interceptor ,
																		t_Iterator
																	) ;

																	if ( t_StatusCode == e_StatusCode_Success ) 
																	{
																		ProviderSubSystem_Globals :: GetSyncProviderController ()->UnLock () ;

																		_IWmiProviderInitialize *t_InterceptorInit = NULL ;

																		t_Result = t_Interceptor->QueryInterface ( IID__IWmiProviderInitialize , ( void ** ) & t_InterceptorInit ) ;
																		if ( SUCCEEDED ( t_Result ) )
																		{
																			CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
																			if ( t_ProviderInitSink )
																			{
																				t_ProviderInitSink->AddRef () ;

																				t_Result = t_ProviderInitSink->SinkInitialize () ;
																				if ( SUCCEEDED ( t_Result ) ) 
																				{
																					CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
																					if ( t_Sink )
																					{
																						t_Sink->AddRef () ;

																						t_Result = t_InterceptorInit->Initialize (

																							0 ,
																							a_Context ,
																							a_TransactionIdentifier ,
																							a_Registration.GetComRegistration ().PerUserInitialization () ? ( BSTR ) a_User : NULL ,
																							a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( BSTR ) a_Locale : NULL  ,
																							t_NamespacePath ,
																							NULL ,
																							NULL ,
																							t_Sink    
																						) ;

																						if ( SUCCEEDED ( t_Result ) )
																						{
																							t_ProviderInitSink->Wait ( a_Registration.GetInitializationTimeoutMilliSeconds () ) ;

																							if ( SUCCEEDED ( t_Result = t_ProviderInitSink->GetResult () ) )
																							{
																								t_Result = t_Interceptor->QueryInterface ( a_RIID , a_Interface ) ;
																							}
																						}

																						t_Sink->Release () ;
																					}
																					else
																					{
																						t_Result = WBEM_E_OUT_OF_MEMORY ;
																					}
																				}

																				t_ProviderInitSink->Release () ;
																			}
																			else
																			{
																				t_Result = WBEM_E_OUT_OF_MEMORY ;
																			}

																			t_InterceptorInit->Release () ;
																		}
																	}
																	else
																	{
																		ProviderSubSystem_Globals :: GetSyncProviderController ()->UnLock () ;

																		t_Result = WBEM_E_OUT_OF_MEMORY ;
																	}

																	t_Interceptor->SetInitialized ( t_Result ) ;

																	t_Interceptor->Release () ;
																}
																else
																{
																	t_Result = WBEM_E_OUT_OF_MEMORY ;
																}

																t_Unknown->Release () ;
															}
														}
													}
												}

												t_Proxy->Release () ;
											}
											else
											{
												t_Result = WBEM_E_OUT_OF_MEMORY ;
											}
										}
									}

									t_Sink->Release () ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							t_ProviderInitSink->Release () ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

						t_ThreadInit->Release () ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
	
			t_StaThread->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;

		if ( a_TransactionIdentifier )
		{
			StringFromGUID2 ( *a_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
		}

		if ( SUCCEEDED ( t_Result ) ) 
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_LoadOperationEvent ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				t_NamespacePath,
				a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
				a_User ,
				a_Locale ,
				a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
				a_Registration.GetComRegistration ().GetClsidServer ().GetProviderClsid () ,
				a_Registration.GetComRegistration ().GetClsidServer ().GetServer_Name () ,
				a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
				a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
				a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetInProcServer32_Path () : NULL ,
				a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetLocalServer32_Path () : NULL ,
				( ULONG ) a_Registration.GetComRegistration ().GetClsidServer ().GetThreadingModel () ,
				( ULONG ) a_Registration.GetComRegistration ().GetClsidServer ().GetSynchronization ()
			) ;
		}
		else
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_LoadOperationFailureEvent ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				t_NamespacePath,
				a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
				a_User ,
				a_Locale ,
				a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
				a_Registration.GetComRegistration ().GetClsidServer ().GetProviderClsid () ,
				a_Registration.GetComRegistration ().GetClsidServer ().GetServer_Name () ,
				a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
				a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
				a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetInProcServer32_Path () : NULL ,
				a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetLocalServer32_Path () : NULL ,
				( ULONG ) a_Registration.GetComRegistration ().GetClsidServer ().GetThreadingModel () ,
				( ULONG ) a_Registration.GetComRegistration ().GetClsidServer ().GetSynchronization () ,
				t_Result 
			);
		}

		delete [] t_NamespacePath ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: CreateSyncProvider ( 

	IWbemServices *a_Stub ,
	IUnknown *a_ServerSideProvider ,
	wchar_t *a_NamespacePath ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	REFIID a_RIID , 
	void **a_Interface ,
	CServerObject_ProviderRegistrationV1 &a_Registration
)
{
	HRESULT t_Result = S_OK ;

	GUID t_Guid ;
	t_Result = CoCreateGuid ( & t_Guid ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		CInterceptor_IWbemSyncProvider *t_Interceptor = new CInterceptor_IWbemSyncProvider (

			m_Allocator , 
			a_ServerSideProvider ,
			a_Stub ,
			ProviderSubSystem_Globals :: GetSyncProviderController () , 
			a_Context ,
			a_Registration ,
			t_Guid
		) ;

		if ( t_Interceptor ) 
		{
			t_Interceptor->AddRef () ;

			CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator ;

			ProviderSubSystem_Globals :: GetSyncProviderController ()->Lock () ;

			WmiStatusCode t_StatusCode = ProviderSubSystem_Globals :: GetSyncProviderController ()->Insert ( 

				*t_Interceptor ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				ProviderSubSystem_Globals :: GetSyncProviderController ()->UnLock () ;

				_IWmiProviderInitialize *t_InterceptorInit = NULL ;

				t_Result = t_Interceptor->QueryInterface ( IID__IWmiProviderInitialize , ( void ** ) & t_InterceptorInit ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
					if ( t_ProviderInitSink )
					{
						t_ProviderInitSink->AddRef () ;

						t_Result = t_ProviderInitSink->SinkInitialize () ;
						if ( SUCCEEDED ( t_Result ) ) 
						{

							CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
							if ( t_Sink )
							{
								t_Sink->AddRef () ;

								t_Result = t_InterceptorInit->Initialize (

									0 ,
									a_Context ,
									a_TransactionIdentifier ,
									a_Registration.GetComRegistration ().PerUserInitialization () ? ( BSTR ) a_User : NULL ,
									a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( BSTR ) a_Locale : NULL  ,
									a_NamespacePath ,
									NULL ,
									NULL ,
									t_Sink    
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_ProviderInitSink->Wait ( a_Registration.GetInitializationTimeoutMilliSeconds () ) ;

									if ( SUCCEEDED ( t_Result = t_ProviderInitSink->GetResult () ) )
									{
										t_Result = t_Interceptor->QueryInterface ( a_RIID , a_Interface ) ;
										if ( SUCCEEDED ( t_Result ) )
										{
										}
									}
								}

								t_Sink->Release () ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}

						t_ProviderInitSink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					t_InterceptorInit->Release () ;
				}
			}
			else
			{
				ProviderSubSystem_Globals :: GetSyncProviderController ()->UnLock () ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			t_Interceptor->SetInitialized ( t_Result ) ;

			t_Interceptor->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: InitializeServerProvider ( 

	IWbemServices *a_Stub ,
	IUnknown *a_ProviderInterface ,
	wchar_t *a_NamespacePath ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	REFIID a_RIID , 
	void **a_Interface ,
	CServerObject_ProviderRegistrationV1 &a_Registration
)
{
	HRESULT t_Result = S_OK ;

	wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;

	if ( a_TransactionIdentifier )
	{
		StringFromGUID2 ( *a_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
	}

	if ( a_Registration.GetEventProviderRegistration ().Supported () )
	{
		IWbemProviderIdentity *t_ProviderIdentity = NULL ;
		t_Result = a_ProviderInterface->QueryInterface ( IID_IWbemProviderIdentity , ( void ** ) & t_ProviderIdentity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemProviderIdentity , t_ProviderIdentity , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_ProviderIdentity->SetRegistrationObject (

							0 ,
							a_Registration.GetIdentity () 
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemProviderIdentity *t_ProviderIdentityProxy = ( IWbemProviderIdentity * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_ProviderIdentityProxy ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								try
								{
									t_Result = t_ProviderIdentityProxy->SetRegistrationObject (

										0 ,
										a_Registration.GetIdentity () 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}	

						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}	

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_ProviderIdentity->Release () ;
		}
	}

	IWbemProviderInit *t_ProviderInit = NULL ;
	t_Result = a_ProviderInterface->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & t_ProviderInit ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Registration.GetComRegistration ().PerUserInitialization () && a_Registration.GetComRegistration ().InitializeAsAdminFirst () )
		{
			CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
			if ( t_ProviderInitSink )
			{
				t_ProviderInitSink->AddRef () ;

				t_Result = t_ProviderInitSink->SinkInitialize ( a_Registration.GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						BOOL t_Impersonating = FALSE ;
						IUnknown *t_OldContext = NULL ;
						IServerSecurity *t_OldSecurity = NULL ;

						t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							BOOL t_Revert = FALSE ;
							IUnknown *t_Proxy = NULL ;

							t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemProviderInit , t_ProviderInit , t_Proxy , t_Revert ) ;
							if ( t_Result == WBEM_E_NOT_FOUND )
							{
								try
								{
									t_Result = t_ProviderInit->Initialize (

										NULL ,
										0 ,
										( const BSTR ) a_NamespacePath ,
										a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
										a_Stub ,
										a_Context ,
										t_Sink    
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								if ( SUCCEEDED ( t_Result ) )
								{
									IWbemProviderInit *t_ProviderInitProxy = ( IWbemProviderInit * ) t_Proxy ;

									// Set cloaking on the proxy
									// =========================

									DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

									t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

										t_ProviderInitProxy ,
										RPC_C_AUTHN_LEVEL_CONNECT , 
										t_ImpersonationLevel
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										t_Result = CoImpersonateClient () ;
										if ( SUCCEEDED ( t_Result ) )
										{
											try
											{
												t_Result = t_ProviderInitProxy->Initialize (

													NULL ,
													0 ,
													( const BSTR ) a_NamespacePath ,
													a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
													a_Stub ,
													a_Context ,
													t_Sink    
												) ;
											}
											catch ( ... )
											{
												t_Result = WBEM_E_PROVIDER_FAILURE ;
											}

											CoRevertToSelf () ;
										}
										else
										{
											t_Result = WBEM_E_ACCESS_DENIED ;
										}
									}	

									HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
								}
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								t_ProviderInitSink->Wait ( a_Registration.GetInitializationTimeoutMilliSeconds () ) ;
								t_Result = t_ProviderInitSink->GetResult () ;
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								WmiSetAndCommitObject (

									ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationEvent ] , 
									WMI_SENDCOMMIT_SET_NOT_REQUIRED,
									a_NamespacePath,
									a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
									a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
									a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
									a_TransactionIdentifier ? t_TransactionIdentifier : NULL
								) ;
							}
							else
							{
								WmiSetAndCommitObject (

									ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationFailureEvent ] , 
									WMI_SENDCOMMIT_SET_NOT_REQUIRED,
									a_NamespacePath,
									a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
									a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
									a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
									a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
									t_Result 
								) ;

								t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
							}

							ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
						}	

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				t_ProviderInitSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )	
		{
			CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
			if ( t_ProviderInitSink )
			{
				t_ProviderInitSink->AddRef () ;

				t_Result = t_ProviderInitSink->SinkInitialize ( a_Registration.GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						BOOL t_Impersonating = FALSE ;
						IUnknown *t_OldContext = NULL ;
						IServerSecurity *t_OldSecurity = NULL ;

						t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							BOOL t_Revert = FALSE ;
							IUnknown *t_Proxy = NULL ;

							t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemProviderInit , t_ProviderInit , t_Proxy , t_Revert ) ;
							if ( t_Result == WBEM_E_NOT_FOUND )
							{
								try
								{
									t_Result = t_ProviderInit->Initialize (

										a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
										0 ,
										( const BSTR ) a_NamespacePath ,
										a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
										a_Stub ,
										a_Context ,
										t_Sink    
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								if ( SUCCEEDED ( t_Result ) )
								{
									IWbemProviderInit *t_ProviderInitProxy = ( IWbemProviderInit * ) t_Proxy ;

									// Set cloaking on the proxy
									// =========================

									DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

									t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

										t_ProviderInitProxy ,
										RPC_C_AUTHN_LEVEL_CONNECT , 
										t_ImpersonationLevel
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										t_Result = CoImpersonateClient () ;
										if ( SUCCEEDED ( t_Result ) )
										{
											try
											{
												t_Result = t_ProviderInitProxy->Initialize (

													a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
													0 ,
													( const BSTR ) a_NamespacePath ,
													a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
													a_Stub ,
													a_Context ,
													t_Sink    
												) ;
											}
											catch ( ... )
											{
												t_Result = WBEM_E_PROVIDER_FAILURE ;
											}

											CoRevertToSelf () ;
										}
										else
										{
											t_Result = WBEM_E_ACCESS_DENIED ;
										}
									}	

									HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
								}
							}	

							if ( SUCCEEDED ( t_Result ) )
							{
								t_ProviderInitSink->Wait ( a_Registration.GetInitializationTimeoutMilliSeconds () ) ;
								t_Result = t_ProviderInitSink->GetResult () ;
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								WmiSetAndCommitObject (

									ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationEvent ] , 
									WMI_SENDCOMMIT_SET_NOT_REQUIRED,
									a_NamespacePath,
									a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
									a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
									a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
									a_TransactionIdentifier ? t_TransactionIdentifier : NULL
								) ;
							}
							else
							{
								WmiSetAndCommitObject (

									ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationFailureEvent ] , 
									WMI_SENDCOMMIT_SET_NOT_REQUIRED,
									a_NamespacePath,
									a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
									a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
									a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
									a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
									t_Result 
								) ;

								t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
							}

							ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				t_ProviderInitSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		t_ProviderInit->Release () ;
	}
	else
	{
		if ( a_Registration.GetPropertyProviderRegistration ().Supported () || a_Registration.GetEventConsumerProviderRegistration ().Supported () )
		{
			if (	a_Registration.GetClassProviderRegistration ().Supported () ||
					a_Registration.GetInstanceProviderRegistration ().Supported () ||
					a_Registration.GetMethodProviderRegistration ().Supported () ||
					a_Registration.GetEventProviderRegistration ().Supported () )
			{
				t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
			else
			{
				t_Result = S_OK ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: InitializeNonApartmentProvider ( 

	IWbemServices *a_Stub ,
	IUnknown *a_ServerSideProviderInterface ,
	wchar_t *a_NamespacePath ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	REFIID a_RIID , 
	void **a_Interface ,
	CServerObject_ProviderRegistrationV1 &a_Registration
)
{
	HRESULT t_Result = S_OK ;

	if ( a_ServerSideProviderInterface )
	{
		t_Result = InitializeServerProvider (

			a_Stub ,
			a_ServerSideProviderInterface ,
			a_NamespacePath ,
			a_Flags ,
			a_Context ,
			a_TransactionIdentifier ,
			a_User ,
			a_Locale ,
			a_Scope,
			a_RIID , 
			a_Interface ,
			a_Registration
		) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateSyncProvider (

			a_Stub ,
			a_ServerSideProviderInterface ,
			a_NamespacePath ,
			a_Flags ,
			a_Context ,
			a_TransactionIdentifier ,
			a_User ,
			a_Locale ,
			a_Scope,
			a_RIID , 
			a_Interface ,
			a_Registration
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: GetNonApartmentProvider ( 

	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	REFIID a_RIID , 
	void **a_Interface ,
	CServerObject_ProviderRegistrationV1 &a_Registration
)
{
	wchar_t *t_NamespacePath = NULL ;

	HRESULT t_Result = ProviderSubSystem_Common_Globals :: GetNamespacePath ( 

		Direct_GetNamespacePath () , 
		t_NamespacePath
	) ;

	if ( SUCCEEDED ( t_Result ) ) 
	{
		IUnknown *t_ServerSideProviderInterface = NULL ;

		t_Result = CreateServerSide (

			a_Registration ,
			a_TransactionIdentifier ,
			a_User ,
			a_Locale ,
			t_NamespacePath ,
			& t_ServerSideProviderInterface 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
#ifdef INTERNAL_IDENTIFY
			CInterceptor_IWbemServices_Proxy *t_Proxy = new CInterceptor_IWbemServices_Proxy ( 

				NULL ,
				m_Allocator , 
				Direct_GetService () ,
				a_Registration 
			) ;
#else
			CInterceptor_IWbemServices_RestrictingInterceptor *t_Proxy = new CInterceptor_IWbemServices_RestrictingInterceptor ( 

				m_Allocator , 
				Direct_GetService () ,
				a_Registration
			) ;
#endif
			if ( t_Proxy )
			{
				t_Proxy->AddRef () ;

				t_Result = t_Proxy->ServiceInitialize () ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = InitializeNonApartmentProvider (

						t_Proxy ,
						t_ServerSideProviderInterface ,
						t_NamespacePath ,
						a_Flags ,
						a_Context ,
						a_TransactionIdentifier ,
						a_User ,
						a_Locale ,
						a_Scope,
						a_RIID , 
						a_Interface ,
						a_Registration
					) ;
				}

				t_Proxy->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			if ( t_ServerSideProviderInterface )
			{
				t_ServerSideProviderInterface->Release () ;
			}
		}

		wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;

		if ( a_TransactionIdentifier )
		{
			StringFromGUID2 ( *a_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
		}

		if ( SUCCEEDED ( t_Result ) ) 
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_LoadOperationEvent ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				t_NamespacePath,
				a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
				a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
				a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
				a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
				a_Registration.GetComRegistration ().GetClsidServer ().GetProviderClsid () ,
				a_Registration.GetComRegistration ().GetClsidServer ().GetServer_Name () ,
				a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
				a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
				a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetInProcServer32_Path () : NULL ,
				a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetLocalServer32_Path () : NULL ,
				( ULONG ) a_Registration.GetComRegistration ().GetClsidServer ().GetThreadingModel () ,
				( ULONG ) a_Registration.GetComRegistration ().GetClsidServer ().GetSynchronization ()
			) ;
		}
		else
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_LoadOperationFailureEvent ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				t_NamespacePath,
				a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
				a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
				a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
				a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
				a_Registration.GetComRegistration ().GetClsidServer ().GetProviderClsid () ,
				a_Registration.GetComRegistration ().GetClsidServer ().GetServer_Name () ,
				a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
				a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? VARIANT_TRUE : VARIANT_FALSE ,
				a_Registration.GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetInProcServer32_Path () : NULL ,
				a_Registration.GetComRegistration ().GetClsidServer ().LocalServer32 () == e_True ? a_Registration.GetComRegistration ().GetClsidServer ().GetLocalServer32_Path () : NULL ,
				( ULONG ) a_Registration.GetComRegistration ().GetClsidServer ().GetThreadingModel () ,
				( ULONG ) a_Registration.GetComRegistration ().GetClsidServer ().GetSynchronization () ,
				t_Result 
			);
		}

		if ( FAILED ( t_Result ) )
		{
			t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}

		delete [] t_NamespacePath ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: GetHostedProvider ( 
	
	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	LPCWSTR a_Name ,
	ULONG a_Host ,
	LPCWSTR a_HostingGroup ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = WBEM_E_NOT_SUPPORTED ;
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: GetClassProvider (

    LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	IWbemClassObject *a_Class ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	try 
	{
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: GetDynamicPropertyResolver (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	try 
	{
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: GetProvider ( 

	WmiInternalContext a_InternalContext ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope,
	LPCWSTR a_Name ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		if ( a_InternalContext.m_IdentifyHandle )
		{
			HANDLE t_IdentifyToken = ( HANDLE ) a_InternalContext.m_IdentifyHandle ;

			BOOL t_Status = SetThreadToken ( NULL , t_IdentifyToken ) ;
			if ( t_Status )
			{
				t_Result = ProviderSubSystem_Globals :: BeginThreadImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

				RevertToSelf () ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}

			CloseHandle ( t_IdentifyToken ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemPath *t_Scope = NULL ;

			if ( a_Scope ) 
			{
				t_Result = CoCreateInstance (

					CLSID_WbemDefPath ,
					NULL ,
					CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
					IID_IWbemPath ,
					( void ** )  & t_Scope
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Scope->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Scope ) ;
				}
			}

			if ( SUCCEEDED ( t_Result ) ) 
			{
				CServerObject_ProviderRegistrationV1 *t_Registration = new CServerObject_ProviderRegistrationV1 ;
				if ( t_Registration )
				{
					t_Registration->AddRef () ;

					t_Result = t_Registration->SetContext ( 

						a_Context ,
						Direct_GetNamespacePath () , 
						Direct_GetRepository ()
					) ;
					
					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_Registration->ObjectProvider () )
						{
							if ( t_Registration->EventProvider () )
							{
								t_Registration->SetUnloadTimeoutMilliSeconds (
								
									ProviderSubSystem_Globals :: s_ObjectCacheTimeout < ProviderSubSystem_Globals :: s_EventCacheTimeout ? 
									
										ProviderSubSystem_Globals :: s_EventCacheTimeout :	ProviderSubSystem_Globals :: s_ObjectCacheTimeout
								) ;
							}
							else
							{
								t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_ObjectCacheTimeout ) ;
							}
						}
						else
						{
							if ( t_Registration->EventProvider () )
							{
								t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_EventCacheTimeout ) ;
							}
						}

						t_Result = t_Registration->Load ( 

							e_All ,
							t_Scope , 
							a_Name
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							IUnknown *t_Unknown = NULL ;

							if ( t_Registration->GetComRegistration ().GetHosting () == e_Hosting_SelfHost )
							{
								t_Result = GetNonApartmentProvider ( 

									a_Flags ,
									a_Context ,
									a_TransactionIdentifier ,
									a_User ,
									a_Locale ,
									a_Scope,
									IID_IUnknown , 
									( void ** ) & t_Unknown ,
									*t_Registration
								) ;
							}
							else
							{
								if ( t_Registration->GetComRegistration ().GetClsidServer ().InProcServer32 () == e_True )
								{
									switch ( t_Registration->GetThreadingModel () )
									{
										case e_Apartment:
										{
											t_Result = GetApartmentInstanceProvider ( 

												a_Flags ,
												a_Context ,
												a_TransactionIdentifier ,
												a_User ,
												a_Locale ,
												a_Scope,
												IID_IUnknown , 
												( void ** ) & t_Unknown ,
												*t_Registration
											) ;
										}
										break ;

										case e_Both:
										case e_Free:
										case e_Neutral:
										{
											t_Result = GetNonApartmentProvider ( 

												a_Flags ,
												a_Context ,
												a_TransactionIdentifier ,
												a_User ,
												a_Locale ,
												a_Scope,
												IID_IUnknown , 
												( void ** ) & t_Unknown ,
												*t_Registration
											) ;
										}
										break ;

										case e_ThreadingModel_Unknown:
										default:
										{
											t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
										}
										break ;
									}
								}
								else
								{
									t_Result = GetNonApartmentProvider ( 

										a_Flags ,
										a_Context ,
										a_TransactionIdentifier ,
										a_User ,
										a_Locale ,
										a_Scope,
										IID_IUnknown , 
										( void ** ) & t_Unknown ,
										*t_Registration
									) ;
								}
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{	
								t_Result = CheckInterfaceConformance (

									*t_Registration ,
									t_Unknown
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_Unknown->QueryInterface ( a_RIID , a_Interface ) ;
								}

								t_Unknown->Release () ;

							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND )
							{
								t_Result = WBEM_E_PROVIDER_NOT_FOUND ;
							}	
							else
							{
								t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
							}
						}
					}

					t_Registration->Release () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( t_Scope ) 
			{
				t_Scope->Release () ;
			}

			if ( a_InternalContext.m_IdentifyHandle )
			{
				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

				RevertToSelf () ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: GetDecoupledProvider (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope,
	LPCWSTR a_Name ,
	REFIID a_RIID , 
	void **a_Interface 
) 
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	try 
	{
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: Initialize (

	_IWmiProvSS *a_SubSys ,
	_IWmiProviderFactory *a_Factory ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Namespace ,
	IWbemServices *a_Repository ,
	IWbemServices *a_Service
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Namespace ) 
	{
		m_Namespace = new wchar_t [ wcslen ( a_Namespace ) + 1 ] ;
		if ( m_Namespace ) 
		{
			wcscpy ( m_Namespace , a_Namespace ) ;
		}
		else
		{	
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CoCreateInstance (

				CLSID_WbemDefPath ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IWbemPath ,
				( void ** )  & m_NamespacePath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = m_NamespacePath->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Namespace ) ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_Flags = a_Flags ;
		m_Context = a_Context ;
		m_Repository = a_Repository ;
		m_Service = a_Service ;

		if ( m_Context ) 
		{
			m_Context->AddRef () ;
		}

		if ( m_Repository ) 
		{
			m_Repository->AddRef () ;
		}

		if ( m_Service ) 
		{
			m_Service->AddRef () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_RawFactory :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	try 
	{
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
	}

	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provresv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvResv.h"
#include "ProvFact.h"
#include "ProvSubS.h"
#include "guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DynamicPropertyProviderResolver :: CServerObject_DynamicPropertyProviderResolver (

	WmiAllocator &a_Allocator ,
	_IWmiProviderFactory *a_Factory ,
	IWbemServices *a_CoreStub

) : m_ReferenceCount ( 0 ) ,
	m_Allocator ( a_Allocator ) ,
	m_Factory ( a_Factory ) ,
	m_CoreStub ( a_CoreStub ) ,
	m_User ( NULL ) ,
	m_Locale ( NULL )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_DynamicPropertyProviderResolver_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_Factory ) 
	{
		m_Factory->AddRef () ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->AddRef () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_DynamicPropertyProviderResolver::~CServerObject_DynamicPropertyProviderResolver ()
{
	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_Factory ) 
	{
		m_Factory->Release () ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_DynamicPropertyProviderResolver_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_DynamicPropertyProviderResolver::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiDynamicPropertyResolver )
	{
		*iplpv = ( LPVOID ) ( _IWmiDynamicPropertyResolver * ) this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * )this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_DynamicPropertyProviderResolver :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_DynamicPropertyProviderResolver :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderResolver :: GetClassAndInstanceContext (

	IWbemClassObject *a_Class ,
	IWbemClassObject *a_Instance ,
	BSTR &a_ClassContext ,
	BSTR &a_InstanceContext ,
	BOOL &a_Dynamic
)
{
	HRESULT t_Result = S_OK ;

	a_Dynamic = FALSE ;
	a_ClassContext = NULL ;
	a_InstanceContext = NULL ;

	IWbemQualifierSet *t_InstanceQualifierObject = NULL ;
	t_Result = a_Instance->GetQualifierSet ( & t_InstanceQualifierObject ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		LONG t_Flavour = 0 ;
		t_Result = t_InstanceQualifierObject->Get (
			
			ProviderSubSystem_Globals :: s_DynProps ,
			0 ,
			& t_Variant ,
			& t_Flavour 
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( t_Variant.vt == VT_BOOL ) 
			{
				if ( t_Variant.boolVal == VARIANT_TRUE )
				{
					a_Dynamic = TRUE ;
 
					VARIANT t_Variant ;
					VariantInit ( & t_Variant ) ;

					t_Flavour = 0 ;
					HRESULT t_TempResult = t_InstanceQualifierObject->Get (
						
						ProviderSubSystem_Globals :: s_InstanceContext ,
						0 ,
						& t_Variant ,
						& t_Flavour 
					) ;

					if ( SUCCEEDED ( t_TempResult ) ) 
					{
						if ( t_Variant.vt == VT_BSTR ) 
						{
							a_InstanceContext = SysAllocString ( t_Variant.bstrVal ) ;
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}

						VariantClear ( & t_Variant ) ;
					}

					VARIANT t_ClassContextVariant ;
					VariantInit ( & t_ClassContextVariant ) ;

					t_TempResult = t_InstanceQualifierObject->Get (
						
						ProviderSubSystem_Globals :: s_ClassContext ,
						0 ,
						& t_ClassContextVariant ,
						& t_Flavour 
					) ;

					if ( SUCCEEDED ( t_TempResult ) ) 
					{
						if ( t_ClassContextVariant.vt == VT_BSTR ) 
						{
							a_ClassContext = SysAllocString ( t_ClassContextVariant.bstrVal ) ;
						}
						else
						{
							t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
						}

						VariantClear ( & t_ClassContextVariant ) ;
					}

					if ( a_ClassContext == NULL )
					{
						IWbemQualifierSet *t_ClassQualifierObject = NULL ;
						t_Result = a_Class->GetQualifierSet ( & t_ClassQualifierObject ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT t_Variant ;
							VariantInit ( & t_Variant ) ;

							LONG t_Flavour = 0 ;

							HRESULT t_TempResult = t_ClassQualifierObject->Get (
								
								ProviderSubSystem_Globals :: s_ClassContext ,
								0 ,
								& t_Variant ,
								& t_Flavour 
							) ;

							if ( SUCCEEDED ( t_TempResult ) ) 
							{
								if ( t_Variant.vt == VT_BSTR ) 
								{
									a_ClassContext = SysAllocString ( t_Variant.bstrVal ) ;
								}
								else
								{
									t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
								}

								VariantClear ( & t_Variant ) ;
							}

							t_ClassQualifierObject->Release () ;
						}
						else
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
				}
			}
			else
			{
				t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
			}

			VariantClear ( & t_Variant ) ;
		}
		else
		{
			t_Result = S_OK ;
		}

		t_InstanceQualifierObject->Release () ;
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderResolver :: ReadOrWrite (

	IWbemContext *a_Context ,
	IWbemClassObject *a_Instance ,
	BSTR a_ClassContext ,
	BSTR a_InstanceContext ,
	BSTR a_PropertyContext ,
	BSTR a_Provider ,
	BSTR a_Property ,
	BOOL a_Read
)
{
	IWbemPropertyProvider *t_Provider = NULL ;

	WmiInternalContext t_InternalContext ;
	ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

	HRESULT t_Result = m_Factory->GetProvider ( 

		t_InternalContext ,
		0 ,
		a_Context ,
		NULL ,
		m_User ,
		m_Locale ,
		NULL ,
		a_Provider ,
		IID_IWbemPropertyProvider , 
		( void ** ) & t_Provider 

	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		if ( a_Read )
		{
			t_Result = t_Provider->GetProperty ( 

				0 ,
				m_Locale ,
				a_ClassContext ,
				a_InstanceContext ,
				a_PropertyContext ,
				& t_Variant 			
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = a_Instance->Put ( a_Property , 0 , & t_Variant , 0 ) ;

				VariantClear ( & t_Variant ) ;
			}	
		}
		else
		{
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			t_Result = a_Instance->Get ( a_Property , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Provider->PutProperty ( 

					0 ,
					m_Locale ,
					a_ClassContext ,
					a_InstanceContext ,
					a_PropertyContext ,
					& t_Variant 			
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = a_Instance->Put ( a_Property , 0 , NULL , 0 ) ;
				}	

				VariantClear ( & t_Variant ) ;
			}
		}

		t_Provider->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderResolver :: ReadOrWrite (

	IWbemContext *a_Context ,
	IWbemClassObject *a_Class ,
	IWbemClassObject *a_Instance ,
	BOOL a_Read
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_ClassContext = NULL ;
	BSTR t_InstanceContext = NULL ;
	BOOL t_Dynamic = FALSE ;

	t_Result = GetClassAndInstanceContext (

		a_Class ,
		a_Instance ,
		t_ClassContext ,
		t_InstanceContext ,
		t_Dynamic
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Dynamic )
		{
			IWbemQualifierSet *t_InstanceQualifierObject = NULL ;
			t_Result = a_Instance->GetQualifierSet ( & t_InstanceQualifierObject ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;

				BSTR t_Property = NULL ;
				CIMTYPE t_Type = CIM_EMPTY ;

				a_Instance->BeginEnumeration ( WBEM_FLAG_NONSYSTEM_ONLY ) ;
				while ( SUCCEEDED ( t_Result ) && ( a_Instance->Next ( 0 , & t_Property , &t_Variant  , &t_Type , NULL ) == WBEM_NO_ERROR ) )
				{
					BSTR t_PropertyContext = NULL ;
					BSTR t_Provider = NULL ;

					IWbemQualifierSet *t_PropertyQualifierSet = NULL ;
					if ( ( a_Instance->GetPropertyQualifierSet ( t_Property , &t_PropertyQualifierSet ) ) == WBEM_NO_ERROR ) 
					{
						VARIANT t_DynamicVariant ;
						VariantInit ( & t_DynamicVariant ) ;

						LONG t_Flag = 0 ;

						if ( SUCCEEDED ( t_PropertyQualifierSet->Get ( ProviderSubSystem_Globals :: s_Dynamic  , 0 , & t_DynamicVariant , &t_Flag ) ) )
						{
							if ( t_DynamicVariant.vt == VT_BOOL )
							{
								if ( t_DynamicVariant.boolVal == VARIANT_TRUE )
								{
									VARIANT t_ProviderVariant ;
									VariantInit ( & t_ProviderVariant ) ;

									t_Flag = 0 ;
									if ( SUCCEEDED ( t_PropertyQualifierSet->Get ( ProviderSubSystem_Globals :: s_Provider  , 0 , & t_ProviderVariant , &t_Flag ) ) )
									{
										if ( t_ProviderVariant.vt == VT_BSTR )
										{
											t_Provider = SysAllocString ( t_ProviderVariant.bstrVal ) ;
										}
										else
										{
											t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
										}

										VariantClear ( & t_ProviderVariant ) ;
									}
									else
									{
										t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
									}

									VARIANT t_PropertyContextVariant ;
									VariantInit ( & t_PropertyContextVariant ) ;

									t_Flag = 0 ;
									if ( SUCCEEDED ( t_PropertyQualifierSet->Get ( ProviderSubSystem_Globals :: s_PropertyContext  , 0 , & t_PropertyContextVariant , &t_Flag ) ) )
									{
										if ( t_PropertyContextVariant.vt == VT_BSTR )
										{
											t_PropertyContext = SysAllocString ( t_PropertyContextVariant.bstrVal ) ;
										}
										else
										{
											t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
										}

										VariantClear ( & t_PropertyContextVariant ) ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
							}

							VariantClear ( & t_DynamicVariant ) ;
						}
					}

					if ( SUCCEEDED ( t_Result ) && t_Provider ) 
					{
						t_Result = ReadOrWrite ( 

							a_Context ,
							a_Instance ,
							t_ClassContext ,
							t_InstanceContext ,
							t_PropertyContext ,
							t_Provider ,
							t_Property ,
							a_Read 
						) ;
					}

					if ( t_PropertyContext ) 
					{
						SysFreeString ( t_PropertyContext ) ;
					}

					if ( t_Provider )
					{
						SysFreeString ( t_Provider ) ;
					}
				}

				t_InstanceQualifierObject->Release () ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( t_ClassContext ) 
		{
			SysFreeString ( t_ClassContext ) ;
		}

		if ( t_InstanceContext ) 
		{
			SysFreeString ( t_InstanceContext ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderResolver :: Read (

	IWbemContext *a_Context ,
	IWbemClassObject *a_Class ,
	IWbemClassObject **a_Instance
)
{
	IWbemClassObject *t_Object = *a_Instance ;

	HRESULT t_Result = ReadOrWrite ( 

		a_Context ,
		a_Class ,
		t_Object ,
		TRUE 
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderResolver :: Write (

	IWbemContext *a_Context ,
    IWbemClassObject *a_Class ,
    IWbemClassObject *a_Instance
)
{
	HRESULT t_Result = ReadOrWrite ( 

		a_Context ,
		a_Class ,
		a_Instance ,
		FALSE
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderResolver :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_Core ,         // For anybody
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	if ( a_User )
	{
		m_User = SysAllocString ( a_User ) ;
		if ( ! m_User ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Locale )
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( ! m_Locale ) 
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_DynamicPropertyProviderResolver :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provinsk.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvInSk.h"
#include "guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderInitSink :: CServerObject_ProviderInitSink (

	SECURITY_DESCRIPTOR *a_SecurityDescriptor 

)	:   m_ReferenceCount ( 0 ) , 
		m_Event ( NULL ) , 
		m_StatusCalled ( FALSE ) , 
		m_Result ( S_OK ) ,
		m_SecurityDescriptor ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderInitSink :: ~CServerObject_ProviderInitSink () 
{
	if ( m_Event ) 
	{
		CloseHandle ( m_Event ) ;
	}

	if ( m_SecurityDescriptor )
	{
		delete [] ( BYTE * ) m_SecurityDescriptor ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderInitSink :: SinkInitialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor )
{
	HRESULT t_Result = S_OK ;

	m_Event = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	if ( m_Event )
	{
		if ( a_SecurityDescriptor )
		{
			t_Result = ProviderSubSystem_Common_Globals :: SinkAccessInitialize ( a_SecurityDescriptor , m_SecurityDescriptor ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_ProviderInitSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemProviderInitSink )
	{
		*iplpv = ( LPVOID ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_ProviderInitSink :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_ProviderInitSink :: Release ()
{
	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderInitSink :: SetStatus (

    LONG a_Status,
    LONG a_Flags 
)
{
	HRESULT t_Result = S_OK ;
	if ( m_SecurityDescriptor )
	{
		t_Result = CoImpersonateClient () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Check_SecurityDescriptor_CallIdentity (

				m_SecurityDescriptor , 
				MASK_PROVIDER_BINDING_BIND ,
				& g_ProviderBindingMapping
			) ;

			CoRevertToSelf () ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_Result = a_Status ;
	}
	else
	{
		m_Result = t_Result ;
	}

	SetEvent ( m_Event ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemProviderInitSink :: CInterceptor_IWbemProviderInitSink (

	IWbemProviderInitSink *a_InterceptedSink

)	:	m_ReferenceCount ( 0 ) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_StatusCalled ( FALSE ) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemProviderInitSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemProviderInitSink::~CInterceptor_IWbemProviderInitSink ()
{
	if ( ! m_StatusCalled ) 
	{
		m_InterceptedSink->SetStatus ( WBEM_E_UNEXPECTED , 0 ) ; 
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemProviderInitSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemProviderInitSink::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemProviderInitSink )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInitSink * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemProviderInitSink :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemProviderInitSink :: Release ()
{
	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProviderInitSink :: SetStatus (

	LONG a_Status,
    LONG a_Flags 
)
{
	HRESULT t_Result = S_OK ;

	m_StatusCalled = TRUE ;

	m_InProgress ++ ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedSink->SetStatus ( 

			a_Status,
			a_Flags 
		) ;
	}

	m_InProgress -- ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProviderInitSink :: Shutdown ()
{
	HRESULT t_Result = S_OK ;

	m_GateClosed ++ ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;
			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provrmgr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvSubS.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <wbemint.h>

#include <HelperFuncs.h>
#include <Logging.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ClassFac.h"
#include "ProvRMgr.h"
#include "Guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerProvRefreshManagerClassFactory :: CServerProvRefreshManagerClassFactory () : m_ReferenceCount ( 0 )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerProvRefreshManagerClassFactory_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerProvRefreshManagerClassFactory :: ~CServerProvRefreshManagerClassFactory ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerProvRefreshManagerClassFactory_ObjectsInProgress  ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;	
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerProvRefreshManagerClassFactory :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) ( IClassFactory * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerProvRefreshManagerClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerProvRefreshManagerClassFactory :: Release ()
{
	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerProvRefreshManagerClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR *ppvObject
)
{
	HRESULT t_Result = S_OK ;

	if ( pUnkOuter )
	{
		t_Result = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		CServerObject_ProviderRefresherManager *t_Manager = new CServerObject_ProviderRefresherManager (

			*ProviderSubSystem_Globals :: s_Allocator
		) ;

		if ( t_Manager == NULL )
		{
			t_Result = E_OUTOFMEMORY ;
		}
		else
		{
			t_Result = t_Manager->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( t_Result ) )
			{
				delete t_Manager ;
			}
			else
			{
			}
		}			
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerProvRefreshManagerClassFactory :: LockServer ( BOOL fLock )
{
/*
 * Place code in critical section
 */

	if ( fLock )
	{
		InterlockedIncrement ( & ProviderSubSystem_Globals :: s_LocksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & ProviderSubSystem_Globals :: s_LocksInProgress ) ;
	}

	return S_OK	;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CServerObject_InterceptorProviderRefresherManager :: CServerObject_InterceptorProviderRefresherManager (

	CWbemGlobal_IWbemRefresherMgrController *a_Controller ,
	const ULONG &a_Period ,
	WmiAllocator &a_Allocator ,
	IWbemContext *a_InitializationContext

) : RefresherManagerCacheElement ( 

		a_Controller ,
		this ,
		a_Period 
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Manager ( NULL ) ,
	m_ProxyContainer ( m_Allocator , 2 , MAX_PROXIES ) ,
	m_Shutdown ( NULL ) ,
	m_Host ( NULL ) ,
	m_ReferenceCount ( 0 ) ,
	m_UnInitialized ( 0 ) ,
	m_Initialized ( 0 ) ,
	m_InitializeResult ( S_OK ) ,
	m_InitializedEvent ( NULL ) , 
	m_InitializationContext ( a_InitializationContext )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_InterceptorProviderRefresherManager_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_InitializationContext )
	{
		m_InitializationContext->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_InterceptorProviderRefresherManager :: ~CServerObject_InterceptorProviderRefresherManager ()
{
	if ( m_Manager )
	{
		m_Manager->Release () ;
	}

	if ( m_Host )
	{
		m_Host->Release () ;	
	}

	if ( m_Shutdown )
	{
		m_Shutdown->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_InterceptorProviderRefresherManager_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: AbnormalShutdown () 
{
	WmiStatusCode t_StatusCode = ProviderSubSystem_Globals :: GetRefresherManagerController ()->Shutdown ( this ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: SetManager ( _IWmiProviderHost *a_Host , _IWbemRefresherMgr *a_Manager )
{
	if ( a_Manager )
	{
		m_Manager = a_Manager ;
		m_Manager->AddRef () ;
	}

	if ( a_Host )
	{
		m_Host = a_Host ;
		m_Host->AddRef () ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: SetInitialized ( HRESULT a_InitializeResult )
{
	m_InitializeResult = a_InitializeResult ;

	InterlockedExchange ( & m_Initialized , 1 ) ;

	if ( m_InitializedEvent )
	{
		SetEvent ( m_InitializedEvent ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: IsIndependant ( IWbemContext *a_Context )
{
	BOOL t_DependantCall = FALSE ;
	HRESULT t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_DependantCall == FALSE )
		{
		}
		else
		{
			return S_FALSE ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout )
{
	HRESULT t_Result = WBEM_E_UNEXPECTED ;

	if ( m_Initialized == 0 )
	{
		BOOL t_DependantCall = FALSE ;
		t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_DependantCall == FALSE )
			{
				if ( WaitForSingleObject ( m_InitializedEvent , a_Timeout ) == WAIT_TIMEOUT )
				{
					return WBEM_E_PROVIDER_LOAD_FAILURE ;
				}
			}
			else
			{
				if ( WaitForSingleObject ( m_InitializedEvent , 0 ) == WAIT_TIMEOUT )
				{
					return S_FALSE ;
				}
			}
		}
	}
	else
	{
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: Initialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_InterceptorProviderRefresherManager :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * )this ;		
	}	
	else if ( iid == IID__IWbemRefresherMgr )
	{
		*iplpv = ( LPVOID ) ( _IWbemRefresherMgr * ) this ;		
	}	
	else if ( iid == IID_CServerObject_InterceptorProviderRefresherManager )
	{
		*iplpv = ( LPVOID ) this ;
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_InterceptorProviderRefresherManager :: AddRef ()
{
	return RefresherManagerCacheElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_InterceptorProviderRefresherManager :: Release ()
{
	return RefresherManagerCacheElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: Startup (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	_IWmiProvSS *a_ProvSS
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , IID__IWbemRefresherMgr , m_Manager , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Manager->Startup ( 

					a_Flags ,
					a_Context ,
					a_ProvSS
				) ;
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					_IWbemRefresherMgr *t_Manager = ( _IWbemRefresherMgr * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Manager ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Manager->Startup ( 

								a_Flags ,
								a_Context ,
								a_ProvSS
							) ;

							if ( FAILED ( t_Result ) )
							{
								if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
								{
									AbnormalShutdown () ;
								}
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}	

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = m_Manager->QueryInterface ( IID_IWbemShutdown , ( void ** ) & m_Shutdown ) ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		if ( m_Shutdown )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemShutdown , IID_IWbemShutdown , m_Shutdown , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_Shutdown->Shutdown ( 

						a_Flags ,
						a_MaxMilliSeconds ,
						a_Context
					) ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemShutdown *t_Shutdown = ( IWbemShutdown * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Shutdown ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Shutdown->Shutdown ( 

									a_Flags ,
									a_MaxMilliSeconds ,
									a_Context
								) ;

								if ( FAILED ( t_Result ) )
								{
									if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
									{
										AbnormalShutdown () ;
									}
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}	

						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemShutdown , t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: AddObjectToRefresher (

	IWbemServices *a_Service, 
	LPCWSTR a_ServerName, 
	LPCWSTR a_Namespace, 
	IWbemClassObject* pClassObject,
	WBEM_REFRESHER_ID *a_DestinationRefresherId, 
	IWbemClassObject *a_InstanceTemplate, 
	long a_Flags, 
	IWbemContext *a_Context,
	IUnknown* a_pLockMgr,
	WBEM_REFRESH_INFO *a_Information
) 
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	if ( m_Initialized == 0 )
	{
		return WBEM_E_NOT_FOUND ;
	}

	HRESULT t_Result = S_OK ;

	try
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , IID__IWbemRefresherMgr , m_Manager , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Manager->AddObjectToRefresher (

					a_Service, 
					a_ServerName, 
					a_Namespace, 
					pClassObject,
					a_DestinationRefresherId, 
					a_InstanceTemplate, 
					a_Flags, 
					a_Context,
					a_pLockMgr,
					a_Information
				) ;
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					_IWbemRefresherMgr *t_Manager = ( _IWbemRefresherMgr * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Manager ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Manager->AddObjectToRefresher (

								a_Service, 
								a_ServerName, 
								a_Namespace, 
								pClassObject,
								a_DestinationRefresherId, 
								a_InstanceTemplate, 
								a_Flags, 
								a_Context,
								a_pLockMgr,
								a_Information
							) ;

							if ( FAILED ( t_Result ) )
							{
								if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
								{
									AbnormalShutdown () ;
								}
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}	

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: AddEnumToRefresher (

	IWbemServices *a_Service, 
	LPCWSTR a_ServerName, 
	LPCWSTR a_Namespace, 
	IWbemClassObject* pClassObject,
	WBEM_REFRESHER_ID *a_DestinationRefresherId, 
	IWbemClassObject *a_InstanceTemplate, 
	LPCWSTR a_Class,
	long a_Flags, 
	IWbemContext *a_Context, 
	IUnknown* a_pLockMgr,
	WBEM_REFRESH_INFO *a_Information
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	if ( m_Initialized == 0 )
	{
		return WBEM_E_NOT_FOUND ;
	}

	HRESULT t_Result = S_OK ;

	try
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , IID__IWbemRefresherMgr , m_Manager , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Manager->AddEnumToRefresher (

					a_Service, 
					a_ServerName, 
					a_Namespace, 
					pClassObject,
					a_DestinationRefresherId, 
					a_InstanceTemplate, 
					a_Class,
					a_Flags, 
					a_Context, 
					a_pLockMgr,
					a_Information
				) ;
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					_IWbemRefresherMgr *t_Manager = ( _IWbemRefresherMgr * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Manager ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Manager->AddEnumToRefresher (

								a_Service, 
								a_ServerName, 
								a_Namespace, 
								pClassObject,
								a_DestinationRefresherId, 
								a_InstanceTemplate, 
								a_Class,
								a_Flags, 
								a_Context, 
								a_pLockMgr,
								a_Information
							) ;

							if ( FAILED ( t_Result ) )
							{
								if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
								{
									AbnormalShutdown () ;
								}
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}	

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: GetRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId , 
	long a_Flags, 
	BOOL a_AddRefresher,
	IWbemRemoteRefresher **a_RemoteRefresher ,  
	IUnknown* a_pLockMgr,
	GUID *a_Guid
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	if ( m_Initialized == 0 )
	{
		return WBEM_E_NOT_FOUND ;
	}

	HRESULT t_Result = S_OK ;

	try
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , IID__IWbemRefresherMgr , m_Manager , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Manager->GetRemoteRefresher (

					a_RefresherId , 
					a_Flags,
					a_AddRefresher,
					a_RemoteRefresher ,  
					a_pLockMgr,
					a_Guid
				) ;
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					_IWbemRefresherMgr *t_Manager = ( _IWbemRefresherMgr * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Manager ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Manager->GetRemoteRefresher (

								a_RefresherId , 
								a_Flags,
								a_AddRefresher,
								a_RemoteRefresher ,
								a_pLockMgr,
								a_Guid
							) ;

							if ( FAILED ( t_Result ) )
							{
								if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
								{
									AbnormalShutdown () ;
								}
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}	

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_InterceptorProviderRefresherManager :: LoadProvider (

	IWbemServices *a_Service ,
	LPCWSTR a_ProviderName ,
	LPCWSTR a_Namespace,
	IWbemContext * a_Context,
	IWbemHiPerfProvider **a_Provider,
	_IWmiProviderStack** a_ProvStack
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	if ( m_Initialized == 0 )
	{
		return WBEM_E_NOT_FOUND ;
	}

	HRESULT t_Result = S_OK ;

	try
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , IID__IWbemRefresherMgr , m_Manager , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Manager->LoadProvider (

					a_Service , 
					a_ProviderName ,
					a_Namespace ,
					a_Context ,
					a_Provider,
					a_ProvStack
				) ;
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					_IWbemRefresherMgr *t_Manager = ( _IWbemRefresherMgr * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Manager ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Manager->LoadProvider (

								a_Service , 
								a_ProviderName ,
								a_Namespace ,
								a_Context ,
								a_Provider ,
								a_ProvStack
							) ;

							if ( FAILED ( t_Result ) )
							{
								if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
								{
									AbnormalShutdown () ;
								}
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}	

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_RefresherManager_IWbemRefresherMgr , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRefresherManager :: CServerObject_ProviderRefresherManager (

	WmiAllocator &a_Allocator

) : m_Allocator ( a_Allocator ) ,
	m_Manager ( NULL ) ,
	m_Shutdown ( NULL ) ,
	m_ReferenceCount ( 0 )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_ProviderRefresherManager_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRefresherManager :: ~CServerObject_ProviderRefresherManager ()
{
	if ( m_Manager )
	{
		m_Manager->Release () ;
	}

	if ( m_Shutdown )
	{
		m_Shutdown->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_ProviderRefresherManager_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_ProviderRefresherManager :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * )this ;		
	}	
	else if ( iid == IID__IWbemRefresherMgr )
	{
		*iplpv = ( LPVOID ) ( _IWbemRefresherMgr * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_ProviderRefresherManager :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_ProviderRefresherManager :: Release ()
{
	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRefresherManager :: Startup (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	_IWmiProvSS *a_ProvSS
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		t_Result = ProviderSubSystem_Common_Globals :: CreateInstance	(

			CLSID__WbemRefresherMgr ,
			NULL ,
			CLSCTX_INPROC_SERVER ,
			IID__IWbemRefresherMgr ,
			( void ** ) & m_Manager
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = m_Manager->Startup ( 

				a_Flags ,
				a_Context ,
				a_ProvSS
			) ;

			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = m_Manager->QueryInterface ( IID_IWbemShutdown , ( void ** ) & m_Shutdown ) ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRefresherManager :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		t_Result = m_Shutdown->Shutdown ( 

			a_Flags ,
			a_MaxMilliSeconds ,
			a_Context
		) ;
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRefresherManager :: AddObjectToRefresher (

	IWbemServices *a_Service, 
	LPCWSTR a_ServerName, 
	LPCWSTR a_Namespace, 
	IWbemClassObject* pClassObject,
	WBEM_REFRESHER_ID *a_DestinationRefresherId, 
	IWbemClassObject *a_InstanceTemplate, 
	long a_Flags, 
	IWbemContext *a_Context,
	IUnknown* a_pLockMgr,
	WBEM_REFRESH_INFO *a_Information
) 
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		t_Result = m_Manager->AddObjectToRefresher (

			a_Service, 
			a_ServerName, 
			a_Namespace, 
			pClassObject,
			a_DestinationRefresherId, 
			a_InstanceTemplate, 
			a_Flags, 
			a_Context,
			a_pLockMgr,
			a_Information
		) ;
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRefresherManager :: AddEnumToRefresher (

	IWbemServices *a_Service, 
	LPCWSTR a_ServerName, 
	LPCWSTR a_Namespace, 
	IWbemClassObject* pClassObject,
	WBEM_REFRESHER_ID *a_DestinationRefresherId, 
	IWbemClassObject *a_InstanceTemplate, 
	LPCWSTR a_Class,
	long a_Flags, 
	IWbemContext *a_Context, 
	IUnknown* a_pLockMgr,
	WBEM_REFRESH_INFO *a_Information
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		t_Result = m_Manager->AddEnumToRefresher (

			a_Service, 
			a_ServerName, 
			a_Namespace, 
			pClassObject,
			a_DestinationRefresherId, 
			a_InstanceTemplate, 
			a_Class,
			a_Flags, 
			a_Context, 
			a_pLockMgr,
			a_Information
		) ;
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRefresherManager :: GetRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId , 
	long a_Flags, 
	BOOL fAddRefresher,
	IWbemRemoteRefresher **a_RemoteRefresher ,  
	IUnknown* a_pLockMgr,
	GUID *a_Guid
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		t_Result = m_Manager->GetRemoteRefresher (

			a_RefresherId , 
			a_Flags,
			fAddRefresher,
			a_RemoteRefresher ,  
			a_pLockMgr,
			a_Guid
		) ;
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRefresherManager :: LoadProvider (

	IWbemServices *a_Service ,
	LPCWSTR a_ProviderName ,
	LPCWSTR a_Namespace,
	IWbemContext * a_Context,
	IWbemHiPerfProvider **a_Provider,
	_IWmiProviderStack** a_ProvStack
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		t_Result = m_Manager->LoadProvider (

			a_Service , 
			a_ProviderName ,
			a_Namespace ,
			a_Context ,
			a_Provider ,
			a_ProvStack
		) ;
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provobsk.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <stdio.h>

#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvWsv.h"
#include "ProvObSk.h"
#include "Guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemObjectSink :: CInterceptor_IWbemObjectSink (

	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller 

)	:	ObjectSinkContainerElement ( 

			a_Controller ,
			a_InterceptedSink
		) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_Unknown ( a_Unknown ) ,
		m_StatusCalled ( FALSE ) ,
		m_SecurityDescriptor ( NULL ) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemObjectSink :: ~CInterceptor_IWbemObjectSink ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_IWbemObjectSink :: CallBackInternalRelease ()
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemObjectSink :: CallBackInternalRelease ()" )  ;
#endif

	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 0 , 0 ) )
	{
		m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_UNEXPECTED ,
			NULL ,
			NULL
		) ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}

	if ( m_SecurityDescriptor )
	{
		delete [] m_SecurityDescriptor ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}
#ifdef INTERNAL_IDENTIFY
	else if ( iid == IID_Internal_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( Internal_IWbemObjectSink * ) this ;		
	}	
#endif
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemObjectSink :: AddRef ( void )
{
//	printf ( "\nCInterceptor_IWbemObjectSink :: AddRef ()" )  ;

	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemObjectSink :: Release ( void )
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemObjectSink :: Release () " ) ;
#endif

	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemObjectSink :: Initialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor )
{
	return ProviderSubSystem_Common_Globals :: SinkAccessInitialize ( a_SecurityDescriptor , m_SecurityDescriptor ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( SUCCEEDED ( t_Result = ProviderSubSystem_Common_Globals :: CheckAccess ( m_SecurityDescriptor , MASK_PROVIDER_BINDING_BIND , & g_ProviderBindingMapping ) ) )
		{
			t_Result = m_InterceptedSink->Indicate ( 

				a_ObjectCount ,
				a_ObjectArray
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( SUCCEEDED ( t_Result = ProviderSubSystem_Common_Globals :: CheckAccess ( m_SecurityDescriptor , MASK_PROVIDER_BINDING_BIND , & g_ProviderBindingMapping ) ) )
		{
			switch ( a_Flags )
			{
				case WBEM_STATUS_PROGRESS:
				{
					t_Result = m_InterceptedSink->SetStatus ( 

						a_Flags ,
						a_Result ,
						a_StringParam ,
						a_ObjectParam
					) ;
				}
				break ;

				case WBEM_STATUS_COMPLETE:
				{
					if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
					{
						t_Result = m_InterceptedSink->SetStatus ( 

							a_Flags ,
							a_Result ,
							a_StringParam ,
							a_ObjectParam
						) ;
					}
				}
				break ;

				default:
				{
					t_Result = WBEM_E_INVALID_PARAMETER ;
				}
				break ;
			}
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

#ifdef INTERNAL_IDENTIFY

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemObjectSink :: Internal_Indicate (

	WmiInternalContext a_InternalContext ,
	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Indicate (

			a_ObjectCount ,
			a_ObjectArray
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemObjectSink :: Internal_SetStatus (

	WmiInternalContext a_InternalContext ,
	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = SetStatus (

			a_Flags ,
			a_Result ,
			a_StringParam ,
			a_ObjectParam
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
	{
		t_Result = m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_SHUTTING_DOWN ,
			NULL ,
			NULL
		) ;
	}

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_DecoupledIWbemObjectSink :: CInterceptor_DecoupledIWbemObjectSink (

	IWbemServices *a_Provider ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller 

)	:	ObjectSinkContainerElement ( 

			a_Controller ,
			a_InterceptedSink
		) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_Unknown ( a_Unknown ) ,
		m_StatusCalled ( FALSE ) ,
		m_SecurityDescriptor ( NULL ) ,
		m_Provider ( a_Provider ) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( a_Provider ) 
	{
		m_Provider->AddRef () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_DecoupledIWbemObjectSink :: ~CInterceptor_DecoupledIWbemObjectSink ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemObjectSink :: Initialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor )
{
	return ProviderSubSystem_Common_Globals :: SinkAccessInitialize ( a_SecurityDescriptor , m_SecurityDescriptor ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_DecoupledIWbemObjectSink :: CallBackInternalRelease ()
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemObjectSink :: CallBackInternalRelease ()" )  ;
#endif

	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 0 , 0 ) )
	{
		m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_UNEXPECTED ,
			NULL ,
			NULL
		) ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider ) 
	{
		m_Provider->Release () ;
	}

	if ( m_SecurityDescriptor )
	{
		delete [] m_SecurityDescriptor ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_DecoupledIWbemObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	
	else if ( iid == IID_IObjectSink_CancelOperation )
	{
		*iplpv = ( LPVOID ) ( IObjectSink_CancelOperation * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_DecoupledIWbemObjectSink :: AddRef ( void )
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemObjectSink :: AddRef ()" )  ;
#endif

	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_DecoupledIWbemObjectSink :: Release ( void )
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemObjectSink :: Release () " ) ;
#endif

	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( SUCCEEDED ( t_Result = ProviderSubSystem_Common_Globals :: CheckAccess ( m_SecurityDescriptor , MASK_PROVIDER_BINDING_BIND , & g_ProviderBindingMapping ) ) )
		{
			t_Result = m_InterceptedSink->Indicate ( 

				a_ObjectCount ,
				a_ObjectArray
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		switch ( a_Flags )
		{
			if ( SUCCEEDED ( t_Result = ProviderSubSystem_Common_Globals :: CheckAccess ( m_SecurityDescriptor , MASK_PROVIDER_BINDING_BIND , & g_ProviderBindingMapping ) ) )
			{
				case WBEM_STATUS_PROGRESS:
				{
					t_Result = m_InterceptedSink->SetStatus ( 

						a_Flags ,
						a_Result ,
						a_StringParam ,
						a_ObjectParam
					) ;
				}
				break ;

				case WBEM_STATUS_COMPLETE:
				{
					if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
					{
						t_Result = m_InterceptedSink->SetStatus ( 

							a_Flags ,
							a_Result ,
							a_StringParam ,
							a_ObjectParam
						) ;
					}
				}
				break ;

				default:
				{
					t_Result = WBEM_E_INVALID_PARAMETER ;
				}
				break ;
			}
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
	{
		t_Result = m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_SHUTTING_DOWN ,
			NULL ,
			NULL
		) ;
	}

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemObjectSink :: Cancel (

	LONG a_Flags
)
{
	HRESULT t_Result = S_OK ;

	if ( m_Provider )
	{
		t_Result = m_Provider->CancelAsyncCall (

			this
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink :: CInterceptor_IWbemSyncObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	: CCommon_IWbemSyncObjectSink ( 

		a_Allocator ,
		a_InterceptedSink ,
		a_Unknown ,
		a_Controller ,
		a_Dependant 
	) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink :: ~CInterceptor_IWbemSyncObjectSink ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_GetObjectAsync :: CInterceptor_IWbemSyncObjectSink_GetObjectAsync (

	WmiAllocator &a_Allocator ,
	long a_Flags ,
	BSTR a_ObjectPath ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_IWbemSyncObjectSink (

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_ObjectPath ( a_ObjectPath ) ,
		m_Interceptor ( a_Interceptor ) 
{

	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_GetObjectAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_ObjectPath
		) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_GetObjectAsync :: ~CInterceptor_IWbemSyncObjectSink_GetObjectAsync ()
{
	if ( m_ObjectPath ) 
	{
		SysFreeString ( m_ObjectPath ) ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_GetObjectAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink_GetObjectAsync :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_GetObjectAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_ObjectPath ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync :: CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync (

	WmiAllocator &a_Allocator ,
	long a_Flags ,
	BSTR a_ObjectPath ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_IWbemSyncObjectSink (

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_ObjectPath ( a_ObjectPath ) ,
		m_Interceptor ( a_Interceptor ) 
{

	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_DeleteInstanceAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_ObjectPath
		) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync :: ~CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync ()
{
	if ( m_ObjectPath ) 
	{
		SysFreeString ( m_ObjectPath ) ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_DeleteInstanceAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_ObjectPath ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_DeleteClassAsync :: CInterceptor_IWbemSyncObjectSink_DeleteClassAsync (

	WmiAllocator &a_Allocator ,
	long a_Flags ,
	BSTR a_Class ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_IWbemSyncObjectSink (

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_Class ( a_Class ) ,
		m_Interceptor ( a_Interceptor ) 
{

	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_DeleteClassAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_Class
		) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_DeleteClassAsync :: ~CInterceptor_IWbemSyncObjectSink_DeleteClassAsync ()
{
	if ( m_Class ) 
	{
		SysFreeString ( m_Class ) ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_DeleteClassAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink_DeleteClassAsync :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_DeleteClassAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_Class ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_PutClassAsync :: CInterceptor_IWbemSyncObjectSink_PutClassAsync (

	WmiAllocator &a_Allocator ,
	long a_Flags ,
	IWbemClassObject *a_Class ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_IWbemSyncObjectSink (

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_Class ( a_Class ) ,
		m_Interceptor ( a_Interceptor ) 
{
	if ( m_Class )
	{
		m_Class->AddRef () ;
	}

	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_PutClassAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_Class
		) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_PutClassAsync :: ~CInterceptor_IWbemSyncObjectSink_PutClassAsync ()
{
	if ( m_Class )
	{
		m_Class->Release () ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_PutClassAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink_PutClassAsync :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_PutClassAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_Class ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_PutInstanceAsync :: CInterceptor_IWbemSyncObjectSink_PutInstanceAsync (

	WmiAllocator &a_Allocator ,
	long a_Flags ,
	IWbemClassObject *a_Instance ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_IWbemSyncObjectSink (

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_Instance ( a_Instance ) ,
		m_Interceptor ( a_Interceptor ) 
{
	if ( m_Instance )
	{
		m_Instance->AddRef () ;
	}

	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_PutInstanceAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_Instance
		) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_PutInstanceAsync :: ~CInterceptor_IWbemSyncObjectSink_PutInstanceAsync ()
{
	if ( m_Instance )
	{
		m_Instance->Release () ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_PutInstanceAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink_PutInstanceAsync :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_PutInstanceAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_Instance ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync :: CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync (

	WmiAllocator &a_Allocator ,
	long a_Flags ,
	BSTR a_Class ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_Batching_IWbemSyncObjectSink (

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_Class ( a_Class ) ,
		m_Interceptor ( a_Interceptor ) 
{
	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_CreateInstanceEnumAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_Class
		) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync :: ~CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync ()
{
	if ( m_Class ) 
	{
		SysFreeString ( m_Class ) ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = CCommon_Batching_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_CreateInstanceEnumAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_Class ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync :: CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync (

	WmiAllocator &a_Allocator ,
	long a_Flags ,
	BSTR a_SuperClass ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_Batching_IWbemSyncObjectSink (

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_SuperClass ( a_SuperClass ) ,
		m_Interceptor ( a_Interceptor ) 
{
	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_CreateClassEnumAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_SuperClass
		) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync :: ~CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync ()
{
	if ( m_SuperClass ) 
	{
		SysFreeString ( m_SuperClass ) ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = CCommon_Batching_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_CreateClassEnumAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_SuperClass ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_ExecQueryAsync :: CInterceptor_IWbemSyncObjectSink_ExecQueryAsync (

	WmiAllocator &a_Allocator ,
	long a_Flags ,
	BSTR a_QueryLanguage ,
	BSTR a_Query ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_Batching_IWbemSyncObjectSink (

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_Query ( a_Query ) ,
		m_QueryLanguage ( a_QueryLanguage ) ,
		m_Interceptor ( a_Interceptor ) 
{
	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ExecQueryAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_QueryLanguage ,
			m_Query
		) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_ExecQueryAsync :: ~CInterceptor_IWbemSyncObjectSink_ExecQueryAsync ()
{
	if ( m_Query ) 
	{
		SysFreeString ( m_Query ) ;
	}

	if ( m_QueryLanguage ) 
	{
		SysFreeString ( m_QueryLanguage ) ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_ExecQueryAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink_ExecQueryAsync :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = CCommon_Batching_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ExecQueryAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_QueryLanguage ,
				m_Query ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncObjectSink_ExecMethodAsync :: CInterceptor_IWbemSyncObjectSink_ExecMethodAsync (

	WmiAllocator &a_Allocator ,
	long a_Flags ,
	BSTR a_ObjectPath ,
	BSTR a_MethodName ,
	IWbemClassObject *a_InParameters ,
	CInterceptor_IWbemSyncProvider *a_Interceptor ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	:	CCommon_IWbemSyncObjectSink (

			a_Allocator ,
			a_InterceptedSink ,
			a_Unknown ,
			a_Controller ,
			a_Dependant 
		) ,
		m_Flags ( a_Flags ) ,
		m_ObjectPath ( a_ObjectPath ) ,
		m_MethodName ( a_MethodName ) ,
		m_InParameters ( a_InParameters ) ,
		m_Interceptor ( a_Interceptor ) 
{
	if ( m_InParameters ) 
	{
		m_InParameters->AddRef () ;
	}

	if ( m_Interceptor ) 
	{
		m_Interceptor->AddRef () ;

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ExecMethodAsyncEvent_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Interceptor->m_Namespace ,
			m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_Interceptor->m_User ,
			m_Interceptor->m_Locale ,
			m_Interceptor->m_TransactionIdentifier ,
			m_Flags ,
			m_ObjectPath ,
			m_MethodName ,
			m_InParameters
		) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncObjectSink_ExecMethodAsync :: ~CInterceptor_IWbemSyncObjectSink_ExecMethodAsync ()
{
	if ( m_MethodName ) 
	{
		SysFreeString ( m_MethodName ) ;
	}

	if ( m_ObjectPath ) 
	{
		SysFreeString ( m_ObjectPath ) ;
	}

	if ( m_InParameters ) 
	{
		m_InParameters->Release () ;
	}

	if ( m_Interceptor )
	{
		m_Interceptor->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncObjectSink_ExecMethodAsync :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncObjectSink_ExecMethodAsync :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = CCommon_IWbemSyncObjectSink :: SetStatus (

		a_Flags ,
		a_Result ,
		a_StringParam ,
		a_ObjectParam
	) ;

	if ( m_Interceptor ) 
	{
		if ( a_Flags == WBEM_STATUS_COMPLETE )
		{
			WmiSetAndCommitObject (

				ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ExecMethodAsyncEvent_Post ] , 
				WMI_SENDCOMMIT_SET_NOT_REQUIRED,
				m_Interceptor->m_Namespace ,
				m_Interceptor->m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
				m_Interceptor->m_User ,
				m_Interceptor->m_Locale ,
				m_Interceptor->m_TransactionIdentifier ,
				m_Flags ,
				m_ObjectPath ,
				m_MethodName ,
				m_InParameters ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemFilteringObjectSink :: CInterceptor_IWbemFilteringObjectSink (

	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query

)	:	CInterceptor_IWbemObjectSink ( 

			a_InterceptedSink ,
			a_Unknown ,
			a_Controller 
		) ,
		m_Filtering ( FALSE ) ,
		m_QueryFilter ( NULL )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemFilteringObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( a_Query )
	{
		m_Query = SysAllocString ( a_Query ) ;
	}

	if ( a_QueryLanguage ) 
	{
		m_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemFilteringObjectSink :: ~CInterceptor_IWbemFilteringObjectSink ()
{
	if ( m_QueryFilter )
	{
		m_QueryFilter->Release () ;
	}

	if ( m_Query )
	{
		SysFreeString ( m_Query ) ;
	}

	if ( m_QueryLanguage ) 
	{
		 SysFreeString ( m_QueryLanguage ) ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemFilteringObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemFilteringObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

#if 0
	if ( m_Filtering )
	{
		for ( LONG t_Index = 0 ; t_Index < a_ObjectCount ; t_Index ++ ) 
		{
			if ( SUCCEEDED ( m_QueryFilter->TestObject ( 0 , 0 , IID_IWbemClassObject , ( void * ) a_ObjectArray [ t_Index ] ) ) )
			{
				t_Result = CInterceptor_IWbemObjectSink :: Indicate ( 

					t_Index  ,
					& a_ObjectArray [ t_Index ]
				) ;
			}
		}
	}
	else
	{
		t_Result = CInterceptor_IWbemObjectSink :: Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;
	}
#else
	t_Result = CInterceptor_IWbemObjectSink :: Indicate ( 

		a_ObjectCount ,
		a_ObjectArray
	) ;
#endif

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemFilteringObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemFilteringObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	switch ( a_Flags )
	{
		case WBEM_STATUS_PROGRESS:
		{
			t_Result = CInterceptor_IWbemObjectSink :: SetStatus ( 

				a_Flags ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
		break ;

		case WBEM_STATUS_COMPLETE:
		{
			t_Result = CInterceptor_IWbemObjectSink :: SetStatus ( 

				a_Flags ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
		}
		break ;

		case WBEM_STATUS_REQUIREMENTS:
		{
#if 0
			if ( ! InterlockedCompareExchange ( & m_Filtering , 1 , 0 ) )
			{
				t_Result = ProviderSubSystem_Common_Globals :: CreateInstance	(

					CLSID_WbemQuery ,
					NULL ,
					CLSCTX_INPROC_SERVER ,
					IID_IWbemQuery ,
					( void ** ) & m_QueryFilter
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = m_QueryFilter->Parse ( 

						m_QueryLanguage ,
						m_Query , 
						0 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
#else
			t_Result = CInterceptor_IWbemObjectSink :: SetStatus ( 

				a_Flags ,
				a_Result ,
				a_StringParam ,
				a_ObjectParam
			) ;
#endif
		}
		break;

		default:
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncFilteringObjectSink :: CInterceptor_IWbemSyncFilteringObjectSink (

	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	ULONG a_Dependant 

)	:	ObjectSinkContainerElement ( 

			a_Controller ,
			a_InterceptedSink
		) ,
		m_InterceptedSink ( a_InterceptedSink ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_Unknown ( a_Unknown ) ,
		m_StatusCalled ( FALSE ) ,
		m_Filtering ( FALSE ) ,
		m_QueryFilter ( NULL ) ,
		m_Dependant ( a_Dependant ) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncFilteringObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}

	if ( a_Query )
	{
		m_Query = SysAllocString ( a_Query ) ;
	}

	if ( a_QueryLanguage ) 
	{
		m_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncFilteringObjectSink :: ~CInterceptor_IWbemSyncFilteringObjectSink ()
{
	if ( m_QueryFilter )
	{
		m_QueryFilter->Release () ;
	}

	if ( m_Query )
	{
		SysFreeString ( m_Query ) ;
	}

	if ( m_QueryLanguage ) 
	{
		 SysFreeString ( m_QueryLanguage ) ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncFilteringObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_IWbemSyncFilteringObjectSink :: CallBackInternalRelease ()
{
	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 0 , 0 ) )
	{
		m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_UNEXPECTED ,
			NULL ,
			NULL
		) ;
	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemSyncFilteringObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemSyncFilteringObjectSink :: AddRef ( void )
{
//	printf ( "\nCInterceptor_IWbemSyncFilteringObjectSink :: AddRef ()" )  ;

	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemSyncFilteringObjectSink :: Release ( void )
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncFilteringObjectSink :: Release () " ) ;
#endif

	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncFilteringObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
#if 0
		if ( m_Filtering )
		{
			for ( LONG t_Index = 0 ; t_Index < a_ObjectCount ; t_Index ++ ) 
			{
				if ( SUCCEEDED ( m_QueryFilter->TestObject ( 0 , 0 , IID_IWbemClassObject , ( void * ) a_ObjectArray [ t_Index ] ) ) )
				{
					t_Result = m_InterceptedSink->Indicate ( 

						t_Index  ,
						& a_ObjectArray [ t_Index ]
					) ;
				}
			}
		}
		else
		{
			t_Result = m_InterceptedSink->Indicate ( 

				a_ObjectCount ,
				a_ObjectArray
			) ;
		}
#else
		t_Result = m_InterceptedSink->Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;
#endif
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncFilteringObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemSyncFilteringObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		switch ( a_Flags )
		{
			case WBEM_STATUS_PROGRESS:
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					a_Flags ,
					a_Result ,
					a_StringParam ,
					a_ObjectParam
				) ;
			}
			break ;

			case WBEM_STATUS_COMPLETE:
			{
				if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
				{
					t_Result = m_InterceptedSink->SetStatus ( 

						a_Flags ,
						a_Result ,
						a_StringParam ,
						a_ObjectParam
					) ;
				}
			}
			break ;

			case WBEM_STATUS_REQUIREMENTS:
			{
#if 0
				if ( ! InterlockedCompareExchange ( & m_Filtering , 1 , 0 ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: CreateInstance	(

						CLSID_WbemQuery ,
						NULL ,
						CLSCTX_INPROC_SERVER ,
						IID_IWbemQuery ,
						( void ** ) & m_QueryFilter
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = m_QueryFilter->Parse ( 

							m_QueryLanguage ,
							m_Query , 
							0 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
						}
						else
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
#else
				t_Result = m_InterceptedSink->SetStatus ( 

					a_Flags ,
					a_Result ,
					a_StringParam ,
					a_ObjectParam
				) ;
#endif

			}
			break;

			default:
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}
			break ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncFilteringObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
	{
		t_Result = m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_SHUTTING_DOWN ,
			NULL ,
			NULL
		) ;
	}

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_DecoupledIWbemCombiningObjectSink :: CInterceptor_DecoupledIWbemCombiningObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller

) : CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	ObjectSinkContainerElement ( 

			a_Controller ,
			a_InterceptedSink
	) ,
	m_InterceptedSink ( a_InterceptedSink ) ,
	m_Event ( NULL ) , 
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_StatusCalled ( FALSE ) ,
	m_SinkCount ( 0 )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemCombiningObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	CWbemGlobal_IWmiObjectSinkController :: Initialize () ;

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}

	m_Event = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_DecoupledIWbemCombiningObjectSink :: ~CInterceptor_DecoupledIWbemCombiningObjectSink ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemCombiningObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_DecoupledIWbemCombiningObjectSink :: CallBackInternalRelease ()
{
	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_Event ) 
	{
		CloseHandle ( m_Event ) ;
	}

	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_DecoupledIWbemCombiningObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	
	else if ( iid == IID_IObjectSink_CancelOperation )
	{
		*iplpv = ( LPVOID ) ( IObjectSink_CancelOperation * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_DecoupledIWbemCombiningObjectSink :: AddRef ()
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemCombiningObjectSink :: AddRef ()" ) ;
#endif

	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_DecoupledIWbemCombiningObjectSink :: Release ()
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemCombiningObjectSink :: Release ()" ) ;
#endif

	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedSink->Indicate ( 

			a_ObjectCount ,
			a_ObjectArray
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_DecoupledIWbemCombiningObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( FAILED ( a_Result ) )
		{
			ULONG t_SinkCount = InterlockedDecrement ( & m_SinkCount ) ;

			if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
			{
				t_Result = m_InterceptedSink->SetStatus ( 

					0 ,
					a_Result ,
					NULL ,
					NULL 
				) ;

				SetEvent ( m_Event ) ;
			}
		}
		else
		{
			ULONG t_SinkCount = InterlockedDecrement ( & m_SinkCount ) ;
			if ( t_SinkCount == 0 )
			{
				if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
				{
					t_Result = m_InterceptedSink->SetStatus ( 

						0 ,
						S_OK ,
						NULL ,
						NULL 
					) ;

					SetEvent ( m_Event ) ;
				}
			}
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
	{
		t_Result = m_InterceptedSink->SetStatus ( 

			0 ,
			WBEM_E_SHUTTING_DOWN ,
			NULL ,
			NULL
		) ;
	}

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: Wait ( ULONG a_Timeout ) 
{
	HRESULT t_Result = S_OK ;

	ULONG t_Status = WaitForSingleObject ( m_Event , a_Timeout ) ;
	switch ( t_Status )
	{
		case WAIT_TIMEOUT:
		{
			t_Result = WBEM_E_TIMED_OUT ;
		}
		break ;

		case WAIT_OBJECT_0:
		{
		}
		break ;

		default:
		{
			t_Result = WBEM_E_FAILED ;
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: Cancel (

	LONG a_Flags
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	Lock () ;

	if ( t_Container->Size () )
	{
		IObjectSink_CancelOperation **t_Elements = new IObjectSink_CancelOperation * [ t_Container->Size () ] ;
		if ( t_Elements )
		{
			CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

			ULONG t_Count = 0 ;
			while ( ! t_Iterator.Null () )
			{
				t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IObjectSink_CancelOperation , ( void ** ) & t_Elements [ t_Count ] ) ;

				t_Iterator.Increment () ;

				t_Count ++ ;
			}

			UnLock () ;

			for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
			{
				if ( t_Elements [ t_Index ] ) 
				{
					t_Result = t_Elements [ t_Index ]->Cancel ( 

						a_Flags
					) ;

					IWbemShutdown *t_Shutdown = NULL ;
					HRESULT t_TempResult = t_Elements [ t_Index ]->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
					if ( SUCCEEDED ( t_TempResult ) )
					{
						t_TempResult = t_Shutdown->Shutdown ( 

							0 , 
							0 , 
							NULL 
						) ;

						t_Shutdown->Release () ;
					}

					t_Elements [ t_Index ]->Release () ;
				}
			}

			delete [] t_Elements ;
		}
		else
		{
			UnLock () ;

			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		UnLock () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledIWbemCombiningObjectSink :: EnQueue ( CInterceptor_DecoupledIWbemObjectSink *a_Sink ) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

	WmiStatusCode t_StatusCode = Lock () ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		t_StatusCode = Insert ( 

			*a_Sink ,
			t_Iterator
		) ;

		UnLock () ;
	}

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		InterlockedIncrement ( & m_SinkCount ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_DecoupledIWbemCombiningObjectSink :: Suspend ()
{
	InterlockedIncrement ( & m_SinkCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_DecoupledIWbemCombiningObjectSink :: Resume ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_SinkCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		InterlockedIncrement ( & m_InProgress ) ;

		if ( m_GateClosed == 1 )
		{
		}
		else
		{
			if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
			{
				HRESULT t_Result = m_InterceptedSink->SetStatus ( 

					0 ,
					S_OK ,
					NULL ,
					NULL 
				) ;

				SetEvent ( m_Event ) ;
			}			
		}

		InterlockedDecrement ( & m_InProgress ) ;

	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemWaitingObjectSink :: CInterceptor_IWbemWaitingObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemServices *a_Provider ,
	IWbemObjectSink *a_InterceptedSink ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration 

) : CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	ObjectSinkContainerElement ( 

			a_Controller ,
			a_InterceptedSink
	) ,
	m_Queue ( a_Allocator ) ,
	m_Event ( NULL ) , 
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_StatusCalled ( FALSE ) ,
	m_Result ( S_OK ) ,
	m_SecurityDescriptor ( NULL ) ,
	m_ReferenceCount ( 0 ) ,
	m_Registration ( a_Registration ) ,
	m_Provider ( a_Provider ) ,
	m_CriticalSection (NOTHROW_LOCK)
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemWaitingObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	m_Registration.AddRef () ;

	if ( m_Provider )
	{
		m_Provider->AddRef () ;
	}

	WmiStatusCode t_StatusCode = m_Queue.Initialize () ;

	CWbemGlobal_IWmiObjectSinkController :: Initialize () ;

	m_Event = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;

}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink :: ~CInterceptor_IWbemWaitingObjectSink ()
{
	if ( m_Event ) 
	{
		CloseHandle ( m_Event ) ;
	}

	ULONG t_Count = m_Queue.Size();
	for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
	{
		IWbemClassObject *t_ClassObject ;
		WmiStatusCode t_StatusCode = m_Queue.Top ( t_ClassObject ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_ClassObject->Release () ;
			t_StatusCode = m_Queue.DeQueue () ;
		}
	}
	m_Queue.UnInitialize () ;
	

	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	if ( m_SecurityDescriptor )
	{
		delete [] m_SecurityDescriptor ;
	}

	m_Registration.Release () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemWaitingObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: Initialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor )
{
	return m_CriticalSection.valid() ? ProviderSubSystem_Common_Globals :: SinkAccessInitialize ( a_SecurityDescriptor , m_SecurityDescriptor ) :
								WBEM_E_OUT_OF_MEMORY;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemWaitingObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	
	else if ( iid == IID_IObjectSink_CancelOperation )
	{
		*iplpv = ( LPVOID ) ( IObjectSink_CancelOperation * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemWaitingObjectSink :: AddRef ()
{
	LONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;

	return ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemWaitingObjectSink :: Release ()
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemWaitingObjectSink :: Release ()" ) ;
#endif

	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 1 )
	{
		if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
		{
			if ( SUCCEEDED ( m_Result ) )
			{
				m_Result = WBEM_E_UNEXPECTED ;
			}

			SetEvent ( m_Event ) ;
		}
	}

	return ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_IWbemWaitingObjectSink :: CallBackInternalRelease ()
{
	if ( m_Provider )
	{
		m_Provider->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: Cancel (

	LONG a_Flags
)
{
	HRESULT t_Result = S_OK ;

	if ( m_Provider )
	{
		t_Result = m_Provider->CancelAsyncCall (

			this
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( SUCCEEDED ( t_Result = ProviderSubSystem_Common_Globals :: CheckAccess ( m_SecurityDescriptor , MASK_PROVIDER_BINDING_BIND , & g_ProviderBindingMapping ) ) )
		{
			WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_CriticalSection , FALSE ) ;
			if ( t_StatusCode == e_StatusCode_Success )
			{
				for ( LONG t_Index = 0 ; SUCCEEDED ( t_Result ) && ( t_Index < a_ObjectCount ) ; t_Index ++ )
				{
					if ( a_ObjectArray [ t_Index ] )
					{
						WmiStatusCode t_StatusCode = m_Queue.EnQueue ( a_ObjectArray [ t_Index ] ) ;
						if ( t_StatusCode == e_StatusCode_Success )
						{
							a_ObjectArray [ t_Index ]->AddRef () ;
						}
						else
						{
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_OBJECT ;
					}
				}
				WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCInterceptor_IWbemWaitingObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( SUCCEEDED ( t_Result = ProviderSubSystem_Common_Globals :: CheckAccess ( m_SecurityDescriptor , MASK_PROVIDER_BINDING_BIND , & g_ProviderBindingMapping ) ) )
		{
			if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
			{
				if ( SUCCEEDED ( m_Result ) )
				{
					m_Result = a_Result ;
				}

				SetEvent ( m_Event ) ;
			}
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
	{
		m_Result = WBEM_E_SHUTTING_DOWN ;

		SetEvent ( m_Event ) ;
	}

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink :: Wait ( ULONG a_Timeout ) 
{
	HRESULT t_Result = S_OK ;

	ULONG t_Status = WaitForSingleObject ( m_Event , a_Timeout ) ;
	switch ( t_Status )
	{
		case WAIT_TIMEOUT:
		{
			t_Result = WBEM_E_TIMED_OUT ;
		}
		break ;

		case WAIT_OBJECT_0:
		{
		}
		break ;

		default:
		{
			t_Result = WBEM_E_FAILED ;
		}
		break ;
	}

	ObjectSinkContainerElement :: GetController ()->Lock () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	ObjectSinkContainerElement :: GetController ()->GetContainer ( t_Container ) ;
	t_Container->Delete ( VoidPointerContainerElement :: GetKey () ) ;

	ObjectSinkContainerElement :: GetController ()->UnLock () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink_GetObjectAsync :: CInterceptor_IWbemWaitingObjectSink_GetObjectAsync ( 

	WmiAllocator &m_Allocator ,
	IWbemServices *a_Provider ,
	IWbemObjectSink *a_InterceptedSink ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration 

) : CInterceptor_IWbemWaitingObjectSink (

		m_Allocator ,
		a_Provider ,
		a_InterceptedSink ,
		a_Controller ,
		a_Registration 
	) ,
	m_ObjectPath ( NULL ) ,
	m_Flags ( 0 ) ,
	m_Context ( NULL ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink_GetObjectAsync :: ~CInterceptor_IWbemWaitingObjectSink_GetObjectAsync ()
{
	if ( m_ObjectPath ) 
	{
		SysFreeString ( m_ObjectPath ) ;
	}

	if ( m_Context )
	{
		m_Context->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink_GetObjectAsync :: Initialize (

	SECURITY_DESCRIPTOR *a_SecurityDescriptor , 
	BSTR a_ObjectPath ,
	LONG a_Flags ,
	IWbemContext *a_Context 
)
{
	HRESULT t_Result = S_OK ;

	m_Flags = a_Flags ;

	m_Context = a_Context ;
	if ( m_Context )
	{
		m_Context->AddRef () ;
	}

	m_ObjectPath = SysAllocString ( a_ObjectPath ) ;
	if ( m_ObjectPath == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CInterceptor_IWbemWaitingObjectSink :: Initialize ( a_SecurityDescriptor ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync :: CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync ( 

	WmiAllocator &m_Allocator ,
	IWbemServices *a_Provider ,
	IWbemObjectSink *a_InterceptedSink ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration 

) : CInterceptor_IWbemWaitingObjectSink (

		m_Allocator ,
		a_Provider ,
		a_InterceptedSink ,
		a_Controller ,
		a_Registration 
	) ,
	m_Class ( NULL ) ,
	m_Flags ( 0 ) ,
	m_Context ( NULL ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync :: ~CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync ()
{
	if ( m_Class ) 
	{
		SysFreeString ( m_Class ) ;
	}

	if ( m_Context )
	{
		m_Context->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync :: Initialize (

	SECURITY_DESCRIPTOR *a_SecurityDescriptor , 
	BSTR a_Class ,
	LONG a_Flags ,
	IWbemContext *a_Context 
)
{
	HRESULT t_Result = S_OK ;

	m_Flags = a_Flags ;

	m_Context = a_Context ;
	if ( m_Context )
	{
		m_Context->AddRef () ;
	}

	m_Class = SysAllocString ( a_Class ) ;
	if ( m_Class == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CInterceptor_IWbemWaitingObjectSink :: Initialize ( a_SecurityDescriptor ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync :: CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync ( 

	WmiAllocator &m_Allocator ,
	IWbemServices *a_Provider ,
	IWbemObjectSink *a_InterceptedSink ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration 

) : CInterceptor_IWbemWaitingObjectSink (

		m_Allocator ,
		a_Provider ,
		a_InterceptedSink ,
		a_Controller ,
		a_Registration 
	) ,
	m_SuperClass ( NULL ) ,
	m_Flags ( 0 ) ,
	m_Context ( NULL ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync :: ~CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync ()
{
	if ( m_SuperClass ) 
	{
		SysFreeString ( m_SuperClass ) ;
	}

	if ( m_Context )
	{
		m_Context->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync :: Initialize (

	SECURITY_DESCRIPTOR *a_SecurityDescriptor , 
	BSTR a_SuperClass ,
	LONG a_Flags ,
	IWbemContext *a_Context 
)
{
	HRESULT t_Result = S_OK ;

	m_Flags = a_Flags ;

	m_Context = a_Context ;
	if ( m_Context )
	{
		m_Context->AddRef () ;
	}

	m_SuperClass = SysAllocString ( a_SuperClass ) ;
	if ( m_SuperClass == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CInterceptor_IWbemWaitingObjectSink :: Initialize ( a_SecurityDescriptor ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink_PutClassAsync :: CInterceptor_IWbemWaitingObjectSink_PutClassAsync ( 

	WmiAllocator &m_Allocator ,
	IWbemServices *a_Provider ,
	IWbemObjectSink *a_InterceptedSink ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration 

) : CInterceptor_IWbemWaitingObjectSink (

		m_Allocator ,
		a_Provider ,
		a_InterceptedSink ,
		a_Controller ,
		a_Registration 
	) ,
	m_ClassObject ( NULL ) ,
	m_Flags ( 0 ) ,
	m_Context ( NULL ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemWaitingObjectSink_PutClassAsync :: ~CInterceptor_IWbemWaitingObjectSink_PutClassAsync ()
{
	if ( m_ClassObject ) 
	{
		m_ClassObject->Release () ;
	}

	if ( m_Context )
	{
		m_Context->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemWaitingObjectSink_PutClassAsync :: Initialize (

	SECURITY_DESCRIPTOR *a_SecurityDescriptor , 
	IWbemClassObject *a_ClassObject ,
	LONG a_Flags ,
	IWbemContext *a_Context 
)
{
	HRESULT t_Result = S_OK ;

	m_Flags = a_Flags ;

	m_Context = a_Context ;
	if ( m_Context )
	{
		m_Context->AddRef () ;
	}

	m_ClassObject = a_ClassObject ;
	if ( m_ClassObject )
	{
		m_ClassObject->AddRef () ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CInterceptor_IWbemWaitingObjectSink :: Initialize ( a_SecurityDescriptor ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWaitingObjectSink :: CWaitingObjectSink (

	WmiAllocator &a_Allocator

) : m_Queue ( a_Allocator ) ,
	m_Event ( NULL ) , 
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_StatusCalled ( FALSE ) ,
	m_Result ( S_OK ) ,
	m_CriticalSection(NOTHROW_LOCK)
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWaitingObjectSink :: ~CWaitingObjectSink ()
{
	if ( m_Event ) 
	{
		CloseHandle ( m_Event ) ;
	}
	ULONG t_Count = m_Queue.Size();
	for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
	{
		IWbemClassObject *t_ClassObject ;
		WmiStatusCode t_StatusCode = m_Queue.Top ( t_ClassObject ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_ClassObject->Release () ;
			t_StatusCode = m_Queue.DeQueue () ;
		}
	}
	m_Queue.UnInitialize () ;
	
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWaitingObjectSink :: SinkInitialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = m_Queue.Initialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		if ( m_CriticalSection.valid() )
		{
			m_Event = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
			if ( m_Event == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CWaitingObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemObjectSink )
	{
		*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CWaitingObjectSink :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CWaitingObjectSink :: Release ()
{
#if 0
	OutputDebugString ( L"\nCWaitingObjectSink :: Release ()" ) ;
#endif

	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWaitingObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_CriticalSection , FALSE ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			for ( LONG t_Index = 0 ; SUCCEEDED ( t_Result ) && ( t_Index < a_ObjectCount ) ; t_Index ++ )
			{
				if ( a_ObjectArray [ t_Index ] )
				{
					WmiStatusCode t_StatusCode = m_Queue.EnQueue ( a_ObjectArray [ t_Index ] ) ;
					if ( t_StatusCode == e_StatusCode_Success )
					{
						a_ObjectArray [ t_Index ]->AddRef () ;
					}
					else
					{
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_OBJECT ;
				}
			}
			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWaitingObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
#if 0
	OutputDebugString ( L"\nCWaitingObjectSink :: SetStatus ()" ) ;
#endif

	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
		{
			if ( SUCCEEDED ( m_Result ) )
			{
				m_Result = a_Result ;
			}

			SetEvent ( m_Event ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWaitingObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
	{
		m_Result = WBEM_E_SHUTTING_DOWN ;

		SetEvent ( m_Event ) ;
	}

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;

			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CWaitingObjectSink :: Wait ( ULONG a_Timeout ) 
{
	HRESULT t_Result = S_OK ;

	ULONG t_Status = WaitForSingleObject ( m_Event , a_Timeout ) ;
	switch ( t_Status )
	{
		case WAIT_TIMEOUT:
		{
			t_Result = WBEM_E_TIMED_OUT ;
		}
		break ;

		case WAIT_OBJECT_0:
		{
		}
		break ;

		default:
		{
			t_Result = WBEM_E_FAILED ;
		}
		break ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provself.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include <PreComp.h>
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvResv.h"
#include "ProvFact.h"
#include "ProvSubS.h"
#include "ProvRegInfo.h"
#include "ProvSelf.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_IWbemServices :: CServerObject_IWbemServices (

	WmiAllocator &a_Allocator
) : 
	m_ReferenceCount ( 0 ) , 
	m_Service ( NULL ) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_IWbemServices_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_IWbemServices :: ~CServerObject_IWbemServices ()
{
	if ( m_Service )
	{
		m_Service->Release () ; 
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_IWbemServices_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_IWbemServices :: AddRef ( void )
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_IWbemServices :: Release ( void )
{
	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_IWbemServices :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices::OpenNamespace ( 

	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemServices **a_NamespaceService, 
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: QueryObjectSink ( 

	long a_Flags,		
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: GetObject ( 
		
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject **a_Object,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: Write_Msft_WmiProvider_Counters ( 
	
	IWbemClassObject *a_Object 
)
{
	if ( ProviderSubSystem_Globals :: GetSharedCounters () )
	{
		_IWmiObject *t_FastObject = NULL ;
		HRESULT t_Result = a_Object->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastObject ) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_FastObject->WriteProp (

				L"ProviderOperation_GetObjectAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_GetObjectAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_PutClassAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_PutClassAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_DeleteClassAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_DeleteClassAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_CreateClassEnumAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_CreateClassEnumAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_PutInstanceAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_PutInstanceAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_CreateInstanceEnumAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_CreateInstanceEnumAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_ExecQueryAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_ExecQueryAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_ExecNotificationQueryAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_ExecNotificationQueryAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_DeleteInstanceAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_DeleteInstanceAsync
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_ExecMethodAsync" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64 , 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_ExecMethodAsync
			) ;

#if 0
			t_FastObject->WriteProp (

				L"ProviderHost_WmiCore_Loads" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderHost_WmiCore_Loads
			) ;

			t_FastObject->WriteProp (

				L"ProviderHost_WmiCore_UnLoads" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderHost_WmiCore_UnLoads
			) ;

			t_FastObject->WriteProp (

				L"ProviderHost_WmiCoreOrSelfHost_Loads" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderHost_WmiCoreOrSelfHost_Loads
			) ;

			t_FastObject->WriteProp (

				L"ProviderHost_WmiCoreOrSelfHost_UnLoads" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderHost_WmiCoreOrSelfHost_UnLoads
			) ;

			t_FastObject->WriteProp (

				L"ProviderHost_SelfHost_Loads" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderHost_SelfHost_Loads
			) ;

			t_FastObject->WriteProp (

				L"ProviderHost_SelfHost_UnLoads" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderHost_SelfHost_UnLoads
			) ;

			t_FastObject->WriteProp (

				L"ProviderHost_ClientHost_Loads" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderHost_ClientHost_Loads
			) ;

			t_FastObject->WriteProp (

				L"ProviderHost_ClientHost_UnLoads" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderHost_ClientHost_UnLoads
			) ;

			t_FastObject->WriteProp (

				L"ProviderHost_Decoupled_Loads" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderHost_Decoupled_Loads
			) ;

			t_FastObject->WriteProp (

				L"ProviderHost_Decoupled_UnLoads" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderHost_Decoupled_UnLoads
			) ;

			t_FastObject->WriteProp (

				L"ProviderHost_SharedLocalSystemHost_Loads" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderHost_SharedLocalSystemHost_Loads
			) ;

			t_FastObject->WriteProp (

				L"ProviderHost_SharedLocalSystemHost_UnLoads" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderHost_SharedLocalSystemHost_UnLoads
			) ;

			t_FastObject->WriteProp (

				L"ProviderHost_SharedNetworkHost_Loads" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderHost_SharedNetworkHost_Loads
			) ;

			t_FastObject->WriteProp (

				L"ProviderHost_SharedNetworkHost_UnLoads" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderHost_SharedNetworkHost_UnLoads
			) ;

			t_FastObject->WriteProp (

				L"ProviderHost_SharedUserHost_Loads" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderHost_SharedUserHost_Loads
			) ;

			t_FastObject->WriteProp (

				L"ProviderHost_SharedUserHost_UnLoads" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderHost_SharedUserHost_UnLoads
			) ;
#endif
			t_FastObject->WriteProp (

				L"ProviderOperation_QueryInstances" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_QueryInstances
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_CreateRefresher" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_CreateRefresher
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_CreateRefreshableObject" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_CreateRefreshableObject
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_StopRefreshing" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_StopRefreshing
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_CreateRefreshableEnum" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_CreateRefreshableEnum
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_GetObjects" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_GetObjects
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_GetProperty" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_GetProperty
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_PutProperty" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_PutProperty
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_ProvideEvents" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_ProvideEvents
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_NewQuery" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_NewQuery
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_CancelQuery" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_CancelQuery
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_AccessCheck" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_AccessCheck
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_SetRegistrationObject" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_SetRegistrationObject
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_FindConsumer" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_FindConsumer
			) ;

			t_FastObject->WriteProp (

				L"ProviderOperation_ValidateSubscription" , 
				0 , 
				sizeof ( UINT64 ) , 
				1 ,
				CIM_UINT64, 
				& ProviderSubSystem_Globals :: GetSharedCounters ()->m_ProviderOperation_ValidateSubscription
			) ;

			t_FastObject->Release () ;
		}

		return t_Result ;
	}

	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: GetObjectAsync_Msft_WmiProvider_Counters ( 
	
	IWbemPath *a_Path,
	BSTR a_Class ,
	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	ULONGLONG t_Information = 0 ;

	t_Result = a_Path->GetInfo (

		0 ,
		& t_Information
	) ;

	if ( t_Information & WBEMPATH_INFO_IS_SINGLETON )
	{
		IWbemClassObject *t_Object = NULL ;

		t_Result = m_Service->GetObject (

			a_Class ,
			0 ,
			a_Context ,
			& t_Object ,
			NULL 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_Instance = NULL ;
			t_Result = t_Object->SpawnInstance ( 

				0 , 
				& t_Instance 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Write_Msft_WmiProvider_Counters ( 
	
					t_Instance
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = a_Sink->Indicate ( 1 , & t_Instance ) ;

					t_Instance->Release () ;
				}
			}
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_OBJECT_PATH ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: GetObjectAsync_Msft_Providers ( 
	
	IWbemPath *a_Path,
	BSTR a_Class ,
	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProvSubSysController *t_SubSystemController = ProviderSubSystem_Globals :: GetProvSubSysController () ;
	if ( t_SubSystemController )
	{
		t_SubSystemController->Lock () ;

		CWbemGlobal_IWmiProvSubSysController_Container *t_Container = NULL ;
		t_SubSystemController->GetContainer ( t_Container ) ;

		if ( t_Container->Size () )
		{
			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator = t_Container->Begin ();

			_IWmiProviderConfiguration **t_ControllerElements = new _IWmiProviderConfiguration * [ t_Container->Size () ] ;
			if ( t_ControllerElements )
			{
				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				t_SubSystemController->UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ControllerElements [ t_Index ] )
					{
						t_Result = t_ControllerElements [ t_Index ]->Get ( 

							m_Service ,
							a_Flags, 
							a_Context,
							a_Class ,
							a_ObjectPath, 
							a_Sink
						) ;

						t_ControllerElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ControllerElements ;
			}
			else
			{
				t_SubSystemController->UnLock () ;
			}
		}
		else
		{
			t_SubSystemController->UnLock () ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	IWbemPath *t_Path = NULL ;

	if ( a_ObjectPath ) 
	{
		t_Result = CoCreateInstance (

			CLSID_WbemDefPath ,
			NULL ,
			CLSCTX_INPROC_SERVER ,
			IID_IWbemPath ,
			( void ** )  & t_Path
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Path->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_ObjectPath ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				ULONG t_Length = 32 ; // None of supported classes is longer than this length
				BSTR t_Class = SysAllocStringLen ( NULL , t_Length ) ; 

				if ( t_Class )
				{
					t_Result = t_Path->GetClassName (

						& t_Length ,
						t_Class
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( _wcsicmp ( t_Class , L"Msft_WmiProvider_Counters" ) == 0 )
						{
							t_Result = GetObjectAsync_Msft_WmiProvider_Counters (

								t_Path ,
								t_Class ,
								a_ObjectPath, 
								a_Flags, 
								a_Context,
								a_Sink
							) ;
						}
						else if ( _wcsicmp ( t_Class , L"Msft_Providers" ) == 0 )
						{
							t_Result = GetObjectAsync_Msft_Providers (

								t_Path ,
								t_Class ,
								a_ObjectPath, 
								a_Flags, 
								a_Context,
								a_Sink
							) ;
						}
						else
						{
							t_Result = WBEM_E_INVALID_CLASS ;
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_CLASS ;
					}

					SysFreeString ( t_Class ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
		}

		t_Path->Release () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: PutClass ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: PutClassAsync ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: DeleteClass ( 
		
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: DeleteClassAsync ( 
		
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: CreateClassEnum ( 

	const BSTR a_Superclass, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CServerObject_IWbemServices :: CreateClassEnumAsync (

	const BSTR a_Superclass, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: PutInstance (

    IWbemClassObject *a_Instance,
    long a_Flags,
    IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags, 
    IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: DeleteInstance ( 

	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CServerObject_IWbemServices :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext FAR *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: CreateInstanceEnumAsync_Msft_Providers (

 	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink 
) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProvSubSysController *t_SubSystemController = ProviderSubSystem_Globals :: GetProvSubSysController () ;
	if ( t_SubSystemController )
	{
		t_SubSystemController->Lock () ;

		CWbemGlobal_IWmiProvSubSysController_Container *t_Container = NULL ;
		t_SubSystemController->GetContainer ( t_Container ) ;

		if ( t_Container->Size () )
		{
			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator = t_Container->Begin ();

			_IWmiProviderConfiguration **t_ControllerElements = new _IWmiProviderConfiguration * [ t_Container->Size () ] ;
			if ( t_ControllerElements )
			{
				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				t_SubSystemController->UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ControllerElements [ t_Index ] )
					{
						HRESULT t_Result = t_ControllerElements [ t_Index ]->Enumerate ( 

							m_Service ,
							a_Flags, 
							a_Context,
 							a_Class, 
							a_Sink 
						) ;

						t_ControllerElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ControllerElements ;
			}
			else
			{
				t_SubSystemController->UnLock () ;
			}
		}
		else
		{
			t_SubSystemController->UnLock () ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: CreateInstanceEnumAsync_Msft_WmiProvider_Counters (

 	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink 
) 
{
	IWbemClassObject *t_Object = NULL ;
	HRESULT t_Result = m_Service->GetObject (

		a_Class ,
		0 ,
		a_Context ,
		& t_Object ,
		NULL 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemClassObject *t_Instance = NULL ;
		t_Result = t_Object->SpawnInstance ( 

			0 , 
			& t_Instance 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = Write_Msft_WmiProvider_Counters ( 

				t_Instance
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = a_Sink->Indicate ( 1 , & t_Instance ) ;
			}

			t_Instance->Release () ;
		}

		t_Object->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: CreateInstanceEnumAsync (

 	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink 
) 
{
	HRESULT t_Result = S_OK ;

	if ( _wcsicmp ( a_Class , L"Msft_WmiProvider_Counters" ) == 0 )
	{
		t_Result = CreateInstanceEnumAsync_Msft_WmiProvider_Counters (

 			a_Class, 
			a_Flags, 
			a_Context,
			a_Sink 
		) ;
	}
	else if ( _wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
	{
		t_Result = CreateInstanceEnumAsync_Msft_Providers (

 			a_Class, 
			a_Flags, 
			a_Context,
			a_Sink 
		) ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CServerObject_IWbemServices :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CServerObject_IWbemServices :: ExecMethod ( 

	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
    IWbemClassObject **a_OutParams,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: Helper_ExecMethodAsync_Suspend ( 

    IWbemPath *a_Path ,
	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProvSubSysController *t_SubSystemController = ProviderSubSystem_Globals :: GetProvSubSysController () ;
	if ( t_SubSystemController )
	{
		t_SubSystemController->Lock () ;

		CWbemGlobal_IWmiProvSubSysController_Container *t_Container = NULL ;
		t_SubSystemController->GetContainer ( t_Container ) ;

		if ( t_Container->Size () )
		{
			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator = t_Container->Begin ();

			_IWmiProviderConfiguration **t_ControllerElements = new _IWmiProviderConfiguration * [ t_Container->Size () ] ;
			if ( t_ControllerElements )
			{
				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				t_SubSystemController->UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ControllerElements [ t_Index ] )
					{
						t_Result = t_ControllerElements [ t_Index ]->Call ( 

							m_Service ,
							a_Flags ,
							a_Context ,
							L"Msft_Providers" ,
							a_ObjectPath ,		
							a_MethodName ,
							a_InParams,
							a_Sink
						) ;

						t_ControllerElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ControllerElements ;
			}
			else
			{
				t_SubSystemController->UnLock () ;
			}
		}
		else
		{
			t_SubSystemController->UnLock () ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: Helper_ExecMethodAsync_Resume ( 

    IWbemPath *a_Path ,
	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProvSubSysController *t_SubSystemController = ProviderSubSystem_Globals :: GetProvSubSysController () ;
	if ( t_SubSystemController )
	{
		t_SubSystemController->Lock () ;

		CWbemGlobal_IWmiProvSubSysController_Container *t_Container = NULL ;
		t_SubSystemController->GetContainer ( t_Container ) ;

		if ( t_Container->Size () )
		{
			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator = t_Container->Begin ();

			_IWmiProviderConfiguration **t_ControllerElements = new _IWmiProviderConfiguration * [ t_Container->Size () ] ;
			if ( t_ControllerElements )
			{
				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				t_SubSystemController->UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ControllerElements [ t_Index ] )
					{
						t_Result = t_ControllerElements [ t_Index ]->Call ( 

							m_Service ,
							a_Flags ,
							a_Context ,
							L"Msft_Providers" ,
							a_ObjectPath ,		
							a_MethodName ,
							a_InParams,
							a_Sink
						) ;

						t_ControllerElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ControllerElements ;
			}
			else
			{
				t_SubSystemController->UnLock () ;
			}
		}
		else
		{
			t_SubSystemController->UnLock () ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: Helper_ExecMethodAsync_Load ( 

    IWbemPath *a_Path ,
	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProvSubSysController *t_SubSystemController = ProviderSubSystem_Globals :: GetProvSubSysController () ;
	if ( t_SubSystemController )
	{
		t_SubSystemController->Lock () ;

		CWbemGlobal_IWmiProvSubSysController_Container *t_Container = NULL ;
		t_SubSystemController->GetContainer ( t_Container ) ;

		if ( t_Container->Size () )
		{
			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator = t_Container->Begin ();

			_IWmiProviderConfiguration **t_ControllerElements = new _IWmiProviderConfiguration * [ t_Container->Size () ] ;
			if ( t_ControllerElements )
			{
				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				t_SubSystemController->UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ControllerElements [ t_Index ] )
					{
						t_Result = t_ControllerElements [ t_Index ]->Call ( 

							m_Service ,
							a_Flags ,
							a_Context ,
							L"Msft_Providers" ,
							a_ObjectPath ,		
							a_MethodName ,
							a_InParams,
							a_Sink
						) ;

						t_ControllerElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ControllerElements ;
			}
			else
			{
				t_SubSystemController->UnLock () ;
			}
		}
		else
		{
			t_SubSystemController->UnLock () ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: Helper_ExecMethodAsync_UnLoad ( 

    IWbemPath *a_Path ,
	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProvSubSysController *t_SubSystemController = ProviderSubSystem_Globals :: GetProvSubSysController () ;
	if ( t_SubSystemController )
	{
		t_SubSystemController->Lock () ;

		CWbemGlobal_IWmiProvSubSysController_Container *t_Container = NULL ;
		t_SubSystemController->GetContainer ( t_Container ) ;

		if ( t_Container->Size () )
		{
			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator = t_Container->Begin ();

			_IWmiProviderConfiguration **t_ControllerElements = new _IWmiProviderConfiguration * [ t_Container->Size () ] ;
			if ( t_ControllerElements )
			{
				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				t_SubSystemController->UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ControllerElements [ t_Index ] )
					{
						t_Result = t_ControllerElements [ t_Index ]->Call ( 

							m_Service ,
							a_Flags ,
							a_Context ,
							L"Msft_Providers" ,
							a_ObjectPath ,		
							a_MethodName ,
							a_InParams,
							a_Sink
						) ;

						t_ControllerElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ControllerElements ;
			}
			else
			{
				t_SubSystemController->UnLock () ;
			}
		}
		else
		{
			t_SubSystemController->UnLock () ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	t_Result = CoImpersonateClient () ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ProviderSubSystem_Common_Globals :: Check_SecurityDescriptor_CallIdentity (

			ProviderSubSystem_Common_Globals :: GetMethodSecurityDescriptor () , 
			MASK_PROVIDER_BINDING_BIND ,
			& g_ProviderBindingMapping
		) ;

		CoRevertToSelf () ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemPath *t_Path = NULL ;

		if ( a_ObjectPath && a_MethodName ) 
		{
			t_Result = CoCreateInstance (

				CLSID_WbemDefPath ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IWbemPath ,
				( void ** )  & t_Path
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Path->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_ObjectPath ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					ULONG t_Length = 32 ; // None of supported classes is longer than this length
					BSTR t_Class = SysAllocStringLen ( NULL , t_Length ) ; 
					if ( t_Class )
					{
						t_Result = t_Path->GetClassName (

							& t_Length ,
							t_Class
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( _wcsicmp ( t_Class , L"Msft_Providers" ) == 0 ) 
							{
								if ( _wcsicmp ( a_MethodName , L"Suspend" ) == 0 ) 
								{
									t_Result = Helper_ExecMethodAsync_Suspend (

										t_Path ,
										a_ObjectPath,
										a_MethodName,
										a_Flags,
										a_Context,
										a_InParams,
										a_Sink
									) ;
								}
								else if ( _wcsicmp ( a_MethodName , L"Resume" ) == 0 ) 
								{
									t_Result = Helper_ExecMethodAsync_Resume (

										t_Path ,
										a_ObjectPath,
										a_MethodName,
										a_Flags,
										a_Context,
										a_InParams,
										a_Sink
									) ;
								}
								else if ( _wcsicmp ( a_MethodName , L"Load" ) == 0 ) 
								{
									t_Result = Helper_ExecMethodAsync_Load (

										t_Path ,
										a_ObjectPath,
										a_MethodName,
										a_Flags,
										a_Context,
										a_InParams,
										a_Sink
									) ;
								}
								else if ( _wcsicmp ( a_MethodName , L"UnLoad" ) == 0 ) 
								{
									t_Result = Helper_ExecMethodAsync_UnLoad (

										t_Path ,
										a_ObjectPath,
										a_MethodName,
										a_Flags,
										a_Context,
										a_InParams,
										a_Sink
									) ;
								}
							}
							else
							{
								t_Result = WBEM_E_INVALID_CLASS ;
							}
						}

						SysFreeString ( t_Class ) ;
					}
				}

				t_Path->Release () ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
			t_Result = WBEM_E_INVALID_OBJECT_PATH ;
		}
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_Core ,
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	m_Service = a_Core ;
	if ( m_Service )
	{
		m_Service->AddRef () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_IWbemServices :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provsubs.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvSubS.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <wbemint.h>

#include <HelperFuncs.h>
#include <Logging.h>

#include <CGlobals.h>
#include "Globals.h"
#include "ClassFac.h"
#include "ProvResv.h"
#include "ProvFact.h"
#include "ProvSubS.h"
#include "ProvAggr.h"
#include "ProvHost.h"
#include "ProvLoad.h"
#include "ProvRMgr.h"
#include "StrobeThread.h"
#include "ProvCache.h"
#include "ProvDnf.h"
#include "Guids.h"
#include "winmgmtr.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWmiProvSSSink :: CInterceptor_IWmiProvSSSink (

	_IWmiProvSSSink *a_InterceptedSink ,
	CWbemGlobal_VoidPointerController *a_Controller 

)	:	VoidPointerContainerElement ( 

			a_Controller ,
			a_InterceptedSink
		) ,
		m_InterceptedSink ( a_InterceptedSink )
{
	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWmiProvSSSink :: ~CInterceptor_IWmiProvSSSink  ()
{
	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}


	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWmiProvSSSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiProvSSSink )
	{
		*iplpv = ( LPVOID ) ( _IWmiProvSSSink * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWmiProvSSSink :: AddRef ( void )
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWmiProvSSSink :: Release ( void )
{
	return VoidPointerContainerElement:: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWmiProvSSSink :: Synchronize (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Namespace ,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = m_InterceptedSink->Synchronize (

		a_Flags ,
		a_Context ,
		a_Namespace ,
		a_Provider

	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerProvSubSysClassFactory :: CServerProvSubSysClassFactory () : m_ReferenceCount ( 0 )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerProvSubSysClassFactory :: ~CServerProvSubSysClassFactory ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerProvSubSysClassFactory :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) ( IClassFactory * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerProvSubSysClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerProvSubSysClassFactory :: Release ()
{
	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerProvSubSysClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR *ppvObject
)
{
	HRESULT t_Result = S_OK ;

	if ( pUnkOuter )
	{
		t_Result = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		CWbemGlobal_IWmiProvSubSysController *t_Controller = ProviderSubSystem_Globals :: GetProvSubSysController () ;

		CServerObject_ProviderSubSystem *t_ProvSubSys = new CServerObject_ProviderSubSystem (

			*ProviderSubSystem_Globals :: s_Allocator ,
			t_Controller
		) ;

		if ( t_ProvSubSys == NULL )
		{
			t_Result = E_OUTOFMEMORY ;
		}
		else
		{
			t_ProvSubSys->AddRef () ;

			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator ;

			t_Controller->Lock () ;

			WmiStatusCode t_StatusCode = t_Controller->Insert (

				*t_ProvSubSys ,
				t_Iterator
			) ;

			if ( t_StatusCode != e_StatusCode_Success )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;

				t_ProvSubSys->Release () ;
			}

			t_Controller->UnLock () ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_ProvSubSys->QueryInterface ( riid , ppvObject ) ;
				if ( FAILED ( t_Result ) )
				{
					t_ProvSubSys->Release () ;
				}
			}
		}			

		t_ProvSubSys->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerProvSubSysClassFactory :: LockServer ( BOOL fLock )
{
/*
 * Place code in critical section
 */

	if ( fLock )
	{
		InterlockedIncrement ( & ProviderSubSystem_Globals :: s_LocksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & ProviderSubSystem_Globals :: s_LocksInProgress ) ;
	}

	return S_OK	;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CServerObject_ProviderSubSystem :: CServerObject_ProviderSubSystem (

	WmiAllocator &a_Allocator ,
	CWbemGlobal_IWmiProvSubSysController *a_Controller

) : CWbemGlobal_IWmiFactoryController ( a_Allocator ) ,
	ProvSubSysContainerElement (

		a_Controller ,
		this
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Core ( NULL ) ,
	m_Internal ( this ) ,
	m_SinkController ( NULL ) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_ProviderSubSystem_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderSubSystem :: ~CServerObject_ProviderSubSystem ()
{
	CWbemGlobal_IWmiFactoryController :: UnInitialize () ;

	ClearSinkController () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_ProviderSubSystem_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: ClearSinkController ()
{
	HRESULT t_Result = S_OK ;

	if ( m_SinkController )
	{
		CWbemGlobal_VoidPointerController_Container *t_Container = NULL ;
		
		m_SinkController->GetContainer ( t_Container ) ;

		m_SinkController->Lock () ;

		if ( t_Container->Size () )
		{
			CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator = t_Container->Begin ();
			while ( ! t_Iterator.Null () )
			{
				_IWmiProvSSSink *t_Sink = NULL ;

				t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProvSSSink  , ( void ** ) & t_Sink ) ;

				t_Iterator.Increment () ;

				t_Sink->Release () ;

				t_Sink->Release () ;
			}

			m_SinkController->UnLock () ;
		}
		else
		{
			m_SinkController->UnLock () ;
		}

		m_SinkController->CWbemGlobal_VoidPointerController :: UnInitialize () ;

		delete m_SinkController ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_ProviderSubSystem :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiProvSS )
	{
		*iplpv = ( LPVOID ) ( _IWmiProvSS * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * )this ;		
	}	
	else if ( iid == IID__IWmiProviderConfiguration )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderConfiguration * ) this ;		
	}	
	else if ( iid == IID_CWbemGlobal_IWmiFactoryController )
	{
		*iplpv = ( LPVOID ) ( CWbemGlobal_IWmiFactoryController * ) this ;		
	}	
	else if ( iid == IID_CWbemProviderSubSystem )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_CWbemSubSystemHook )
	{
		*iplpv = ( LPVOID ) & ( this->m_Internal ) ;
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_ProviderSubSystem :: AddRef ()
{
	return ProvSubSysContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_ProviderSubSystem :: Release ()
{
	return ProvSubSysContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CServerObject_ProviderSubSystem :: CallBackInternalRelease ()
{
	if ( m_Core )
	{
		m_Core->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: GetWmiService (

	const BSTR a_Namespace ,
	const BSTR a_User ,
	const BSTR a_Locale ,
	IWbemServices *&a_Service
)
{
	LONG t_Flags = WMICORE_FLAG_FULL_SERVICES | WMICORE_CLIENT_TYPE_PROVIDER ;

	HRESULT t_Result = m_Core->GetServices (

		a_Namespace ,
		a_User ,
		a_Locale ,
		t_Flags ,
		IID_IWbemServices ,
		( void ** ) & a_Service
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: GetWmiService (

	IWbemPath *a_Namespace ,
	const BSTR a_User ,
	const BSTR a_Locale ,
	IWbemServices *&a_Service
)
{
	wchar_t *t_NamespacePath = NULL ;

	HRESULT t_Result = ProviderSubSystem_Common_Globals :: GetNamespacePath (

		a_Namespace ,
		t_NamespacePath
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		LONG t_Flags = WMICORE_FLAG_FULL_SERVICES | WMICORE_CLIENT_TYPE_PROVIDER ;

		t_Result = m_Core->GetServices (

			t_NamespacePath ,
			a_User ,
			a_Locale ,
			t_Flags ,
			IID_IWbemServices ,
			( void ** ) & a_Service
		) ;

		delete [] t_NamespacePath ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: GetWmiRepositoryService (

	IWbemPath *a_Namespace ,
	const BSTR a_User ,
	const BSTR a_Locale ,
	IWbemServices *&a_Service
)
{
	wchar_t *t_NamespacePath = NULL ;

	HRESULT t_Result = ProviderSubSystem_Common_Globals :: GetNamespacePath (

		a_Namespace ,
		t_NamespacePath
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		LONG t_Flags = WMICORE_FLAG_REPOSITORY | WMICORE_CLIENT_TYPE_PROVIDER ;

		t_Result = m_Core->GetServices (

			t_NamespacePath ,
			a_User ,
			a_Locale ,
			t_Flags ,
			IID_IWbemServices ,
			( void ** ) & a_Service
		) ;

		delete [] t_NamespacePath ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: GetWmiRepositoryService (

	const BSTR a_Namespace ,
	const BSTR a_User ,
	const BSTR a_Locale ,
	IWbemServices *&a_Service
)
{
	LONG t_Flags = WMICORE_FLAG_REPOSITORY | WMICORE_CLIENT_TYPE_PROVIDER ;

	HRESULT t_Result = m_Core->GetServices (

		a_Namespace ,
		a_User ,
		a_Locale ,
		t_Flags ,
		IID_IWbemServices ,
		( void ** ) & a_Service
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: RegisterNotificationSink (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	_IWmiProvSSSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	CInterceptor_IWmiProvSSSink *t_Sink = new CInterceptor_IWmiProvSSSink (

		a_Sink ,
		m_SinkController
	) ;

	if ( t_Sink )
	{
		t_Sink->AddRef () ;

		CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

		m_SinkController->Lock () ;

		WmiStatusCode t_StatusCode = m_SinkController->Insert (

			*t_Sink ,
			t_Iterator 
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
		}
		else
		{
			t_Sink->Release () ;

			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		m_SinkController->UnLock () ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;	
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: UnRegisterNotificationSink (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	_IWmiProvSSSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

	m_SinkController->Lock () ;

	WmiStatusCode t_StatusCode = m_SinkController->Find (

		a_Sink ,
		t_Iterator 
	) ;

	if ( t_StatusCode == e_StatusCode_Success )
	{
		m_SinkController->UnLock () ;

		VoidPointerContainerElement *t_Element = t_Iterator.GetElement () ;			

		t_Element->Release () ;

		t_Element->Release () ;
	}
	else
	{
		m_SinkController->UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;	
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: ForwardReload (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Namespace ,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_VoidPointerController_Container *t_Container = NULL ;
		
	m_SinkController->GetContainer ( t_Container ) ;

	m_SinkController->Lock () ;

	if ( t_Container->Size () )
	{
		_IWmiProvSSSink **t_Elements = new _IWmiProvSSSink * [ t_Container->Size () ] ;
		if ( t_Elements )
		{
			CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator = t_Container->Begin ();

			ULONG t_Count = 0 ;
			while ( ! t_Iterator.Null () )
			{
				t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProvSSSink  , ( void ** ) & t_Elements [ t_Count ] ) ;

				t_Iterator.Increment () ;

				t_Count ++ ;
			}

			m_SinkController->UnLock () ;

			for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
			{
				if ( t_Elements [ t_Index ] ) 
				{
					t_Result = t_Elements [ t_Index ]->Synchronize ( 

						a_Flags ,
						a_Context ,
						a_Namespace ,
						a_Provider
					) ;

					t_Elements [ t_Index ]->Release () ;
				}
			}

			delete [] t_Elements ;
		}
		else
		{
			m_SinkController->UnLock () ;

			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		m_SinkController->UnLock () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Cache (

	LPCWSTR a_Namespace ,
	IWbemPath *a_NamespacePath ,
	CServerObject_BindingFactory *a_Factory ,
	BindingFactoryCacheKey &a_Key ,
	REFIID a_RIID ,
	void **a_Interface
)
{
	CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator ;

	HRESULT t_Result = S_OK ;

	Lock () ;

	WmiStatusCode t_StatusCode = Insert (

		*a_Factory ,
		t_Iterator
	) ;

	if ( t_StatusCode == e_StatusCode_Success )
	{
		UnLock () ;

		t_Result = a_Factory->QueryInterface (

			a_RIID ,
			a_Interface
		) ;
	}
	else
	{
		if ( t_StatusCode == e_StatusCode_AlreadyExists )
		{
			WmiStatusCode t_StatusCode = Find ( a_Key , t_Iterator ) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
				BindingFactoryCacheElement *t_Factory = t_Iterator.GetElement () ;

				t_Result = t_Factory->QueryInterface (

					a_RIID ,
					a_Interface
				) ;

				t_Factory->Release () ;

				UnLock () ;
			}
			else
			{
				UnLock () ;
			}
		}
		else
		{
			UnLock () ;

			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: CreateAndCache (

	IWbemServices *a_Core ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Namespace ,
	IWbemPath *a_NamespacePath ,
	BindingFactoryCacheKey &a_Key ,
	REFIID a_RIID ,
	void **a_Interface
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		CServerObject_BindingFactory *t_Factory = NULL ;

		try
		{
			t_Factory = new CServerObject_BindingFactory (

				m_Allocator ,
				this ,
				a_Key ,
				ProviderSubSystem_Globals :: s_InternalCacheTimeout
			) ;

			if ( t_Factory == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		catch ( Wmi_Heap_Exception &a_Exception )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Factory->AddRef () ;

/*
*	Just set the context, since we want status regarding construction of object.
*/
			_IWmiProviderFactoryInitialize *t_FactoryInitializer = NULL ;

			t_Result = t_Factory->QueryInterface (

				IID__IWmiProviderFactoryInitialize ,
				( void ** ) & t_FactoryInitializer
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_FactoryInitializer->Initialize (

					this ,
					NULL ,
					a_Flags ,
					a_Context ,
					a_Namespace ,
					a_Core ,
					NULL
				) ;
		
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = Cache (

						a_Namespace ,
						a_NamespacePath ,
						t_Factory ,
						a_Key ,
						a_RIID ,
						a_Interface
					) ;
				}

				t_FactoryInitializer->Release () ;
			}

			t_Factory->Release () ;
		}
		else
		{
			delete t_Factory ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Create (

	IWbemServices *a_Core ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Namespace ,
	REFIID a_RIID ,
	void **a_Interface
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

#if 0
DebugMacro0(

	WmiDebugLog :: s_WmiDebugLog->Write (

		L"CServerObject_ProviderSubSystem :: Create"
	) ;
)
#endif

	HRESULT t_Result = S_OK ;

/*
 *	At this stage just allocate the object, we might move to CoCreateInstance
 *	if it becomes necessary to remote the object.
 */
	try
	{
		IWbemPath *t_Path = NULL ;
		t_Result = CoCreateInstance (

			CLSID_WbemDefPath ,
			NULL ,
			CLSCTX_INPROC_SERVER ,
			IID_IWbemPath ,
			( void ** )  & t_Path
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Path->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Namespace ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				wchar_t *t_NamespacePath = NULL ;
				t_Result = ProviderSubSystem_Common_Globals :: GetNamespacePath (

					t_Path  ,
					t_NamespacePath
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator ;

					try
					{
						BindingFactoryCacheKey t_Key ( t_NamespacePath ) ;

						Lock () ;

						WmiStatusCode t_StatusCode = Find ( t_Key , t_Iterator ) ;

						if ( t_StatusCode == e_StatusCode_Success )
						{
							BindingFactoryCacheElement *t_Factory = t_Iterator.GetElement () ;

							t_Result = t_Factory->QueryInterface (

								a_RIID ,
								a_Interface
							) ;

							t_Factory->Release () ;

							UnLock () ;
						}
						else
						{
							UnLock () ;

							t_Result = CreateAndCache (

								a_Core ,
								a_Flags ,
								a_Context ,
								a_Namespace ,
								t_Path ,
								t_Key ,
								a_RIID ,
								a_Interface
							) ;
						}
					}
					catch ( Wmi_Heap_Exception &a_Exception )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}

					delete [] t_NamespacePath ;
				}
			}
			else
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}

			t_Path->Release () ;
		}
		else
		{
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: CreateRefresherManager (

	IWbemServices *a_Core ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	REFIID a_RIID ,
	void **a_Interface
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		RefresherManagerController *t_Controller = ProviderSubSystem_Globals :: GetRefresherManagerController () ;

		CWbemGlobal_IWbemRefresherMgrController_Cache *t_Cache = NULL ;
		t_Controller->GetCache ( t_Cache ) ;

		t_Controller->Lock () ;

		CWbemGlobal_IWbemRefresherMgrController_Cache_Iterator t_Iterator = t_Cache->Begin () ;

		if ( ! t_Iterator.Null () )
		{
			RefresherManagerCacheElement *t_Element = t_Iterator.GetElement () ;

			CServerObject_InterceptorProviderRefresherManager *t_RefresherManager = NULL ;

			t_Result = t_Element->QueryInterface (

				IID_CServerObject_InterceptorProviderRefresherManager ,
				( void ** ) & t_RefresherManager
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Controller->UnLock () ;

				t_Result = t_RefresherManager->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Result == S_FALSE )
					{
						t_Result = t_Element->QueryInterface (

							a_RIID ,
							a_Interface
						) ;

						t_RefresherManager->Release () ;

						return t_Result ;
					}

					if ( SUCCEEDED ( t_Result = t_RefresherManager->GetInitializeResult () ) )
					{
						t_Result = t_Element->QueryInterface (

							a_RIID ,
							a_Interface
						) ;
					}
				}

				t_RefresherManager->Release () ;
			}
			else
			{
				t_Controller->UnLock () ;
			}
		}
		else
		{
			CServerObject_InterceptorProviderRefresherManager *t_Manager = NULL ;

			try
			{
				t_Manager = new CServerObject_InterceptorProviderRefresherManager (

					t_Controller , 
					ProviderSubSystem_Globals :: s_InternalCacheTimeout ,
					m_Allocator ,
					a_Context 
				) ;

				if ( t_Manager )
				{
					t_Manager->AddRef () ;

					t_Result = t_Manager->Initialize () ;
					if ( SUCCEEDED ( t_Result ) )
					{
						CWbemGlobal_IWbemRefresherMgrController_Cache_Iterator t_Iterator ;

						WmiStatusCode t_StatusCode = t_Controller->Insert (

							*t_Manager ,
							t_Iterator
						) ;

						if ( t_StatusCode != e_StatusCode_Success )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;

							t_Manager->Release () ;
						}
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			t_Controller->UnLock () ;

			if ( SUCCEEDED ( t_Result ) )
			{
				// Should be a global?
				_IWbemRefresherMgr*	t_RefresherMgr = NULL;
				_IWmiProviderHost *t_Host = NULL ;

				try
				{
					HostCacheKey t_Key ( 

						HostCacheKey :: e_HostDesignation_Shared ,
						CServerObject_ComProviderRegistrationV1 :: s_Strings_Wmi_DefaultSharedNetworkServiceHost ,
						HostCacheKey :: e_IdentityDesignation_NetworkService ,
						NULL
					) ;

					t_Result = CServerObject_HostInterceptor :: CreateUsingAccount (

						t_Key ,
						L"NetworkService" ,
						L"NT AUTHORITY" ,
						& t_Host ,
						& t_RefresherMgr 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Manager->SetManager ( t_Host , t_RefresherMgr ) ;
						if ( SUCCEEDED ( t_Result ) ) 
						{
							t_Result = t_Manager->Startup ( 0L, a_Context, this );
							if ( SUCCEEDED( t_Result ) )
							{
								t_Result = t_Manager->QueryInterface( a_RIID, a_Interface );
							}
						}

						t_RefresherMgr->Release();

						if ( t_Host )
						{
							t_Host->Release () ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				t_Manager->SetInitialized ( t_Result ) ;

				t_Manager->Release () ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Get (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemObjectSink *a_Sink
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	BOOL t_Found = FALSE ;

	try 
	{
		if ( _wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
		{
			wchar_t *t_Namespace = NULL ; 

			IWbemPath *t_PathObject = NULL ;

			t_Result = CoCreateInstance (

				CLSID_WbemDefPath ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IWbemPath ,
				( void ** )  & t_PathObject
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_PathObject->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_Path ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					IWbemPathKeyList *t_Keys = NULL ;

					t_Result = t_PathObject->GetKeyList (

						& t_Keys 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						ULONG t_KeyCount = 0 ;
						t_Result = t_Keys->GetCount (

							& t_KeyCount 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_KeyCount == 7 )
							{
								for ( ULONG t_Index = 0 ; ( t_Index < t_KeyCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
								{
									wchar_t t_Key [ 32 ] ; 
									wchar_t *t_KeyValue = NULL ; 
									ULONG t_KeyLength = 32 ;
									ULONG t_KeyValueLength = 0 ;
									ULONG t_KeyType = 0 ;

									t_Result = t_Keys->GetKey (

										t_Index ,
										0 ,
										& t_KeyLength ,
										t_Key ,
										& t_KeyValueLength ,
										t_KeyValue ,
										& t_KeyType
									) ;

									if ( SUCCEEDED ( t_Result ) ) 
									{
										if ( t_KeyType == CIM_STRING )
										{
											t_KeyValue = new wchar_t [ t_KeyValueLength ] ;
											if ( t_KeyValue )
											{
												t_Result = t_Keys->GetKey (

													t_Index ,
													0 ,
													& t_KeyLength ,
													t_Key ,
													& t_KeyValueLength ,
													t_KeyValue ,
													& t_KeyType
												) ;

												if ( SUCCEEDED ( t_Result ) )
												{
													if ( _wcsicmp ( L"Namespace" , t_Key ) == 0 )
													{
														t_Namespace = t_KeyValue ;
													}
													else
													{
														delete [] t_KeyValue ;
													}
												}
												else
												{
													t_Result = WBEM_E_CRITICAL_ERROR ;
												}
											}
											else
											{
												t_Result = WBEM_E_OUT_OF_MEMORY ;
											}	
										}
										else if ( t_KeyType == CIM_SINT32 )
										{
										}
										else
										{
											t_Result = WBEM_E_INVALID_OBJECT_PATH ;
										}
									}
									else
									{
										t_Result = WBEM_E_CRITICAL_ERROR ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_INVALID_OBJECT_PATH ;
							}
						}
                        t_Keys->Release();
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				t_PathObject->Release () ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator ;

				BindingFactoryCacheElement *t_Factory = NULL ;

				Lock () ;

				try
				{
					BindingFactoryCacheKey t_Key ( t_Namespace ) ;

					WmiStatusCode t_StatusCode = Find ( t_Key , t_Iterator ) ;
					if ( t_StatusCode == e_StatusCode_Success )
					{
						t_Factory = t_Iterator.GetElement () ;
					}
					else
					{
						t_Result = WBEM_E_NOT_FOUND ;
					}
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				UnLock () ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Found = TRUE ;

					_IWmiProviderConfiguration *t_Configuration = NULL ;

					t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_Configuration ) ;

					t_Result = t_Configuration->Get ( 

						a_Service ,
						a_Flags, 
						a_Context,
 						a_Class, 
						a_Path,
						a_Sink 
					) ;

					t_Configuration->Release () ;

					t_Factory->Release () ;
				}
			}

			if ( t_Namespace )
			{
				delete [] t_Namespace ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( ! t_Found )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Set (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_OldObject ,
	IWbemClassObject *a_NewObject  

)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Deleted (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_Object  
) 
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Enumerate (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	IWbemObjectSink *a_Sink
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		if ( _wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
		{
			Lock () ;

			CWbemGlobal_IWmiFactoryController_Cache *t_Cache = NULL ;
			GetCache ( t_Cache ) ;

			if ( t_Cache->Size () )
			{
				CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator = t_Cache->Begin ();

				_IWmiProviderConfiguration **t_ControllerElements = new _IWmiProviderConfiguration * [ t_Cache->Size () ] ;
				if ( t_ControllerElements )
				{
					ULONG t_Count = 0 ;
					while ( ! t_Iterator.Null () )
					{
						HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

						t_Iterator.Increment () ;

						t_Count ++ ;
					}

					UnLock () ;

					for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
					{
						if ( t_ControllerElements [ t_Index ] )
						{
							HRESULT t_Result = t_ControllerElements [ t_Index ]->Enumerate ( 

								a_Service ,
								a_Flags, 
								a_Context,
 								a_Class, 
								a_Sink 
							) ;

							t_ControllerElements [ t_Index ]->Release () ;
						}
					}

					delete [] t_ControllerElements ;
				}
				else
				{
					UnLock () ;
				}
			}
			else
			{
				UnLock () ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Call_Load (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,		
	LPCWSTR a_Method,
	IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try 
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		t_Result = a_InParams->Get ( L"Namespace" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BSTR )
			{
				IWbemServices *t_Services = NULL ;

				BSTR t_Namespace = SysAllocString ( t_Variant.bstrVal ) ;
				if ( t_Namespace )
				{
					t_Result = GetWmiService (

						t_Namespace ,
						NULL ,
						NULL ,
						t_Services
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					_IWmiProviderFactory *t_Factory = NULL ;

					t_Result = Create (

						t_Services ,
						0 ,
						a_Context ,
						t_Namespace ,
						IID__IWmiProviderFactory,
						( void ** ) & t_Factory 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;
					
						LONG t_VarType = 0 ;
						LONG t_Flavour = 0 ;

						BSTR t_User = NULL ;
						BSTR t_Locale = NULL ;
						BSTR t_TransactionIdentifier = NULL ;
						BSTR t_Provider = NULL ;
						GUID t_TransactionIdentifierGuid ;

						t_Result = a_InParams->Get ( L"User" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_Variant.vt == VT_BSTR )		
							{
								t_User = SysAllocString ( t_Variant.bstrVal ) ;
							}
							else if ( t_Variant.vt == VT_NULL )
							{
							}
							else
							{
								t_Result = WBEM_E_INVALID_PARAMETER ;
							}
						}
						else
						{
							t_Result = ( t_Result == WBEM_E_NOT_FOUND ) ? S_OK : t_Result ;
						}
			
						VariantClear ( & t_Variant ) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = a_InParams->Get ( L"Locale" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_Variant.vt == VT_BSTR )		
								{
									t_Locale = SysAllocString ( t_Variant.bstrVal ) ;
								}
								else if ( t_Variant.vt == VT_NULL )
								{
								}
								else
								{
									t_Result = WBEM_E_INVALID_PARAMETER ;
								}
							}
							else
							{
								t_Result = ( t_Result == WBEM_E_NOT_FOUND ) ? S_OK : t_Result ;
							}
				
							VariantClear ( & t_Variant ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = a_InParams->Get ( L"Provider" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_Variant.vt == VT_BSTR )		
								{
									t_Provider = SysAllocString ( t_Variant.bstrVal ) ;
								}
								else
								{
									t_Result = WBEM_E_INVALID_PARAMETER ;
								}
							}
							else
							{
								t_Result = ( t_Result == WBEM_E_NOT_FOUND ) ? S_OK : t_Result ;
							}
				
							VariantClear ( & t_Variant ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = a_InParams->Get ( L"TransactionIdentifier" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_Variant.vt == VT_BSTR )		
								{
									t_TransactionIdentifier = SysAllocString ( t_Variant.bstrVal ) ;

									t_Result = CLSIDFromString (
										
										t_TransactionIdentifier ,
										& t_TransactionIdentifierGuid
									) ;

									if ( FAILED ( t_Result ) )
									{
										t_Result = WBEM_E_INVALID_PARAMETER ;
									}
								}
								else if ( t_Variant.vt == VT_NULL )
								{
								}
								else
								{
									t_Result = WBEM_E_INVALID_PARAMETER ;
								}
							}
							else
							{
								t_Result = ( t_Result == WBEM_E_NOT_FOUND ) ? S_OK : t_Result ;
							}
				
							VariantClear ( & t_Variant ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							CServerObject_ProviderRegistrationV1 *t_Registration = new CServerObject_ProviderRegistrationV1 ;
							if ( t_Registration )
							{
								t_Registration->AddRef () ;

								IWbemPath *t_NamespacePath = NULL ;

								t_Result = CoCreateInstance (

									CLSID_WbemDefPath ,
									NULL ,
									CLSCTX_INPROC_SERVER ,
									IID_IWbemPath ,
									( void ** )  & t_NamespacePath
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_NamespacePath->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , t_Namespace ) ;
									if ( SUCCEEDED ( t_Result ) )
									{
										t_Result = t_Registration->SetContext ( 

											a_Context ,
											t_NamespacePath , 
											t_Services
										) ;
										
										if ( SUCCEEDED ( t_Result ) )
										{
											t_Result = t_Registration->Load ( 

												e_All ,
												NULL , 
												t_Provider
											) ;

											if ( SUCCEEDED ( t_Result ) )
											{
												ProviderSubSystem_Globals :: DeleteGuidTag ( t_Registration->GetClsid () ) ;
											}
										}
									}

									t_NamespacePath->Release () ;
								}

								t_Registration->Release () ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							IUnknown *t_Unknown = NULL ;

							WmiInternalContext t_InternalContext ;
							ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

							t_Result = t_Factory->GetProvider ( 

								t_InternalContext ,
								0 ,
								a_Context ,
								t_TransactionIdentifier ? & t_TransactionIdentifierGuid : NULL ,
								t_User ,
								t_Locale ,
								NULL ,
								t_Provider ,
								IID_IUnknown, 
								( void ** ) & t_Unknown
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								_IWmiProviderLoad *t_Load = NULL ;

								t_Result = t_Unknown->QueryInterface ( IID__IWmiProviderLoad , ( void ** ) & t_Load ) ;
								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_Load->Load ( 

										0 ,
										a_Context
									) ;

									t_Load->Release () ;
								}
								else
								{
									t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
								}

								t_Unknown->Release () ;
							}
						}
 
						t_Factory->Release () ;

						if ( t_User )
						{
							SysFreeString ( t_User ) ;
						}

						if ( t_Locale ) 
						{
							SysFreeString ( t_Locale ) ;
						}

						if ( t_Provider ) 
						{
							SysFreeString( t_Provider ) ;
						}

						if ( t_TransactionIdentifier ) 
						{
							SysFreeString ( t_TransactionIdentifier ) ;
						}
					}

					t_Services->Release () ;
				}

				if ( t_Namespace )
				{
					SysFreeString ( t_Namespace ) ;
				}
			}
			else
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}

			VariantClear ( & t_Variant ) ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Call (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,		
	LPCWSTR a_Method,
	IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	BOOL t_Found = FALSE ;

	try 
	{
		if ( _wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
		{
			if ( _wcsicmp ( a_Method , L"Load" ) == 0 )
			{
				t_Result = Call_Load ( 

					a_Flags, 
					a_Context,
 					a_Class, 
					a_Path,
					a_Method,
					a_InParams,
					a_Sink 
				) ;

				t_Found = TRUE ;
			}
			else
			{
				wchar_t *t_Namespace = NULL ; 

				IWbemPath *t_PathObject = NULL ;

				t_Result = CoCreateInstance (

					CLSID_WbemDefPath ,
					NULL ,
					CLSCTX_INPROC_SERVER ,
					IID_IWbemPath ,
					( void ** )  & t_PathObject
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_PathObject->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_Path ) ;
					if ( SUCCEEDED ( t_Result ) ) 
					{
						IWbemPathKeyList *t_Keys = NULL ;

						t_Result = t_PathObject->GetKeyList (

							& t_Keys 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							ULONG t_KeyCount = 0 ;
							t_Result = t_Keys->GetCount (

								& t_KeyCount 
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_KeyCount == 7 )
								{
									for ( ULONG t_Index = 0 ; ( t_Index < t_KeyCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
									{
										wchar_t t_Key [ 32 ] ; 
										wchar_t *t_KeyValue = NULL ; 
										ULONG t_KeyLength = 32 ;
										ULONG t_KeyValueLength = 0 ;
										ULONG t_KeyType = 0 ;

										t_Result = t_Keys->GetKey (

											t_Index ,
											0 ,
											& t_KeyLength ,
											t_Key ,
											& t_KeyValueLength ,
											t_KeyValue ,
											& t_KeyType
										) ;

										if ( SUCCEEDED ( t_Result ) ) 
										{
											if ( t_KeyType == CIM_STRING )
											{
												t_KeyValue = new wchar_t [ t_KeyValueLength ] ;
												if ( t_KeyValue )
												{
													t_Result = t_Keys->GetKey (

														t_Index ,
														0 ,
														& t_KeyLength ,
														t_Key ,
														& t_KeyValueLength ,
														t_KeyValue ,
														& t_KeyType
													) ;

													if ( SUCCEEDED ( t_Result ) )
													{
														if ( _wcsicmp ( L"Namespace" , t_Key ) == 0 )
														{
															t_Namespace = t_KeyValue ;
														}
														else
														{
															delete [] t_KeyValue ;
														}
													}
													else
													{
														t_Result = WBEM_E_CRITICAL_ERROR ;
													}
												}
												else
												{
													t_Result = WBEM_E_OUT_OF_MEMORY ;
												}	
											}
											else if ( t_KeyType == CIM_SINT32 )
											{
											}
											else
											{
												t_Result = WBEM_E_INVALID_OBJECT_PATH ;
											}
										}
										else
										{
											t_Result = WBEM_E_CRITICAL_ERROR ;
										}
									}
								}
								else
								{
									t_Result = WBEM_E_INVALID_OBJECT_PATH ;
								}
							}
                            t_Keys->Release();
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}

					t_PathObject->Release () ;
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator ;

					BindingFactoryCacheElement *t_Factory = NULL ;

					Lock () ;

					try
					{
						BindingFactoryCacheKey t_Key ( t_Namespace ) ;

						WmiStatusCode t_StatusCode = Find ( t_Key , t_Iterator ) ;
						if ( t_StatusCode == e_StatusCode_Success )
						{
							t_Factory = t_Iterator.GetElement () ;
						}
						else
						{
							t_Result = WBEM_E_NOT_FOUND ;
						}
					}
					catch ( Wmi_Heap_Exception &a_Exception )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}

					UnLock () ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Found = TRUE ;

						_IWmiProviderConfiguration *t_Configuration = NULL ;

						t_Result = t_Iterator.GetElement ()->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_Configuration ) ;

						t_Result = t_Configuration->Call ( 

							a_Service ,
							a_Flags, 
							a_Context,
 							a_Class, 
							a_Path,
							a_Method,
							a_InParams,
							a_Sink 
						) ;

						t_Configuration->Release () ;

						t_Factory->Release () ;
					}
				}

				if ( t_Namespace )
				{
					delete [] t_Namespace ;
				}
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( ! t_Found )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Shutdown (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	ULONG a_MilliSeconds
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Query (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
	WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
	VARIANT *a_Value 
)
{
	return WBEM_E_NOT_SUPPORTED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState CServerObject_ProviderSubSystem :: IsA (

	IWbemClassObject *a_Left ,
	BSTR a_Right
) 
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_False ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	LONG t_VarType = 0 ;
	LONG t_Flavour = 0 ;

	HRESULT t_Result = a_Left->Get ( L"__Class" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Variant.vt == ( VT_NULL ) )
		{
		}
		else
		{
			if ( _wcsicmp ( t_Variant.bstrVal , a_Right ) == 0 )
			{
				t_Status = QueryPreprocessor :: State_True ;
			}
		}

		VariantClear ( & t_Variant ) ;
	}
	else
	{
		t_Status = QueryPreprocessor :: State_Error ;
	}

	if ( t_Status == QueryPreprocessor :: State_False )
	{
		VARIANT t_LeftSafeArray ;
		VariantInit ( & t_LeftSafeArray ) ;

		t_Result = a_Left->Get ( L"__Derivation" , 0 , & t_LeftSafeArray , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_LeftSafeArray.vt == ( VT_BSTR | VT_ARRAY ) )
			{
				SAFEARRAY *t_LeftArray = t_LeftSafeArray.parray ;
				if ( SafeArrayGetDim ( t_LeftSafeArray.parray ) == 1 )
				{
					LONG t_Dimension = 1 ; 

					LONG t_Lower ;
					SafeArrayGetLBound ( t_LeftSafeArray.parray , t_Dimension , & t_Lower ) ;

					LONG t_Upper ;
					SafeArrayGetUBound ( t_LeftSafeArray.parray , t_Dimension , & t_Upper ) ;

					for ( LONG t_Index = t_Lower ; t_Index <= t_Upper ; t_Index ++ )
					{
						BSTR t_Element = NULL ;
						if ( SUCCEEDED ( SafeArrayGetElement ( t_LeftSafeArray.parray , & t_Index , & t_Element ) ) )
						{
							if ( _wcsicmp ( t_Element , a_Right ) == 0 )
							{
								SysFreeString ( t_Element ) ;

								t_Status = QueryPreprocessor :: State_True ;

								break ;
							}

							SysFreeString ( t_Element ) ;
						}
						else
						{
							t_Status = QueryPreprocessor :: State_Error ;

							break ;
						}
					}
				}
				else
				{
					t_Status = QueryPreprocessor :: State_Error ;
				}
			}
			else
			{
				t_Status = QueryPreprocessor :: State_Error ;
			}
		}
		else
		{
			t_Status = QueryPreprocessor :: State_Error ;
		}

		VariantClear ( & t_LeftSafeArray ) ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: ReportEvent ( 

	CServerObject_ProviderRegistrationV1 &a_Registration ,
	const BSTR a_NamespacePath
)
{
	HRESULT t_Result = S_OK ;

	BOOL t_DataProvider =	a_Registration.GetClassProviderRegistration ().Supported () ||
							a_Registration.GetInstanceProviderRegistration ().Supported () ||
							a_Registration.GetPropertyProviderRegistration ().Supported () ||
							a_Registration.GetMethodProviderRegistration ().Supported () ;

	if ( t_DataProvider && ( ( a_Registration.GetHosting () == e_Hosting_SharedLocalSystemHost ) || ( a_Registration.GetHosting () == e_Hosting_SharedLocalSystemHostOrSelfHost ) ) )
	{
		t_Result= VerifySecureLocalSystemProviders ( a_Registration.GetComRegistration ().GetClsidServer ().GetProviderClsid () ) ;
		if ( FAILED ( t_Result ) )
		{
			_IWmiCallSec *t_CallSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: CreateInstance (

				CLSID__IWbemCallSec ,
				NULL ,
				CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
				IID__IWmiCallSec ,
				( void ** ) & t_CallSecurity 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				ULONG t_Size = 0 ;
				PSID t_Sid = NULL ;

				t_Result = CoImpersonateClient () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_CallSecurity->GetUserSid ( 

						& t_Size ,
						t_Sid
					) ;

					if ( SUCCEEDED ( t_Result ) ) 
					{
						t_Sid = ( PSID ) new BYTE [ t_Size ] ;
						if ( t_Sid )
						{
							t_Result = t_CallSecurity->GetUserSid ( 

								& t_Size ,
								t_Sid
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_FAILED ;
					}
				}

				CoRevertToSelf () ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					wchar_t *t_Array [ 2 ] ;

					t_Array [ 0 ] = a_Registration.GetProviderName () ;
					t_Array [ 1 ] = a_NamespacePath ;

					BOOL t_Status = :: ReportEvent (

					  ProviderSubSystem_Globals :: GetNtEventSource () ,
					  EVENTLOG_WARNING_TYPE ,
					  0 ,
					  WBEM_MC_PROVIDER_SUBSYSTEM_LOCALSYSTEM_PROVIDER_LOAD ,
					  t_Sid ,
					  2 ,
					  0 ,
					  ( LPCWSTR * ) t_Array ,
					  NULL
					) ;

					if ( t_Status == 0 )
					{
						DWORD t_LastError = GetLastError () ;
					}
				}

				t_CallSecurity->Release () ;

				if ( t_Sid )
				{
					delete [] ( BYTE * ) t_Sid ;
				}
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: VerifySecurity ( 

	IWbemContext *a_Context ,
	const BSTR a_Provider ,
	const BSTR a_NamespacePath
)
{
	IWbemServices *t_RepositoryService = NULL ;
	HRESULT t_Result = GetWmiRepositoryService ( a_NamespacePath , NULL , NULL , t_RepositoryService ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		IWbemPath *t_Namespace = NULL ;
		if ( a_NamespacePath ) 
		{
			t_Result = CoCreateInstance (

				CLSID_WbemDefPath ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IWbemPath ,
				( void ** )  & t_Namespace
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Namespace->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_NamespacePath ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CServerObject_ProviderRegistrationV1 t_Registration ;

					t_Result = t_Registration.SetContext ( 

						a_Context ,
						t_Namespace , 
						t_RepositoryService
					) ;
					
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Registration.Load ( 

							e_All ,
							NULL , 
							a_Provider
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							HRESULT t_TempResult = ReportEvent ( 

								t_Registration ,
								a_NamespacePath
							) ;
						}
					}
				}

				t_Namespace->Release () ;
			}
		}

		t_RepositoryService->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: GetPath (

    IWbemClassObject *a_Object ,
    IWbemPath *&a_Path ,
	LPWSTR &a_PathText
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Object )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		t_Result = a_Object->Get ( L"__Path" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			a_PathText = new wchar_t [ wcslen ( t_Variant.bstrVal ) + 1 ] ;
			if ( a_PathText )
			{
				wcscpy ( a_PathText , t_Variant.bstrVal ) ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = CoCreateInstance (

					CLSID_WbemDefPath ,
					NULL ,
					CLSCTX_INPROC_SERVER ,
					IID_IWbemPath ,
					( void ** )  & a_Path
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = a_Path->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_PathText ) ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: GetProvider (

    LPCWSTR a_Class ,
    IWbemPath *a_Path ,
    IWbemClassObject *a_Object ,
    LPWSTR &a_Provider
)
{
	HRESULT t_Result = S_OK ;

	QueryPreprocessor :: QuadState t_State = IsA ( a_Object  , L"__Win32Provider" ) ;
	if ( t_State == QueryPreprocessor :: State_Error )
	{
		return WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_State == QueryPreprocessor :: State_True )
	{
		IWbemPathKeyList *t_ProviderKeys = NULL ;

		t_Result = a_Path->GetKeyList (

			& t_ProviderKeys
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			ULONG t_ProviderNameLength = 0 ;
			ULONG t_Type = 0 ;

			t_Result = t_ProviderKeys->GetKey (

				0 ,
				0 ,
				NULL ,
				NULL ,
				& t_ProviderNameLength ,
				a_Provider ,
				& t_Type
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				a_Provider = new wchar_t [ ( t_ProviderNameLength / sizeof ( wchar_t ) ) + 1 ] ;
				if ( a_Provider )
				{
					t_Result = t_ProviderKeys->GetKey (

						0 ,
						0 ,
						NULL ,
						NULL ,
						& t_ProviderNameLength ,
						a_Provider ,
						& t_Type
					) ;

					if ( FAILED ( t_Result ) )
					{
						delete [] a_Provider ;

						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			t_ProviderKeys->Release () ;
		}
	}
	else
	{
		if ( t_State == QueryPreprocessor :: State_False )
		{
			t_State = IsA ( a_Object  , L"__EventProviderRegistration" ) ;
			if ( t_State == QueryPreprocessor :: State_Error )
			{
				return WBEM_E_OUT_OF_MEMORY ;
			}

			if ( t_State == QueryPreprocessor :: State_False )
			{
				t_State = IsA ( a_Object  , L"__EventProviderRegistration" ) ;
				if ( t_State == QueryPreprocessor :: State_Error )
				{
					return WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( t_State == QueryPreprocessor :: State_False )
			{
				t_State = IsA ( a_Object  , L"__EventConsumerProviderRegistration" ) ;
				if ( t_State == QueryPreprocessor :: State_Error )
				{
					return WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( t_State == QueryPreprocessor :: State_False )
			{
				t_State = IsA ( a_Object  , L"__InstanceProviderRegistration" ) ;
				if ( t_State == QueryPreprocessor :: State_Error )
				{
					return WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( t_State == QueryPreprocessor :: State_False )
			{
				t_State = IsA ( a_Object  , L"__MethodProviderRegistration" ) ;
				if ( t_State == QueryPreprocessor :: State_Error )
				{
					return WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( t_State == QueryPreprocessor :: State_False )
			{
				t_State = IsA ( a_Object  , L"__PropertyProviderRegistration" ) ;
				if ( t_State == QueryPreprocessor :: State_Error )
				{
					return WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( t_State == QueryPreprocessor :: State_False )
			{
				t_State = IsA ( a_Object  , L"__ClassProviderRegistration" ) ;
				if ( t_State == QueryPreprocessor :: State_Error )
				{
					return WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( t_State == QueryPreprocessor :: State_True )
			{
				IWbemPathKeyList *t_RegistrationKeys = NULL ;

				t_Result = a_Path->GetKeyList (

					& t_RegistrationKeys
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					wchar_t *t_ProviderReference = NULL ;
					ULONG t_ProviderReferenceLength = 0 ;
					ULONG t_Type = 0 ;

					t_Result = t_RegistrationKeys->GetKey (

						0 ,
						0 ,
						NULL ,
						NULL ,
						& t_ProviderReferenceLength ,
						t_ProviderReference ,
						& t_Type
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_ProviderReference = new wchar_t [ ( t_ProviderReferenceLength / sizeof ( wchar_t ) ) + 1 ] ;
						if ( t_ProviderReference )
						{
							t_Result = t_RegistrationKeys->GetKey (

								0 ,
								0 ,
								NULL ,
								NULL ,
								& t_ProviderReferenceLength ,
								t_ProviderReference ,
								& t_Type
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								IWbemPath *t_ProviderPath = NULL ;

								t_Result = CoCreateInstance (

									CLSID_WbemDefPath ,
									NULL ,
									CLSCTX_INPROC_SERVER ,
									IID_IWbemPath ,
									( void ** )  & t_ProviderPath
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_ProviderPath->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , t_ProviderReference ) ;
									if ( SUCCEEDED ( t_Result ) )
									{
										IWbemPathKeyList *t_ProviderKeys = NULL ;

										t_Result = t_ProviderPath->GetKeyList (

											& t_ProviderKeys
										) ;

										if ( SUCCEEDED ( t_Result ) )
										{
											ULONG t_ProviderLength = 0 ;
											ULONG t_Type = 0 ;

											t_Result = t_ProviderKeys->GetKey (

												0 ,
												0 ,
												NULL ,
												NULL ,
												& t_ProviderLength ,
												a_Provider ,
												& t_Type
											) ;

											if ( SUCCEEDED ( t_Result ) )
											{
												a_Provider = new wchar_t [ ( t_ProviderLength / sizeof ( wchar_t ) ) + 1 ] ;
												if ( a_Provider )
												{
													t_Result = t_ProviderKeys->GetKey (

														0 ,
														0 ,
														NULL ,
														NULL ,
														& t_ProviderLength ,
														a_Provider ,
														& t_Type
													) ;

													if ( FAILED ( t_Result ) )
													{
														delete [] a_Provider ;
													}
												}
												else
												{
													t_Result = WBEM_E_OUT_OF_MEMORY ;
												}
											}

											t_ProviderKeys->Release () ;
										}
									}

									t_ProviderPath->Release () ;
								}
							}

							delete [] t_ProviderReference ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_RegistrationKeys->Release () ;
				}
			}
			else
			{
				t_Result = WBEM_E_NOT_FOUND ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: PrePut (

    long a_Flags ,
    long a_UserFlags ,
    IWbemContext *a_Context ,
    IWbemPath *a_Path ,
    LPCWSTR a_Namespace ,
    LPCWSTR a_Class ,
    _IWmiObject *a_Copy
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = WBEM_S_NO_POSTHOOK;

	try
	{
		if ( ( a_Flags & WBEM_FLAG_INST_PUT ) == WBEM_FLAG_INST_PUT )
		{
			IWbemClassObject *t_Object = NULL ;
			t_Result = a_Copy->QueryInterface ( IID_IWbemClassObject , ( void ** ) & t_Object ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				QueryPreprocessor :: QuadState t_State = IsA ( t_Object  , L"__Win32Provider" ) ;
				if ( t_State == QueryPreprocessor :: State_Error )
				{
					t_Object->Release () ;

					return WBEM_E_OUT_OF_MEMORY ;
				}

				if ( t_State == QueryPreprocessor :: State_True )
				{
					CServerObject_ComProviderRegistrationV1 t_Registration ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Registration.QueryProperties ( 

							e_All ,
							t_Object , 
							NULL
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
#ifdef DEV_BUILD
							if ( SUCCEEDED ( t_Result ) ) 
							{
								t_Result = WBEM_S_POSTHOOK_WITH_BOTH ;
							}
#else
							if ( ( t_Registration.GetHosting () == e_Hosting_WmiCore ) || ( t_Registration.GetHosting () == e_Hosting_WmiCoreOrSelfHost ) ) 
							{
								t_Result = VerifySecureSvcHostProviders ( t_Registration.GetClsidServer ().GetProviderClsid () ) ;
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{
								t_Result = WBEM_S_POSTHOOK_WITH_BOTH ;
							}
#endif

						}
						else
						{
							t_Result = WBEM_E_VETO_PUT ;
						}
					}
				}
				else
				{
					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_Object  , L"__EventProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							t_Object->Release () ;
							return WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_Object  , L"__EventConsumerProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							t_Object->Release () ;
							return WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_Object  , L"__InstanceProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							t_Object->Release () ;
							return WBEM_E_OUT_OF_MEMORY ;
						}
						else if ( t_State == QueryPreprocessor :: State_True )
						{
							CServerObject_InstanceProviderRegistrationV1 t_Registration ;

							t_Result = t_Registration.QueryProperties ( 

								e_All ,
								t_Object
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = WBEM_S_POSTHOOK_WITH_BOTH ;
							}
							else
							{
								t_Result = WBEM_E_VETO_PUT ;
							}
						}
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_Object  , L"__MethodProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							t_Object->Release () ;
							return WBEM_E_OUT_OF_MEMORY ;
						}
						else if ( t_State == QueryPreprocessor :: State_True )
						{
							CServerObject_MethodProviderRegistrationV1 t_Registration ;

							t_Result = t_Registration.QueryProperties ( 

								e_All ,
								t_Object
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = WBEM_S_POSTHOOK_WITH_BOTH ;
							}
							else
							{
								t_Result = WBEM_E_VETO_PUT ;
							}
						}
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_Object  , L"__PropertyProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							t_Object->Release () ;
							return WBEM_E_OUT_OF_MEMORY ;
						}
						else if ( t_State == QueryPreprocessor :: State_True )
						{
							CServerObject_DynamicPropertyProviderRegistrationV1 t_Registration ;

							t_Result = t_Registration.QueryProperties ( 

								e_All ,
								t_Object
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = WBEM_S_POSTHOOK_WITH_BOTH ;
							}
							else
							{
								t_Result = WBEM_E_VETO_PUT ;
							}
						}
					}


					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_Object  , L"__ClassProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							t_Object->Release () ;
							return WBEM_E_OUT_OF_MEMORY ;
						}
						else if ( t_State == QueryPreprocessor :: State_True )
						{
							CServerObject_ClassProviderRegistrationV1 t_Registration ;

							t_Result = t_Registration.QueryProperties ( 

								e_All ,
								t_Object
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = WBEM_S_POSTHOOK_WITH_BOTH ;
							}
							else
							{
								t_Result = WBEM_E_VETO_PUT ;
							}
						}
					}
				}

				t_Object->Release () ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: PostPut (

    long a_Flags ,
    HRESULT hRes,
    IWbemContext *a_Context ,
    IWbemPath *a_Path ,
    LPCWSTR a_Namespace ,
    LPCWSTR a_Class ,
    _IWmiObject *a_New ,
    _IWmiObject *a_Old
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		IWbemClassObject *t_OldObject = NULL ;
		IWbemClassObject *t_NewObject = NULL ;

		if ( a_Old ) 
		{
			t_Result = a_Old->QueryInterface ( IID_IWbemClassObject , ( void ** ) & t_OldObject ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( a_New )
			{
				t_Result = a_New->QueryInterface ( IID_IWbemClassObject , ( void ** ) & t_NewObject ) ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			LPWSTR t_Class = NULL ;
			LPWSTR t_Path = NULL ;
			IWbemPath *t_PathObject = NULL ;

			if ( a_Class == NULL )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
			
				LONG t_VarType = 0 ;
				LONG t_Flavour = 0 ;

				t_Result = t_NewObject->Get ( L"__Class" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Class = new wchar_t [ wcslen ( t_Variant.bstrVal ) + 1 ] ;
					if ( t_Class )
					{
						wcscpy ( t_Class , t_Variant.bstrVal ) ;
					}					
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					VariantClear ( & t_Variant ) ;
				}
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( a_Path == NULL )
				{
					t_Result = GetPath ( t_NewObject , t_PathObject , t_Path ) ;
				}
				else
				{
					t_Result = ProviderSubSystem_Common_Globals :: GetPathText (

						a_Path ,
						t_Path
					) ;
				}
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				LPWSTR t_Provider = NULL ;

				t_Result = GetProvider (

					a_Class ? a_Class : t_Class ,
					a_Path ? a_Path : t_PathObject ,
					t_NewObject ,
					t_Provider
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = VerifySecurity ( 

						a_Context ,
						( const BSTR ) t_Provider ,
						( const BSTR ) a_Namespace
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator ;

						BindingFactoryCacheElement *t_Factory = NULL ;

						Lock () ;

						try
						{
							BindingFactoryCacheKey t_Key ( a_Namespace ) ;

							WmiStatusCode t_StatusCode = Find ( t_Key , t_Iterator ) ;

							if ( t_StatusCode == e_StatusCode_Success )
							{
								t_Factory = t_Iterator.GetElement () ;
							}
							else
							{
								t_Result = WBEM_E_NOT_FOUND ;
							}
						}
						catch ( Wmi_Heap_Exception &a_Exception )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}

						UnLock () ;

						if ( SUCCEEDED ( t_Result  ) )
						{
							_IWmiProviderConfiguration *t_Configuration = NULL ;
							t_Result = t_Factory->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_Configuration ) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Configuration->Set (

									NULL ,
									a_Flags ,
									a_Context ,
									t_Provider ,
									a_Class ? a_Class : t_Class ,
									t_Path ,
									t_OldObject ,
									t_NewObject
								) ;

								t_Configuration->Release () ;
							}

							t_Factory->Release () ;
						}
					}

					delete [] t_Provider ;
				}
			}

			if ( t_Class )
			{
				delete [] t_Class ;
			}

			if ( t_Path )
			{
				delete [] t_Path ;
			}

			if ( t_PathObject )
			{
				t_PathObject->Release () ;
			}

			if ( t_OldObject )
			{
				t_OldObject->Release () ;
			}	
	
			t_NewObject->Release () ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: PreDelete (

    long a_Flags ,
    long a_UserFlags ,
    IWbemContext *a_Context ,
    IWbemPath *a_Path,
    LPCWSTR a_Namespace,
    LPCWSTR a_Class
)
{
	return WBEM_S_POSTHOOK_WITH_OLD ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: PostDelete_ProviderRegistration (

    long a_Flags ,
    HRESULT hRes,
    IWbemContext *a_Context ,
    IWbemPath *a_Path,
    LPCWSTR a_PathString ,
    LPCWSTR a_Namespace,
    LPCWSTR a_Class,
    IWbemClassObject *a_Old
)
{
	LPWSTR t_Provider = NULL ;

	HRESULT t_Result = GetProvider (

		a_Class ,
		a_Path ,
		a_Old ,
		t_Provider
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator ;

		BindingFactoryCacheElement *t_Factory = NULL ;

		Lock () ;

		try
		{
			BindingFactoryCacheKey t_Key ( a_Namespace ) ;

			WmiStatusCode t_StatusCode = Find ( t_Key , t_Iterator ) ;
			if ( t_StatusCode == e_StatusCode_Success )
			{
				t_Factory = t_Iterator.GetElement () ;
			}
			else
			{
				t_Result = WBEM_E_NOT_FOUND ;
			}
		}
		catch ( Wmi_Heap_Exception &a_Exception )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		UnLock () ;

		if ( SUCCEEDED ( t_Result ) )
		{
			_IWmiProviderConfiguration *t_Configuration = NULL ;
			t_Result = t_Factory->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_Configuration ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Configuration->Deleted (

					NULL ,
					a_Flags ,
					a_Context ,
					t_Provider ,
					a_Class ,
					a_PathString ,
					a_Old 
				) ;

				t_Configuration->Release () ;
			}

			t_Factory->Release () ;
		}

		delete [] t_Provider ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

wchar_t *CServerObject_ProviderSubSystem :: Strip_Slash ( wchar_t *a_String )
{
	wchar_t *t_String = new wchar_t [ wcslen ( a_String ) + 1 ] ;
	if ( t_String )
	{
		wcscpy ( t_String , a_String ) ;

		wchar_t *t_Scan = t_String ;
		while ( *t_Scan != NULL )
		{
			if ( *t_Scan == '/' )
			{
				*t_Scan = '\\' ;
			}

			t_Scan ++ ;
		}
	}

	return t_String ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

wchar_t *CServerObject_ProviderSubSystem :: Strip_Server ( wchar_t *a_String , wchar_t *&a_FreeString )
{
	wchar_t *t_Mark = a_FreeString = Strip_Slash ( a_String ) ;
	if ( t_Mark )
	{
		wchar_t *t_Scan = t_Mark ;

		ULONG t_State = 0 ;
		while ( t_State < 0x80000000 )
		{
			switch ( t_State )
			{
				case 0:
				{
					if ( *t_Scan == '\\' )
					{
						t_State = 1 ;
					}
					else if ( *t_Scan == 0 )
					{
						t_State = 0x80000000 ;
					}
					else
					{
						t_State = 0x80000000 ;
					}
				}
				break ;

				case 1:
				{
					if ( *t_Scan == '\\' )
					{
						t_State = 2 ;
					}
					else
					{
						t_State = 0xFFFFFFFF ;
					}
				}
				break ;

				case 2:
				{
					t_State = 3 ;
					t_Mark = t_Scan ;
					t_Mark ++ ;
				}
				break ;

				case 3:
				{
					if ( ( *t_Scan == '\\' ) || ( *t_Scan == NULL ) )
					{
						t_State = 0x80000000 ;

						t_Scan = t_Mark ;
					}
				}
				break ;

				case 4:
				{
					if ( *t_Scan == '\\' )
					{
						t_State = 0x80000000 ;
					}
					else if ( *t_Scan == NULL )
					{
						t_State = 0x80000000 ;
					}
				}
				break ;

				case 0x80000000:
				case 0xFFFFFFFF:
				default:
				{
					t_State = 0xFFFFFFFF ;
				}
				break ;
			}

			if ( t_State < 0x80000000 )
			{
				t_Scan ++ ;
			}
		}

		if ( t_State != 0x80000000 )
		{
			delete [] a_FreeString ;
			t_Mark = NULL ;
		}
	}

	return t_Mark ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: IsChild_Namespace (

	wchar_t *a_Left ,
	wchar_t *a_Right
)
{
	HRESULT t_Result = S_OK ;

	wchar_t *t_Free = NULL ;
	wchar_t *t_Right = Strip_Server ( a_Right , t_Free ) ;
	if ( t_Right )
	{
		t_Result = ( _wcsnicmp ( a_Left , t_Right , wcslen ( a_Left ) ) == 0 ) ? S_OK : S_FALSE ;

		delete [] t_Free ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: PostDelete_Namespace (

    long a_Flags ,
    HRESULT hRes,
    IWbemContext *a_Context ,
    IWbemPath *a_Path,
    LPCWSTR a_PathString ,
    LPCWSTR a_Namespace,
    LPCWSTR a_Class,
    IWbemClassObject *a_Old
)
{
	HRESULT t_Result = S_OK ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	LONG t_VarType = 0 ;
	LONG t_Flavour = 0 ;

	t_Result = a_Old->Get ( L"Name" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Variant.vt == VT_BSTR )
		{
			BSTR t_Namespace = NULL ;
			t_Result = WmiHelper :: ConcatenateStrings ( 

				3 ,
				& t_Namespace ,
				a_Namespace , 
				L"\\" ,
				t_Variant.bstrVal
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				wchar_t *t_ToDelete = NULL ;
				wchar_t *t_ToScan = Strip_Server ( t_Namespace , t_ToDelete ) ;
				if ( t_ToScan )
				{
					CWbemGlobal_IWmiFactoryController_Cache *t_Cache = NULL ;
					GetCache ( t_Cache ) ;

					Lock () ;

					if ( t_Cache->Size () )
					{
						IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Cache->Size () ] ;
						if ( t_ShutdownElements )
						{
							CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator = t_Cache->Begin ();

							ULONG t_Count = 0 ;
							while ( ! t_Iterator.Null () )
							{
								CWbemGlobal_IWmiFactoryController_Cache_Iterator t_NextIterator = t_Iterator ;
								t_NextIterator.Increment () ;

								t_Result = IsChild_Namespace ( t_ToScan , t_Iterator.GetKey ().m_Namespace ) ;
								if ( t_Result == S_OK )
								{
									t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;
	
									CWbemGlobal_IWmiFactoryController :: Shutdown ( t_Iterator.GetKey () ) ;
								}

								t_Iterator = t_NextIterator  ;

								t_Count ++ ;
							}

							UnLock () ;

							for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
							{
								if ( t_ShutdownElements [ t_Index ] ) 
								{
									t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

										0 ,
										0 ,
										NULL
									) ;

									t_ShutdownElements [ t_Index ]->Release () ;
								}
							}

							delete [] t_ShutdownElements ;
						}
						else
						{
							UnLock () ;

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						UnLock () ;
					}

					delete [] t_ToDelete ;
				}

				SysFreeString ( t_Namespace ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROPERTY ;
		}

		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: GetDeleteInfo (

	IWbemClassObject *a_OldObject ,
	LPCWSTR a_Class ,
    IWbemPath *a_Path ,
	LPWSTR &a_OutClass ,
	LPWSTR &a_OutStringPath ,
    IWbemPath *&a_OutPathObject
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Class == NULL )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
	
		LONG t_VarType = 0 ;
		LONG t_Flavour = 0 ;

		t_Result = a_OldObject->Get ( L"__Class" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			a_OutClass = new wchar_t [ wcslen ( t_Variant.bstrVal ) + 1 ] ;
			if ( a_OutClass )
			{
				wcscpy ( a_OutClass , t_Variant.bstrVal ) ;
			}					
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			VariantClear ( & t_Variant ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Path == NULL )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			t_Result = a_OldObject->Get ( L"__Path" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				a_OutStringPath = new wchar_t [ wcslen ( t_Variant.bstrVal ) + 1 ] ;
				if ( a_OutStringPath )
				{
					wcscpy ( a_OutStringPath , t_Variant.bstrVal ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = CoCreateInstance (

						CLSID_WbemDefPath ,
						NULL ,
						CLSCTX_INPROC_SERVER ,
						IID_IWbemPath ,
						( void ** )  & a_OutPathObject
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = a_OutPathObject->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_OutStringPath ) ;
					}
				}

				VariantClear ( & t_Variant ) ;
			}
		}
		else
		{
			t_Result = ProviderSubSystem_Common_Globals :: GetPathText (

				a_Path ,
				a_OutStringPath
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: PostDelete (

    long a_Flags ,
    HRESULT hRes,
    IWbemContext *a_Context ,
    IWbemPath *a_Path,
    LPCWSTR a_Namespace,
    LPCWSTR a_Class,
    _IWmiObject *a_Old
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		IWbemClassObject *t_OldObject = NULL ;
		t_Result = a_Old->QueryInterface ( IID_IWbemClassObject , ( void ** ) & t_OldObject ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			QueryPreprocessor :: QuadState t_State = IsA ( t_OldObject  , L"__Namespace" ) ;
			if ( t_State == QueryPreprocessor :: State_Error )
			{
				t_OldObject->Release () ;

				return WBEM_E_OUT_OF_MEMORY ;
			}

			if ( t_State == QueryPreprocessor :: State_True )
			{
				LPWSTR t_Class = NULL ;
				LPWSTR t_Path = NULL ;
				IWbemPath *t_PathObject = NULL ;

				t_Result = GetDeleteInfo (

					t_OldObject ,
					a_Class ,
					a_Path ,
					t_Class ,
					t_Path ,
					t_PathObject
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = PostDelete_Namespace ( 

						a_Flags ,
						hRes,
						a_Context ,
						a_Path ? a_Path : t_PathObject ,
						t_Path ,
						a_Namespace,
						a_Class ? a_Class : t_Class ,
						a_Old
					) ;
				}

				if ( t_Class )
				{
					delete [] t_Class ;
				}

				if ( t_Path )
				{
					delete [] t_Path ;
				}

				if ( t_PathObject )
				{
					t_PathObject->Release () ;
				}
			}
			else
			{
				if ( t_State == QueryPreprocessor :: State_False )
				{
					t_State = IsA ( t_OldObject  , L"__EventProviderRegistration" ) ;
					if ( t_State == QueryPreprocessor :: State_Error )
					{
						return WBEM_E_OUT_OF_MEMORY ;
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_OldObject  , L"__EventProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							return WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_OldObject  , L"__EventConsumerProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							return WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_OldObject  , L"__InstanceProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							return WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_OldObject  , L"__MethodProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							return WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_OldObject  , L"__PropertyProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							return WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( t_State == QueryPreprocessor :: State_False )
					{
						t_State = IsA ( t_OldObject  , L"__ClassProviderRegistration" ) ;
						if ( t_State == QueryPreprocessor :: State_Error )
						{
							return WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( t_State == QueryPreprocessor :: State_True )
					{
						LPWSTR t_Class = NULL ;
						LPWSTR t_Path = NULL ;
						IWbemPath *t_PathObject = NULL ;

						t_Result = GetDeleteInfo (

							t_OldObject ,
							a_Class ,
							a_Path ,
							t_Class ,
							t_Path ,
							t_PathObject
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = PostDelete_ProviderRegistration ( 

								a_Flags ,
								hRes,
								a_Context ,
								a_Path ? a_Path : t_PathObject ,
								t_Path ,
								a_Namespace,
								a_Class ? a_Class : t_Class ,
								a_Old
							) ;
						}

						if ( t_Class )
						{
							delete [] t_Class ;
						}

						if ( t_Path )
						{
							delete [] t_Path ;
						}

						if ( t_PathObject )
						{
							t_PathObject->Release () ;
						}
					}
				}
			}

			t_OldObject->Release () ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Initialize (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	_IWmiCoreServices *a_Core
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		if ( a_Core )
		{
			m_Core = a_Core ;
			m_Core->AddRef () ;
		}

		WmiStatusCode t_StatusCode = CWbemGlobal_IWmiFactoryController :: Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				_IWmiCoreWriteHook *t_ThisHook = NULL ;
				t_Result = this->QueryInterface ( IID_CWbemSubSystemHook , ( void ** ) & t_ThisHook ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = m_Core->RegisterWriteHook (

						WBEM_FLAG_INST_PUT|WBEM_FLAG_INST_DELETE ,
						t_ThisHook
					) ;

					t_ThisHook->Release () ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			ProviderSubSystem_Globals :: s_DecoupledRegistrar = new CDecoupled_ProviderSubsystemRegistrar ( *ProviderSubSystem_Globals :: s_Allocator  , this ) ;
			if ( ProviderSubSystem_Globals :: s_DecoupledRegistrar )
			{
				ProviderSubSystem_Globals :: s_DecoupledRegistrar->AddRef () ;

				t_Result = ProviderSubSystem_Globals :: s_DecoupledRegistrar->Save () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}


		if ( SUCCEEDED ( t_Result ) )
		{
			m_SinkController = new CWbemGlobal_VoidPointerController ( 

				m_Allocator 
			)  ;

			if ( m_SinkController ) 
			{
				m_SinkController->AddRef () ;

				WmiStatusCode t_StatusCode = m_SinkController->CWbemGlobal_VoidPointerController :: Initialize () ;
				if ( t_StatusCode != e_StatusCode_Success ) 
				{
					m_SinkController->Release () ;
					m_SinkController = NULL ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderSubSystem :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
#ifndef STRUCTURED_HANDLER_SET_BY_WMI
	Wmi_SetStructuredExceptionHandler t_StructuredException ;
#endif

	HRESULT t_Result = S_OK ;

	try
	{
		if ( m_Core ) 
		{
			_IWmiCoreWriteHook *t_ThisHook = NULL ;
			t_Result = this->QueryInterface ( IID_CWbemSubSystemHook , ( void ** ) & t_ThisHook ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = m_Core->UnregisterWriteHook (

					t_ThisHook
				) ;

				t_ThisHook->Release () ;
			}
		}

		Lock () ;

		CWbemGlobal_IWmiFactoryController_Cache *t_Cache = NULL ;
		GetCache ( t_Cache ) ;

		if ( t_Cache->Size () )
		{
			IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Cache->Size () ] ;
			if ( t_ShutdownElements )
			{
				CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator = t_Cache->Begin ();

				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ShutdownElements [ t_Index ] )
					{
						t_Result = t_ShutdownElements [ t_Index ]->Shutdown (

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;

						t_ShutdownElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ShutdownElements ;
			}
			else
			{
				UnLock () ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else	
		{
			UnLock () ;
		}

		CWbemGlobal_IWmiFactoryController :: Shutdown () ;

		if ( ProviderSubSystem_Globals :: s_DecoupledRegistrar )
		{
			t_Result = ProviderSubSystem_Globals :: s_DecoupledRegistrar->Delete () ;

			ProviderSubSystem_Globals :: s_DecoupledRegistrar->Release () ;
			ProviderSubSystem_Globals :: s_DecoupledRegistrar = NULL ;
		}
	}
	catch ( Wmi_Structured_Exception t_StructuredException )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;	/* Need to make this WBEM_E_SUBSYSTEM_FAILURE */
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CServerObject_ProviderSubSystem :: Strobe ( ULONG &a_NextStrobeDelta )
{
	Lock () ;

	CWbemGlobal_IWmiFactoryController_Cache *t_Cache = NULL ;
	GetCache ( t_Cache ) ;

	if ( t_Cache->Size () )
	{
		CWbemGlobal_IWmiFactoryController_Cache_Iterator t_Iterator = t_Cache->Begin ();

		CServerObject_StrobeInterface **t_ControllerElements = new CServerObject_StrobeInterface * [ t_Cache->Size () ] ;
		if ( t_ControllerElements )
		{
			ULONG t_Count = 0 ;
			while ( ! t_Iterator.Null () )
			{
				HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_CWbemGlobal_IWmiProviderController , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

				t_Iterator.Increment () ;

				t_Count ++ ;
			}

			UnLock () ;

			for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
			{
				if ( t_ControllerElements [ t_Index ] )
				{
					HRESULT t_Result = t_ControllerElements [ t_Index ]->Strobe ( a_NextStrobeDelta ) ;

					t_ControllerElements [ t_Index ]->Release () ;
				}
			}

			delete [] t_ControllerElements ;
		}
		else
		{
			UnLock () ;
		}
	}
	else
	{
		UnLock () ;
	}

	return CWbemGlobal_IWmiFactoryController :: Strobe ( a_NextStrobeDelta ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CServerObject_ProviderSubSystem :: StrobeBegin ( const ULONG &a_Period )
{
	ULONG t_Timeout = ProviderSubSystem_Globals :: GetStrobeThread ().GetTimeout () ;
	ProviderSubSystem_Globals :: GetStrobeThread ().SetTimeout ( t_Timeout < a_Period ? t_Timeout : a_Period ) ;

	return e_StatusCode_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\sources.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

WMIUNICODE=1
WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETPATH=obj
	
C_DEFINES=$(C_DEFINES) /D_WIN32_DCOM
USE_NATIVE_EH=ASYNC
USE_RTTI=1
USE_MSVCRT=1
USE_VCCOM=1

# The TARGETLIBS macro specifies additional libraries to link against your target
# image. Each library path specification should contain an asterisk (*)
# where the machine-specific subdirectory name should go.
TARGETLIBS= \
	$(SDK_LIB_PATH)\ntdll.lib \
	$(WBEMINT_LIB) \
	$(WMIIDL_LIB) \
	$(WBEMCOMN_DLL_LIB) \
	$(COREPROX_LIB) \
	$(STDLIBRARY_LIB) \
	$(NCOBJAPI_LIB) \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\rpcrt4.lib \
	$(SDK_LIB_PATH)\uuid.lib

LINKLIBS= \
	$(WBEMPRV_COMN_LIB)\

# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	$(CONTAINER_INC); \
	$(CONTAINER_SRC); \
	$(NC_COMMON); \
	$(WBEMINT_INC);\
	$(WMIREPOSITIDL_INC); \
	$(WBEMCORE_INC); \
	$(MC_INC); \
	$(STDLIBRARY_INC); \
	$(COREPROX_INC); \
	$(WBEMCOMN_INC); \
	$(WBEMPRV_COMN_INC);\
	$(WBEMPSSSERVER_INC); \

SOURCES=$(XSOURCES) \
	..\Globals.cpp \
	..\maindll.cpp \
	..\ProvHost.cpp \
	..\ProvSubS.cpp \
	..\ProvFact.cpp \
	..\ProvCntrs.cpp \
	..\ProvSelf.cpp \
	..\ProvDWsv.cpp \
	..\ProvWsv.cpp \
	..\ProvWsvS.cpp \
	..\ProvsWsv.cpp \
	..\ProvObSk.cpp \
	..\ProvInSk.cpp \
	..\ProvAggr.cpp \
	..\ProvLoad.cpp \
	..\StaThread.cpp \
	..\StaTask.cpp \
	..\ProvResv.cpp \
	..\StrobeThread.cpp \
	..\ProvCache.cpp \
	..\ProvRMgr.cpp \
	..\ProvDcAggr.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provwsv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"

#include <wbemint.h>
#include <stdio.h>
#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvSubs.h"
#include "ProvFact.h"
#include "ProvObSk.h"
#include "ProvInSk.h"
#include "ProvWsv.h"
#include "ProvCache.h"

#include "arrtempl.h"

#include "Guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemUnboundObjectSink :: CInterceptor_IWbemUnboundObjectSink (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) :	VoidPointerContainerElement (

		a_Controller ,
		this 
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Controller ( NULL ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_Internal_IWbemUnboundObjectSink ( NULL ) ,
	m_Registration ( & a_Registration ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_UnBound_Size , MAX_PROXIES ) ,
	m_InitializeResult ( S_OK ) ,
	m_ProcessIdentifier ( 0 ) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemUnboundObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
	
	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	m_InitializeResult = a_Controller->QueryInterface ( IID__IWmiProviderAbnormalShutdown , ( void ** ) & m_Controller ) ;
	if ( SUCCEEDED ( m_InitializeResult ) )
	{
		if ( a_ServerSideProvider ) 
		{
			m_Unknown = a_ServerSideProvider ;
			m_Unknown->AddRef () ;

			m_InitializeResult = a_ServerSideProvider->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
			if ( SUCCEEDED ( m_InitializeResult ) )
			{
				m_InitializeResult  = a_ServerSideProvider->QueryInterface ( IID_Internal_IWbemUnboundObjectSink , ( void ** ) & m_Provider_Internal_IWbemUnboundObjectSink ) ;
			}
		}
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemUnboundObjectSink :: ~CInterceptor_IWbemUnboundObjectSink ()
{
	if ( m_Controller )
	{
		m_Controller->Release () ;
	}

	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Provider_Internal_IWbemUnboundObjectSink )
	{
		m_Provider_Internal_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemUnboundObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemUnboundObjectSink :: Initialize ()
{
	if ( SUCCEEDED ( m_InitializeResult ) )
	{
		WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			m_InitializeResult = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( m_InitializeResult ) )
	{
		_IWmiProviderSite *t_Site = NULL ;
		m_InitializeResult = m_Unknown->QueryInterface ( IID__IWmiProviderSite , ( void ** ) & t_Site ) ;
		if ( SUCCEEDED ( m_InitializeResult ) )
		{
			m_InitializeResult = t_Site->GetSite ( & m_ProcessIdentifier ) ;
			t_Site->Release () ;
		}
	}

	return m_InitializeResult ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemUnboundObjectSink :: AddRef ()
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemUnboundObjectSink :: Release ()
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemUnboundObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemUnboundObjectSink :: Begin_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	DWORD t_AuthenticationLevel = 0 ;

	t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating , & t_AuthenticationLevel ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_ProcessIdentifier )
		{
			t_Result = CoImpersonateClient () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				CoRevertToSelf () ;

				if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
					
						m_ProxyContainer , 
						a_ProxyIndex , 
						a_InterfaceIdentifier , 
						a_ServerInterface , 
						a_Proxy , 
						a_Revert
					) ;
				}
				else
				{
					switch ( m_Registration->GetHosting () )
					{
						case e_Hosting_SharedLocalSystemHost:
						case e_Hosting_SharedLocalSystemHostOrSelfHost:
						{
							t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
							
								m_ProxyContainer , 
								a_InternalProxyIndex , 
								a_InterfaceIdentifier , 
								a_InternalServerInterface , 
								a_Proxy , 
								a_Revert , 
								a_ProcessIdentifier , 
								a_IdentifyToken ,
								ProviderSubSystem_Common_Globals :: s_Token_All_Access_System_ACE ,
								ProviderSubSystem_Common_Globals :: s_System_ACESize
							) ;
						}
						break ;

						case e_Hosting_SharedLocalServiceHost:
						{
							t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
							
								m_ProxyContainer , 
								a_InternalProxyIndex , 
								a_InterfaceIdentifier , 
								a_InternalServerInterface , 
								a_Proxy , 
								a_Revert , 
								a_ProcessIdentifier , 
								a_IdentifyToken ,
								ProviderSubSystem_Common_Globals :: s_Token_All_Access_LocalService_ACE ,
								ProviderSubSystem_Common_Globals :: s_LocalService_ACESize
							) ;
						}
						break ;

						case e_Hosting_SharedNetworkServiceHost:
						{
							t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
							
								m_ProxyContainer , 
								a_InternalProxyIndex , 
								a_InterfaceIdentifier , 
								a_InternalServerInterface , 
								a_Proxy , 
								a_Revert , 
								a_ProcessIdentifier , 
								a_IdentifyToken ,
								ProviderSubSystem_Common_Globals :: s_Token_All_Access_NetworkService_ACE ,
								ProviderSubSystem_Common_Globals :: s_NetworkService_ACESize
	 						) ;
						}
						break ;

						default:
						{
							t_Result = WBEM_E_UNEXPECTED ;
						}
						break ;
					}
				}
			}
		}
		else
		{
			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
			
				m_ProxyContainer , 
				a_ProxyIndex , 
				a_InterfaceIdentifier , 
				a_ServerInterface , 
				a_Proxy , 
				a_Revert
			) ;
		}

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = a_ServerInterface ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IUnknown * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( a_Context )
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;
						t_Variant.lVal = t_AuthenticationLevel ;
						t_Variant.vt = VT_I4 ;

						
						t_Result = a_Context->SetValue ( L"__WBEM_CLIENT_AUTHENTICATION_LEVEL" , 0, & t_Variant ) ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					if ( a_IdentifyToken )
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 

							m_ProxyContainer , 
							a_InternalProxyIndex , 
							a_Proxy , 
							a_Revert ,
							a_ProcessIdentifier , 
							a_IdentifyToken 
						) ;
					}
					else
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

							m_ProxyContainer , 
							a_ProxyIndex , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemUnboundObjectSink :: End_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 

				m_ProxyContainer , 
				a_InternalProxyIndex , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier ,
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				a_ProxyIndex , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemUnboundObjectSink :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemUnboundObjectSink ;
		REFIID t_InterfaceIdentifier = IID_IWbemUnboundObjectSink ;
		DWORD t_ProxyIndex = ProxyIndex_UnBound_IWbemUnboundObjectSink ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemUnboundObjectSink ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemUnboundObjectSink ;
		DWORD t_InternalProxyIndex = ProxyIndex_UnBound_Internal_IWbemUnboundObjectSink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = m_ProcessIdentifier ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemUnboundObjectSink * ) t_Interface )->Internal_IndicateToConsumer (

					t_InternalContext ,
					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else
			{

				t_Result = ( ( IWbemUnboundObjectSink * ) t_Interface )->IndicateToConsumer (

					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				if ( m_Controller )
				{
					m_Controller->AbnormalShutdown () ;
				}
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemUnboundObjectSink :: Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

InternalQuotaInterface :: InternalQuotaInterface ( CInterceptor_IWbemProvider *a_Owner ) : m_Owner ( NULL ) , m_ReferenceCount ( 0 )
{
	a_Owner->QueryInterface ( IID__IWmiProviderQuota , ( void ** ) & m_Owner ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

InternalQuotaInterface :: ~InternalQuotaInterface ()
{
	if ( m_Owner )
	{
		m_Owner->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT InternalQuotaInterface :: Initialize ()
{
	return m_Owner ? S_OK : WBEM_E_CRITICAL_ERROR ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP InternalQuotaInterface :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiProviderQuota )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderQuota * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) InternalQuotaInterface :: AddRef ( void )
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) InternalQuotaInterface :: Release ( void )
{
	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT InternalQuotaInterface :: Violation (

	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemClassObject *a_Object	
)
{
	return m_Owner->Violation (

		a_Flags ,
		a_Context ,
		a_Object	
	) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemProvider :: CInterceptor_IWbemProvider (

	WmiAllocator &a_Allocator ,
	CWbemGlobal_IWmiProviderController *a_Controller ,
	const ProviderCacheKey &a_Key ,
	const ULONG &a_Period ,
	IWbemContext *a_InitializationContext ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) : CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	ServiceCacheElement ( 

		a_Controller ,
		a_Key ,
		a_Period 
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Unknown ( NULL ) ,
	m_Registration ( & a_Registration ) ,
	m_Host ( NULL ) ,
	m_Quota ( NULL ) ,
	m_Internal ( this ) ,
	m_User ( NULL ) ,
	m_Locale ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Provider_IWbemServices ( NULL ) ,
	m_Provider_IWbemPropertyProvider ( NULL ) ,
	m_Provider_IWbemHiPerfProvider ( NULL ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_Internal_IWbemServices ( NULL ) ,
	m_Provider_Internal_IWbemPropertyProvider ( NULL ) ,
	m_Provider_Internal_IWbemEventProvider ( NULL ) ,
	m_Provider_Internal_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_Internal_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_Internal_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_Internal_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_Internal_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_Internal_IWmiProviderConfiguration ( NULL ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_Provider_Size , MAX_PROXIES ) ,
	m_ProcessIdentifier ( 0 ) ,
	m_Resumed ( 1 ) ,
	m_UnInitialized ( 0 ) ,
	m_Initialized ( 0 ) ,
	m_InitializeResult ( S_OK ) ,
	m_InitializedEvent ( NULL ) , 
	m_InitializationContext ( a_InitializationContext )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_InitializationContext )
	{
		m_InitializationContext->AddRef () ;
	}

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemProvider :: ~CInterceptor_IWbemProvider ()
{
#if 0
wchar_t t_Buffer [ 128 ] ;
wsprintf ( t_Buffer , L"\n%lx - ~CInterceptor_IWbemProvider ( %lx ) " , GetTickCount () , this ) ;
OutputDebugString ( t_Buffer ) ;
#endif

	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	if ( m_InitializationContext )
	{
		m_InitializationContext->Release () ;
	}

	if ( m_InitializedEvent )
	{
		CloseHandle ( m_InitializedEvent ) ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_Core ,         // For anybody
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}
	
	if ( SUCCEEDED ( t_Result ) )
	{
		t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_InitializedEvent = CreateEvent ( NULL , TRUE , FALSE , NULL ) ;
		if ( m_InitializedEvent == NULL )
		{
			t_Result = t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_Quota = new InternalQuotaInterface ( this ) ;
		if ( m_Quota )
		{
			m_Quota->AddRef () ;
			t_Result = m_Quota->Initialize () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = m_InitializeResult ;
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: SetProvider ( _IWmiProviderHost *a_Host , IUnknown *a_Unknown )
{
	if ( a_Host )
	{
		m_Host = a_Host ;
		m_Host->AddRef () ;

		HRESULT t_Result = m_Host->GetProcessIdentifier ( & m_ProcessIdentifier ) ;
		if ( FAILED ( t_Result ) )
		{
			m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}
	else
	{
		m_ProcessIdentifier = GetCurrentProcessId ();
	}

	m_Unknown = a_Unknown ;
	m_Unknown->AddRef () ;

	HRESULT t_TempResult = m_Unknown->QueryInterface ( IID_IWbemServices , ( void ** ) & m_Provider_IWbemServices ) ;
	if ( SUCCEEDED ( t_TempResult ) )
	{
		t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemServices , ( void ** ) & m_Provider_Internal_IWbemServices ) ;
		if ( FAILED ( t_TempResult ) )
		{
			m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	t_TempResult = m_Unknown->QueryInterface ( IID_IWbemPropertyProvider , ( void ** ) & m_Provider_IWbemPropertyProvider ) ;
	if ( SUCCEEDED ( t_TempResult ) )
	{
		t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemPropertyProvider , ( void ** ) & m_Provider_Internal_IWbemPropertyProvider ) ;
		if ( FAILED ( t_TempResult ) )
		{
			m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	t_TempResult = m_Unknown->QueryInterface ( IID_IWbemHiPerfProvider , ( void ** ) & m_Provider_IWbemHiPerfProvider ) ;

	t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
	if ( SUCCEEDED ( t_TempResult ) )
	{
		t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventProvider , ( void ** ) & m_Provider_Internal_IWbemEventProvider ) ;
		if ( FAILED ( t_TempResult ) )
		{
			m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;
	if ( SUCCEEDED ( t_TempResult ) )
	{
		t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_Internal_IWbemEventProviderQuerySink ) ;
		if ( FAILED ( t_TempResult ) )
		{
			m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
	if ( SUCCEEDED ( t_TempResult ) )
	{
		t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventProviderSecurity , ( void ** ) & m_Provider_Internal_IWbemEventProviderSecurity ) ;
		if ( FAILED ( t_TempResult ) )
		{
			m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	t_TempResult = m_Unknown->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
	if ( SUCCEEDED ( t_TempResult ) )
	{
		t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemUnboundObjectSink , ( void ** ) & m_Provider_Internal_IWbemUnboundObjectSink ) ;
		if ( FAILED ( t_TempResult ) )
		{
			m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
	if ( SUCCEEDED ( t_TempResult ) )
	{
		t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventConsumerProvider , ( void ** ) & m_Provider_Internal_IWbemEventConsumerProvider ) ;
		if ( FAILED ( t_TempResult ) )
		{
			m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_IWbemEventConsumerProviderEx ) ;
	if ( SUCCEEDED ( t_TempResult ) )
	{
		t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_Internal_IWbemEventConsumerProviderEx ) ;
		if ( FAILED ( t_TempResult ) )
		{
			m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	t_TempResult = m_Unknown->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & m_Provider__IWmiProviderConfiguration ) ;
	if ( FAILED ( t_TempResult ) )
	{
		m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
	}

	t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWmiProviderConfiguration , ( void ** ) & m_Provider_Internal_IWmiProviderConfiguration ) ;
	if ( FAILED ( t_TempResult ) )
	{
		m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
	}

	return m_InitializeResult ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: DownLevel (

	long a_Flags ,
	IWbemContext *a_Context ,
	REFIID a_Riid,
	void **a_Interface
)
{
	return m_Unknown->QueryInterface ( a_Riid , a_Interface ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: SetInitialized ( HRESULT a_InitializeResult )
{
	m_InitializeResult = a_InitializeResult ;

	InterlockedExchange ( & m_Initialized , 1 ) ;

	if ( m_InitializedEvent )
	{
		SetEvent ( m_InitializedEvent ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: IsIndependant ( IWbemContext *a_Context )
{
	BOOL t_DependantCall = FALSE ;
	HRESULT t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_DependantCall == FALSE )
		{
		}
		else
		{
			return S_FALSE ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout )
{
	HRESULT t_Result = WBEM_E_UNEXPECTED ;

	if ( m_Initialized == 0 )
	{
		BOOL t_DependantCall = FALSE ;
		t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_DependantCall == FALSE )
			{
				if ( WaitForSingleObject ( m_InitializedEvent , a_Timeout ) == WAIT_TIMEOUT )
				{
					return WBEM_E_PROVIDER_LOAD_FAILURE ;
				}
			}
			else
			{
				if ( WaitForSingleObject ( m_InitializedEvent , 0 ) == WAIT_TIMEOUT )
				{
					return S_FALSE ;
				}
			}
		}
	}
	else
	{
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemProvider :: AddRef ( void )
{
	return ServiceCacheElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemProvider :: Release ( void )
{
	return ServiceCacheElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_IWbemProvider :: CallBackInternalRelease ()
{
	if ( InterlockedCompareExchange ( & m_UnInitialized ,  1 , 0 ) == 0 )
	{
		WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

		CWbemGlobal_HostedProviderController *t_Controller = ProviderSubSystem_Globals :: GetHostedProviderController () ;
		CWbemGlobal_HostedProviderController_Container_Iterator t_Iterator ;

		t_Controller->Lock () ;

		t_StatusCode = t_Controller->Find ( m_ProcessIdentifier , t_Iterator ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			ProviderController *t_ProviderController = NULL ;
			HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_ProviderController , ( void ** ) & t_ProviderController ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_StatusCode = t_ProviderController->Delete ( this ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					NonCyclicRelease () ;
				}

				t_ProviderController->Release () ;
			}
		}

		t_Controller->UnLock () ;

		if ( m_Host )
		{
			m_Host->Release () ;
		}

		if ( m_Quota )
		{
			m_Quota->Release () ;
		}

		if ( m_Unknown )
		{
			m_Unknown->Release () ;
		}

		if ( m_Provider_IWbemServices )
		{
			m_Provider_IWbemServices->Release () ; 
		}

		if ( m_Provider_IWbemPropertyProvider )
		{
			m_Provider_IWbemPropertyProvider->Release () ; 
		}

		if ( m_Provider_IWbemHiPerfProvider )
		{
			m_Provider_IWbemHiPerfProvider->Release () ;
		}

		if ( m_Provider_IWbemEventProvider )
		{
			m_Provider_IWbemEventProvider->Release () ;
		}

		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			m_Provider_IWbemEventProviderQuerySink->Release () ;
		}

		if ( m_Provider_IWbemEventProviderSecurity )
		{
			m_Provider_IWbemEventProviderSecurity->Release () ;
		}

		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			m_Provider_IWbemEventConsumerProviderEx->Release () ;
		}

		if ( m_Provider_IWbemEventConsumerProvider )
		{
			m_Provider_IWbemEventConsumerProvider->Release () ;
		}

		if ( m_Provider__IWmiProviderConfiguration )
		{
			m_Provider__IWmiProviderConfiguration->Release () ;
		}

		if ( m_Provider_IWbemUnboundObjectSink )
		{
			m_Provider_IWbemUnboundObjectSink->Release () ;
		}

		if ( m_Provider_Internal_IWbemServices )
		{
			m_Provider_Internal_IWbemServices->Release () ;
		}

		if ( m_Provider_Internal_IWbemPropertyProvider )
		{
			m_Provider_Internal_IWbemPropertyProvider->Release () ;
		}

		if ( m_Provider_Internal_IWbemEventProvider )
		{
			m_Provider_Internal_IWbemEventProvider->Release () ;
		}

		if ( m_Provider_Internal_IWbemEventProviderQuerySink )
		{
			m_Provider_Internal_IWbemEventProviderQuerySink->Release () ;
		}

		if ( m_Provider_Internal_IWbemEventProviderSecurity )
		{
			m_Provider_Internal_IWbemEventProviderSecurity->Release () ;
		}

		if ( m_Provider_Internal_IWbemEventConsumerProvider )
		{
			m_Provider_Internal_IWbemEventConsumerProvider->Release () ;
		}

		if ( m_Provider_Internal_IWbemEventConsumerProviderEx )
		{
			m_Provider_Internal_IWbemEventConsumerProviderEx->Release () ;
		}

		if ( m_Provider_Internal_IWbemUnboundObjectSink )
		{
			m_Provider_Internal_IWbemUnboundObjectSink->Release () ;
		}

		if ( m_Provider_Internal_IWmiProviderConfiguration )
		{
			m_Provider_Internal_IWmiProviderConfiguration->Release () ;
		}

		SetEvent ( ProviderSubSystem_Globals :: s_CoFreeUnusedLibrariesEvent ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( m_Initialized == 0 )
	{
		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) this ;
		}
		else if ( iid == IID_IWbemServices )
		{
			*iplpv = ( LPVOID ) ( IWbemServices * ) this ;
		}	
		else if ( iid == IID_IWbemPropertyProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemPropertyProvider * ) this ;
		}
		else if ( iid == IID_IWbemHiPerfProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemHiPerfProvider * ) this ;
		}
		else if ( iid == IID_IWbemEventProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProvider * ) this ;
		}
		else if ( iid == IID_IWbemEventProviderQuerySink )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
		}
		else if ( iid == IID_IWbemEventProviderSecurity )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
		}
		else if ( iid == IID_IWbemEventConsumerProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
		}
		else if ( iid == IID_IWbemEventConsumerProviderEx )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
		}
		else if ( iid == IID_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
		else if ( iid == IID_IWbemProviderInit )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
		}	
		else if ( iid == IID__IWmiProviderInitialize )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderInitialize * ) this ;		
		}	
		else if ( iid == IID_IWbemShutdown )
		{
			*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;
		}
		else if ( iid == IID__IWmiProviderLoad )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderLoad * )this ;		
		}	
		else if ( iid == IID__IWmiProviderConfiguration )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderConfiguration * ) this ;
		}	
		else if ( iid == IID__IWmiProviderQuota )
		{
			*iplpv = ( LPVOID ) & ( this->m_Internal ) ;
		}	
		else if ( iid == IID__IWmiProviderStack )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderStack * ) this ;
		}	
		else if ( iid == IID__IWmiProviderCache )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderCache * ) this ;
		}	
		else if ( iid == IID_CWbemGlobal_IWmiObjectSinkController )
		{
			*iplpv = ( LPVOID ) ( CWbemGlobal_IWmiObjectSinkController * ) this ;
		}	
		else if ( iid == IID_CInterceptor_IWbemProvider )
		{
			*iplpv = ( LPVOID ) ( CInterceptor_IWbemProvider * ) this ;
		}	
	}
	else
	{
		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) this ;
		}
		else if ( iid == IID_IWbemServices )
		{
			if ( m_Provider_IWbemServices )
			{
				*iplpv = ( LPVOID ) ( IWbemServices * ) this ;
			}
		}	
		else if ( iid == IID_IWbemPropertyProvider )
		{
			if ( m_Provider_IWbemPropertyProvider )
			{
				*iplpv = ( LPVOID ) ( IWbemPropertyProvider * ) this ;
			}
		}
		else if ( iid == IID_IWbemHiPerfProvider )
		{
			if ( m_Provider_IWbemHiPerfProvider )
			{
				*iplpv = ( LPVOID ) ( IWbemHiPerfProvider * ) this ;
			}
		}
		else if ( iid == IID_IWbemEventProvider )
		{
			if ( m_Provider_IWbemEventProvider )
			{
				*iplpv = ( LPVOID ) ( IWbemEventProvider * ) this ;
			}
		}
		else if ( iid == IID_IWbemEventProviderQuerySink )
		{
			if ( m_Provider_IWbemEventProviderQuerySink )
			{
				*iplpv = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
			}
		}
		else if ( iid == IID_IWbemEventProviderSecurity )
		{
			if ( m_Provider_IWbemEventProviderSecurity )
			{
				*iplpv = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
			}
		}
		else if ( iid == IID_IWbemEventConsumerProvider )
		{
			if ( m_Provider_IWbemEventConsumerProvider )
			{
				*iplpv = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
			}
		}
		else if ( iid == IID_IWbemEventConsumerProviderEx )
		{
			if ( m_Provider_IWbemEventConsumerProviderEx )
			{
				*iplpv = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
			}
		}
		else if ( iid == IID_IWbemUnboundObjectSink )
		{
			if ( m_Provider_IWbemUnboundObjectSink )
			{
				*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
			}
		}
		else if ( iid == IID_IWbemProviderInit )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
		}	
		else if ( iid == IID__IWmiProviderInitialize )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderInitialize * ) this ;		
		}	
		else if ( iid == IID_IWbemShutdown )
		{
			*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;
		}	
		else if ( iid == IID__IWmiProviderLoad )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderLoad * )this ;		
		}	
		else if ( iid == IID__IWmiProviderConfiguration )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderConfiguration * ) this ;
		}	
		else if ( iid == IID__IWmiProviderQuota )
		{
			*iplpv = ( LPVOID ) & ( this->m_Internal ) ;
		}	
		else if ( iid == IID__IWmiProviderStack )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderStack * ) this ;
		}	
		else if ( iid == IID__IWmiProviderCache )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderCache * ) this ;
		}	
		else if ( iid == IID__IWmiProviderAbnormalShutdown )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderAbnormalShutdown * ) this ;
		}	
		else if ( iid == IID_CWbemGlobal_IWmiObjectSinkController )
		{
			*iplpv = ( LPVOID ) ( CWbemGlobal_IWmiObjectSinkController * ) this ;
		}	
		else if ( iid == IID_CInterceptor_IWbemProvider )
		{
			*iplpv = ( LPVOID ) ( CInterceptor_IWbemProvider * ) this ;
		}	
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Begin_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_WmiCoreOrSelfHost:
		case e_Hosting_SelfHost:
		{
			a_Interface = a_ServerInterface ;
			a_IsProxy = FALSE ;
		}
		break ;

		default:
		{
			DWORD t_AuthenticationLevel = 0 ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating , & t_AuthenticationLevel ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				if ( a_ProcessIdentifier )
				{
					t_Result = CoImpersonateClient () ;
					if ( SUCCEEDED ( t_Result ) )
					{
						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						CoRevertToSelf () ;

						if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
						{
							t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
							
								m_ProxyContainer , 
								a_ProxyIndex , 
								a_InterfaceIdentifier , 
								a_ServerInterface , 
								a_Proxy , 
								a_Revert
							) ;
						}
						else
						{
							switch ( m_Registration->GetHosting () )
							{
								case e_Hosting_SharedLocalSystemHost:
								case e_Hosting_SharedLocalSystemHostOrSelfHost:
								{
									t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
									
										m_ProxyContainer , 
										a_InternalProxyIndex , 
										a_InterfaceIdentifier , 
										a_InternalServerInterface , 
										a_Proxy , 
										a_Revert , 
										a_ProcessIdentifier , 
										a_IdentifyToken ,
										ProviderSubSystem_Common_Globals :: s_Token_All_Access_System_ACE ,
										ProviderSubSystem_Common_Globals :: s_System_ACESize
									) ;
								}
								break ;

								case e_Hosting_SharedLocalServiceHost:
								{
									t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
									
										m_ProxyContainer , 
										a_InternalProxyIndex , 
										a_InterfaceIdentifier , 
										a_InternalServerInterface , 
										a_Proxy , 
										a_Revert , 
										a_ProcessIdentifier , 
										a_IdentifyToken ,
										ProviderSubSystem_Common_Globals :: s_Token_All_Access_LocalService_ACE ,
										ProviderSubSystem_Common_Globals :: s_LocalService_ACESize
									) ;
								}
								break ;

								case e_Hosting_SharedNetworkServiceHost:
								{
									t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
									
										m_ProxyContainer , 
										a_InternalProxyIndex , 
										a_InterfaceIdentifier , 
										a_InternalServerInterface , 
										a_Proxy , 
										a_Revert , 
										a_ProcessIdentifier , 
										a_IdentifyToken ,
										ProviderSubSystem_Common_Globals :: s_Token_All_Access_NetworkService_ACE ,
										ProviderSubSystem_Common_Globals :: s_NetworkService_ACESize
	 								) ;
								}
								break ;

								default:
								{
									t_Result = WBEM_E_UNEXPECTED ;
								}
								break ;
							}
						}
					}
				}
				else
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
					
						m_ProxyContainer , 
						a_ProxyIndex , 
						a_InterfaceIdentifier , 
						a_ServerInterface , 
						a_Proxy , 
						a_Revert
					) ;
				}

				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					a_Interface = a_ServerInterface ;
					a_IsProxy = FALSE ;
					t_Result = S_OK ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						a_IsProxy = TRUE ;

						a_Interface = ( IUnknown * ) a_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							a_Interface ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( a_Context )
							{
								VARIANT t_Variant ;
								VariantInit ( & t_Variant ) ;
								t_Variant.lVal = t_AuthenticationLevel ;
								t_Variant.vt = VT_I4 ;

								
								t_Result = a_Context->SetValue ( L"__WBEM_CLIENT_AUTHENTICATION_LEVEL" , 0, & t_Variant ) ;
							}
						}

						if ( FAILED ( t_Result ) )
						{
							if ( a_IdentifyToken )
							{
								HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 

									m_ProxyContainer , 
									a_InternalProxyIndex , 
									a_Proxy , 
									a_Revert ,
									a_ProcessIdentifier , 
									a_IdentifyToken 
								) ;
							}
							else
							{
								HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

									m_ProxyContainer , 
									a_ProxyIndex , 
									a_Proxy , 
									a_Revert
								) ;
							}
						}
					}
				}

				if ( FAILED ( t_Result ) )
				{
					ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
				}
			}
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: End_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 

				m_ProxyContainer , 
				a_InternalProxyIndex , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier ,
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				a_ProxyIndex , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_WmiCoreOrSelfHost:
		case e_Hosting_SelfHost:
		{
		}
		break ;

		default:
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
		break ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

			Lock () ;

			WmiStatusCode t_StatusCode = Find ( 

				a_Sink ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				ObjectSinkContainerElement *t_Element = t_Iterator.GetElement () ;

				UnLock () ;

				IWbemObjectSink *t_ObjectSink = NULL ;
				t_Result = t_Element->QueryInterface ( IID_IWbemObjectSink , ( void ** ) & t_ObjectSink ) ;
				if ( SUCCEEDED ( t_Result ) )
				{ 
					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							WmiInternalContext t_InternalContext ;
							t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
							t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

							t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CancelAsyncCall (

								t_InternalContext ,
								t_ObjectSink
							) ;
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->CancelAsyncCall (

								t_ObjectSink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}

					t_ObjectSink->Release () ;
				}

				IWbemShutdown *t_Shutdown = NULL ;
				HRESULT t_TempResult = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
				if ( SUCCEEDED ( t_TempResult ) )
				{
					t_TempResult = t_Shutdown->Shutdown ( 

						0 , 
						0 , 
						NULL 
					) ;

					t_Shutdown->Release () ;
				}

				t_Element->Release () ;
			}
			else
			{
				UnLock () ;

				t_Result = WBEM_E_NOT_FOUND ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

		return WBEM_E_NOT_FOUND ;
	}

	BOOL t_DependantCall = FALSE ;

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
						REFIID t_InterfaceIdentifier = IID_IWbemServices ;
						DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
						IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
						REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
						DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
						BOOL t_Impersonating ;
						IUnknown *t_OldContext ;
						IServerSecurity *t_OldSecurity ;
						BOOL t_IsProxy ;
						IUnknown *t_Interface ;
						BOOL t_Revert ;
						IUnknown *t_Proxy ;
						HANDLE t_IdentifyToken = NULL ;

						t_Result = Begin_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_IdentifyToken )
							{
								BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
								if ( t_ObjectPath )
								{
									WmiInternalContext t_InternalContext ;
									t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
									t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

									t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_GetObjectAsync (

										t_InternalContext ,
										t_ObjectPath, 
										a_Flags, 
										a_Context ,
										t_Sink
									) ;

									SysFreeString ( t_ObjectPath ) ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = ( ( IWbemServices * ) t_Interface )->GetObjectAsync (

									a_ObjectPath, 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}

							End_Interface (

								t_ServerInterface ,
								t_InterfaceIdentifier ,
								t_ProxyIndex ,
								t_InternalServerInterface ,
								t_InternalInterfaceIdentifier ,
								t_InternalProxyIndex ,
								m_ProcessIdentifier ,
								t_IdentifyToken ,
								t_Impersonating ,
								t_OldContext ,
								t_OldSecurity ,
								t_IsProxy ,
								t_Interface ,
								t_Revert ,
								t_Proxy
							) ;
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
						REFIID t_InterfaceIdentifier = IID_IWbemServices ;
						DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
						IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
						REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
						DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
						BOOL t_Impersonating ;
						IUnknown *t_OldContext ;
						IServerSecurity *t_OldSecurity ;
						BOOL t_IsProxy ;
						IUnknown *t_Interface ;
						BOOL t_Revert ;
						IUnknown *t_Proxy ;
						HANDLE t_IdentifyToken = NULL ;

						t_Result = Begin_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_IdentifyToken )
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutClassAsync (

									t_InternalContext ,
									a_Object , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}
							else
							{
								t_Result = ( ( IWbemServices * ) t_Interface )->PutClassAsync (

									a_Object , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}

							End_Interface (

								t_ServerInterface ,
								t_InterfaceIdentifier ,
								t_ProxyIndex ,
								t_InternalServerInterface ,
								t_InternalInterfaceIdentifier ,
								t_InternalProxyIndex ,
								m_ProcessIdentifier ,
								t_IdentifyToken ,
								t_Impersonating ,
								t_OldContext ,
								t_OldSecurity ,
								t_IsProxy ,
								t_Interface ,
								t_Revert ,
								t_Proxy
							) ;
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: DeleteClassAsync ( 
		
	const BSTR a_Class ,
	long a_Flags,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
						REFIID t_InterfaceIdentifier = IID_IWbemServices ;
						DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
						IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
						REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
						DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
						BOOL t_Impersonating ;
						IUnknown *t_OldContext ;
						IServerSecurity *t_OldSecurity ;
						BOOL t_IsProxy ;
						IUnknown *t_Interface ;
						BOOL t_Revert ;
						IUnknown *t_Proxy ;
						HANDLE t_IdentifyToken = NULL ;

						t_Result = Begin_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_IdentifyToken )
							{
								BSTR t_Class = SysAllocString ( a_Class ) ;
								if ( t_Class ) 
								{
									WmiInternalContext t_InternalContext ;
									t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
									t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

									t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteClassAsync (

										t_InternalContext ,
										t_Class , 
										a_Flags, 
										a_Context ,
										t_Sink
									) ;

									SysFreeString ( t_Class ) ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = ( ( IWbemServices * ) t_Interface )->DeleteClassAsync (

									a_Class , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}

							End_Interface (

								t_ServerInterface ,
								t_InterfaceIdentifier ,
								t_ProxyIndex ,
								t_InternalServerInterface ,
								t_InternalInterfaceIdentifier ,
								t_InternalProxyIndex ,
								m_ProcessIdentifier ,
								t_IdentifyToken ,
								t_Impersonating ,
								t_OldContext ,
								t_OldSecurity ,
								t_IsProxy ,
								t_Interface ,
								t_Revert ,
								t_Proxy
							) ;
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CInterceptor_IWbemProvider :: CreateClassEnumAsync (

	const BSTR a_Superclass ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
						REFIID t_InterfaceIdentifier = IID_IWbemServices ;
						DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
						IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
						REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
						DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
						BOOL t_Impersonating ;
						IUnknown *t_OldContext ;
						IServerSecurity *t_OldSecurity ;
						BOOL t_IsProxy ;
						IUnknown *t_Interface ;
						BOOL t_Revert ;
						IUnknown *t_Proxy ;
						HANDLE t_IdentifyToken = NULL ;

						t_Result = Begin_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_IdentifyToken )
							{
								BSTR t_Superclass = SysAllocString ( a_Superclass ) ;
								if ( t_Superclass ) 
								{
									WmiInternalContext t_InternalContext ;
									t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
									t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

									t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateClassEnumAsync  (

										t_InternalContext ,
										t_Superclass , 
										a_Flags, 
										a_Context ,
										t_Sink
									) ;

									SysFreeString ( t_Superclass ) ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = ( ( IWbemServices * ) t_Interface )->CreateClassEnumAsync  (

									a_Superclass , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}

							End_Interface (

								t_ServerInterface ,
								t_InterfaceIdentifier ,
								t_ProxyIndex ,
								t_InternalServerInterface ,
								t_InternalInterfaceIdentifier ,
								t_InternalProxyIndex ,
								m_ProcessIdentifier ,
								t_IdentifyToken ,
								t_Impersonating ,
								t_OldContext ,
								t_OldSecurity ,
								t_IsProxy ,
								t_Interface ,
								t_Revert ,
								t_Proxy
							) ;
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: PutInstance (

    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance , 
	long a_Flags ,
    IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
						REFIID t_InterfaceIdentifier = IID_IWbemServices ;
						DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
						IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
						REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
						DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
						BOOL t_Impersonating ;
						IUnknown *t_OldContext ;
						IServerSecurity *t_OldSecurity ;
						BOOL t_IsProxy ;
						IUnknown *t_Interface ;
						BOOL t_Revert ;
						IUnknown *t_Proxy ;
						HANDLE t_IdentifyToken = NULL ;

						t_Result = Begin_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_IdentifyToken )
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutInstanceAsync (

									t_InternalContext ,
									a_Instance , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}
							else
							{
								t_Result = ( ( IWbemServices * ) t_Interface )->PutInstanceAsync (

									a_Instance , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}

							End_Interface (

								t_ServerInterface ,
								t_InterfaceIdentifier ,
								t_ProxyIndex ,
								t_InternalServerInterface ,
								t_InternalInterfaceIdentifier ,
								t_InternalProxyIndex ,
								m_ProcessIdentifier ,
								t_IdentifyToken ,
								t_Impersonating ,
								t_OldContext ,
								t_OldSecurity ,
								t_IsProxy ,
								t_Interface ,
								t_Revert ,
								t_Proxy
							) ;
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: DeleteInstance ( 

	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemProvider :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink	
)
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
						REFIID t_InterfaceIdentifier = IID_IWbemServices ;
						DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
						IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
						REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
						DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
						BOOL t_Impersonating ;
						IUnknown *t_OldContext ;
						IServerSecurity *t_OldSecurity ;
						BOOL t_IsProxy ;
						IUnknown *t_Interface ;
						BOOL t_Revert ;
						IUnknown *t_Proxy ;
						HANDLE t_IdentifyToken = NULL ;

						t_Result = Begin_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_IdentifyToken )
							{
								BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
								if ( t_ObjectPath ) 
								{
									WmiInternalContext t_InternalContext ;
									t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
									t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

									t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteInstanceAsync  (

										t_InternalContext ,
										t_ObjectPath ,
										a_Flags ,
										a_Context ,
										t_Sink
									) ;

									SysFreeString ( t_ObjectPath ) ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = ( ( IWbemServices * ) t_Interface )->DeleteInstanceAsync  (

									a_ObjectPath ,
									a_Flags ,
									a_Context ,
									t_Sink
								) ;
							}

							End_Interface (

								t_ServerInterface ,
								t_InterfaceIdentifier ,
								t_ProxyIndex ,
								t_InternalServerInterface ,
								t_InternalInterfaceIdentifier ,
								t_InternalProxyIndex ,
								m_ProcessIdentifier ,
								t_IdentifyToken ,
								t_Impersonating ,
								t_OldContext ,
								t_OldSecurity ,
								t_IsProxy ,
								t_Interface ,
								t_Revert ,
								t_Proxy
							) ;
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: CreateInstanceEnum ( 

	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink

) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
						REFIID t_InterfaceIdentifier = IID_IWbemServices ;
						DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
						IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
						REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
						DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
						BOOL t_Impersonating ;
						IUnknown *t_OldContext ;
						IServerSecurity *t_OldSecurity ;
						BOOL t_IsProxy ;
						IUnknown *t_Interface ;
						BOOL t_Revert ;
						IUnknown *t_Proxy ;
						HANDLE t_IdentifyToken = NULL ;

						t_Result = Begin_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_IdentifyToken )
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								BSTR t_Class = SysAllocString ( a_Class ) ;
								if ( t_Class )
								{
									t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateInstanceEnumAsync (

										t_InternalContext ,
 										t_Class ,
										a_Flags ,
										a_Context ,
										t_Sink 
									) ;

									SysFreeString ( t_Class ) ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{

								t_Result = ( ( IWbemServices * ) t_Interface )->CreateInstanceEnumAsync (

 									a_Class ,
									a_Flags ,
									a_Context ,
									t_Sink 
								) ;
							}

							End_Interface (

								t_ServerInterface ,
								t_InterfaceIdentifier ,
								t_ProxyIndex ,
								t_InternalServerInterface ,
								t_InternalInterfaceIdentifier ,
								t_InternalProxyIndex ,
								m_ProcessIdentifier ,
								t_IdentifyToken ,
								t_Impersonating ,
								t_OldContext ,
								t_OldSecurity ,
								t_IsProxy ,
								t_Interface ,
								t_Revert ,
								t_Proxy
							) ;
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: ExecQuery ( 

	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CInterceptor_IWbemFilteringObjectSink *t_Sink = new CInterceptor_IWbemFilteringObjectSink (

				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				a_QueryLanguage ,
				a_Query 
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
						REFIID t_InterfaceIdentifier = IID_IWbemServices ;
						DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
						IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
						REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
						DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
						BOOL t_Impersonating ;
						IUnknown *t_OldContext ;
						IServerSecurity *t_OldSecurity ;
						BOOL t_IsProxy ;
						IUnknown *t_Interface ;
						BOOL t_Revert ;
						IUnknown *t_Proxy ;
						HANDLE t_IdentifyToken = NULL ;

						t_Result = Begin_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_IdentifyToken )
							{
								BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
								BSTR t_Query = SysAllocString ( a_Query ) ;

								if ( t_QueryLanguage && t_Query ) 
								{
									WmiInternalContext t_InternalContext ;
									t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
									t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

									t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecQueryAsync  (

										t_InternalContext ,
										t_QueryLanguage , 
										t_Query, 
										a_Flags, 
										a_Context ,
										t_Sink
									) ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								SysFreeString ( t_QueryLanguage ) ;
								SysFreeString ( t_Query ) ;
							}
							else
							{
								t_Result = ( ( IWbemServices * ) t_Interface )->ExecQueryAsync  (

									a_QueryLanguage , 
									a_Query, 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}

							End_Interface (

								t_ServerInterface ,
								t_InterfaceIdentifier ,
								t_ProxyIndex ,
								t_InternalServerInterface ,
								t_InternalInterfaceIdentifier ,
								t_InternalProxyIndex ,
								m_ProcessIdentifier ,
								t_IdentifyToken ,
								t_Impersonating ,
								t_OldContext ,
								t_OldSecurity ,
								t_IsProxy ,
								t_Interface ,
								t_Revert ,
								t_Proxy
							) ;
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				
				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemProvider :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: ExecMethod (

	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: ExecMethodAsync ( 

    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

		return WBEM_E_NOT_FOUND ;
	}

	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
						REFIID t_InterfaceIdentifier = IID_IWbemServices ;
						DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
						IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
						REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
						DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
						BOOL t_Impersonating ;
						IUnknown *t_OldContext ;
						IServerSecurity *t_OldSecurity ;
						BOOL t_IsProxy ;
						IUnknown *t_Interface ;
						BOOL t_Revert ;
						IUnknown *t_Proxy ;
						HANDLE t_IdentifyToken = NULL ;

						t_Result = Begin_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy ,
							a_Context
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_IdentifyToken )
							{
								BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
								BSTR t_MethodName = SysAllocString ( a_MethodName ) ;

								if ( t_ObjectPath && t_MethodName ) 
								{
									WmiInternalContext t_InternalContext ;
									t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
									t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

									t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecMethodAsync  (

										t_InternalContext ,
										t_ObjectPath ,
										t_MethodName ,
										a_Flags ,
										a_Context ,
										a_InParams ,
										t_Sink
									) ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								SysFreeString ( t_ObjectPath ) ;
								SysFreeString ( t_MethodName ) ;
							}
							else
							{
								t_Result = ( ( IWbemServices * ) t_Interface )->ExecMethodAsync  (

									a_ObjectPath ,
									a_MethodName ,
									a_Flags ,
									a_Context ,
									a_InParams ,
									t_Sink
								) ;
							}

							End_Interface (

								t_ServerInterface ,
								t_InterfaceIdentifier ,
								t_ProxyIndex ,
								t_InternalServerInterface ,
								t_InternalInterfaceIdentifier ,
								t_InternalProxyIndex ,
								m_ProcessIdentifier ,
								t_IdentifyToken ,
								t_Impersonating ,
								t_OldContext ,
								t_OldSecurity ,
								t_IsProxy ,
								t_Interface ,
								t_Revert ,
								t_Proxy
							) ;
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: GetProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	if ( GetResumed () )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			IUnknown *t_ServerInterface = m_Provider_IWbemPropertyProvider ;
			REFIID t_InterfaceIdentifier = IID_IWbemPropertyProvider ;
			DWORD t_ProxyIndex = ProxyIndex_IWbemPropertyProvider ;
			IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemPropertyProvider ;
			REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemPropertyProvider ;
			DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemPropertyProvider ;
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			HANDLE t_IdentifyToken = NULL ;

			HRESULT t_Result = Begin_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					BSTR t_ClassMapping = NULL ;
					BSTR t_InstanceMapping = NULL ;
					BSTR t_PropertyMapping = NULL ;

					if ( a_ClassMapping )
					{
						t_ClassMapping = SysAllocString ( a_ClassMapping ) ;
						if ( t_ClassMapping == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( a_InstanceMapping )
					{
						t_InstanceMapping = SysAllocString ( a_InstanceMapping ) ;
						if ( t_InstanceMapping == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						} 
					}

					if ( a_PropertyMapping )
					{
						t_PropertyMapping = SysAllocString ( a_PropertyMapping ) ;
						if ( t_PropertyMapping == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						WmiInternalContext t_InternalContext ;
						t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
						t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

						( ( Internal_IWbemPropertyProvider * ) t_Interface )->Internal_GetProperty ( 

							t_InternalContext ,
							a_Flags ,
							a_Locale ,
							t_ClassMapping ,
							t_InstanceMapping ,
							t_PropertyMapping ,
							a_Value
						) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					SysFreeString ( t_ClassMapping ) ;
					SysFreeString ( t_InstanceMapping ) ;
					SysFreeString ( t_PropertyMapping ) ;
				}
				else
				{
					t_Result = ( ( IWbemPropertyProvider * ) t_Interface )->GetProperty (

						a_Flags ,
						a_Locale ,
						a_ClassMapping ,
						a_InstanceMapping ,
						a_PropertyMapping ,
						a_Value
					) ;
				}

				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}

			return t_Result ;
		}	
		else
		{
			return WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}

	return WBEM_E_PROVIDER_SUSPENDED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: PutProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	if ( GetResumed () )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			IUnknown *t_ServerInterface = m_Provider_IWbemPropertyProvider ;
			REFIID t_InterfaceIdentifier = IID_IWbemPropertyProvider ;
			DWORD t_ProxyIndex = ProxyIndex_IWbemPropertyProvider ;
			IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemPropertyProvider ;
			REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemPropertyProvider ;
			DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemPropertyProvider ;
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			HANDLE t_IdentifyToken = NULL ;

			HRESULT t_Result = Begin_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					BSTR t_ClassMapping = NULL ;
					BSTR t_InstanceMapping = NULL ;
					BSTR t_PropertyMapping = NULL ;

					if ( a_ClassMapping )
					{
						t_ClassMapping = SysAllocString ( a_ClassMapping ) ;
						if ( t_ClassMapping == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( a_InstanceMapping )
					{
						t_InstanceMapping = SysAllocString ( a_InstanceMapping ) ;
						if ( t_InstanceMapping == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						} 
					}

					if ( a_PropertyMapping )
					{
						t_PropertyMapping = SysAllocString ( a_PropertyMapping ) ;
						if ( t_PropertyMapping == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						WmiInternalContext t_InternalContext ;
						t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
						t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

						( ( Internal_IWbemPropertyProvider * ) t_Interface )->Internal_PutProperty ( 

							t_InternalContext ,
							a_Flags ,
							a_Locale ,
							t_ClassMapping ,
							t_InstanceMapping ,
							t_PropertyMapping ,
							a_Value
						) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					SysFreeString ( t_ClassMapping ) ;
					SysFreeString ( t_InstanceMapping ) ;
					SysFreeString ( t_PropertyMapping ) ;
				}
				else
				{
					t_Result = ( ( IWbemPropertyProvider * ) t_Interface )->PutProperty (

						a_Flags ,
						a_Locale ,
						a_ClassMapping ,
						a_InstanceMapping ,
						a_PropertyMapping ,
						a_Value
					) ;
				}

				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}

			return t_Result ;
		}

		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return WBEM_E_PROVIDER_SUSPENDED ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	if ( GetResumed () )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			IUnknown *t_ServerInterface = m_Provider_IWbemEventProvider ;
			REFIID t_InterfaceIdentifier = IID_IWbemEventProvider ;
			DWORD t_ProxyIndex = ProxyIndex_IWbemEventProvider ;
			IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProvider ;
			REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProvider ;
			DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProvider ;
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			HANDLE t_IdentifyToken = NULL ;

			HRESULT t_Result = Begin_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					t_Result = ( ( Internal_IWbemEventProvider * ) t_Interface )->Internal_ProvideEvents (

						t_InternalContext ,
						a_Sink ,
						a_Flags 
					) ;
				}
				else
				{
					t_Result = ( ( IWbemEventProvider * ) t_Interface )->ProvideEvents (

						a_Sink ,
						a_Flags 
					) ;
				}

				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}

			return t_Result ;
		}

		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return WBEM_E_PROVIDER_SUSPENDED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	if ( GetResumed () )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderQuerySink ;
			REFIID t_InterfaceIdentifier = IID_IWbemEventProviderQuerySink ;
			DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderQuerySink ;
			IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProviderQuerySink ;
			REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProviderQuerySink ;
			DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProviderQuerySink ;
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			HANDLE t_IdentifyToken = NULL ;

			HRESULT t_Result = Begin_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
					BSTR t_Query = SysAllocString ( a_Query ) ;

					if ( t_QueryLanguage && t_Query )
					{
						WmiInternalContext t_InternalContext ;
						t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
						t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

						t_Result = ( ( Internal_IWbemEventProviderQuerySink * ) t_Interface )->Internal_NewQuery (

							t_InternalContext ,
							a_Id ,
							t_QueryLanguage ,
							t_Query
						) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					SysFreeString ( t_QueryLanguage ) ;
					SysFreeString ( t_Query ) ;
				}
				else
				{
					t_Result = ( ( IWbemEventProviderQuerySink * ) t_Interface )->NewQuery (

						a_Id ,
						a_QueryLanguage ,
						a_Query
					) ;
				}

				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}

			return t_Result ;
		}

		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return WBEM_E_PROVIDER_SUSPENDED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::CancelQuery (

	unsigned long a_Id
)
{
	if ( GetResumed () )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderQuerySink ;
			REFIID t_InterfaceIdentifier = IID_IWbemEventProviderQuerySink ;
			DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderQuerySink ;
			IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProviderQuerySink ;
			REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProviderQuerySink ;
			DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProviderQuerySink ;
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			HANDLE t_IdentifyToken = NULL ;

			HRESULT t_Result = Begin_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					t_Result = ( ( Internal_IWbemEventProviderQuerySink * ) t_Interface )->Internal_CancelQuery (

						t_InternalContext ,
						a_Id
					) ;
				}
				else
				{
					t_Result = ( ( IWbemEventProviderQuerySink * ) t_Interface )->CancelQuery (

						a_Id
					) ;
				}

				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}

			return t_Result ;
		}

		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return WBEM_E_PROVIDER_SUSPENDED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	if ( GetResumed () )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderSecurity ;
			REFIID t_InterfaceIdentifier = IID_IWbemEventProviderSecurity ;
			DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderSecurity ;
			IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProviderSecurity ;
			REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProviderSecurity ;
			DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProviderSecurity;
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			HANDLE t_IdentifyToken = NULL ;

			HRESULT t_Result = Begin_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
					BSTR t_Query = SysAllocString ( a_Query ) ;

					if ( t_QueryLanguage && t_Query )
					{
						WmiInternalContext t_InternalContext ;
						t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
						t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

						t_Result = ( ( Internal_IWbemEventProviderSecurity * ) t_Interface )->Internal_AccessCheck (

							t_InternalContext ,
							t_QueryLanguage ,
							t_Query ,
							a_SidLength ,
							a_Sid
						) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					SysFreeString ( t_QueryLanguage ) ;
					SysFreeString ( t_Query ) ;
				}
				else
				{
					t_Result = ( ( IWbemEventProviderSecurity * ) t_Interface )->AccessCheck (

						a_QueryLanguage ,
						a_Query ,
						a_SidLength ,
						a_Sid
					) ;
				}

				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;

				if ( FAILED ( t_Result ) )
				{
					if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
					{
						AbnormalShutdown () ;
					}
				}
			}

			return t_Result ;
		}

		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return WBEM_E_PROVIDER_SUSPENDED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	if ( GetResumed () )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			IWbemUnboundObjectSink *t_Consumer = NULL ;

			IUnknown *t_ServerInterface = m_Provider_IWbemEventConsumerProvider ;
			REFIID t_InterfaceIdentifier = IID_IWbemEventConsumerProvider ;
			DWORD t_ProxyIndex = ProxyIndex_IWbemEventConsumerProvider ;
			IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventConsumerProvider ;
			REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventConsumerProvider ;
			DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventConsumerProvider ;
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			HANDLE t_IdentifyToken = NULL ;

			HRESULT t_Result = Begin_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					t_Result = ( ( Internal_IWbemEventConsumerProvider * ) t_Interface )->Internal_FindConsumer (

						t_InternalContext ,
						a_LogicalConsumer ,
						& t_Consumer
					) ;
				}
				else
				{
					t_Result = ( ( IWbemEventConsumerProvider * ) t_Interface )->FindConsumer (

						a_LogicalConsumer ,
						& t_Consumer
					) ;
				}

				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( a_Consumer )
				{
					CInterceptor_IWbemUnboundObjectSink *t_UnboundObjectSink = new CInterceptor_IWbemUnboundObjectSink (

							m_Allocator ,
							t_Consumer , 
							this ,
							*m_Registration
					) ;

					if ( t_UnboundObjectSink )
					{
						t_UnboundObjectSink->AddRef () ;

						t_Result = t_UnboundObjectSink->Initialize () ;
						if ( SUCCEEDED ( t_Result ) ) 
						{
							CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

							Lock () ;

							WmiStatusCode t_StatusCode = Insert ( 

								*t_UnboundObjectSink ,
								t_Iterator
							) ;

							if ( t_StatusCode == e_StatusCode_Success ) 
							{
								UnLock () ;

								*a_Consumer = t_UnboundObjectSink ;

								t_UnboundObjectSink->AddRef () ;
							}
							else
							{
								UnLock () ;

								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}

						t_UnboundObjectSink->Release () ;
					}
				}
			}
			else
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}

			if ( t_Consumer )
			{
				t_Consumer->Release () ;
			}

			return t_Result ;
		}

		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return WBEM_E_PROVIDER_SUSPENDED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	if ( GetResumed () )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			IUnknown *t_ServerInterface = m_Provider_IWbemEventConsumerProviderEx ;
			REFIID t_InterfaceIdentifier = IID_IWbemEventConsumerProviderEx ;
			DWORD t_ProxyIndex = ProxyIndex_IWbemEventConsumerProviderEx ;
			IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventConsumerProviderEx ;
			REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventConsumerProviderEx ;
			DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventConsumerProviderEx ;
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			HANDLE t_IdentifyToken = NULL ;

			HRESULT t_Result = Begin_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					t_Result = ( ( Internal_IWbemEventConsumerProviderEx * ) t_Interface )->Internal_ValidateSubscription (

						t_InternalContext ,
						a_LogicalConsumer
					) ;
				}
				else
				{

					t_Result = ( ( IWbemEventConsumerProviderEx * ) t_Interface )->ValidateSubscription (

						a_LogicalConsumer
					) ;
				}

				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}

			return t_Result ;
		}

		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return WBEM_E_PROVIDER_SUSPENDED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( GetResumed () )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			IUnknown *t_ServerInterface = m_Provider_IWbemUnboundObjectSink ;
			REFIID t_InterfaceIdentifier = IID_IWbemUnboundObjectSink ;
			DWORD t_ProxyIndex = ProxyIndex_IWbemUnboundObjectSink ;
			IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemUnboundObjectSink ;
			REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemUnboundObjectSink ;
			DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemUnboundObjectSink ;
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			HANDLE t_IdentifyToken = NULL ;

			HRESULT t_Result = Begin_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					t_Result = ( ( Internal_IWbemUnboundObjectSink * ) t_Interface )->Internal_IndicateToConsumer (

						t_InternalContext ,
						a_LogicalConsumer ,
						a_ObjectCount ,
						a_Objects
					) ;
				}
				else
				{

					t_Result = ( ( IWbemUnboundObjectSink * ) t_Interface )->IndicateToConsumer (

						a_LogicalConsumer ,
						a_ObjectCount ,
						a_Objects
					) ;
				}

				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}

			return t_Result ;
		}

		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return WBEM_E_PROVIDER_SUSPENDED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::QueryInstances (

	IWbemServices *a_Namespace ,
	WCHAR *a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::CreateRefresher (

	IWbemServices *a_Namespace ,
	long a_Flags ,
	IWbemRefresher **a_Refresher
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE;
} 

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::CreateRefreshableObject (

	IWbemServices *a_Namespace ,
	IWbemObjectAccess *a_Template ,
	IWbemRefresher *a_Refresher ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectAccess **a_Refreshable ,
	long *a_Id
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::StopRefreshing (

	IWbemRefresher *a_Refresher ,
	long a_Id ,
	long a_Flags
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::CreateRefreshableEnum (

	IWbemServices *a_Namespace ,
	LPCWSTR a_Class ,
	IWbemRefresher *a_Refresher ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemHiPerfEnum *a_HiPerfEnum ,
	long *a_Id
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::GetObjects (

	IWbemServices *a_Namespace ,
	long a_ObjectCount ,
	IWbemObjectAccess **a_Objects ,
	long a_Flags ,
	IWbemContext *a_Context
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Get (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	if ( _wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
	{
		CWaitingObjectSink *t_Sink = new CWaitingObjectSink ( m_Allocator ) ;
		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				try
				{
					ProviderCacheKey t_Key = ServiceCacheElement :: GetKey () ;

					t_Result = m_Provider__IWmiProviderConfiguration->Get ( 

						a_Service ,
						a_Flags ,
						a_Context ,
						a_Class ,
						a_Path ,
						t_Sink 
					) ;

					t_Result = t_Sink->Wait ( INFINITE ) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Sink->GetResult () ;
						if ( FAILED ( t_Result ) )
						{
						}
					}

					WmiQueue <IWbemClassObject *,8> &t_Queue = t_Sink->GetQueue () ;

					WmiStatusCode t_StatusCode = e_StatusCode_Success ;

					IWbemClassObject *t_Object = NULL ;
					while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
					{
						if ( SUCCEEDED ( t_Result  ) )
						{
							VARIANT t_VariantUser ;
							VariantInit ( & t_VariantUser ) ;
							t_VariantUser.vt = VT_BSTR ;
							t_VariantUser.bstrVal = t_Key.m_User ? SysAllocString ( t_Key.m_User ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"User" , 0 , & t_VariantUser , 0 ) ;
							VariantClear ( & t_VariantUser ) ;
				
							VARIANT t_VariantLocale ;
							VariantInit ( & t_VariantLocale ) ; 
							t_VariantLocale.vt = VT_BSTR ;
							t_VariantLocale.bstrVal = t_Key.m_Locale ? SysAllocString ( t_Key.m_Locale ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"Locale" , 0 , & t_VariantLocale , 0 ) ;
							VariantClear ( & t_VariantLocale ) ;

							VARIANT t_VariantProvider ;
							VariantInit ( & t_VariantProvider ) ; 
							t_VariantProvider.vt = VT_BSTR ;
							t_VariantProvider.bstrVal = t_Key.m_Provider ? SysAllocString ( t_Key.m_Provider ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"Provider" , 0 , & t_VariantProvider , 0 ) ;
							VariantClear ( & t_VariantProvider ) ;

							VARIANT t_VariantHostingSpecification ;
							VariantInit ( & t_VariantHostingSpecification ) ;
							t_VariantHostingSpecification.vt = VT_I4 ;
							t_VariantHostingSpecification.lVal = t_Key.m_Hosting ;
							t_Object->Put ( L"HostingSpecification" , 0 , & t_VariantHostingSpecification , 0 ) ;
							VariantClear ( & t_VariantHostingSpecification ) ;

							VARIANT t_VariantHostGroup ;
							VariantInit ( & t_VariantHostGroup ) ; 
							t_VariantHostGroup.vt = VT_BSTR ;
							t_VariantHostGroup.bstrVal = t_Key.m_Group ? SysAllocString ( t_Key.m_Group ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"HostingGroup" , 0 , & t_VariantHostGroup , 0 ) ;
							VariantClear ( & t_VariantHostGroup ) ;

							wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;
							if ( t_Key.m_TransactionIdentifier )
							{
								StringFromGUID2 ( *t_Key.m_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
							}

							VARIANT t_VariantTransactionIdentifier ;
							VariantInit ( & t_VariantTransactionIdentifier ) ;
							t_VariantTransactionIdentifier.vt = VT_BSTR ;
							t_VariantTransactionIdentifier.bstrVal = t_Key.m_TransactionIdentifier ? SysAllocString ( t_TransactionIdentifier ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"TransactionIdentifier" , 0 , & t_VariantTransactionIdentifier , 0 ) ;
							VariantClear ( & t_VariantTransactionIdentifier ) ;

							a_Sink->Indicate ( 1, & t_Object ) ;
						}

						t_Object->Release () ;
						t_StatusCode = t_Queue.DeQueue () ;
					}
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}	
	}
	else
	{
		t_Result = WBEM_E_INVALID_CLASS ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Set (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_OldObject ,
	IWbemClassObject *a_NewObject  
)
{
	HRESULT t_Result = m_Provider__IWmiProviderConfiguration->Set ( 

		a_Service ,
		a_Flags ,
		a_Context ,
		a_Provider ,
		a_Class ,
		a_Path ,
		a_OldObject ,
		a_NewObject
	) ;

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Deleted (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_Object  
)
{
	HRESULT t_Result = m_Provider__IWmiProviderConfiguration->Deleted ( 

		a_Service ,
		a_Flags ,
		a_Context ,
		a_Provider ,
		a_Class ,
		a_Path ,
		a_Object  
	) ;

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Enumerate (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	if ( _wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
	{
		CWaitingObjectSink *t_Sink = new CWaitingObjectSink ( m_Allocator ) ;
		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				try
				{
					ProviderCacheKey t_Key = ServiceCacheElement :: GetKey () ;

					t_Result = m_Provider__IWmiProviderConfiguration->Enumerate ( 

						a_Service ,
						a_Flags ,
						a_Context ,
						a_Class ,
						t_Sink 
					) ;

					t_Result = t_Sink->Wait ( INFINITE ) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Sink->GetResult () ;
						if ( FAILED ( t_Result ) )
						{
						}
					}

					WmiQueue <IWbemClassObject *,8> &t_Queue = t_Sink->GetQueue () ;

					WmiStatusCode t_StatusCode = e_StatusCode_Success ;

					IWbemClassObject *t_Object = NULL ;
					while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
					{
						if ( SUCCEEDED ( t_Result  ) )
						{
							VARIANT t_VariantUser ;
							VariantInit ( & t_VariantUser ) ;
							t_VariantUser.vt = VT_BSTR ;
							t_VariantUser.bstrVal = t_Key.m_User ? SysAllocString ( t_Key.m_User ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"User" , 0 , & t_VariantUser , 0 ) ;
							VariantClear ( & t_VariantUser ) ;
				
							VARIANT t_VariantLocale ;
							VariantInit ( & t_VariantLocale ) ; 
							t_VariantLocale.vt = VT_BSTR ;
							t_VariantLocale.bstrVal = t_Key.m_Locale ? SysAllocString ( t_Key.m_Locale ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"Locale" , 0 , & t_VariantLocale , 0 ) ;
							VariantClear ( & t_VariantLocale ) ;

							VARIANT t_VariantProvider ;
							VariantInit ( & t_VariantProvider ) ; 
							t_VariantProvider.vt = VT_BSTR ;
							t_VariantProvider.bstrVal = t_Key.m_Provider ? SysAllocString ( t_Key.m_Provider ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"Provider" , 0 , & t_VariantProvider , 0 ) ;
							VariantClear ( & t_VariantProvider ) ;

							VARIANT t_VariantHostingSpecification ;
							VariantInit ( & t_VariantHostingSpecification ) ;
							t_VariantHostingSpecification.vt = VT_I4 ;
							t_VariantHostingSpecification.lVal = t_Key.m_Hosting ;
							t_Object->Put ( L"HostingSpecification" , 0 , & t_VariantHostingSpecification , 0 ) ;
							VariantClear ( & t_VariantHostingSpecification ) ;

							VARIANT t_VariantHostGroup ;
							VariantInit ( & t_VariantHostGroup ) ; 
							t_VariantHostGroup.vt = VT_BSTR ;
							t_VariantHostGroup.bstrVal = t_Key.m_Group ? SysAllocString ( t_Key.m_Group ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"HostingGroup" , 0 , & t_VariantHostGroup , 0 ) ;
							VariantClear ( & t_VariantHostGroup ) ;

							wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;
							if ( t_Key.m_TransactionIdentifier )
							{
								StringFromGUID2 ( *t_Key.m_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
							}

							VARIANT t_VariantTransactionIdentifier ;
							VariantInit ( & t_VariantTransactionIdentifier ) ;
							t_VariantTransactionIdentifier.vt = VT_BSTR ;
							t_VariantTransactionIdentifier.bstrVal = t_Key.m_TransactionIdentifier ? SysAllocString ( t_TransactionIdentifier ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"TransactionIdentifier" , 0 , & t_VariantTransactionIdentifier , 0 ) ;
							VariantClear ( & t_VariantTransactionIdentifier ) ;

							a_Sink->Indicate ( 1, & t_Object ) ;
						}

						t_Object->Release () ;
						t_StatusCode = t_Queue.DeQueue () ;
					}
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}	
	}
	else
	{
		t_Result = WBEM_E_INVALID_CLASS ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Shutdown (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	ULONG a_MilliSeconds
)
{
	HRESULT t_Result = m_Provider__IWmiProviderConfiguration->Shutdown ( 

		a_Service ,
		a_Flags ,
		a_Context ,
		a_Provider ,
		a_MilliSeconds
	) ;

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Call (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	LPCWSTR a_Method,
	IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	if ( _wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
	{
		if ( _wcsicmp ( a_Method , L"Suspend" ) == 0 )
		{
			SetResumed ( 0 ) ;
		}
		else if ( _wcsicmp ( a_Method , L"Resume" ) == 0 )
		{
			SetResumed ( 1 ) ;
		}
		else
		{
			CWaitingObjectSink *t_Sink = new CWaitingObjectSink ( m_Allocator ) ;
			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					try
					{
						ProviderCacheKey t_Key = ServiceCacheElement :: GetKey () ;

						t_Result = m_Provider__IWmiProviderConfiguration->Call ( 

							a_Service ,
							a_Flags ,
							a_Context ,
							a_Class ,
							a_Path ,
							a_Method,
							a_InParams,
							t_Sink 
						) ;

						t_Result = t_Sink->Wait ( INFINITE ) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Sink->GetResult () ;
							if ( FAILED ( t_Result ) )
							{
							}
						}

						WmiQueue <IWbemClassObject *,8> &t_Queue = t_Sink->GetQueue () ;

						WmiStatusCode t_StatusCode = e_StatusCode_Success ;

						IWbemClassObject *t_Object = NULL ;
						while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
						{
							a_Sink->Indicate ( 1, & t_Object ) ;
							t_Object->Release () ;
							t_StatusCode = t_Queue.DeQueue () ;
						}
					}
					catch ( Wmi_Heap_Exception &a_Exception )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_CLASS ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Query (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
	WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
	VARIANT *a_Value 
)
{
	if ( m_Initialized == 0 )
	{
		HRESULT t_Result = WBEM_E_INVALID_PROPERTY ;

		if ( a_ClassIdentifier == WBEM_PROVIDER_CONFIGURATION_CLASS_ID_INSTANCE_PROVIDER_REGISTRATION ) 
		{
			if ( a_PropertyIdentifier == WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID_EXTENDEDQUERY_SUPPORT )
			{
				a_Value->vt = VT_BOOL ;
				a_Value->boolVal = VARIANT_FALSE ;

				t_Result = S_OK ;
			}
		}

		return t_Result ;
	}

	HRESULT t_Result = m_Provider__IWmiProviderConfiguration->Query (

		a_Service ,
		a_Flags ,
		a_Context ,
		a_ClassIdentifier ,
		a_PropertyIdentifier ,
		a_Value 
	) ;

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: AbnormalShutdown ()
{
	HRESULT t_Result = S_OK ;

	Lock () ;

	BOOL t_Cached = ServiceCacheElement :: GetCached () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Container->Size () ] ;
	if ( t_ShutdownElements )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

		ULONG t_Count = 0 ;
		while ( ! t_Iterator.Null () )
		{
			t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

			t_Iterator.Increment () ;

			t_Count ++ ;
		}

		UnLock () ;

		for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
		{
			if ( t_ShutdownElements [ t_Index ] ) 
			{
				t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

					0 ,
					0 ,
					NULL
				) ;

				t_ShutdownElements [ t_Index ]->Release () ;
			}
		}

		delete [] t_ShutdownElements ;
	}
	else
	{	
		UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	CWbemGlobal_IWmiProviderController *t_Controller = ServiceCacheElement :: GetController () ;
	if ( t_Controller )
	{
		t_Controller->Shutdown ( ServiceCacheElement :: GetKey () ) ;
	}

	if ( t_Cached )
	{
		t_Result = ForceReload () ;
	}


	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Expel (

	long a_Flags ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProviderController *t_Controller = ServiceCacheElement :: GetController () ;
	if ( t_Controller )
	{
		t_Controller->Shutdown ( ServiceCacheElement :: GetKey () ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Violation (

	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemClassObject *a_Object	
)
{
	HRESULT t_Result = S_OK ;

	t_Result = AbnormalShutdown () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	IWbemShutdown *t_Shutdown = NULL ;

	if ( m_Unknown )
	{
		t_Result = m_Unknown->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Shutdown->Shutdown (

				a_Flags ,
				a_MaxMilliSeconds ,
				a_Context
			) ;

			t_Shutdown->Release () ;
		}
	}

	Lock () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Container->Size () ] ;
	if ( t_ShutdownElements )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

		ULONG t_Count = 0 ;
		while ( ! t_Iterator.Null () )
		{
			t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

			t_Iterator.Increment () ;

			t_Count ++ ;
		}

		UnLock () ;

		for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
		{
			if ( t_ShutdownElements [ t_Index ] ) 
			{
				t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

					a_Flags ,
					a_MaxMilliSeconds ,
					a_Context
				) ;

				t_ShutdownElements [ t_Index ]->Release () ;
			}
		}

		delete [] t_ShutdownElements ;
	}
	else
	{	
		UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: ForceReload ()
{
	HRESULT t_Result = ProviderSubSystem_Globals :: ForwardReload ( 

		_IWMIPROVSSSINK_FLAGS_RELOAD , 
		NULL ,
		m_Namespace ,
		ServiceCacheElement :: GetKey ().m_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider  :: Unload (

	long a_Flags ,
	IWbemContext *a_Context
)
{
	ProviderSubSystem_Globals :: InsertGuidTag ( m_Registration->GetClsid () ) ;

	HRESULT t_Result = Shutdown (

		0 ,
		0 ,
		a_Context
	) ;

	t_Result = ProviderSubSystem_Globals :: ForwardReload ( 

		_IWMIPROVSSSINK_FLAGS_UNLOAD , 
		NULL ,
		m_Namespace ,
		ServiceCacheElement :: GetKey ().m_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider  :: Load (

	long a_Flags ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = ProviderSubSystem_Globals :: ForwardReload ( 

		_IWMIPROVSSSINK_FLAGS_LOAD , 
		NULL ,
		m_Namespace ,
		ServiceCacheElement :: GetKey ().m_Provider
	) ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provswsv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"

#include <wbemint.h>
#include <stdio.h>
#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvFact.h"
#include "ProvObSk.h"
#include "ProvInSk.h"
#include "ProvWsv.h"
#include "ProvCache.h"

#include "arrtempl.h"

#include "Guids.h"

#ifdef WMIASLOCAL
#include "Main.h"
#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CheckThreadToken () 
{
	HANDLE t_ThreadToken ;
	BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		MAXIMUM_ALLOWED ,
		TRUE ,
		& t_ThreadToken
	) ;

	if ( ! t_Status ) 
	{
		DWORD t_LastError = GetLastError () ;
		if ( t_LastError == ERROR_ACCESS_DENIED )
		{
			DebugBreak () ;
		}
	}
	else
	{
		CloseHandle ( t_ThreadToken ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncUnboundObjectSink :: CInterceptor_IWbemSyncUnboundObjectSink (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) :	VoidPointerContainerElement (

		a_Controller ,
		this 
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Registration ( & a_Registration ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_UnBoundSync_Size , MAX_PROXIES )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncUnboundObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	if ( a_ServerSideProvider ) 
	{
		m_Unknown = a_ServerSideProvider ;
		m_Unknown->AddRef () ;

		HRESULT t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncUnboundObjectSink :: ~CInterceptor_IWbemSyncUnboundObjectSink ()
{
	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncUnboundObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncUnboundObjectSink :: Initialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemSyncUnboundObjectSink :: AddRef ()
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemSyncUnboundObjectSink :: Release ()
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemSyncUnboundObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID__IWmiProviderSite )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderSite * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncUnboundObjectSink :: Internal_IndicateToConsumer (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = IndicateToConsumer (


			a_LogicalConsumer ,
			a_ObjectCount ,
			a_Objects
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncUnboundObjectSink :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_UnBoundSync_IWbemUnboundObjectSink , IID_IWbemUnboundObjectSink , m_Provider_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Provider_IWbemUnboundObjectSink->IndicateToConsumer (


					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemUnboundObjectSink *t_Provider = ( IWbemUnboundObjectSink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Provider->IndicateToConsumer (

							a_LogicalConsumer ,
							a_ObjectCount ,
							a_Objects
						) ;
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_UnBoundSync_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncUnboundObjectSink :: Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncUnboundObjectSink :: GetSite ( DWORD *a_ProcessIdentifier )
{
	HRESULT t_Result = S_OK ;

	if ( a_ProcessIdentifier ) 
	{
		*a_ProcessIdentifier = GetCurrentProcessId () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncUnboundObjectSink :: SetContainer ( IUnknown *a_Container )
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemSyncProvider :: CInterceptor_IWbemSyncProvider (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	IWbemServices *a_CoreStub ,
	CWbemGlobal_IWbemSyncProviderController *a_Controller ,
	IWbemContext *a_InitializationContext ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	GUID &a_Guid 

) :	CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	SyncProviderContainerElement (

		a_Controller ,
		a_Guid
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemServices ( NULL ) ,
	m_Provider_IWbemPropertyProvider ( NULL ) ,
	m_Provider_IWbemHiPerfProvider ( NULL ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_ExtendedStatusObject ( NULL ) ,
	m_CoreStub ( a_CoreStub ) ,
	m_Quota ( NULL ) ,
	m_Registration ( & a_Registration ) ,
	m_Locale ( NULL ) ,
	m_User ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_Provider_Size , MAX_PROXIES ) ,
	m_ProviderOperation_GetObjectAsync ( 0 ) ,
	m_ProviderOperation_PutClassAsync ( 0 ) ,
	m_ProviderOperation_DeleteClassAsync ( 0 ) ,
	m_ProviderOperation_CreateClassEnumAsync ( 0 ) ,
	m_ProviderOperation_PutInstanceAsync ( 0 ) ,
	m_ProviderOperation_DeleteInstanceAsync ( 0 ) ,
	m_ProviderOperation_CreateInstanceEnumAsync ( 0 ) ,
	m_ProviderOperation_ExecQueryAsync ( 0 ) ,
	m_ProviderOperation_ExecNotificationQueryAsync ( 0 ) ,
	m_ProviderOperation_ExecMethodAsync ( 0 ) ,
	m_ProviderOperation_QueryInstances ( 0 ) ,
	m_ProviderOperation_CreateRefresher ( 0 ) ,
	m_ProviderOperation_CreateRefreshableObject ( 0 ) ,
	m_ProviderOperation_StopRefreshing ( 0 ) ,
	m_ProviderOperation_CreateRefreshableEnum ( 0 ) ,
	m_ProviderOperation_GetObjects ( 0 ) ,
	m_ProviderOperation_GetProperty ( 0 ) ,
	m_ProviderOperation_PutProperty ( 0 ) ,
	m_ProviderOperation_ProvideEvents ( 0 ) ,
	m_ProviderOperation_NewQuery ( 0 ) ,
	m_ProviderOperation_CancelQuery ( 0 ) ,
	m_ProviderOperation_AccessCheck ( 0 ) ,
	m_ProviderOperation_SetRegistrationObject ( 0 ) ,
	m_ProviderOperation_FindConsumer ( 0 ) ,
	m_ProviderOperation_ValidateSubscription ( 0 ) ,
	m_Initialized ( 0 ) ,
	m_InitializeResult ( S_OK ) ,
	m_InitializedEvent ( NULL ) , 
	m_InitializationContext ( a_InitializationContext )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( a_InitializationContext )
	{
		a_InitializationContext->AddRef () ;
	}

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	if ( a_ServerSideProvider ) 
	{
		m_Unknown = a_ServerSideProvider ;
		m_Unknown->AddRef () ;

		HRESULT t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemServices , ( void ** ) & m_Provider_IWbemServices ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemPropertyProvider , ( void ** ) & m_Provider_IWbemPropertyProvider ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_IWbemEventConsumerProviderEx ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
	    t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemHiPerfProvider , ( void ** ) & m_Provider_IWbemHiPerfProvider ) ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemSyncProvider :: ~CInterceptor_IWbemSyncProvider ()
{
	WmiSetAndCommitObject (

		ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_UnLoadOperationEvent ] , 
		WMI_SENDCOMMIT_SET_NOT_REQUIRED,
		m_Namespace ,
		m_Registration->GetProviderName () ,
		m_User ,
		m_Locale ,
		NULL 
	) ;

	if ( m_ExtendedStatusObject )
	{
		m_ExtendedStatusObject->Release () ;
	}

	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemServices )
	{
		m_Provider_IWbemServices->Release () ; 
	}

	if ( m_Provider_IWbemPropertyProvider )
	{
		m_Provider_IWbemPropertyProvider->Release () ; 
	}

	if ( m_Provider_IWbemHiPerfProvider )
	{
		m_Provider_IWbemHiPerfProvider->Release () ;
	}

	if ( m_Provider_IWbemEventProvider )
	{
		m_Provider_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		m_Provider_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		m_Provider_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		m_Provider_IWbemEventConsumerProviderEx->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProvider )
	{
		m_Provider_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->Release () ;
	}

	if ( m_Quota )
	{
		m_Quota->Release () ;
	}

	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	if ( m_InitializationContext )
	{
		m_InitializationContext->Release () ;
	}

	if ( m_InitializedEvent )
	{
		CloseHandle ( m_InitializedEvent ) ;
	}

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemSyncProvider :: AddRef ()
{
	return SyncProviderContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemSyncProvider :: Release ()
{
	return SyncProviderContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemSyncProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		if ( m_Provider_IWbemServices || m_Provider_IWbemHiPerfProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemServices * ) this ;
		}
	}
	else if ( iid == IID_IWbemPropertyProvider )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemPropertyProvider * ) this ;
		}
	}	
	else if ( iid == IID_IWbemHiPerfProvider )
	{
		if ( m_Provider_IWbemHiPerfProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemHiPerfProvider * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProvider )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProvider * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID__IWmiProviderSite )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderSite * ) this ;		
	}
	else if ( iid == IID__IWmiProviderQuota )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderQuota * ) this ;		
	}
	else if ( iid == IID__IWmiProviderInitialize )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderInitialize * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}
	else if ( iid == IID__IWmiProviderConfiguration )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderConfiguration * ) this ;		
	}	
	else if ( iid == IID_CWbemGlobal_IWmiObjectSinkController )
	{
		*iplpv = ( LPVOID ) ( CWbemGlobal_IWmiObjectSinkController * ) this ;		
	}	
	else if ( iid == IID_CacheElement )
	{
		*iplpv = ( LPVOID ) ( SyncProviderContainerElement * ) this ;		
	}
	else if ( iid == IID_Internal_IWbemServices )
	{
		if ( m_Provider_IWbemServices || m_Provider_IWbemHiPerfProvider )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemServices * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWbemPropertyProvider )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemPropertyProvider * ) this ;
		}
	}	
	else if ( iid == IID_Internal_IWbemEventProvider )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemEventProvider * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWmiProviderConfiguration )
	{
		*iplpv = ( LPVOID ) ( Internal_IWmiProviderConfiguration * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_OpenNamespace ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = OpenNamespace (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_NamespaceService ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_CancelAsyncCall ( 
	
	WmiInternalContext a_InternalContext ,		
	IWbemObjectSink *a_Sink
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CancelAsyncCall (
		
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_QueryObjectSink ( 

	WmiInternalContext a_InternalContext ,
	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryObjectSink (

			a_Flags ,	
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_GetObject ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetObject (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_Object ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_GetObjectAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetObjectAsync (

			a_ObjectPath ,
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_PutClass ( 

	WmiInternalContext a_InternalContext ,		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutClass (

			a_Object ,
			a_Flags , 
			a_Context ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_PutClassAsync ( 
		
	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_Object , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutClassAsync (

			a_Object , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_DeleteClass ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteClass (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_DeleteClassAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteClassAsync (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_CreateClassEnum ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_SuperClass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateClassEnum (

			a_SuperClass ,
			a_Flags, 
			a_Context ,
			a_Enum
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_CreateClassEnumAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_SuperClass , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateClassEnumAsync (

			a_SuperClass ,
			a_Flags, 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_PutInstance (

	WmiInternalContext a_InternalContext ,
    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutInstance (

			a_Instance ,
			a_Flags ,
			a_Context ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_PutInstanceAsync ( 

	WmiInternalContext a_InternalContext ,		
	IWbemClassObject *a_Instance , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutInstanceAsync (

			a_Instance , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_DeleteInstance ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteInstance (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_DeleteInstanceAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteInstanceAsync (

			a_ObjectPath ,
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_CreateInstanceEnum ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateInstanceEnum (

			a_Class ,
			a_Flags , 
			a_Context , 
			a_Enum
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_CreateInstanceEnumAsync (

	WmiInternalContext a_InternalContext ,
 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateInstanceEnumAsync (

			a_Class ,
			a_Flags ,
			a_Context ,
			a_Sink 
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_ExecQuery ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecQuery (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Enum
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_ExecQueryAsync ( 

	WmiInternalContext a_InternalContext ,		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecQueryAsync (

			a_QueryLanguage ,
			a_Query, 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_ExecNotificationQuery ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecNotificationQuery (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Enum
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemSyncProvider :: Internal_ExecNotificationQueryAsync ( 

	WmiInternalContext a_InternalContext ,            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecNotificationQueryAsync (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Sink 
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_ExecMethod (

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecMethod (

			a_ObjectPath ,
			a_MethodName ,
			a_Flags ,
			a_Context ,
			a_InParams ,
			a_OutParams ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_ExecMethodAsync ( 

	WmiInternalContext a_InternalContext ,		
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecMethodAsync (

			a_ObjectPath ,
			a_MethodName ,
			a_Flags ,
			a_Context ,
			a_InParams ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_GetProperty (

	WmiInternalContext a_InternalContext ,
    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetProperty ( 

			a_Flags ,
			a_Locale ,
			a_ClassMapping ,
			a_InstanceMapping ,
			a_PropertyMapping ,
			a_Value
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_PutProperty (

	WmiInternalContext a_InternalContext ,
    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutProperty ( 

			a_Flags ,
			a_Locale ,
			a_ClassMapping ,
			a_InstanceMapping ,
			a_PropertyMapping ,
			a_Value
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_ProvideEvents (

	WmiInternalContext a_InternalContext ,
	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ProvideEvents (

			a_Sink ,
			a_Flags 
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_NewQuery (

	WmiInternalContext a_InternalContext ,
	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = NewQuery (

			a_Id ,
			a_QueryLanguage ,
			a_Query
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_CancelQuery (

	WmiInternalContext a_InternalContext ,
	unsigned long a_Id
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CancelQuery (

			a_Id
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_AccessCheck (

	WmiInternalContext a_InternalContext ,
	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = AccessCheck (

			a_QueryLanguage ,
			a_Query ,
			a_SidLength ,
			a_Sid
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_FindConsumer (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = FindConsumer (

			a_LogicalConsumer ,
			a_Consumer
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_ValidateSubscription (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ValidateSubscription (

			a_LogicalConsumer
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_IndicateToConsumer (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = IndicateToConsumer (


			a_LogicalConsumer ,
			a_ObjectCount ,
			a_Objects
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_Get (

	WmiInternalContext a_InternalContext ,
	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemObjectSink *a_Sink
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Get (
		
			a_Service ,
			a_Flags ,
			a_Context ,
			a_Class ,
			a_Path ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_Set (

	WmiInternalContext a_InternalContext ,
	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_OldObject ,
	IWbemClassObject *a_NewObject  
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Set (
		
			a_Service ,
			a_Flags ,
			a_Context ,
			a_Provider ,
			a_Class ,
			a_Path ,
			a_OldObject ,
			a_NewObject  
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_Deleted (

	WmiInternalContext a_InternalContext ,
	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_Object  
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Deleted (
		
			a_Service ,
			a_Flags ,
			a_Context ,
			a_Provider ,
			a_Class ,
			a_Path ,
			a_Object  
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_Enumerate (

	WmiInternalContext a_InternalContext ,
	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	IWbemObjectSink *a_Sink
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Enumerate (
		
			a_Service ,
			a_Flags ,
			a_Context ,
			a_Class ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_Call (

	WmiInternalContext a_InternalContext ,
	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	LPCWSTR a_Method,
	IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Call (
		
			a_Service ,
			a_Flags ,
			a_Context ,
			a_Class ,
			a_Path ,
			a_Method,
			a_InParams,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_Query (

	WmiInternalContext a_InternalContext ,
	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
	WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
	VARIANT *a_Value 
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Query (
		
			a_Service ,
			a_Flags ,
			a_Context ,
			a_ClassIdentifier ,
			a_PropertyIdentifier ,
			a_Value 
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Internal_Shutdown (

	WmiInternalContext a_InternalContext ,
	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	ULONG a_MilliSeconds
)
{
#if DBG
	CheckThreadToken () ;
#endif

	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Shutdown (
		
			a_Service ,
			a_Flags ,
			a_Context ,
			a_Provider ,
			a_MilliSeconds
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: AdjustGetContext (

    IWbemContext *a_Context
)
{
    // See if per-property get are being used.
    // ========================================

    HRESULT t_Result = S_OK ;

    if ( a_Context )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		t_Result = a_Context->GetValue ( L"__GET_EXTENSIONS" , 0, & t_Variant ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			// If here, they are being used.  Next we have to check and see
			// if the reentrancy flag is set or not.
			// =============================================================

			VariantClear ( & t_Variant ) ;

			t_Result = a_Context->GetValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 , & t_Variant ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				
				VariantClear ( & t_Variant ) ;

				a_Context->DeleteValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 ) ;
			}
			else
			{
				// If here, we have to clear out the get extensions.
				// =================================================

				a_Context->DeleteValue ( L"__GET_EXTENSIONS" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_KEYS_ONLY" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_PROPERTIES" , 0 ) ;
			}
		}
	}

    return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: SetStatus ( 

	LPWSTR a_Operation ,
	LPWSTR a_Parameters ,
	LPWSTR a_Description ,
	HRESULT a_Result ,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	if ( m_ExtendedStatusObject )
	{
		IWbemClassObject *t_StatusObject ;
		t_Result = m_ExtendedStatusObject ->SpawnInstance ( 

			0 , 
			& t_StatusObject
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: Set_String ( t_StatusObject , L"Provider" , m_Registration->GetProviderName () ) ;

			if ( a_Operation ) 
			{
				ProviderSubSystem_Common_Globals :: Set_String ( t_StatusObject , L"Operation" , a_Operation ) ;
			}

			if ( a_Parameters ) 
			{
				ProviderSubSystem_Common_Globals :: Set_String ( t_StatusObject , L"ParameterInfo" , a_Parameters ) ;
			}

			if ( a_Description ) 
			{
				ProviderSubSystem_Common_Globals :: Set_String ( t_StatusObject , L"Description" , a_Description ) ;
			}

			_IWmiObject *t_FastStatusObject ;
			t_Result = t_StatusObject->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastStatusObject ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				ProviderSubSystem_Common_Globals :: Set_Uint32 ( t_FastStatusObject , L"StatusCode" , a_Result ) ;

				t_FastStatusObject->Release () ;
			}

			t_Result = a_Sink->SetStatus ( 0 , a_Result , L"Provider Subsystem Error Report" , t_StatusObject ) ;

			t_StatusObject->Release () ;
		}
		else
		{
			t_Result = a_Sink->SetStatus ( 0 , a_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = a_Sink->SetStatus ( 0 , a_Result , NULL , NULL ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Begin_IWbemServices (

	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IWbemServices *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalServiceHost:
		case e_Hosting_SharedNetworkServiceHost:
		case e_Hosting_SharedUserHost:
		{
			a_Interface = m_Provider_IWbemServices ;
			a_IsProxy = FALSE ;
		}
		break ;

		default:
		{
			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , a_Proxy , a_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					a_Interface = m_Provider_IWbemServices ;
					a_IsProxy = FALSE ;
					t_Result = S_OK ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						a_IsProxy = TRUE ;

						a_Interface = ( IWbemServices * ) a_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							a_Interface ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						if ( FAILED ( t_Result ) )
						{
							HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

								m_ProxyContainer , 
								ProxyIndex_IWbemServices , 
								a_Proxy , 
								a_Revert
							) ;
						}
					}
				}

				if ( FAILED ( t_Result ) )
				{
					ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
				}
			}
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: End_IWbemServices (

	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IWbemServices *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

			m_ProxyContainer , 
			ProxyIndex_IWbemServices , 
			a_Proxy , 
			a_Revert
		) ;
	}

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalServiceHost:
		case e_Hosting_SharedNetworkServiceHost:
		case e_Hosting_SharedUserHost:
		{
		}
		break ;

		default:
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
		break ;
	}
	
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Find ( 

			a_Sink ,
			t_Iterator
		) ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			ObjectSinkContainerElement *t_Element = t_Iterator.GetElement () ;

			UnLock () ;

			IWbemObjectSink *t_ObjectSink = NULL ;
			t_Result = t_Element->QueryInterface ( IID_IWbemObjectSink , ( void ** ) & t_ObjectSink ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_Impersonating ;
				IUnknown *t_OldContext ;
				IServerSecurity *t_OldSecurity ;
				BOOL t_IsProxy ;
				IWbemServices *t_Interface ;
				BOOL t_Revert ;
				IUnknown *t_Proxy ;

				t_Result = Begin_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Interface->CancelAsyncCall (

						t_ObjectSink
					) ;

					End_IWbemServices (

						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;
				}

				t_ObjectSink->Release () ;
			}

			IWbemShutdown *t_Shutdown = NULL ;
			HRESULT t_TempResult = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				t_TempResult = t_Shutdown->Shutdown ( 

					0 , 
					0 , 
					NULL 
				) ;

				t_Shutdown->Release () ;
			}

			t_Element->Release () ;
		}
		else
		{
			UnLock () ;

			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_GetObjectAsync (

	BOOL a_IsProxy ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
		if ( t_ObjectPath ) 
		{
			CInterceptor_IWbemSyncObjectSink_GetObjectAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_GetObjectAsync (

				m_Allocator ,
				a_Flags ,
				t_ObjectPath ,
				this ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				t_Dependant
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_GetObjectAsync () ;
							}

							Increment_ProviderOperation_GetObjectAsync () ;

							try	
							{
								t_Result = a_Service->GetObjectAsync (

 									t_ObjectPath ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_GetObjectAsync () ;
							}

							Increment_ProviderOperation_GetObjectAsync () ;

							if ( a_IsProxy )
							{
								t_Result = CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{
								try
								{
									t_Result = a_Service->GetObjectAsync (

 										t_ObjectPath ,
										a_Flags ,
										t_ContextCopy ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( FAILED ( t_Result ) )
					{
						HRESULT t_TempResult = SetStatus ( L"GetObjectAsync" , NULL , NULL , t_Result , t_Sink ) ;
					}
				}

				t_Sink->Release () ;
			}
			else
			{
				SysFreeString ( t_ObjectPath ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_HiPerfGetObjectAsync (

	IWbemHiPerfProvider *a_HighPerformanceProvider ,
 	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
    IWbemClassObject *t_Instance = NULL ;

#if 0
    HRESULT t_Result = m_CoreStub->CreateRefreshableObjectTemplate (

		a_ObjectPath , 
		a_Flags , 
		& t_Instance
	);
#else
	// Parse the path
	// ==============

	IWbemPath*	pPathParser = NULL;
	WCHAR*	pwszClassName = NULL;
	HRESULT t_Result = CoCreateInstance( CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER, IID_IWbemPath, (void**) &pPathParser );

	if ( SUCCEEDED( t_Result ) )
	{
		t_Result = pPathParser->SetText( WBEMPATH_CREATE_ACCEPT_ALL, a_ObjectPath );

		if ( SUCCEEDED( t_Result ) )
		{
			ULONG	uLength = 0;

			// Get the length of the name
			t_Result = pPathParser->GetClassName( &uLength, NULL );

			if ( SUCCEEDED( t_Result ) )
			{
				// Allocate memory and get it for real
				uLength++;
				pwszClassName = new WCHAR[uLength];

				if ( NULL != pwszClassName )
				{
					t_Result = pPathParser->GetClassName( &uLength, pwszClassName );
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY;
				}

			}	// IF Buffer too small

		}	// IF SetText

	}	// IF CoCreateInstance
	
	// Cleanup the parser and any allocated memory
	CReleaseMe	rmPP( pPathParser );
	CVectorDeleteMe<WCHAR>	vdm( pwszClassName );

	if ( FAILED( t_Result ) )
	{
		return t_Result;
	}

	// Get the class
	// =============

	IWbemClassObject* pClass = NULL;

	// Must use a BSTR in case the call gets marshaled
	BSTR	bstrClass = SysAllocString( pwszClassName );
	if ( NULL == bstrClass )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	CSysFreeMe	sfm( bstrClass );

	// Note that WBEM_FLAG_USE_AMENDED_QUALIFIERS is a valid flag
	t_Result = m_CoreStub->GetObject( bstrClass, 0L, NULL, &pClass, NULL);
	CReleaseMe	rmClass( pClass );

	if(FAILED(t_Result))
	{
		return WBEM_E_INVALID_CLASS;
	}

	_IWmiObject*	pWmiClass = NULL;
	t_Result = pClass->QueryInterface( IID__IWmiObject, (void**) &pWmiClass );
	CReleaseMe		rmObj( pWmiClass );

	// Get a Keyed instance and continue
	if ( SUCCEEDED( t_Result ) )
	{
		_IWmiObject*	pTempInst = NULL;

		t_Result = pWmiClass->SpawnKeyedInstance( 0L, a_ObjectPath, &pTempInst );
		CReleaseMe	rmTempInst( pTempInst );

		if ( SUCCEEDED( t_Result ) )
		{
			t_Result = pTempInst->QueryInterface( IID_IWbemClassObject, (void**) &t_Instance );
		}
	}
	
	CReleaseMe	rmInst( t_Instance );

#endif

    if ( SUCCEEDED ( t_Result ) )
    {
		try
		{
			t_Result = a_HighPerformanceProvider->GetObjects (

				m_CoreStub , 
				1 ,
				( IWbemObjectAccess ** ) & t_Instance , 
				0 ,
				a_Context
			) ;
		}
		catch ( ... )
		{
			t_Result = WBEM_E_PROVIDER_FAILURE ;
		}

		CoRevertToSelf () ;

        if ( SUCCEEDED ( t_Result ) && t_Instance )
        {
            a_Sink->Indicate ( 1 , & t_Instance ) ;
        }
        else
		{
			if ( 
				SUCCEEDED ( t_Result ) ||
				t_Result == WBEM_E_PROVIDER_NOT_CAPABLE ||
				t_Result == WBEM_E_METHOD_NOT_IMPLEMENTED ||
				t_Result == E_NOTIMPL ||
				t_Result == WBEM_E_NOT_SUPPORTED
			)
			{

				IWbemRefresher *t_Refresher = NULL ;

				try
				{
					t_Result = a_HighPerformanceProvider->CreateRefresher (
		
						m_CoreStub , 
						0 , 
						& t_Refresher
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;

				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemObjectAccess *t_Object = NULL ;
	                long t_Id = 0 ;

					try
					{
						t_Result = a_HighPerformanceProvider->CreateRefreshableObject (

							m_CoreStub , 
							( IWbemObjectAccess * ) t_Instance ,
							t_Refresher , 
							0, 
							a_Context , 
							& t_Object, 
							& t_Id
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}

					CoRevertToSelf () ;

					if ( SUCCEEDED ( t_Result ) )
					{
						try
						{
							t_Result = t_Refresher->Refresh ( 0 ) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;

						if ( SUCCEEDED( t_Result ) )
						{
							a_Sink->Indicate ( 1, ( IWbemClassObject ** ) & t_Object );
						}

						t_Object->Release () ;
					}

					t_Refresher->Release () ;
				}
			}
		}
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsGet () || m_Registration->GetClassProviderRegistration ().SupportsGet () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_GetObjectAsync ( 

					t_IsProxy ,
					a_ObjectPath ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}
	else
	{
		if ( m_Provider_IWbemHiPerfProvider )
		{
			t_Result = Helper_HiPerfGetObjectAsync (

				m_Provider_IWbemHiPerfProvider ,
 				a_ObjectPath ,
				a_Flags ,
				a_Context ,
				a_Sink
			) ;

			// Send back the final status
			a_Sink->SetStatus( WBEM_STATUS_COMPLETE, t_Result, NULL, NULL );
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_PutClassAsync (

	BOOL a_IsProxy ,
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CInterceptor_IWbemSyncObjectSink_PutClassAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_PutClassAsync (

			m_Allocator ,
			a_Flags ,
			a_Object ,
			this ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			t_Dependant
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( ProviderSubSystem_Globals :: GetSharedCounters () )
						{
							ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_PutClassAsync () ;
						}

						Increment_ProviderOperation_PutClassAsync () ;

						try
						{
							t_Result = a_Service->PutClassAsync (

 								a_Object ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_PutClassAsync () ;
							}

							Increment_ProviderOperation_PutClassAsync () ;

							try
							{
								t_Result = a_Service->PutClassAsync (

 									a_Object ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"PutClassAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsPut () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_PutClassAsync ( 

					t_IsProxy ,
					a_Object ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_DeleteClassAsync (

	BOOL a_IsProxy ,
	const BSTR a_Class , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		BSTR t_Class = SysAllocString ( a_Class ) ;
		if ( t_Class ) 
		{
			CInterceptor_IWbemSyncObjectSink_DeleteClassAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_DeleteClassAsync (

				m_Allocator ,
				a_Flags ,
				t_Class ,
				this ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				t_Dependant
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_DeleteClassAsync () ;
							}

							Increment_ProviderOperation_DeleteClassAsync () ;

							try
							{
								t_Result = a_Service->DeleteClassAsync (

 									t_Class ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							if ( a_IsProxy )
							{
								t_Result = CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{
								if ( ProviderSubSystem_Globals :: GetSharedCounters () )
								{
									ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_DeleteClassAsync () ;
								}

								Increment_ProviderOperation_DeleteClassAsync () ;

								try
								{
									t_Result = a_Service->DeleteClassAsync (

 										t_Class ,
										a_Flags ,
										t_ContextCopy ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( FAILED ( t_Result ) )
					{
						HRESULT t_TempResult = SetStatus ( L"DeleteClassAsync" , NULL , NULL , t_Result , t_Sink ) ;
					}
				}

				t_Sink->Release () ;
			}
			else
			{
				SysFreeString ( t_Class ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: DeleteClassAsync ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsDelete () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_DeleteClassAsync ( 

					t_IsProxy ,
					a_Class ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_CreateClassEnumAsync (

	BOOL a_IsProxy ,
	const BSTR a_SuperClass , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		BSTR t_SuperClass = SysAllocString ( a_SuperClass ) ;
		if ( t_SuperClass ) 
		{
			CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync (

				m_Allocator ,
				a_Flags ,
				t_SuperClass ,
				this ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				t_Dependant
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CreateClassEnumAsync () ;
							}

							Increment_ProviderOperation_CreateClassEnumAsync () ;

							try
							{
								t_Result = a_Service->CreateClassEnumAsync (

 									t_SuperClass ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							if ( a_IsProxy )
							{
								t_Result = CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{
								if ( ProviderSubSystem_Globals :: GetSharedCounters () )
								{
									ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CreateClassEnumAsync () ;
								}

								Increment_ProviderOperation_CreateClassEnumAsync () ;

								try
								{
									t_Result = a_Service->CreateClassEnumAsync (

 										t_SuperClass ,
										a_Flags ,
										t_ContextCopy ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( FAILED ( t_Result ) )
					{
						HRESULT t_TempResult = SetStatus ( L"CreateClassEnumAsync" , NULL , NULL , t_Result , t_Sink ) ;
					}
				}

				t_Sink->Release () ;
			}
			else
			{
				SysFreeString ( t_SuperClass ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: CreateClassEnumAsync ( 
		
	const BSTR a_SuperClass , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsEnumeration () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_CreateClassEnumAsync ( 

					t_IsProxy ,
					a_SuperClass ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: PutInstance (

    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_PutInstanceAsync (

	BOOL a_IsProxy ,
	IWbemClassObject *a_Instance ,
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CInterceptor_IWbemSyncObjectSink_PutInstanceAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_PutInstanceAsync (

			m_Allocator ,
			a_Flags ,
			a_Instance ,
			this ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			t_Dependant
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) ) 
					{
						if ( ProviderSubSystem_Globals :: GetSharedCounters () )
						{
							ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_PutInstanceAsync () ;
						}

						Increment_ProviderOperation_PutInstanceAsync () ;

						try
						{
							t_Result = a_Service->PutInstanceAsync (

 								a_Instance ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_PutInstanceAsync () ;
							}

							Increment_ProviderOperation_PutInstanceAsync () ;

							try
							{
								t_Result = a_Service->PutInstanceAsync (

 									a_Instance ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"PutInstanceAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsPut () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_PutInstanceAsync ( 

					t_IsProxy ,
					a_Instance ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: DeleteInstance ( 

	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_DeleteInstanceAsync (

	BOOL a_IsProxy ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
		if ( t_ObjectPath ) 
		{
			CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync (

				m_Allocator ,
				a_Flags ,
				t_ObjectPath ,
				this ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				t_Dependant
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_DeleteInstanceAsync () ;
							}

							Increment_ProviderOperation_DeleteInstanceAsync () ;

							try
							{
								t_Result = a_Service->DeleteInstanceAsync (

 									t_ObjectPath ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							if ( a_IsProxy )
							{
								t_Result = CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{
								if ( ProviderSubSystem_Globals :: GetSharedCounters () )
								{
									ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_DeleteInstanceAsync () ;
								}

								Increment_ProviderOperation_DeleteInstanceAsync () ;

								try
								{
									t_Result = a_Service->DeleteInstanceAsync (

 										t_ObjectPath ,
										a_Flags ,
										t_ContextCopy ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( FAILED ( t_Result ) )
					{
						HRESULT t_TempResult = SetStatus ( L"DeleteInstanceAsync" , NULL , NULL , t_Result , t_Sink ) ;
					}
				}

				t_Sink->Release () ;
			}
			else
			{
				SysFreeString ( t_ObjectPath ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: DeleteInstanceAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsDelete () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_DeleteInstanceAsync ( 

					t_IsProxy ,
					a_ObjectPath ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: CreateInstanceEnum ( 

	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_CreateInstanceEnumAsync (

	BOOL a_IsProxy ,
 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;

			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		BSTR t_Class = SysAllocString ( a_Class ) ;
		if ( t_Class ) 
		{
			CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync (

				m_Allocator ,
				a_Flags ,
				t_Class ,
				this ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				t_Dependant
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CreateInstanceEnumAsync () ;
							}

							Increment_ProviderOperation_CreateInstanceEnumAsync () ;

							try
							{
								t_Result = a_Service->CreateInstanceEnumAsync (

 									t_Class ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;

#if DBG
								CheckThreadToken () ;
#endif

							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							if ( a_IsProxy )
							{
								t_Result = CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

								if ( ProviderSubSystem_Globals :: GetSharedCounters () )
								{
									ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CreateInstanceEnumAsync () ;
								}

								Increment_ProviderOperation_CreateInstanceEnumAsync () ;

								try
								{
									t_Result = a_Service->CreateInstanceEnumAsync (

 										t_Class ,
										a_Flags ,
										t_ContextCopy ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"CreateInstanceEnumAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				SysFreeString ( t_Class ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_QueryInstancesAsync (

	IWbemHiPerfProvider *a_PerformanceProvider ,
 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
	HRESULT t_Result = S_OK ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;

			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CInterceptor_IWbemSyncObjectSink *t_Sink = new CInterceptor_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			t_Dependant
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					BSTR t_Class = SysAllocString ( a_Class ) ;
					if ( t_Class ) 
					{
						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( ProviderSubSystem_Globals :: GetSharedCounters () )
						{
							ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_QueryInstances () ;
						}

						Increment_ProviderOperation_QueryInstances () ;

						try
						{
							t_Result = a_PerformanceProvider->QueryInstances (

								m_CoreStub ,
								a_Class, 
								a_Flags, 
								a_Context, 
								t_Sink
							) ;
						}
						catch ( ... ) 
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_QueryInstances () ;
							}

							Increment_ProviderOperation_QueryInstances () ;

							try
							{
								a_PerformanceProvider->QueryInstances (

									m_CoreStub,
									a_Class, 
									a_Flags, 
									a_Context, 
									t_Sink
								) ;
							}
							catch ( ... ) 
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}

						SysFreeString ( t_Class ) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#if 0

HRESULT CInterceptor_IWbemSyncProvider :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () )
		{
			BOOL t_Impersonating = FALSE ;
			IServerSecurity *t_Security = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_Security , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = Helper_CreateInstanceEnumAsync ( 

						FALSE ,
						a_Class ,
						a_Flags , 
						a_Context ,
						a_Sink ,
						m_Provider_IWbemServices
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = Helper_CreateInstanceEnumAsync ( 

								TRUE ,
								a_Class ,
								a_Flags , 
								a_Context ,
								a_Sink ,
								t_Provider
							) ;
						}

						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_Security , t_Impersonating ) ;
			}
		}
	}
	else
	{
		if ( m_Provider_IWbemHiPerfProvider )
		{
			t_Result = Helper_QueryInstancesAsync ( 

				m_Provider_IWbemHiPerfProvider ,
				a_Class ,
				a_Flags , 
				a_Context ,
				a_Sink
			) ;
		}
	}

	return t_Result ;
}

#else

HRESULT CInterceptor_IWbemSyncProvider :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_CreateInstanceEnumAsync ( 

					t_IsProxy ,
					a_Class ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}
	else
	{
		if ( m_Provider_IWbemHiPerfProvider )
		{
			t_Result = Helper_QueryInstancesAsync ( 

				m_Provider_IWbemHiPerfProvider ,
				a_Class ,
				a_Flags , 
				a_Context ,
				a_Sink
			) ;
		}
	}

	return t_Result ;
}

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ExecQuery ( 

	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_ExecQueryAsync (

	BOOL a_IsProxy ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Context )
		{
			t_Result = a_Context->Clone ( & t_ContextCopy ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = S_OK ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		if ( ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_UnarySelect ) ||  ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_V1ProviderDefined ) ) 
		{
			BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
			BSTR t_Query = SysAllocString ( a_Query ) ;

			if ( t_QueryLanguage && t_Query ) 
			{
				CInterceptor_IWbemSyncObjectSink_ExecQueryAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_ExecQueryAsync (

					m_Allocator ,
					a_Flags ,
					t_QueryLanguage ,
					t_Query ,
					this ,
					a_Sink , 
					( IWbemServices * ) this , 
					( CWbemGlobal_IWmiObjectSinkController * ) this ,
					t_Dependant
				) ;

#if 0
				CInterceptor_IWbemSyncFilteringObjectSink *t_Sink = new CInterceptor_IWbemSyncFilteringObjectSink (

					a_Sink , 
					( IWbemServices * ) this , 
					( CWbemGlobal_IWmiObjectSinkController * ) this ,
					a_QueryLanguage ,
					a_Query ,
					t_Dependant
				) ;
#endif

				if ( t_Sink )
				{
					t_Sink->AddRef () ;

					t_Result = t_Sink->SinkInitialize () ;
					if ( SUCCEEDED ( t_Result ) )
					{
						CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

						Lock () ;

						WmiStatusCode t_StatusCode = Insert ( 

							*t_Sink ,
							t_Iterator
						) ;

						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							UnLock () ;

							if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
							{
								a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
							}

							if ( a_IsProxy )
							{
								t_Result = CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								if ( ProviderSubSystem_Globals :: GetSharedCounters () )
								{
									ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_ExecQueryAsync () ;
								}

								Increment_ProviderOperation_ExecQueryAsync () ;

								try
								{
									t_Result = a_Service->ExecQueryAsync (

										t_QueryLanguage ,
										t_Query, 
										a_Flags ,
										t_ContextCopy ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}

							if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
							{
								a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

								if ( a_IsProxy )
								{
									t_Result = CoImpersonateClient () ;
								}
								else
								{
									t_Result = S_OK ;
								}

								if ( SUCCEEDED ( t_Result ) ) 
								{
									if ( ProviderSubSystem_Globals :: GetSharedCounters () )
									{
										ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_ExecQueryAsync () ;
									}

									Increment_ProviderOperation_ExecQueryAsync () ;

									try
									{
										t_Result = a_Service->ExecQueryAsync (

											t_QueryLanguage ,
											t_Query, 
											a_Flags ,
											t_ContextCopy ,
											t_Sink 
										) ;
									}
									catch ( ... )
									{
										t_Result = WBEM_E_PROVIDER_FAILURE ;
									}

									CoRevertToSelf () ;
								}
								else
								{
									t_Result = WBEM_E_ACCESS_DENIED ;
								}
							}
						}
						else
						{
							UnLock () ;

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

						if ( FAILED ( t_Result ) )
						{
							HRESULT t_TempResult = SetStatus ( L"ExecQueryAsync" , NULL , NULL , t_Result , t_Sink ) ;
						}
					}

					t_Sink->Release () ;
				}
				else
				{
					SysFreeString ( t_Query ) ;
					SysFreeString ( t_QueryLanguage ) ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else if ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () )
		{
			IWbemQuery *t_QueryFilter = NULL ;
			t_Result = ProviderSubSystem_Common_Globals :: CreateInstance	(

				CLSID_WbemQuery ,
				NULL ,
				CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
				IID_IWbemQuery ,
				( void ** ) & t_QueryFilter
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_QueryFilter->Parse ( 

					a_QueryLanguage ,
					a_Query , 
					0 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					SWbemRpnEncodedQuery *t_Expression = NULL ;

					t_Result = t_QueryFilter->GetAnalysis (

						WMIQ_ANALYSIS_RPN_SEQUENCE ,
						0 ,
						( void ** ) & t_Expression
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_Expression->m_uFromTargetType == WMIQ_RPN_FROM_UNARY )
						{
							BSTR t_Class = SysAllocString ( t_Expression->m_ppszFromList [ 0 ] ) ;
							if ( t_Class )
							{
								CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync (

									m_Allocator ,
									a_Flags ,
									t_Class ,
									this ,
									a_Sink , 
									( IWbemServices * ) this , 
									( CWbemGlobal_IWmiObjectSinkController * ) this ,
									t_Dependant
								) ;

								if ( t_Sink )
								{
									t_Sink->AddRef () ;

									t_Result = t_Sink->SinkInitialize () ;
									if ( SUCCEEDED ( t_Result ) )
									{
										a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , 0 , NULL , NULL ) ;

										CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

										Lock () ;

										WmiStatusCode t_StatusCode = Insert ( 

											*t_Sink ,
											t_Iterator
										) ;

										if ( t_StatusCode == e_StatusCode_Success ) 
										{
											UnLock () ;

											if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
											{
												a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
											}

											if ( a_IsProxy )
											{
												t_Result = CoImpersonateClient () ;
											}
											else
											{
												t_Result = S_OK ;
											}

											if ( SUCCEEDED ( t_Result ) )
											{
												a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , 0 , NULL , NULL ) ;

												if ( ProviderSubSystem_Globals :: GetSharedCounters () )
												{
													ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CreateInstanceEnumAsync () ;
												}

												Increment_ProviderOperation_CreateInstanceEnumAsync () ;

												try
												{
													t_Result = a_Service->CreateInstanceEnumAsync (

 														t_Class ,
														a_Flags ,
														t_ContextCopy ,
														t_Sink 
													) ;
												}
												catch ( ... )
												{
													t_Result = WBEM_E_PROVIDER_FAILURE ;
												}
				
												CoRevertToSelf () ;
											}
											else
											{
												t_Result = WBEM_E_ACCESS_DENIED ;
											}

											if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
											{
												a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

												if ( a_IsProxy )
												{
													t_Result = CoImpersonateClient () ;
												}
												else
												{
													t_Result = S_OK ;
												}

												if ( SUCCEEDED ( t_Result ) ) 
												{
													if ( ProviderSubSystem_Globals :: GetSharedCounters () )
													{
														ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CreateInstanceEnumAsync () ;
													}

													Increment_ProviderOperation_CreateInstanceEnumAsync () ;

													try
													{
														t_Result = a_Service->CreateInstanceEnumAsync (

 															t_Class ,
															a_Flags ,
															t_ContextCopy ,
															t_Sink 
														) ;
													}
													catch ( ... )
													{
														t_Result = WBEM_E_PROVIDER_FAILURE ;
													}
					
													CoRevertToSelf () ;
												}
												else
												{
													t_Result = WBEM_E_ACCESS_DENIED ;
												}
											}
										}
										else
										{
											t_Result = WBEM_E_OUT_OF_MEMORY ;
										}
									}

									if ( FAILED ( t_Result ) )
									{
										HRESULT t_TempResult = SetStatus ( L"CreateInstanceEnumAsync" , NULL , NULL , t_Result , t_Sink ) ;
									}

                                    t_Sink->Release () ;
								}
								else
								{
									SysFreeString ( t_Class ) ;

									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = WBEM_E_NOT_SUPPORTED ;
						}

						t_QueryFilter->FreeMemory ( t_Expression ) ;
					}
					else
					{
						t_Result = WBEM_E_UNEXPECTED ;
					}
				}
				else
				{
					t_Result = WBEM_E_NOT_SUPPORTED ;
				}

				t_QueryFilter->Release () ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_SUPPORTED ;
		}
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_UnarySelect ) || ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_V1ProviderDefined ) || ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () ) )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_ExecQueryAsync ( 

					t_IsProxy ,
					a_QueryLanguage ,
					a_Query, 
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}
	else
	{
		if ( m_Provider_IWbemHiPerfProvider )
		{
			IWbemQuery *t_QueryFilter = NULL ;
			t_Result = ProviderSubSystem_Common_Globals :: CreateInstance	(

				CLSID_WbemQuery ,
				NULL ,
				CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
				IID_IWbemQuery ,
				( void ** ) & t_QueryFilter
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_QueryFilter->Parse ( 

					a_QueryLanguage ,
					a_Query , 
					0 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					SWbemRpnEncodedQuery *t_Expression = NULL ;

					t_Result = t_QueryFilter->GetAnalysis (

						WMIQ_ANALYSIS_RPN_SEQUENCE ,
						0 ,
						( void ** ) & t_Expression
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_Expression->m_uFromTargetType == WMIQ_RPN_FROM_UNARY )
						{
							BSTR t_Class = SysAllocString ( t_Expression->m_ppszFromList [ 0 ] ) ;
							if ( t_Class )
							{
								a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , 0 , NULL , NULL ) ;

								t_Result = Helper_QueryInstancesAsync ( 

									m_Provider_IWbemHiPerfProvider ,
									t_Class ,
									a_Flags , 
									a_Context ,
									a_Sink
								) ;

								SysFreeString ( t_Class ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = WBEM_E_NOT_SUPPORTED ;
						}

						t_QueryFilter->FreeMemory ( t_Expression ) ;
					}
					else
					{
						t_Result = WBEM_E_UNEXPECTED ;
					}
				}
				else
				{
					t_Result = WBEM_E_NOT_SUPPORTED ;
				}

				t_QueryFilter->Release () ;
			}
		}
		else
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemSyncProvider :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ExecMethod (

	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Helper_ExecMethodAsync (

	BOOL a_IsProxy ,
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
		BSTR t_MethodName = SysAllocString ( a_MethodName ) ;
		if ( t_ObjectPath && t_MethodName ) 
		{
			CInterceptor_IWbemSyncObjectSink_ExecMethodAsync *t_Sink = new CInterceptor_IWbemSyncObjectSink_ExecMethodAsync (

				m_Allocator ,
				a_Flags ,
				t_ObjectPath ,
				t_MethodName ,
				a_InParams ,
				this ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				t_Dependant
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_ExecMethodAsync () ;
							}

							Increment_ProviderOperation_ExecMethodAsync () ;

							try
							{
								t_Result = a_Service->ExecMethodAsync (

 									t_ObjectPath ,
									t_MethodName ,
									a_Flags ,
									t_ContextCopy ,
									a_InParams ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							if ( a_IsProxy )
							{
								t_Result = CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{
								if ( ProviderSubSystem_Globals :: GetSharedCounters () )
								{
									ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_ExecMethodAsync () ;
								}

								Increment_ProviderOperation_ExecMethodAsync () ;

								try
								{
									t_Result = a_Service->ExecMethodAsync (

 										t_ObjectPath ,
										t_MethodName ,
										a_Flags ,
										t_ContextCopy ,
										a_InParams ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( FAILED ( t_Result ) )
					{
						HRESULT t_TempResult = SetStatus ( L"ExecMethodAsync" , NULL , NULL , t_Result , t_Sink ) ;
					}
				}

				t_Sink->Release () ;
			}
			else
			{
				SysFreeString ( t_ObjectPath ) ;
				SysFreeString ( t_MethodName ) ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ExecMethodAsync ( 
		
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
#if DBG
	CheckThreadToken () ;
#endif

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetMethodProviderRegistration ().SupportsMethods () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_ExecMethodAsync ( 

					t_IsProxy ,
					a_ObjectPath ,
					a_MethodName ,
					a_Flags ,
					a_Context ,
					a_InParams ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: GetProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		if ( m_Registration->GetPropertyProviderRegistration ().SupportsGet () )
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_GetProperty () ;
			}

			Increment_ProviderOperation_GetProperty () ;

			HRESULT t_Result = S_OK ;

			try
			{
				t_Result = m_Provider_IWbemPropertyProvider->GetProperty ( 

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;

				CoRevertToSelf () ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;

				CoRevertToSelf () ;
			}

			return t_Result ;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: PutProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		if ( m_Registration->GetPropertyProviderRegistration ().SupportsPut () )
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_PutProperty () ;
			}

			Increment_ProviderOperation_PutProperty () ;

			HRESULT t_Result = S_OK ;

			try
			{
				t_Result = m_Provider_IWbemPropertyProvider->PutProperty ( 

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;

				CoRevertToSelf () ;

				return t_Result ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;

				CoRevertToSelf () ;
			}

			return t_Result ;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	if ( m_Provider_IWbemEventProvider )
	{
		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ProvideEvents_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Namespace ,
			m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_User ,
			m_Locale ,
			m_TransactionIdentifier ,
			a_Flags
		) ;

		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProvider , IID_IWbemEventProvider , m_Provider_IWbemEventProvider , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				if ( ProviderSubSystem_Globals :: GetSharedCounters () )
				{
					ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_ProvideEvents () ;
				}

				Increment_ProviderOperation_ProvideEvents () ;

				try
				{
					t_Result = m_Provider_IWbemEventProvider->ProvideEvents (

						a_Sink ,
						a_Flags 
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProvider *t_Provider = ( IWbemEventProvider * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_ProvideEvents () ;
							}

							Increment_ProviderOperation_ProvideEvents () ;

							try
							{
								t_Result = t_Provider->ProvideEvents (

									a_Sink ,
									a_Flags 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProvider , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_ProvideEvents_Post ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Namespace ,
			m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_User ,
			m_Locale ,
			m_TransactionIdentifier ,
			a_Flags ,
			t_Result 
		) ;

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_NewQuery_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Namespace ,
			m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_User ,
			m_Locale ,
			m_TransactionIdentifier ,
			a_Id ,
			a_QueryLanguage ,
			a_Query 
		) ;

		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				if ( ProviderSubSystem_Globals :: GetSharedCounters () )
				{
					ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_NewQuery () ;
				}

				Increment_ProviderOperation_NewQuery () ;

				try
				{
					t_Result = m_Provider_IWbemEventProviderQuerySink->NewQuery (

						a_Id ,
						a_QueryLanguage ,
						a_Query
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_NewQuery () ;
							}

							Increment_ProviderOperation_NewQuery () ;

							try
							{
								t_Result = t_Provider->NewQuery (

									a_Id ,
									a_QueryLanguage ,
									a_Query
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_NewQuery_Post ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Namespace ,
			m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_User ,
			m_Locale ,
			m_TransactionIdentifier ,
			a_Id ,
			a_QueryLanguage ,
			a_Query ,
			t_Result 
		) ;

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::CancelQuery (

	unsigned long a_Id
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_CancelQuery_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Namespace ,
			m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_User ,
			m_Locale ,
			m_TransactionIdentifier ,
			a_Id
		) ;

		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				if ( ProviderSubSystem_Globals :: GetSharedCounters () )
				{
					ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CancelQuery () ;
				}

				Increment_ProviderOperation_CancelQuery () ;

				try
				{
					t_Result = m_Provider_IWbemEventProviderQuerySink->CancelQuery (

						a_Id
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CancelQuery () ;
							}

							Increment_ProviderOperation_CancelQuery () ;

							try
							{
								t_Result = t_Provider->CancelQuery (

									a_Id
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_CancelQuery_Post ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Namespace ,
			m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_User ,
			m_Locale ,
			m_TransactionIdentifier ,
			a_Id ,
			t_Result 
		) ;

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	if ( m_Provider_IWbemEventProviderSecurity )
	{
		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_AccessCheck_Pre ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Namespace ,
			m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_User ,
			m_Locale ,
			m_TransactionIdentifier ,
			a_QueryLanguage ,
			a_Query ,
			a_Sid,
 			a_SidLength 
		) ;

		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderSecurity , IID_IWbemEventProviderSecurity , m_Provider_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				if ( ProviderSubSystem_Globals :: GetSharedCounters () )
				{
					ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_AccessCheck () ;
				}

				Increment_ProviderOperation_AccessCheck () ;

				try
				{
					t_Result = m_Provider_IWbemEventProviderSecurity->AccessCheck (

						a_QueryLanguage ,
						a_Query ,
						a_SidLength ,
						a_Sid
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProviderSecurity *t_Provider = ( IWbemEventProviderSecurity * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_AccessCheck () ;
							}

							Increment_ProviderOperation_AccessCheck () ;

							try
							{
								t_Result = t_Provider->AccessCheck (

									a_QueryLanguage ,
									a_Query ,
									a_SidLength ,
									a_Sid
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		WmiSetAndCommitObject (

			ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_AccessCheck_Post ] , 
			WMI_SENDCOMMIT_SET_NOT_REQUIRED,
			m_Namespace ,
			m_Registration->GetComRegistration ().GetClsidServer ().GetProviderName () ,
			m_User ,
			m_Locale ,
			m_TransactionIdentifier ,
			a_QueryLanguage ,
			a_Query ,
			a_Sid ,
			a_SidLength
		) ;

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::SetRegistrationObject (

	long a_Flags ,
	IWbemClassObject *a_ProviderRegistration
)
{
	if ( m_Provider_IWbemProviderIdentity )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemProviderIdentity , IID_IWbemProviderIdentity , m_Provider_IWbemProviderIdentity , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				if ( ProviderSubSystem_Globals :: GetSharedCounters () )
				{
					ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_SetRegistrationObject () ;
				}

				Increment_ProviderOperation_SetRegistrationObject () ;

				try
				{
					t_Result = m_Provider_IWbemProviderIdentity->SetRegistrationObject (

						a_Flags ,
						a_ProviderRegistration
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemProviderIdentity *t_Provider = ( IWbemProviderIdentity * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_SetRegistrationObject () ;
							}

							Increment_ProviderOperation_SetRegistrationObject () ;

							try
							{
								t_Result = t_Provider->SetRegistrationObject (

									a_Flags ,
									a_ProviderRegistration
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemProviderIdentity , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	if ( m_Provider_IWbemEventConsumerProvider )
	{
		IWbemUnboundObjectSink *t_Consumer = NULL ;

		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProvider , IID_IWbemEventConsumerProvider , m_Provider_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				if ( ProviderSubSystem_Globals :: GetSharedCounters () )
				{
					ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_FindConsumer () ;
				}

				Increment_ProviderOperation_FindConsumer () ;

				try
				{
					t_Result = m_Provider_IWbemEventConsumerProvider->FindConsumer (

						a_LogicalConsumer ,
						& t_Consumer
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventConsumerProvider *t_Provider = ( IWbemEventConsumerProvider * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_FindConsumer () ;
							}

							Increment_ProviderOperation_FindConsumer () ;

							try
							{
								t_Result = t_Provider->FindConsumer (

									a_LogicalConsumer ,
									& t_Consumer
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( a_Consumer )
			{
				CInterceptor_IWbemSyncUnboundObjectSink *t_UnboundObjectSink = new CInterceptor_IWbemSyncUnboundObjectSink (

						m_Allocator ,
						t_Consumer , 
						this ,
						*m_Registration
				) ;

				if ( t_UnboundObjectSink )
				{
					t_UnboundObjectSink->AddRef () ;

					t_Result = t_UnboundObjectSink->Initialize () ;
					if ( SUCCEEDED ( t_Result ) )
					{
						CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

						Lock () ;

						WmiStatusCode t_StatusCode = Insert ( 

							*t_UnboundObjectSink ,
							t_Iterator
						) ;

						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							UnLock () ;

							*a_Consumer = t_UnboundObjectSink ;

							t_UnboundObjectSink->AddRef () ;
						}
						else
						{
							UnLock () ;

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_UnboundObjectSink->Release () ;
				}
			}
		}

		if ( t_Consumer )
		{
			t_Consumer->Release () ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProviderEx , IID_IWbemEventConsumerProviderEx , m_Provider_IWbemEventConsumerProviderEx , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				if ( ProviderSubSystem_Globals :: GetSharedCounters () )
				{
					ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_ValidateSubscription () ;
				}

				Increment_ProviderOperation_ValidateSubscription () ;

				try
				{
					t_Result = m_Provider_IWbemEventConsumerProviderEx->ValidateSubscription (

						a_LogicalConsumer
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventConsumerProviderEx *t_Provider = ( IWbemEventConsumerProviderEx * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( ProviderSubSystem_Globals :: GetSharedCounters () )
							{
								ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_ValidateSubscription () ;
							}

							Increment_ProviderOperation_ValidateSubscription () ;

							try
							{
								t_Result = t_Provider->ValidateSubscription (

									a_LogicalConsumer
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProviderEx , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemUnboundObjectSink , IID_IWbemUnboundObjectSink , m_Provider_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Provider_IWbemUnboundObjectSink->IndicateToConsumer (


					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemUnboundObjectSink *t_Provider = ( IWbemUnboundObjectSink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Provider->IndicateToConsumer (

							a_LogicalConsumer ,
							a_ObjectCount ,
							a_Objects
						) ;
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::QueryInstances (

	IWbemServices *a_Namespace ,
	WCHAR *a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
)
{
	if ( m_Provider_IWbemHiPerfProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_QueryInstances () ;
			}

			Increment_ProviderOperation_QueryInstances () ;

			try
			{
				t_Result = m_Provider_IWbemHiPerfProvider->QueryInstances (

					a_Namespace ,
					a_Class ,
					a_Flags ,
					a_Context ,
					a_Sink
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			CoRevertToSelf () ;

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

			return t_Result;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::CreateRefresher (

	IWbemServices *a_Namespace ,
	long a_Flags ,
	IWbemRefresher **a_Refresher
)
{
	if ( m_Provider_IWbemHiPerfProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CreateRefresher () ;
			}

			Increment_ProviderOperation_CreateRefresher () ;

			try
			{
				t_Result = m_Provider_IWbemHiPerfProvider->CreateRefresher (

					a_Namespace ,
					a_Flags ,
					a_Refresher
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			CoRevertToSelf () ;

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

			return t_Result;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
} 

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::CreateRefreshableObject (

	IWbemServices *a_Namespace ,
	IWbemObjectAccess *a_Template ,
	IWbemRefresher *a_Refresher ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectAccess **a_Refreshable ,
	long *a_Id
)
{
	if ( m_Provider_IWbemHiPerfProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CreateRefreshableObject () ;
			}

			Increment_ProviderOperation_CreateRefreshableObject () ;

			try
			{
				t_Result = m_Provider_IWbemHiPerfProvider->CreateRefreshableObject (

					a_Namespace ,
					a_Template ,
					a_Refresher ,
					a_Flags ,
					a_Context ,
					a_Refreshable ,
					a_Id
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			CoRevertToSelf () ;

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

			return t_Result;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::StopRefreshing (

	IWbemRefresher *a_Refresher ,
	long a_Id ,
	long a_Flags
)
{
	if ( m_Provider_IWbemHiPerfProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_StopRefreshing () ;
			}

			Increment_ProviderOperation_StopRefreshing () ;

			try
			{
				t_Result = m_Provider_IWbemHiPerfProvider->StopRefreshing (

					a_Refresher ,
					a_Id ,
					a_Flags
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			CoRevertToSelf () ;

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

			return t_Result;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::CreateRefreshableEnum (

	IWbemServices *a_Namespace ,
	LPCWSTR a_Class ,
	IWbemRefresher *a_Refresher ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemHiPerfEnum *a_HiPerfEnum ,
	long *a_Id
)
{
	if ( m_Provider_IWbemHiPerfProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_CreateRefreshableEnum () ;
			}

			Increment_ProviderOperation_CreateRefreshableEnum () ;

			try
			{
				t_Result = m_Provider_IWbemHiPerfProvider->CreateRefreshableEnum (

					a_Namespace ,
					a_Class ,
					a_Refresher ,
					a_Flags ,
					a_Context ,
					a_HiPerfEnum ,
					a_Id
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			CoRevertToSelf () ;

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

			return t_Result;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider ::GetObjects (

	IWbemServices *a_Namespace ,
	long a_ObjectCount ,
	IWbemObjectAccess **a_Objects ,
	long a_Flags ,
	IWbemContext *a_Context
)
{
	if ( m_Provider_IWbemHiPerfProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			if ( ProviderSubSystem_Globals :: GetSharedCounters () )
			{
				ProviderSubSystem_Globals :: GetSharedCounters ()->Increment_ProviderOperation_GetObjects () ;
			}

			Increment_ProviderOperation_GetObjects () ;

			try
			{
				t_Result = m_Provider_IWbemHiPerfProvider->GetObjects (

					a_Namespace ,
					a_ObjectCount ,
					a_Objects ,
					a_Flags ,
					a_Context
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}

			CoRevertToSelf () ;

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;

			return t_Result;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Get (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	if ( _wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
	{
		IWbemClassObject *t_Object = NULL ;

		BSTR t_Class = SysAllocString ( a_Class ) ;
		if ( t_Class ) 
		{
			t_Result = a_Service->GetObject (

				t_Class ,
				0 ,
				a_Context ,
				& t_Object ,
				NULL 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemClassObject *t_Instance = NULL ;
				t_Result = t_Object->SpawnInstance ( 

					0 , 
					& t_Instance 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					_IWmiObject *t_FastObject = NULL ;
					t_Instance->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastObject ) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_GetObjectAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_GetObjectAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_PutClassAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_PutClassAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_DeleteClassAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_DeleteClassAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateClassEnumAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_CreateClassEnumAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_PutInstanceAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_PutInstanceAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateInstanceEnumAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_CreateInstanceEnumAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ExecQueryAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_ExecQueryAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ExecNotificationQueryAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_ExecNotificationQueryAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_DeleteInstanceAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_DeleteInstanceAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ExecMethodAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_ExecMethodAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_QueryInstances" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_QueryInstances
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateRefresher" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_CreateRefresher
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateRefreshableObject" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_CreateRefreshableObject
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_StopRefreshing" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_StopRefreshing
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateRefreshableEnum" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_CreateRefreshableEnum
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_GetObjects" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_GetObjects
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_GetProperty" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_GetProperty
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_PutProperty" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_PutProperty
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ProvideEvents" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_ProvideEvents
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_NewQuery" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_NewQuery
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CancelQuery" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_CancelQuery
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_AccessCheck" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_AccessCheck
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_SetRegistrationObject" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_SetRegistrationObject
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_FindConsumer" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_FindConsumer
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ValidateSubscription" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_ValidateSubscription
					) ;

					t_FastObject->Release () ;

					VARIANT t_VariantProcessIdentifier ;
					VariantInit ( & t_VariantProcessIdentifier ) ;
					t_VariantProcessIdentifier.vt = VT_I4 ;
					t_VariantProcessIdentifier.lVal = GetCurrentProcessId () ;
					t_Instance->Put ( L"HostProcessIdentifier" , 0 , & t_VariantProcessIdentifier , 0 ) ;
					VariantClear ( & t_VariantProcessIdentifier ) ;

					t_Result = a_Sink->Indicate ( 1 , & t_Instance ) ;

					t_Instance->Release () ;
				}

				t_Object->Release () ;
			}

			SysFreeString ( t_Class ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_CLASS ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Set (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_OldObject ,
	IWbemClassObject *a_NewObject  
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Deleted (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_Object  
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Enumerate (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	if ( _wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
	{
		IWbemClassObject *t_Object = NULL ;

		BSTR t_Class = SysAllocString ( a_Class ) ;
		if ( t_Class ) 
		{
			t_Result = a_Service->GetObject (

				t_Class ,
				0 ,
				a_Context ,
				& t_Object ,
				NULL 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemClassObject *t_Instance = NULL ;
				t_Result = t_Object->SpawnInstance ( 

					0 , 
					& t_Instance 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					_IWmiObject *t_FastObject = NULL ;
					t_Instance->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastObject ) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_GetObjectAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_GetObjectAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_PutClassAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_PutClassAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_DeleteClassAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_DeleteClassAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateClassEnumAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_CreateClassEnumAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_PutInstanceAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_PutInstanceAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateInstanceEnumAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_CreateInstanceEnumAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ExecQueryAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_ExecQueryAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ExecNotificationQueryAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_ExecNotificationQueryAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_DeleteInstanceAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_DeleteInstanceAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ExecMethodAsync" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64 , 
						& m_ProviderOperation_ExecMethodAsync
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_QueryInstances" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_QueryInstances
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateRefresher" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_CreateRefresher
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateRefreshableObject" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_CreateRefreshableObject
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_StopRefreshing" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_StopRefreshing
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CreateRefreshableEnum" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_CreateRefreshableEnum
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_GetObjects" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_GetObjects
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_GetProperty" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_GetProperty
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_PutProperty" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_PutProperty
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ProvideEvents" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_ProvideEvents
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_NewQuery" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_NewQuery
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_CancelQuery" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_CancelQuery
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_AccessCheck" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_AccessCheck
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_SetRegistrationObject" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_SetRegistrationObject
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_FindConsumer" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_FindConsumer
					) ;

					t_FastObject->WriteProp (

						L"ProviderOperation_ValidateSubscription" , 
						0 , 
						sizeof ( UINT64 ) , 
						1 ,
						CIM_UINT64, 
						& m_ProviderOperation_ValidateSubscription
					) ;

					t_FastObject->Release () ;

					VARIANT t_VariantProcessIdentifier ;
					VariantInit ( & t_VariantProcessIdentifier ) ;
					t_VariantProcessIdentifier.vt = VT_I4 ;
					t_VariantProcessIdentifier.lVal = GetCurrentProcessId () ;
					t_Instance->Put ( L"HostProcessIdentifier" , 0 , & t_VariantProcessIdentifier , 0 ) ;
					VariantClear ( & t_VariantProcessIdentifier ) ;

					t_Result = a_Sink->Indicate ( 1 , & t_Instance ) ;

					t_Instance->Release () ;
				}

				t_Object->Release () ;
			}

			SysFreeString ( t_Class ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_CLASS ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Call (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	LPCWSTR a_Method,
	IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Query (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
	WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
	VARIANT *a_Value 
)
{
	HRESULT t_Result = WBEM_E_INVALID_PROPERTY ;

	if ( a_ClassIdentifier == WBEM_PROVIDER_CONFIGURATION_CLASS_ID_INSTANCE_PROVIDER_REGISTRATION ) 
	{
		if ( a_PropertyIdentifier == WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID_EXTENDEDQUERY_SUPPORT )
		{
			if ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_V1ProviderDefined ) 
			{
				a_Value->vt = VT_BOOL ;
				a_Value->boolVal = VARIANT_TRUE ;
			}
			else
			{
				a_Value->vt = VT_BOOL ;
				a_Value->boolVal = VARIANT_FALSE ;
			}

			t_Result = S_OK ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: ForceReload ()
{
	return WBEM_E_NOT_SUPPORTED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Shutdown (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	ULONG a_MilliSeconds
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Violation (

	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemClassObject *a_Object	
)
{
	if ( m_Quota )
	{
		return m_Quota->Violation (

			a_Flags ,
			a_Context ,
			a_Object	
		) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: GetSite ( DWORD *a_ProcessIdentifier )
{
	HRESULT t_Result = S_OK ;

	if ( a_ProcessIdentifier ) 
	{
		*a_ProcessIdentifier = GetCurrentProcessId () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: SetContainer ( IUnknown *a_Container )
{
	if ( a_Container )
	{
		HRESULT t_Result = a_Container->QueryInterface ( IID__IWmiProviderQuota , ( void ** ) & m_Quota ) ;
		return t_Result ;
	}
	
	return WBEM_E_INVALID_PARAMETER ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: SetInitialized ( HRESULT a_InitializeResult )
{
	m_InitializeResult = a_InitializeResult ;

	InterlockedExchange ( & m_Initialized , 1 ) ;

	if ( m_InitializedEvent )
	{
		SetEvent ( m_InitializedEvent ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout )
{
	HRESULT t_Result = WBEM_E_UNEXPECTED ;

	if ( m_Initialized == 0 )
	{
		BOOL t_DependantCall = FALSE ;
		t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_DependantCall == FALSE )
			{
				if ( WaitForSingleObject ( m_InitializedEvent , a_Timeout ) == WAIT_TIMEOUT )
				{
					return WBEM_E_PROVIDER_LOAD_FAILURE ;
				}
			}
			else
			{
				if ( WaitForSingleObject ( m_InitializedEvent , 0 ) == WAIT_TIMEOUT )
				{
					return S_FALSE ;
				}
			}
		}
	}
	else
	{
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Initialize (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Namespace ,
	IWbemServices *a_Repository ,
	IWbemServices *a_Service ,
	IWbemProviderInitSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_TransactionIdentifier )
		{
			wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;

			if ( a_TransactionIdentifier )
			{
				StringFromGUID2 ( *a_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
			}

			m_TransactionIdentifier = SysAllocString ( t_TransactionIdentifier ) ;
		}
	}

	if ( a_Repository )
	{
		t_Result = a_Repository->GetObject ( 

			L"__ExtendedStatus" ,
			0 , 
			a_Context ,
			& m_ExtendedStatusObject ,
			NULL
		) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_InitializedEvent = CreateEvent ( NULL , TRUE , FALSE , NULL ) ;
		if ( m_InitializedEvent == NULL )
		{
			t_Result = t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemSyncProvider :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	IWbemShutdown *t_Shutdown = NULL ;

	if ( m_Unknown )
	{
		t_Result = m_Unknown->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , IID_IWbemShutdown , t_Shutdown , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_Shutdown->Shutdown (

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}

					CoRevertToSelf () ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemShutdown *t_Provider = ( IWbemShutdown * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								try
								{
									t_Result = t_Provider->Shutdown (

										a_Flags ,
										a_MaxMilliSeconds ,
										a_Context
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
						}

						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_Shutdown->Release () ;
		}
	}

	if ( m_CoreStub )
	{
		t_Shutdown = NULL ;
		t_Result = m_CoreStub->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Shutdown->Shutdown (

				a_Flags ,
				a_MaxMilliSeconds ,
				a_Context
			) ;

			t_Shutdown->Release () ;
		}
	}

	Lock () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Container->Size () ] ;
	if ( t_ShutdownElements )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

		ULONG t_Count = 0 ;
		while ( ! t_Iterator.Null () )
		{
			t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

			t_Iterator.Increment () ;

			t_Count ++ ;
		}

		UnLock () ;

		for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
		{
			if ( t_ShutdownElements [ t_Index ] ) 
			{
				t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

					a_Flags ,
					a_MaxMilliSeconds ,
					a_Context
				) ;

				t_ShutdownElements [ t_Index ]->Release () ;
			}
		}

		delete [] t_ShutdownElements ;
	}
	else
	{	
		UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\dll\makefile.inc ===
!include $(_NTDRIVE)$(_NTROOT)\ADMIN\WMI\WBEM\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\exe\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\statask.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvLoad.h"
#include "ProvRegInfo.h"
#include "ProvObSk.h"
#include "ProvInSk.h"
#include "StaThread.h"
#include "StaTask.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

StaTask_Create :: StaTask_Create (

	WmiAllocator &a_Allocator ,
	CServerObject_StaThread &a_Thread ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Namespace 

) : WmiTask < ULONG > ( a_Allocator ) ,
	m_Thread ( a_Thread ) ,
	m_Scope ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_ContextStream ( NULL ) ,
	m_RepositoryStream ( NULL ) ,
	m_ProviderStream ( NULL ) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_StaTask_Create_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

StaTask_Create :: ~StaTask_Create ()
{
	if ( m_Namespace ) 
	{
		delete [] m_Namespace ;
	}

	if ( m_Scope ) 
	{
		delete [] m_Scope ;
	}

	if ( m_ContextStream ) 
	{
		m_ContextStream->Release () ;
	}

	if ( m_RepositoryStream ) 
	{
		m_RepositoryStream->Release () ;
	}

	if ( m_ProviderStream ) 
	{
		m_ProviderStream->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_StaTask_Create_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT StaTask_Create :: MarshalContext (

	IWbemContext *a_Context ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

/* 
 *	Marshal interfaces here, so that we can pass an STA proxy.
 */

	if ( a_Context )
	{
		t_Result = CoMarshalInterThreadInterfaceInStream ( 

			IID_IWbemContext , 
			a_Context , 
			& m_ContextStream 
		) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Repository ) 
		{
			t_Result = CoMarshalInterThreadInterfaceInStream ( 

				IID_IWbemServices , 
				a_Repository , 
				& m_RepositoryStream
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT StaTask_Create :: UnMarshalContext ()
{
	HRESULT t_Result = S_OK ;

	IWbemContext *t_Context = NULL ;
	IWbemServices *t_Repository = NULL ;

	if ( m_ContextStream )
	{
		t_Result = CoGetInterfaceAndReleaseStream ( 

			m_ContextStream , 
			IID_IWbemContext , 
			( void ** ) & t_Context 
		) ;

		m_ContextStream = NULL ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( m_RepositoryStream ) 
		{
			t_Result = CoGetInterfaceAndReleaseStream ( 

				m_RepositoryStream , 
				IID_IWbemServices , 
				( void ** ) & t_Repository
			) ;

			m_RepositoryStream = NULL ;
		}
	}

	if ( t_Context ) 
	{
		m_Thread.SetContext ( t_Context ) ;
		t_Context->Release () ;
	}

	if ( t_Repository ) 
	{
		m_Thread.SetRepository ( t_Repository ) ;
		t_Repository->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT StaTask_Create :: MarshalOutgoing (

	IUnknown *a_ProviderService
)
{
	HRESULT t_Result = S_OK ;

/* 
 *	Marshal interfaces here, so that we can pass an STA proxy.
 */

	if ( a_ProviderService )
	{
		t_Result = CoMarshalInterThreadInterfaceInStream ( 

			IID_IUnknown , 
			a_ProviderService , 
			& m_ProviderStream 
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT StaTask_Create :: UnMarshalOutgoing ()
{
	HRESULT t_Result = S_OK ;

	IUnknown *t_ProviderService = NULL ;

	if ( m_ProviderStream )
	{
		t_Result = CoGetInterfaceAndReleaseStream ( 

			m_ProviderStream , 
			IID_IUnknown , 
			( void ** ) &t_ProviderService
		) ;

		m_ProviderStream = NULL ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			m_Thread.SetProviderService ( t_ProviderService ) ;
			t_ProviderService->Release () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode StaTask_Create :: Process ( WmiThread <ULONG > &a_Thread )
{
	m_Result = S_OK ;

	wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;

	if ( m_Thread.Direct_GetTransactionIdentifier () )
	{
		StringFromGUID2 ( *m_Thread.Direct_GetTransactionIdentifier () , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
	}

	IUnknown *t_ProviderInterface = NULL ;

	m_Result = UnMarshalContext () ;
	if ( SUCCEEDED ( m_Result ) )
	{
		wchar_t *t_NamespacePath = NULL ;

		m_Result = ProviderSubSystem_Common_Globals :: GetNamespacePath ( 

			m_Thread.Direct_GetNamespacePath () , 
			t_NamespacePath
		) ;

		if ( SUCCEEDED ( m_Result ) )
		{
			CServerObject_ProviderRegistrationV1 *t_Registration = new CServerObject_ProviderRegistrationV1 ;
			if ( t_Registration )
			{
				t_Registration->AddRef () ;

				m_Result = t_Registration->SetContext ( 

					m_Thread.Direct_GetContext () ,
					m_Thread.Direct_GetNamespacePath () , 
					m_Thread.Direct_GetRepository ()
				) ;
				
				if ( SUCCEEDED ( m_Result ) )
				{
					t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_ObjectCacheTimeout ) ;

					m_Result = t_Registration->Load ( 

						e_All ,
						NULL , 
						m_Thread.Direct_GetProviderName () 
					) ;

					if ( SUCCEEDED ( m_Result ) )
					{
						m_Result = CServerObject_RawFactory :: CreateServerSide ( 

							*t_Registration ,
							NULL ,
							NULL ,
							NULL ,
							t_NamespacePath ,
							& t_ProviderInterface
						) ;

						if ( SUCCEEDED ( m_Result ) )
						{
							IUnknown *t_ProviderService = NULL ;
							m_Result = t_ProviderInterface->QueryInterface ( IID_IUnknown , ( void ** ) & t_ProviderService ) ;
							if ( SUCCEEDED ( m_Result ) )
							{
								MarshalOutgoing ( t_ProviderService ) ;

								t_ProviderService->Release () ;
							}

							t_ProviderInterface->Release () ;
						}
					}
				}

				t_Registration->Release () ;
			}

			delete [] t_NamespacePath ;
		}
		else
		{
			m_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	Complete () ;
	return e_StatusCode_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\exclusion.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Exclusion.h

Abstract:


History:

--*/

#ifndef _Exclusion_H
#define _Exclusion_H

#include <pssException.h>

#include "ProvCache.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Exclusion : public ExclusionCacheElement
{
private:

	WmiMultiReaderMultiWriter m_Exclusion ;

public:

	Exclusion (

		const ULONG &a_ReaderSize ,
		const ULONG &a_WriterSize ,
		const GUID &a_Guid ,
		const ULONG &a_Period ,
		CWbemGlobal_ExclusionController *a_Controller
	)  ;

	~Exclusion () ;

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
	STDMETHODIMP_( ULONG ) AddRef () ;
	STDMETHODIMP_( ULONG ) Release () ;

	WmiMultiReaderMultiWriter &GetExclusion () { return m_Exclusion ; }

	static HRESULT CreateAndCache (

		const GUID &a_Clsid ,
		Exclusion *&a_Exclusion 
	) ;

} ;

#endif _Exclusion_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provwsvs.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvCache.h"
#include "ProvObSk.h"
#include "ProvInSk.h"
#include "ProvWsvS.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemServices_Interceptor :: CInterceptor_IWbemServices_Interceptor (

	WmiAllocator &a_Allocator ,
	IWbemServices *a_Service

) : m_ReferenceCount ( 0 ) , 
	m_Core_IWbemServices ( a_Service ) ,
	m_Core_IWbemRefreshingServices ( NULL ) ,
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_Allocator ( a_Allocator ),
	m_CriticalSection (NOTHROW_LOCK)
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Interceptor_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	HRESULT t_Result = m_Core_IWbemServices->QueryInterface ( IID_IWbemRefreshingServices , ( void ** ) & m_Core_IWbemRefreshingServices ) ;

	m_Core_IWbemServices->AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemServices_Interceptor :: ~CInterceptor_IWbemServices_Interceptor ()
{
	if ( m_Core_IWbemServices )
	{
		m_Core_IWbemServices->Release () ; 
	}

	if ( m_Core_IWbemRefreshingServices )
	{
		m_Core_IWbemRefreshingServices->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Interceptor_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_Interceptor :: AddRef ( void )
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_Interceptor :: Release ( void )
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemServices_Interceptor :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}
	else if ( iid == IID_IWbemRefreshingServices )
	{
		*iplpv = ( LPVOID ) ( IWbemRefreshingServices * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->OpenNamespace (

			a_ObjectPath, 
			a_Flags, 
			a_Context ,
			a_NamespaceService, 
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->CancelAsyncCall (

			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->QueryObjectSink (

			a_Flags,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->GetObject (

			a_ObjectPath,
			a_Flags,
			a_Context ,
			a_Object,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->GetObjectAsync (

			a_ObjectPath, 
			a_Flags, 
			a_Context ,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->PutClass (

			a_Object, 
			a_Flags, 
			a_Context,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->PutClassAsync (

			a_Object, 
			a_Flags, 
			a_Context ,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->DeleteClass (

			a_Class, 
			a_Flags, 
			a_Context,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: DeleteClassAsync ( 
		
	const BSTR a_Class ,
	long a_Flags,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->DeleteClassAsync (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->CreateClassEnum (

			a_Superclass, 
			a_Flags, 
			a_Context,
			a_Enum
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CInterceptor_IWbemServices_Interceptor :: CreateClassEnumAsync (

	const BSTR a_Superclass ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->CreateClassEnumAsync (

			a_Superclass, 
			a_Flags, 
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: PutInstance (

    IWbemClassObject *a_Instance,
    long a_Flags,
    IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->PutInstance (

			a_Instance,
			a_Flags,
			a_Context,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags, 
    IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->PutInstanceAsync (

			a_Instance, 
			a_Flags, 
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: DeleteInstance ( 

	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->DeleteInstance (

			a_ObjectPath,
			a_Flags,
			a_Context,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_Interceptor :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink	
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->DeleteInstanceAsync (

			a_ObjectPath,
			a_Flags,
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->CreateInstanceEnum (

			a_Class, 
			a_Flags, 
			a_Context, 
			a_Enum
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: CreateInstanceEnumAsync (

 	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink

) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->CreateInstanceEnumAsync (

 			a_Class, 
			a_Flags, 
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecQuery (

			a_QueryLanguage, 
			a_Query, 
			a_Flags, 
			a_Context,
			a_Enum
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecQueryAsync (

			a_QueryLanguage, 
			a_Query, 
			a_Flags, 
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecNotificationQuery (

			a_QueryLanguage,
			a_Query,
			a_Flags,
			a_Context,
			a_Enum
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_Interceptor :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecNotificationQueryAsync (

			a_QueryLanguage,
			a_Query,
			a_Flags,
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CInterceptor_IWbemServices_Interceptor :: ExecMethod ( 

	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
    IWbemClassObject **a_OutParams,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecMethod (

			a_ObjectPath,
			a_MethodName,
			a_Flags,
			a_Context,
			a_InParams,
			a_OutParams,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CInterceptor_IWbemServices_Interceptor :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecMethodAsync (

			a_ObjectPath,
			a_MethodName,
			a_Flags,
			a_Context,
			a_InParams,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: ServiceInitialize ()
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;
			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: AddObjectToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Path,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->AddObjectToRefresher (

				a_RefresherId ,
				a_Path,
				a_Flags ,
				a_Context,
				a_ClientRefresherVersion ,
				a_Information ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: AddObjectToRefresherByTemplate (

	WBEM_REFRESHER_ID *a_RefresherId ,
	IWbemClassObject *a_Template ,
	long a_Flags ,
	IWbemContext *a_Context ,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->AddObjectToRefresherByTemplate (

				a_RefresherId ,
				a_Template ,
				a_Flags ,
				a_Context ,
				a_ClientRefresherVersion ,
				a_Information ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: AddEnumToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->AddEnumToRefresher (

				a_RefresherId ,
				a_Class ,
				a_Flags ,
				a_Context,
				a_ClientRefresherVersion ,
				a_Information ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: RemoveObjectFromRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Id ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->RemoveObjectFromRefresher (

				a_RefresherId ,
				a_Id ,
				a_Flags ,
				a_ClientRefresherVersion ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: GetRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	IWbemRemoteRefresher **a_RemoteRefresher ,
	GUID *a_Guid ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->GetRemoteRefresher (

				a_RefresherId ,
				a_Flags ,
				a_ClientRefresherVersion ,
				a_RemoteRefresher ,
				a_Guid ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Interceptor :: ReconnectRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId,
	long a_Flags,
	long a_NumberOfObjects,
	DWORD a_ClientRefresherVersion ,
	WBEM_RECONNECT_INFO *a_ReconnectInformation ,
	WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->ReconnectRemoteRefresher (

				a_RefresherId,
				a_Flags,
				a_NumberOfObjects,
				a_ClientRefresherVersion ,
				a_ReconnectInformation ,
				a_ReconnectResults ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemServices_RestrictingInterceptor :: CInterceptor_IWbemServices_RestrictingInterceptor (

	WmiAllocator &a_Allocator ,
	IWbemServices *a_Service ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) : m_ReferenceCount ( 0 ) , 
	m_Core_IWbemServices ( a_Service ) ,
	m_Core_IWbemRefreshingServices ( NULL ) ,
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_Registration ( a_Registration ) , 
	m_Allocator ( a_Allocator ) ,
	m_ProxyContainer ( a_Allocator , 3 , MAX_PROXIES ),
	m_CriticalSection(NOTHROW_LOCK)
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_RestrictingInterceptor_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	HRESULT t_Result = m_Core_IWbemServices->QueryInterface ( IID_IWbemRefreshingServices , ( void ** ) & m_Core_IWbemRefreshingServices ) ;

	m_Core_IWbemServices->AddRef () ;

	m_Registration.AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemServices_RestrictingInterceptor :: ~CInterceptor_IWbemServices_RestrictingInterceptor ()
{
	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	if ( m_Core_IWbemServices )
	{
		m_Core_IWbemServices->Release () ; 
	}

	if ( m_Core_IWbemRefreshingServices )
	{
		m_Core_IWbemRefreshingServices->Release () ;
	}

	m_Registration.Release () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_RestrictingInterceptor_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_RestrictingInterceptor :: AddRef ( void )
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_RestrictingInterceptor :: Release ( void )
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemServices_RestrictingInterceptor :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}
	else if ( iid == IID_IWbemRefreshingServices )
	{
		*iplpv = ( LPVOID ) ( IWbemRefreshingServices * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: Begin_IWbemServices (

	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IWbemServices *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context 
)
{
	HRESULT t_Result = S_OK ;

	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Proxy_IWbemServices , IID_IWbemServices , m_Core_IWbemServices , a_Proxy , a_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = m_Core_IWbemServices ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IWbemServices * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

						m_ProxyContainer , 
						ProxyIndex_Proxy_IWbemServices , 
						a_Proxy , 
						a_Revert
					) ;
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: End_IWbemServices (

	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IWbemServices *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

			m_ProxyContainer , 
			ProxyIndex_Proxy_IWbemServices , 
			a_Proxy , 
			a_Revert
		) ;
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: Begin_IWbemRefreshingServices (

	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IWbemRefreshingServices *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context 
)
{
	HRESULT t_Result = S_OK ;

	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Proxy_IWbemRefreshingServices , IID_IWbemRefreshingServices , m_Core_IWbemRefreshingServices , a_Proxy , a_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = m_Core_IWbemRefreshingServices ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IWbemRefreshingServices * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

						m_ProxyContainer , 
						ProxyIndex_Proxy_IWbemRefreshingServices , 
						a_Proxy , 
						a_Revert
					) ;
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: End_IWbemRefreshingServices (

	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IWbemRefreshingServices *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

			m_ProxyContainer , 
			ProxyIndex_Proxy_IWbemRefreshingServices , 
			a_Proxy , 
			a_Revert
		) ;
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->OpenNamespace (

				a_ObjectPath, 
				a_Flags, 
				a_Context ,
				a_NamespaceService, 
				a_CallResult
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->CancelAsyncCall (

				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->QueryObjectSink (

				a_Flags,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->GetObject (

				a_ObjectPath,
				a_Flags,
				a_Context ,
				a_Object,
				a_CallResult
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->GetObjectAsync (

				a_ObjectPath, 
				a_Flags, 
				a_Context ,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->PutClass (

				a_Object, 
				a_Flags, 
				a_Context,
				a_CallResult
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->PutClassAsync (

				a_Object, 
				a_Flags, 
				a_Context ,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->DeleteClass (

				a_Class, 
				a_Flags, 
				a_Context,
				a_CallResult
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: DeleteClassAsync ( 
		
	const BSTR a_Class ,
	long a_Flags,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->DeleteClassAsync (

				a_Class , 
				a_Flags , 
				a_Context ,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->CreateClassEnum (

				a_Superclass, 
				a_Flags, 
				a_Context,
				a_Enum
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CInterceptor_IWbemServices_RestrictingInterceptor :: CreateClassEnumAsync (

	const BSTR a_Superclass ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->CreateClassEnumAsync (

				a_Superclass, 
				a_Flags, 
				a_Context,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: PutInstance (

    IWbemClassObject *a_Instance,
    long a_Flags,
    IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->PutInstance (

				a_Instance,
				a_Flags,
				a_Context,
				a_CallResult
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags, 
    IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->PutInstanceAsync (

				a_Instance, 
				a_Flags, 
				a_Context,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: DeleteInstance ( 

	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->DeleteInstance (

				a_ObjectPath,
				a_Flags,
				a_Context,
				a_CallResult
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink	
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->DeleteInstanceAsync (

				a_ObjectPath,
				a_Flags,
				a_Context,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->CreateInstanceEnum (

				a_Class, 
				a_Flags, 
				a_Context, 
				a_Enum
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: CreateInstanceEnumAsync (

 	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink

) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->CreateInstanceEnumAsync (

 				a_Class, 
				a_Flags, 
				a_Context,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->ExecQuery (

				a_QueryLanguage, 
				a_Query, 
				a_Flags, 
				a_Context,
				a_Enum
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->ExecQueryAsync (

				a_QueryLanguage, 
				a_Query, 
				a_Flags, 
				a_Context,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->ExecNotificationQuery (

				a_QueryLanguage,
				a_Query,
				a_Flags,
				a_Context,
				a_Enum
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->ExecNotificationQueryAsync (

				a_QueryLanguage,
				a_Query,
				a_Flags,
				a_Context,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CInterceptor_IWbemServices_RestrictingInterceptor :: ExecMethod ( 

	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
    IWbemClassObject **a_OutParams,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->ExecMethod (

				a_ObjectPath,
				a_MethodName,
				a_Flags,
				a_Context,
				a_InParams,
				a_OutParams,
				a_CallResult
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CInterceptor_IWbemServices_RestrictingInterceptor :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->ExecMethodAsync (

				a_ObjectPath,
				a_MethodName,
				a_Flags,
				a_Context,
				a_InParams,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: ServiceInitialize ()
{
	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		return S_OK ;
	}
	else
	{
		return WBEM_E_OUT_OF_MEMORY ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;
			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: AddObjectToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Path,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->AddObjectToRefresher (

					a_RefresherId ,
					a_Path,
					a_Flags ,
					a_Context,
					a_ClientRefresherVersion ,
					a_Information ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: AddObjectToRefresherByTemplate (

	WBEM_REFRESHER_ID *a_RefresherId ,
	IWbemClassObject *a_Template ,
	long a_Flags ,
	IWbemContext *a_Context ,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->AddObjectToRefresherByTemplate (

					a_RefresherId ,
					a_Template ,
					a_Flags ,
					a_Context ,
					a_ClientRefresherVersion ,
					a_Information ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
			else
			{
				t_Result = WBEM_E_NOT_AVAILABLE ;
			}
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: AddEnumToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->AddEnumToRefresher (

					a_RefresherId ,
					a_Class ,
					a_Flags ,
					a_Context,
					a_ClientRefresherVersion ,
					a_Information ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: RemoveObjectFromRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Id ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->RemoveObjectFromRefresher (

					a_RefresherId ,
					a_Id ,
					a_Flags ,
					a_ClientRefresherVersion ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: GetRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	IWbemRemoteRefresher **a_RemoteRefresher ,
	GUID *a_Guid ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->GetRemoteRefresher (

					a_RefresherId ,
					a_Flags ,
					a_ClientRefresherVersion ,
					a_RemoteRefresher ,
					a_Guid ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: ReconnectRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId,
	long a_Flags,
	long a_NumberOfObjects,
	DWORD a_ClientRefresherVersion ,
	WBEM_RECONNECT_INFO *a_ReconnectInformation ,
	WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->ReconnectRemoteRefresher (

					a_RefresherId,
					a_Flags,
					a_NumberOfObjects,
					a_ClientRefresherVersion ,
					a_ReconnectInformation ,
					a_ReconnectResults ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

#ifdef INTERNAL_IDENTIFY

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IEnumWbemClassObject_Stub :: CInterceptor_IEnumWbemClassObject_Stub (

	CWbemGlobal_VoidPointerController *a_Controller ,
	WmiAllocator &a_Allocator ,
	IEnumWbemClassObject *a_InterceptedEnum

)	:	CWbemGlobal_VoidPointerController ( a_Allocator ) ,
		VoidPointerContainerElement ( 

			a_Controller ,
			this
		) ,
		m_Allocator ( a_Allocator ) ,
		m_InterceptedEnum ( a_InterceptedEnum ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IEnumWbemClassObject_Stub_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_InterceptedEnum )
	{
		m_InterceptedEnum->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IEnumWbemClassObject_Stub :: ~CInterceptor_IEnumWbemClassObject_Stub ()
{
	CWbemGlobal_VoidPointerController :: UnInitialize () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IEnumWbemClassObject_Stub_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IEnumWbemClassObject_Stub :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IEnumWbemClassObject )
	{
		*iplpv = ( LPVOID ) ( IEnumWbemClassObject * ) this ;		
	}
	else if ( iid == IID_Internal_IEnumWbemClassObject )
	{
		*iplpv = ( LPVOID ) ( Internal_IEnumWbemClassObject * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IEnumWbemClassObject_Stub :: AddRef ( void )
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IEnumWbemClassObject_Stub :: Release ( void )
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: EnumInitialize ()
{
	HRESULT t_Result = S_OK ;

	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = CWbemGlobal_VoidPointerController :: Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Enqueue_IEnumWbemClassObject (

	IEnumWbemClassObject *a_Enum ,
	IEnumWbemClassObject *&a_Stub
)
{
	HRESULT t_Result = S_OK ;

	CInterceptor_IEnumWbemClassObject_Stub *t_Stub = new CInterceptor_IEnumWbemClassObject_Stub ( 

		this , 
		m_Allocator , 
		a_Enum
	) ;

	if ( t_Stub )
	{
		t_Stub->AddRef () ;

		t_Result = t_Stub->EnumInitialize () ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;


			Lock () ;

			WmiStatusCode t_StatusCode = Insert ( 

				*t_Stub ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				a_Stub = t_Stub ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			UnLock () ;
		}
		else
		{
			t_Stub->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Reset ()
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedEnum->Reset () ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Next (

	long a_Timeout ,
	ULONG a_Count ,
	IWbemClassObject **a_Objects ,
	ULONG *a_Returned
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedEnum->Next ( 

			a_Timeout ,
			a_Count ,
			a_Objects ,
			a_Returned
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: NextAsync (

	ULONG a_Count,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedEnum->NextAsync ( 

			a_Count,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Clone (

	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		*a_Enum = NULL ;
	}
	catch ( ... ) 
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		InterlockedIncrement ( & m_InProgress ) ;

		if ( m_GateClosed == 1 )
		{
			t_Result = WBEM_E_SHUTTING_DOWN ;
		}
		else
		{
			IEnumWbemClassObject *t_Enum = NULL ;

			t_Result = m_InterceptedEnum->Clone ( 

				& t_Enum
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

					t_Enum ,
					*a_Enum
				) ;

				if ( FAILED ( t_TempResult ) )
				{
					t_Result = t_TempResult ;
				}

				t_Enum->Release () ;
			}
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Skip (

    long a_Timeout,
    ULONG a_Count
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		IEnumWbemClassObject *t_Enum = NULL ;

		t_Result = m_InterceptedEnum->Skip ( 

			a_Timeout,
			a_Count
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Internal_Reset (

	WmiInternalContext a_InternalContext
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Reset () ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Internal_Next (

	WmiInternalContext a_InternalContext ,
	long a_Timeout ,
	ULONG a_Count ,
	IWbemClassObject **a_Objects ,
	ULONG *a_Returned
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Next (

			a_Timeout ,
			a_Count ,
			a_Objects ,
			a_Returned
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Internal_NextAsync (

	WmiInternalContext a_InternalContext ,
	ULONG a_Count,
	IWbemObjectSink *a_Sink
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = NextAsync (

			a_Count,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Internal_Clone (

	WmiInternalContext a_InternalContext ,
	IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Clone (

			a_Enum
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Internal_Skip (

	WmiInternalContext a_InternalContext ,
    long a_Timeout,
    ULONG a_Count
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Skip (

			a_Timeout,
			a_Count
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IEnumWbemClassObject_Proxy :: CInterceptor_IEnumWbemClassObject_Proxy (

	CWbemGlobal_VoidPointerController *a_Controller ,
	WmiAllocator &a_Allocator ,
	IEnumWbemClassObject *a_InterceptedEnum

)	:	CWbemGlobal_VoidPointerController ( a_Allocator ) ,
		VoidPointerContainerElement ( 

			a_Controller ,
			this
		) ,
		m_Allocator ( a_Allocator ) ,
		m_ProxyContainer ( a_Allocator , ProxyIndex_EnumProxy_Size , MAX_PROXIES ) ,
		m_InterceptedEnum ( a_InterceptedEnum ) ,
		m_Internal_InterceptedEnum ( NULL ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IEnumWbemClassObject_Proxy_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_InterceptedEnum )
	{
		m_InterceptedEnum->AddRef () ;

		HRESULT t_Result = m_InterceptedEnum->QueryInterface ( IID_Internal_IEnumWbemClassObject , ( void ** ) & m_Internal_InterceptedEnum ) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IEnumWbemClassObject_Proxy :: ~CInterceptor_IEnumWbemClassObject_Proxy ()
{
	CWbemGlobal_VoidPointerController :: UnInitialize () ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IEnumWbemClassObject_Proxy_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IEnumWbemClassObject_Proxy :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IEnumWbemClassObject )
	{
		*iplpv = ( LPVOID ) ( IEnumWbemClassObject * ) this ;		
	}
	else if ( iid == IID_Internal_IEnumWbemClassObject )
	{
		*iplpv = ( LPVOID ) ( Internal_IEnumWbemClassObject * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IEnumWbemClassObject_Proxy :: AddRef ( void )
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IEnumWbemClassObject_Proxy :: Release ( void )
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Proxy :: EnumInitialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = CWbemGlobal_VoidPointerController :: Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Proxy :: Begin_IEnumWbemClassObject (

	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_ProcessIdentifier )
		{
			t_Result = CoImpersonateClient () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				CoRevertToSelf () ;

				if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
					
						m_ProxyContainer , 
						ProxyIndex_EnumProxy_IEnumWbemClassObject , 
						IID_IEnumWbemClassObject , 
						m_InterceptedEnum , 
						a_Proxy , 
						a_Revert
					) ;
				}
				else
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_PrvHost ( 
					
						m_ProxyContainer , 
						ProxyIndex_EnumProxy_Internal_IEnumWbemClassObject , 
						IID_Internal_IEnumWbemClassObject , 
						m_Internal_InterceptedEnum , 
						a_Proxy , 
						a_Revert ,
						a_ProcessIdentifier ,
						a_IdentifyToken 
					) ;
				}
			}
		}
		else
		{
			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
			
				m_ProxyContainer , 
				ProxyIndex_EnumProxy_IEnumWbemClassObject , 
				IID_IEnumWbemClassObject , 
				m_InterceptedEnum , 
				a_Proxy , 
				a_Revert
			) ;
		}

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = m_InterceptedEnum ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IUnknown * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( FAILED ( t_Result ) )
				{
					if ( a_IdentifyToken )
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost ( 

							m_ProxyContainer , 
							ProxyIndex_EnumProxy_Internal_IEnumWbemClassObject , 
							a_Proxy , 
							a_Revert ,
							a_ProcessIdentifier , 
							a_IdentifyToken 
						) ;
					}
					else
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

							m_ProxyContainer , 
							ProxyIndex_EnumProxy_IEnumWbemClassObject , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Proxy :: End_IEnumWbemClassObject (

	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost ( 

				m_ProxyContainer , 
				ProxyIndex_EnumProxy_Internal_IEnumWbemClassObject , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier , 
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				ProxyIndex_EnumProxy_IEnumWbemClassObject , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Proxy :: Enqueue_IEnumWbemClassObject (

	IEnumWbemClassObject *a_Enum ,
	IEnumWbemClassObject *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	CInterceptor_IEnumWbemClassObject_Proxy *t_Proxy = new CInterceptor_IEnumWbemClassObject_Proxy ( 

		this , 
		m_Allocator , 
		a_Enum
	) ;

	if ( t_Proxy )
	{
		t_Proxy->AddRef () ;

		t_Result = t_Proxy->EnumInitialize () ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;


			Lock () ;

			WmiStatusCode t_StatusCode = Insert ( 

				*t_Proxy ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				a_Proxy = t_Proxy ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			UnLock () ;
		}
		else
		{
			t_Proxy->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Proxy :: Reset ()
{
	try
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_IEnumWbemClassObject (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IEnumWbemClassObject * ) t_Interface )->Internal_Reset (

					t_InternalContext
				) ;
			}
			else
			{
				t_Result = ( ( IEnumWbemClassObject * ) t_Interface )->Reset () ;
			}

			End_IEnumWbemClassObject (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		return t_Result ;
	}
	catch ( ... )
	{
		return WBEM_E_CRITICAL_ERROR ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Proxy :: Next (

	long a_Timeout ,
	ULONG a_Count ,
	IWbemClassObject **a_Objects ,
	ULONG *a_Returned
)
{
	try
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_IEnumWbemClassObject (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IEnumWbemClassObject * ) t_Interface )->Internal_Next (

					t_InternalContext ,
					a_Timeout ,
					a_Count ,
					a_Objects ,
					a_Returned
				) ;
			}
			else
			{
				t_Result = ( ( IEnumWbemClassObject * ) t_Interface )->Next (
				
					a_Timeout ,
					a_Count ,
					a_Objects ,
					a_Returned
				) ;
			}

			End_IEnumWbemClassObject (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		return t_Result ;
	}
	catch ( ... )
	{
		return WBEM_E_CRITICAL_ERROR ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Proxy :: NextAsync (

	ULONG a_Count,
	IWbemObjectSink *a_Sink
)
{
	try
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_IEnumWbemClassObject (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IEnumWbemClassObject * ) t_Interface )->Internal_NextAsync (

					t_InternalContext ,
					a_Count,
					a_Sink
				) ;
			}
			else
			{
				t_Result = ( ( IEnumWbemClassObject * ) t_Interface )->NextAsync (
				
					a_Count,
					a_Sink
				) ;
			}

			End_IEnumWbemClassObject (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		return t_Result ;
	}
	catch ( ... )
	{
		return WBEM_E_CRITICAL_ERROR ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Proxy :: Clone (

	IEnumWbemClassObject **a_Enum
)
{
	try
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_IEnumWbemClassObject (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IEnumWbemClassObject * ) t_Interface )->Internal_Clone (

					t_InternalContext ,
					a_Enum
				) ;
			}
			else
			{
				t_Result = ( ( IEnumWbemClassObject * ) t_Interface )->Clone (
				
					a_Enum
				) ;
			}

			End_IEnumWbemClassObject (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		return t_Result ;
	}
	catch ( ... )
	{
		return WBEM_E_CRITICAL_ERROR ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Proxy :: Skip (

    long a_Timeout,
    ULONG a_Count
)
{
	try
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_IEnumWbemClassObject (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IEnumWbemClassObject * ) t_Interface )->Internal_Skip (

					t_InternalContext ,
					a_Timeout,
					a_Count
				) ;
			}
			else
			{
				t_Result = ( ( IEnumWbemClassObject * ) t_Interface )->Skip (
				
					a_Timeout,
					a_Count
				) ;
			}

			End_IEnumWbemClassObject (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		return t_Result ;
	}
	catch ( ... )
	{
		return WBEM_E_CRITICAL_ERROR ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemServices_Stub :: CInterceptor_IWbemServices_Stub (

	CWbemGlobal_VoidPointerController *a_Controller ,
	WmiAllocator &a_Allocator ,
	IWbemServices *a_Service

) : CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	VoidPointerContainerElement ( 

		a_Controller ,
		this
	) ,
	m_Core_IWbemServices ( a_Service ) ,
	m_Core_IWbemRefreshingServices ( NULL ) ,
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_Allocator ( a_Allocator )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Stub_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	HRESULT t_Result = m_Core_IWbemServices->QueryInterface ( IID_IWbemRefreshingServices , ( void ** ) & m_Core_IWbemRefreshingServices ) ;

	m_Core_IWbemServices->AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemServices_Stub :: ~CInterceptor_IWbemServices_Stub ()
{
	CWbemGlobal_VoidPointerController :: UnInitialize () ;

	if ( m_Core_IWbemServices )
	{
		m_Core_IWbemServices->Release () ; 
	}

	if ( m_Core_IWbemRefreshingServices )
	{
		m_Core_IWbemRefreshingServices->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Stub_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_Stub :: AddRef ( void )
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_Stub :: Release ( void )
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemServices_Stub :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}
	else if ( iid == IID_IWbemRefreshingServices )
	{
		*iplpv = ( LPVOID ) ( IWbemRefreshingServices * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	
	else if ( iid == IID_Internal_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( Internal_IWbemServices * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Enqueue_IWbemServices (

	IWbemServices *a_Service ,
	IWbemServices *&a_Stub
)
{
	HRESULT t_Result = S_OK ;

	CInterceptor_IWbemServices_Stub *t_Stub = new CInterceptor_IWbemServices_Stub ( 

		this , 
		m_Allocator , 
		a_Service
	) ;

	if ( t_Stub )
	{
		t_Stub->AddRef () ;

		t_Result = t_Stub->ServiceInitialize () ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

			Lock () ;

			WmiStatusCode t_StatusCode = Insert ( 

				*t_Stub ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				a_Stub = t_Stub ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			UnLock () ;
		}
		else
		{
			t_Stub->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Enqueue_IEnumWbemClassObject (

	IEnumWbemClassObject *a_Enum ,
	IEnumWbemClassObject *&a_Stub
)
{
	HRESULT t_Result = S_OK ;

	CInterceptor_IEnumWbemClassObject_Stub *t_Stub = new CInterceptor_IEnumWbemClassObject_Stub ( 

		this , 
		m_Allocator , 
		a_Enum
	) ;

	if ( t_Stub )
	{
		t_Stub->AddRef () ;

		t_Result = t_Stub->EnumInitialize () ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;


			Lock () ;

			WmiStatusCode t_StatusCode = Insert ( 

				*t_Stub ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				a_Stub = t_Stub ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			UnLock () ;
		}
		else
		{
			t_Stub->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->OpenNamespace (

			a_ObjectPath, 
			a_Flags, 
			a_Context ,
			a_NamespaceService, 
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->CancelAsyncCall (

			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->QueryObjectSink (

			a_Flags,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->GetObject (

			a_ObjectPath,
			a_Flags,
			a_Context ,
			a_Object,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->GetObjectAsync (

			a_ObjectPath, 
			a_Flags, 
			a_Context ,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->PutClass (

			a_Object, 
			a_Flags, 
			a_Context,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->PutClassAsync (

			a_Object, 
			a_Flags, 
			a_Context ,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->DeleteClass (

			a_Class, 
			a_Flags, 
			a_Context,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: DeleteClassAsync ( 
		
	const BSTR a_Class ,
	long a_Flags,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->DeleteClassAsync (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		IEnumWbemClassObject *t_Enum = NULL ;

		t_Result = m_Core_IWbemServices->CreateClassEnum (

			a_Superclass, 
			a_Flags, 
			a_Context,
			& t_Enum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

				t_Enum ,
				*a_Enum
			) ;

			if ( FAILED ( t_TempResult ) )
			{
				t_Result = t_TempResult ;
			}

			t_Enum->Release () ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: CreateClassEnumAsync (

	const BSTR a_Superclass ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->CreateClassEnumAsync (

			a_Superclass, 
			a_Flags, 
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: PutInstance (

    IWbemClassObject *a_Instance,
    long a_Flags,
    IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->PutInstance (

			a_Instance,
			a_Flags,
			a_Context,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags, 
    IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->PutInstanceAsync (

			a_Instance, 
			a_Flags, 
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: DeleteInstance ( 

	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->DeleteInstance (

			a_ObjectPath,
			a_Flags,
			a_Context,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_Stub :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink	
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->DeleteInstanceAsync (

			a_ObjectPath,
			a_Flags,
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		IEnumWbemClassObject *t_Enum = NULL ;

		t_Result = m_Core_IWbemServices->CreateInstanceEnum (

			a_Class, 
			a_Flags, 
			a_Context, 
			& t_Enum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

				t_Enum ,
				*a_Enum
			) ;

			if ( FAILED ( t_TempResult ) )
			{
				t_Result = t_TempResult ;
			}

			t_Enum->Release () ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: CreateInstanceEnumAsync (

 	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink

) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->CreateInstanceEnumAsync (

 			a_Class, 
			a_Flags, 
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		IEnumWbemClassObject *t_Enum = NULL ;

		t_Result = m_Core_IWbemServices->ExecQuery (

			a_QueryLanguage, 
			a_Query, 
			a_Flags, 
			a_Context,
			& t_Enum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

				t_Enum ,
				*a_Enum
			) ;

			if ( FAILED ( t_TempResult ) )
			{
				t_Result = t_TempResult ;
			}

			t_Enum->Release () ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecQueryAsync (

			a_QueryLanguage, 
			a_Query, 
			a_Flags, 
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecNotificationQuery (

			a_QueryLanguage,
			a_Query,
			a_Flags,
			a_Context,
			a_Enum
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_Stub :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecNotificationQueryAsync (

			a_QueryLanguage,
			a_Query,
			a_Flags,
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ExecMethod ( 

	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
    IWbemClassObject **a_OutParams,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecMethod (

			a_ObjectPath,
			a_MethodName,
			a_Flags,
			a_Context,
			a_InParams,
			a_OutParams,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecMethodAsync (

			a_ObjectPath,
			a_MethodName,
			a_Flags,
			a_Context,
			a_InParams,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ServiceInitialize ()
{
	HRESULT t_Result = S_OK ;

	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = CWbemGlobal_VoidPointerController :: Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;
			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: AddObjectToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Path,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->AddObjectToRefresher (

				a_RefresherId ,
				a_Path,
				a_Flags ,
				a_Context,
				a_ClientRefresherVersion ,
				a_Information ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: AddObjectToRefresherByTemplate (

	WBEM_REFRESHER_ID *a_RefresherId ,
	IWbemClassObject *a_Template ,
	long a_Flags ,
	IWbemContext *a_Context ,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->AddObjectToRefresherByTemplate (

				a_RefresherId ,
				a_Template ,
				a_Flags ,
				a_Context ,
				a_ClientRefresherVersion ,
				a_Information ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: AddEnumToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->AddEnumToRefresher (

				a_RefresherId ,
				a_Class ,
				a_Flags ,
				a_Context,
				a_ClientRefresherVersion ,
				a_Information ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: RemoveObjectFromRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Id ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->RemoveObjectFromRefresher (

				a_RefresherId ,
				a_Id ,
				a_Flags ,
				a_ClientRefresherVersion ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: GetRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	IWbemRemoteRefresher **a_RemoteRefresher ,
	GUID *a_Guid ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->GetRemoteRefresher (

				a_RefresherId ,
				a_Flags ,
				a_ClientRefresherVersion ,
				a_RemoteRefresher ,
				a_Guid ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ReconnectRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId,
	long a_Flags,
	long a_NumberOfObjects,
	DWORD a_ClientRefresherVersion ,
	WBEM_RECONNECT_INFO *a_ReconnectInformation ,
	WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->ReconnectRemoteRefresher (

				a_RefresherId,
				a_Flags,
				a_NumberOfObjects,
				a_ClientRefresherVersion ,
				a_ReconnectInformation ,
				a_ReconnectResults ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_OpenNamespace ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = OpenNamespace (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_NamespaceService ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_CancelAsyncCall ( 
	
	WmiInternalContext a_InternalContext ,		
	IWbemObjectSink *a_Sink
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CancelAsyncCall (
		
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_QueryObjectSink ( 

	WmiInternalContext a_InternalContext ,
	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryObjectSink (

			a_Flags ,	
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_GetObject ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetObject (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_Object ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_GetObjectAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetObjectAsync (

			a_ObjectPath ,
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_PutClass ( 

	WmiInternalContext a_InternalContext ,		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutClass (

			a_Object ,
			a_Flags , 
			a_Context ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_PutClassAsync ( 
		
	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_Object , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutClassAsync (

			a_Object , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_DeleteClass ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteClass (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_DeleteClassAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteClassAsync (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_CreateClassEnum ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_SuperClass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateClassEnum (

			a_SuperClass ,
			a_Flags, 
			a_Context ,
			a_Enum
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_CreateClassEnumAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_SuperClass , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateClassEnumAsync (

			a_SuperClass ,
			a_Flags, 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_PutInstance (

	WmiInternalContext a_InternalContext ,
    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutInstance (

			a_Instance ,
			a_Flags ,
			a_Context ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_PutInstanceAsync ( 

	WmiInternalContext a_InternalContext ,		
	IWbemClassObject *a_Instance , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutInstanceAsync (

			a_Instance , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_DeleteInstance ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteInstance (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_DeleteInstanceAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteInstanceAsync (

			a_ObjectPath ,
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_CreateInstanceEnum ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateInstanceEnum (

			a_Class ,
			a_Flags , 
			a_Context , 
			a_Enum
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_CreateInstanceEnumAsync (

	WmiInternalContext a_InternalContext ,
 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateInstanceEnumAsync (

			a_Class ,
			a_Flags ,
			a_Context ,
			a_Sink 
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_ExecQuery ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecQuery (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Enum
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_ExecQueryAsync ( 

	WmiInternalContext a_InternalContext ,		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecQueryAsync (

			a_QueryLanguage ,
			a_Query, 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_ExecNotificationQuery ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecNotificationQuery (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Enum
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_Stub :: Internal_ExecNotificationQueryAsync ( 

	WmiInternalContext a_InternalContext ,            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecNotificationQueryAsync (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Sink 
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_ExecMethod (

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecMethod (

			a_ObjectPath ,
			a_MethodName ,
			a_Flags ,
			a_Context ,
			a_InParams ,
			a_OutParams ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_ExecMethodAsync ( 

	WmiInternalContext a_InternalContext ,		
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecMethodAsync (

			a_ObjectPath ,
			a_MethodName ,
			a_Flags ,
			a_Context ,
			a_InParams ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemServices_Proxy :: CInterceptor_IWbemServices_Proxy (

	CWbemGlobal_VoidPointerController *a_Controller ,
	WmiAllocator &a_Allocator ,
	IWbemServices *a_Service ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) : CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	VoidPointerContainerElement ( 

		a_Controller ,
		this
	) ,
	m_Core_IWbemServices ( a_Service ) ,
	m_Core_IWbemRefreshingServices ( NULL ) ,
	m_Core_Internal_IWbemServices ( NULL ) ,
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_Allocator ( a_Allocator ) ,
	m_Registration ( a_Registration ) , 
	m_ProxyContainer ( a_Allocator , ProxyIndex_Proxy_Size , MAX_PROXIES )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Proxy_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	HRESULT t_Result = m_Core_IWbemServices->QueryInterface ( IID_IWbemRefreshingServices , ( void ** ) & m_Core_IWbemRefreshingServices ) ;
	t_Result = m_Core_IWbemServices->QueryInterface ( IID_Internal_IWbemServices , ( void ** ) & m_Core_Internal_IWbemServices ) ;

	m_Core_IWbemServices->AddRef () ;

	m_Registration.AddRef () ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemServices_Proxy :: ~CInterceptor_IWbemServices_Proxy ()
{
	CWbemGlobal_VoidPointerController :: UnInitialize () ;

	m_Registration.Release () ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	if ( m_Core_IWbemServices )
	{
		m_Core_IWbemServices->Release () ; 
	}

	if ( m_Core_Internal_IWbemServices )
	{
		m_Core_Internal_IWbemServices->Release () ; 
	}

	if ( m_Core_IWbemRefreshingServices )
	{
		m_Core_IWbemRefreshingServices->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Proxy_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_Proxy :: AddRef ( void )
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_Proxy :: Release ( void )
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemServices_Proxy :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}
	else if ( iid == IID_IWbemRefreshingServices )
	{
		*iplpv = ( LPVOID ) ( IWbemRefreshingServices * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: Begin_IWbemServices (

	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_ProcessIdentifier )
		{
			t_Result = CoImpersonateClient () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				CoRevertToSelf () ;

				if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
					
						m_ProxyContainer , 
						ProxyIndex_Proxy_IWbemServices , 
						IID_IWbemServices , 
						m_Core_IWbemServices , 
						a_Proxy , 
						a_Revert
					) ;
				}
				else
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_PrvHost ( 
					
						m_ProxyContainer , 
						ProxyIndex_Proxy_Internal_IWbemServices , 
						IID_Internal_IWbemServices , 
						m_Core_Internal_IWbemServices , 
						a_Proxy , 
						a_Revert ,
						a_ProcessIdentifier ,
						a_IdentifyToken 
					) ;
				}
			}
		}
		else
		{
			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
			
				m_ProxyContainer , 
				ProxyIndex_Proxy_IWbemServices , 
				IID_IWbemServices , 
				m_Core_IWbemServices , 
				a_Proxy , 
				a_Revert
			) ;
		}

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = m_Core_IWbemServices ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IUnknown * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( FAILED ( t_Result ) )
				{
					if ( a_IdentifyToken )
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost ( 

							m_ProxyContainer , 
							ProxyIndex_Proxy_Internal_IWbemServices , 
							a_Proxy , 
							a_Revert ,
							a_ProcessIdentifier , 
							a_IdentifyToken 
						) ;
					}
					else
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

							m_ProxyContainer , 
							ProxyIndex_Proxy_IWbemServices , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: End_IWbemServices (

	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost ( 

				m_ProxyContainer , 
				ProxyIndex_Proxy_Internal_IWbemServices , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier , 
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				ProxyIndex_Proxy_IWbemServices , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: Begin_IWbemRefreshingServices (

	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IWbemRefreshingServices *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context 
)
{
	HRESULT t_Result = S_OK ;

	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 

			m_ProxyContainer , 
			ProxyIndex_Proxy_IWbemRefreshingServices , 
			IID_IWbemRefreshingServices , 
			m_Core_IWbemRefreshingServices , 
			a_Proxy , 
			a_Revert
		) ;

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = m_Core_IWbemRefreshingServices ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IWbemRefreshingServices * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

						m_ProxyContainer , 
						ProxyIndex_Proxy_IWbemRefreshingServices , 
						a_Proxy , 
						a_Revert
					) ;
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: End_IWbemRefreshingServices (

	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IWbemRefreshingServices *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

			m_ProxyContainer , 
			ProxyIndex_Proxy_IWbemRefreshingServices , 
			a_Proxy , 
			a_Revert
		) ;
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: Enqueue_IWbemServices (

	IWbemServices *a_Service ,
	IWbemServices *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	CInterceptor_IWbemServices_Proxy *t_Proxy = new CInterceptor_IWbemServices_Proxy ( 

		this , 
		m_Allocator , 
		a_Service ,
		m_Registration
	) ;

	if ( t_Proxy )
	{
		t_Proxy->AddRef () ;

		t_Result = t_Proxy->ServiceInitialize () ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;


			Lock () ;

			WmiStatusCode t_StatusCode = Insert ( 

				*t_Proxy ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				a_Proxy = t_Proxy ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			UnLock () ;
		}
		else
		{
			t_Proxy->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: Enqueue_IEnumWbemClassObject (

	IEnumWbemClassObject *a_Enum ,
	IEnumWbemClassObject *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	CInterceptor_IEnumWbemClassObject_Proxy *t_Proxy = new CInterceptor_IEnumWbemClassObject_Proxy ( 

		this , 
		m_Allocator , 
		a_Enum
	) ;

	if ( t_Proxy )
	{
		t_Proxy->AddRef () ;

		t_Result = t_Proxy->EnumInitialize () ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;


			Lock () ;

			WmiStatusCode t_StatusCode = Insert ( 

				*t_Proxy ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				a_Proxy = t_Proxy ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			UnLock () ;
		}
		else
		{
			t_Proxy->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		*a_NamespaceService = NULL ;
	}
	catch ( ... ) 
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		InterlockedIncrement ( & m_InProgress ) ;

		if ( m_GateClosed == 1 )
		{
			t_Result = WBEM_E_SHUTTING_DOWN ;
		}
		else
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
			HANDLE t_IdentifyToken = NULL ;

			t_Result = Begin_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

					BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
					if ( t_ObjectPath )
					{
						IWbemServices *t_Service = NULL ;

						t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_OpenNamespace (

							t_InternalContext ,
							t_ObjectPath, 
							a_Flags, 
							a_Context ,
							& t_Service , 
							a_CallResult
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = Enqueue_IWbemServices ( 

								t_Service ,
								*a_NamespaceService
							) ;
						}

						SysFreeString ( t_ObjectPath ) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					IWbemServices *t_Service = NULL ;

					t_Result = ( ( IWbemServices * ) t_Interface )->OpenNamespace (

						a_ObjectPath, 
						a_Flags, 
						a_Context ,
						& t_Service , 
						a_CallResult
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = Enqueue_IWbemServices ( 

							t_Service ,
							*a_NamespaceService
						) ;
					}
				}

				End_IWbemServices (

					t_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CancelAsyncCall (

					t_InternalContext ,
					a_Sink
				) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->CancelAsyncCall (

					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_QueryObjectSink (

					t_InternalContext ,
					a_Flags ,
					a_Sink
				) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->QueryObjectSink (

					a_Flags ,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
				if ( t_ObjectPath )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_GetObject (

						t_InternalContext ,
						t_ObjectPath,
						a_Flags,
						a_Context ,
						a_Object,
						a_CallResult
					) ;

					SysFreeString ( t_ObjectPath ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->GetObject (

					a_ObjectPath,
					a_Flags,
					a_Context ,
					a_Object,
					a_CallResult
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
				if ( t_ObjectPath )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_GetObjectAsync (

						t_InternalContext ,
						t_ObjectPath, 
						a_Flags, 
						a_Context ,
						a_Sink
					) ;

					SysFreeString ( t_ObjectPath ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->GetObjectAsync (

					a_ObjectPath, 
					a_Flags, 
					a_Context ,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutClass (

					t_InternalContext ,
					a_Object, 
					a_Flags, 
					a_Context,
					a_CallResult
				) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->PutClass (

					a_Object, 
					a_Flags, 
					a_Context,
					a_CallResult
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutClassAsync (

					t_InternalContext ,
					a_Object, 
					a_Flags, 
					a_Context ,
					a_Sink
				) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->PutClassAsync (

					a_Object, 
					a_Flags, 
					a_Context ,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_Class = SysAllocString ( a_Class ) ;
				if ( t_Class )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteClass (

						t_InternalContext ,
						t_Class, 
						a_Flags, 
						a_Context,
						a_CallResult
					) ;

					SysFreeString ( t_Class ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->DeleteClass (

					a_Class, 
					a_Flags, 
					a_Context,
					a_CallResult
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: DeleteClassAsync ( 
		
	const BSTR a_Class ,
	long a_Flags,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_Class = SysAllocString ( a_Class ) ;
				if ( t_Class )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteClassAsync (

						t_InternalContext ,
						t_Class , 
						a_Flags , 
						a_Context ,
						a_Sink
					) ;

					SysFreeString ( t_Class ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->DeleteClassAsync (

					a_Class , 
					a_Flags , 
					a_Context ,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: CreateClassEnum ( 

	const BSTR a_SuperClass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	HRESULT t_Result = S_OK ;

	try
	{
		*a_Enum = NULL ;
	}
	catch ( ... ) 
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		InterlockedIncrement ( & m_InProgress ) ;

		if ( m_GateClosed == 1 )
		{
			t_Result = WBEM_E_SHUTTING_DOWN ;
		}
		else
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
			HANDLE t_IdentifyToken = NULL ;

			t_Result = Begin_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

					BSTR t_SuperClass = SysAllocString ( a_SuperClass ) ;
					if ( t_SuperClass )
					{
						IEnumWbemClassObject *t_Enum = NULL ;

						t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateClassEnum (

							t_InternalContext ,
							t_SuperClass, 
							a_Flags, 
							a_Context,
							& t_Enum
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

								t_Enum ,
								*a_Enum
							) ;

							if ( FAILED ( t_TempResult ) )
							{
								t_Result = t_TempResult ;
							}

							t_Enum->Release () ;
						}
			
						SysFreeString ( t_SuperClass ) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					IEnumWbemClassObject *t_Enum = NULL ;

					t_Result = ( ( IWbemServices * ) t_Interface )->CreateClassEnum (

						a_SuperClass, 
						a_Flags, 
						a_Context,
						& t_Enum
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

							t_Enum ,
							*a_Enum
						) ;

						if ( FAILED ( t_TempResult ) )
						{
							t_Result = t_TempResult ;
						}

						t_Enum->Release () ;
					}
				}

				End_IWbemServices (

					t_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CInterceptor_IWbemServices_Proxy :: CreateClassEnumAsync (

	const BSTR a_SuperClass ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_SuperClass = SysAllocString ( a_SuperClass ) ;
				if ( t_SuperClass )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateClassEnumAsync (

						t_InternalContext ,
						t_SuperClass, 
						a_Flags, 
						a_Context,
						a_Sink
					) ;

					SysFreeString ( t_SuperClass ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->CreateClassEnumAsync (

					a_SuperClass, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: PutInstance (

    IWbemClassObject *a_Instance,
    long a_Flags,
    IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutInstance (

					t_InternalContext ,
					a_Instance,
					a_Flags,
					a_Context,
					a_CallResult
				) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->PutInstance (

					a_Instance,
					a_Flags,
					a_Context,
					a_CallResult
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags, 
    IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutInstanceAsync (

					t_InternalContext ,
					a_Instance, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->PutInstanceAsync (

					a_Instance, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: DeleteInstance ( 

	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
				if ( t_ObjectPath )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteInstance (

						t_InternalContext ,
						t_ObjectPath,
						a_Flags,
						a_Context,
						a_CallResult
					) ;

					SysFreeString ( t_ObjectPath ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->DeleteInstance (

					a_ObjectPath,
					a_Flags,
					a_Context,
					a_CallResult
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_Proxy :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink	
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
				if ( t_ObjectPath )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteInstanceAsync (

						t_InternalContext ,
						t_ObjectPath,
						a_Flags,
						a_Context,
						a_Sink
					) ;

					SysFreeString ( t_ObjectPath ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->DeleteInstanceAsync (

					a_ObjectPath,
					a_Flags,
					a_Context,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		*a_Enum = NULL ;
	}
	catch ( ... ) 
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		InterlockedIncrement ( & m_InProgress ) ;

		if ( m_GateClosed == 1 )
		{
			t_Result = WBEM_E_SHUTTING_DOWN ;
		}
		else
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
			HANDLE t_IdentifyToken = NULL ;

			t_Result = Begin_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

					BSTR t_Class = SysAllocString ( a_Class ) ;
					if ( t_Class )
					{
						IEnumWbemClassObject *t_Enum = NULL ;

						t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateInstanceEnum (

							t_InternalContext ,
							t_Class, 
							a_Flags, 
							a_Context, 
							& t_Enum
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

								t_Enum ,
								*a_Enum
							) ;

							if ( FAILED ( t_TempResult ) )
							{
								t_Result = t_TempResult ;
							}

							t_Enum->Release () ;
						}
		
						SysFreeString ( t_Class ) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					IEnumWbemClassObject *t_Enum = NULL ;

					t_Result = ( ( IWbemServices * ) t_Interface )->CreateInstanceEnum (

						a_Class, 
						a_Flags, 
						a_Context, 
						& t_Enum
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

							t_Enum ,
							*a_Enum
						) ;

						if ( FAILED ( t_TempResult ) )
						{
							t_Result = t_TempResult ;
						}

						t_Enum->Release () ;
					}
				}

				End_IWbemServices (

					t_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: CreateInstanceEnumAsync (

 	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink

) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_Class = SysAllocString ( a_Class ) ;
				if ( t_Class )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateInstanceEnumAsync (

						t_InternalContext ,
 						t_Class, 
						a_Flags, 
						a_Context,
						a_Sink
					) ;

					SysFreeString ( t_Class ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->CreateInstanceEnumAsync (

					a_Class, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		*a_Enum = NULL ;
	}
	catch ( ... ) 
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		InterlockedIncrement ( & m_InProgress ) ;

		if ( m_GateClosed == 1 )
		{
			t_Result = WBEM_E_SHUTTING_DOWN ;
		}
		else
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
			HANDLE t_IdentifyToken = NULL ;

			t_Result = Begin_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

					BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
					BSTR t_Query = SysAllocString ( a_Query ) ;

					if ( t_QueryLanguage && t_Query )
					{
						IEnumWbemClassObject *t_Enum = NULL ;

						t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecQuery (

							t_InternalContext ,
							t_QueryLanguage, 
							t_Query, 
							a_Flags, 
							a_Context,
							& t_Enum
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

								t_Enum ,
								*a_Enum
							) ;

							if ( FAILED ( t_TempResult ) )
							{
								t_Result = t_TempResult ;
							}

							t_Enum->Release () ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					SysFreeString ( t_QueryLanguage ) ;
					SysFreeString ( t_Query ) ;
				}
				else
				{
					IEnumWbemClassObject *t_Enum = NULL ;

					t_Result = ( ( IWbemServices * ) t_Interface )->ExecQuery (

						a_QueryLanguage, 
						a_Query, 
						a_Flags, 
						a_Context,
						& t_Enum
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

							t_Enum ,
							*a_Enum
						) ;

						if ( FAILED ( t_TempResult ) )
						{
							t_Result = t_TempResult ;
						}

						t_Enum->Release () ;
					}

				}

				End_IWbemServices (

					t_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
				BSTR t_Query = SysAllocString ( a_Query ) ;

				if ( t_QueryLanguage && t_Query )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecQueryAsync (

						t_InternalContext ,
						t_QueryLanguage, 
						t_Query, 
						a_Flags, 
						a_Context,
						a_Sink
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_QueryLanguage ) ;
				SysFreeString ( t_Query ) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->ExecQueryAsync (

					a_QueryLanguage, 
					a_Query, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
				BSTR t_Query = SysAllocString ( a_Query ) ;

				if ( t_QueryLanguage && t_Query )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecNotificationQuery (

						t_InternalContext ,
						t_QueryLanguage,
						t_Query,
						a_Flags,
						a_Context,
						a_Enum
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_QueryLanguage ) ;
				SysFreeString ( t_Query ) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->ExecNotificationQuery (

					a_QueryLanguage,
					a_Query,
					a_Flags,
					a_Context,
					a_Enum
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_Proxy :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
				BSTR t_Query = SysAllocString ( a_Query ) ;

				if ( t_QueryLanguage && t_Query )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecNotificationQueryAsync (

						t_InternalContext ,
						a_QueryLanguage,
						a_Query,
						a_Flags,
						a_Context,
						a_Sink
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_QueryLanguage ) ;
				SysFreeString ( t_Query ) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->ExecNotificationQueryAsync (

					a_QueryLanguage,
					a_Query,
					a_Flags,
					a_Context,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CInterceptor_IWbemServices_Proxy :: ExecMethod ( 

	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
    IWbemClassObject **a_OutParams,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
				BSTR t_MethodName = SysAllocString ( a_MethodName ) ;

				if ( t_ObjectPath && t_MethodName )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecMethod (

						t_InternalContext ,
						t_ObjectPath,
						t_MethodName,
						a_Flags,
						a_Context,
						a_InParams,
						a_OutParams,
						a_CallResult
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_ObjectPath ) ;
				SysFreeString ( t_MethodName ) ;

			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->ExecMethod (

					a_ObjectPath,
					a_MethodName,
					a_Flags,
					a_Context,
					a_InParams,
					a_OutParams,
					a_CallResult
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CInterceptor_IWbemServices_Proxy :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
				BSTR t_MethodName = SysAllocString ( a_MethodName ) ;

				if ( t_ObjectPath && t_MethodName )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecMethodAsync (

						t_InternalContext ,
						t_ObjectPath,
						t_MethodName,
						a_Flags,
						a_Context,
						a_InParams,
						a_Sink
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_ObjectPath ) ;
				SysFreeString ( t_MethodName ) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->ExecMethodAsync (

					a_ObjectPath,
					a_MethodName,
					a_Flags,
					a_Context,
					a_InParams,
					a_Sink

				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: ServiceInitialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success )
	{
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_StatusCode = CWbemGlobal_VoidPointerController :: Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;
			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: AddObjectToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Path,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->AddObjectToRefresher (

					a_RefresherId ,
					a_Path,
					a_Flags ,
					a_Context,
					a_ClientRefresherVersion ,
					a_Information ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: AddObjectToRefresherByTemplate (

	WBEM_REFRESHER_ID *a_RefresherId ,
	IWbemClassObject *a_Template ,
	long a_Flags ,
	IWbemContext *a_Context ,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->AddObjectToRefresherByTemplate (

					a_RefresherId ,
					a_Template ,
					a_Flags ,
					a_Context ,
					a_ClientRefresherVersion ,
					a_Information ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
			else
			{
				t_Result = WBEM_E_NOT_AVAILABLE ;
			}
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: AddEnumToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->AddEnumToRefresher (

					a_RefresherId ,
					a_Class ,
					a_Flags ,
					a_Context,
					a_ClientRefresherVersion ,
					a_Information ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: RemoveObjectFromRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Id ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->RemoveObjectFromRefresher (

					a_RefresherId ,
					a_Id ,
					a_Flags ,
					a_ClientRefresherVersion ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: GetRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	IWbemRemoteRefresher **a_RemoteRefresher ,
	GUID *a_Guid ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->GetRemoteRefresher (

					a_RefresherId ,
					a_Flags ,
					a_ClientRefresherVersion ,
					a_RemoteRefresher ,
					a_Guid ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: ReconnectRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId,
	long a_Flags,
	long a_NumberOfObjects,
	DWORD a_ClientRefresherVersion ,
	WBEM_RECONNECT_INFO *a_ReconnectInformation ,
	WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->ReconnectRemoteRefresher (

					a_RefresherId,
					a_Flags,
					a_NumberOfObjects,
					a_ClientRefresherVersion ,
					a_ReconnectInformation ,
					a_ReconnectResults ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\stathread.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvRegInfo.h"
#include "ProvObSk.h"
#include "ProvInSk.h"
#include "StaThread.h"
#include "StaTask.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CServerObject_StaThread :: Initialize_Callback ()
{
	CoInitializeEx ( NULL , COINIT_APARTMENTTHREADED ) ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CServerObject_StaThread :: UnInitialize_Callback () 
{
	if ( m_User == NULL )
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Locale == NULL )
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_Scope ) 
	{
		delete [] m_Scope ;
	}

	if ( m_Namespace ) 
	{
		delete [] m_Namespace ;
	}
	
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}

	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	CoUninitialize () ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CServerObject_StaThread :: CallBackRelease ()
{
	if ( m_Provider_IUnknown )
	{
		m_Provider_IUnknown->Release () ;
		m_Provider_IUnknown = NULL ;
	}

	if ( m_Provider_IWbemServices )
	{
		m_Provider_IWbemServices->Release () ; 
		m_Provider_IWbemServices = NULL ;
	}

	if ( m_Provider_IWbemEventConsumerProvider )
	{
		m_Provider_IWbemEventConsumerProvider->Release () ;
		m_Provider_IWbemEventConsumerProvider = NULL ;
	}

	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		m_Provider_IWbemEventConsumerProviderEx->Release () ;
		m_Provider_IWbemEventConsumerProviderEx= NULL ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
		m_Provider_IWbemUnboundObjectSink = NULL ;
	}

	if ( m_Provider_IWbemEventProvider )
	{
		m_Provider_IWbemEventProvider->Release () ; 
		m_Provider_IWbemEventProvider = NULL ;
	}

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		m_Provider_IWbemEventProviderQuerySink->Release () ;
		m_Provider_IWbemEventProviderQuerySink = NULL ;
	}

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		m_Provider_IWbemEventProviderSecurity->Release () ;
		m_Provider_IWbemEventProviderSecurity = NULL ;
	}

	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;
}

#pragma warning( disable : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_StaThread :: CServerObject_StaThread (

	WmiAllocator &a_Allocator

) : WmiThread < ULONG > ( a_Allocator ) ,
	CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	m_Allocator ( a_Allocator ) ,
	m_Flags ( 0 ) ,
	m_Context ( NULL ) ,
	m_TransactionIdentifier ( NULL ) ,
	m_User ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Repository ( NULL ) ,
	m_Provider_IUnknown ( NULL ) ,
	m_Provider_IWbemServices ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_ProviderName ( NULL ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_Sta_Size , MAX_PROXIES )
{
	SetStackSize ( ProviderSubSystem_Common_Globals :: GetDefaultStackSize () ) ;

	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_StaThread_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_StaThread::~CServerObject_StaThread ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_StaThread_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: SetContext ( IWbemContext *a_Context )
{
	HRESULT t_Result = S_OK ;

	if ( a_Context ) 
	{
		m_Context = a_Context ;
		m_Context->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: SetScope ( LPCWSTR a_Scope )
{
	HRESULT t_Result = S_OK ;

	if ( a_Scope ) 
	{
		m_Scope = new wchar_t [ wcslen ( a_Scope ) + 1 ] ;
		if ( m_Scope )
		{
			wcscpy ( m_Scope , a_Scope ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: SetNamespace ( LPCWSTR a_Namespace )
{
	HRESULT t_Result = S_OK ;

	if ( a_Namespace ) 
	{
		m_Namespace = new wchar_t [ wcslen ( a_Namespace ) + 1 ] ;
		if ( m_Namespace )
		{
			wcscpy ( m_Namespace , a_Namespace ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: SetNamespacePath ( IWbemPath *a_NamespacePath )
{
	HRESULT t_Result = S_OK ;

	if ( a_NamespacePath ) 
	{
		m_NamespacePath = a_NamespacePath ;
		m_NamespacePath->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: SetRepository ( IWbemServices *a_Repository )
{
	HRESULT t_Result = S_OK ;

	if ( a_Repository ) 
	{
		m_Repository = a_Repository ;
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: SetProviderService ( IUnknown *a_ProviderService ) 
{
	HRESULT t_Result = S_OK ;

	if ( a_ProviderService ) 
	{
		m_Provider_IUnknown = a_ProviderService ;
		m_Provider_IUnknown->AddRef () ;

		HRESULT t_TempResult = a_ProviderService->QueryInterface ( IID_IWbemServices , ( void ** ) & m_Provider_IWbemServices ) ;
		t_TempResult = a_ProviderService->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
		t_TempResult = a_ProviderService->QueryInterface ( IID_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_IWbemEventConsumerProviderEx ) ;
		t_TempResult = a_ProviderService->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
		t_TempResult = a_ProviderService->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
		t_TempResult = a_ProviderService->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;
		t_TempResult = a_ProviderService->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: SetProviderName ( wchar_t *a_ProviderName ) 
{
	HRESULT t_Result = S_OK ;

	if ( m_ProviderName ) 
	{
		delete [] m_ProviderName ;
	}

	m_ProviderName = new wchar_t [ wcslen ( a_ProviderName ) + 1 ] ;
	if ( m_ProviderName )
	{
		wcscpy ( m_ProviderName , a_ProviderName ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: InitializeProvider (

	GUID *a_TransactionIdentifier ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Namespace ,
	IWbemPath *a_NamespacePath ,
	IWbemServices *a_Repository ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Scope ,
	CServerObject_ProviderRegistrationV1 &a_Registration
) 
{
	wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;

	if ( a_TransactionIdentifier )
	{
		StringFromGUID2 ( *a_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
	}

	if ( a_Registration.GetEventProviderRegistration ().Supported () )
	{
		IWbemProviderIdentity *t_ProviderIdentity = NULL ;
		HRESULT t_Result = m_Provider_IUnknown->QueryInterface ( IID_IWbemProviderIdentity , ( void ** ) & t_ProviderIdentity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemProviderIdentity , t_ProviderIdentity , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_ProviderIdentity->SetRegistrationObject (

							0 ,
							a_Registration.GetIdentity () 
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemProviderIdentity *t_ProviderIdentityProxy = ( IWbemProviderIdentity * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_ProviderIdentityProxy ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								try
								{
									t_Result = t_ProviderIdentityProxy->SetRegistrationObject (

										0 ,
										a_Registration.GetIdentity () 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}	

						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}	

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_ProviderIdentity->Release () ;
		}
	}

	IWbemProviderInit *t_ProviderInit = NULL ;
	HRESULT t_Result = m_Provider_IUnknown->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & t_ProviderInit ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Registration.GetComRegistration ().PerUserInitialization () && a_Registration.GetComRegistration ().InitializeAsAdminFirst () )
		{
			CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
			if ( t_ProviderInitSink )
			{
				t_ProviderInitSink->AddRef () ;

				t_Result = t_ProviderInitSink->SinkInitialize ( a_Registration.GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						BOOL t_Impersonating = FALSE ;
						IUnknown *t_OldContext = NULL ;
						IServerSecurity *t_OldSecurity = NULL ;

						t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							BOOL t_Revert = FALSE ;
							IUnknown *t_Proxy = NULL ;

							t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemProviderInit , t_ProviderInit , t_Proxy , t_Revert ) ;
							if ( t_Result == WBEM_E_NOT_FOUND )
							{
								try
								{
									t_Result = t_ProviderInit->Initialize (

										NULL ,
										0 ,
										( const BSTR ) a_Namespace ,
										a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
										a_Repository ,
										a_Context ,
										t_Sink    
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								if ( SUCCEEDED ( t_Result ) )
								{
									IWbemProviderInit *t_ProviderInitProxy = ( IWbemProviderInit * ) t_Proxy ;

									// Set cloaking on the proxy
									// =========================

									DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

									t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

										t_ProviderInitProxy ,
										RPC_C_AUTHN_LEVEL_CONNECT , 
										t_ImpersonationLevel
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										t_Result = CoImpersonateClient () ;
										if ( SUCCEEDED ( t_Result ) )
										{
											try
											{
												t_Result = t_ProviderInitProxy->Initialize (

													NULL ,
													0 ,
													( const BSTR ) a_Namespace ,
													a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
													a_Repository ,
													a_Context ,
													t_Sink    
												) ;
											}
											catch ( ... )
											{
												t_Result = WBEM_E_PROVIDER_FAILURE ;
											}

											CoRevertToSelf () ;
										}
										else
										{
											t_Result = WBEM_E_ACCESS_DENIED ;
										}
									}	

									HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
								}
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								t_ProviderInitSink->Wait ( a_Registration.GetInitializationTimeoutMilliSeconds () ) ;
								t_Result = t_ProviderInitSink->GetResult () ;
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								WmiSetAndCommitObject (

									ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationEvent ] , 
									WMI_SENDCOMMIT_SET_NOT_REQUIRED,
									a_Namespace,
									a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
									a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
									a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
									a_TransactionIdentifier ? t_TransactionIdentifier : NULL
								) ;
							}
							else
							{
								WmiSetAndCommitObject (

									ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationFailureEvent ] , 
									WMI_SENDCOMMIT_SET_NOT_REQUIRED,
									a_Namespace,
									a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
									a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
									a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
									a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
									t_Result 
								) ;

								t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
							}

							ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
						}	

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				t_ProviderInitSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )	
		{
			CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
			if ( t_ProviderInitSink )
			{
				t_ProviderInitSink->AddRef () ;

				t_Result = t_ProviderInitSink->SinkInitialize ( a_Registration.GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						BOOL t_Impersonating = FALSE ;
						IUnknown *t_OldContext = NULL ;
						IServerSecurity *t_OldSecurity = NULL ;

						t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							BOOL t_Revert = FALSE ;
							IUnknown *t_Proxy = NULL ;

							t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemProviderInit , t_ProviderInit , t_Proxy , t_Revert ) ;
							if ( t_Result == WBEM_E_NOT_FOUND )
							{
								try
								{
									t_Result = t_ProviderInit->Initialize (

										a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
										0 ,
										( const BSTR ) a_Namespace ,
										a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
										a_Repository ,
										a_Context ,
										t_Sink    
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								if ( SUCCEEDED ( t_Result ) )
								{
									IWbemProviderInit *t_ProviderInitProxy = ( IWbemProviderInit * ) t_Proxy ;

									// Set cloaking on the proxy
									// =========================

									DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

									t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

										t_ProviderInitProxy ,
										RPC_C_AUTHN_LEVEL_CONNECT , 
										t_ImpersonationLevel
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										t_Result = CoImpersonateClient () ;
										if ( SUCCEEDED ( t_Result ) )
										{
											try
											{
												t_Result = t_ProviderInitProxy->Initialize (

													a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
													0 ,
													( const BSTR ) a_Namespace ,
													a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
													a_Repository ,
													a_Context ,
													t_Sink    
												) ;
											}
											catch ( ... )
											{
												t_Result = WBEM_E_PROVIDER_FAILURE ;
											}

											CoRevertToSelf () ;
										}
										else
										{
											t_Result = WBEM_E_ACCESS_DENIED ;
										}
									}	

									HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
								}
							}	

							if ( SUCCEEDED ( t_Result ) )
							{
								t_ProviderInitSink->Wait ( a_Registration.GetInitializationTimeoutMilliSeconds () ) ;
								t_Result = t_ProviderInitSink->GetResult () ;
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								WmiSetAndCommitObject (

									ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationEvent ] , 
									WMI_SENDCOMMIT_SET_NOT_REQUIRED,
									a_Namespace,
									a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
									a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
									a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
									a_TransactionIdentifier ? t_TransactionIdentifier : NULL
								) ;
							}
							else
							{
								WmiSetAndCommitObject (

									ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationFailureEvent ] , 
									WMI_SENDCOMMIT_SET_NOT_REQUIRED,
									a_Namespace,
									a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
									a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
									a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
									a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
									t_Result 
								) ;

								t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
							}

							ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				t_ProviderInitSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		t_ProviderInit->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: GetApartmentInstanceProvider (

	GUID *a_TransactionIdentifier ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Namespace ,
	IWbemPath *a_NamespacePath ,
	IWbemServices *a_Repository ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Scope ,
	CServerObject_ProviderRegistrationV1 &a_Registration
) 
{
	HRESULT t_Result = S_OK ;

	m_TransactionIdentifier = a_TransactionIdentifier ;

	if ( a_User )
	{
		m_User = SysAllocString ( ( LPWSTR ) a_User ) ;
		if ( m_User == NULL )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			return t_Result ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Locale )
		{
			m_Locale = SysAllocString ( ( LPWSTR ) a_Locale ) ;
			if ( m_Locale == NULL ) 
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = SetScope ( a_Scope ) ;
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = SetNamespace ( a_Namespace ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = SetNamespacePath ( a_NamespacePath ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_Flags = a_Flags ;

		StaTask_Create *t_Task = new StaTask_Create ( 

			m_Allocator ,
			*this ,
			a_Scope ,
			a_Namespace
		) ;

		if ( t_Task )
		{
			t_Task->AddRef () ;

			if ( t_Task->Initialize () == e_StatusCode_Success ) 
			{
				t_Result = t_Task->MarshalContext ( 

					a_Context ,
					a_Repository 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					WmiStatusCode t_StatusCode = EnQueue ( 

						0 ,
						*t_Task
					) ;

					if ( t_StatusCode == e_StatusCode_Success )
					{
						t_StatusCode = t_Task->WaitInterruptable ( INFINITE ) ;
						if ( t_StatusCode == e_StatusCode_Success )
						{
							t_Result = t_Task->GetResultCode () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Task->UnMarshalOutgoing () ;
								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = InitializeProvider (

										a_TransactionIdentifier ,
										a_User ,
										a_Locale ,
										a_Namespace ,
										a_NamespacePath ,
										a_Repository ,
										a_Flags ,
										a_Context ,
										a_Scope ,
										a_Registration
									) ;
								}
							}
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			t_Task->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_StaThread :: AddRef ( void )
{
	return WmiThread <ULONG> :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_StaThread :: Release ( void )
{
	return WmiThread <ULONG> :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_StaThread :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}	
	else if ( iid == IID_IWbemServices )
	{
		if ( m_Provider_IWbemServices )
		{
			*iplpv = ( LPVOID ) ( IWbemServices * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProvider )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProvider * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread::OpenNamespace ( 

	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemServices **a_NamespaceService, 
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->CancelAsyncCall (

						a_Sink
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: QueryObjectSink ( 

	long a_Flags,		
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: GetObject ( 
		
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject **a_Object,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->GetObjectAsync (

						a_ObjectPath, 
						a_Flags, 
						a_Context,
						a_Sink
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: PutClass ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemCallResult ** a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: PutClassAsync ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

 HRESULT CServerObject_StaThread :: DeleteClass ( 
		
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: DeleteClassAsync ( 
		
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: CreateClassEnum ( 

	const BSTR a_Superclass, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CServerObject_StaThread :: CreateClassEnumAsync (

	const BSTR a_Superclass, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: PutInstance (

    IWbemClassObject *a_Instance,
    long a_Flags,
    IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags, 
    IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->PutInstanceAsync (

						a_Instance, 
						a_Flags, 
						a_Context,
						a_Sink
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: DeleteInstance ( 

	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CServerObject_StaThread :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink	
)
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->DeleteInstanceAsync (

						a_ObjectPath,
						a_Flags,
						a_Context,
						a_Sink
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: CreateInstanceEnumAsync (

 	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink

) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->CreateInstanceEnumAsync ( 

						a_Class ,
						a_Flags , 
						a_Context ,
						a_Sink
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->ExecQueryAsync (

						a_QueryLanguage, 
						a_Query, 
						a_Flags, 
						a_Context,
						a_Sink
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CServerObject_StaThread :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CServerObject_StaThread :: ExecMethod( 

	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
    IWbemClassObject **a_OutParams,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CServerObject_StaThread :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->ExecMethodAsync (

						a_ObjectPath,
						a_MethodName,
						a_Flags,
						a_Context,
						a_InParams,
						a_Sink
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: ProvideEvents ( 
		
	IWbemObjectSink *a_Sink ,
	long a_Flags
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemEventProvider )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventProvider , IID_IWbemEventProvider , m_Provider_IWbemEventProvider , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemEventProvider *t_Provider = ( IWbemEventProvider * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->ProvideEvents (

						a_Sink ,
						a_Flags
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventProvider , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventProviderQuerySink , IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->NewQuery (

						a_Id ,
						a_QueryLanguage ,
						a_Query
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: CancelQuery (

	unsigned long a_Id
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventProviderQuerySink , IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->CancelQuery (

						a_Id 
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventProviderSecurity , IID_IWbemEventProviderSecurity , m_Provider_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemEventProviderSecurity *t_Provider = ( IWbemEventProviderSecurity * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->AccessCheck (

						a_QueryLanguage ,
						a_Query ,
						a_SidLength ,
						a_Sid
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	if ( m_Provider_IWbemEventConsumerProvider )
	{
		IWbemUnboundObjectSink *t_Consumer = NULL ;

		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventConsumerProvider , IID_IWbemEventConsumerProvider , m_Provider_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				try
				{
					t_Result = m_Provider_IWbemEventConsumerProvider->FindConsumer (

						a_LogicalConsumer ,
						& t_Consumer
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventConsumerProvider *t_Provider = ( IWbemEventConsumerProvider * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							try
							{
								t_Result = t_Provider->FindConsumer (

									a_LogicalConsumer ,
									& t_Consumer
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( a_Consumer )
			{
				CInterceptor_IWbemSyncUnboundObjectSink *t_UnboundObjectSink = new CInterceptor_IWbemSyncUnboundObjectSink (

						m_Allocator ,
						t_Consumer , 
						this ,
						*m_Registration
				) ;

				if ( t_UnboundObjectSink )
				{
					t_UnboundObjectSink->AddRef () ;

					t_Result = t_UnboundObjectSink->Initialize () ;
					if ( SUCCEEDED ( t_Result ) )
					{
						CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

						Lock () ;

						WmiStatusCode t_StatusCode = Insert ( 

							*t_UnboundObjectSink ,
							t_Iterator
						) ;

						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							UnLock () ;

							*a_Consumer = t_UnboundObjectSink ;

							t_UnboundObjectSink->AddRef () ;
						}
						else
						{
							UnLock () ;

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_UnboundObjectSink->Release () ;
				}
			}
		}

		if ( t_Consumer )
		{
			t_Consumer->Release () ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventConsumerProviderEx , IID_IWbemEventConsumerProviderEx , m_Provider_IWbemEventConsumerProviderEx , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				try
				{
					t_Result = m_Provider_IWbemEventConsumerProviderEx->ValidateSubscription (

						a_LogicalConsumer
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventConsumerProviderEx *t_Provider = ( IWbemEventConsumerProviderEx * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							try
							{
								t_Result = t_Provider->ValidateSubscription (

									a_LogicalConsumer
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventConsumerProviderEx , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemUnboundObjectSink , IID_IWbemUnboundObjectSink , m_Provider_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Provider_IWbemUnboundObjectSink->IndicateToConsumer (


					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemUnboundObjectSink *t_Provider = ( IWbemUnboundObjectSink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Provider->IndicateToConsumer (

							a_LogicalConsumer ,
							a_ObjectCount ,
							a_Objects
						) ;
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_Core,
	IWbemContext *a_Context,
	IWbemProviderInitSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	Lock () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

	while ( ! t_Iterator.Null () )
	{
		IWbemShutdown *t_Shutdown = NULL ;
		t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;

		t_Iterator.Increment () ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Shutdown->Shutdown ( 

				a_Flags ,
				a_MaxMilliSeconds ,
				a_Context
			) ;

			t_Shutdown->Release () ;
		}
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	UnLock () ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\strobethread.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvSubS.h"
#include "Guids.h"
#include "StrobeThread.h"
#include "ProvCache.h"
#include "ProvHost.h"
#include "ProvWsv.h"

#if 0
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode StrobeThread :: Initialize_Callback ()
{
	CoInitializeEx ( NULL , COINIT_MULTITHREADED ) ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode StrobeThread :: UnInitialize_Callback () 
{
	CoUninitialize () ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

StrobeThread :: StrobeThread (

	WmiAllocator &a_Allocator ,
	const ULONG &a_Timeout 

) : WmiThread < ULONG > ( a_Allocator , NULL , a_Timeout ) ,
	m_Allocator ( a_Allocator )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_StrobeThread_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

StrobeThread::~StrobeThread ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_StrobeThread_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


WmiStatusCode StrobeThread :: TimedOut ()
{
	try 
	{
		ULONG t_NextStrobeDelta = 0xFFFFFFFF ;

		CWbemGlobal_IWbemRefresherMgrController *t_RefresherManagerController = ProviderSubSystem_Globals :: GetRefresherManagerController () ;
		t_RefresherManagerController->Strobe ( t_NextStrobeDelta ) ;

		CWbemGlobal_IWmiHostController *t_HostController = ProviderSubSystem_Globals :: GetHostController () ;
		t_HostController->Strobe ( t_NextStrobeDelta ) ;

		CWbemGlobal_IWmiProvSubSysController *t_ProvSubSysController = ProviderSubSystem_Globals :: GetProvSubSysController () ;

		CWbemGlobal_IWmiProvSubSysController_Container *t_Container = NULL ;
		WmiStatusCode t_StatusCode = t_ProvSubSysController->GetContainer ( t_Container ) ;

		t_ProvSubSysController->Lock () ;

		CWbemGlobal_IWmiFactoryController **t_ShutdownElements = new CWbemGlobal_IWmiFactoryController * [ t_Container->Size () ] ;
		if ( t_ShutdownElements )
		{
			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator = t_Container->Begin () ;

			ULONG t_Count = 0 ;
			while ( ! t_Iterator.Null () )
			{
				CWbemGlobal_IWmiFactoryController *t_FactoryController = NULL ;
				ProvSubSysContainerElement *t_Element = t_Iterator.GetElement () ;

				HRESULT t_Result = t_Element->QueryInterface ( IID_CWbemGlobal_IWmiFactoryController , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

				t_Iterator.Increment () ;

				t_Count ++ ;
			}

			t_ProvSubSysController->UnLock () ;

			for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
			{
				if ( t_ShutdownElements [ t_Index ] ) 
				{
					t_ShutdownElements [ t_Index ]->Strobe ( t_NextStrobeDelta ) ;

					t_ShutdownElements [ t_Index ]->Release () ;
				}
			}

			delete [] t_ShutdownElements ;
		}
		else
		{
			t_ProvSubSysController->UnLock () ;
		}

		SetTimeout ( t_NextStrobeDelta ) ;

		// CoFreeUnusedLibraries () ;
	}
	catch ( ... )
	{
	}

	return e_StatusCode_Success ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


WmiStatusCode StrobeThread :: Shutdown ()
{
	CWbemGlobal_IWmiProvSubSysController *t_ProvSubSysController = ProviderSubSystem_Globals :: GetProvSubSysController () ;
	t_ProvSubSysController->Shutdown () ;

	return e_StatusCode_Success ;
}


#endif

StrobeThread :: StrobeThread (WmiAllocator &a_Allocator , DWORD timeout) :
	m_Allocator ( a_Allocator ), timeout_(timeout)
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_StrobeThread_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

#if 0
wchar_t t_Buffer [ 128 ] ;
wsprintf ( t_Buffer , L"\n%lx - StrobeThread :: StrobeThread () " , GetTickCount () ) ;
OutputDebugString ( t_Buffer ) ;
#endif

}

StrobeThread::~StrobeThread ()
{
	CWbemGlobal_IWmiProvSubSysController *t_ProvSubSysController = ProviderSubSystem_Globals :: GetProvSubSysController () ;
	t_ProvSubSysController->Shutdown () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_StrobeThread_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

int  StrobeThread :: handleTimeout ()
{
#if 0
wchar_t t_Buffer [ 128 ] ;
wsprintf ( t_Buffer , L"\n%lx - StrobeThread :: TimedOut () " , GetTickCount () ) ;
OutputDebugString ( t_Buffer ) ;
#endif

	CoInitializeEx ( NULL , COINIT_MULTITHREADED ) ;
	ULONG t_NextStrobeDelta = 0xFFFFFFFF ;
	try 
	{
		CWbemGlobal_IWbemRefresherMgrController *t_RefresherManagerController = ProviderSubSystem_Globals :: GetRefresherManagerController () ;
		t_RefresherManagerController->Strobe ( t_NextStrobeDelta ) ;

		CWbemGlobal_IWmiHostController *t_HostController = ProviderSubSystem_Globals :: GetHostController () ;
		t_HostController->Strobe ( t_NextStrobeDelta ) ;

		CWbemGlobal_IWmiProvSubSysController *t_ProvSubSysController = ProviderSubSystem_Globals :: GetProvSubSysController () ;

		CWbemGlobal_IWmiProvSubSysController_Container *t_Container = NULL ;
		WmiStatusCode t_StatusCode = t_ProvSubSysController->GetContainer ( t_Container ) ;

		t_ProvSubSysController->Lock () ;

		CWbemGlobal_IWmiFactoryController **t_ShutdownElements = new CWbemGlobal_IWmiFactoryController * [ t_Container->Size () ] ;
		if ( t_ShutdownElements )
		{
			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator = t_Container->Begin () ;

			ULONG t_Count = 0 ;
			while ( ! t_Iterator.Null () )
			{
				CWbemGlobal_IWmiFactoryController *t_FactoryController = NULL ;
				ProvSubSysContainerElement *t_Element = t_Iterator.GetElement () ;

				HRESULT t_Result = t_Element->QueryInterface ( IID_CWbemGlobal_IWmiFactoryController , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

				t_Iterator.Increment () ;

				t_Count ++ ;
			}

			t_ProvSubSysController->UnLock () ;

			for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
			{
				if ( t_ShutdownElements [ t_Index ] ) 
				{
					t_ShutdownElements [ t_Index ]->Strobe ( t_NextStrobeDelta ) ;

#if 0
wsprintf ( t_Buffer , L"\n%lx - StrobeThread :: Next ( %lx ) " , GetTickCount () , t_NextStrobeDelta ) ;
OutputDebugString ( t_Buffer ) ;
#endif

					t_ShutdownElements [ t_Index ]->Release () ;
				}
			}

			delete [] t_ShutdownElements ;
		}
		else
		{
			t_ProvSubSysController->UnLock () ;
		}
	}
	catch ( ... )
	{
	}

	Dispatcher::changeTimer(*this, t_NextStrobeDelta);

	CoUninitialize () ;

#if 0
wsprintf ( t_Buffer , L"\n%lx - StrobeThread :: TimedOut ( %lx ) " , GetTickCount () , t_NextStrobeDelta ) ;
OutputDebugString ( t_Buffer ) ;
#endif

	return 0 ;
}



Task_ProcessTermination :: Task_ProcessTermination (

	WmiAllocator &a_Allocator ,
	HANDLE a_Process ,
	DWORD a_ProcessIdentifier 

):	m_ProcessIdentifier ( a_ProcessIdentifier ),
	processHandle_(a_Process)
{
	
}

Task_ProcessTermination::~Task_ProcessTermination()	
{
	CloseHandle(processHandle_);
}

HANDLE Task_ProcessTermination::getHandle()	
{
	return processHandle_;
}

int Task_ProcessTermination::handleEvent()	
{
	try
	{

 
//	Discard entities in host.
 

		CWbemGlobal_HostedProviderController *t_Controller = ProviderSubSystem_Globals :: GetHostedProviderController () ;

		t_Controller->Lock () ;

		CWbemGlobal_HostedProviderController_Container_Iterator t_Iterator ;

		WmiStatusCode t_StatusCode = t_Controller->Find ( m_ProcessIdentifier , t_Iterator ) ;
		switch ( t_StatusCode )
		{
			case e_StatusCode_Success:
			{
				HostedProviderContainerElement *t_Element = t_Iterator.GetElement () ;

				t_StatusCode = t_Controller->Delete ( m_ProcessIdentifier ) ;

				t_Controller->UnLock () ;

				ProviderController *t_ProviderController = NULL ;
				HRESULT t_Result = t_Element->QueryInterface ( IID_ProviderController , ( void ** ) & t_ProviderController ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_ProviderController->Lock () ;

					ProviderController :: Container *t_Container = NULL ;

					t_StatusCode = t_ProviderController->GetContainer ( t_Container ) ;

					CInterceptor_IWbemProvider **t_InterceptorElements = new CInterceptor_IWbemProvider * [ t_Container->Size () ] ;
					if ( t_InterceptorElements )
					{
						ProviderController :: Container_Iterator t_Iterator = t_Container->Begin () ;
		
						ULONG t_Count = 0 ;
						while ( ! t_Iterator.Null () )
						{
							t_InterceptorElements [ t_Count ] = t_Iterator.GetElement ();
							
							t_ProviderController->Delete ( t_Iterator.GetKey () ) ;

							t_Iterator = t_Container->Begin () ;

							t_Count ++ ;
						}

						t_ProviderController->UnLock () ;

						for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
						{
							if ( t_InterceptorElements [ t_Index ] ) 
							{
								t_Result = t_InterceptorElements [ t_Index ]->AbnormalShutdown () ;

								t_InterceptorElements [ t_Index ]->NonCyclicRelease () ;
							}
						}

						delete [] t_InterceptorElements ;
					}
					else
					{
						t_ProviderController->UnLock () ;
					}

					t_ProviderController->Release () ;
				}

				t_Element->Release () ;
			}
			break ;
		
			default:
			{
				t_Controller->UnLock () ;
			}
			break ;
		}

 
//	Discard of host.
 

		CWbemGlobal_IWmiHostController_Cache *t_Cache = NULL ;
		ProviderSubSystem_Globals :: GetHostController ()->GetCache ( t_Cache ) ;

		ProviderSubSystem_Globals :: GetHostController ()->Lock () ;

		ULONG t_Count = 0 ;
		CServerObject_HostInterceptor **t_InterceptorElements = new CServerObject_HostInterceptor * [ t_Cache->Size () ] ;
		if ( t_InterceptorElements )
		{
			CWbemGlobal_IWmiHostController_Cache_Iterator t_HostIterator = t_Cache->Begin () ;
			while ( ! t_HostIterator.Null () )
			{
				HostCacheElement *t_Element = t_HostIterator.GetElement () ;

				t_InterceptorElements [ t_Count ] = NULL ;

				HRESULT t_Result = t_Element->QueryInterface (

					IID_CServerObject_HostInterceptor ,
					( void ** ) & t_InterceptorElements [ t_Count ] 
				) ;

				t_HostIterator.Increment () ;

				t_Count ++ ;
			}
		}

		ProviderSubSystem_Globals :: GetHostController ()->UnLock () ;

		if ( t_InterceptorElements )
		{
			for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
			{
				if ( t_InterceptorElements [ t_Index ] ) 
				{
					if ( t_InterceptorElements [ t_Index ]->GetProcessIdentifier () == m_ProcessIdentifier )
					{
						ProviderSubSystem_Globals :: GetHostController ()->Shutdown ( t_InterceptorElements [ t_Index ]->GetKey () ) ; 
					}

					t_InterceptorElements [ t_Index ]->Release () ;
				}
			}

			delete [] t_InterceptorElements ;
		}
	}
	catch ( ... )
	{
	}

	return -1;	// remove from queue
}











#if 0

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

Task_ProcessTermination :: Task_ProcessTermination (

	WmiAllocator &a_Allocator ,
	HANDLE a_Process ,
	DWORD a_ProcessIdentifier 

) : WmiTask < ULONG > ( a_Allocator , a_Process , NULL , NULL , NULL ) ,
	m_ProcessIdentifier ( a_ProcessIdentifier )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

Task_ProcessTermination :: ~Task_ProcessTermination ()
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode Task_ProcessTermination :: Process ( WmiThread <ULONG > &a_Thread )
{
	try
	{

 
//	Discard entities in host.
 

		CWbemGlobal_HostedProviderController *t_Controller = ProviderSubSystem_Globals :: GetHostedProviderController () ;

		t_Controller->Lock () ;

		CWbemGlobal_HostedProviderController_Container_Iterator t_Iterator ;

		WmiStatusCode t_StatusCode = t_Controller->Find ( m_ProcessIdentifier , t_Iterator ) ;
		switch ( t_StatusCode )
		{
			case e_StatusCode_Success:
			{
				HostedProviderContainerElement *t_Element = t_Iterator.GetElement () ;

				t_StatusCode = t_Controller->Delete ( m_ProcessIdentifier ) ;

				t_Controller->UnLock () ;

				ProviderController *t_ProviderController = NULL ;
				HRESULT t_Result = t_Element->QueryInterface ( IID_ProviderController , ( void ** ) & t_ProviderController ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_ProviderController->Lock () ;

					ProviderController :: Container *t_Container = NULL ;

					t_StatusCode = t_ProviderController->GetContainer ( t_Container ) ;

					CInterceptor_IWbemProvider **t_InterceptorElements = new CInterceptor_IWbemProvider * [ t_Container->Size () ] ;
					if ( t_InterceptorElements )
					{
						ProviderController :: Container_Iterator t_Iterator = t_Container->Begin () ;
		
						ULONG t_Count = 0 ;
						while ( ! t_Iterator.Null () )
						{
							t_InterceptorElements [ t_Count ] = t_Iterator.GetElement ();
							
							t_ProviderController->Delete ( t_Iterator.GetKey () ) ;

							t_Iterator = t_Container->Begin () ;

							t_Count ++ ;
						}

						t_ProviderController->UnLock () ;

						for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
						{
							if ( t_InterceptorElements [ t_Index ] ) 
							{
								t_Result = t_InterceptorElements [ t_Index ]->AbnormalShutdown () ;

								t_InterceptorElements [ t_Index ]->NonCyclicRelease () ;
							}
						}

						delete [] t_InterceptorElements ;
					}
					else
					{
						t_ProviderController->UnLock () ;
					}

					t_ProviderController->Release () ;
				}

				t_Element->Release () ;
			}
			break ;
		
			default:
			{
				t_Controller->UnLock () ;
			}
			break ;
		}

 
//	Discard of host.
 

		CWbemGlobal_IWmiHostController_Cache *t_Cache = NULL ;
		ProviderSubSystem_Globals :: GetHostController ()->GetCache ( t_Cache ) ;

		ProviderSubSystem_Globals :: GetHostController ()->Lock () ;

		CWbemGlobal_IWmiHostController_Cache_Iterator t_HostIterator = t_Cache->Begin () ;
		while ( ! t_HostIterator.Null () )
		{
			HostCacheElement *t_Element = t_HostIterator.GetElement () ;

			CServerObject_HostInterceptor *t_HostInterceptor = NULL ;

			HRESULT t_Result = t_Element->QueryInterface (

				IID_CServerObject_HostInterceptor ,
				( void ** ) & t_HostInterceptor
			) ;

			ProviderSubSystem_Globals :: GetHostController ()->UnLock () ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_HostInterceptor->GetProcessIdentifier () == m_ProcessIdentifier )
				{
					ProviderSubSystem_Globals :: GetHostController ()->Shutdown ( t_HostIterator.GetKey () ) ; 

					t_HostIterator = t_Cache->Begin () ;
				}
				else
				{
					t_HostIterator.Increment () ;
				}

				t_HostInterceptor->Release () ;
			}
			else
			{
				t_HostIterator.Increment () ;
			}

			ProviderSubSystem_Globals :: GetHostController ()->Lock () ;
		}

		ProviderSubSystem_Globals :: GetHostController ()->UnLock () ;

	}
	catch ( ... )
	{
	}

	Complete () ;

	return e_StatusCode_Success ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\classfac.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ClassFac.h

Abstract:


History:

--*/

#ifndef _ServerClassFactory_H
#define _ServerClassFactory_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
class CServerClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

    CServerClassFactory () ;
    ~CServerClassFactory () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerProvSubSysClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

    CServerProvSubSysClassFactory () ;
    ~CServerProvSubSysClassFactory () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerProvRefreshManagerClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

    CServerProvRefreshManagerClassFactory () ;
    ~CServerProvRefreshManagerClassFactory () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};


#include <classfac.cpp>

#endif // _ServerClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\globals.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _Globals_H
#define _Globals_H

#include <pssException.h>
#include <Allocator.h>
#include <BasicTree.h>
#include <PQueue.h>
#include <ReaderWriter.h>

#include "ProvCntrs.h"
#include "ProvCache.h"
#include "ProvDcAggr.h"
#include "StrobeThread.h"
#include <lockst.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Event_Identifier {

	Msft_WmiProvider_ComServerLoadOperationEvent = 0 ,
	Msft_WmiProvider_ComServerOperationFailureEvent ,
	Msft_WmiProvider_LoadOperationEvent ,
	Msft_WmiProvider_LoadOperationFailureEvent ,
	Msft_WmiProvider_InitializationOperationFailureEvent ,
	Msft_WmiProvider_InitializationOperationEvent ,
	Msft_WmiProvider_UnLoadOperationEvent ,
#if 0
	Msft_WmiProvider_HostLoadOperationEvent ,
	Msft_WmiProvider_HostLoadFailureOperationEvent ,
	Msft_WmiProvider_HostUnLoadOperationEvent ,
#endif
	Msft_WmiProvider_GetObjectAsyncEvent_Pre ,
	Msft_WmiProvider_PutClassAsyncEvent_Pre ,
	Msft_WmiProvider_DeleteClassAsyncEvent_Pre ,
	Msft_WmiProvider_CreateClassEnumAsyncEvent_Pre ,
	Msft_WmiProvider_PutInstanceAsyncEvent_Pre ,
	Msft_WmiProvider_DeleteInstanceAsyncEvent_Pre ,
	Msft_WmiProvider_CreateInstanceEnumAsyncEvent_Pre ,
	Msft_WmiProvider_ExecQueryAsyncEvent_Pre ,
	Msft_WmiProvider_ExecNotificationQueryAsyncEvent_Pre ,
	Msft_WmiProvider_ExecMethodAsyncEvent_Pre ,

	Msft_WmiProvider_ProvideEvents_Pre ,
	Msft_WmiProvider_AccessCheck_Pre ,
	Msft_WmiProvider_CancelQuery_Pre ,
	Msft_WmiProvider_NewQuery_Pre ,

	Msft_WmiProvider_GetObjectAsyncEvent_Post ,
	Msft_WmiProvider_PutClassAsyncEvent_Post ,
	Msft_WmiProvider_DeleteClassAsyncEvent_Post ,
	Msft_WmiProvider_CreateClassEnumAsyncEvent_Post ,
	Msft_WmiProvider_PutInstanceAsyncEvent_Post ,
	Msft_WmiProvider_DeleteInstanceAsyncEvent_Post ,
	Msft_WmiProvider_CreateInstanceEnumAsyncEvent_Post ,
	Msft_WmiProvider_ExecQueryAsyncEvent_Post ,
	Msft_WmiProvider_ExecNotificationQueryAsyncEvent_Post ,
	Msft_WmiProvider_ExecMethodAsyncEvent_Post ,

	Msft_WmiProvider_ProvideEvents_Post ,
	Msft_WmiProvider_AccessCheck_Post ,
	Msft_WmiProvider_CancelQuery_Post ,
	Msft_WmiProvider_NewQuery_Post

} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class ProviderSubSystem_Globals
{
public:

	static LONG s_Initialized ;

	static WmiAllocator *s_Allocator ;

	static CriticalSection s_DecoupledRegistrySection ;

	static HANDLE s_FileMapping ;
	static CServerObject_ProviderSubsystem_Counters *s_SharedCounters ;

	static CriticalSection s_GuidTagSection ;
	static CWbemGlobal_ComServerTagContainer *s_GuidTag ;

	static HostController *s_HostController ;
	static RefresherManagerController *s_RefresherManagerController ;
	static CWbemGlobal_HostedProviderController *s_HostedProviderController ;
	static CWbemGlobal_IWmiProvSubSysController *s_ProvSubSysController ;
	static CWbemGlobal_IWbemSyncProviderController *s_SyncProviderController ;
	static CDecoupled_ProviderSubsystemRegistrar *s_DecoupledRegistrar ;
	static StrobeThread *s_StrobeThread ;

	static LONG s_LocksInProgress ;
	static LONG s_ObjectsInProgress ;

	static HANDLE s_CoFreeUnusedLibrariesEvent ;

	static LPCWSTR s_HostJobObjectName ;
	static HANDLE s_HostJobObject ;

	static ULONG s_InternalCacheTimeout ;
	static ULONG s_ObjectCacheTimeout ;
	static ULONG s_EventCacheTimeout ;
	static ULONG s_StrobeTimeout ;
	static SIZE_T s_Quota_ProcessMemoryLimitCount ;
	static SIZE_T s_Quota_JobMemoryLimitCount ;
	static SIZE_T s_Quota_PrivatePageCount ;
	static ULONG s_Quota_ProcessLimitCount ;
	static ULONG s_Quota_HandleCount ;
	static ULONG s_Quota_NumberOfThreads ;

    static LONG s_CServerClassFactory_ObjectsInProgress ;
    static LONG s_CAggregator_IWbemProvider_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemObjectSink_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemObjectSinkEx_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemFilteringObjectSink_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemSyncObjectSink_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemSyncObjectSinkEx_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemSyncFilteringObjectSink_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemCombiningObjectSink_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemWaitingObjectSink_ObjectsInProgress ;
    static LONG s_CInterceptor_IWbemProviderInitSink_ObjectsInProgress ;
    static LONG s_CInterceptor_IWbemProvider_ObjectsInProgress ;
    static LONG s_CInterceptor_IWbemSyncProvider_ObjectsInProgress ;
    static LONG s_CInterceptor_IWbemServices_Stub_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemServices_Proxy_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemServices_Interceptor_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemServices_RestrictingInterceptor_ObjectsInProgress ;
	static LONG s_CInterceptor_IEnumWbemClassObject_Stub_ObjectsInProgress ;
	static LONG s_CInterceptor_IEnumWbemClassObject_Proxy_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemUnboundObjectSink_ObjectsInProgress	;
	static LONG s_CInterceptor_IWbemSyncUnboundObjectSink_ObjectsInProgress	;
	static LONG s_CInterceptor_IWbemDecoupledProvider_ObjectsInProgress ;
	static LONG s_CDecoupled_IWbemUnboundObjectSink_ObjectsInProgress ;
	static LONG s_CServerObject_Host_ObjectsInProgress ;
	static LONG s_CServerObject_HostInterceptor_ObjectsInProgress ;
    static LONG s_CServerObject_BindingFactory_ObjectsInProgress ;
    static LONG s_CServerObject_DynamicPropertyProviderResolver_ObjectsInProgress ;
    static LONG s_CServerObject_IWbemServices_ObjectsInProgress ;
    static LONG s_CServerObject_ProviderSubsystem_Counters_ObjectsInProgress ;
    static LONG s_CServerObject_ProviderSubSystem_ObjectsInProgress ;
    static LONG s_CServerObject_RawFactory_ObjectsInProgress ;
    static LONG s_CServerObject_StaThread_ObjectsInProgress ;
    static LONG s_StaTask_Create_ObjectsInProgress ;
    static LONG s_StrobeThread_ObjectsInProgress ;
	static LONG s_CDecoupledAggregator_IWbemProvider_ObjectsInProgress ;
	static LONG s_CDecoupled_ProviderSubsystemRegistrar_ObjectsInProgress ;
	static LONG s_CServerObject_ProviderRefresherManager_ObjectsInProgress ;
	static LONG s_CServerObject_InterceptorProviderRefresherManager_ObjectsInProgress ;
	static LONG s_CServerProvRefreshManagerClassFactory_ObjectsInProgress ;

	static HRESULT Global_Startup () ;
	static HRESULT Global_Shutdown () ;

	static LPCWSTR s_FileMappingName ;

	static LPCWSTR s_QueryPrefix ;
	static ULONG s_QueryPrefixLen ;

	static LPCWSTR s_QueryPostfix ;
	static ULONG s_QueryPostfixLen ;

	static ULONG s_QueryConstantsLen ;

	static LPCWSTR s_Provider ;
	static ULONG s_ProviderLen ;

	static LPCWSTR s_Class ;
	static ULONG s_ClassLen ;

	static LPCWSTR s_Wql ;

	static LPCWSTR s_DynProps ;

	static LPCWSTR s_ClassContext ;
	static LPCWSTR s_InstanceContext ;
	static LPCWSTR s_PropertyContext ;

	static LPCWSTR s_Dynamic ;

	static LPCWSTR s_ProviderSubsystemEventSourceName ;
	static HANDLE s_NtEventLogSource ;

	static HANDLE s_EventSource ;
	static LPWSTR s_EventPropertySources [] ;
	static HANDLE s_EventClassHandles [] ;
	static ULONG s_EventClassHandlesSize ;

	static HRESULT CreateJobObject () ;
	static HRESULT DeleteJobObject () ;
	static HRESULT AssignProcessToJobObject ( HANDLE a_Handle ) ;

	static HRESULT Initialize_Events () ;
	static HRESULT UnInitialize_Events () ;

	static HRESULT Initialize_SharedCounters () ;
	static HRESULT UnInitialize_SharedCounters () ;

	static CWbemGlobal_ComServerTagContainer *GetGuidTag () ;
	static CriticalSection *GetGuidTagCriticalSection () ;

	static CriticalSection *GetDecoupledRegistrySection () ;

	static CWbemGlobal_IWmiProvSubSysController *GetProvSubSysController () ;

	static CWbemGlobal_IWbemSyncProviderController *GetSyncProviderController () ;

	static CWbemGlobal_HostedProviderController *GetHostedProviderController () ;

	static RefresherManagerController *GetRefresherManagerController () ;

	static HostController *GetHostController () ;

	static CServerObject_ProviderSubsystem_Counters *GetSharedCounters () { return s_SharedCounters ; }

	static StrobeThread &GetStrobeThread () { return *s_StrobeThread ; }

	static HANDLE GetNtEventSource () { return s_NtEventLogSource ; }

	static HRESULT ForwardReload (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Namespace ,
		LPCWSTR a_Provider
	) ;

	static BOOL CheckGuidTag ( const GUID &a_Guid ) ;
	static void InsertGuidTag ( const GUID &a_Guid ) ;
	static void DeleteGuidTag ( const GUID &a_Guid ) ;

	static HRESULT BeginThreadImpersonation (

		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating
	) ;

	static HRESULT EndThreadImpersonation (

		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_Impersonating 
	) ;

	static HRESULT Begin_IdentifyCall_PrvHost (

		WmiInternalContext a_InternalContext ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity
	) ;

	static HRESULT End_IdentifyCall_PrvHost (

		WmiInternalContext a_InternalContext ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating 
	) ;

	static HRESULT Begin_IdentifyCall_SvcHost (

		WmiInternalContext a_InternalContext ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity
	) ;

	static HRESULT End_IdentifyCall_SvcHost (

		WmiInternalContext a_InternalContext ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating
	) ;

	static LONG Increment_Global_Object_Count () ;
	static LONG Decrement_Global_Object_Count () ;
} ;

#endif // _Globals_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\guids.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Guids.h

Abstract:


History:

--*/

// {4F09F43F-5BD7-49e5-97D1-A9D8D148B76A}
DEFINE_GUID(IID_CWbemProviderSubSystem, 
0x4f09f43f, 0x5bd7, 0x49e5, 0x97, 0xd1, 0xa9, 0xd8, 0xd1, 0x48, 0xb7, 0x6a);

// {61FA9B2B-D06D-4014-8ADA-0054F43F9E8A}
DEFINE_GUID(IID_CWbemGlobal_IWmiProviderController, 
0x61fa9b2b, 0xd06d, 0x4014, 0x8a, 0xda, 0x0, 0x54, 0xf4, 0x3f, 0x9e, 0x8a);

// {45C4123B-827D-4a02-9C0F-DE8384E65F42}
DEFINE_GUID(IID_CWbemGlobal_IWmiFactoryController, 
0x45c4123b, 0x827d, 0x4a02, 0x9c, 0xf, 0xde, 0x83, 0x84, 0xe6, 0x5f, 0x42);

// {F7BF10E6-A310-4530-8B63-B3354C485E2D}
DEFINE_GUID(IID_CWbemGlobal_IWmiObjectSinkController, 
0xf7bf10e6, 0xa310, 0x4530, 0x8b, 0x63, 0xb3, 0x35, 0x4c, 0x48, 0x5e, 0x2d);

// {A28EE4AD-A6AC-4b08-884C-1C1EE6C85AAF}
DEFINE_GUID(IID_CWbemGlobal_IWmiSyncObjectSinkController, 
0xa28ee4ad, 0xa6ac, 0x4b08, 0x88, 0x4c, 0x1c, 0x1e, 0xe6, 0xc8, 0x5a, 0xaf);

// {5B19371B-5016-49c5-AFB6-E21919FB9B65}
DEFINE_GUID(IID_CWbemHostContainer, 
0x5b19371b, 0x5016, 0x49c5, 0xaf, 0xb6, 0xe2, 0x19, 0x19, 0xfb, 0x9b, 0x65);

// {3FA1662F-1CBF-4e1d-85C3-75D13D3DAAC8}
DEFINE_GUID(IID_CWbemSubSystemHook, 
0x3fa1662f, 0x1cbf, 0x4e1d, 0x85, 0xc3, 0x75, 0xd1, 0x3d, 0x3d, 0xaa, 0xc8);

// {2CBDE6A3-350A-4c37-BAD0-BAC62FE2AB2A}
DEFINE_GUID(IID_ProviderController, 
0x2cbde6a3, 0x350a, 0x4c37, 0xba, 0xd0, 0xba, 0xc6, 0x2f, 0xe2, 0xab, 0x2a);

// {3DCDD390-8853-40f2-99E2-EB77EAE0091F}
DEFINE_GUID(IID_CServerObject_HostInterceptor,
0x3dcdd390, 0x8853, 0x40f2, 0x99, 0xe2, 0xeb, 0x77, 0xea, 0xe0, 0x9, 0x1f);

// {AA5E5035-DF5A-4baf-8B47-DA979398164D}
DEFINE_GUID(IID_CInterceptor_IWbemProvider, 
0xaa5e5035, 0xdf5a, 0x4baf, 0x8b, 0x47, 0xda, 0x97, 0x93, 0x98, 0x16, 0x4d);

// {90A56151-A5C9-44f7-8462-F8F4A8B74B6E}
DEFINE_GUID(IID_CDecoupledAggregator_IWbemProvider, 
0x90a56151, 0xa5c9, 0x44f7, 0x84, 0x62, 0xf8, 0xf4, 0xa8, 0xb7, 0x4b, 0x6e);

// {E3ECA416-FFD4-41bd-9259-B90A2365A891}
DEFINE_GUID(IID_CAggregator_IWbemProvider, 
0xe3eca416, 0xffd4, 0x41bd, 0x92, 0x59, 0xb9, 0xa, 0x23, 0x65, 0xa8, 0x91);

// {7F598975-37E0-4a67-A992-116680F0CEDA}
DEFINE_GUID(CLSID_ProvSubSys_Provider, 
0x7f598975, 0x37e0, 0x4a67, 0xa9, 0x92, 0x11, 0x66, 0x80, 0xf0, 0xce, 0xda);

// {BBAFF296-93CC-459c-9EE6-D3E35276A21C}
DEFINE_GUID(IID_CWbemCombiningObjectSink, 
0xbbaff296, 0x93cc, 0x459c, 0x9e, 0xe6, 0xd3, 0xe3, 0x52, 0x76, 0xa2, 0x1c);

// {8D955AC7-AF43-407a-A838-C26080B6671B}
DEFINE_GUID(IID_CacheElement, 
0x8d955ac7, 0xaf43, 0x407a, 0xa8, 0x38, 0xc2, 0x60, 0x80, 0xb6, 0x67, 0x1b);

// {B052FF1D-4619-4c9b-93C2-FC8F7137F969}
DEFINE_GUID(IID_CServerObject_InterceptorProviderRefresherManager, 
0xb052ff1d, 0x4619, 0x4c9b, 0x93, 0xc2, 0xfc, 0x8f, 0x71, 0x37, 0xf9, 0x69);

// {29F06F0C-FB7F-44A5-83CD-D41705D5C525}
DEFINE_GUID(CLSID_NCProvider,
0x29F06F0C,0xFB7F,0x44A5,0x83,0xCD,0xD4,0x17,0x05,0xD5,0xC5,0x25);

// {48D17DED-BC50-41b6-9821-2191EE6AA18E}
DEFINE_GUID(IID_IObjectSink_CancelOperation, 
0x48d17ded, 0xbc50, 0x41b6, 0x98, 0x21, 0x21, 0x91, 0xee, 0x6a, 0xa1, 0x8e);

// {51C629AD-06A8-4efb-8656-F8003FB04777}
DEFINE_GUID(IID_IProvider_Unload, 
0x51c629ad, 0x6a8, 0x4efb, 0x86, 0x56, 0xf8, 0x0, 0x3f, 0xb0, 0x47, 0x77);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\main.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Main.h

Abstract:


History:

--*/

#ifndef _Main_H
#define _Main_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class FactoryLifeTimeThread : public WmiThread < ULONG > 
{
private:

	WmiAllocator &m_Allocator ;

protected:

public:	/* Internal */

    FactoryLifeTimeThread ( 

		WmiAllocator & a_Allocator ,
		const ULONG &a_Timeout 
	) ;

    ~FactoryLifeTimeThread () ;

	WmiStatusCode Initialize_Callback () ;

	WmiStatusCode UnInitialize_Callback () ;

	WmiStatusCode TimedOut () ;

	BOOL QuotaCheck () ;
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Task_ObjectDestruction : public WmiTask < ULONG > 
{
private:
protected:
public:	// Internal 

	Task_ObjectDestruction ( WmiAllocator &a_Allocator ) : WmiTask < ULONG > ( a_Allocator ) 
	{
	}

	WmiStatusCode Process ( WmiThread <ULONG> &a_Thread ) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllRegisterServer () ;
STDAPI DllUnregisterServer () ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void SetObjectDestruction () ;

#endif // _Main_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provcache.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Cache.H

Abstract:


History:

--*/

#ifndef _Server_Cache_H
#define _Server_Cache_H

#include <PssException.h>
#include <Allocator.h>
#include <Algorithms.h>
#include <PQueue.h>
#include <TPQueue.h>
#include <BasicTree.h>
#include <Cache.h>
#include <CGlobals.h>
#include <lockst.h>
#include "ProvRegInfo.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class AutoFreeString 
{
private:

	BSTR m_String ;

protected:
public:

	AutoFreeString ( BSTR a_String = NULL ) 
	{
		m_String = a_String ;
	}

	~AutoFreeString ()
	{
		SysFreeString ( m_String ) ;
	}

	const BSTR Get () const
	{
		return m_String ;
	}

	BSTR Take ()
	{
		BSTR t_Str = m_String ;
		m_String = NULL ;
		return t_Str ;
	}

	AutoFreeString &operator= ( BSTR a_String )
	{
		SysFreeString ( m_String ) ;
		m_String = a_String ;

		return *this ;
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class HostCacheKey 
{
public:

	enum HostDesignation
	{
		e_HostDesignation_Shared
	};

	enum IdentityDesignation
	{
		e_IdentityDesignation_LocalSystem ,
		e_IdentityDesignation_LocalService ,
		e_IdentityDesignation_NetworkService ,
		e_IdentityDesignation_User
	} ;

	HostDesignation m_HostDesignation ;
	BSTR m_Group ;
	IdentityDesignation m_IdentityDesignation ;
	BSTR m_Identity ;

public:

	HostCacheKey () :

		m_Identity ( NULL ) ,
		m_Group ( NULL ) ,
		m_HostDesignation ( e_HostDesignation_Shared ) ,
		m_IdentityDesignation ( e_IdentityDesignation_LocalSystem ) 
	{
	}

	HostCacheKey ( 

		const HostCacheKey &a_Key 

	) :	m_Identity ( NULL ) ,
		m_Group ( NULL ) ,
		m_HostDesignation ( a_Key.m_HostDesignation ) ,
		m_IdentityDesignation ( a_Key.m_IdentityDesignation )
	{
		AutoFreeString t_Group ;
		AutoFreeString t_Identity ;

		if ( a_Key.m_Group )
		{
			t_Group = SysAllocString ( a_Key.m_Group ) ;
			if ( t_Group.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_Key.m_Identity )
		{
			t_Identity = SysAllocString ( a_Key.m_Identity ) ;
			if ( t_Identity.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		m_Identity = t_Identity.Take () ;
		m_Group = t_Group.Take () ;
	}

	HostCacheKey ( 

		HostDesignation a_HostDesignation ,
		const wchar_t *a_Group ,
		IdentityDesignation a_IdentityDesignation ,
		const wchar_t *a_Identity

	) :	m_Identity ( NULL ) ,
		m_Group ( NULL ) ,
		m_HostDesignation ( a_HostDesignation ) ,
		m_IdentityDesignation ( a_IdentityDesignation )
	{
		AutoFreeString t_Group ;
		AutoFreeString t_Identity ;

		if ( a_Group )
		{
			t_Group = SysAllocString ( a_Group ) ;
			if ( t_Group.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_Identity )
		{
			t_Identity = SysAllocString ( a_Identity ) ;
			if ( t_Identity.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		m_Identity = t_Identity.Take () ;
		m_Group = t_Group.Take () ;
	}

	~HostCacheKey ()
	{
		if ( m_Group )
		{
			SysFreeString ( m_Group ) ;
		}

		if ( m_Identity )
		{
			SysFreeString ( m_Identity ) ;
		}
	}

	HostCacheKey &operator= ( const HostCacheKey &a_Key ) 
	{
		m_HostDesignation = a_Key.m_HostDesignation ;
		m_IdentityDesignation = a_Key.m_IdentityDesignation ;

		if ( m_Group )
		{
			SysFreeString ( m_Group ) ;
		}

		if ( a_Key.m_Group )
		{
			m_Group = SysAllocString ( a_Key.m_Group ) ;
			if ( m_Group == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			m_Group = NULL ;
		}

		if ( m_Identity )
		{
			SysFreeString ( m_Identity ) ;
		}

		if ( a_Key.m_Identity )
		{
			m_Identity = SysAllocString ( a_Key.m_Identity ) ;
			if ( m_Identity == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			m_Identity = NULL ;
		}

		return *this ;
	}

	LONG Compare ( const HostCacheKey &a_Key ) const
	{
		if ( m_HostDesignation == a_Key.m_HostDesignation )
		{
			if ( m_HostDesignation == e_HostDesignation_Shared )
			{
				LONG t_Compare = _wcsicmp ( m_Group , a_Key.m_Group ) ;
				if ( t_Compare == 0 )
				{
				}
				else
				{
					return t_Compare ;
				}
			}

			if ( m_IdentityDesignation == a_Key.m_IdentityDesignation )
			{
				if ( m_IdentityDesignation == e_IdentityDesignation_User )
				{
					return _wcsicmp ( m_Identity , a_Key.m_Identity ) ;
				}	
				else
				{
					return 0 ;
				}
			}
			else
			{
				return m_IdentityDesignation == a_Key.m_IdentityDesignation ? 0 : ( m_IdentityDesignation < a_Key.m_IdentityDesignation ) ? -1 : 1 ;
			}
		}
		else
		{
			return m_HostDesignation == a_Key.m_HostDesignation ? 0 : ( m_HostDesignation < a_Key.m_HostDesignation ) ? -1 : 1 ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern LONG CompareElement ( const HostCacheKey &a_Arg1 , const HostCacheKey &a_Arg2 ) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class BindingFactoryCacheKey 
{
public:

	BSTR m_Namespace ;

public:

	BindingFactoryCacheKey () :

		m_Namespace ( NULL )
	{
	}

	BindingFactoryCacheKey ( 

		const BindingFactoryCacheKey &a_Key 

	) :	m_Namespace ( NULL )
	{
		AutoFreeString t_Namespace ;

		if ( a_Key.m_Namespace )
		{
			t_Namespace = SysAllocString ( a_Key.m_Namespace ) ;
			if ( t_Namespace.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		m_Namespace = t_Namespace.Take () ;
	}

	BindingFactoryCacheKey ( 

		const wchar_t *a_Namespace 

	) :	m_Namespace ( NULL )
	{
		AutoFreeString t_Namespace ;

		if ( a_Namespace )
		{
			t_Namespace = SysAllocString ( a_Namespace ) ;
			if ( t_Namespace.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		m_Namespace = t_Namespace.Take () ;
	}

	~BindingFactoryCacheKey ()
	{
		if ( m_Namespace )
		{
			SysFreeString ( m_Namespace ) ;
		}
	}

	BindingFactoryCacheKey &operator= ( const BindingFactoryCacheKey &a_Key ) 
	{
		if ( m_Namespace )
		{
			SysFreeString ( m_Namespace ) ;
		}

		if ( a_Key.m_Namespace )
		{
			m_Namespace = SysAllocString ( a_Key.m_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			m_Namespace = NULL ;
		}
				
		return *this ;
	}

	LONG CompareNamespace ( const BSTR a_Namespace ) const
	{
		if ( m_Namespace && a_Namespace )
		{
			return _wcsicmp ( m_Namespace , a_Namespace ) ;
		}	
		else
		{
			return m_Namespace == a_Namespace ? 0 : ( m_Namespace < a_Namespace ) ? -1 : 1 ;
		}
	}

	LONG Compare ( const BindingFactoryCacheKey &a_Key ) const
	{
		return CompareNamespace ( a_Key.m_Namespace ) ;
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern LONG CompareElement ( const BindingFactoryCacheKey &a_Arg1 , const BindingFactoryCacheKey &a_Arg2 ) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern LONG CompareElement ( const GUID &a_Arg1 , const GUID &a_Arg2 ) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class ProviderCacheKey 
{
public:

	BSTR m_Provider ;
	ULONG m_Hosting ;
	BSTR m_Group ;
	BSTR m_User ;
	BSTR m_Locale ;
	bool m_Raw ;
	GUID *m_TransactionIdentifier ;	

public:

	ProviderCacheKey () :

		m_User ( NULL ) ,
		m_Locale ( NULL ) ,
		m_Raw ( false ) ,
		m_Provider ( NULL ) ,
		m_Hosting ( 0 ) ,
		m_Group ( NULL ) ,
		m_TransactionIdentifier ( NULL )
	{
	}

	ProviderCacheKey ( 

		const ProviderCacheKey &a_Key

	) : m_User ( NULL ) ,
		m_Locale ( NULL ) ,
		m_TransactionIdentifier ( NULL ) ,
		m_Raw ( a_Key.m_Raw ) ,
		m_Hosting ( a_Key.m_Hosting ) ,
		m_Group ( NULL ) ,
		m_Provider ( NULL )
	{
		AutoFreeString t_User ;
		AutoFreeString t_Locale ;
		AutoFreeString t_Provider ;
		AutoFreeString t_Group ;

		if ( a_Key.m_User )
		{
			t_User = SysAllocString ( a_Key.m_User ) ;
			if ( t_User.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_Key.m_Locale )
		{
			t_Locale = SysAllocString ( a_Key.m_Locale ) ;
			if ( t_Locale.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_Key.m_Provider ) 
		{
			t_Provider = SysAllocString ( a_Key.m_Provider ) ;
			if ( t_Provider.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_Key.m_Group ) 
		{
			t_Group = SysAllocString ( a_Key.m_Group ) ;
			if ( t_Group.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_Key.m_TransactionIdentifier )
		{
			m_TransactionIdentifier = new GUID ;
			if ( m_TransactionIdentifier == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}

			*m_TransactionIdentifier = *a_Key.m_TransactionIdentifier ;
		}

		m_User = t_User.Take () ;
		m_Locale = t_Locale.Take () ;
		m_Provider = t_Provider.Take () ;
		m_Group = t_Group.Take () ;
	}	
	
	ProviderCacheKey ( 

		const wchar_t *a_Provider ,
		const ULONG a_Hosting ,
		const wchar_t *a_Group ,
		const bool a_Raw ,
		GUID *a_TransactionIdentifier ,
		const wchar_t *a_User ,
		const wchar_t *a_Locale
	) :
		m_Raw ( a_Raw ) ,
		m_Provider ( NULL ) ,
		m_Group ( NULL ) ,
		m_Hosting ( a_Hosting ) ,
		m_TransactionIdentifier ( NULL ) ,
		m_User ( NULL ) ,
		m_Locale ( NULL )
	{
		AutoFreeString t_User ;
		AutoFreeString t_Locale ;
		AutoFreeString t_Provider ;
		AutoFreeString t_Group ;

		if ( a_User )
		{
			t_User = SysAllocString ( a_User ) ;
			if ( t_User.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_Locale )
		{
			t_Locale = SysAllocString ( a_Locale ) ;
			if ( t_Locale.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_Provider ) 
		{
			t_Provider = SysAllocString ( a_Provider ) ;
			if ( t_Provider.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_Group ) 
		{
			t_Group = SysAllocString ( a_Group ) ;
			if ( t_Group.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_TransactionIdentifier )
		{
			m_TransactionIdentifier = new GUID ;
			if ( m_TransactionIdentifier == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}

			*m_TransactionIdentifier = *a_TransactionIdentifier ;
		}

		m_User = t_User.Take () ;
		m_Locale = t_Locale.Take () ;
		m_Provider = t_Provider.Take () ;
		m_Group = t_Group.Take () ;
	}

	~ProviderCacheKey ()
	{
		if ( m_User )
		{
			SysFreeString ( m_User ) ;
		}

		if ( m_Locale )
		{
			SysFreeString ( m_Locale ) ;
		}

		if ( m_Provider ) 
		{
			SysFreeString ( m_Provider ) ;
		}

		if ( m_Group ) 
		{
			SysFreeString ( m_Group ) ;
		}

		if ( m_TransactionIdentifier )
		{
			delete m_TransactionIdentifier ;
		}
	}

	ProviderCacheKey &operator= ( const ProviderCacheKey &a_Key ) 
	{
		m_Raw = a_Key.m_Raw ;
		m_Hosting = a_Key.m_Hosting ;

		if ( m_User )
		{
			SysFreeString ( m_User ) ;
		}

		if ( a_Key.m_User )
		{
			m_User = SysAllocString ( a_Key.m_User ) ;
			if ( m_User == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			m_User = NULL ;
		}

		if ( m_Locale )
		{
			SysFreeString ( m_Locale ) ;
		}

		if ( a_Key.m_Locale )
		{
			m_Locale = SysAllocString ( a_Key.m_Locale ) ;
			if ( m_Locale == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			m_Locale = NULL ;
		}

		if ( m_Provider ) 
		{
			SysFreeString ( m_Provider ) ;
		}

		if ( a_Key.m_Provider ) 
		{
			m_Provider = SysAllocString ( a_Key.m_Provider ) ;
			if ( m_Provider == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			m_Provider = NULL ;
		}

		if ( m_Group ) 
		{
			SysFreeString ( m_Group ) ;
		}
		
		if ( a_Key.m_Group ) 
		{
			m_Group = SysAllocString ( a_Key.m_Group ) ;
			if ( m_Group == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{	
			m_Group = NULL ;
		}

		if ( m_TransactionIdentifier )
		{
			delete m_TransactionIdentifier ;
		}

		if ( a_Key.m_TransactionIdentifier )
		{
			m_TransactionIdentifier = new GUID ;
			if ( m_TransactionIdentifier == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}

			*m_TransactionIdentifier = *a_Key.m_TransactionIdentifier ;
		}
		else
		{
			m_TransactionIdentifier = NULL ;
		}

		return *this ;
	}

	LONG CompareUser ( const BSTR a_User ) const
	{
		if ( m_User && a_User )
		{
			return _wcsicmp ( m_User , a_User ) ;
		}	
		else
		{
			return m_User == a_User ? 0 : ( m_User < a_User ) ? -1 : 1 ;
		}
	}

	LONG CompareLocale ( const BSTR a_Locale ) const
	{
		if ( m_Locale && a_Locale )
		{
			return _wcsicmp ( m_Locale , a_Locale ) ;
		}	
		else
		{
			return m_Locale == a_Locale ? 0 : ( m_Locale < a_Locale ) ? -1 : 1 ;
		}
	}

	LONG CompareProvider ( const BSTR a_Provider ) const
	{
		if ( m_Provider && a_Provider )
		{
			return _wcsicmp ( m_Provider , a_Provider ) ;
		}	
		else
		{
			return m_Provider == a_Provider ? 0 : ( m_Provider < a_Provider ) ? -1 : 1 ;
		}
	}

	LONG CompareGroup ( const BSTR a_Group ) const
	{
		if ( m_Group && a_Group )
		{
			return _wcsicmp ( m_Group , a_Group ) ;
		}	
		else
		{
			return m_Group == a_Group ? 0 : ( m_Group < a_Group ) ? -1 : 1 ;
		}
	}

	LONG CompareHosting ( const DWORD a_Hosting ) const
	{
		return m_Hosting == a_Hosting ? 0 : ( m_Hosting < a_Hosting ) ? -1 : 1 ;
	}

	LONG CompareTransaction ( const GUID *a_TransactionIdentifier ) const 
	{
		if ( m_TransactionIdentifier && a_TransactionIdentifier )
		{
			return CompareElement ( *m_TransactionIdentifier , *a_TransactionIdentifier ) ;
		}	
		else
		{
			return m_TransactionIdentifier == a_TransactionIdentifier ? 0 : ( m_TransactionIdentifier < a_TransactionIdentifier ) ? -1 : 1 ;
		}
	}

	LONG Compare ( const ProviderCacheKey &a_Key ) const
	{
		LONG t_CompareProvider = CompareProvider ( a_Key.m_Provider ) ;
		if ( t_CompareProvider == 0 )
		{
			LONG t_CompareHosting = CompareHosting ( a_Key.m_Hosting ) ;
			if ( t_CompareHosting == 0 )
			{
				LONG t_CompareGroup = CompareGroup ( a_Key.m_Group ) ;
				if ( t_CompareGroup == 0 )
				{
					LONG t_CompareUser = CompareUser ( a_Key.m_User ) ;
					if ( t_CompareUser == 0 )
					{
						LONG t_CompareLocale = CompareLocale ( a_Key.m_Locale ) ;
						if ( t_CompareLocale == 0 )
						{
							if ( m_Raw == a_Key.m_Raw ) 
							{
									return CompareElement ( m_TransactionIdentifier , a_Key.m_TransactionIdentifier ) ;
							}
							else
							{
								return m_Raw - a_Key.m_Raw ;
							}
						}	
						else
						{
							return t_CompareLocale ;
						}
					}	
					else
					{
						return t_CompareUser ;
					}
				}
				else
				{
					return t_CompareGroup ;
				}
			}
			else
			{
				return t_CompareHosting ;
			}
		}
		else
		{
			return t_CompareProvider ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern LONG CompareElement ( const ProviderCacheKey &a_Arg1 , const ProviderCacheKey &a_Arg2 ) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef WmiAvlTree	<GUID,GUID>					CWbemGlobal_ComServerTagContainer ;
typedef WmiAvlTree	<GUID,GUID>	:: Iterator		CWbemGlobal_ComServerTagContainer_Iterator ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_HostInterceptor ;

typedef WmiCacheController <HostCacheKey>					CWbemGlobal_IWmiHostController ;
typedef CWbemGlobal_IWmiHostController :: Cache				CWbemGlobal_IWmiHostController_Cache ;
typedef CWbemGlobal_IWmiHostController :: Cache_Iterator	CWbemGlobal_IWmiHostController_Cache_Iterator ;
typedef CWbemGlobal_IWmiHostController :: WmiCacheElement	HostCacheElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_InterceptorProviderRefresherManager ;

typedef WmiCacheController <void *>										CWbemGlobal_IWbemRefresherMgrController ;
typedef CWbemGlobal_IWbemRefresherMgrController :: Cache				CWbemGlobal_IWbemRefresherMgrController_Cache ;
typedef CWbemGlobal_IWbemRefresherMgrController :: Cache_Iterator		CWbemGlobal_IWbemRefresherMgrController_Cache_Iterator ;
typedef CWbemGlobal_IWbemRefresherMgrController :: WmiCacheElement		RefresherManagerCacheElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_BindingFactory ;

typedef WmiCacheController <BindingFactoryCacheKey>				CWbemGlobal_IWmiFactoryController ;
typedef CWbemGlobal_IWmiFactoryController :: Cache				CWbemGlobal_IWmiFactoryController_Cache ;
typedef CWbemGlobal_IWmiFactoryController :: Cache_Iterator		CWbemGlobal_IWmiFactoryController_Cache_Iterator ;
typedef CWbemGlobal_IWmiFactoryController :: WmiCacheElement	BindingFactoryCacheElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemProvider ;

typedef WmiCacheController <ProviderCacheKey>					CWbemGlobal_IWmiProviderController ;
typedef CWbemGlobal_IWmiProviderController :: Cache				CWbemGlobal_IWmiProviderController_Cache ;
typedef CWbemGlobal_IWmiProviderController :: Cache_Iterator	CWbemGlobal_IWmiProviderController_Cache_Iterator ;
typedef CWbemGlobal_IWmiProviderController :: WmiCacheElement	ServiceCacheElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderSubSystem ;

typedef WmiContainerController <void *>										CWbemGlobal_IWmiProvSubSysController ;
typedef CWbemGlobal_IWmiProvSubSysController :: Container					CWbemGlobal_IWmiProvSubSysController_Container ;
typedef CWbemGlobal_IWmiProvSubSysController :: Container_Iterator			CWbemGlobal_IWmiProvSubSysController_Container_Iterator ;
typedef CWbemGlobal_IWmiProvSubSysController :: WmiContainerElement			ProvSubSysContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncProvider ;

typedef WmiContainerController <GUID>										CWbemGlobal_IWbemSyncProviderController ;
typedef CWbemGlobal_IWbemSyncProviderController :: Container				CWbemGlobal_IWbemSyncProvider_Container ;
typedef CWbemGlobal_IWbemSyncProviderController :: Container_Iterator		CWbemGlobal_IWbemSyncProvider_Container_Iterator ;
typedef CWbemGlobal_IWbemSyncProviderController :: WmiContainerElement		SyncProviderContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef WmiContainerController <DWORD>										CWbemGlobal_HostedProviderController ;
typedef CWbemGlobal_HostedProviderController :: Container					CWbemGlobal_HostedProviderController_Container ;
typedef CWbemGlobal_HostedProviderController :: Container_Iterator			CWbemGlobal_HostedProviderController_Container_Iterator ;
typedef CWbemGlobal_HostedProviderController :: WmiContainerElement			HostedProviderContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class HostController : public CWbemGlobal_IWmiHostController
{
private:
protected:
public:

	HostController ( WmiAllocator &a_Allocator ) ;

	WmiStatusCode StrobeBegin ( const ULONG &a_Period ) ;
} ;


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class RefresherManagerController : public CWbemGlobal_IWbemRefresherMgrController
{
private:
protected:
public:

	RefresherManagerController ( WmiAllocator &a_Allocator ) ;

	WmiStatusCode StrobeBegin ( const ULONG &a_Period ) ;
} ;


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemProvider ;

class ProviderController : public HostedProviderContainerElement
{
public:

typedef WmiBasicTree <CInterceptor_IWbemProvider *,CInterceptor_IWbemProvider *> Container ;
typedef Container :: Iterator Container_Iterator ;

private:

	CriticalSection m_CriticalSection ;

	Container m_Container ;

public:

	ProviderController (

		WmiAllocator &a_Allocator , 
		CWbemGlobal_HostedProviderController *a_Controller ,
		DWORD a_ProcessIdentifier
	) ;

	virtual ~ProviderController () ;

	virtual STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;

	virtual STDMETHODIMP_( ULONG ) AddRef () ;

	virtual STDMETHODIMP_( ULONG ) Release () ;

	virtual WmiStatusCode Initialize () ;

	virtual WmiStatusCode UnInitialize () ;

	virtual WmiStatusCode Lock () ;

	virtual WmiStatusCode UnLock () ;

	virtual WmiStatusCode Insert (

		CInterceptor_IWbemProvider *a_Element , 
		Container_Iterator &a_Iterator
	) ;

	virtual WmiStatusCode Find ( CInterceptor_IWbemProvider * const &a_Key , Container_Iterator &a_Iterator ) ;

	virtual WmiStatusCode Delete ( CInterceptor_IWbemProvider *const & a_Key ) ;

	virtual WmiStatusCode Shutdown () ;

	WmiStatusCode GetContainer ( Container *&a_Container )
	{
		a_Container = & m_Container ;
		return e_StatusCode_Success ;
	}

} ;

#endif _Server_Cache_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provaggr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _Server_Aggregator_IWbemProvider_H
#define _Server_Aggregator_IWbemProvider_H

#include "ProvDnf.h"
#include "ProvRegInfo.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CAggregator_IWbemProvider :	public IWbemServices , 
									public _IWmiProviderInitialize , 
									public IWbemShutdown ,
									public _IWmiProviderCache ,
									public _IWmiProviderAssociatorsHelper,
									public ServiceCacheElement ,
									public CWbemGlobal_IWmiObjectSinkController

{
private:

	LONG m_ReferenceCount ;         //Object reference count
	WmiAllocator &m_Allocator ;

	_IWmiProviderFactory *m_Factory ;

	IWbemServices *m_CoreRepositoryStub ;
	IWbemServices *m_CoreFullStub ;

	BSTR m_User ;
	BSTR m_Locale ;

	ULONG m_ClassProvidersCount ;
	CServerObject_ProviderRegistrationV1 **m_ClassProviders ;

	LONG m_Initialized ;
	HRESULT m_InitializeResult ;
	HANDLE m_InitializedEvent ;
	IWbemContext *m_InitializationContext ;

private:

	QueryPreprocessor :: QuadState IsA (

		IWbemClassObject *a_Left ,
		IWbemClassObject *a_Right ,
		LONG &a_LeftLength ,
		LONG &a_RightLength ,
		BOOL &a_LeftIsA
	) ;

	QueryPreprocessor :: QuadState EnumDeep_RecursiveEvaluate ( 

		IWbemClassObject *a_Class ,
		IWbemContext *a_Context , 
		WmiTreeNode *&a_Node
	) ;

	QueryPreprocessor :: QuadState EnumDeep_Evaluate ( 

		IWbemClassObject *a_Class ,
		IWbemContext *a_Context , 
		WmiTreeNode *&a_Node
	) ;

	QueryPreprocessor :: QuadState EnumShallow_RecursiveEvaluate ( 

		IWbemClassObject *a_Class ,
		IWbemContext *a_Context , 
		WmiTreeNode *&a_Node
	) ;

	QueryPreprocessor :: QuadState EnumShallow_Evaluate ( 

		IWbemClassObject *a_Class ,
		IWbemContext *a_Context , 
		WmiTreeNode *&a_Node
	) ;

	QueryPreprocessor :: QuadState Get_RecursiveEvaluate ( 

		wchar_t *a_Class ,
		IWbemContext *a_Context , 
		WmiTreeNode *&a_Node
	) ;

	QueryPreprocessor :: QuadState Get_Evaluate ( 

		wchar_t *a_Class ,
		IWbemContext *a_Context , 
		WmiTreeNode *&a_Node
	) ;

	HRESULT Enum_ClassProviders (

		IWbemServices *a_Repository ,
		IWbemContext *a_Context 
	) ;

	HRESULT PutClass_Helper_Advisory ( 

		IWbemClassObject *a_ClassObject, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT PutClass_Helper_Put_CreateOrUpdate ( 

		BSTR a_Class ,
		IWbemClassObject *a_Object, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT PutClass_Helper_Put ( 
			
		IWbemClassObject *a_Object, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT DeleteClass_Helper_Advisory ( 

		IWbemClassObject *a_ClassObject ,
		BSTR a_Class, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT DeleteClass_Helper_Enum ( 

		IWbemClassObject *a_ClassObject ,
		BSTR a_Class, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT DeleteClass_Helper_Get ( 

		IWbemClassObject *a_ClassObject ,
		BSTR a_Class, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink
	) ;

public:

	CAggregator_IWbemProvider ( 

		WmiAllocator &m_Allocator ,
		CWbemGlobal_IWmiProviderController *a_Controller , 
		_IWmiProviderFactory *a_Factory ,
		IWbemServices *a_CoreRepositoryStub ,
		IWbemServices *a_CoreFullStub ,
		const ProviderCacheKey &a_Key ,
		const ULONG &a_Period ,
		IWbemContext *a_InitializationContext
	) ;
	
    ~CAggregator_IWbemProvider () ;

	HRESULT SetInitialized ( HRESULT a_Result ) ;

	HRESULT IsIndependant ( IWbemContext *a_Context ) ;

	HRESULT Enum_ClassProviders ( IWbemContext *a_Context ) ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Initialize (

		long a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User,
        LPCWSTR a_Locale,
		LPCWSTR a_Namespace ,
		IWbemServices *a_Repository ,
		IWbemServices *a_Service ,
		IWbemProviderInitSink *a_Sink

	) ;

	HRESULT STDMETHODCALLTYPE WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout ) ;

	HRESULT STDMETHODCALLTYPE GetInitializeResult () 
	{
		return m_InitializeResult ;
	}

	HRESULT STDMETHODCALLTYPE GetHosting ( ULONG *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = e_Hosting_WmiCore ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE GetHostingGroup ( BSTR *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = NULL ;

			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE IsInternal ( BOOL *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = TRUE ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE IsPerUserInitialization ( BOOL *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = FALSE ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE IsPerLocaleInitialization ( BOOL *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = FALSE ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	/* _IWmiProviderCache */

	HRESULT STDMETHODCALLTYPE Expel (

		long a_Flags ,
		IWbemContext *a_Context
	) ;
	HRESULT STDMETHODCALLTYPE ForceReload () ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

	/* _IWmiProviderAssociatorsHelper */

	HRESULT STDMETHODCALLTYPE GetReferencesClasses (
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;

} ;


#endif // _Server_Aggregator_IWbemProvider_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provfact.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Server_ProviderFactory_H
#define _Server_ProviderFactory_H

#include "ProvRegInfo.h"
#include "ProvCache.h"
#include "ProvAggr.h"
#include "Guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ProxyIndex__IWmiProviderFactory		0
#define ProxyIndex_Factory_Size				1

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_StrobeInterface : public IUnknown
{
private:
protected:
public:

	virtual WmiStatusCode Strobe ( ULONG &a_NextStrobeDelta ) = 0 ;

	virtual WmiStatusCode StrobeBegin ( const ULONG &a_Period ) = 0 ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_BindingFactory :	public _IWmiProviderFactory , 
										public _IWmiProviderFactoryInitialize , 
										public IWbemShutdown , 
										public _IWmiProviderConfiguration ,
										public BindingFactoryCacheElement , 
										public CWbemGlobal_IWmiProviderController 
{
private:

	WmiAllocator &m_Allocator ;

	LONG m_Flags ;
	_IWmiProvSS *m_SubSystem ;
	IWbemContext *m_Context ;
	LPWSTR m_Namespace ;
	IWbemPath *m_NamespacePath ;
	IWbemServices *m_Repository ;

	class InternalInterface : public CServerObject_StrobeInterface
	{
	private:

		CServerObject_BindingFactory *m_This ;

	public:

		InternalInterface ( CServerObject_BindingFactory *a_This ) : m_This ( a_This ) 
		{
		}

		STDMETHODIMP QueryInterface ( 

			REFIID iid , 
			LPVOID FAR *iplpv 
		)
		{
			*iplpv = NULL ;

			if ( iid == IID_IUnknown )
			{
				*iplpv = ( LPVOID ) this ;
			}
			else if ( iid == IID_CWbemGlobal_IWmiProviderController )
			{
				*iplpv = ( LPVOID ) ( CServerObject_StrobeInterface * ) this ;		
			}	

			if ( *iplpv )
			{
				( ( LPUNKNOWN ) *iplpv )->AddRef () ;

				return ResultFromScode ( S_OK ) ;
			}
			else
			{
				return ResultFromScode ( E_NOINTERFACE ) ;
			}
		}

		STDMETHODIMP_( ULONG ) AddRef ()
		{
			return m_This->InternalAddRef () ; 
		}

		STDMETHODIMP_( ULONG ) Release ()
		{
			return m_This->InternalRelease () ;
		}

		WmiStatusCode Strobe ( ULONG &a_NextStrobeDelta )
		{
			return m_This->Strobe ( a_NextStrobeDelta ) ;
		}

		WmiStatusCode StrobeBegin ( const ULONG &a_Period )
		{
			return m_This->StrobeBegin ( a_Period ) ;
		}
	} ;

	InternalInterface m_Internal ;

protected:

public:	/* Internal */

    CServerObject_BindingFactory ( 

		WmiAllocator &a_Allocator ,
		WmiCacheController<BindingFactoryCacheKey> *a_Controller ,
		const BindingFactoryCacheKey &a_Key ,
		const ULONG &a_Period 
	) ;

    CServerObject_BindingFactory ( 

		WmiAllocator &a_Allocator
	) ;

    ~CServerObject_BindingFactory () ;

	IWbemContext *Direct_GetContext () { return m_Context ; }
	IWbemPath *Direct_GetNamespacePath () { return m_NamespacePath ; }
	LPCWSTR Direct_GetNamespace () { return m_Namespace ; }
	IWbemServices *Direct_GetRepository () { return m_Repository ; }
	_IWmiProvSS *Direct_GetSubSystem () { return m_SubSystem ; }

	HRESULT CacheProvider (

		_IWmiProviderSubsystemRegistrar *a_Registrar ,
		IWbemContext *a_Context ,
		CServerObject_DecoupledClientRegistration_Element &a_Element ,
		IUnknown *a_Unknown 
	) ;

	HRESULT Load (

		_IWmiProviderSubsystemRegistrar *a_Registrar ,
		IWbemContext *a_Context ,
		CServerObject_DecoupledClientRegistration_Element &a_Element
	) ;

	HRESULT Load (

		CDecoupledAggregator_IWbemProvider *a_Aggregator ,
		IWbemContext *a_Context ,
		BSTR a_Provider ,
		BSTR a_User ,
		BSTR a_Locale ,
		BSTR a_Scope
	) ;

	HRESULT GetHosting ( 

		CServerObject_ProviderRegistrationV1 &a_Registration ,
		IWbemContext *a_Context ,
		Enum_Hosting &a_Hosting ,
		LPCWSTR &a_HostingGroup
	) ;

	HRESULT Create ( 

		CServerObject_ProviderRegistrationV1 &a_Registration ,
		Enum_Hosting a_Hosting ,
		LPCWSTR a_HostingGroup ,
		LPCWSTR a_User ,
		_IWmiProviderHost **a_Host ,
		_IWmiProviderFactory **a_Factory 
	) ;

	HRESULT InitializeHostedService (

		CInterceptor_IWbemProvider *a_Interceptor ,
		IUnknown *a_Unknown 
	) ;

	HRESULT InternalGetProvider ( 

		IWbemServices *a_RepositoryService ,
		IWbemServices *a_FullService ,
		_IWmiProviderHost *a_Host ,
		_IWmiProviderFactory *a_Factory ,
		CInterceptor_IWbemProvider *a_Interceptor ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		ProviderCacheKey &a_Key ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Name ,
		void **a_Unknown ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

	HRESULT InternalGetProviderViaProxyRoute ( 

		IWbemServices *a_RepositoryService ,
		IWbemServices *a_FullService ,
		CInterceptor_IWbemProvider *a_Interceptor ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		Enum_Hosting a_Hosting ,
		LPCWSTR a_HostingGroup ,
		ProviderCacheKey &a_Key ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Name ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

	HRESULT InternalFindProvider ( 

		IWbemServices *a_RepositoryService ,
		IWbemServices *a_FullService ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		Enum_Hosting a_Hosting ,
		LPCWSTR a_HostingGroup ,
		ProviderCacheKey &a_Key ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Name ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

	HRESULT GetAggregatedClassProviderViaProxyRoute ( 

		ProviderCacheKey &a_Key ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope,
		IWbemClassObject *a_Class ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

	HRESULT WaitProvider ( 

		IWbemContext *a_Context ,
		REFIID a_RIID , 
		void **a_Interface ,
		ServiceCacheElement *a_Element ,
		_IWmiProviderInitialize *a_Initializer 
	) ;

	HRESULT SearchSpecificProvider ( 

		IWbemContext *a_Context ,
		ProviderCacheKey &a_Key ,
		REFIID a_RIID , 
		void **a_Interface ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale
	) ;

	HRESULT FindProvider ( 

		IWbemContext *a_Context ,
		ProviderCacheKey &a_Key ,
		BOOL a_SpecificProvider ,
		REFIID a_RIID , 
		void **a_Interface ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale
	) ;

	HRESULT GetAggregatedClassProvider ( 

		IWbemServices *a_RepositoryService ,
		IWbemServices *a_FullService ,
		ProviderCacheKey &a_Key ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope,
		IWbemClassObject *a_Class ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

	HRESULT InternalFindAggregatedDecoupledProvider ( 

		IWbemServices *a_RepositoryService ,
		IWbemServices *a_FullService ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		ProviderCacheKey &a_Key ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Name ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

public:	/* External */


	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	// CServerObject_BindingFactory members

    HRESULT STDMETHODCALLTYPE GetClassProvider (

        LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope,
		IWbemClassObject *a_Class ,
		REFIID a_RIID , 
		void **a_Interface 
	);

	HRESULT STDMETHODCALLTYPE GetDynamicPropertyResolver (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

	HRESULT STDMETHODCALLTYPE GetHostedProvider ( 
	
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope,
		LPCWSTR a_Name ,
		ULONG a_Host ,
		LPCWSTR a_HostGroup ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

	HRESULT STDMETHODCALLTYPE GetProvider ( 

		WmiInternalContext a_InternalContext ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope,
		LPCWSTR a_Name ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

    HRESULT STDMETHODCALLTYPE GetDecoupledProvider (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope,
		LPCWSTR a_Name ,
		REFIID a_RIID , 
		void **a_Interface 
    ) ;

	/* _IWmiProviderConfiguration methods */

	HRESULT STDMETHODCALLTYPE Get (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Set (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_OldObject ,
		IWbemClassObject *a_NewObject  
	) ;

	HRESULT STDMETHODCALLTYPE Deleted (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_Object  
	) ;

	HRESULT STDMETHODCALLTYPE Enumerate (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		ULONG a_MilliSeconds
	) ;

	HRESULT STDMETHODCALLTYPE Call (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,		
		LPCWSTR a_Method,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Query (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
		WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
		VARIANT *a_Value 
	) ;

	HRESULT STDMETHODCALLTYPE Initialize (

		_IWmiProvSS *a_SubSys ,
		_IWmiProviderFactory *a_Factory ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Namespace ,
		IWbemServices *a_Repository ,
		IWbemServices *a_Service
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

	WmiStatusCode Strobe ( ULONG &a_NextStrobeDelta ) ;

	WmiStatusCode StrobeBegin ( const ULONG &a_Period ) ;
};

#endif // _Server_ProviderFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provcntrs.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Server_ProviderCounters_H
#define _Server_ProviderCounters_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderSubsystem_Counters 
{
public:

    UINT64 m_ProviderHost_WmiCore_Loads ;
    UINT64 m_ProviderHost_WmiCore_UnLoads ;

	UINT64 m_ProviderHost_WmiCoreOrSelfHost_Loads ;
	UINT64 m_ProviderHost_WmiCoreOrSelfHost_UnLoads ;

	UINT64 m_ProviderHost_SelfHost_Loads ;
	UINT64 m_ProviderHost_SelfHost_UnLoads ;

	UINT64 m_ProviderHost_ClientHost_Loads ;
	UINT64 m_ProviderHost_ClientHost_UnLoads ;

	UINT64 m_ProviderHost_Decoupled_Loads ;
	UINT64 m_ProviderHost_Decoupled_UnLoads ;

	UINT64 m_ProviderHost_SharedLocalSystemHost_Loads ;
	UINT64 m_ProviderHost_SharedLocalSystemHost_UnLoads ;

	UINT64 m_ProviderHost_SharedNetworkHost_Loads ;
	UINT64 m_ProviderHost_SharedNetworkHost_UnLoads ;

	UINT64 m_ProviderHost_SharedUserHost_Loads ;
	UINT64 m_ProviderHost_SharedUserHost_UnLoads ;

	UINT64 m_ProviderOperation_GetObjectAsync ;
	UINT64 m_ProviderOperation_PutClassAsync ;
	UINT64 m_ProviderOperation_DeleteClassAsync ;
	UINT64 m_ProviderOperation_CreateClassEnumAsync ;
	UINT64 m_ProviderOperation_PutInstanceAsync ;
	UINT64 m_ProviderOperation_DeleteInstanceAsync ;
	UINT64 m_ProviderOperation_CreateInstanceEnumAsync ;
	UINT64 m_ProviderOperation_ExecQueryAsync ;
	UINT64 m_ProviderOperation_ExecNotificationQueryAsync ;
	UINT64 m_ProviderOperation_ExecMethodAsync ;

	UINT64 m_ProviderOperation_QueryInstances ;
	UINT64 m_ProviderOperation_CreateRefresher ;
	UINT64 m_ProviderOperation_CreateRefreshableObject ;
	UINT64 m_ProviderOperation_StopRefreshing ;
	UINT64 m_ProviderOperation_CreateRefreshableEnum ;
	UINT64 m_ProviderOperation_GetObjects ;

	UINT64 m_ProviderOperation_GetProperty ;
	UINT64 m_ProviderOperation_PutProperty ;

	UINT64 m_ProviderOperation_ProvideEvents ;
	UINT64 m_ProviderOperation_NewQuery ;
	UINT64 m_ProviderOperation_CancelQuery ;
	UINT64 m_ProviderOperation_AccessCheck ;
	UINT64 m_ProviderOperation_SetRegistrationObject ;
	UINT64 m_ProviderOperation_FindConsumer ;
	UINT64 m_ProviderOperation_ValidateSubscription ;

protected:

public:	/* Internal */

    CServerObject_ProviderSubsystem_Counters () ;
    ~CServerObject_ProviderSubsystem_Counters () ;

public:	/* External */

    void Increment_ProviderHost_WmiCore_Loads () { m_ProviderHost_WmiCore_Loads ++ ; }
    void Increment_ProviderHost_WmiCore_UnLoads () { m_ProviderHost_WmiCore_UnLoads ++ ; }

	void Increment_ProviderHost_WmiCoreOrSelfHost_Loads () { m_ProviderHost_WmiCoreOrSelfHost_Loads ++ ; }
	void Increment_ProviderHost_WmiCoreOrSelfHost_UnLoads () { m_ProviderHost_WmiCoreOrSelfHost_UnLoads ++ ; }

	void Increment_ProviderHost_SelfHost_Loads () { m_ProviderHost_SelfHost_Loads ++ ; }
	void Increment_ProviderHost_SelfHost_UnLoads () { m_ProviderHost_SelfHost_UnLoads ++ ; }

	void Increment_ProviderHost_ClientHost_Loads () { m_ProviderHost_ClientHost_Loads ++ ; }
	void Increment_ProviderHost_ClientHost_UnLoads () { m_ProviderHost_ClientHost_UnLoads ++ ; }

	void Increment_ProviderHost_Decoupled_Loads () { m_ProviderHost_Decoupled_Loads ++ ; }
	void Increment_ProviderHost_Decoupled_UnLoads () { m_ProviderHost_Decoupled_UnLoads ++ ; }

	void Increment_ProviderHost_SharedLocalSystemHost_Loads () { m_ProviderHost_SharedLocalSystemHost_Loads ++ ; }
	void Increment_ProviderHost_SharedLocalSystemHost_UnLoads () { m_ProviderHost_SharedLocalSystemHost_UnLoads ++ ; }

	void Increment_ProviderHost_SharedNetworkHost_Loads () { m_ProviderHost_SharedNetworkHost_Loads ++ ; }
	void Increment_ProviderHost_SharedNetworkHost_UnLoads () { m_ProviderHost_SharedNetworkHost_UnLoads ++ ; }

	void Increment_ProviderHost_SharedUserHost_Loads () { m_ProviderHost_SharedUserHost_Loads ++ ; }
	void Increment_ProviderHost_SharedUserHost_UnLoads () { m_ProviderHost_SharedUserHost_UnLoads ++ ; }

	void Increment_ProviderOperation_GetObjectAsync () { m_ProviderOperation_GetObjectAsync ++ ; }
 	void Increment_ProviderOperation_PutClassAsync () { m_ProviderOperation_PutClassAsync ++ ; }
	void Increment_ProviderOperation_DeleteClassAsync () { m_ProviderOperation_DeleteClassAsync ++ ; }
	void Increment_ProviderOperation_CreateClassEnumAsync () { m_ProviderOperation_CreateClassEnumAsync ++ ; }
	void Increment_ProviderOperation_PutInstanceAsync () { m_ProviderOperation_PutInstanceAsync ++ ; }
	void Increment_ProviderOperation_DeleteInstanceAsync () { m_ProviderOperation_DeleteInstanceAsync ++ ; }
	void Increment_ProviderOperation_CreateInstanceEnumAsync () { m_ProviderOperation_CreateInstanceEnumAsync ++ ; }
	void Increment_ProviderOperation_ExecQueryAsync () { m_ProviderOperation_ExecQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecNotificationQueryAsync () { m_ProviderOperation_ExecNotificationQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecMethodAsync () { m_ProviderOperation_ExecMethodAsync ++ ; }

	void Increment_ProviderOperation_QueryInstances () { m_ProviderOperation_QueryInstances ++ ; }
	void Increment_ProviderOperation_CreateRefresher () { m_ProviderOperation_CreateRefresher ++ ; }
	void Increment_ProviderOperation_CreateRefreshableObject () { m_ProviderOperation_CreateRefreshableObject ++ ; }
	void Increment_ProviderOperation_StopRefreshing () { m_ProviderOperation_StopRefreshing ++ ; }
	void Increment_ProviderOperation_CreateRefreshableEnum () { m_ProviderOperation_CreateRefreshableEnum ++ ; }
	void Increment_ProviderOperation_GetObjects () { m_ProviderOperation_GetObjects ++ ; }

	void Increment_ProviderOperation_GetProperty () { m_ProviderOperation_GetProperty ++ ; }
	void Increment_ProviderOperation_PutProperty () { m_ProviderOperation_PutProperty ++ ; }

	void Increment_ProviderOperation_ProvideEvents () { m_ProviderOperation_ProvideEvents ++ ; }
	void Increment_ProviderOperation_NewQuery () { m_ProviderOperation_NewQuery ++ ; }
	void Increment_ProviderOperation_CancelQuery () { m_ProviderOperation_CancelQuery ++ ; }
	void Increment_ProviderOperation_AccessCheck () { m_ProviderOperation_AccessCheck ++ ; }
	void Increment_ProviderOperation_SetRegistrationObject () { m_ProviderOperation_SetRegistrationObject ++ ; }
	void Increment_ProviderOperation_FindConsumer () { m_ProviderOperation_FindConsumer ++ ; }
	void Increment_ProviderOperation_ValidateSubscription () { m_ProviderOperation_ValidateSubscription ++ ; }

    UINT64 Get_ProviderHost_WmiCore_Loads () { return m_ProviderHost_WmiCore_Loads ; }
    UINT64 Get_ProviderHost_WmiCore_UnLoads () { return m_ProviderHost_WmiCore_UnLoads ; }

	UINT64 Get_ProviderHost_WmiCoreOrSelfHost_Loads () { return m_ProviderHost_WmiCoreOrSelfHost_Loads ; }
	UINT64 Get_ProviderHost_WmiCoreOrSelfHost_UnLoads () { return m_ProviderHost_WmiCoreOrSelfHost_UnLoads ; }

	UINT64 Get_ProviderHost_SelfHost_Loads () { return m_ProviderHost_SelfHost_Loads ; }
	UINT64 Get_ProviderHost_SelfHost_UnLoads () { return m_ProviderHost_SelfHost_UnLoads ; }

	UINT64 Get_ProviderHost_ClientHost_Loads () { return m_ProviderHost_ClientHost_Loads ; }
	UINT64 Get_ProviderHost_ClientHost_UnLoads () { return m_ProviderHost_ClientHost_UnLoads ; }

	UINT64 Get_ProviderHost_Decoupled_Loads () { return m_ProviderHost_Decoupled_Loads ; }
	UINT64 Get_ProviderHost_Decoupled_UnLoads () { return m_ProviderHost_Decoupled_UnLoads ; }

	UINT64 Get_ProviderHost_SharedLocalSystemHost_Loads () { return m_ProviderHost_SharedLocalSystemHost_Loads ; }
	UINT64 Get_ProviderHost_SharedLocalSystemHost_UnLoads () { return m_ProviderHost_SharedLocalSystemHost_UnLoads ; }

	UINT64 Get_ProviderHost_SharedNetworkHost_Loads () { return m_ProviderHost_SharedNetworkHost_Loads ; }
	UINT64 Get_ProviderHost_SharedNetworkHost_UnLoads () { return m_ProviderHost_SharedNetworkHost_UnLoads ; }

	UINT64 Get_ProviderHost_SharedUserHost_Loads () { return m_ProviderHost_SharedUserHost_Loads ; }
	UINT64 Get_ProviderHost_SharedUserHost_UnLoads () { return m_ProviderHost_SharedUserHost_UnLoads ; }

	UINT64 Get_ProviderOperation_GetObjectAsync () { return m_ProviderOperation_GetObjectAsync ; }
	UINT64 Get_ProviderOperation_PutClassAsync () { return m_ProviderOperation_PutClassAsync ; }
	UINT64 Get_ProviderOperation_DeleteClassAsync () { return m_ProviderOperation_DeleteClassAsync ; }
	UINT64 Get_ProviderOperation_CreateClassEnumAsync () { return m_ProviderOperation_CreateClassEnumAsync ; }
	UINT64 Get_ProviderOperation_PutInstanceAsync () { return m_ProviderOperation_PutInstanceAsync ; }
	UINT64 Get_ProviderOperation_DeleteInstanceAsync () { return m_ProviderOperation_DeleteInstanceAsync ; }
	UINT64 Get_ProviderOperation_CreateInstanceEnumAsync () { return m_ProviderOperation_CreateInstanceEnumAsync ; }
	UINT64 Get_ProviderOperation_ExecQueryAsync () { return m_ProviderOperation_ExecQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecNotificationQueryAsync () { return m_ProviderOperation_ExecNotificationQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecMethodAsync () { return m_ProviderOperation_ExecMethodAsync ; }

	UINT64 Get_ProviderOperation_QueryInstances () { return m_ProviderOperation_QueryInstances ; }
	UINT64 Get_ProviderOperation_CreateRefresher () { return m_ProviderOperation_CreateRefresher ; }
	UINT64 Get_ProviderOperation_CreateRefreshableObject () { return m_ProviderOperation_CreateRefreshableObject ; }
	UINT64 Get_ProviderOperation_StopRefreshing () { return m_ProviderOperation_StopRefreshing ; }
	UINT64 Get_ProviderOperation_CreateRefreshableEnum () { return m_ProviderOperation_CreateRefreshableEnum ; }
	UINT64 Get_ProviderOperation_GetObjects () { return m_ProviderOperation_GetObjects ; }

	UINT64 Get_ProviderOperation_GetProperty () { return m_ProviderOperation_GetProperty ; }
	UINT64 Get_ProviderOperation_PutProperty () { return m_ProviderOperation_PutProperty ; }

	UINT64 Get_ProviderOperation_ProvideEvents () { return m_ProviderOperation_ProvideEvents ; }
	UINT64 Get_ProviderOperation_NewQuery () { return m_ProviderOperation_NewQuery ; }
	UINT64 Get_ProviderOperation_CancelQuery () { return m_ProviderOperation_CancelQuery ; }
	UINT64 Get_ProviderOperation_AccessCheck () { return m_ProviderOperation_AccessCheck ; }
	UINT64 Get_ProviderOperation_SetRegistrationObject () { return m_ProviderOperation_SetRegistrationObject ; }
	UINT64 Get_ProviderOperation_FindConsumer () { return m_ProviderOperation_FindConsumer ; }
	UINT64 Get_ProviderOperation_ValidateSubscription () { return m_ProviderOperation_ValidateSubscription ; }

};

#endif // _Server_ProviderCounters_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provload.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Server_SimpleFactory_H
#define _Server_SimpleFactory_H

#include "ProvRegInfo.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_RawFactory :	public _IWmiProviderFactory , 
									public _IWmiProviderFactoryInitialize , 
									public IWbemShutdown
{
private:

	WmiAllocator &m_Allocator ;

    long m_ReferenceCount ;

	LONG m_Flags ;
	IWbemContext *m_Context ;
	LPWSTR m_Namespace ;
	IWbemPath *m_NamespacePath ;
	IWbemServices *m_Repository ;
	IWbemServices *m_Service ;

public:	/* Internal */

    CServerObject_RawFactory (	WmiAllocator & a_Allocator ) ;
    ~CServerObject_RawFactory () ;

	IWbemContext *Direct_GetContext () { return m_Context ; }
	LPCWSTR Direct_GetNamespace () { return m_Namespace ; }
	IWbemPath *Direct_GetNamespacePath () { return m_NamespacePath ; }
	IWbemServices *Direct_GetRepository () { return m_Repository ; }
	IWbemServices *Direct_GetService () { return m_Service ; }

	HRESULT CreateSyncProvider ( 

		IWbemServices *a_Stub ,
		IUnknown *a_ServerSideProvider ,
		wchar_t *a_NamespacePath ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		REFIID a_RIID , 
		void **a_Interface ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	HRESULT InitializeServerProvider ( 

		IWbemServices *a_Stub ,
		IUnknown *a_ProviderInterface ,
		wchar_t *a_NamespacePath ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		REFIID a_RIID , 
		void **a_Interface ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	HRESULT InitializeNonApartmentProvider ( 

		IWbemServices *a_Stub ,
		IUnknown *a_ServerSideProviderInterface ,
		wchar_t *a_NamespacePath ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		REFIID a_RIID , 
		void **a_Interface ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	HRESULT GetApartmentInstanceProvider ( 

		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope ,
		REFIID a_RIID , 
		void **a_Interface ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	HRESULT GetNonApartmentProvider ( 

		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope ,
		REFIID a_RIID , 
		void **a_Interface ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	HRESULT CheckInterfaceConformance (

		CServerObject_ProviderRegistrationV1 &a_Registration ,
		IUnknown *a_Unknown
	) ;

public: /* Internal */

	static HRESULT CreateInstance ( 

		CServerObject_ProviderRegistrationV1 &a_Registration ,
		const CLSID &a_ReferenceClsid ,
		LPUNKNOWN a_OuterUnknown ,
		const DWORD &a_ClassContext ,
		const UUID &a_ReferenceInterfaceId ,
		void **a_ObjectInterface
	) ;

	static HRESULT CreateServerSide ( 

		CServerObject_ProviderRegistrationV1 &a_Registration ,
		GUID *a_TransactionIdentifier ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		wchar_t *a_NamespacePath ,
		IUnknown **a_ProviderInterface
	) ;

public:	/* External */


	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	// CServerObject_RawFactory members

	HRESULT STDMETHODCALLTYPE GetHostedProvider ( 
	
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope ,
		LPCWSTR a_Name ,
		ULONG a_Host ,
		LPCWSTR a_HostGroup ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

    HRESULT STDMETHODCALLTYPE GetClassProvider (

        LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope ,
		IWbemClassObject *a_SuperClass ,
		REFIID a_RIID , 
		void **a_Interface 
	);

	HRESULT STDMETHODCALLTYPE GetDynamicPropertyResolver (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

	HRESULT STDMETHODCALLTYPE GetProvider ( 

		WmiInternalContext a_InternalContext ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope ,
		LPCWSTR a_Name ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

    HRESULT STDMETHODCALLTYPE GetDecoupledProvider (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope,
		LPCWSTR a_Name ,
		REFIID a_RIID , 
		void **a_Interface 
    ) ;

	HRESULT STDMETHODCALLTYPE Initialize (

		_IWmiProvSS *a_SubSys ,
		_IWmiProviderFactory *a_Factory ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Namespace ,
		IWbemServices *a_Repository ,
		IWbemServices *a_Service 
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
};

#endif // _Server_SimpleFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provinsk.h ===
#ifndef _Server_Interceptor_IWbemProviderInitSink_H
#define _Server_Interceptor_IWbemProviderInitSink_H

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvObSk.H

Abstract:


History:

--*/


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderInitSink : public IWbemProviderInitSink 
{
private:

	LONG m_ReferenceCount ;

	BOOL m_StatusCalled ;

	HANDLE m_Event ;

	HRESULT m_Result ;

	SECURITY_DESCRIPTOR *m_SecurityDescriptor ;

protected:

public:

	CServerObject_ProviderInitSink ( SECURITY_DESCRIPTOR *a_SecurityDescriptor = NULL ) ;
	virtual ~CServerObject_ProviderInitSink () ;

	HRESULT SinkInitialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor = NULL ) ;

	STDMETHODIMP QueryInterface (

		REFIID iid , 
		LPVOID FAR *iplpv 
	) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_(ULONG) Release () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

        LONG a_Status,
        LONG a_Flags 
	) ;

	void Wait ( DWORD a_Timeout = 300000 ) 
	{
		if ( WaitForSingleObject ( m_Event , a_Timeout ) == WAIT_TIMEOUT )
		{
			m_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	void Reset () 
	{
		ResetEvent ( m_Event ) ;
		m_Result = S_OK ;
	}

	HRESULT GetResult () { return m_Result ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemProviderInitSink : public IWbemProviderInitSink
{
private:

	LONG m_ReferenceCount ;

	LONG m_GateClosed ;
	LONG m_InProgress ;

	BOOL m_StatusCalled ;

	IWbemProviderInitSink *m_InterceptedSink ;

protected:
public:

	CInterceptor_IWbemProviderInitSink (

		IWbemProviderInitSink *a_InterceptedSink
	) ;

	~CInterceptor_IWbemProviderInitSink () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

        LONG a_Status,
        LONG a_Flags 
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown () ;
} ;

#endif _Server_Interceptor_IWbemProviderInitSink_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provdcaggr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _Server_DecoupledAggregator_IWbemProvider_H
#define _Server_DecoupledAggregator_IWbemProvider_H

#include "ProvRegDeCoupled.h"
#include "ProvWsv.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupled_ProviderSubsystemRegistrar :	public _IWmiProviderSubsystemRegistrar
{
private:

	LONG m_ReferenceCount ;         //Object reference count
	WmiAllocator &m_Allocator ;
	CServerObject_ProviderSubSystem *m_SubSystem ;

	HRESULT SaveToRegistry (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		DWORD a_ProcessIdentifier ,
		GUID &a_Identity ,
		IUnknown *a_Unknown
	) ;

	HRESULT ValidateClientSecurity (

		IWbemContext *a_Context ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		IWbemServices *a_Service 
	) ;

	HRESULT CacheProvider (

		CServerObject_ProviderSubSystem *a_SubSystem ,
		IWbemContext *a_Context ,
		CServerObject_DecoupledClientRegistration_Element &a_Element ,
		IUnknown *a_Unknown 
	) ;

	HRESULT Load (

		CServerObject_ProviderSubSystem *a_SubSystem ,
		IWbemContext *a_Context ,
		CServerObject_DecoupledClientRegistration_Element &a_Element
	) ;

	HRESULT MarshalRegistration (

		IUnknown *a_Unknown ,
		BYTE *&a_MarshaledProxy ,
		DWORD &a_MarshaledProxyLength
	) ;

	HRESULT SaveToRegistry (

		IUnknown *a_Unknown ,
		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength
	) ;

protected:
public:

	CDecoupled_ProviderSubsystemRegistrar ( WmiAllocator &a_Allocator , CServerObject_ProviderSubSystem *a_SubSystem ) ;
	~CDecoupled_ProviderSubsystemRegistrar () ;

	HRESULT Load (

		CServerObject_ProviderSubSystem *a_SubSystem , 
		IWbemContext *a_Context
	) ;

	HRESULT Save () ;
	HRESULT Delete () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE Register (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Registration ,
		LPCWSTR a_Scope ,
		DWORD a_ProcessIdentifier ,
		IUnknown *a_Unknown ,
		GUID a_Identity 
	) ;

	HRESULT STDMETHODCALLTYPE UnRegister (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		GUID a_Identity
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupledAggregator_IWbemProvider :	public IWbemServices , 
											public IWbemEventProvider ,
											public IWbemEventProviderQuerySink ,
											public IWbemEventProviderSecurity ,
											public IWbemProviderIdentity ,
											public IWbemEventConsumerProviderEx ,
											public _IWmiProviderSubsystemRegistrar ,
											public _IWmiProviderInitialize ,
											public IWbemShutdown ,
											public _IWmiProviderCache ,
											public ServiceCacheElement ,
											public CWbemGlobal_IWmiObjectSinkController

{
private:

	LONG m_ReferenceCount ;         //Object reference count
	WmiAllocator &m_Allocator ;

	CWbemGlobal_IWbemSyncProviderController *m_Controller ;

	_IWmiProviderFactory *m_Factory ;

	IWbemObjectSink *m_Sink ;
	IWbemServices *m_CoreRepositoryStub ;
	IWbemServices *m_CoreFullStub ;
	IWbemPath *m_NamespacePath ;

	BSTR m_User ;
	BSTR m_Locale ;
	BSTR m_Namespace ;

	IWbemClassObject *m_ExtendedStatusObject ;
	CServerObject_ProviderRegistrationV1 *m_Registration ;

	LONG m_Initialized ;
	HRESULT m_InitializeResult ;
	HANDLE m_InitializedEvent ;
	IWbemContext *m_InitializationContext ;

private:

	HRESULT InitializeProvider ( 

		IUnknown *a_Unknown ,
		IWbemServices *a_Stub ,
		wchar_t *a_NamespacePath ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	HRESULT CreateSyncProvider ( 

		IUnknown *a_ServerSideProvider ,
		IWbemServices *a_Stub ,
		wchar_t *a_NamespacePath ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		GUID a_Identity ,
		CInterceptor_IWbemDecoupledProvider *&a_Interceptor 
	) ;

	HRESULT SetStatus ( 

		LPWSTR a_Operation ,
		LPWSTR a_Parameters ,
		LPWSTR a_Description ,
		HRESULT a_Result ,
		IWbemObjectSink *a_Sink
	) ;

public:

	CDecoupledAggregator_IWbemProvider ( 

		WmiAllocator &m_Allocator ,
		CWbemGlobal_IWmiProviderController *a_Controller , 
		_IWmiProviderFactory *a_Factory ,
		IWbemServices *a_CoreRepositoryStub ,
		IWbemServices *a_CoreFullStub ,
		const ProviderCacheKey &a_Key ,
		const ULONG &a_Period ,
		IWbemContext *a_InitializationContext ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;
	
    ~CDecoupledAggregator_IWbemProvider () ;

	HRESULT SetInitialized ( HRESULT a_InitializeResult ) ;

	HRESULT IsIndependant ( IWbemContext *a_Context ) ;

	HRESULT AbnormalShutdown ( IUnknown *t_Element ) ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderIdentity */

	HRESULT STDMETHODCALLTYPE SetRegistrationObject (

		long a_Flags ,
		IWbemClassObject *a_ProviderRegistration
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	HRESULT STDMETHODCALLTYPE Register (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Scope ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Registration ,
		DWORD a_ProcessIdentifier ,
		IUnknown *a_Unknown ,
		GUID a_Identity
	) ;

	HRESULT STDMETHODCALLTYPE UnRegister (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		GUID a_Identity
	) ;

	HRESULT STDMETHODCALLTYPE Initialize (

		long a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User,
        LPCWSTR a_Locale,
		LPCWSTR a_Namespace ,
		IWbemServices *a_Repository ,
		IWbemServices *a_Service ,
		IWbemProviderInitSink *a_Sink

	) ;

	HRESULT STDMETHODCALLTYPE WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout ) ;

	HRESULT STDMETHODCALLTYPE GetInitializeResult () 
	{
		return m_InitializeResult ;
	}

	HRESULT STDMETHODCALLTYPE GetHosting ( ULONG *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = e_Hosting_WmiCore ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE GetHostingGroup ( BSTR *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = NULL ;

			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE IsInternal ( BOOL *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = TRUE ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE IsPerUserInitialization ( BOOL *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = FALSE ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE IsPerLocaleInitialization ( BOOL *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = FALSE ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	/* _IWmiProviderCache */

	HRESULT STDMETHODCALLTYPE Expel (

		long a_Flags ,
		IWbemContext *a_Context
	) ;

	HRESULT STDMETHODCALLTYPE Unload (

		long a_Flags ,
		IWbemContext *a_Context
	) ;

	HRESULT STDMETHODCALLTYPE Load (

		long a_Flags ,
		IWbemContext *a_Context
	) ;

	HRESULT STDMETHODCALLTYPE ForceReload () ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;


#endif // _Server_DecoupledAggregator_IWbemProvider_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provhost.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvSubS.h

Abstract:


History:

--*/

#ifndef _Server_Host_H
#define _Server_Host_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ProxyIndex_Host__IWmiProviderHost				0
#define ProxyIndex_Host_IWbemShutdown					1

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#include "ProvCache.h"

class CServerObject_HostInterceptor :	public _IWmiProviderHost ,
										public IWbemShutdown ,
										public HostCacheElement 
{
private:

	WmiAllocator &m_Allocator ;

	IUnknown *m_Unknown ;
	IWbemShutdown *m_Host_IWbemShutdown ;
	_IWmiProviderHost *m_Host_IWmiProviderHost ;

	ProxyContainer m_ProxyContainer ;

	LONG m_Initialized ;
	LONG m_UnInitialized ;
	HRESULT m_InitializeResult ;
	HANDLE m_InitializedEvent ;
	IWbemContext *m_InitializationContext ;
	DWORD m_ProcessIdentifier ;
	
	void CallBackInternalRelease () ;

public:

	CServerObject_HostInterceptor ( 

		WmiAllocator &a_Allocator ,
		CWbemGlobal_IWmiHostController *a_Controller , 
		const HostCacheKey &a_Key ,
		const ULONG &a_Period ,
		IWbemContext *a_InitializationContext
	) ;

    ~CServerObject_HostInterceptor () ;

	HRESULT Initialize (

		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink     // For init signals
	) ;

	HRESULT SetHost ( IUnknown *a_Unknown ) ;

	HRESULT IsIndependant ( IWbemContext *a_Context ) ;

	HRESULT SetInitialized ( HRESULT a_InitializeResult ) ;

	HRESULT WaitHost ( IWbemContext *a_Context , ULONG a_Timeout ) ;

	HRESULT GetInitializeResult () 
	{
		return m_InitializeResult ;
	}

	DWORD GetProcessIdentifier ()
	{
		return m_ProcessIdentifier ;
	}

	static HRESULT AbnormalShutdown (

		HostCacheKey &a_Key
	) ;

	static HRESULT CreateUsingAccount (

		HostCacheKey &a_Key ,
		LPWSTR a_User ,
		LPWSTR a_Domain ,
		_IWmiProviderHost **a_Host ,
		_IWmiProviderFactory **a_Factory 
	) ;

	static HRESULT CreateUsingToken (

		HostCacheKey &a_Key ,
		_IWmiProviderHost **a_Host ,
		_IWmiProviderFactory **a_Factory 
	) ;

	static HRESULT CreateUsingToken (

		HostCacheKey &a_Key ,
		_IWmiProviderHost **a_Host ,
		_IWbemRefresherMgr **a_RefresherManager 
	) ;

	static HRESULT CreateUsingAccount (

		HostCacheKey &a_Key ,
		LPWSTR a_User ,
		LPWSTR a_Domain ,
		_IWmiProviderHost **a_Host ,
		_IWbemRefresherMgr **a_RefresherManager 
	) ;

	static HRESULT FindHost ( 

		IWbemContext *a_Context ,
		HostCacheKey &a_Key ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE GetObject (

		REFCLSID a_Clsid ,
		long a_Flags ,
		IWbemContext *a_Context ,
		REFIID a_Riid ,
		void **a_Interface
	) ;

	HRESULT STDMETHODCALLTYPE GetProcessIdentifier ( DWORD *a_ProcessIdentifier ) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ;

} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_Host :	public _IWmiProviderHost ,
							public IWbemShutdown

{
private:

	LONG m_ReferenceCount ;
	WmiAllocator &m_Allocator ;

protected:
public:

    CServerObject_Host ( WmiAllocator &a_Allocator ) ;
    ~CServerObject_Host ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//

	HRESULT STDMETHODCALLTYPE GetObject (

		REFCLSID a_Clsid ,
		long a_Flags ,
		IWbemContext *a_Context ,
		REFIID a_Riid ,
		void **a_Interface
	) ;

	HRESULT STDMETHODCALLTYPE GetProcessIdentifier ( DWORD *a_ProcessIdentifier ) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ;

};

#endif // _Server_Host_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provobsk.h ===
#ifndef _Server_Interceptor_IWbemObjectSink_H
#define _Server_Interceptor_IWbemObjectSink_H

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvObSk.H

Abstract:


History:

--*/

#include <ProvObjectSink.h>
#include "ProvCache.h"
#include "Queue.h"
#include <lockst.h>

#define SYNCPROV_USEBATCH

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ProxyIndex_IWbemObjectSink					0
#define ProxyIndex_Internal_IWbemObjectSink			1
#define ProxyIndex_ObjectSink_Size					2

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class IObjectSink_CancelOperation : public IUnknown
{
private:
protected:
public:

	virtual HRESULT STDMETHODCALLTYPE Cancel (

		LONG a_Flags

	) = 0 ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemObjectSink :	public IWbemObjectSink , 
										public IWbemShutdown ,

#ifdef INTERNAL_IDENTIFY
										public Internal_IWbemObjectSink , 
#endif
										public ObjectSinkContainerElement 
{
private:

	LONG m_InProgress ;
	LONG m_StatusCalled ;

	IWbemObjectSink *m_InterceptedSink ;
	IUnknown *m_Unknown ;
	SECURITY_DESCRIPTOR *m_SecurityDescriptor ;

protected:

	LONG m_GateClosed ;

public:

	CInterceptor_IWbemObjectSink (

		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller 
	) ;

	~CInterceptor_IWbemObjectSink () ;

	HRESULT Initialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor ) ;

	void CallBackInternalRelease () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

#ifdef INTERNAL_IDENTIFY

    HRESULT STDMETHODCALLTYPE Internal_Indicate (

		WmiInternalContext a_InternalContext ,
		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE Internal_SetStatus (

		WmiInternalContext a_InternalContext ,
		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
#endif
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink :	public CCommon_IWbemSyncObjectSink
{
private:
protected:
public:

	CInterceptor_IWbemSyncObjectSink (

		WmiAllocator &a_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink() ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_GetObjectAsync : public CCommon_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_ObjectPath ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_GetObjectAsync (

		WmiAllocator &a_Allocator ,
		long a_Flags ,
		BSTR a_ObjectPath ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_GetObjectAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync : public CCommon_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_ObjectPath ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync (

		WmiAllocator &a_Allocator ,
		long a_Flags ,
		BSTR a_ObjectPath ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_DeleteClassAsync : public CCommon_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_Class ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_DeleteClassAsync (

		WmiAllocator &a_Allocator ,
		long a_Flags ,
		BSTR a_Class ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_DeleteClassAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_PutInstanceAsync : public CCommon_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	IWbemClassObject *m_Instance ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_PutInstanceAsync (

		WmiAllocator &a_Allocator ,
		long a_Flags ,
		IWbemClassObject *a_Class ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_PutInstanceAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_PutClassAsync : public CCommon_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	IWbemClassObject *m_Class ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_PutClassAsync (

		WmiAllocator &a_Allocator ,
		long a_Flags ,
		IWbemClassObject *a_Class ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_PutClassAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync : public CCommon_Batching_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_Class ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync (

		WmiAllocator &a_Allocator ,
		long a_Flags ,
		BSTR a_Class ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync : public CCommon_Batching_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_SuperClass ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync (

		WmiAllocator &a_Allocator ,
		long a_Flags ,
		BSTR a_SuperClass ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_ExecQueryAsync : public CCommon_Batching_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_QueryLanguage ;
	BSTR m_Query ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_ExecQueryAsync (

		WmiAllocator &a_Allocator ,
		long a_Flags ,
		BSTR a_QueryLanguage ,
		BSTR a_Query ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_ExecQueryAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_ExecMethodAsync : public CCommon_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_ObjectPath ;
	BSTR m_MethodName ;
	IWbemClassObject *m_InParameters ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_ExecMethodAsync (

		WmiAllocator &a_Allocator ,
		long a_Flags ,
		BSTR a_ObjectPath ,
		BSTR a_MethodName ,
		IWbemClassObject *a_InParameters ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_ExecMethodAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemFilteringObjectSink :	public CInterceptor_IWbemObjectSink
{
private:

	LONG m_Filtering ;

	BSTR m_QueryLanguage ;
	BSTR m_Query ;

	IWbemQuery *m_QueryFilter ;

protected:
public:

	CInterceptor_IWbemFilteringObjectSink (

		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query
	) ;

	~CInterceptor_IWbemFilteringObjectSink () ;

public:

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncFilteringObjectSink :	public IWbemObjectSink , 
													public IWbemShutdown ,
													public ObjectSinkContainerElement
{
private:

	LONG m_InProgress ;
	LONG m_StatusCalled ;
	LONG m_Filtering ;

	BSTR m_QueryLanguage ;
	BSTR m_Query ;

	ULONG m_Dependant ;

	IWbemObjectSink *m_InterceptedSink ;
	IWbemQuery *m_QueryFilter ;
	IUnknown *m_Unknown ;

protected:

	LONG m_GateClosed ;

public:

	CInterceptor_IWbemSyncFilteringObjectSink (

		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncFilteringObjectSink() ;

	void CallBackInternalRelease () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_DecoupledIWbemObjectSink :	public IWbemObjectSink , 
												public IWbemShutdown ,
												public IObjectSink_CancelOperation ,
												public ObjectSinkContainerElement
{
private:

	LONG m_InProgress ;
	LONG m_StatusCalled ;

	IWbemObjectSink *m_InterceptedSink ;
	IUnknown *m_Unknown ;

	SECURITY_DESCRIPTOR *m_SecurityDescriptor ;

	IWbemServices *m_Provider ;

protected:

	LONG m_GateClosed ;

public:

	CInterceptor_DecoupledIWbemObjectSink (

		IWbemServices *a_Provider ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller 
	) ;

	~CInterceptor_DecoupledIWbemObjectSink () ;

	HRESULT Initialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor ) ;

	void CallBackInternalRelease () ;

	IWbemServices *GetProvider () { return m_Provider ; }

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

	HRESULT STDMETHODCALLTYPE Cancel (

		LONG a_Flags
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_DecoupledIWbemCombiningObjectSink :	public IWbemObjectSink , 
														public IWbemShutdown ,
														public IObjectSink_CancelOperation ,
														public ObjectSinkContainerElement ,
														public CWbemGlobal_IWmiObjectSinkController 
{
private:

	LONG m_InProgress ;
	LONG m_StatusCalled ;

	LONG m_SinkCount ;
	HANDLE m_Event ;

	IWbemObjectSink *m_InterceptedSink ;

	void CallBackInternalRelease () ;

protected:

	LONG m_GateClosed ;

public:

	CInterceptor_DecoupledIWbemCombiningObjectSink (

		WmiAllocator &m_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller
	) ;

	~CInterceptor_DecoupledIWbemCombiningObjectSink () ;

	HRESULT Wait ( ULONG a_Timeout ) ;

	HRESULT EnQueue ( CInterceptor_DecoupledIWbemObjectSink *a_Sink ) ;

	void Suspend () ;

	void Resume () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

	HRESULT STDMETHODCALLTYPE Cancel (

		LONG a_Flags
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemWaitingObjectSink :		public IWbemObjectSink , 
												public IWbemShutdown ,
												public IObjectSink_CancelOperation ,
												public ObjectSinkContainerElement ,
												public CWbemGlobal_IWmiObjectSinkController 
{
private:

	LONG m_ReferenceCount ;
	LONG m_InProgress ;
	LONG m_StatusCalled ;

	WmiQueue <IWbemClassObject *,8> m_Queue ;
	CriticalSection m_CriticalSection ;

	HANDLE m_Event ;

	HRESULT m_Result ;

	IWbemServices *m_Provider ;
		
	CServerObject_ProviderRegistrationV1 &m_Registration ;

	SECURITY_DESCRIPTOR *m_SecurityDescriptor ;

protected:

	LONG m_GateClosed ;

public:

	CInterceptor_IWbemWaitingObjectSink (

		WmiAllocator &m_Allocator ,
		IWbemServices *a_Provider ,
		IWbemObjectSink *a_InterceptedSink ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		CServerObject_ProviderRegistrationV1 &a_Registration 
	) ;

	~CInterceptor_IWbemWaitingObjectSink () ;

	HRESULT Initialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor ) ;

	void CallBackInternalRelease () ;

	HRESULT Wait ( ULONG a_Timeout = INFINITE ) ;

	WmiQueue <IWbemClassObject *,8> & GetQueue () { return m_Queue ; }
	CriticalSection &GetQueueCriticalSection () { return m_CriticalSection ; }

	HRESULT GetResult () { return m_Result ; }

	IWbemServices *GetProvider () { return m_Provider ; }

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

	HRESULT STDMETHODCALLTYPE Cancel (

		LONG a_Flags
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemWaitingObjectSink_GetObjectAsync : public CInterceptor_IWbemWaitingObjectSink
{
private:

	BSTR m_ObjectPath ;
	LONG m_Flags ;
	IWbemContext *m_Context ;

protected:
public:

	CInterceptor_IWbemWaitingObjectSink_GetObjectAsync ( 

		WmiAllocator &m_Allocator ,
		IWbemServices *a_Provider ,
		IWbemObjectSink *a_InterceptedSink ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		CServerObject_ProviderRegistrationV1 &a_Registration 
	) ;

	~CInterceptor_IWbemWaitingObjectSink_GetObjectAsync () ;

	HRESULT Initialize ( 
	
		SECURITY_DESCRIPTOR *a_SecurityDescriptor , 
		BSTR a_ObjectPath ,
		LONG a_Flags , 
		IWbemContext *a_Context
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync : public CInterceptor_IWbemWaitingObjectSink
{
private:

	BSTR m_Class ;
	LONG m_Flags ;
	IWbemContext *m_Context ;

protected:
public:

	CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync ( 

		WmiAllocator &m_Allocator ,
		IWbemServices *a_Provider ,
		IWbemObjectSink *a_InterceptedSink ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		CServerObject_ProviderRegistrationV1 &a_Registration 
	) ;

	~CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync () ;

	HRESULT Initialize ( 
	
		SECURITY_DESCRIPTOR *a_SecurityDescriptor , 
		BSTR a_Class ,
		LONG a_Flags , 
		IWbemContext *a_Context
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync : public CInterceptor_IWbemWaitingObjectSink
{
private:

	BSTR m_SuperClass ;
	LONG m_Flags ;
	IWbemContext *m_Context ;

protected:
public:

	CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync ( 

		WmiAllocator &m_Allocator ,
		IWbemServices *a_Provider ,
		IWbemObjectSink *a_InterceptedSink ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		CServerObject_ProviderRegistrationV1 &a_Registration 
	) ;

	~CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync () ;

	HRESULT Initialize ( 
	
		SECURITY_DESCRIPTOR *a_SecurityDescriptor , 
		BSTR a_SuperClass ,
		LONG a_Flags , 
		IWbemContext *a_Context
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemWaitingObjectSink_PutClassAsync : public CInterceptor_IWbemWaitingObjectSink
{
private:

	IWbemClassObject *m_ClassObject ;
	LONG m_Flags ;
	IWbemContext *m_Context ;

protected:
public:

	CInterceptor_IWbemWaitingObjectSink_PutClassAsync ( 

		WmiAllocator &m_Allocator ,
		IWbemServices *a_Provider ,
		IWbemObjectSink *a_InterceptedSink ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		CServerObject_ProviderRegistrationV1 &a_Registration 
	) ;

	~CInterceptor_IWbemWaitingObjectSink_PutClassAsync () ;

	HRESULT Initialize ( 
	
		SECURITY_DESCRIPTOR *a_SecurityDescriptor , 
		IWbemClassObject *a_ClassObject ,
		LONG a_Flags , 
		IWbemContext *a_Context
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CWaitingObjectSink :	public IWbemObjectSink ,
							public IWbemShutdown ,
							public ObjectSinkContainerElement
{
private:

	LONG m_InProgress ;
	LONG m_StatusCalled ;

	HRESULT m_Result ;

	LONG m_ReferenceCount ;

	HANDLE m_Event ;

	WmiQueue <IWbemClassObject *,8> m_Queue ;
	CriticalSection m_CriticalSection ;

protected:

	LONG m_GateClosed ;

public:

	HRESULT SinkInitialize () ;

public:

	CWaitingObjectSink ( WmiAllocator &a_Allocator ) ;

	~CWaitingObjectSink () ;

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_(ULONG) Release () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

        long a_Flags ,
        HRESULT a_Result ,
        BSTR a_StringParameter ,
        IWbemClassObject *a_ObjectParameter
	) ;

    HRESULT STDMETHODCALLTYPE Indicate (

        LONG a_ObjectCount,
        IWbemClassObject **a_ObjectArray
	) ;

	HRESULT Wait ( DWORD a_Timeout = INFINITE ) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

	WmiQueue <IWbemClassObject *,8> & GetQueue () { return m_Queue ; }
	CriticalSection &GetQueueCriticalSection () { return m_CriticalSection ; }

	HRESULT GetResult () { return m_Result ; }
} ;

#endif _Server_Interceptor_IWbemObjectSink_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\resource.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Resource.h

Abstract:


History:

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by propprov.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provresv.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.h

Abstract:


History:

--*/

#ifndef _Server_DynamicPropertyProviderResolver_H
#define _Server_DynamicPropertyProviderResolver_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_DynamicPropertyProviderResolver :	public _IWmiDynamicPropertyResolver , 
														public IWbemProviderInit , 
														public IWbemShutdown
{
private:

    long m_ReferenceCount ;
	WmiAllocator &m_Allocator ;
	_IWmiProviderFactory *m_Factory ;
	IWbemServices *m_CoreStub ;
	BSTR m_User ;
	BSTR m_Locale ;

	HRESULT GetClassAndInstanceContext (

		IWbemClassObject *a_Class ,
		IWbemClassObject *a_Instance ,
		BSTR &a_ClassContext ,
		BSTR &a_InstanceContext ,
		BOOL &a_Dynamic
	) ;

	HRESULT ReadOrWrite (

		IWbemContext *a_Context ,
		IWbemClassObject *a_Instance ,
		BSTR a_ClassContext ,
		BSTR a_InstanceContext ,
		BSTR a_PropertyContext ,
		BSTR a_Provider ,
		BSTR a_Property ,
		BOOL a_Read 
	) ;

	HRESULT STDMETHODCALLTYPE ReadOrWrite (

		IWbemContext *a_Context ,
        IWbemClassObject *a_Class ,
        IWbemClassObject *a_Instance ,
		BOOL a_Read 
	) ;

protected:
public:

    CServerObject_DynamicPropertyProviderResolver (

		WmiAllocator &a_Allocator ,
		_IWmiProviderFactory *a_Factory ,
		IWbemServices *a_CoreStub
	) ;

    ~CServerObject_DynamicPropertyProviderResolver () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	// IWmi_DynamicPropertyResolver members

    HRESULT STDMETHODCALLTYPE Read (

		IWbemContext *a_Context ,
		IWbemClassObject *a_Class ,
		IWbemClassObject **a_Instance
	);

	HRESULT STDMETHODCALLTYPE Write (

		IWbemContext *a_Context ,
        IWbemClassObject *a_Class ,
        IWbemClassObject *a_Instance
	) ;

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ;
};

#endif // #define _Server_DynamicPropertyProviderResolver_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provrmgr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvSubS.h

Abstract:


History:

--*/

#ifndef _Server_ProviderRefresherManager_H
#define _Server_ProviderRefresherManager_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#include "ProvCache.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ProxyIndex_RefresherManager_IWbemRefresherMgr				0
#define ProxyIndex_RefresherManager_IWbemShutdown					1

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_InterceptorProviderRefresherManager :	public _IWbemRefresherMgr ,
															public IWbemShutdown ,
															public RefresherManagerCacheElement

{
public:
private:

	LONG m_ReferenceCount ;

	WmiAllocator &m_Allocator ;

	ProxyContainer m_ProxyContainer ;

	_IWmiProviderHost *m_Host ;
	_IWbemRefresherMgr *m_Manager ; 
	IWbemShutdown *m_Shutdown ;

	LONG m_Initialized ;
	LONG m_UnInitialized ;
	HRESULT m_InitializeResult ;
	HANDLE m_InitializedEvent ;
	IWbemContext *m_InitializationContext ;

protected:

	HRESULT AbnormalShutdown () ;

public:

	HRESULT Initialize () ;

	HRESULT SetManager ( _IWmiProviderHost *a_Host , _IWbemRefresherMgr *a_Manager ) ;

	HRESULT SetInitialized ( HRESULT a_InitializeResult ) ;

	HRESULT IsIndependant ( IWbemContext *a_Context ) ;

	HRESULT STDMETHODCALLTYPE WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout ) ;

	HRESULT STDMETHODCALLTYPE GetInitializeResult () 
	{
		return m_InitializeResult ;
	}

public:

    CServerObject_InterceptorProviderRefresherManager (

		CWbemGlobal_IWbemRefresherMgrController *a_Controller ,
		const ULONG &a_Period ,
		WmiAllocator &a_Allocator ,
		IWbemContext *a_InitializationContext
	) ;

    ~CServerObject_InterceptorProviderRefresherManager () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	// IWmi_ProviderSubSystem members

	// IWmi_Initialize members

	HRESULT STDMETHODCALLTYPE Startup (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		_IWmiProvSS *a_ProvSS
	) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ;

	HRESULT STDMETHODCALLTYPE AddObjectToRefresher (

		IWbemServices *a_Service, 
		LPCWSTR a_ServerName, 
		LPCWSTR a_Namespace, 
		IWbemClassObject* pClassObject,
		WBEM_REFRESHER_ID *a_DestinationRefresherId, 
		IWbemClassObject *a_InstanceTemplate, 
		long a_Flags, 
		IWbemContext *a_Context,
		IUnknown* pLockMgr,
		WBEM_REFRESH_INFO *a_Information
	) ;

	HRESULT STDMETHODCALLTYPE AddEnumToRefresher (

		IWbemServices *a_Service, 
		LPCWSTR a_ServerName, 
		LPCWSTR a_Namespace, 
		IWbemClassObject* pClassObject,
		WBEM_REFRESHER_ID *a_DestinationRefresherId, 
		IWbemClassObject *a_InstanceTemplate, 
		LPCWSTR a_Class,
		long a_Flags, 
		IWbemContext *a_Context, 
		IUnknown* pLockMgr,
		WBEM_REFRESH_INFO *a_Information
	) ;

	HRESULT STDMETHODCALLTYPE GetRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId , 
		long a_Flags, 
		BOOL fAddRefresher,
		IWbemRemoteRefresher **a_RemoteRefresher ,  
		IUnknown* pLockMgr,
		GUID *a_Guid
	) ;

	HRESULT STDMETHODCALLTYPE LoadProvider (

		IWbemServices *a_Service ,
		LPCWSTR a_ProviderName ,
		LPCWSTR a_Namespace ,
		IWbemContext * a_Context,
		IWbemHiPerfProvider **a_Provider,
		_IWmiProviderStack **a_ProvStack
	) ; 
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderRefresherManager :	public _IWbemRefresherMgr ,
												public IWbemShutdown

{
public:
private:

	LONG m_ReferenceCount ;

	WmiAllocator &m_Allocator ;

	_IWbemRefresherMgr *m_Manager ; 
	IWbemShutdown *m_Shutdown ;

protected:

public:

    CServerObject_ProviderRefresherManager ( WmiAllocator &a_Allocator ) ;
    ~CServerObject_ProviderRefresherManager () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	// IWmi_ProviderSubSystem members

	// IWmi_Initialize members

	HRESULT STDMETHODCALLTYPE Startup (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		_IWmiProvSS *a_ProvSS
	) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ;

	HRESULT STDMETHODCALLTYPE AddObjectToRefresher (

		IWbemServices *a_Service, 
		LPCWSTR a_ServerName, 
		LPCWSTR a_Namespace, 
		IWbemClassObject* pClassObject,
		WBEM_REFRESHER_ID *a_DestinationRefresherId, 
		IWbemClassObject *a_InstanceTemplate, 
		long a_Flags, 
		IWbemContext *a_Context,
		IUnknown* pLockMgr,
		WBEM_REFRESH_INFO *a_Information
	) ;

	HRESULT STDMETHODCALLTYPE AddEnumToRefresher (

		IWbemServices *a_Service, 
		LPCWSTR a_ServerName, 
		LPCWSTR a_Namespace, 
		IWbemClassObject* pClassObject,
		WBEM_REFRESHER_ID *a_DestinationRefresherId, 
		IWbemClassObject *a_InstanceTemplate, 
		LPCWSTR a_Class,
		long a_Flags, 
		IWbemContext *a_Context, 
		IUnknown* pLockMgr,
		WBEM_REFRESH_INFO *a_Information
	) ;

	HRESULT STDMETHODCALLTYPE GetRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId , 
		long a_Flags, 
		BOOL fAddRefresher,
		IWbemRemoteRefresher **a_RemoteRefresher ,  
		IUnknown* pLockMgr,
		GUID *a_Guid
	) ;

	HRESULT STDMETHODCALLTYPE LoadProvider (

		IWbemServices *a_Service ,
		LPCWSTR a_ProviderName ,
		LPCWSTR a_Namespace ,
		IWbemContext * a_Context,
		IWbemHiPerfProvider **a_Provider,
		_IWmiProviderStack** a_ProvStack
	) ; 
};

#endif // _Server_ProviderRefresherManager_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provself.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _Server_ProviderSelfInstrumentation_H
#define _Server_ProviderSelfInstrumentation_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_IWbemServices : public IWbemServices , public IWbemProviderInit
{
private:

	LONG m_ReferenceCount ;         //Object reference count

	IWbemServices *m_Service ;

	HRESULT Write_Msft_WmiProvider_Counters ( 
		
		IWbemClassObject *a_Object 
	) ;

	HRESULT GetObjectAsync_Msft_WmiProvider_Counters ( 
		
		IWbemPath *a_Path,
		BSTR a_Class ,
		const BSTR a_ObjectPath, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT GetObjectAsync_Msft_Providers ( 
		
		IWbemPath *a_Path,
		BSTR a_Class ,
		const BSTR a_ObjectPath, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT CreateInstanceEnumAsync_Msft_WmiProvider_Counters (

 		const BSTR a_Class, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink 
	) ;

	HRESULT CreateInstanceEnumAsync_Msft_Providers (

 		const BSTR a_Class, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink 
	) ;

	HRESULT Helper_ExecMethodAsync_Suspend ( 

		IWbemPath *a_Path ,
		const BSTR a_ObjectPath,
		const BSTR a_MethodName,
		long a_Flags,
		IWbemContext *a_Context,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT Helper_ExecMethodAsync_Resume ( 

		IWbemPath *a_Path ,
		const BSTR a_ObjectPath,
		const BSTR a_MethodName,
		long a_Flags,
		IWbemContext *a_Context,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT Helper_ExecMethodAsync_UnLoad ( 

		IWbemPath *a_Path ,
		const BSTR a_ObjectPath,
		const BSTR a_MethodName,
		long a_Flags,
		IWbemContext *a_Context,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT Helper_ExecMethodAsync_Load ( 

		IWbemPath *a_Path ,
		const BSTR a_ObjectPath,
		const BSTR a_MethodName,
		long a_Flags,
		IWbemContext *a_Context,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

public:

	CServerObject_IWbemServices (

		WmiAllocator &a_Allocator
	) ;

    ~CServerObject_IWbemServices () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;


#endif // _Server_ProviderSelfInstrumentation_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\stress\client.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <stdio.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemint.h>

#include <Allocator.h>
#include <HelperFuncs.h>
#include "Globals.h"
#include "Task.h"
#include "CThread.h"

/******************************************************************************
 *
 *	Name:
 *
 *	`
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Process_MultiThread ( ULONG a_OperationCount )
{
	HRESULT t_Result = S_OK ;

	WmiAllocator t_Allocator ;
	WmiStatusCode t_StatusCode = t_Allocator.Initialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_Initialize ( t_Allocator ) ;

#if 1
		WmiThread < ULONG > *t_Thread1 = new ClientThread ( t_Allocator ) ;
		if ( t_Thread1 )
		{
			t_Thread1->AddRef () ;

			t_StatusCode = t_Thread1->Initialize () ;

			Task_Execute t_Task1 ( t_Allocator , a_OperationCount ) ;
			t_Task1.Initialize () ;
			t_Thread1->EnQueue ( 0 , t_Task1 ) ;

			t_Task1.WaitInterruptable () ;

			HANDLE t_Thread1Handle = NULL ;

			BOOL t_Status = DuplicateHandle ( 

				GetCurrentProcess () ,
				t_Thread1->GetHandle () ,
				GetCurrentProcess () ,
				& t_Thread1Handle, 
				0 , 
				FALSE , 
				DUPLICATE_SAME_ACCESS
			) ;

			t_Thread1->Release () ;

			WaitForSingleObject ( t_Thread1Handle , INFINITE ) ;

			CloseHandle ( t_Thread1Handle ) ;
		}

#else
		WmiThread < ULONG > *t_Thread1 = new ClientThread ( t_Allocator ) ;
		if ( t_Thread1 )
		{
			t_Thread1->AddRef () ;

			t_StatusCode = t_Thread1->Initialize () ;

			WmiThread < ULONG > *t_Thread2 = new ClientThread ( t_Allocator ) ;
			if ( t_Thread2 )
			{
				t_Thread2->AddRef () ;

				t_StatusCode = t_Thread2->Initialize () ;

				Task_Execute t_Task1 ( t_Allocator , a_OperationCount ) ;
				t_Task1.Initialize () ;
				t_Thread1->EnQueue ( 0 , t_Task1 ) ;

				Task_Execute t_Task2 ( t_Allocator , a_OperationCount ) ;
				t_Task2.Initialize () ;
				t_Thread2->EnQueue ( 0 , t_Task2 ) ;

				t_Task1.WaitInterruptable () ;
				t_Task2.WaitInterruptable () ;

				HANDLE t_Thread1Handle = NULL ;

				BOOL t_Status = DuplicateHandle ( 

					GetCurrentProcess () ,
					t_Thread1->GetHandle () ,
					GetCurrentProcess () ,
					& t_Thread1Handle, 
					0 , 
					FALSE , 
					DUPLICATE_SAME_ACCESS
				) ;

				t_Thread1->Release () ;

				WaitForSingleObject ( t_Thread1Handle , INFINITE ) ;

				CloseHandle ( t_Thread1Handle ) ;

				HANDLE t_Thread2Handle = NULL ; 

				t_Status = DuplicateHandle ( 

					GetCurrentProcess () ,
					t_Thread2->GetHandle () ,
					GetCurrentProcess () ,
					& t_Thread2Handle, 
					0 , 
					FALSE , 
					DUPLICATE_SAME_ACCESS
				) ;

				t_Thread2->Release () ;
	
				WaitForSingleObject ( t_Thread2Handle , INFINITE ) ;

				CloseHandle ( t_Thread2Handle ) ;
			}
		}

#endif
		t_StatusCode = WmiThread <ULONG> :: Static_UnInitialize ( t_Allocator ) ;
	}	
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void Process ( ULONG a_OperationCount )
{
	HRESULT t_Result = CoInitializeEx(0, COINIT_MULTITHREADED) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CoInitializeSecurity (

			NULL, 
			-1, 
			NULL, 
			NULL,
			RPC_C_AUTHN_LEVEL_NONE,
			RPC_C_IMP_LEVEL_IMPERSONATE,
			NULL, 
			EOAC_NONE, 
			0
		);

		t_Result = Process_MultiThread ( a_OperationCount );

		CoUninitialize () ;
	}
	else
	{
		// fwprintf ( stderr , L"CoInitilize: %lx\n" , t_Result ) ;
	}
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

EXTERN_C int __cdecl wmain (

	int argc ,
	char **argv 
)
{
	ULONG t_OperationCount = 2 ;

	Process ( t_OperationCount ) ;
	
	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\stress\cthread.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CThread.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ClientThread :: Initialize_Callback ()
{
	CoInitializeEx ( NULL , COINIT_MULTITHREADED ) ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ClientThread :: UnInitialize_Callback () 
{
	CoUninitialize () ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ClientThread :: ClientThread (

	WmiAllocator &a_Allocator	

) : WmiThread < ULONG > ( a_Allocator ) ,
	m_Allocator ( a_Allocator )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ClientThread::~ClientThread ()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provwsv.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvWsv.H

Abstract:


History:

--*/

#ifndef _Server_Interceptor_IWbemServices_H
#define _Server_Interceptor_IWbemServices_H

#include <CGlobals.h>
#include "ProvCache.h"
#include "ProvRegInfo.h"

#define ProxyIndex_IWbemServices					0
#define ProxyIndex_IWbemPropertyProvider			1
#define ProxyIndex_IWbemHiPerfProvider				2
#define ProxyIndex_IWbemEventProvider				3
#define ProxyIndex_IWbemEventProviderQuerySink		4
#define ProxyIndex_IWbemEventProviderSecurity		5
#define ProxyIndex_IWbemProviderIdentity			6
#define ProxyIndex_IWbemEventConsumerProvider		7
#define ProxyIndex_IWbemEventConsumerProviderEx		8
#define ProxyIndex_IWbemUnboundObjectSink			9
#define ProxyIndex_IWbemProviderInit				10

#define ProxyIndex_Internal_IWbemServices					11
#define ProxyIndex_Internal_IWbemPropertyProvider			12
#define ProxyIndex_Internal_IWbemEventProvider				13
#define ProxyIndex_Internal_IWbemEventProviderQuerySink		14
#define ProxyIndex_Internal_IWbemEventProviderSecurity		15
#define ProxyIndex_Internal_IWbemEventConsumerProvider		16
#define ProxyIndex_Internal_IWbemEventConsumerProviderEx	17
#define ProxyIndex_Internal_IWbemUnboundObjectSink			18
#define ProxyIndex_Internal_IWbemProviderIdentity			19
#define ProxyIndex_Internal_IWbemProviderInit				20

#define ProxyIndex_IWbemShutdown					21
#define ProxyIndex__IWmiProviderConfiguration		22

#define ProxyIndex_Internal_IWmiProviderConfiguration		23

#define ProxyIndex_Provider_Size					23

#define ProxyIndex_UnBound_IWbemUnboundObjectSink				0
#define ProxyIndex_UnBound_Internal_IWbemUnboundObjectSink		1
#define ProxyIndex_UnBound_Size									2

#define ProxyIndex_UnBoundSync_IWbemUnboundObjectSink			0
#define ProxyIndex_UnBoundSync_Size								1

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemUnboundObjectSink :		public IWbemUnboundObjectSink ,
												public IWbemShutdown , 
												public VoidPointerContainerElement
{
private:

	WmiAllocator &m_Allocator ;
	CServerObject_ProviderRegistrationV1 *m_Registration ;

	_IWmiProviderAbnormalShutdown *m_Controller ;

	IUnknown *m_Unknown ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;
	Internal_IWbemUnboundObjectSink *m_Provider_Internal_IWbemUnboundObjectSink ;

	ProxyContainer m_ProxyContainer ;

	DWORD m_ProcessIdentifier ;

	HRESULT m_InitializeResult ;

protected:

	HRESULT Begin_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

public:

	CInterceptor_IWbemUnboundObjectSink (

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideProvider , 
		CWbemGlobal_IWmiObjectSinkController *a_Controller , 
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	~CInterceptor_IWbemUnboundObjectSink () ;

	HRESULT Initialize () ;

public:

	STDMETHODIMP QueryInterface ( 

		REFIID iid , 
		LPVOID FAR *iplpv 
	) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupled_IWbemUnboundObjectSink :		public IWbemUnboundObjectSink ,
												public IWbemShutdown , 
												public VoidPointerContainerElement
{
private:

	WmiAllocator &m_Allocator ;
	CServerObject_ProviderRegistrationV1 *m_Registration ;

	_IWmiProviderAbnormalShutdown *m_Controller ;

	IUnknown *m_Unknown ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;
	Internal_IWbemUnboundObjectSink *m_Provider_Internal_IWbemUnboundObjectSink ;

	ProxyContainer m_ProxyContainer ;

	DWORD m_ProcessIdentifier ;

	HRESULT m_InitializeResult ;

protected:

	HRESULT Begin_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

public:

	CDecoupled_IWbemUnboundObjectSink (

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideProvider , 
		CWbemGlobal_IWmiObjectSinkController *a_Controller , 
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	~CDecoupled_IWbemUnboundObjectSink () ;

	HRESULT Initialize () ;

public:

	STDMETHODIMP QueryInterface ( 

		REFIID iid , 
		LPVOID FAR *iplpv 
	) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemProvider ;

class InternalQuotaInterface : public _IWmiProviderQuota
{
private:

	LONG m_ReferenceCount ;
	_IWmiProviderQuota *m_Owner ;

public:

	InternalQuotaInterface ( CInterceptor_IWbemProvider *a_Owner ) ;

	~InternalQuotaInterface () ;

	HRESULT Initialize () ;

	STDMETHODIMP QueryInterface ( 

		REFIID iid , 
		LPVOID FAR *iplpv 
	) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE Violation (

		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_Object	
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemProvider :		public IWbemServices , 
										public IWbemPropertyProvider ,
										public IWbemEventProvider ,
										public IWbemEventProviderQuerySink ,
										public IWbemEventProviderSecurity ,
										public IWbemEventConsumerProviderEx ,
										public IWbemUnboundObjectSink ,
										public IWbemHiPerfProvider ,
										public IWbemProviderInit , 
										public _IWmiProviderInitialize ,
										public _IWmiProviderLoad , 
										public IWbemShutdown , 
										public _IWmiProviderQuota ,
										public _IWmiProviderConfiguration ,
										public _IWmiProviderStack ,
										public _IWmiProviderCache ,
										public _IWmiProviderAbnormalShutdown ,
										public ServiceCacheElement , 
										public CWbemGlobal_IWmiObjectSinkController 
{
private:

	WmiAllocator &m_Allocator ;
	CServerObject_ProviderRegistrationV1 *m_Registration ;

	_IWmiProviderHost *m_Host ;

	InternalQuotaInterface *m_Quota ;

	IUnknown *m_Unknown ;
	IWbemServices *m_Provider_IWbemServices ;
	IWbemPropertyProvider *m_Provider_IWbemPropertyProvider ;
	IWbemHiPerfProvider *m_Provider_IWbemHiPerfProvider ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemEventConsumerProviderEx *m_Provider_IWbemEventConsumerProviderEx ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;
	_IWmiProviderConfiguration *m_Provider__IWmiProviderConfiguration ;

	Internal_IWbemServices *m_Provider_Internal_IWbemServices ;
	Internal_IWbemPropertyProvider *m_Provider_Internal_IWbemPropertyProvider ;
	Internal_IWbemEventProvider *m_Provider_Internal_IWbemEventProvider ;
	Internal_IWbemEventProviderQuerySink *m_Provider_Internal_IWbemEventProviderQuerySink ;
	Internal_IWbemEventProviderSecurity *m_Provider_Internal_IWbemEventProviderSecurity ;
	Internal_IWbemEventConsumerProvider *m_Provider_Internal_IWbemEventConsumerProvider ;
	Internal_IWbemEventConsumerProviderEx *m_Provider_Internal_IWbemEventConsumerProviderEx ;
	Internal_IWbemUnboundObjectSink *m_Provider_Internal_IWbemUnboundObjectSink ;
	Internal_IWmiProviderConfiguration *m_Provider_Internal_IWmiProviderConfiguration ;

	ProxyContainer m_ProxyContainer ;

	DWORD m_ProcessIdentifier ;

	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Namespace ;

	LONG m_Initialized ;
	LONG m_UnInitialized ;
	HRESULT m_InitializeResult ;
	HANDLE m_InitializedEvent ;
	IWbemContext *m_InitializationContext ;

	LONG m_Resumed ;

	class InternalInterface : public _IWmiProviderQuota
	{
	private:

		CInterceptor_IWbemProvider *m_This ;

	public:

		InternalInterface ( CInterceptor_IWbemProvider *a_This ) : m_This ( a_This ) 
		{
		}

		STDMETHODIMP QueryInterface ( 

			REFIID iid , 
			LPVOID FAR *iplpv 
		)
		{
			return m_This->QueryInterface (

				iid , 
				iplpv 
			) ; 
		}

		STDMETHODIMP_( ULONG ) AddRef ()
		{
			return m_This->ServiceCacheElement :: NonCyclicAddRef () ; 
		}

		STDMETHODIMP_( ULONG ) Release ()
		{
			return m_This->ServiceCacheElement :: NonCyclicRelease () ;
		}

		HRESULT STDMETHODCALLTYPE Violation (

			long a_Flags ,
			IWbemContext *a_Context ,
			IWbemClassObject *a_Object	
		)
		{
			return m_This->Violation (

				a_Flags ,
				a_Context ,
				a_Object	
			) ;
		}
	} ;

	InternalInterface m_Internal ;

	void CallBackInternalRelease () ;

	HRESULT Begin_Interface_Context (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_Interface_Context (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Begin_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

public:

	CInterceptor_IWbemProvider ( 

		WmiAllocator &a_Allocator ,
		CWbemGlobal_IWmiProviderController *a_Controller , 
		const ProviderCacheKey &a_Key ,
		const ULONG &a_Period ,
		IWbemContext *a_InitializationContext ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

    ~CInterceptor_IWbemProvider () ;

	InternalQuotaInterface *GetQuota ()
	{
		return m_Quota ;
	}

	void SetResumed ( LONG a_Resumed )
	{
		if ( a_Resumed )
		{
			InterlockedExchange ( & m_Resumed , 1 ) ;
		}
		else
		{
			InterlockedExchange ( & m_Resumed , 0 ) ;
		}
	}

	LONG GetResumed ()
	{
		return m_Resumed ;
	}

	HRESULT SetProvider ( _IWmiProviderHost *a_Host , IUnknown *a_Unknown ) ;

	HRESULT SetInitialized ( HRESULT a_InitializeResult ) ;

	HRESULT IsIndependant ( IWbemContext *a_Context ) ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **a_Object ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE GetProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE PutProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	/* IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	/* IWbemHiPerfProvider */

	HRESULT STDMETHODCALLTYPE QueryInstances (

		IWbemServices *a_Namespace ,
		WCHAR *a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE CreateRefresher (

		IWbemServices *a_Namespace ,
		long a_Flags ,
		IWbemRefresher **a_Refresher
	) ; 

	HRESULT STDMETHODCALLTYPE CreateRefreshableObject (

		IWbemServices *a_Namespace ,
		IWbemObjectAccess *a_Template ,
		IWbemRefresher *a_Refresher ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectAccess **a_Refreshable ,
		long *a_Id
	) ;

	HRESULT STDMETHODCALLTYPE StopRefreshing (

		IWbemRefresher *a_Refresher ,
		long a_Id ,
		long a_Flags
	) ;

	HRESULT STDMETHODCALLTYPE CreateRefreshableEnum (

		IWbemServices *a_Namespace ,
		LPCWSTR a_Class ,
		IWbemRefresher *a_Refresher ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemHiPerfEnum *a_HiPerfEnum ,
		long *a_Id
	) ;

	HRESULT STDMETHODCALLTYPE GetObjects (

		IWbemServices *a_Namespace ,
		long a_ObjectCount ,
		IWbemObjectAccess **a_Objects ,
		long a_Flags ,
		IWbemContext *a_Context
	) ;

	HRESULT STDMETHODCALLTYPE Call (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,		
		const BSTR a_Method,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	/* _IWmiProviderConfiguration methods */

	HRESULT STDMETHODCALLTYPE Get (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Set (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_OldObject ,
		IWbemClassObject *a_NewObject  
	) ;

	HRESULT STDMETHODCALLTYPE Deleted (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_Object  
	) ;

	HRESULT STDMETHODCALLTYPE Enumerate (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		ULONG a_MilliSeconds
	) ;

	HRESULT STDMETHODCALLTYPE Call (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,		
		LPCWSTR a_Method,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Query (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
		WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
		VARIANT *a_Value 
	) ;

	HRESULT STDMETHODCALLTYPE Unload (

		long a_Flags ,
		IWbemContext *a_Context
	) ;

	HRESULT STDMETHODCALLTYPE Load (

		long a_Flags ,
		IWbemContext *a_Context
	) ;

	HRESULT STDMETHODCALLTYPE ForceReload () ;

	/* _IWmiProviderQuota */

	HRESULT STDMETHODCALLTYPE Violation (

		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_Object	
	) ;

	/* _IWmiProviderCache */

	HRESULT STDMETHODCALLTYPE Expel (

		long a_Flags ,
		IWbemContext *a_Context
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Initialize (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Namespace ,
		IWbemServices *a_Repository ,
		IWbemServices *a_Service ,
		IWbemProviderInitSink *a_Sink
	)
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout ) ;

	HRESULT STDMETHODCALLTYPE GetInitializeResult () 
	{
		return m_InitializeResult ;
	}

	HRESULT STDMETHODCALLTYPE GetHosting ( ULONG *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = m_Registration->GetHosting () ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE GetHostingGroup ( BSTR *a_Value )
	{
		if ( a_Value )
		{
			if ( m_Registration->GetHostingGroup () )
			{
				BSTR t_Value = SysAllocString ( m_Registration->GetHostingGroup () ) ;
				*a_Value = t_Value ;
			}
			else
			{
				*a_Value = NULL ;
			}

			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE IsInternal ( BOOL *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = FALSE ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE IsPerUserInitialization ( BOOL *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = m_Registration->PerUserInitialization () ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE IsPerLocaleInitialization ( BOOL *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = m_Registration->PerLocaleInitialization () ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	// _IWmiProviderStack 

	HRESULT STDMETHODCALLTYPE DownLevel (

		long a_Flags ,
		IWbemContext *a_Context ,
		REFIID a_Riid,
		void **a_Interface
	) ;

	HRESULT STDMETHODCALLTYPE AbnormalShutdown () ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncUnboundObjectSink : public IWbemUnboundObjectSink ,
												public Internal_IWbemUnboundObjectSink ,
												public _IWmiProviderSite ,
												public IWbemShutdown , 
												public VoidPointerContainerElement
{
private:

	WmiAllocator &m_Allocator ;
	CServerObject_ProviderRegistrationV1 *m_Registration ;

	IUnknown *m_Unknown ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;

	ProxyContainer m_ProxyContainer ;

protected:

	HRESULT Begin_Interface_Consumer (

		bool a_Identify ,
		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_Interface_Consumer (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT InternalEx_IndicateToConsumer (

		bool a_Identify ,
		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

public:

	CInterceptor_IWbemSyncUnboundObjectSink (

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideProvider , 
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	~CInterceptor_IWbemSyncUnboundObjectSink () ;

	HRESULT Initialize () ;

public:

	STDMETHODIMP QueryInterface ( 

		REFIID iid , 
		LPVOID FAR *iplpv 
	) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE Internal_IndicateToConsumer (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	/* _IWmiProviderSite */

	HRESULT STDMETHODCALLTYPE GetSite ( DWORD *a_ProcessIdentifier ) ;

	HRESULT STDMETHODCALLTYPE SetContainer ( IUnknown *a_Container ) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncProvider :	public IWbemServices , 
										public IWbemPropertyProvider ,
										public IWbemEventProvider ,
										public IWbemEventProviderQuerySink ,
										public IWbemEventProviderSecurity ,
										public IWbemProviderIdentity ,
										public IWbemEventConsumerProviderEx ,
										public IWbemUnboundObjectSink ,
										public IWbemHiPerfProvider ,

										public Internal_IWbemServices , 
										public Internal_IWbemPropertyProvider ,
										public Internal_IWbemEventProvider ,
										public Internal_IWbemEventProviderQuerySink ,
										public Internal_IWbemEventProviderSecurity ,
										public Internal_IWbemEventConsumerProviderEx ,
										public Internal_IWbemUnboundObjectSink ,


										public _IWmiProviderInitialize , 
										public IWbemShutdown , 
										public _IWmiProviderQuota ,
										public _IWmiProviderSite ,

										public _IWmiProviderConfiguration ,
										public Internal_IWmiProviderConfiguration ,

										public SyncProviderContainerElement ,
										public CWbemGlobal_IWmiObjectSinkController 
{
private:

	IUnknown *m_Unknown ;
	IWbemServices *m_Provider_IWbemServices ;
	IWbemPropertyProvider *m_Provider_IWbemPropertyProvider ;
	IWbemHiPerfProvider *m_Provider_IWbemHiPerfProvider ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;
	IWbemProviderIdentity *m_Provider_IWbemProviderIdentity ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemEventConsumerProviderEx *m_Provider_IWbemEventConsumerProviderEx ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;
	_IWmiProviderQuota *m_Quota ;

	IWbemServices *m_CoreStub ;

	IWbemClassObject *m_ExtendedStatusObject ;

	WmiAllocator &m_Allocator ;

	ProxyContainer m_ProxyContainer ;

	LONG m_Initialized ;
	HRESULT m_InitializeResult ;
	HANDLE m_InitializedEvent ;
	IWbemContext *m_InitializationContext ;

public:

	HRESULT SetInitialized ( HRESULT a_InitializeResult ) ;

public:

	CServerObject_ProviderRegistrationV1 *m_Registration ;
	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Namespace ;
	BSTR m_TransactionIdentifier ;

	UINT64 m_ProviderOperation_GetObjectAsync ;
	UINT64 m_ProviderOperation_PutClassAsync ;
	UINT64 m_ProviderOperation_DeleteClassAsync ;
	UINT64 m_ProviderOperation_CreateClassEnumAsync ;
	UINT64 m_ProviderOperation_PutInstanceAsync ;
	UINT64 m_ProviderOperation_DeleteInstanceAsync ;
	UINT64 m_ProviderOperation_CreateInstanceEnumAsync ;
	UINT64 m_ProviderOperation_ExecQueryAsync ;
	UINT64 m_ProviderOperation_ExecNotificationQueryAsync ;
	UINT64 m_ProviderOperation_ExecMethodAsync ;

	UINT64 m_ProviderOperation_Begin ;
	UINT64 m_ProviderOperation_Rollback ;
	UINT64 m_ProviderOperation_Commit ;
	UINT64 m_ProviderOperation_QueryState ;

	UINT64 m_ProviderOperation_QueryInstances ;
	UINT64 m_ProviderOperation_CreateRefresher ;
	UINT64 m_ProviderOperation_CreateRefreshableObject ;
	UINT64 m_ProviderOperation_StopRefreshing ;
	UINT64 m_ProviderOperation_CreateRefreshableEnum ;
	UINT64 m_ProviderOperation_GetObjects ;

	UINT64 m_ProviderOperation_GetProperty ;
	UINT64 m_ProviderOperation_PutProperty ;

	UINT64 m_ProviderOperation_ProvideEvents ;
	UINT64 m_ProviderOperation_NewQuery ;
	UINT64 m_ProviderOperation_CancelQuery ;
	UINT64 m_ProviderOperation_AccessCheck ;
	UINT64 m_ProviderOperation_SetRegistrationObject ;
	UINT64 m_ProviderOperation_FindConsumer ;
	UINT64 m_ProviderOperation_ValidateSubscription ;

	void Increment_ProviderOperation_GetObjectAsync () { m_ProviderOperation_GetObjectAsync ++ ; }
 	void Increment_ProviderOperation_PutClassAsync () { m_ProviderOperation_PutClassAsync ++ ; }
	void Increment_ProviderOperation_DeleteClassAsync () { m_ProviderOperation_DeleteClassAsync ++ ; }
	void Increment_ProviderOperation_CreateClassEnumAsync () { m_ProviderOperation_CreateClassEnumAsync ++ ; }
	void Increment_ProviderOperation_PutInstanceAsync () { m_ProviderOperation_PutInstanceAsync ++ ; }
	void Increment_ProviderOperation_DeleteInstanceAsync () { m_ProviderOperation_DeleteInstanceAsync ++ ; }
	void Increment_ProviderOperation_CreateInstanceEnumAsync () { m_ProviderOperation_CreateInstanceEnumAsync ++ ; }
	void Increment_ProviderOperation_ExecQueryAsync () { m_ProviderOperation_ExecQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecNotificationQueryAsync () { m_ProviderOperation_ExecNotificationQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecMethodAsync () { m_ProviderOperation_ExecMethodAsync ++ ; }

	void Increment_ProviderOperation_Begin () { m_ProviderOperation_Begin ++ ; }
	void Increment_ProviderOperation_Rollback () { m_ProviderOperation_Rollback ++ ; }
	void Increment_ProviderOperation_Commit () { m_ProviderOperation_Commit ++ ; }
	void Increment_ProviderOperation_QueryState () { m_ProviderOperation_QueryState ++ ; }

	void Increment_ProviderOperation_QueryInstances () { m_ProviderOperation_QueryInstances ++ ; }
	void Increment_ProviderOperation_CreateRefresher () { m_ProviderOperation_CreateRefresher ++ ; }
	void Increment_ProviderOperation_CreateRefreshableObject () { m_ProviderOperation_CreateRefreshableObject ++ ; }
	void Increment_ProviderOperation_StopRefreshing () { m_ProviderOperation_StopRefreshing ++ ; }
	void Increment_ProviderOperation_CreateRefreshableEnum () { m_ProviderOperation_CreateRefreshableEnum ++ ; }
	void Increment_ProviderOperation_GetObjects () { m_ProviderOperation_GetObjects ++ ; }

	void Increment_ProviderOperation_GetProperty () { m_ProviderOperation_GetProperty ++ ; }
	void Increment_ProviderOperation_PutProperty () { m_ProviderOperation_PutProperty ++ ; }

	void Increment_ProviderOperation_ProvideEvents () { m_ProviderOperation_ProvideEvents ++ ; }
	void Increment_ProviderOperation_NewQuery () { m_ProviderOperation_NewQuery ++ ; }
	void Increment_ProviderOperation_CancelQuery () { m_ProviderOperation_CancelQuery ++ ; }
	void Increment_ProviderOperation_AccessCheck () { m_ProviderOperation_AccessCheck ++ ; }
	void Increment_ProviderOperation_SetRegistrationObject () { m_ProviderOperation_SetRegistrationObject ++ ; }
	void Increment_ProviderOperation_FindConsumer () { m_ProviderOperation_FindConsumer ++ ; }
	void Increment_ProviderOperation_ValidateSubscription () { m_ProviderOperation_ValidateSubscription ++ ; }

	UINT64 Get_ProviderOperation_GetObjectAsync () { return m_ProviderOperation_GetObjectAsync ; }
	UINT64 Get_ProviderOperation_PutClassAsync () { return m_ProviderOperation_PutClassAsync ; }
	UINT64 Get_ProviderOperation_DeleteClassAsync () { return m_ProviderOperation_DeleteClassAsync ; }
	UINT64 Get_ProviderOperation_CreateClassEnumAsync () { return m_ProviderOperation_CreateClassEnumAsync ; }
	UINT64 Get_ProviderOperation_PutInstanceAsync () { return m_ProviderOperation_PutInstanceAsync ; }
	UINT64 Get_ProviderOperation_DeleteInstanceAsync () { return m_ProviderOperation_DeleteInstanceAsync ; }
	UINT64 Get_ProviderOperation_CreateInstanceEnumAsync () { return m_ProviderOperation_CreateInstanceEnumAsync ; }
	UINT64 Get_ProviderOperation_ExecQueryAsync () { return m_ProviderOperation_ExecQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecNotificationQueryAsync () { return m_ProviderOperation_ExecNotificationQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecMethodAsync () { return m_ProviderOperation_ExecMethodAsync ; }

	UINT64 Get_ProviderOperation_Begin () { return m_ProviderOperation_Begin ; }
	UINT64 Get_ProviderOperation_Rollback () { return m_ProviderOperation_Rollback ; }
	UINT64 Get_ProviderOperation_Commit () { return m_ProviderOperation_Commit ; }
	UINT64 Get_ProviderOperation_QueryState () { return m_ProviderOperation_QueryState ; }

	UINT64 Get_ProviderOperation_QueryInstances () { return m_ProviderOperation_QueryInstances ; }
	UINT64 Get_ProviderOperation_CreateRefresher () { return m_ProviderOperation_CreateRefresher ; }
	UINT64 Get_ProviderOperation_CreateRefreshableObject () { return m_ProviderOperation_CreateRefreshableObject ; }
	UINT64 Get_ProviderOperation_StopRefreshing () { return m_ProviderOperation_StopRefreshing ; }
	UINT64 Get_ProviderOperation_CreateRefreshableEnum () { return m_ProviderOperation_CreateRefreshableEnum ; }
	UINT64 Get_ProviderOperation_GetObjects () { return m_ProviderOperation_GetObjects ; }

	UINT64 Get_ProviderOperation_GetProperty () { return m_ProviderOperation_GetProperty ; }
	UINT64 Get_ProviderOperation_PutProperty () { return m_ProviderOperation_PutProperty ; }

	UINT64 Get_ProviderOperation_ProvideEvents () { return m_ProviderOperation_ProvideEvents ; }
	UINT64 Get_ProviderOperation_NewQuery () { return m_ProviderOperation_NewQuery ; }
	UINT64 Get_ProviderOperation_CancelQuery () { return m_ProviderOperation_CancelQuery ; }
	UINT64 Get_ProviderOperation_AccessCheck () { return m_ProviderOperation_AccessCheck ; }
	UINT64 Get_ProviderOperation_SetRegistrationObject () { return m_ProviderOperation_SetRegistrationObject ; }
	UINT64 Get_ProviderOperation_FindConsumer () { return m_ProviderOperation_FindConsumer ; }
	UINT64 Get_ProviderOperation_ValidateSubscription () { return m_ProviderOperation_ValidateSubscription ; }

private:

	HRESULT SetStatus ( 

		LPWSTR a_Operation ,
		LPWSTR a_Parameters ,
		LPWSTR a_Description ,
		HRESULT a_Result ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT Begin_IWbemServices (

		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IWbemServices *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_IWbemServices (

		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IWbemServices *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Begin_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Begin_Interface_Consumer (

		bool a_Identify ,
		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_Interface_Consumer (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Begin_Interface_Events (

		bool a_Identify ,
		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_Interface_Events (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT AdjustGetContext (

		IWbemContext *a_Context
	) ;

	HRESULT Helper_HiPerfGetObjectAsync (

		IWbemHiPerfProvider *a_HighPerformanceProvider ,
 		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT Helper_GetObjectAsync (

		BOOL a_IsProxy ,
 		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_PutClassAsync (

		BOOL a_IsProxy ,
		IWbemClassObject *a_Object , 
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_DeleteClassAsync (

		BOOL a_IsProxy ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_CreateClassEnumAsync (

		BOOL a_IsProxy ,
		const BSTR a_SuperClass ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_PutInstanceAsync (

		BOOL a_IsProxy ,
		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_DeleteInstanceAsync (

		BOOL a_IsProxy ,
		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

    HRESULT Helper_CreateInstanceEnumAsync (

		BOOL a_IsProxy ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service
	) ;

	HRESULT Helper_QueryInstancesAsync (

		IWbemHiPerfProvider *a_PerformanceProvider ,
 		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;

	HRESULT Helper_ExecQueryAsync (

		BOOL a_IsProxy ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query, 
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_ExecMethodAsync (

		BOOL a_IsProxy ,
		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT STDMETHODCALLTYPE InternalEx_ProvideEvents (

		bool a_Identify ,
		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	HRESULT STDMETHODCALLTYPE InternalEx_NewQuery (

		bool a_Identify ,
		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE InternalEx_CancelQuery (

		bool a_Identify ,
		unsigned long a_Id
	) ;

	HRESULT STDMETHODCALLTYPE InternalEx_AccessCheck (

		bool a_Identify ,
		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	HRESULT STDMETHODCALLTYPE InternalEx_FindConsumer (

		bool a_Identify ,
		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	HRESULT STDMETHODCALLTYPE InternalEx_ValidateSubscription (

		bool a_Identify ,
		IWbemClassObject *a_LogicalConsumer
	) ;

	HRESULT STDMETHODCALLTYPE InternalEx_IndicateToConsumer (

		bool a_Identify ,
		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

public:

	CInterceptor_IWbemSyncProvider ( 

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideUnknown , 
		IWbemServices *a_CoreStub ,
		CWbemGlobal_IWbemSyncProviderController *a_Controller ,
		IWbemContext *a_InitializationContext ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		GUID &a_Guid 
	) ;

    ~CInterceptor_IWbemSyncProvider () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE GetProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE PutProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderIdentity */

	HRESULT STDMETHODCALLTYPE SetRegistrationObject (

		long a_Flags ,
		IWbemClassObject *a_ProviderRegistration
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	/* IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	/* IWbemHiPerfProvider */

	HRESULT STDMETHODCALLTYPE QueryInstances (

		IWbemServices *a_Namespace ,
		WCHAR *a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE CreateRefresher (

		IWbemServices *a_Namespace ,
		long a_Flags ,
		IWbemRefresher **a_Refresher
	) ; 

	HRESULT STDMETHODCALLTYPE CreateRefreshableObject (

		IWbemServices *a_Namespace ,
		IWbemObjectAccess *a_Template ,
		IWbemRefresher *a_Refresher ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectAccess **a_Refreshable ,
		long *a_Id
	) ;

	HRESULT STDMETHODCALLTYPE StopRefreshing (

		IWbemRefresher *a_Refresher ,
		long a_Id ,
		long a_Flags
	) ;

	HRESULT STDMETHODCALLTYPE CreateRefreshableEnum (

		IWbemServices *a_Namespace ,
		LPCWSTR a_Class ,
		IWbemRefresher *a_Refresher ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemHiPerfEnum *a_HiPerfEnum ,
		long *a_Id
	) ;

	HRESULT STDMETHODCALLTYPE GetObjects (

		IWbemServices *a_Namespace ,
		long a_ObjectCount ,
		IWbemObjectAccess **a_Objects ,
		long a_Flags ,
		IWbemContext *a_Context
	) ;

/* Internal_IWbemServices */
 
     HRESULT STDMETHODCALLTYPE Internal_OpenNamespace ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CancelAsyncCall ( 

		WmiInternalContext a_InternalContext ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_QueryObjectSink ( 

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_GetObject ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_GetObjectAsync (
        
		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE Internal_PutClass ( 

		WmiInternalContext a_InternalContext ,
        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutClassAsync ( 

		WmiInternalContext a_InternalContext ,
        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteClass ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteClassAsync ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateClassEnum ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateClassEnumAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutInstance (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutInstanceAsync (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteInstance ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteInstanceAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateInstanceEnum (

		WmiInternalContext a_InternalContext ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateInstanceEnumAsync (

		WmiInternalContext a_InternalContext ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecQuery ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecQueryAsync (

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecNotificationQuery (

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecNotificationQueryAsync ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecMethod (

		WmiInternalContext a_InternalContext ,
        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecMethodAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* Internal_IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE Internal_GetProperty (

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE Internal_PutProperty (

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* Internal_IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE Internal_ProvideEvents (

		WmiInternalContext a_InternalContext ,
		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* Internal_IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE Internal_NewQuery (

		WmiInternalContext a_InternalContext ,
		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE Internal_CancelQuery (

		WmiInternalContext a_InternalContext ,
		unsigned long a_Id
	) ;

	/* Internal_IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE Internal_AccessCheck (

		WmiInternalContext a_InternalContext ,
		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* Internal_IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE Internal_FindConsumer (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* Internal_IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE Internal_ValidateSubscription (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer
	) ;

	/* Internal_IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE Internal_IndicateToConsumer (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	/* _IWmiProviderConfiguration methods */

	HRESULT STDMETHODCALLTYPE Get (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Set (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_OldObject ,
		IWbemClassObject *a_NewObject  
	) ;

	HRESULT STDMETHODCALLTYPE Deleted (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_Object  
	) ;

	HRESULT STDMETHODCALLTYPE Enumerate (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		ULONG a_MilliSeconds
	) ;

	HRESULT STDMETHODCALLTYPE Call (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,		
		LPCWSTR a_Method,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Query (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
		WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
		VARIANT *a_Value 
	) ;

	HRESULT STDMETHODCALLTYPE ForceReload () ;

	/* Internal_IWmiProviderConfiguration methods */

	HRESULT STDMETHODCALLTYPE Internal_Get (

		WmiInternalContext a_InternalContext ,
		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Internal_Set (

		WmiInternalContext a_InternalContext ,
		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_OldObject ,
		IWbemClassObject *a_NewObject  
	) ;

	HRESULT STDMETHODCALLTYPE Internal_Deleted (

		WmiInternalContext a_InternalContext ,
		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_Object  
	) ;

	HRESULT STDMETHODCALLTYPE Internal_Enumerate (

		WmiInternalContext a_InternalContext ,
		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Internal_Shutdown (

		WmiInternalContext a_InternalContext ,
		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		ULONG a_MilliSeconds
	) ;

	HRESULT STDMETHODCALLTYPE Internal_Call (

		WmiInternalContext a_InternalContext ,
		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,		
		LPCWSTR a_Method,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Internal_Query (

		WmiInternalContext a_InternalContext ,
		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
		WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
		VARIANT *a_Value 
	) ;


	/* _IWmiProviderQuota */

	HRESULT STDMETHODCALLTYPE Violation (

		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_Object	
	) ;

	/* _IWmiProviderSite */

	HRESULT STDMETHODCALLTYPE GetSite ( DWORD *a_ProcessIdentifier ) ;

	HRESULT STDMETHODCALLTYPE SetContainer ( IUnknown *a_Container ) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Namespace ,
		IWbemServices *a_Repository ,
		IWbemServices *a_Service ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout ) ;

	HRESULT STDMETHODCALLTYPE GetInitializeResult () 
	{
		return m_InitializeResult ;
	}

	HRESULT STDMETHODCALLTYPE GetHosting ( ULONG *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE GetHostingGroup ( BSTR *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsInternal ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsPerUserInitialization ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsPerLocaleInitialization ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemDecoupledProvider :	public IWbemServices , 
											public IWbemPropertyProvider ,
											public IWbemEventProvider ,
											public IWbemEventProviderQuerySink ,
											public IWbemEventProviderSecurity ,
											public IWbemProviderInit ,
											public IWbemProviderIdentity ,
											public IWbemEventConsumerProviderEx ,
											public IWbemUnboundObjectSink ,

											public IWbemShutdown , 
											public _IWmiProviderInitialize ,
											public _IWmiProviderAbnormalShutdown ,
											public SyncProviderContainerElement ,
											public CWbemGlobal_IWmiObjectSinkController 
{
private:

	IUnknown *m_Unknown ;
	IWbemServices *m_Provider_IWbemServices ;
	IWbemPropertyProvider *m_Provider_IWbemPropertyProvider ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemEventConsumerProviderEx *m_Provider_IWbemEventConsumerProviderEx ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;
	IWbemProviderInit *m_Provider_IWbemProviderInit ;
	IWbemProviderIdentity *m_Provider_IWbemProviderIdentity ;

	Internal_IWbemServices *m_Provider_Internal_IWbemServices ;
	Internal_IWbemPropertyProvider *m_Provider_Internal_IWbemPropertyProvider ;
	Internal_IWbemEventProvider *m_Provider_Internal_IWbemEventProvider ;
	Internal_IWbemEventProviderQuerySink *m_Provider_Internal_IWbemEventProviderQuerySink ;
	Internal_IWbemEventProviderSecurity *m_Provider_Internal_IWbemEventProviderSecurity ;
	Internal_IWbemEventConsumerProvider *m_Provider_Internal_IWbemEventConsumerProvider ;
	Internal_IWbemEventConsumerProviderEx *m_Provider_Internal_IWbemEventConsumerProviderEx ;
	Internal_IWbemUnboundObjectSink *m_Provider_Internal_IWbemUnboundObjectSink ;
	Internal_IWmiProviderConfiguration *m_Provider_Internal_IWmiProviderConfiguration ;
	Internal_IWbemProviderInit *m_Provider_Internal_IWbemProviderInit ;
	Internal_IWbemProviderIdentity *m_Provider_Internal_IWbemProviderIdentity ;

	IWbemServices *m_CoreStub ;

	IWbemClassObject *m_ExtendedStatusObject ;

	WmiAllocator &m_Allocator ;

	ProxyContainer m_ProxyContainer ;

	LONG m_Initialized ;
	HRESULT m_InitializeResult ;
	HANDLE m_InitializedEvent ;
	IWbemContext *m_InitializationContext ;
	SECURITY_DESCRIPTOR * m_expandedSD;

	DWORD m_ProcessIdentifier ;

	HRESULT Begin_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;
	SECURITY_DESCRIPTOR* GetSD(){ if (m_expandedSD) return m_expandedSD; else return m_Registration->GetComRegistration ().GetSecurityDescriptor ();}
	HRESULT AddProcessToSD (DWORD pid, SECURITY_DESCRIPTOR*& sourceSD, SECURITY_DESCRIPTOR* destSD );
public:

	HRESULT SetInitialized ( HRESULT a_InitializeResult ) ;

public:

	CServerObject_ProviderRegistrationV1 *m_Registration ;
	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Namespace ;
	BSTR m_TransactionIdentifier ;

	UINT64 m_ProviderOperation_GetObjectAsync ;
	UINT64 m_ProviderOperation_PutClassAsync ;
	UINT64 m_ProviderOperation_DeleteClassAsync ;
	UINT64 m_ProviderOperation_CreateClassEnumAsync ;
	UINT64 m_ProviderOperation_PutInstanceAsync ;
	UINT64 m_ProviderOperation_DeleteInstanceAsync ;
	UINT64 m_ProviderOperation_CreateInstanceEnumAsync ;
	UINT64 m_ProviderOperation_ExecQueryAsync ;
	UINT64 m_ProviderOperation_ExecNotificationQueryAsync ;
	UINT64 m_ProviderOperation_ExecMethodAsync ;

	UINT64 m_ProviderOperation_Begin ;
	UINT64 m_ProviderOperation_Rollback ;
	UINT64 m_ProviderOperation_Commit ;
	UINT64 m_ProviderOperation_QueryState ;

	UINT64 m_ProviderOperation_QueryInstances ;
	UINT64 m_ProviderOperation_CreateRefresher ;
	UINT64 m_ProviderOperation_CreateRefreshableObject ;
	UINT64 m_ProviderOperation_StopRefreshing ;
	UINT64 m_ProviderOperation_CreateRefreshableEnum ;
	UINT64 m_ProviderOperation_GetObjects ;

	UINT64 m_ProviderOperation_GetProperty ;
	UINT64 m_ProviderOperation_PutProperty ;

	UINT64 m_ProviderOperation_ProvideEvents ;
	UINT64 m_ProviderOperation_NewQuery ;
	UINT64 m_ProviderOperation_CancelQuery ;
	UINT64 m_ProviderOperation_AccessCheck ;
	UINT64 m_ProviderOperation_SetRegistrationObject ;
	UINT64 m_ProviderOperation_FindConsumer ;
	UINT64 m_ProviderOperation_ValidateSubscription ;

	void Increment_ProviderOperation_GetObjectAsync () { m_ProviderOperation_GetObjectAsync ++ ; }
 	void Increment_ProviderOperation_PutClassAsync () { m_ProviderOperation_PutClassAsync ++ ; }
	void Increment_ProviderOperation_DeleteClassAsync () { m_ProviderOperation_DeleteClassAsync ++ ; }
	void Increment_ProviderOperation_CreateClassEnumAsync () { m_ProviderOperation_CreateClassEnumAsync ++ ; }
	void Increment_ProviderOperation_PutInstanceAsync () { m_ProviderOperation_PutInstanceAsync ++ ; }
	void Increment_ProviderOperation_DeleteInstanceAsync () { m_ProviderOperation_DeleteInstanceAsync ++ ; }
	void Increment_ProviderOperation_CreateInstanceEnumAsync () { m_ProviderOperation_CreateInstanceEnumAsync ++ ; }
	void Increment_ProviderOperation_ExecQueryAsync () { m_ProviderOperation_ExecQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecNotificationQueryAsync () { m_ProviderOperation_ExecNotificationQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecMethodAsync () { m_ProviderOperation_ExecMethodAsync ++ ; }

	void Increment_ProviderOperation_Begin () { m_ProviderOperation_Begin ++ ; }
	void Increment_ProviderOperation_Rollback () { m_ProviderOperation_Rollback ++ ; }
	void Increment_ProviderOperation_Commit () { m_ProviderOperation_Commit ++ ; }
	void Increment_ProviderOperation_QueryState () { m_ProviderOperation_QueryState ++ ; }

	void Increment_ProviderOperation_QueryInstances () { m_ProviderOperation_QueryInstances ++ ; }
	void Increment_ProviderOperation_CreateRefresher () { m_ProviderOperation_CreateRefresher ++ ; }
	void Increment_ProviderOperation_CreateRefreshableObject () { m_ProviderOperation_CreateRefreshableObject ++ ; }
	void Increment_ProviderOperation_StopRefreshing () { m_ProviderOperation_StopRefreshing ++ ; }
	void Increment_ProviderOperation_CreateRefreshableEnum () { m_ProviderOperation_CreateRefreshableEnum ++ ; }
	void Increment_ProviderOperation_GetObjects () { m_ProviderOperation_GetObjects ++ ; }

	void Increment_ProviderOperation_GetProperty () { m_ProviderOperation_GetProperty ++ ; }
	void Increment_ProviderOperation_PutProperty () { m_ProviderOperation_PutProperty ++ ; }

	void Increment_ProviderOperation_ProvideEvents () { m_ProviderOperation_ProvideEvents ++ ; }
	void Increment_ProviderOperation_NewQuery () { m_ProviderOperation_NewQuery ++ ; }
	void Increment_ProviderOperation_CancelQuery () { m_ProviderOperation_CancelQuery ++ ; }
	void Increment_ProviderOperation_AccessCheck () { m_ProviderOperation_AccessCheck ++ ; }
	void Increment_ProviderOperation_SetRegistrationObject () { m_ProviderOperation_SetRegistrationObject ++ ; }
	void Increment_ProviderOperation_FindConsumer () { m_ProviderOperation_FindConsumer ++ ; }
	void Increment_ProviderOperation_ValidateSubscription () { m_ProviderOperation_ValidateSubscription ++ ; }

	UINT64 Get_ProviderOperation_GetObjectAsync () { return m_ProviderOperation_GetObjectAsync ; }
	UINT64 Get_ProviderOperation_PutClassAsync () { return m_ProviderOperation_PutClassAsync ; }
	UINT64 Get_ProviderOperation_DeleteClassAsync () { return m_ProviderOperation_DeleteClassAsync ; }
	UINT64 Get_ProviderOperation_CreateClassEnumAsync () { return m_ProviderOperation_CreateClassEnumAsync ; }
	UINT64 Get_ProviderOperation_PutInstanceAsync () { return m_ProviderOperation_PutInstanceAsync ; }
	UINT64 Get_ProviderOperation_DeleteInstanceAsync () { return m_ProviderOperation_DeleteInstanceAsync ; }
	UINT64 Get_ProviderOperation_CreateInstanceEnumAsync () { return m_ProviderOperation_CreateInstanceEnumAsync ; }
	UINT64 Get_ProviderOperation_ExecQueryAsync () { return m_ProviderOperation_ExecQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecNotificationQueryAsync () { return m_ProviderOperation_ExecNotificationQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecMethodAsync () { return m_ProviderOperation_ExecMethodAsync ; }

	UINT64 Get_ProviderOperation_Begin () { return m_ProviderOperation_Begin ; }
	UINT64 Get_ProviderOperation_Rollback () { return m_ProviderOperation_Rollback ; }
	UINT64 Get_ProviderOperation_Commit () { return m_ProviderOperation_Commit ; }
	UINT64 Get_ProviderOperation_QueryState () { return m_ProviderOperation_QueryState ; }

	UINT64 Get_ProviderOperation_QueryInstances () { return m_ProviderOperation_QueryInstances ; }
	UINT64 Get_ProviderOperation_CreateRefresher () { return m_ProviderOperation_CreateRefresher ; }
	UINT64 Get_ProviderOperation_CreateRefreshableObject () { return m_ProviderOperation_CreateRefreshableObject ; }
	UINT64 Get_ProviderOperation_StopRefreshing () { return m_ProviderOperation_StopRefreshing ; }
	UINT64 Get_ProviderOperation_CreateRefreshableEnum () { return m_ProviderOperation_CreateRefreshableEnum ; }
	UINT64 Get_ProviderOperation_GetObjects () { return m_ProviderOperation_GetObjects ; }

	UINT64 Get_ProviderOperation_GetProperty () { return m_ProviderOperation_GetProperty ; }
	UINT64 Get_ProviderOperation_PutProperty () { return m_ProviderOperation_PutProperty ; }

	UINT64 Get_ProviderOperation_ProvideEvents () { return m_ProviderOperation_ProvideEvents ; }
	UINT64 Get_ProviderOperation_NewQuery () { return m_ProviderOperation_NewQuery ; }
	UINT64 Get_ProviderOperation_CancelQuery () { return m_ProviderOperation_CancelQuery ; }
	UINT64 Get_ProviderOperation_AccessCheck () { return m_ProviderOperation_AccessCheck ; }
	UINT64 Get_ProviderOperation_SetRegistrationObject () { return m_ProviderOperation_SetRegistrationObject ; }
	UINT64 Get_ProviderOperation_FindConsumer () { return m_ProviderOperation_FindConsumer ; }
	UINT64 Get_ProviderOperation_ValidateSubscription () { return m_ProviderOperation_ValidateSubscription ; }

public:

	CInterceptor_IWbemDecoupledProvider ( 

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideUnknown , 
		IWbemServices *a_CoreStub ,
		CWbemGlobal_IWbemSyncProviderController *a_Controller ,
		IWbemContext *a_InitializationContext ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		GUID &a_Guid 
	) ;

    ~CInterceptor_IWbemDecoupledProvider () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE GetProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE PutProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderIdentity */

	HRESULT STDMETHODCALLTYPE SetRegistrationObject (

		long a_Flags ,
		IWbemClassObject *a_ProviderRegistration
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	/* IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_CoreService ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;
    
	HRESULT STDMETHODCALLTYPE Initialize (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Namespace ,
		IWbemServices *a_Repository ,
		IWbemServices *a_Service ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout ) ;

	HRESULT STDMETHODCALLTYPE GetInitializeResult () 
	{
		return m_InitializeResult ;
	}

	HRESULT STDMETHODCALLTYPE GetHosting ( ULONG *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE GetHostingGroup ( BSTR *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsInternal ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsPerUserInitialization ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsPerLocaleInitialization ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE AbnormalShutdown () ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

#endif // _Server_Interceptor_IWbemServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provwsvs.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _Server_Interceptor_IWbemServices_Stub_H
#define _Server_Interceptor_IWbemServices_Stub_H

#define ProxyIndex_Proxy_IWbemServices					0
#define ProxyIndex_Proxy_IWbemRefreshingServices		1
#define ProxyIndex_Proxy_Internal_IWbemServices			2
#define ProxyIndex_Proxy_Size							3

#define ProxyIndex_EnumProxy_IEnumWbemClassObject			0
#define ProxyIndex_EnumProxy_Internal_IEnumWbemClassObject	1
#define ProxyIndex_EnumProxy_Size							2

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemServices_Interceptor :	public IWbemServices , 
												public IWbemRefreshingServices ,
												public IWbemShutdown
{
private:

	LONG m_ReferenceCount ;         //Object reference count

	LONG m_GateClosed ;
	LONG m_InProgress ;

	CriticalSection m_CriticalSection ;

	WmiAllocator &m_Allocator ;

	IWbemServices *m_Core_IWbemServices ;
	IWbemRefreshingServices *m_Core_IWbemRefreshingServices ;

public:

	CInterceptor_IWbemServices_Interceptor ( 

		WmiAllocator &a_Allocator , 
		IWbemServices *a_Service
	) ;

    ~CInterceptor_IWbemServices_Interceptor () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE AddObjectToRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Path,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddObjectToRefresherByTemplate (

		WBEM_REFRESHER_ID *a_RefresherId ,
		IWbemClassObject *a_Template ,
		long a_Flags ,
		IWbemContext *a_Context ,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddEnumToRefresher(

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE RemoveObjectFromRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Id ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT STDMETHODCALLTYPE GetRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		IWbemRemoteRefresher **a_RemoteRefresher ,
		GUID *a_Guid ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE ReconnectRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId,
		long a_Flags,
		long a_NumberOfObjects,
		DWORD a_ClientRefresherVersion ,
		WBEM_RECONNECT_INFO *a_ReconnectInformation ,
		WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT ServiceInitialize () ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemServices_RestrictingInterceptor :	public IWbemServices , 
															public IWbemRefreshingServices ,
															public IWbemShutdown
{
private:

	LONG m_ReferenceCount ;         //Object reference count

	LONG m_GateClosed ;
	LONG m_InProgress ;

	CriticalSection m_CriticalSection ;

	WmiAllocator &m_Allocator ;

	IWbemServices *m_Core_IWbemServices ;
	IWbemRefreshingServices *m_Core_IWbemRefreshingServices ;

	CServerObject_ProviderRegistrationV1 &m_Registration ;

	ProxyContainer m_ProxyContainer ;

private:

	HRESULT Begin_IWbemServices (

		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IWbemServices *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_IWbemServices (

		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IWbemServices *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Begin_IWbemRefreshingServices (

		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IWbemRefreshingServices *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_IWbemRefreshingServices (

		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IWbemRefreshingServices *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

public:

	CInterceptor_IWbemServices_RestrictingInterceptor ( 

		WmiAllocator &a_Allocator , 
		IWbemServices *a_Service ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

    ~CInterceptor_IWbemServices_RestrictingInterceptor () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE AddObjectToRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Path,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddObjectToRefresherByTemplate (

		WBEM_REFRESHER_ID *a_RefresherId ,
		IWbemClassObject *a_Template ,
		long a_Flags ,
		IWbemContext *a_Context ,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddEnumToRefresher(

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE RemoveObjectFromRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Id ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT STDMETHODCALLTYPE GetRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		IWbemRemoteRefresher **a_RemoteRefresher ,
		GUID *a_Guid ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE ReconnectRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId,
		long a_Flags,
		long a_NumberOfObjects,
		DWORD a_ClientRefresherVersion ,
		WBEM_RECONNECT_INFO *a_ReconnectInformation ,
		WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT ServiceInitialize () ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

#ifdef INTERNAL_IDENTIFY

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IEnumWbemClassObject_Stub :	public IEnumWbemClassObject , 
												public IWbemShutdown ,
												public Internal_IEnumWbemClassObject ,
												public VoidPointerContainerElement ,
												public CWbemGlobal_VoidPointerController 
{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;
	WmiAllocator &m_Allocator ;

	IEnumWbemClassObject *m_InterceptedEnum ;

protected:
public:

	CInterceptor_IEnumWbemClassObject_Stub (

		CWbemGlobal_VoidPointerController *a_Controller ,
		WmiAllocator &a_Allocator ,
		IEnumWbemClassObject *a_InterceptedEnum
	) ;

	~CInterceptor_IEnumWbemClassObject_Stub () ;

	HRESULT EnumInitialize () ;

	HRESULT Enqueue_IEnumWbemClassObject (

		IEnumWbemClassObject *a_Enum ,
		IEnumWbemClassObject *&a_Proxy
	) ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Reset () ;

    HRESULT STDMETHODCALLTYPE Next (

		long a_Timeout ,
		ULONG a_Count ,
		IWbemClassObject **a_Objects ,
		ULONG *a_Returned
	) ;

    HRESULT STDMETHODCALLTYPE NextAsync (

		ULONG a_Count,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE Clone (

		IEnumWbemClassObject **a_Enum
	) ;

    HRESULT STDMETHODCALLTYPE Skip (

        long a_Timeout,
        ULONG a_Count
	) ;

    HRESULT STDMETHODCALLTYPE Internal_Reset (
	
		WmiInternalContext a_InternalContext
	) ;

    HRESULT STDMETHODCALLTYPE Internal_Next (

		WmiInternalContext a_InternalContext ,
		long a_Timeout ,
		ULONG a_Count ,
		IWbemClassObject **a_Objects ,
		ULONG *a_Returned
	) ;

    HRESULT STDMETHODCALLTYPE Internal_NextAsync (

		WmiInternalContext a_InternalContext ,
		ULONG a_Count,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE Internal_Clone (

		WmiInternalContext a_InternalContext ,
		IEnumWbemClassObject **a_Enum
	) ;

    HRESULT STDMETHODCALLTYPE Internal_Skip (

		WmiInternalContext a_InternalContext ,
        long a_Timeout,
        ULONG a_Count
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IEnumWbemClassObject_Proxy :	public IEnumWbemClassObject , 
												public VoidPointerContainerElement ,
												public CWbemGlobal_VoidPointerController

{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;

	WmiAllocator &m_Allocator ;

	IEnumWbemClassObject *m_InterceptedEnum ;
	Internal_IEnumWbemClassObject *m_Internal_InterceptedEnum ;

	ProxyContainer m_ProxyContainer ;
	
protected:

	HRESULT Begin_IEnumWbemClassObject (

		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_IEnumWbemClassObject (

		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Enqueue_IEnumWbemClassObject (

		IEnumWbemClassObject *a_Enum ,
		IEnumWbemClassObject *&a_Proxy
	) ;

public:

	CInterceptor_IEnumWbemClassObject_Proxy (

		CWbemGlobal_VoidPointerController *a_Controller ,
		WmiAllocator &a_Allocator ,
		IEnumWbemClassObject *a_InterceptedEnum
	) ;

	~CInterceptor_IEnumWbemClassObject_Proxy () ;

	virtual HRESULT EnumInitialize () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Reset () ;

    HRESULT STDMETHODCALLTYPE Next (

		long a_Timeout ,
		ULONG a_Count ,
		IWbemClassObject **a_Objects ,
		ULONG *a_Returned
	) ;

    HRESULT STDMETHODCALLTYPE NextAsync (

		ULONG a_Count,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE Clone (

		IEnumWbemClassObject **a_Enum
	) ;

    HRESULT STDMETHODCALLTYPE Skip (

        long a_Timeout,
        ULONG a_Count
	) ;

    HRESULT STDMETHODCALLTYPE Internal_Reset (
	
		WmiInternalContext a_InternalContext
	) ;

    HRESULT STDMETHODCALLTYPE Internal_Next (

		WmiInternalContext a_InternalContext ,
		long a_Timeout ,
		ULONG a_Count ,
		IWbemClassObject **a_Objects ,
		ULONG *a_Returned
	) ;

    HRESULT STDMETHODCALLTYPE Internal_NextAsync (

		WmiInternalContext a_InternalContext ,
		ULONG a_Count,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE Internal_Clone (

		WmiInternalContext a_InternalContext ,
		IEnumWbemClassObject **a_Enum
	) ;

    HRESULT STDMETHODCALLTYPE Internal_Skip (

		WmiInternalContext a_InternalContext ,
        long a_Timeout,
        ULONG a_Count
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemServices_Proxy :	public IWbemServices , 
											public IWbemRefreshingServices ,
											public IWbemShutdown ,
											public VoidPointerContainerElement ,
											public CWbemGlobal_VoidPointerController
{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;

	CriticalSection m_CriticalSection ;

	WmiAllocator &m_Allocator ;

	CServerObject_ProviderRegistrationV1 &m_Registration ;

	IWbemServices *m_Core_IWbemServices ;
	IWbemRefreshingServices *m_Core_IWbemRefreshingServices ;

	Internal_IWbemServices *m_Core_Internal_IWbemServices ;

	ProxyContainer m_ProxyContainer ;

	HRESULT Begin_IWbemServices (

		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_IWbemServices (

		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Begin_IWbemRefreshingServices (

		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IWbemRefreshingServices *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_IWbemRefreshingServices (

		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IWbemRefreshingServices *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Enqueue_IWbemServices (

		IWbemServices *a_Service ,
		IWbemServices *&a_Proxy
	) ;

	HRESULT Enqueue_IEnumWbemClassObject (

		IEnumWbemClassObject *a_Enum ,
		IEnumWbemClassObject *&a_Proxy
	) ;

public:

	CInterceptor_IWbemServices_Proxy ( 

		CWbemGlobal_VoidPointerController *a_Controller ,
		WmiAllocator &a_Allocator , 
		IWbemServices *a_Service ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

    ~CInterceptor_IWbemServices_Proxy () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE AddObjectToRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Path,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddObjectToRefresherByTemplate (

		WBEM_REFRESHER_ID *a_RefresherId ,
		IWbemClassObject *a_Template ,
		long a_Flags ,
		IWbemContext *a_Context ,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddEnumToRefresher(

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE RemoveObjectFromRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Id ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT STDMETHODCALLTYPE GetRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		IWbemRemoteRefresher **a_RemoteRefresher ,
		GUID *a_Guid ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE ReconnectRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId,
		long a_Flags,
		long a_NumberOfObjects,
		DWORD a_ClientRefresherVersion ,
		WBEM_RECONNECT_INFO *a_ReconnectInformation ,
		WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT ServiceInitialize () ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemServices_Stub : public IWbemServices , 
										public IWbemRefreshingServices ,
										public IWbemShutdown ,
										public Internal_IWbemServices ,
										public VoidPointerContainerElement ,
										public CWbemGlobal_VoidPointerController
{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;
	BOOL m_InterceptCallContext ;

	CriticalSection m_CriticalSection ;

	WmiAllocator &m_Allocator ;

	IWbemServices *m_Core_IWbemServices ;
	IWbemRefreshingServices *m_Core_IWbemRefreshingServices ;

	HRESULT Begin_IWbemServices (

		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IWbemServices *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_IWbemServices (

		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IWbemServices *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Begin_IWbemRefreshingServices (

		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IWbemRefreshingServices *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_IWbemRefreshingServices (

		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IWbemRefreshingServices *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Enqueue_IWbemServices (

		IWbemServices *a_Service ,
		IWbemServices *&a_Stub
	) ;

	HRESULT Enqueue_IEnumWbemClassObject (

		IEnumWbemClassObject *a_Enum ,
		IEnumWbemClassObject *&a_Stub
	) ;

public:

	CInterceptor_IWbemServices_Stub (

		CWbemGlobal_VoidPointerController *a_Controller ,
		WmiAllocator &a_Allocator , 
		IWbemServices *a_Service
	) ;

    ~CInterceptor_IWbemServices_Stub () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE AddObjectToRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Path,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddObjectToRefresherByTemplate (

		WBEM_REFRESHER_ID *a_RefresherId ,
		IWbemClassObject *a_Template ,
		long a_Flags ,
		IWbemContext *a_Context ,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddEnumToRefresher(

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE RemoveObjectFromRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Id ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT STDMETHODCALLTYPE GetRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		IWbemRemoteRefresher **a_RemoteRefresher ,
		GUID *a_Guid ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE ReconnectRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId,
		long a_Flags,
		long a_NumberOfObjects,
		DWORD a_ClientRefresherVersion ,
		WBEM_RECONNECT_INFO *a_ReconnectInformation ,
		WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT ServiceInitialize () ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

/* Internal_IWbemServices */
 
     HRESULT STDMETHODCALLTYPE Internal_OpenNamespace ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CancelAsyncCall ( 

		WmiInternalContext a_InternalContext ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_QueryObjectSink ( 

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_GetObject ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_GetObjectAsync (
        
		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE Internal_PutClass ( 

		WmiInternalContext a_InternalContext ,
        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutClassAsync ( 

		WmiInternalContext a_InternalContext ,
        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteClass ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteClassAsync ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateClassEnum ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateClassEnumAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutInstance (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutInstanceAsync (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteInstance ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteInstanceAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateInstanceEnum (

		WmiInternalContext a_InternalContext ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateInstanceEnumAsync (

		WmiInternalContext a_InternalContext ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecQuery ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecQueryAsync (

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecNotificationQuery (

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecNotificationQueryAsync ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecMethod (

		WmiInternalContext a_InternalContext ,
        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecMethodAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

} ;

#endif

#endif // _Server_Interceptor_IWbemServices_Stub_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\stress\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <tchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\stress\globals.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.cpp

Abstract:


History:

--*/

#include "PreComp.h"

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemint.h>

#include <Exception.h>
#include <Thread.h>

#include <Allocator.cpp>
#include <HelperFuncs.cpp>

#include "Globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\statask.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Server_StaTask_H
#define _Server_StaTask_H

#include <Thread.h>
#include "ProvRegInfo.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class StaTask_Create : public WmiTask < ULONG > 
{
private:

	CServerObject_StaThread &m_Thread ;

	HRESULT m_Result ;

	LPWSTR m_Scope ;
	LPWSTR m_Namespace ;

	LPSTREAM m_ContextStream ;
	LPSTREAM m_RepositoryStream ;
	LPSTREAM m_ProviderStream ;

protected:

public:	/* Internal */

    StaTask_Create (

		WmiAllocator & a_Allocator , 
		CServerObject_StaThread &a_Thread ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Namespace 
	) ;

    ~StaTask_Create () ;

	HRESULT UnMarshalContext () ;

	HRESULT MarshalContext (

		IWbemContext *a_Context ,
		IWbemServices *a_Repository
	) ;

	HRESULT MarshalOutgoing ( IUnknown *a_ProviderService ) ;

	HRESULT UnMarshalOutgoing () ;

	WmiStatusCode Process ( WmiThread <ULONG> &a_Thread ) ;

	HRESULT GetResultCode () { return m_Result ; }
};

#endif // _Server_StaTask_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provsubs.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvSubS.h

Abstract:


History:

--*/

#ifndef _Server_ProviderSubSystem_H
#define _Server_ProviderSubSystem_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#include "ProvCache.h"

class CInterceptor_IWmiProvSSSink :	public _IWmiProvSSSink , 
									public VoidPointerContainerElement 
{
private:

	_IWmiProvSSSink *m_InterceptedSink ;

protected:
public:

	CInterceptor_IWmiProvSSSink (

		_IWmiProvSSSink *a_InterceptedSink ,
		CWbemGlobal_VoidPointerController *a_Controller 
	) ;

	~CInterceptor_IWmiProvSSSink () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Synchronize (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Namespace ,
		LPCWSTR a_Provider
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_BindingFactory ;
class CServerObject_ProviderSubSystem : public _IWmiProvSS ,
										public _IWmiCoreWriteHook ,
										public _IWmiProviderConfiguration ,
										public IWbemShutdown ,
										public ProvSubSysContainerElement ,
										public CWbemGlobal_IWmiFactoryController

{
public:

	class InternalInterface : public _IWmiCoreWriteHook
	{
	private:

		CServerObject_ProviderSubSystem *m_This ;

	public:

		InternalInterface ( CServerObject_ProviderSubSystem *a_This ) : m_This ( a_This )
		{
		}

		STDMETHODIMP QueryInterface (

			REFIID iid ,
			LPVOID FAR *iplpv
		)
		{
			*iplpv = NULL ;

			if ( iid == IID_IUnknown )
			{
				*iplpv = ( LPVOID ) this ;
			}
			else if ( iid == IID__IWmiCoreWriteHook )
			{
				*iplpv = ( LPVOID ) ( _IWmiCoreWriteHook * ) this ;		
			}	

			if ( *iplpv )
			{
				( ( LPUNKNOWN ) *iplpv )->AddRef () ;

				return ResultFromScode ( S_OK ) ;
			}
			else
			{
				return ResultFromScode ( E_NOINTERFACE ) ;
			}
		}

		STDMETHODIMP_( ULONG ) AddRef ()
		{
			return m_This->ProvSubSysContainerElement :: NonCyclicAddRef () ;
		}

		STDMETHODIMP_( ULONG ) Release ()
		{
			return m_This->ProvSubSysContainerElement :: NonCyclicRelease () ;
		}

		HRESULT STDMETHODCALLTYPE PrePut (

			long a_Flags ,
			long a_UserFlags ,
			IWbemContext *a_Context ,
			IWbemPath *a_Path ,
			LPCWSTR a_Namespace ,
			LPCWSTR a_Class ,
			_IWmiObject *a_Copy
		)
		{
			return m_This->PrePut (

				a_Flags ,
				a_UserFlags ,
				a_Context ,
				a_Path ,
				a_Namespace ,
				a_Class ,
				a_Copy
			) ;
		}

		HRESULT STDMETHODCALLTYPE PostPut (

			long a_Flags ,
            HRESULT hRes,
			IWbemContext *a_Context ,
			IWbemPath *a_Path ,
			LPCWSTR a_Namespace ,
			LPCWSTR a_Class ,
			_IWmiObject *a_New ,
			_IWmiObject *a_Old
		)
		{
			return m_This->PostPut (

				a_Flags ,
                hRes,
				a_Context ,
				a_Path ,
				a_Namespace ,
				a_Class ,
				a_New ,
				a_Old
			) ;
		}

		HRESULT STDMETHODCALLTYPE PreDelete (

			long a_Flags ,
			long a_UserFlags ,
			IWbemContext *a_Context ,
			IWbemPath *a_Path,
			LPCWSTR a_Namespace,
			LPCWSTR a_Class
		)
		{
			return m_This->PreDelete (

				a_Flags ,
				a_UserFlags ,
				a_Context ,
				a_Path,
				a_Namespace,
				a_Class
			) ;
		}

		HRESULT STDMETHODCALLTYPE PostDelete (

			long a_Flags ,
            HRESULT hRes,
			IWbemContext *a_Context ,
			IWbemPath *a_Path,
			LPCWSTR a_Namespace,
			LPCWSTR a_Class,
			_IWmiObject *a_Old
		)
		{
			return m_This->PostDelete (

				a_Flags ,
                hRes,
				a_Context ,
				a_Path,
				a_Namespace,
				a_Class,
				a_Old
			) ;
		}
	} ;

	InternalInterface m_Internal ;

	void CallBackInternalRelease () ;

private:

	_IWmiCoreServices *m_Core ;

	WmiAllocator &m_Allocator ;

	CWbemGlobal_VoidPointerController *m_SinkController ;

	wchar_t *Strip_Slash ( wchar_t *a_String ) ;
	wchar_t *Strip_Server ( wchar_t *a_String , wchar_t *&a_FreeString ) ;

	HRESULT IsChild_Namespace (	wchar_t *a_Left , wchar_t *a_Right ) ;

	HRESULT GetNamespaceServerPath (

		IWbemPath *a_Namespace ,
		wchar_t *&a_ServerNamespacePath
	) ;

	HRESULT Cache (

		LPCWSTR a_Namespace ,
		IWbemPath *a_NamespacePath ,
		CServerObject_BindingFactory *a_Factory ,
		BindingFactoryCacheKey &a_Key ,
		REFIID a_RIID ,
		void **a_Interface
	) ;

	HRESULT CreateAndCache (

		IWbemServices *a_Core ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Namespace ,
		IWbemPath *a_NamespacePath ,
		BindingFactoryCacheKey &a_Key ,
		REFIID a_RIID ,
		void **a_Interface
	) ;

	HRESULT GetProvider (

		LPCWSTR a_Class ,
		IWbemPath *a_Path ,
		IWbemClassObject *a_Object ,
		LPWSTR &a_Provider
	) ;

	HRESULT Call_Load (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,		
		LPCWSTR a_Method,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT GetDeleteInfo (

		IWbemClassObject *a_OldObject ,
		LPCWSTR a_Class ,
		IWbemPath *a_Path ,
		LPWSTR &a_OutClass ,
		LPWSTR &a_OutStringPath ,
		IWbemPath *&a_OutPathObject
	) ;

	HRESULT PostDelete_ProviderRegistration (

		long a_Flags ,
		HRESULT hRes,
		IWbemContext *a_Context ,
		IWbemPath *a_Path,
		LPCWSTR a_PathString ,
		LPCWSTR a_Namespace,
		LPCWSTR a_Class,
		IWbemClassObject *a_Old

	) ;

	HRESULT PostDelete_Namespace (

		long a_Flags ,
		HRESULT hRes,
		IWbemContext *a_Context ,
		IWbemPath *a_Path,
		LPCWSTR a_PathString ,
		LPCWSTR a_Namespace,
		LPCWSTR a_Class,
		IWbemClassObject *a_Old
	) ;

	QueryPreprocessor :: QuadState IsA (

		IWbemClassObject *a_Left ,
		wchar_t *a_Right
	) ;

	HRESULT VerifySecurity ( 

		IWbemContext *a_Context ,
		const BSTR a_Provider ,
		const BSTR a_NamespacePath
	) ;

	HRESULT GetPath (

		IWbemClassObject *a_Object ,
		IWbemPath *&a_Path ,
		LPWSTR &a_PathText
	) ;

	static HRESULT ReportEvent ( 

		CServerObject_ProviderRegistrationV1 &a_Registration ,
		const BSTR a_NamespacePath
	) ;

	HRESULT ClearSinkController () ;

protected:
public:

    CServerObject_ProviderSubSystem ( WmiAllocator &a_Allocator , CWbemGlobal_IWmiProvSubSysController *a_Controller ) ;
    ~CServerObject_ProviderSubSystem ( void ) ;

	HRESULT GetWmiRepositoryService (

		IWbemPath *a_Namespace ,
		const BSTR a_User ,
		const BSTR a_Locale ,
		IWbemServices *&a_Service
	) ;

	HRESULT GetWmiRepositoryService (

		const BSTR a_Namespace ,
		const BSTR a_User ,
		const BSTR a_Locale ,
		IWbemServices *&a_Service
	) ;

	HRESULT GetWmiService (

		IWbemPath *a_Namespace ,
		const BSTR a_User ,
		const BSTR a_Locale ,
		IWbemServices *&a_Service
	) ;

	HRESULT GetWmiService (

		const BSTR a_Namespace ,
		const BSTR a_User ,
		const BSTR a_Locale ,
		IWbemServices *&a_Service
	) ;

	HRESULT ForwardReload (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Namespace ,
		LPCWSTR a_Provider
	) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	// IWmi_ProviderSubSystem members

	HRESULT STDMETHODCALLTYPE Create (

		IWbemServices *a_Core ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Namespace ,
		REFIID a_RIID ,
		void **a_Interface
	) ;

	HRESULT STDMETHODCALLTYPE CreateRefresherManager (

		IWbemServices *a_Core ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		REFIID a_RIID ,
		void **a_Interface
   	) ;

	HRESULT STDMETHODCALLTYPE RegisterNotificationSink (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		_IWmiProvSSSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE UnRegisterNotificationSink (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		_IWmiProvSSSink *a_Sink
	) ;

	// IWmi_Initialize members

	HRESULT STDMETHODCALLTYPE Initialize (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		_IWmiCoreServices *a_Core
	) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ;

	WmiStatusCode Strobe ( ULONG &a_NextStrobeDelta ) ;

	WmiStatusCode StrobeBegin ( const ULONG &a_Period ) ;

	/* _IWmiProviderConfiguration methods */

	HRESULT STDMETHODCALLTYPE Get (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Set (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_OldObject ,
		IWbemClassObject *a_NewObject  
	) ;

	HRESULT STDMETHODCALLTYPE Deleted (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_Object  
	) ;

	HRESULT STDMETHODCALLTYPE Enumerate (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		ULONG a_MilliSeconds
	) ;

	HRESULT STDMETHODCALLTYPE Call (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,		
		LPCWSTR a_Method,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Query (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
		WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
		VARIANT *a_Value 
	) ;

    HRESULT STDMETHODCALLTYPE PrePut (

        long a_Flags ,
        long a_UserFlags ,
        IWbemContext *a_Context ,
        IWbemPath *a_Path ,
        LPCWSTR a_Namespace ,
        LPCWSTR a_Class ,
        _IWmiObject *a_Copy
	) ;

    HRESULT STDMETHODCALLTYPE PostPut (

        long a_Flags ,
        HRESULT hRes,
        IWbemContext *a_Context ,
        IWbemPath *a_Path ,
        LPCWSTR a_Namespace ,
        LPCWSTR a_Class ,
        _IWmiObject *a_New ,
        _IWmiObject *a_Old
	) ;

    HRESULT STDMETHODCALLTYPE PreDelete (

        long a_Flags ,
        long a_UserFlags ,
        IWbemContext *a_Context ,
        IWbemPath *a_Path,
        LPCWSTR a_Namespace,
        LPCWSTR a_Class
	) ;

    HRESULT STDMETHODCALLTYPE PostDelete (

        long a_Flags ,
        HRESULT hRes,
        IWbemContext *a_Context ,
        IWbemPath *a_Path,
        LPCWSTR a_Namespace,
        LPCWSTR a_Class,
        _IWmiObject *a_Old
	) ;
};

#endif // _Server_ProviderSubSystem_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\stress\include\globals.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _Globals_H
#define _Globals_H

#include <Allocator.h>

#endif // _Globals_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\stress\include\cthread.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _CThread_H
#define _CThread_H

#include <Thread.h>

class ClientThread : public WmiThread < ULONG > 
{
private:

	WmiAllocator &m_Allocator ;

protected:

public:	/* Internal */

    ClientThread ( 

		WmiAllocator & a_Allocator
	) ;

    ~ClientThread () ;

	WmiStatusCode Initialize_Callback () ;

	WmiStatusCode UnInitialize_Callback () ;

};

#endif // _CThread_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\stress\include\task.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Task_H
#define _Task_H

#include <Thread.h>
#include "Service.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CProviderSink : public IWbemObjectSink 
{
private:

	HRESULT m_Result ;
	LONG m_ReferenceCount ;

	HANDLE m_Event ;

protected:

public:

    HRESULT STDMETHODCALLTYPE SetStatus (
        long lFlags,
        HRESULT hResult,
        BSTR strParam,
        IWbemClassObject *pObjParam
	)
	{
		m_Result = hResult ;

		SetEvent ( m_Event ) ;

		return S_OK ;
	}

    HRESULT STDMETHODCALLTYPE Indicate (

        LONG lObjectCount,
        IWbemClassObject **apObjArray
	)
	{
#if 0
		for ( LONG t_Index = 0 ; t_Index < lObjectCount ; t_Index ++ )
		{
			IWbemClassObject *t_Object = apObjArray [ t_Index ] ;

			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			wprintf ( L"\n" ) ;

			HRESULT t_Result = t_Object->Get ( L"Handle" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if( SUCCEEDED ( t_Result ) )
			{
				wprintf ( L"%s", t_Variant.bstrVal ) ;

				VariantClear ( & t_Variant ) ;
			}

			t_Result = t_Object->Get ( L"Name" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if( SUCCEEDED ( t_Result ) )
			{
				wprintf ( L"\t%s", t_Variant.bstrVal ) ;

				VariantClear ( & t_Variant ) ;
			}
		}
#endif

		return S_OK ;
	}

	CProviderSink () : m_ReferenceCount ( 0 ) , m_Event ( NULL ) , m_Result ( S_OK ) 
	{
		m_Event = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	}

	~CProviderSink () 
	{
		if ( m_Event ) 
		{
			CloseHandle ( m_Event ) ;
		}
	}

	STDMETHODIMP QueryInterface (

		REFIID iid , 
		LPVOID FAR *iplpv 
	) 
	{
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) this ;
		}
		else if ( iid == IID_IWbemObjectSink )
		{
			*iplpv = ( LPVOID ) this ;		
		}	

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
	}

	STDMETHODIMP_( ULONG ) AddRef ()
	{
		return InterlockedIncrement ( & m_ReferenceCount ) ;
	}

	STDMETHODIMP_(ULONG) Release ()
	{
		LONG ref ;
		if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return ref ;
		}
	}

	void Wait () 
	{
		WaitForSingleObject ( m_Event , INFINITE ) ;
	}

	HRESULT GetResult () { return m_Result ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Task_Execute : public WmiTask < ULONG > 
{
private:

	ULONG m_Count ;
	ULONG m_Index ;
	WmiAllocator &m_Allocator ;
	CProvider_IWbemServices *m_ProviderService ;

	HRESULT m_Result ;

	IWbemServices *m_WmiService ;

	HRESULT GetClass (

		IWbemServices *a_Service , 
		LPCWSTR a_Class
	) ;

	HRESULT GetInstance (

		IWbemServices *a_Service , 
		LPCWSTR a_Instance
	) ;

	HRESULT CreateInstanceEnumSync (

		IWbemServices *a_Service , 
		LPCWSTR a_Class ,
		ULONG a_BatchSize 
	) ;

	HRESULT CreateInstanceEnumForwardSync (

		IWbemServices *a_Service , 
		LPCWSTR a_Class ,
		ULONG a_BatchSize 
	) ;

	HRESULT CreateInstanceEnumSemiSync (

		IWbemServices *a_Service , 
		LPCWSTR a_Class ,
		ULONG a_BatchSize 
	) ;

	HRESULT CreateInstanceEnumASync (

		IWbemServices *a_Service , 
		LPCWSTR a_Class
	) ;

	HRESULT ExecQueryASync (

		IWbemServices *a_Service , 
		LPCWSTR a_Class
	) ;

	HRESULT Function_ASync () ;

	HRESULT Function_SemiSync ( ULONG a_BatchSize ) ;

	HRESULT Function_Sync ( ULONG a_BatchSize ) ;

	HRESULT Function_ForwardSync ( ULONG a_BatchSize ) ;

	HRESULT Function () ;

protected:

public:	/* Internal */

    Task_Execute ( WmiAllocator & a_Allocator , ULONG a_Count ) ;
    ~Task_Execute () ;

	WmiStatusCode Process ( WmiThread <ULONG> &a_Thread ) ;

	HRESULT GetResultCode () { return m_Result ; }
};

#endif // _Task_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\stathread.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Server_StaThread_H
#define _Server_StaThread_H

#include <Thread.h>
#include <ReaderWriter.h>
#include "ProvRegInfo.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ProxyIndex_Sta_IWbemServices					0
#define ProxyIndex_Sta_IWbemEventProvider				1
#define ProxyIndex_Sta_IWbemEventProviderQuerySink		2
#define ProxyIndex_Sta_IWbemEventProviderSecurity		3
#define ProxyIndex_Sta_IWbemEventConsumerProvider		4
#define ProxyIndex_Sta_IWbemEventConsumerProviderEx		5
#define ProxyIndex_Sta_IWbemUnboundObjectSink			6

#define ProxyIndex_Sta_Size								7

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_StaThread : public IWbemServices , 
								public IWbemEventProvider ,
								public IWbemEventProviderQuerySink ,
								public IWbemEventProviderSecurity ,
								public IWbemEventConsumerProviderEx ,
								public IWbemUnboundObjectSink ,
								public IWbemProviderInit , 
								public IWbemShutdown , 
								public WmiThread < ULONG > , 
								public CWbemGlobal_IWmiObjectSinkController 
{
private:

	WmiAllocator &m_Allocator ;

	LONG m_Flags ;
	IWbemContext *m_Context ;
	GUID *m_TransactionIdentifier ;
	LPWSTR m_User ;
	LPWSTR m_Locale ;
	LPWSTR m_Scope ;
	LPWSTR m_Namespace ;
	LPWSTR m_ProviderName ;
	IWbemPath *m_NamespacePath ;
	IWbemServices *m_Repository ;

	IUnknown *m_Provider_IUnknown ;
	IWbemServices *m_Provider_IWbemServices ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemEventConsumerProviderEx *m_Provider_IWbemEventConsumerProviderEx ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;

	CServerObject_ProviderRegistrationV1 *m_Registration ;

	ProxyContainer m_ProxyContainer ;

protected:

public:	/* Internal */

    CServerObject_StaThread ( 

		WmiAllocator & a_Allocator
	) ;

    ~CServerObject_StaThread () ;

	WmiStatusCode Initialize_Callback () ;

	WmiStatusCode UnInitialize_Callback () ;

	void CallBackRelease () ;

	LPCWSTR Direct_GetProviderName () { return m_ProviderName ; }
	LPCWSTR Direct_GetLocale () { return m_Locale ; }
	LPCWSTR Direct_GetUser () { return m_User ; }
	GUID *Direct_GetTransactionIdentifier () { return m_TransactionIdentifier ; }
	IWbemContext *Direct_GetContext () { return m_Context ; }
	LPCWSTR Direct_GetNamespace () { return m_Namespace ; }
	IWbemPath *Direct_GetNamespacePath () { return m_NamespacePath ; }
	LPCWSTR Direct_GetScope () { return m_Scope ; }
	IWbemServices *Direct_GetRepository () { return m_Repository ; }
	IWbemServices *Direct_GetProviderService () { return m_Provider_IWbemServices ; }

	HRESULT SetProviderName ( wchar_t *a_ProviderName ) ;
	HRESULT SetContext ( IWbemContext *a_Context ) ;
	HRESULT SetScope ( LPCWSTR a_Scope ) ;
	HRESULT SetNamespace ( LPCWSTR a_Namespace ) ;
	HRESULT SetNamespacePath ( IWbemPath *a_NamespacePath ) ;
	HRESULT SetRepository ( IWbemServices *a_Repository ) ;
	HRESULT SetProviderService ( IUnknown *a_ProviderService ) ;

	HRESULT InitializeProvider (

		GUID *a_TransactionIdentifier ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Namespace ,
		IWbemPath *a_NamespacePath ,
		IWbemServices *a_Repository ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Scope ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	HRESULT GetApartmentInstanceProvider (

		GUID *a_TransactionIdentifier ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Namespace ,
		IWbemPath *a_NamespacePath ,
		IWbemServices *a_Repository ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Scope ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

public:	/* External */

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	/* IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
};

#endif // _Server_StaThread_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\stress\service.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include <precomp.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"

#include <objbase.h>
#include <wbemint.h>
#include "Globals.h"
#include "HelperFuncs.h"
#include "DateTime.h"
#include "Service.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Set_Uint64 (

	_IWmiObject *a_Instance ,
	wchar_t *a_Name ,
	const UINT64 &a_Uint64
)
{
	HRESULT t_Result = a_Instance->WriteProp (

		a_Name , 
		0 , 
		sizeof ( UINT64 ) , 
		0 ,
		CIM_UINT64 ,
		( void * ) & a_Uint64
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Set_Uint32 ( 

	_IWmiObject *a_Instance , 
	wchar_t *a_Name ,
	const DWORD &a_Uint32
)
{
	HRESULT t_Result = a_Instance->WriteProp (

		a_Name , 
		0 , 
		sizeof ( DWORD ) , 
		0 ,
		CIM_UINT32 ,
		( void * ) & a_Uint32
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Set_String ( 

	IWbemClassObject *a_Instance , 
	wchar_t *a_Name ,
	wchar_t *a_String
)
{
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;
	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_String ) ;
	a_Instance->Put ( a_Name , 0 , & t_Variant , 0 ) ;
	VariantClear ( & t_Variant ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Set_DateTime ( 

	IWbemClassObject *a_Instance , 
	wchar_t *a_Name ,
	FILETIME a_Time
)
{
	CWbemDateTime t_Time ;
	t_Time.SetFileTimeDate ( a_Time , VARIANT_FALSE ) ;

	BSTR t_String ;
	HRESULT t_Result = t_Time.GetValue ( & t_String ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
		t_Variant.vt = VT_BSTR ;
		t_Variant.bstrVal = t_String ;
		a_Instance->Put ( a_Name , 0 , & t_Variant , CIM_DATETIME ) ;
		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

HRESULT EnablePrivilegeOnCurrentThread ( wchar_t *a_Privilege )
{
	HRESULT t_Result = WBEM_E_ACCESS_DENIED ;

    HANDLE t_Token = NULL;
	BOOL t_ProcessToken = FALSE ;

    if ( OpenThreadToken ( GetCurrentThread () , TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, FALSE , & t_Token ) )
	{
	}
	else
	{		
		if ( OpenProcessToken ( GetCurrentProcess () , TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY , & t_Token ) )
		{
		}
	}

	if ( t_Token )
    {
	    TOKEN_PRIVILEGES t_TokenPrivileges ;

		BOOL t_Status = LookupPrivilegeValue (

			NULL, 
			a_Privilege , 
			& t_TokenPrivileges.Privileges[0].Luid
		) ;

        if (t_Status)
        {
            t_TokenPrivileges.PrivilegeCount = 1;
            t_TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            SetLastError(0);

            t_Status = AdjustTokenPrivileges (

				t_Token , 
				FALSE , 
				& t_TokenPrivileges , 
				0 ,
                (PTOKEN_PRIVILEGES) NULL , 
				0
			) ;

			if ( GetLastError() == 0 )
			{
				t_Result = S_OK ;
			}
        }

        CloseHandle ( t_Token ) ;

		if ( t_ProcessToken )
		{
			RevertToSelf () ;
		}
    }

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CProvider_IWbemServices :: CProvider_IWbemServices (

	 WmiAllocator &a_Allocator 

) : m_ReferenceCount ( 0 ) , 
	m_Allocator ( a_Allocator ) ,
	m_User ( NULL ) ,
	m_Locale ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_CoreService ( NULL ) ,
	m_ComputerName  ( NULL ) ,
	m_OperatingSystemVersion ( NULL ) ,
	m_OperatingSystemRunning ( NULL ) , 
	m_ProductName ( NULL ) , 
	m_Win32_Process_Object ( NULL )
{
	InitializeCriticalSection ( & m_CriticalSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CProvider_IWbemServices :: ~CProvider_IWbemServices ()
{
	DeleteCriticalSection ( & m_CriticalSection ) ;

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_CoreService ) 
	{
		m_CoreService->Release () ;
	}

	if ( m_Win32_Process_Object ) 
	{
		m_Win32_Process_Object->Release () ;
	}

	if ( m_ComputerName ) 
	{
		SysFreeString ( m_ComputerName ) ;
	}

	if ( m_OperatingSystemVersion ) 
	{
		SysFreeString ( m_OperatingSystemVersion ) ;
	}

	if ( m_OperatingSystemRunning ) 
	{
		SysFreeString ( m_OperatingSystemRunning ) ;
	}

	if ( m_ProductName )
	{
		SysFreeString ( m_ProductName ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CProvider_IWbemServices :: AddRef ( void )
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CProvider_IWbemServices :: Release ( void )
{
	LONG t_Reference ;
	if ( ( t_Reference = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Reference ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CProvider_IWbemServices :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}	
	else if ( iid == IID_IWbemPropertyProvider )
	{
		*iplpv = ( LPVOID ) ( IWbemPropertyProvider * ) this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices::OpenNamespace ( 

	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* pNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetObject ( 
		
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetObjectAsync ( 
		
	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_FOUND ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: PutClass ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: PutClassAsync ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
 	 return WBEM_E_NOT_FOUND ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: DeleteClass ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: DeleteClassAsync ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateClassEnum ( 

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CProvider_IWbemServices :: CreateClassEnumAsync (

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_NOT_FOUND ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: PutInstance (

    IWbemClassObject FAR *pInst,
    long lFlags,
    IWbemContext FAR *pCtx,
	IWbemCallResult FAR *FAR *ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: PutInstanceAsync ( 
		
	IWbemClassObject FAR* pInst, 
	long lFlags, 
    IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: DeleteInstance ( 

	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CProvider_IWbemServices :: DeleteInstanceAsync (
 
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pSink	
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext FAR *a_Context, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *a_Enum
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD GetCurrentImpersonationLevel ()
{
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;

    HANDLE t_ThreadToken = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread() ,
		TOKEN_QUERY,
		TRUE,
		&t_ThreadToken
	) ;

    if ( t_Status )
    {
		SECURITY_IMPERSONATION_LEVEL t_Level = SecurityAnonymous ;
		DWORD t_Returned = 0 ;

		t_Status = GetTokenInformation (

			t_ThreadToken ,
			TokenImpersonationLevel ,
			& t_Level ,
			sizeof ( SECURITY_IMPERSONATION_LEVEL ) ,
			& t_Returned
		) ;

		CloseHandle ( t_ThreadToken ) ;

		if ( t_Status == FALSE )
		{
			t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
		}
		else
		{
			switch ( t_Level )
			{
				case SecurityAnonymous:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;

				case SecurityIdentification:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				break ;

				case SecurityImpersonation:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
				}
				break ;

				case SecurityDelegation:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
				}
				break ;

				default:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;
			}
		}
	}
	else
	{
        ULONG t_LastError = GetLastError () ;

        if ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN )
        {
            t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
        }
        else 
		{
			if ( t_LastError == ERROR_CANT_OPEN_ANONYMOUS )
			{
				t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
			}
			else
			{
				t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
			}
		}
    }

	return t_ImpersonationLevel ;
}

HRESULT CProvider_IWbemServices :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext __RPC_FAR *a_Context,
	IWbemObjectSink FAR *a_Sink

) 
{
#if 1
	HRESULT t_Result = CoImpersonateClient () ;

	if ( _wcsicmp ( a_Class , L"Win32_Process2" ) == 0 )
	{
		t_Result = CreateInstanceEnumAsync_Process ( 

			a_Flags ,
			a_Context , 
			a_Sink
		) ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
#else
	HRESULT t_Result = S_OK ;

	t_Result = CoImpersonateClient () ;

	DWORD t_Level = GetCurrentImpersonationLevel () ;
	if ( _wcsicmp ( a_Class , L"Sample" ) == 0 )
	{
		BSTR t_String = SysAllocString ( L"Win32_Process2" ) ;
		if ( t_String ) 
		{
			IClientSecurity *t_ClientSecurity = NULL ;

			HRESULT t_Result = m_CoreService->QueryInterface (
			
				IID_IClientSecurity , 
				( void ** ) & t_ClientSecurity
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_ClientSecurity->SetBlanket (

					m_CoreService ,
					RPC_C_AUTHN_WINNT ,
					RPC_C_AUTHZ_NONE ,
					NULL ,
					RPC_C_AUTHN_LEVEL_CONNECT ,
					RPC_C_IMP_LEVEL_IMPERSONATE ,
					NULL ,
					EOAC_DYNAMIC_CLOAKING
				) ;

				t_ClientSecurity->Release () ;
			}

			t_Result = m_CoreService->CreateInstanceEnumAsync ( 

				t_String ,
				a_Flags ,
				a_Context , 
				a_Sink
			) ;

			SysFreeString ( t_String ) ;
		}
	}
	else if ( _wcsicmp ( a_Class , L"RecursiveSample" ) == 0 )
	{
		BSTR t_String = SysAllocString ( L"Sample" ) ;
		if ( t_String ) 
		{
			t_Result = m_CoreService->CreateInstanceEnumAsync ( 

				t_String ,
				a_Flags ,
				a_Context , 
				a_Sink
			) ;

			SysFreeString ( t_String ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_CLASS ;
	}

	return t_Result ;
#endif
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: ExecQuery ( 

	const BSTR QueryLanguage, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: ExecQueryAsync ( 
		
	const BSTR QueryFormat, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pSink
) 
{
	HRESULT t_Result = WBEM_E_SHUTTING_DOWN ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: ExecNotificationQuery ( 

	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CProvider_IWbemServices :: ExecNotificationQueryAsync ( 
            
	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CProvider_IWbemServices :: ExecMethod ( 

	const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CProvider_IWbemServices :: ExecMethodAsync ( 

    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
	IWbemObjectSink FAR *pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	if ( _wcsicmp ( a_PropertyMapping , L"ExtraProperty1" ) == 0 )
	{
	}
	else if ( _wcsicmp ( a_PropertyMapping , L"ExtraProperty2" ) == 0 )
	{
	}
	else
	{
	}
	
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT CProvider_IWbemServices :: PutProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	if ( _wcsicmp ( a_PropertyMapping , L"ExtraProperty1" ) == 0 )
	{
	}
	else if ( _wcsicmp ( a_PropertyMapping , L"ExtraProperty2" ) == 0 )
	{
	}
	else
	{
	}

	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProductInformation ()
{
	HRESULT t_Result = S_OK ;

	ULONG t_ProductType = 0xffffffff ;

	if ( USER_SHARED_DATA->ProductTypeIsValid )
	{
		t_ProductType = USER_SHARED_DATA->NtProductType ;

		HKEY t_CurrentVersion ;
		LONG t_RegResult = RegOpenKeyEx (

			HKEY_LOCAL_MACHINE ,
			L"SOFTWARE\\Microsoft\\Windows NT\\Currentversion" ,
			0 ,
			KEY_READ ,
			& t_CurrentVersion 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			wchar_t t_ProductName [ _MAX_PATH ] ;

			DWORD t_ValueType = REG_SZ ;
			DWORD t_DataSize = sizeof ( t_ProductName ) ;

			t_RegResult = RegQueryValueEx (

			  t_CurrentVersion ,
			  L"" ,
			  0 ,
			  & t_ValueType ,
			  LPBYTE ( & t_ProductName ) ,
			  & t_DataSize 
			);

			if ( t_RegResult == ERROR_SUCCESS )
			{
				if ( wcscmp ( t_ProductName , L"" ) == 0 )
				{
					wcscpy ( t_ProductName , L"Microsoft Windows 2000" ) ;
				}

				if ( ( VER_SUITE_DATACENTER & USER_SHARED_DATA->SuiteMask ) &&
					( ( VER_NT_SERVER == t_ProductType ) || ( VER_NT_DOMAIN_CONTROLLER == t_ProductType ) )
				)
				{
					t_Result = WmiHelper :: ConcatenateStrings ( 

						2, 
						& m_ProductName , 
						t_ProductName ,
						L" Datacenter Server"
					) ;
				}
				else
				{
					if ( ( VER_SUITE_ENTERPRISE & USER_SHARED_DATA->SuiteMask ) &&
						( ( VER_NT_SERVER == t_ProductType ) || ( VER_NT_DOMAIN_CONTROLLER == t_ProductType ) )
					)
					{
						t_Result = WmiHelper :: ConcatenateStrings ( 

							2, 
							& m_ProductName , 
							t_ProductName ,
							L" Advanced Server"
						) ;
					}
					else
					{
						if ( ( VER_NT_SERVER == t_ProductType ) || ( VER_NT_DOMAIN_CONTROLLER == t_ProductType ) )
						{
							t_Result = WmiHelper :: ConcatenateStrings ( 

								2, 
								& m_ProductName , 
								t_ProductName ,
								L" Server"
							) ;
						}
						else
						{
							if ( VER_NT_WORKSTATION == t_ProductType )
							{
								t_Result = WmiHelper :: ConcatenateStrings ( 

									2, 
									& m_ProductName , 
									t_ProductName ,
									L" Professional"
								) ;
							}
						}
					}
				}

			}

			RegCloseKey ( t_CurrentVersion ) ;
		}

	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		wchar_t t_WindowsDirectory [ _MAX_PATH ] ;

	    if ( ! GetWindowsDirectory ( t_WindowsDirectory , sizeof ( t_WindowsDirectory ) / sizeof(wchar_t)) )
	    {
		    t_WindowsDirectory [0] = '\0';
	    }

		wchar_t t_File [_MAX_PATH] ;

		wcscpy ( t_File , t_WindowsDirectory ) ;
		wcscat ( t_File , _T("\\REPAIR\\SETUP.LOG") ) ;

		wchar_t t_Device [_MAX_PATH] ;

		GetPrivateProfileString (

			L"Paths" ,
			L"TargetDevice" ,
			L"" ,
			t_Device,
			sizeof ( t_Device ) / sizeof ( wchar_t ) ,
			t_File
		) ;

		t_Result = WmiHelper :: ConcatenateStrings ( 

			5 , 
			& m_OperatingSystemRunning , 
			m_ProductName ,
			L"|",
			t_WindowsDirectory ,
			L"|" ,
			t_Device
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_CoreService,         // For anybody
	IWbemContext *a_Context,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	if ( a_CoreService ) 
	{
		m_CoreService = a_CoreService ;
		m_CoreService->AddRef () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	
	if ( SUCCEEDED ( t_Result ) ) 
	{
		BSTR t_Class = SysAllocString ( L"Win32_Process2" ) ;
		if ( t_Class ) 
		{
			t_Result = m_CoreService->GetObject (

				t_Class ,
				0 ,
				a_Context ,
				& m_Win32_Process_Object ,
				NULL 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
			}

			SysFreeString ( t_Class ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		m_ComputerName = SysAllocStringLen ( NULL , _MAX_PATH ) ;
		if ( m_ComputerName ) 
		{
			DWORD t_Length = _MAX_PATH ;
			GetComputerName ( m_ComputerName , & t_Length ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{	
		OSVERSIONINFO t_VersionInfo ;
		t_VersionInfo.dwOSVersionInfoSize = sizeof ( OSVERSIONINFO ) ;
		if ( GetVersionEx ( & t_VersionInfo ) )
		{
			m_OperatingSystemVersion  = SysAllocStringLen ( NULL , _MAX_PATH ) ;
			if ( m_OperatingSystemVersion )
			{
				swprintf (	m_OperatingSystemVersion ,	L"%d.%d.%hu", t_VersionInfo.dwMajorVersion , t_VersionInfo.dwMinorVersion , LOWORD ( t_VersionInfo.dwBuildNumber ) ) ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_FAILED ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetProductInformation () ;	
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProcessExecutable ( HANDLE a_Process , wchar_t *&a_ExecutableName )
{
	HRESULT t_Result = WBEM_E_FAILED ;

    PROCESS_BASIC_INFORMATION t_BasicInfo ;

    NTSTATUS t_Status = NtQueryInformationProcess (

        a_Process ,
        ProcessBasicInformation ,
        & t_BasicInfo ,
        sizeof ( t_BasicInfo ) ,
        NULL
	) ;

    if ( NT_SUCCESS ( t_Status ) )
	{
		PEB *t_Peb = t_BasicInfo.PebBaseAddress ;

		//
		// Ldr = Peb->Ldr
		//

		PPEB_LDR_DATA t_Ldr ;

		t_Status = ReadProcessMemory (

			a_Process,
			& t_Peb->Ldr,
			& t_Ldr,
			sizeof ( t_Ldr ) ,
			NULL
		) ;

		if ( t_Status )
		{
			LIST_ENTRY *t_LdrHead = & t_Ldr->InMemoryOrderModuleList ;

			//
			// LdrNext = Head->Flink;
			//

			LIST_ENTRY *t_LdrNext ;

			t_Status = ReadProcessMemory (

				a_Process,
				& t_LdrHead->Flink,
				& t_LdrNext,
				sizeof ( t_LdrNext ) ,
				NULL
			) ;

			if ( t_Status )
			{
				if ( t_LdrNext != t_LdrHead )
				{
					LDR_DATA_TABLE_ENTRY t_LdrEntryData ;

					LDR_DATA_TABLE_ENTRY *t_LdrEntry = CONTAINING_RECORD ( t_LdrNext , LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks ) ;

					t_Status = ReadProcessMemory (

						a_Process,
						t_LdrEntry,
						& t_LdrEntryData,
						sizeof ( t_LdrEntryData ) ,
						NULL
					) ;

					if ( t_Status )
					{
						a_ExecutableName = ( wchar_t * ) new wchar_t [t_LdrEntryData.FullDllName.MaximumLength ];
						if ( a_ExecutableName )
						{
							t_Status = ReadProcessMemory (

								a_Process,
								t_LdrEntryData.FullDllName.Buffer,
								a_ExecutableName ,
								t_LdrEntryData.FullDllName.MaximumLength ,
								NULL
							) ;

							if ( t_Status )
							{
								t_Result = S_OK ;
							}
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
				}
			}
		}
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: NextProcessBlock (

	SYSTEM_PROCESS_INFORMATION *a_ProcessBlock , 
	SYSTEM_PROCESS_INFORMATION *&a_NextProcessBlock
)
{
	if ( a_ProcessBlock )
	{
		DWORD t_NextOffSet = a_ProcessBlock->NextEntryOffset ;
		if ( t_NextOffSet )
		{
			a_NextProcessBlock = ( SYSTEM_PROCESS_INFORMATION * ) ( ( ( BYTE * ) a_ProcessBlock ) + t_NextOffSet ) ;
		}
		else
		{
			a_NextProcessBlock = NULL ;
		}
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProcessBlocks ( SYSTEM_PROCESS_INFORMATION *&a_ProcessInformation )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ProcessInformationSize = 32768;
	a_ProcessInformation = ( SYSTEM_PROCESS_INFORMATION * ) new BYTE [t_ProcessInformationSize] ;

	if ( a_ProcessInformation )
	{
		BOOL t_Retry = TRUE ;
		while ( t_Retry )
		{
			NTSTATUS t_Status = NtQuerySystemInformation (

				SystemProcessInformation,
				a_ProcessInformation,
				t_ProcessInformationSize,
				NULL
			) ;

			if ( t_Status == STATUS_INFO_LENGTH_MISMATCH )
			{
				delete [] a_ProcessInformation  ;
				a_ProcessInformation = NULL ;
				t_ProcessInformationSize += 32768 ;
				a_ProcessInformation = ( SYSTEM_PROCESS_INFORMATION * ) new BYTE [ t_ProcessInformationSize ] ;
				if ( ! a_ProcessInformation )
				{
					return WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Retry = FALSE ;

				if ( ! NT_SUCCESS ( t_Status ) )
				{
					delete [] a_ProcessInformation;
					a_ProcessInformation = NULL ;
				}
			}
		}
	}
	else
	{
		return WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProcessInformation (

	SYSTEM_PROCESS_INFORMATION *&a_ProcessInformation
)
{
	HRESULT t_Result = S_OK ;

	if ( FAILED ( EnablePrivilegeOnCurrentThread ( SE_DEBUG_NAME ) ) )
    {
		t_Result = WBEM_E_ACCESS_DENIED ;
    }
	else
	{
		return GetProcessBlocks ( a_ProcessInformation ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProcessParameters (

	HANDLE a_Process ,
	wchar_t *&a_ProcessCommandLine
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

    PROCESS_BASIC_INFORMATION t_BasicInfo ;

    NTSTATUS t_Status = NtQueryInformationProcess (

        a_Process ,
        ProcessBasicInformation ,
        & t_BasicInfo ,
        sizeof ( t_BasicInfo ) ,
        NULL
	) ;

    if ( NT_SUCCESS ( t_Status ) )
	{
		PEB *t_Peb = t_BasicInfo.PebBaseAddress ;

		RTL_USER_PROCESS_PARAMETERS *t_ProcessParameters = NULL ;

		BOOL t_Success = ReadProcessMemory (

			a_Process,
			& t_Peb->ProcessParameters,
			& t_ProcessParameters,
			sizeof ( t_ProcessParameters ) ,
			NULL
		) ;

		if ( t_Success )
		{
			RTL_USER_PROCESS_PARAMETERS t_Parameters ;

			t_Success = ReadProcessMemory (

				a_Process,
				t_ProcessParameters,
				& t_Parameters ,
				sizeof ( RTL_USER_PROCESS_PARAMETERS ) ,
				NULL
			) ;

			if ( t_Success )
			{
				a_ProcessCommandLine = new wchar_t [ t_Parameters.CommandLine.MaximumLength ];

				t_Success = ReadProcessMemory (

					a_Process,
					t_Parameters.CommandLine.Buffer ,
					a_ProcessCommandLine ,
					t_Parameters.CommandLine.MaximumLength ,
					NULL
				) ;

				if ( t_Success )
				{
					t_Result = S_OK ;
				}
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateInstanceEnumAsync_Process_Load (

	SYSTEM_PROCESS_INFORMATION *a_ProcessInformation ,
	IWbemClassObject *a_Instance 
)
{
	HRESULT t_Result = S_OK ;

	_IWmiObject *t_FastInstance = NULL ;
	t_Result = a_Instance->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastInstance ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		wchar_t t_Handle [ _MAX_PATH ] ;
		_ui64tow ( HandleToUlong ( a_ProcessInformation->UniqueProcessId ) , t_Handle , 10 ) ;
		Set_String ( a_Instance , L"Handle" , t_Handle ) ;

		Set_Uint32 ( t_FastInstance , L"ProcessId" , HandleToUlong ( a_ProcessInformation->UniqueProcessId )  ) ;

		if ( a_ProcessInformation->ImageName.Buffer )
		{
			Set_String ( a_Instance , L"Name" , a_ProcessInformation->ImageName.Buffer ) ;
			Set_String ( a_Instance , L"Caption" , a_ProcessInformation->ImageName.Buffer ) ;
			Set_String ( a_Instance , L"Description" , a_ProcessInformation->ImageName.Buffer ) ;
		}
		else
		{
			switch ( HandleToUlong ( a_ProcessInformation->UniqueProcessId ) )
			{
				case 0:
				{
					Set_String ( a_Instance , L"Name" , L"System Idle Process" ) ;
					Set_String ( a_Instance , L"Caption" , L"System Idle Process" ) ;
					Set_String ( a_Instance , L"Description" , L"System Idle Process" ) ;
				}
				break ;

				case 2:
				case 8:
				{
					Set_String ( a_Instance , L"Name" , L"System" ) ;
					Set_String ( a_Instance , L"Caption" , L"System" ) ;
					Set_String ( a_Instance , L"Description" , L"System" ) ;
				}
				break ;

				default:
				{
					Set_String ( a_Instance , L"Name" , L"Unknown" ) ;
					Set_String ( a_Instance , L"Caption" , L"Unknown" ) ;
					Set_String ( a_Instance , L"Description" , L"Unknown" ) ;
				}
				break ;
			}
		}

		Set_String ( a_Instance , L"CSCreationClassName"	, L"Win32_ComputerSystem"	) ;
		Set_String ( a_Instance , L"CSName"					, m_ComputerName			) ;
		Set_String ( a_Instance , L"OSCreationClassName"	, L"Win32_OperatingSystem"	) ;
		Set_String ( a_Instance , L"WindowsVersion"			, m_OperatingSystemVersion	) ;
		Set_String ( a_Instance , L"OSName"					, m_OperatingSystemRunning	) ;

		Set_Uint32 ( t_FastInstance , L"ProcessId" , HandleToUlong ( a_ProcessInformation->UniqueProcessId )  ) ;

		Set_Uint32 ( t_FastInstance , L"PageFaults" , a_ProcessInformation->PageFaultCount ) ;
		Set_Uint32 ( t_FastInstance , L"PeakWorkingSetSize" , a_ProcessInformation->PeakWorkingSetSize ) ;
		Set_Uint64 ( t_FastInstance , L"WorkingSetSize" , (const unsigned __int64) a_ProcessInformation->WorkingSetSize ) ;
		Set_Uint32 ( t_FastInstance , L"QuotaPeakPagedPoolUsage" , a_ProcessInformation->QuotaPeakPagedPoolUsage ) ;
		Set_Uint32 ( t_FastInstance , L"QuotaPagedPoolUsage" , a_ProcessInformation->QuotaPagedPoolUsage ) ;
		Set_Uint32 ( t_FastInstance , L"QuotaPeakNonPagedPoolUsage" , a_ProcessInformation->QuotaPeakNonPagedPoolUsage ) ;
		Set_Uint32 ( t_FastInstance , L"QuotaNonPagedPoolUsage" , a_ProcessInformation->QuotaNonPagedPoolUsage ) ;
		Set_Uint32 ( t_FastInstance , L"PageFileUsage" , a_ProcessInformation->PagefileUsage ) ;
		Set_Uint32 ( t_FastInstance , L"PeakPageFileUsage" , a_ProcessInformation->PeakPagefileUsage ) ;
		Set_Uint32 ( t_FastInstance , L"Priority" , a_ProcessInformation->BasePriority ) ;

		if ( a_ProcessInformation->CreateTime.u.HighPart > 0 )
		{
			Set_DateTime ( a_Instance , L"CreationDate" , * ( FILETIME * ) ( & a_ProcessInformation->CreateTime.u ) ) ;
		}

		Set_Uint32 ( t_FastInstance , L"ThreadCount" , a_ProcessInformation->NumberOfThreads ) ;
		Set_Uint32 ( t_FastInstance , L"ParentProcessId" , HandleToUlong ( a_ProcessInformation->InheritedFromUniqueProcessId ) ) ;
		Set_Uint32 ( t_FastInstance , L"HandleCount" , a_ProcessInformation->HandleCount ) ;
		Set_Uint32 ( t_FastInstance , L"SessionId" , a_ProcessInformation->SessionId ) ;
		Set_Uint64 ( t_FastInstance , L"KernelModeTime" , (const unsigned __int64) a_ProcessInformation->KernelTime.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"UserModeTime" , (const unsigned __int64) a_ProcessInformation->UserTime.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"PrivatePageCount" , (const unsigned __int64) a_ProcessInformation->PrivatePageCount ) ;
		Set_Uint64 ( t_FastInstance , L"PeakVirtualSize" , (const unsigned __int64) a_ProcessInformation->PeakVirtualSize ) ;
		Set_Uint64 ( t_FastInstance , L"VirtualSize" , (const unsigned __int64) a_ProcessInformation->VirtualSize ) ;
		Set_Uint64 ( t_FastInstance , L"ReadOperationCount" , (const unsigned __int64) a_ProcessInformation->ReadOperationCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"WriteOperationCount" , (const unsigned __int64) a_ProcessInformation->WriteOperationCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"OtherOperationCount" , (const unsigned __int64) a_ProcessInformation->OtherOperationCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"ReadTransferCount" , (const unsigned __int64) a_ProcessInformation->ReadTransferCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"WriteTransferCount" , (const unsigned __int64) a_ProcessInformation->WriteTransferCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"OtherTransferCount" , (const unsigned __int64) a_ProcessInformation->OtherTransferCount.QuadPart ) ;

		HANDLE t_ProcessHandle = OpenProcess (

			PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
			FALSE,
			HandleToUlong ( a_ProcessInformation->UniqueProcessId )
		) ;

		if ( t_ProcessHandle )
		{
			wchar_t *t_ExecutableName = NULL ;
			t_Result = GetProcessExecutable ( t_ProcessHandle , t_ExecutableName ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				Set_String ( a_Instance , L"ExecutablePath" , t_ExecutableName );
				delete [] t_ExecutableName ;
			}

			QUOTA_LIMITS QuotaLimits;
			NTSTATUS Status = NtQueryInformationProcess (

				t_ProcessHandle,
				ProcessQuotaLimits,
				&QuotaLimits,
				sizeof(QuotaLimits),
				NULL
			);

			if ( NT_SUCCESS ( Status ) )
			{
				Set_Uint32 ( t_FastInstance , L"MinimumWorkingSetSize" , QuotaLimits.MinimumWorkingSetSize ) ;
				Set_Uint32 ( t_FastInstance , L"MaximumWorkingSetSize" , QuotaLimits.MaximumWorkingSetSize ) ;
			}

			wchar_t *t_CommandParameters = NULL ;

			t_Result = GetProcessParameters (

				t_ProcessHandle ,
				t_CommandParameters
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				Set_String ( a_Instance , L"CommandLine" , t_CommandParameters ) ;
				delete [] t_CommandParameters ;
			}

			CloseHandle ( t_ProcessHandle ) ;
		}

		t_FastInstance->Release () ;
	}

	return t_Result ;
}
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateInstanceEnumAsync_Process (

	long a_Flags , 
	IWbemContext __RPC_FAR *a_Context,
	IWbemObjectSink FAR *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	SYSTEM_PROCESS_INFORMATION *t_ProcessBlock = NULL ;

	t_Result = GetProcessInformation ( t_ProcessBlock ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		ULONG t_Count = 0 ; 
		SYSTEM_PROCESS_INFORMATION *t_CurrentInformation = t_ProcessBlock ;
		while ( SUCCEEDED ( t_Result ) && t_CurrentInformation )
		{
			t_Count ++ ;
			t_Result = NextProcessBlock ( t_CurrentInformation , t_CurrentInformation ) ;
		}

		if ( t_Count )
		{
			ULONG t_Index = 0 ;

			IWbemClassObject **t_ObjectArray = new IWbemClassObject * [ t_Count ] ;

			t_CurrentInformation = t_ProcessBlock ;
			while ( SUCCEEDED ( t_Result ) && t_CurrentInformation )
			{
				IWbemClassObject *t_Instance = NULL ;
				t_Result = m_Win32_Process_Object->SpawnInstance ( 

					0 , 
					& t_ObjectArray [ t_Index ]
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = CreateInstanceEnumAsync_Process_Load (

						t_CurrentInformation ,
						t_ObjectArray [ t_Index ]
					) ;
				}

				t_Index ++ ;

				t_Result = NextProcessBlock ( t_CurrentInformation , t_CurrentInformation ) ;
			}

			t_Result = a_Sink->Indicate ( t_Count , t_ObjectArray ) ;
			for ( t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
			{
				t_ObjectArray [ t_Index ]->Release () ;
			}
		}

		delete [] ( BYTE * ) t_ProcessBlock ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\stress\task.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <wmiutils.h>

#include "Globals.h"
#include "Task.h"
#include "Service.h"

#if 0
#define SAMPLE_NAMESPACE L"Root\\Cimv2"
//#define SAMPLE_CLASS L"RecursiveSample"
//#define SAMPLE_CLASS L"Sample"
#define SAMPLE_CLASS L"Win32_Process"
#else
#define SAMPLE_NAMESPACE L"Root\\Default"
#define SAMPLE_CLASS L"__Win32Provider"
#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT WmiSetSecurity ( IWbemServices *a_Service ) 
{
	IClientSecurity *t_Security = NULL ;
	HRESULT t_Result = a_Service->QueryInterface ( IID_IClientSecurity , ( void ** ) & t_Security ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_Security->SetBlanket ( 

			a_Service , 
			RPC_C_AUTHN_WINNT, 
			RPC_C_AUTHZ_NONE, 
			NULL,
			RPC_C_AUTHN_LEVEL_CONNECT , 
			RPC_C_IMP_LEVEL_IMPERSONATE, 
			NULL,
			EOAC_NONE
		) ;

		t_Security->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT WmiCompileFile (

	LPWSTR a_MofFile ,
	LPWSTR a_Namespace ,
	LPWSTR a_User,
	LPWSTR a_Authority ,
	LPWSTR a_Password ,
	LONG a_OptionFlags ,
	LONG a_ClassFlags,
	LONG a_InstanceFlags
)
{
	IMofCompiler *t_Compiler = NULL ;

	HRESULT t_Result = CoCreateInstance (
  
		CLSID_MofCompiler ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IMofCompiler ,
		( void ** )  & t_Compiler 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		WBEM_COMPILE_STATUS_INFO t_CompileStatus ;
 
		t_Result = t_Compiler->CompileFile (

			a_MofFile ,
			a_Namespace ,
			a_User,
			a_Authority ,
			a_Password ,
			a_OptionFlags ,
			a_ClassFlags,
			a_InstanceFlags,
			& t_CompileStatus
		) ;

		t_Compiler->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CreateContext ( IWbemServices *&a_Context )
{
	HRESULT t_Result = CoCreateInstance (
  
		CLSID_WbemContext ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IWbemContext ,
		( void ** )  & a_Context 
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT WmiConnect ( LPWSTR a_Namespace , IWbemServices *&a_Service )
{
	IWbemLocator *t_Locator = NULL ;

	HRESULT t_Result = CoCreateInstance (
  
		CLSID_WbemLocator ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IUnknown ,
		( void ** )  & t_Locator
	);

	if ( SUCCEEDED ( t_Result ) )
	{
		BSTR t_Namespace = SysAllocString ( a_Namespace ) ;

		t_Result = t_Locator->ConnectServer (

			t_Namespace ,
			NULL ,
			NULL,
			NULL ,
			0 ,
			NULL,
			NULL,
			&a_Service
		) ;

		SysFreeString ( t_Namespace ) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = WmiSetSecurity ( a_Service ) ;
		}

		t_Locator->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

Task_Execute :: Task_Execute (

	WmiAllocator &a_Allocator ,
	ULONG a_Count

) : WmiTask < ULONG > ( a_Allocator ) ,
	m_Allocator ( a_Allocator ) ,
	m_WmiService ( NULL ) ,
	m_ProviderService ( NULL ) ,
	m_Count ( a_Count ) ,
	m_Index ( 0 ) ,
	m_Result ( S_OK ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

Task_Execute :: ~Task_Execute ()
{
	if ( m_WmiService ) 
	{
		m_WmiService->Release () ;
	}

	if ( m_ProviderService ) 
	{
		m_ProviderService->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: GetClass (

	IWbemServices *a_Service ,
	LPCWSTR a_Class
)
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_ObjectPath = NULL ;

	t_Result = WmiHelper :: ConcatenateStrings ( 

		4 , 
		& t_ObjectPath , 
		L"\\\\.\\" ,
		SAMPLE_NAMESPACE,
		":" , 
		a_Class
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemClassObject *t_Class = NULL ;

		t_Result = a_Service->GetObject ( 

			t_ObjectPath ,
			0 ,
			NULL , 
			& t_Class , 
			NULL 
		) ;

		SysFreeString ( t_ObjectPath ) ;
	
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Class->Release () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: GetInstance (

	IWbemServices *a_Service ,
	LPCWSTR a_Instance
)
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_ObjectPath = NULL ;

	t_Result = WmiHelper :: ConcatenateStrings ( 

		4 , 
		& t_ObjectPath , 
		L"\\\\.\\" ,
		SAMPLE_NAMESPACE,
		":" , 
		a_Instance
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemClassObject *t_Instance = NULL ;
					
		t_Result = a_Service->GetObject ( 

			t_ObjectPath ,
			0 ,
			NULL , 
			& t_Instance , 
			NULL 
		) ;

		SysFreeString ( t_ObjectPath ) ;
	
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Instance->Release () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: ExecQueryASync (

	IWbemServices *a_Service ,
	LPCWSTR a_Class
)
{
	HRESULT t_Result = S_OK ;

	CProviderSink *t_ProviderSink = new CProviderSink ;
	if ( t_ProviderSink )
	{
		t_ProviderSink->AddRef () ;

		BSTR t_Query = SysAllocString ( L"Select * from win32_process" ) ;
		BSTR t_QueryLanguage = SysAllocString ( L"WQL" ) ;

		t_Result = a_Service->ExecQueryAsync (

			t_QueryLanguage ,
			t_Query ,
			0 ,
			NULL ,
			t_ProviderSink
		) ;

		SysFreeString ( t_Query ) ;
		SysFreeString ( t_QueryLanguage ) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_ProviderSink->Wait () ;
			if ( FAILED( t_ProviderSink->GetResult () ) )
			{
				OutputDebugString ( L"FAILED" ) ;
			}
		}

		t_ProviderSink->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: CreateInstanceEnumASync (

	IWbemServices *a_Service ,
	LPCWSTR a_Class
)
{
	HRESULT t_Result = S_OK ;

	CProviderSink *t_ProviderSink = new CProviderSink ;
	if ( t_ProviderSink )
	{
		t_ProviderSink->AddRef () ;

		BSTR t_Class = SysAllocString ( a_Class ) ;

		t_Result = a_Service->CreateInstanceEnumAsync (

			t_Class ,
			0 ,
			NULL ,
			t_ProviderSink
		) ;

		SysFreeString ( t_Class ) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_ProviderSink->Wait () ;
			if ( FAILED( t_ProviderSink->GetResult () ) )
			{
				OutputDebugString ( L"FAILED" ) ;
			}
		}

		t_ProviderSink->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: CreateInstanceEnumSync (

	IWbemServices *a_Service ,
	LPCWSTR a_Class ,
	ULONG a_BatchSize 
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_Class = SysAllocString ( a_Class ) ;

	IEnumWbemClassObject *t_InstanceObjectEnum = NULL ;

	t_Result = a_Service->CreateInstanceEnum (

		t_Class ,
		0 ,
		NULL ,
		& t_InstanceObjectEnum
	) ;

	SysFreeString ( t_Class ) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemClassObject **t_ClassObjectArray = new IWbemClassObject * [ a_BatchSize ] ;
		if ( t_ClassObjectArray )
		{
			ULONG t_ObjectCount = 0 ;

			t_InstanceObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_InstanceObjectEnum->Next ( WBEM_INFINITE , a_BatchSize , t_ClassObjectArray , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				for ( ULONG t_Index = 0 ; t_Index < t_ObjectCount ; t_Index ++ )
				{
					t_ClassObjectArray [ t_Index ]->Release () ;
				}
			}

			delete [] t_ClassObjectArray ;
		}

		t_InstanceObjectEnum->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: CreateInstanceEnumForwardSync (

	IWbemServices *a_Service ,
	LPCWSTR a_Class ,
	ULONG a_BatchSize 
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_Class = SysAllocString ( a_Class ) ;

	IEnumWbemClassObject *t_InstanceObjectEnum = NULL ;

	t_Result = a_Service->CreateInstanceEnum (

		t_Class ,
		WBEM_FLAG_FORWARD_ONLY ,
		NULL ,
		& t_InstanceObjectEnum
	) ;

	SysFreeString ( t_Class ) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemClassObject **t_ClassObjectArray = new IWbemClassObject * [ a_BatchSize ] ;
		if ( t_ClassObjectArray )
		{
			ULONG t_ObjectCount = 0 ;

			t_InstanceObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_InstanceObjectEnum->Next ( WBEM_INFINITE , a_BatchSize , t_ClassObjectArray , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				for ( ULONG t_Index = 0 ; t_Index < t_ObjectCount ; t_Index ++ )
				{
					t_ClassObjectArray [ t_Index ]->Release () ;
				}
			}

			delete [] t_ClassObjectArray;
		}

		t_InstanceObjectEnum->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: CreateInstanceEnumSemiSync (

	IWbemServices *a_Service ,
	LPCWSTR a_Class ,
	ULONG a_BatchSize 
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_Class = SysAllocString ( a_Class ) ;

	IEnumWbemClassObject *t_InstanceObjectEnum = NULL ;

	t_Result = a_Service->CreateInstanceEnum (

		t_Class ,
		WBEM_FLAG_RETURN_IMMEDIATELY ,
		NULL ,
		& t_InstanceObjectEnum
	) ;

	SysFreeString ( t_Class ) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemClassObject *t_ClassObject = NULL ;
		ULONG t_ObjectCount = 0 ;

		t_InstanceObjectEnum->Reset () ;

		CProviderSink *t_ProviderSink = new CProviderSink ;
		if ( t_ProviderSink )
		{
			t_ProviderSink->AddRef () ;

			while ( t_ProviderSink && SUCCEEDED ( t_Result ) && ( t_InstanceObjectEnum->NextAsync ( a_BatchSize  , t_ProviderSink ) == WBEM_NO_ERROR ) )
			{
				t_ProviderSink->Wait () ;
				if ( FAILED( t_ProviderSink->GetResult () ) )
				{
					OutputDebugString ( L"FAILED" ) ;
				}

				t_ProviderSink->Release () ;

				t_ProviderSink = new CProviderSink ;
				if ( t_ProviderSink )
				{
					t_ProviderSink->AddRef () ;
				}
			}

			if ( t_ProviderSink )
			{
				t_ProviderSink->Release () ;
			}
		}

		t_InstanceObjectEnum->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: Function_ASync ()
{
	ULONG t_TickCount2 = GetTickCount () ;

	for ( ULONG t_Index2 = 0 ; t_Index2 < 100 ; t_Index2 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process2" ) ;
	}

	ULONG t_TickCount3 = GetTickCount () ;

	for ( ULONG t_Index3 = 0 ; t_Index3 < 100 ; t_Index3 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process3" ) ;
	}

	ULONG t_TickCount4 = GetTickCount () ;

	for ( ULONG t_Index4 = 0 ; t_Index4 < 100 ; t_Index4 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process4" ) ;
	}

	ULONG t_TickCount5 = GetTickCount () ;

	for ( ULONG t_Index5 = 0 ; t_Index5 < 100 ; t_Index5 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process5" ) ;
	}

	ULONG t_TickCount6 = GetTickCount () ;

	for ( ULONG t_Index6 = 0 ; t_Index6 < 100 ; t_Index6 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process6" ) ;
	}

	ULONG t_TickCount7 = GetTickCount () ;

	for ( ULONG t_Index7 = 0 ; t_Index7 < 100 ; t_Index7 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process7" ) ;
	}

	ULONG t_TickCount8 = GetTickCount () ;

	for ( ULONG t_Index8 = 0 ; t_Index8 < 100 ; t_Index8 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process8" ) ;
	}

	ULONG t_TickCount9 = GetTickCount () ;

	for ( ULONG t_Index9 = 0 ; t_Index9 < 100 ; t_Index9 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process9" ) ;
	}

	ULONG t_TickCount10 = GetTickCount () ;

	for ( ULONG t_Index10 = 0 ; t_Index10 < 100 ; t_Index10 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process10" ) ;
	}

	ULONG t_TickCount11 = GetTickCount () ;

	for ( ULONG t_Index11 = 0 ; t_Index11 < 100 ; t_Index11 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process11" ) ;
	}

	ULONG t_TickCount12 = GetTickCount () ;

	printf ( "\nASync - Winmgmt - Short Cirtuited - Single = %lu" , t_TickCount3 - t_TickCount2 ) ;
	printf ( "\nASync - Winmgmt - Short Cirtuited - Batched  = %lu" , t_TickCount4 - t_TickCount3 ) ;
	printf ( "\nASync - Winmgmt - Full Cirtuit - Single  = %lu" , t_TickCount5 - t_TickCount4 ) ;
	printf ( "\nASync - Winmgmt - Full Cirtuit - Batched  = %lu" , t_TickCount6 - t_TickCount5 ) ;
	printf ( "\nASync - Winmgmt - No Op = %lu" , t_TickCount7 - t_TickCount6 ) ;

	printf ( "\nASync - Host - Short Cirtuited - Single = %lu" , t_TickCount8 - t_TickCount7 ) ;
	printf ( "\nASync - Host - Short Cirtuited - Batched  = %lu" , t_TickCount9 - t_TickCount8 ) ;
	printf ( "\nASync - Host - Full Cirtuit - Single  = %lu" , t_TickCount10 - t_TickCount9 ) ;
	printf ( "\nASync - Host - Full Cirtuit - Batched = %lu" , t_TickCount11 - t_TickCount10 ) ;
	printf ( "\nASync - Host - No Op = %lu" , t_TickCount12 - t_TickCount11 ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: Function_SemiSync ( ULONG a_BatchSize )
{
	ULONG t_TickCount2 = GetTickCount () ;

	for ( ULONG t_Index2 = 0 ; t_Index2 < 100 ; t_Index2 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process2" , a_BatchSize ) ;
	}

	ULONG t_TickCount3 = GetTickCount () ;

	for ( ULONG t_Index3 = 0 ; t_Index3 < 100 ; t_Index3 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process3" , a_BatchSize ) ;
	}

	ULONG t_TickCount4 = GetTickCount () ;

	for ( ULONG t_Index4 = 0 ; t_Index4 < 100 ; t_Index4 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process4" , a_BatchSize ) ;
	}

	ULONG t_TickCount5 = GetTickCount () ;

	for ( ULONG t_Index5 = 0 ; t_Index5 < 100 ; t_Index5 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process5" , a_BatchSize ) ;
	}

	ULONG t_TickCount6 = GetTickCount () ;

	for ( ULONG t_Index6 = 0 ; t_Index6 < 100 ; t_Index6 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process6" , a_BatchSize ) ;
	}

	ULONG t_TickCount7 = GetTickCount () ;

	for ( ULONG t_Index7 = 0 ; t_Index7 < 100 ; t_Index7 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process7" , a_BatchSize ) ;
	}

	ULONG t_TickCount8 = GetTickCount () ;

	for ( ULONG t_Index8 = 0 ; t_Index8 < 100 ; t_Index8 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process8" , a_BatchSize ) ;
	}

	ULONG t_TickCount9 = GetTickCount () ;

	for ( ULONG t_Index9 = 0 ; t_Index9 < 100 ; t_Index9 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process9" , a_BatchSize ) ;
	}

	ULONG t_TickCount10 = GetTickCount () ;

	for ( ULONG t_Index10 = 0 ; t_Index10 < 100 ; t_Index10 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process10" , a_BatchSize ) ;
	}

	ULONG t_TickCount11 = GetTickCount () ;

	for ( ULONG t_Index11 = 0 ; t_Index11 < 100 ; t_Index11 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process11" , a_BatchSize ) ;
	}

	ULONG t_TickCount12 = GetTickCount () ;

	printf ( "\nBatch Size = %lu" , a_BatchSize ) ;
	printf ( "\nSemiSync - Winmgmt - Short Cirtuited - Single = %lu" , t_TickCount3 - t_TickCount2 ) ;
	printf ( "\nSemiSync - Winmgmt - Short Cirtuited - Batched  = %lu" , t_TickCount4 - t_TickCount3 ) ;
	printf ( "\nSemiSync - Winmgmt - Full Cirtuit - Single  = %lu" , t_TickCount5 - t_TickCount4 ) ;
	printf ( "\nSemiSync - Winmgmt - Full Cirtuit - Batched  = %lu" , t_TickCount6 - t_TickCount5 ) ;
	printf ( "\nSemiSync - Winmgmt - No Op = %lu" , t_TickCount7 - t_TickCount6 ) ;

	printf ( "\nSemiSync - Host - Short Cirtuited - Single = %lu" , t_TickCount8 - t_TickCount7 ) ;
	printf ( "\nSemiSync - Host - Short Cirtuited - Batched  = %lu" , t_TickCount9 - t_TickCount8 ) ;
	printf ( "\nSemiSync - Host - Full Cirtuit - Single  = %lu" , t_TickCount10 - t_TickCount9 ) ;
	printf ( "\nSemiSync - Host - Full Cirtuit - Batched = %lu" , t_TickCount11 - t_TickCount10 ) ;
	printf ( "\nSemiSync - Host - No Op = %lu" , t_TickCount12 - t_TickCount11 ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: Function_Sync ( ULONG a_BatchSize )
{
	ULONG t_TickCount2 = GetTickCount () ;

	for ( ULONG t_Index2 = 0 ; t_Index2 < 100 ; t_Index2 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process2" , a_BatchSize ) ;
	}

	ULONG t_TickCount3 = GetTickCount () ;

	for ( ULONG t_Index3 = 0 ; t_Index3 < 100 ; t_Index3 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process3" , a_BatchSize ) ;
	}

	ULONG t_TickCount4 = GetTickCount () ;

	for ( ULONG t_Index4 = 0 ; t_Index4 < 100 ; t_Index4 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process4" , a_BatchSize ) ;
	}

	ULONG t_TickCount5 = GetTickCount () ;

	for ( ULONG t_Index5 = 0 ; t_Index5 < 100 ; t_Index5 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process5" , a_BatchSize ) ;
	}

	ULONG t_TickCount6 = GetTickCount () ;

	for ( ULONG t_Index6 = 0 ; t_Index6 < 100 ; t_Index6 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process6" , a_BatchSize ) ;
	}

	ULONG t_TickCount7 = GetTickCount () ;

	for ( ULONG t_Index7 = 0 ; t_Index7 < 100 ; t_Index7 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process7" , a_BatchSize ) ;
	}

	ULONG t_TickCount8 = GetTickCount () ;

	for ( ULONG t_Index8 = 0 ; t_Index8 < 100 ; t_Index8 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process8" , a_BatchSize ) ;
	}

	ULONG t_TickCount9 = GetTickCount () ;

	for ( ULONG t_Index9 = 0 ; t_Index9 < 100 ; t_Index9 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process9" , a_BatchSize ) ;
	}

	ULONG t_TickCount10 = GetTickCount () ;

	for ( ULONG t_Index10 = 0 ; t_Index10 < 100 ; t_Index10 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process10" , a_BatchSize ) ;
	}

	ULONG t_TickCount11 = GetTickCount () ;

	for ( ULONG t_Index11 = 0 ; t_Index11 < 100 ; t_Index11 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process11" , a_BatchSize ) ;
	}

	ULONG t_TickCount12 = GetTickCount () ;

	printf ( "\nBatch Size = %lu" , a_BatchSize ) ;
	printf ( "\nSync - Winmgmt - Short Cirtuited - Single = %lu" , t_TickCount3 - t_TickCount2 ) ;
	printf ( "\nSync - Winmgmt - Short Cirtuited - Batched  = %lu" , t_TickCount4 - t_TickCount3 ) ;
	printf ( "\nSync - Winmgmt - Full Cirtuit - Single  = %lu" , t_TickCount5 - t_TickCount4 ) ;
	printf ( "\nSync - Winmgmt - Full Cirtuit - Batched  = %lu" , t_TickCount6 - t_TickCount5 ) ;
	printf ( "\nSync - Winmgmt - No Op = %lu" , t_TickCount7 - t_TickCount6 ) ;

	printf ( "\nSync - Host - Short Cirtuited - Single = %lu" , t_TickCount8 - t_TickCount7 ) ;
	printf ( "\nSync - Host - Short Cirtuited - Batched  = %lu" , t_TickCount9 - t_TickCount8 ) ;
	printf ( "\nSync - Host - Full Cirtuit - Single  = %lu" , t_TickCount10 - t_TickCount9 ) ;
	printf ( "\nSync - Host - Full Cirtuit - Batched = %lu" , t_TickCount11 - t_TickCount10 ) ;
	printf ( "\nSync - Host - No Op = %lu" , t_TickCount12 - t_TickCount11 ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: Function_ForwardSync ( ULONG a_BatchSize )
{
	ULONG t_TickCount2 = GetTickCount () ;

	for ( ULONG t_Index2 = 0 ; t_Index2 < 100 ; t_Index2 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process2" , a_BatchSize ) ;
	}

	ULONG t_TickCount3 = GetTickCount () ;

	for ( ULONG t_Index3 = 0 ; t_Index3 < 100 ; t_Index3 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process3" , a_BatchSize ) ;
	}

	ULONG t_TickCount4 = GetTickCount () ;

	for ( ULONG t_Index4 = 0 ; t_Index4 < 100 ; t_Index4 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process4" , a_BatchSize ) ;
	}

	ULONG t_TickCount5 = GetTickCount () ;

	for ( ULONG t_Index5 = 0 ; t_Index5 < 100 ; t_Index5 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process5" , a_BatchSize ) ;
	}

	ULONG t_TickCount6 = GetTickCount () ;

	for ( ULONG t_Index6 = 0 ; t_Index6 < 100 ; t_Index6 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process6" , a_BatchSize ) ;
	}

	ULONG t_TickCount7 = GetTickCount () ;

	for ( ULONG t_Index7 = 0 ; t_Index7 < 100 ; t_Index7 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process7" , a_BatchSize ) ;
	}

	ULONG t_TickCount8 = GetTickCount () ;

	for ( ULONG t_Index8 = 0 ; t_Index8 < 100 ; t_Index8 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process8" , a_BatchSize ) ;
	}

	ULONG t_TickCount9 = GetTickCount () ;

	for ( ULONG t_Index9 = 0 ; t_Index9 < 100 ; t_Index9 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process9" , a_BatchSize ) ;
	}

	ULONG t_TickCount10 = GetTickCount () ;

	for ( ULONG t_Index10 = 0 ; t_Index10 < 100 ; t_Index10 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process10" , a_BatchSize ) ;
	}

	ULONG t_TickCount11 = GetTickCount () ;

	for ( ULONG t_Index11 = 0 ; t_Index11 < 100 ; t_Index11 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process11" , a_BatchSize ) ;
	}

	ULONG t_TickCount12 = GetTickCount () ;

	printf ( "\nBatch Size = %lu" , a_BatchSize ) ;
	printf ( "\nForwardSync - Winmgmt - Short Cirtuited - Single = %lu" , t_TickCount3 - t_TickCount2 ) ;
	printf ( "\nForwardSync - Winmgmt - Short Cirtuited - Batched  = %lu" , t_TickCount4 - t_TickCount3 ) ;
	printf ( "\nForwardSync - Winmgmt - Full Cirtuit - Single  = %lu" , t_TickCount5 - t_TickCount4 ) ;
	printf ( "\nForwardSync - Winmgmt - Full Cirtuit - Batched  = %lu" , t_TickCount6 - t_TickCount5 ) ;
	printf ( "\nForwardSync - Winmgmt - No Op = %lu" , t_TickCount7 - t_TickCount6 ) ;

	printf ( "\nForwardSync - Host - Short Cirtuited - Single = %lu" , t_TickCount8 - t_TickCount7 ) ;
	printf ( "\nForwardSync - Host - Short Cirtuited - Batched  = %lu" , t_TickCount9 - t_TickCount8 ) ;
	printf ( "\nForwardSync - Host - Full Cirtuit - Single  = %lu" , t_TickCount10 - t_TickCount9 ) ;
	printf ( "\nForwardSync - Host - Full Cirtuit - Batched = %lu" , t_TickCount11 - t_TickCount10 ) ;
	printf ( "\nForwardSync - Host - No Op = %lu" , t_TickCount12 - t_TickCount11 ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: Function ()
{
	ULONG t_TickCount1 = GetTickCount () ;

#if 0
	for ( ULONG t_Index1 = 0 ; t_Index1 < 100 ; t_Index1 ++ )
	{
		CreateInstanceEnumASync ( m_ProviderService , L"Win32_Process" ) ;
	}
#else
	for ( ULONG t_Index1 = 0 ; t_Index1 < 1000 ; t_Index1 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_NtLogEvent" ) ;
	}
#endif

	ULONG t_TickCount2 = GetTickCount () ;

	printf ( "\nClient = %lu" , t_TickCount2 - t_TickCount1 ) ;

#if 0
	Function_ASync () ;
	Function_SemiSync ( 1 ) ;
	Function_Sync ( 1 ) ;
	Function_ForwardSync ( 1 ) ;
	Function_SemiSync ( 100 ) ;
	Function_Sync ( 100 ) ;
	Function_ForwardSync ( 100 ) ;
#endif

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode Task_Execute :: Process ( WmiThread <ULONG > &a_Thread )
{
	m_Result = S_OK ;

	if ( m_Index == 0 )
	{
		m_Result = WmiConnect ( L"root\\cimv2" , m_WmiService ) ;
#if 0
		if ( SUCCEEDED ( m_Result ) )
		{
			CProvider_InitializationSink *t_InitializationSink = new CProvider_InitializationSink ;
			if ( t_InitializationSink )
			{
				m_ProviderService = new CProvider_IWbemServices ( m_Allocator ) ;
				if ( m_ProviderService )
				{
					m_Result = m_ProviderService->Initialize (

						NULL ,
						0 , 
						NULL ,
						NULL ,
						m_WmiService ,
						NULL ,
						t_InitializationSink
					) ;
				}
				else
				{
					m_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				t_InitializationSink->Release () ;
			}
			else
			{
				m_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

#endif

		if ( FAILED ( m_Result ) )
		{
			Complete () ;
			return e_StatusCode_Success ;
		}
	}



	if ( SUCCEEDED ( m_Result ) )
	{
		m_Result = Function () ;
	}

	m_Index ++ ;
	if ( m_Index < m_Count )
	{
		return e_StatusCode_EnQueue ;
	}
	else
	{
		Complete () ;
	}

	return e_StatusCode_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\strobethread.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _StrobeThread_H
#define _StrobeThread_H

#include <Thread.h>

class StrobeThread : public EventHandler
{
private:

	WmiAllocator &m_Allocator ;
	DWORD timeout_;

public:

	StrobeThread ( WmiAllocator & a_Allocator , DWORD timeout) ;
	~StrobeThread () ;

	int handleTimeout (void) ;

	ULONG GetTimeout () { return timeout_; }

	void SetTimeout ( DWORD timeout ) 
	{
		timeout_ = ( timeout_ < timeout ) ? timeout_ : timeout ;
		Dispatcher::changeTimer( *this, timeout_ ) ;
	}
};

class Task_ProcessTermination : public EventHandler
{
	DWORD m_ProcessIdentifier ;
	HANDLE processHandle_;
public:
	Task_ProcessTermination(WmiAllocator & a_Allocator , HANDLE a_Process , DWORD a_ProcessIdentifier );
	~Task_ProcessTermination(void);
	int handleEvent(void);
	HANDLE getHandle(void);
};


#if 0
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class StrobeThread : public WmiThread < ULONG > 
{
private:

	WmiAllocator &m_Allocator ;

protected:

public:	// Internal 

    StrobeThread ( 

		WmiAllocator & a_Allocator ,
		const ULONG &a_Timeout 
	) ;

    ~StrobeThread () ;

	WmiStatusCode Initialize_Callback () ;

	WmiStatusCode UnInitialize_Callback () ;

	WmiStatusCode TimedOut () ;

	WmiStatusCode Shutdown () ;

};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Task_ProcessTermination : public WmiTask < ULONG > 
{
private:

	DWORD m_ProcessIdentifier ;

protected:

public:	// Internal 

    Task_ProcessTermination ( 

		WmiAllocator & a_Allocator ,
		HANDLE a_Process ,
		DWORD a_ProcessIdentifier 
	) ;

    ~Task_ProcessTermination () ;

	WmiStatusCode Process ( WmiThread <ULONG> &a_Thread ) ;
};

#endif
#endif // _StrobeThread_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\stress\include\service.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _Provider_IWbemServices_H
#define _Provider_IWbemServices_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CProvider_InitializationSink : public IWbemProviderInitSink 
{
private:

	LONG m_ReferenceCount ;

	BOOL m_StatusCalled ;

	HANDLE m_Event ;

	HRESULT m_Result ;

protected:

public:

    HRESULT STDMETHODCALLTYPE SetStatus (

        LONG a_Status,
        LONG a_Flags 
	)
	{
		m_Result = a_Status ;

		SetEvent ( m_Event ) ;
		return S_OK ;
	}

	CProvider_InitializationSink () : m_ReferenceCount ( 0 ) , 
										m_Event ( NULL ) , 
										m_StatusCalled ( FALSE ) , 
										m_Result ( S_OK )
	{
		m_Event = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	}

	~CProvider_InitializationSink () 
	{
		if ( m_Event ) 
		{
			CloseHandle ( m_Event ) ;
		}
	}

	STDMETHODIMP QueryInterface (

		REFIID iid , 
		LPVOID FAR *iplpv 
	) 
	{
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) this ;
		}
		else if ( iid == IID_IWbemProviderInitSink )
		{
			*iplpv = ( LPVOID ) this ;		
		}	

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
	}

	STDMETHODIMP_( ULONG ) AddRef ()
	{
		return InterlockedIncrement ( & m_ReferenceCount ) ;
	}

	STDMETHODIMP_(ULONG) Release ()
	{
		LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
		if ( t_ReferenceCount == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return t_ReferenceCount ;
		}
	}

	void Wait ( DWORD a_Timeout = 300000 ) 
	{
		if ( WaitForSingleObject ( m_Event , a_Timeout ) == WAIT_TIMEOUT )
		{
			m_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	void Reset () 
	{
		ResetEvent ( m_Event ) ;
		m_Result = S_OK ;
	}

	HRESULT GetResult () { return m_Result ; }
} ;

class CProvider_IWbemServices : public IWbemServices , public IWbemPropertyProvider , public IWbemProviderInit , public IWbemShutdown
{
private:

	LONG m_ReferenceCount ;         //Object reference count

	WmiAllocator &m_Allocator ;

	CRITICAL_SECTION m_CriticalSection ;

	IWbemServices *m_CoreService ;

	BSTR m_Namespace ;
	BSTR m_Locale ;
	BSTR m_User ;

	BSTR m_ComputerName ;
	BSTR m_OperatingSystemVersion ;
	BSTR m_OperatingSystemRunning ;
	BSTR m_ProductName ;

	IWbemClassObject *m_Win32_Process_Object ;

private:

	HRESULT GetProductInformation () ;

	HRESULT GetProcessExecutable (

		HANDLE a_Process , 
		wchar_t *&a_ExecutableName
	) ;

	HRESULT CProvider_IWbemServices :: NextProcessBlock (

		SYSTEM_PROCESS_INFORMATION *a_ProcessBlock , 
		SYSTEM_PROCESS_INFORMATION *&a_NextProcessBlock
	) ;

	HRESULT GetProcessBlocks ( SYSTEM_PROCESS_INFORMATION *&a_ProcessInformation ) ;

	HRESULT GetProcessInformation (	SYSTEM_PROCESS_INFORMATION *&a_ProcessInformation ) ;

	HRESULT GetProcessParameters (

		HANDLE a_Process ,
		wchar_t *&a_ProcessCommandLine
	) ;

	HRESULT CreateInstanceEnumAsync_Process_Load (

		SYSTEM_PROCESS_INFORMATION *a_ProcessInformation ,
		IWbemClassObject *a_Instance 
	) ;

	HRESULT CreateInstanceEnumAsync_Process (

 		long a_Flags , 
		IWbemContext __RPC_FAR *a_Context,
		IWbemObjectSink FAR *a_Sink
	) ;

public:

	CProvider_IWbemServices ( WmiAllocator &a_Allocator  ) ;
    ~CProvider_IWbemServices () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE GetProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE PutProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;


#endif // _Provider_IWbemServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\queries\filtsink.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FILTSINK.CPP

Abstract:

History:

--*/

#include "filtsink.h"

CFilteringSink::~CFilteringSink()
{
    m_pFrontFilter->Release();
}

void* CFilteringSink::GetInterface(REFIID riid)
{
    if(riid == IID_IHmmEventSink)
    {
        return (IHmmEventSink*)&m_XEventSink;
    }
    else return NULL;
}

STDMETHODIMP CFilteringSink::XEventSink::Indicate(
                                IN long lNumObjects,
                                IN IHmmClassObject **apObjects)
{
    for(long l = 0; l < lNumObjects; l++)
    {
        IHmmClassObject* pObject = apObjects[l];
        IHmmPropertySource* pSource;
        pObject->QueryInterface(IID_IHmmPropertySource, (void**)&pSource);
        HRESULT hres = m_pObject->CheckAndSend(pSource, TRUE, NULL, NULL);
        pSource->Release();
        if(FAILED(hres)) return hres;
    }
    return HMM_S_NO_ERROR;
}

STDMETHODIMP CFilteringSink::XEventSink::IndicateRaw( 
                                IN long lNumObjects,
                                IN IHmmPropertySource **apObjects)
{
    for(long l = 0; l < lNumObjects; l++)
    {
        HRESULT hres = m_pObject->CheckAndSend(apObjects[l], TRUE, NULL, NULL);
        if(FAILED(hres)) return hres;
    }
    return HMM_S_NO_ERROR;
}

STDMETHODIMP CFilteringSink::XEventSink::IndicateWithHint( 
                                IN long lNumObjects,
                                IN IHmmClassObject *pObject,
                                IN IUnknown *pHint)
{
    // for now, ignore the hint
    return Indicate(1, &pObject);
}

STDMETHODIMP CFilteringSink::XEventSink::CheckObject( 
                                IN IHmmPropertySource *pSource,
                                OUT IHmmPropertyList **ppList,
                                OUT IUnknown **ppHint)
{
    return m_pObject->CheckAndSend(pSource, FALSE, ppList, ppHint);
}

STDMETHODIMP CFilteringSink::XEventSink::GetRequirements( 
                                IN IHmmFilter **ppRequirements)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFilteringSink::XEventSink::SetRequirementChangeSink( 
                                IN IHmmRequirementChangeSink *pNewSink,
                                OUT IHmmRequirementChangeSink **ppOldSink)
{
    if(ppOldSink)
    {
        *ppOldSink = m_pObject->m_pChangeSink;
    }
    else
    {
        if(m_pObject->m_pChangeSink) m_pObject->m_pChangeSink->Release();
    }
    m_pObject->m_pChangeSink = pNewSink;
    if(pNewSink) pNewSink->AddRef();
    return HMM_S_NO_ERROR;
}

STDMETHODIMP CFilteringSink::XEventSink::GetOptimizedSink(
                                IN IHmmFilter *pGuaranteedCondition,
                                IN long lFlags,
                                OUT IHmmEventSink **ppOptimizedSink)
{
    if(pGuaranteedCondition == NULL || ppOptimizedSink == NULL)
    {
        return HMM_E_INVALID_PARAMETER;
    }
    // For now: return ourselves
    *ppOptimizedSink = (IHmmEventSink*)this;
    AddRef();
    return HMM_S_NO_ERROR;
}

STDMETHODIMP CFilteringSink::XEventSink::GetUsefulSubsink( 
    long lIndex,
    long lFlags,
    IHmmEventSink **ppSubsink)
{
    // For now --- no useful subsinks
    *ppSubsink = NULL;
    return HMM_S_NO_MORE_DATA;
}


long CFilteringSink::AddSmartMember(IHmmEventSink* pSmartSink)
{
    CMember* pMember = new CMember(pSmartSink);
    m_apMembers.Add(pMember);
    NotifyChanged(NULL, pSmartSink);
    return m_apMembers.GetSize();
}

long CFilteringSink::AddDumbMember(IHmmRawObjectSink* pDumbSink)
{
    CMember* pMember = new CMember(pDumbSink);
    m_apMembers.Add(pMember);
    return m_apMembers.GetSize();
}
    
BOOL CFilteringSink::RemoveMember(long lIndex)
{
    CMember* pMember = m_apMembers[lIndex];
    if(pMember->m_bSmart)
        NotifyChanged(pMember->m_pSmartSink, NULL);
    m_apMembers.RemoveAt(lIndex);
    return TRUE;
}

void CFilteringSink::SetFrontFilter(IHmmFilter* pFilter)
{
    NotifyChanged(m_pFrontFilter, pFilter);
    if(pFilter) pFilter->AddRef();
    if(m_pFrontFilter) m_pFrontFilter->Release();
    m_pFrontFilter = pFilter;
}

HRESULT CFilteringSink::CheckAndSend(IHmmPropertySource* pSource, BOOL bSend,
        IHmmPropertyList** ppList, IUnknown** ppHint)
{
    if(ppList) *ppList = NULL;
    if(ppHint) *ppHint = NULL;

    HRESULT hres;
    BOOL bFound = FALSE;

    // Check the front filter first
    // ============================

    if(m_pFrontFilter)
    {
        hres = m_pFrontFilter->CheckObject(pSource, ppList, NULL);
        if(hres != HMM_S_NO_ERROR) return hres;
    }

    // Check individual members
    // ========================

    for(int i = 0; i < m_apMembers.GetSize(); i++)
    {
        CAnySink* pMember = m_apMembers[i];
        if(bSend)
        {
            // Just send it
            hres = pMember->Send(pSource, *ppList)
            if(FAILED(hres)) return hres;
        }
        else
        {
            IHmmFilter* pFilter = pMember->GetFilter();
            if(pFilter != NULL)
            {
                if(pFilter->CheckObject(pSource, NULL, NULL) == HMM_S_NO_ERROR)
                {
                    bFound = TRUE;
                }
                pFilter->Release();
            }
            else
            {
                bFound = TRUE;
            }
        }
    }

    if(bFound || bSend)
        return HMM_S_NO_ERROR;
    else
        return HMM_S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\queries\classinf.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CLASSINF.H

Abstract:

History:

--*/

#ifndef __HMM_CLASS_INFO__H_
#define __HMM_CLASS_INFO__H_

#include <windows.h>
#include <objbase.h>
#include "providl.h"
#include "unk.h"
#include "arrtempl.h"
#include "hmmstr.h"
#include <wstring.h>
#include "project.h"
#include "trees.h"

class CHmmClassInfo
{
protected:
    WString m_wsClassName;
    BOOL m_bIncludeChildren;
    CPropertyList m_Selected;

public:
    CHmmClassInfo(CLifeControl* pControl) 
        : m_bIncludeChildren(FALSE), m_Selected(pControl, NULL)
    {
        m_Selected.AddRef();
        if(pControl) pControl->Release(&m_Selected);
    }
    void SetControl(CLifeControl* pControl)
    {
        m_Selected.SetControl(pControl);
    }

    void Load(HMM_CLASS_INFO ci);
    void Save(HMM_CLASS_INFO& ci);

    inline CPropertyList& GetSelected() {return m_Selected;}
    inline WString& AccessClassName() {return m_wsClassName;}
    inline BOOL& AccessIncludeChildren() {return m_bIncludeChildren;}

public:
    static HRESULT CheckObjectAgainstMany(
                        IN long lNumInfos,
                        IN CHmmClassInfo** apInfos,
                        IN IHmmPropertySource* pSource, 
                        OUT IHmmPropertyList** ppList,
                        OUT long* plIndex);

    CHmmNode* GetTree();
};

//*****************************************************************************
//
//  IMPORTANT: there is an issue with someone holding on to a CPropertyList 
//      pointer while someone else calls RemoveAllInfos!
//
//*****************************************************************************


class CClassInfoFilter : public CUnk
{
protected:
    class XFilter : public CImpl<IHmmClassInfoFilter, CClassInfoFilter>
    {
    public:
        XFilter(CClassInfoFilter* pObj) 
            : CImpl<IHmmClassInfoFilter, CClassInfoFilter>(pObj){}
        STDMETHOD(CheckObject)(IN IHmmPropertySource* pObject, 
                                IN OUT IHmmPropertyList** ppList,
                                IN OUT IUnknown** ppHint);
        STDMETHOD(IsSpecial)();
        STDMETHOD(GetType)(OUT IID* piid);
        STDMETHOD(GetSelectedPropertyList)(
				IN long lFlags, // necessary, sufficient
                OUT IHmmPropertyList** ppList);

        STDMETHOD(GetClassInfos)(
                IN long lFirstIndex, 
				IN long lNumInfos,
				OUT long* plInfosReturned,
				OUT HMM_CLASS_INFO* aInfos);

    } m_XFilter;
    friend XFilter;

    class XConfigure : public CImpl<IConfigureHmmClassInfoFilter, CClassInfoFilter>
    {
    public:
        XConfigure(CClassInfoFilter* pObj) 
            : CImpl<IConfigureHmmClassInfoFilter, CClassInfoFilter>(pObj){}
        STDMETHOD(AddClassInfos)(IN long lNumInfos, IN HMM_CLASS_INFO* aInfos);
        STDMETHOD(RemoveAllInfos)();
    } m_XConfigure;
    friend XConfigure;

protected:
    CUniquePointerArray<CHmmClassInfo> m_apTokens; 
    CContainerControl m_MemberLife;

    CHmmNode* m_pTree;
    inline void InvalidateTree() {if(m_pTree) m_pTree->Release(); m_pTree = NULL;}
public:
    CClassInfoFilter(CLifeControl* pControl, IUnknown* pOuter) 
        : CUnk(pControl, pOuter), m_XFilter(this), m_XConfigure(this),
        m_MemberLife(GetUnknown()), m_pTree(NULL)
    {}
    ~CClassInfoFilter();

    void* GetInterface(REFIID riid);
    CHmmNode* GetTree();
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\queries\classinf.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CLASSINF.CPP

Abstract:

History:

--*/

#include "classinf.h"
#include "lazy.h"

void CHmmClassInfo::Load(HMM_CLASS_INFO ci)
{
    m_wsClassName = ci.m_wszClassName;
    m_bIncludeChildren = ci.m_bIncludeChildren;
    m_Selected.RemoveAllProperties();
    m_Selected.AddProperties(ci.m_lNumSelectedProperties, 
        ci.m_awszSelected);
}

void CHmmClassInfo::Save(HMM_CLASS_INFO& ci)
{
    ci.m_wszClassName = HmmStringCopy((LPCWSTR)m_wsClassName);
    ci.m_bIncludeChildren = m_bIncludeChildren;
    m_Selected.GetList(0, &ci.m_lNumSelectedProperties, 
        &ci.m_awszSelected);
}

HRESULT CHmmClassInfo::CheckObjectAgainstMany(
                        IN long lNumInfos,
                        IN CHmmClassInfo** apInfos,
                        IN IHmmPropertySource* pSource, 
                        OUT IHmmPropertyList** ppList,
                        OUT long* plIndex)
{
    if(ppList) *ppList = NULL;

    CLazyClassName ClassName(pSource);

    // Go through our tokens one by one
    // ================================

    BOOL bFound = FALSE;
    for(int i = 0; !bFound && i < lNumInfos; i++)
    {
        CHmmClassInfo* pToken = apInfos[i];

        if(pToken->m_bIncludeChildren)
        {
            bFound = (pSource->IsDerivedFrom(pToken->m_wsClassName) == 
                            HMM_S_NO_ERROR);
        }
        else
        {
            bFound = !wcsicmp(ClassName.GetName(), pToken->m_wsClassName);
        }

        if(bFound && ppList)
        {
            pToken->GetSelected().QueryInterface(IID_IHmmPropertyList, 
                (void**)ppList);
        }

    }

    if(bFound)
    {
        return HMM_S_NO_ERROR;
    }
    else
    {
        return HMM_S_FALSE;
    }
}

CHmmNode* CHmmClassInfo::GetTree()
{
    CSql1Token* pExpr = new CSql1Token;

    V_VT(&pExpr->m_vConstValue) = VT_BSTR;
    V_BSTR(&pExpr->m_vConstValue) = SysAllocString(m_wsClassName);

    if(m_bIncludeChildren)
    {
        pExpr->m_lOperator = SQL1_OPERATOR_INHERITSFROM;
        pExpr->m_wsProperty.Empty();
        pExpr->m_lPropertyFunction = pExpr->m_lConstFunction =
            SQL1_FUNCTION_NONE;
    }
    else
    {
        pExpr->m_lOperator = SQL1_OPERATOR_EQUALS;
        pExpr->m_wsProperty = L"__CLASS";
        pExpr->m_lPropertyFunction = pExpr->m_lConstFunction =
            SQL1_FUNCTION_UPPER;
    }

    pExpr->AddRef();
    return pExpr;
}



CClassInfoFilter::~CClassInfoFilter()
{
    if(m_pTree)
        m_pTree->Release();
}

void* CClassInfoFilter::GetInterface(REFIID riid)
{
    if(riid == IID_IHmmFilter || riid == IID_IHmmClassInfoFilter)
        return (IHmmClassInfoFilter*)&m_XFilter;
    else if(riid == IID_IConfigureHmmClassInfoFilter)
        return (IConfigureHmmClassInfoFilter*)&m_XConfigure;
    else 
        return NULL;
}

STDMETHODIMP CClassInfoFilter::XFilter::
CheckObject(IN IHmmPropertySource* pSource, OUT IHmmPropertyList** ppList,
            OUT IUnknown** ppHint)
{
    if(ppHint) *ppHint = NULL;

    return CHmmClassInfo::CheckObjectAgainstMany(
        m_pObject->m_apTokens.GetSize(), 
        m_pObject->m_apTokens.begin(),
        pSource, ppList, NULL);
}


STDMETHODIMP CClassInfoFilter::XFilter::
IsSpecial()
{
    if(m_pObject->m_apTokens.GetSize() == 0)
        return HMM_S_ACCEPTS_NOTHING;
    else
        return HMM_S_FALSE;
}

STDMETHODIMP CClassInfoFilter::XFilter::
GetSelectedPropertyList(IN long lFlags, OUT IHmmPropertyList** ppList)
{
    // Only implemented if one class info is present
    // =============================================

    if(m_pObject->m_apTokens.GetSize() == 1)
    {
        return m_pObject->m_apTokens[0]->GetSelected().
            QueryInterface(IID_IHmmPropertyList, (void**)ppList);
    }
    else
    {
        // Stubbed out
        // ===========

        CPropertyList* pList = new CPropertyList(m_pObject->m_pControl, NULL);
        pList->QueryInterface(IID_IHmmPropertyList, (void**)ppList);

        if(lFlags == HMM_FLAG_NECESSARY)
        {
            pList->RemoveAllProperties(); // no properties are "necessary"
        }
        else
        {
            pList->AddAllProperties();
        }

        return HMM_S_NO_ERROR;
    }
}

STDMETHODIMP CClassInfoFilter::XFilter::
GetType(OUT IID* piid)
{
    if(piid == NULL)
        return HMM_E_INVALID_PARAMETER;
    *piid = IID_IHmmClassInfoFilter;
    return HMM_S_NO_ERROR;
}

STDMETHODIMP CClassInfoFilter::XFilter::
GetClassInfos(IN long lFirstIndex, 
				IN long lNumInfos,
				OUT long* plInfosReturned,
				OUT HMM_CLASS_INFO* aInfos)
{
    if(plInfosReturned == NULL || aInfos == NULL || lFirstIndex < 0 ||
        lNumInfos < 0)
    {
        return HMM_E_INVALID_PARAMETER;
    }

    long lCurrentSize = m_pObject->m_apTokens.GetSize();
    if(lFirstIndex >= lCurrentSize)
        return HMM_S_NO_MORE_DATA;
    
    long lEndIndex = lFirstIndex + lNumInfos;
    if(lEndIndex > lCurrentSize)
        lEndIndex = lCurrentSize;

    for(long l = lFirstIndex; l < lEndIndex; l++)
    {
        m_pObject->m_apTokens[l]->Save(aInfos[l-lFirstIndex]);
    }

    *plInfosReturned = lEndIndex - lFirstIndex;
    return HMM_S_NO_ERROR;
}



STDMETHODIMP CClassInfoFilter::XConfigure::
AddClassInfos(long lNumInfos, IN HMM_CLASS_INFO* aInfos)
{
    if(lNumInfos <= 0 || aInfos == NULL) 
        return HMM_E_INVALID_PARAMETER;

    m_pObject->InvalidateTree();
    for(long l = 0; l < lNumInfos; l++)
    {
        // Create a new info object, setting our MemberLife as its life control
        // object. This will propagate his AddRef and Release calls to us.
        CHmmClassInfo* pNew = new CHmmClassInfo(&m_pObject->m_MemberLife);
        pNew->Load(aInfos[l]);
        m_pObject->m_apTokens.Add(pNew);
    }
    return HMM_S_NO_ERROR;
}

STDMETHODIMP CClassInfoFilter::XConfigure::
RemoveAllInfos()
{
    m_pObject->InvalidateTree();
    m_pObject->m_apTokens.RemoveAll();
    return HMM_S_NO_ERROR;
}

CHmmNode* CClassInfoFilter::GetTree()
{
    if(m_pTree)
    {
        m_pTree->AddRef();
        return m_pTree;
    }

    // Build it
    // ========

    CLogicalNode* pOr = new CLogicalNode;
    pOr->m_lTokenType = SQL1_OR;

    for(int i = 0; i < m_apTokens.GetSize(); i++)
    {
        CHmmClassInfo* pInfo = m_apTokens[i];
        CHmmNode* pExpr = pInfo->GetTree();
        pOr->Add(pExpr);
        pExpr->Release();
    }

    m_pTree = pOr;
    m_pTree->AddRef(); // for storage
    m_pTree->AddRef(); // for return
    return m_pTree;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\queries\filtsink.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FILTSINK.H

Abstract:

History:

--*/

#include <providl.h>
#include <unk.h>
#include <parmdefs.h>
#include "arrtempl.h"
#include <metadata.h>

class CAnySink
{
public:
    virtual RELEASE_ME IHmmFilter* GetFilter() = 0;
    virtual HRESULT Send(IHmmClassObject* pObject) = 0;
    virtual HRESULT Send(IHmmPropertySource* pSource, 
                         IHmmPropertyList* pList) = 0;
};

class CAnySinkContainer
{
public:
    virtual long AddMember(CAnySink* pSink) = 0;
    virtual BOOL RemoveMember(long lIndex) = 0;
    virtual BOOL RemoveMember(CAnySink* pSink) = 0;
    virtual INTERNAL GetMember(long lIndex) = 0;
};

class CAnySinkLocation
{
public:
    virtual BOOL RemoveSink(CAnySink* pSink) = 0;
};

class CAnySinkLocations
{
public:
    virtual void AddLocation(CAnySinkLocation* pLocation) = 0;
};

class CFilteringSink : public CUnk, public CAnySink, public CAnySinkContainer,
                        public CAnySinkLocation
{
protected:
    class XEventSink : public CImpl<IHmmEventSink, CFilteringSink>
    {
    public:
        XEventSink(CFilteringSink* pObj) 
            : CImpl<IHmmEventSink, CFilteringSink>(pObj)
        {}


        STDMETHOD(Indicate)( 
            long lNumObjects,
            IHmmClassObject **apObjects);
        STDMETHOD(IndicateRaw)( 
            long lNumObjects,
            IHmmPropertySource **apObjects);
        
        STDMETHOD(IndicateWithHint)( 
            long lNumObjects,
            IHmmClassObject *pObject,
            IUnknown *pHint);
        
        STDMETHOD(CheckObject)( 
            IHmmPropertySource *pSource,
            IHmmPropertyList **ppList,
            IUnknown **ppHint);
        
        STDMETHOD(GetRequirements)( 
            IHmmFilter **ppRequirements);
        
        STDMETHOD(SetRequirementChangeSink)( 
            IHmmRequirementChangeSink *pNewSink,
            IHmmRequirementChangeSink **ppOldSink);
        
        STDMETHOD(GetOptimizedSink)( 
            IHmmFilter *pGuaranteedCondition,
            long lFlags,
            IHmmEventSink **ppOptimizedSink);
        
        STDMETHOD(GetUsefulSubsink)( 
            long lIndex,
            long lFlags,
            IHmmEventSink **ppSubsink);
    } m_XEventSink;
    friend XEventSink;

protected:
    CUniquePointerArray<CAnySink> m_apMembers;
    IHmmFilter* m_pFrontFilter;
    IHmmFilter* m_pGuaranteedFilter;
    IHmmRequirementChangeSink* m_pChangeSink;
    CMetaData* m_pMeta;        

protected:
    inline void NotifyChanged(IHmmEventSink* pOld, IHmmEventSink* pNew){}
    inline void NotifyChanged(IHmmFilter* pOld, IHmmFilter* pNew){}

    HRESULT CheckAndSend(IHmmPropertySource* pSource, BOOL bSend, 
        IHmmPropertyList** ppList, IUnknown** ppHint);
public:
    CFilteringSink(CMetaData* pMeta, CLifeControl* pControl = NULL, 
                    IUnknown* pOuter = NULL)
        : CUnk(pControl, pOuter), m_XEventSink(this), m_pFrontFilter(NULL),
        m_pChangeSink(NULL), m_pMeta(pMeta)
    {}
    ~CFilteringSink();

    void* GetInterface(REFIID riid);

    // AnySinkContainer methods

    BOOL AddMember(CAnySink* pSink, CAnySinkLocations* pLocations);
    BOOL RemoveMember(long lIndex);
    BOOL RemoveMember(CAnySink* pSink);
    CAnySink* GetMember(long lIndex);

    void SetFrontFilter(IHmmFilter* pFilter);
    void SetGuaranteedFilter(IHmmFilter* pFilter);

    // AnySink methods

    RELEASE_ME IHmmFilter* GetFilter() 
        {return NULL;} // TBD
    HRESULT Send(IHmmClassObject* pObject) 
        {return m_XEventSink.Indicate(1, &pObject);}
    HRESULT Send(IHmmPropertySource* pSource, IHmmPropertyList* pList)
        {return m_XEventSink.IndicateRaw(1, &pSource);}

    // AnySinkLocation methods

    BOOL RemoveSink(CAnySink* pSink) {return RemoveMember(pSink);}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\queries\project.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    PROJECT.CPP

Abstract:

History:

--*/

#include "project.h"

void* CPropertyList::GetInterface(REFIID riid)
{
    if(riid == IID_IHmmPropertyList)
    {
        return (IHmmPropertyList*)&m_XList;
    }
    else if(riid == IID_IConfigureHmmProjector)
    {
        return (IConfigureHmmProjector*)&m_XConfigure;
    }
    else
    {
        return NULL;
    }
}

STDMETHODIMP CPropertyList::XPropertyList::
GetList(IN long lFlags, OUT long* plNumProps, OUT HMM_WSTR** pawszProps)
{
    if(plNumProps == NULL || pawszProps == NULL) 
        return HMM_E_INVALID_PARAMETER;

    *plNumProps = m_pObject->m_awsProperties.Size();
    *pawszProps = (HMM_WSTR*)CoTaskMemAlloc(sizeof(HMM_WSTR)* *plNumProps);
    for(long l = 0; l < *plNumProps; l++)
    {
        LPWSTR wszProp = m_pObject->m_awsProperties[l];
        (*pawszProps)[l] = HmmStringCopy(wszProp);
    }

    return HMM_S_NO_ERROR;
}

STDMETHODIMP CPropertyList::XPropertyList::
IsSelected(IN HMM_WSTR wszProperty)
{
    long lNumProps = m_pObject->m_awsProperties.Size();
    for(long l = 0; l < lNumProps; l++)
    {
        LPWSTR wszThis = m_pObject->m_awsProperties[l];
        int nLen = wcslen(wszThis);
        if(memcmp(wszThis, wszProperty, sizeof(WCHAR)*nLen) == 0)
        {
            if(nLen ==0 || wszProperty[nLen] == 0 || wszProperty[nLen] == L'.')
            {
                return HMM_S_NO_ERROR;
            }
        }
    }
    return HMM_S_FALSE;
}

STDMETHODIMP CPropertyList::XConfigure::
AddProperties(IN long lNumProps, IN HMM_WSTR* awszProps)
{
    if(awszProps == NULL)
        return HMM_E_INVALID_PARAMETER;

    for(long l = 0; l < lNumProps; l++)
    {
        m_pObject->m_awsProperties.Add(HmmStringCopy(awszProps[l]));
    }
    return HMM_S_NO_ERROR;
}

STDMETHODIMP CPropertyList::XConfigure::
RemoveAllProperties()
{
    m_pObject->m_awsProperties.Empty();
    return HMM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\queries\project.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    PROJECT.H

Abstract:

History:

--*/

#ifndef __HMM_PROJECTOR__H_
#define __HMM_PROJECTOR__H_

#include "unk.h"
#include "providl.h"
#include "hmmstr.h"
#include <arena.h>
#include <dbgalloc.h>
#include <flexarry.h>

class CPropertyList : public CUnk
{
protected:
    class XPropertyList : public CImpl<IHmmPropertyList, CPropertyList>
    {
    public:
        XPropertyList(CPropertyList* pObj) 
            : CImpl<IHmmPropertyList, CPropertyList>(pObj)
        {}

        STDMETHOD(GetList)(IN long lFlags, OUT long* plNumProps,
            OUT HMM_WSTR **pawszProperties);
        STDMETHOD(IsSelected)(IN HMM_WSTR wszPropertyName);
    } m_XList;
    friend XPropertyList;

    class XConfigure : public CImpl<IConfigureHmmProjector, CPropertyList>
    {
    public:
        XConfigure(CPropertyList* pObj)
            : CImpl<IConfigureHmmProjector, CPropertyList>(pObj)
        {}

        STDMETHOD(RemoveAllProperties)();
        STDMETHOD(AddProperties)(IN long lNumProps, 
            IN HMM_WSTR* awszProperties);
    } m_XConfigure;
    friend XConfigure;

    CWStringArray m_awsProperties;

public:
    CPropertyList(CLifeControl* pControl, IUnknown* pOuter) 
        : CUnk(pControl, pOuter), m_XList(this), m_XConfigure(this)
    {}
    ~CPropertyList(){}
    void* GetInterface(REFIID riid);

public:
    inline HRESULT RemoveAllProperties() 
        {return m_XConfigure.RemoveAllProperties();}
    inline HRESULT AddProperties(IN long lNumProps, 
                                 IN HMM_WSTR* awszProperties)
        {return m_XConfigure.AddProperties(lNumProps, awszProperties);}
    inline HRESULT GetList(IN long lFlags, OUT long* plNumProps,
                            OUT HMM_WSTR **pawszProperties)
        {return m_XList.GetList(lFlags, plNumProps, pawszProperties);}
    inline HRESULT IsSelected(IN HMM_WSTR wszProperty)
        {return m_XList.IsSelected(wszProperty);}
    inline HRESULT AddAllProperties()
    {
        RemoveAllProperties();
        HMM_WSTR wszNull = L"";
        AddProperties(1, &wszNull);
        return HMM_S_NO_ERROR;
    }
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\queries\main.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MAIN.CPP

Abstract:

History:

--*/

#include "dllmain.h"
#include <providl.h>
#include "classinf.h"
#include "sql1filt.h"
#include "clsfac.h"

void GlobalInitialize()
{
    AddClassInfo(
        CLSID_HmmClassInfoFilter, 
        new CClassFactory<CClassInfoFilter>(g_pLifeControl), 
        "ClassInfo Filter", 
        FALSE);

    AddClassInfo(
        CLSID_HmmSql1Filter, 
        new CClassFactory<CSql1Filter>(g_pLifeControl), 
        "SQL1 Filter", 
        FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\queries\metadata.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    METADATA.CPP

Abstract:

History:

--*/

#include "metadata.h"
#include <stdio.h>

HMM_CLASS_RELATION CMetaData::GetClassRelation(LPCWSTR wszClass1, 
                                               LPCWSTR wszClass2)
{
    char ch;
    printf("Is %S derived from %S? ", wszClass1, wszClass2);
    scanf("%c%*c", &ch);

    if(ch == 'y' || ch == 'Y')
        return SECOND_IS_PARENT;

    printf("Is %S derived from %S? ", wszClass2, wszClass1);
    scanf("%c%*c", &ch);

    if(ch == 'y' || ch == 'Y')
        return FIRST_IS_PARENT;
    else
        return SEPARATE_BRANCHES;
}

RELEASE_ME IHmmClassObject* CMetaData::ConvertSource(
                                               IHmmPropertySource* pSource,
                                               IHmmPropertyList* pList = NULL)
{
    HRESULT hres;
    VARIANT v;
    VariantInit(&v);

    // Get the class
    // =============

    if(FAILED(pSource->GetPropertyValue(L"__CLASS", 0, &v)))
        return NULL;
    if(V_VT(&v) != VT_BSTR)
    {
        VariantClear(&v);
        return NULL;
    }

    IHmmClassObject* pClass;
    hres = m_pNamespace->GetObject(V_BSTR(&v), 0, &pClass, NULL);
    VariantClear(&v);
    if(FAILED(hres)) 
        return NULL;

    // Spawn an instance
    // =================

    IHmmClassObject* pInstance;
    pClass->SpawnInstance(0, &pInstance);
    pClass->Release();

    // Either enumerate all properties in the list, or in the class
    // ============================================================

    if(pList != NULL)
    {
        long lNumProps;
        HMM_WSTR* aProps;
        pList->GetList(0, &lNumProps, &aProps);
        for(long l = 0; l < lNumProps; l++)
        {
            if(SUCCEEDED(pSource->PropertyValue(aProps[l], 0, &v)))
            {
                if(FAILED(pInstance->Put(aProps[l], 0, &v, 0)))
                {
                    // requested property not in the class. So what.
                }
            }
            else
            {
                // requested property not available. So what.
            }
            VariantClear(&v);
        }
    }
    else
    {
        pInstance->BeginEnumeration(HMM_FLAG_NONSYSTEM_ONLY);
        BSTR strName;
        while(pInstance->Next(&strName, NULL, NULL, NULL))
        {
            if(SUCCEEDED(pSource->PropertyValue(strName, 0, &v)))
            {
                if(FAILED(pInstance->Put(strName, 0, &v, 0)))
                {
                    // requested property not in the class. So what.
                }
            }
            else
            {
                // requested property not available. So what.
            }
            VariantClear(&v);
        }
    }

    return pInstance;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\queries\relation.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    RELATION.H

Abstract:

History:

--*/

#include <windows.h>

typedef enum
{
    VALUE_BOTH_FALSE = 0x1,
    VALUE_ONLY_FIRST = 0x2,
    VALUE_ONLY_SECOND = 0x4,
    VALUE_BOTH_TRUE = 0x8,
} HMM_TWO_VALUES;

class CTwoValues
{
public:
    inline static HMM_TWO_VALUES Combine(BOOL bFirst, BOOL bSecond)
    {
        return (HMM_TWO_VALUES)(1 << 
            ( (bFirst == TRUE) + (bSecond == TRUE) << 1 )
                                );
    }                                   
};

typedef enum
{
    RELATION_NONE = VALUE_BOTH_FALSE+VALUE_ONLY_FIRST+VALUE_ONLY_SECOND+VALUE_BOTH_TRUE,
    RELATION_EQUIVALENT = VALUE_BOTH_TRUE + VALUE_BOTH_FALSE,
    RELATION_CONTRARY = VALUE_ONLY_FIRST + VALUE_ONLY_SECOND,
    RELATION_FIRST_IMPLIES = RELATION_NONE - VALUE_ONLY_FIRST,
    RELATION_SECOND_IMPLIES = RELATION_NONE - VALUE_ONLY_SECOND,
    RELATION_NOT_BOTH = RELATION_NONE - VALUE_BOTH_TRUE,
    RELATION_AT_LEAST_ONE = RELATION_NONE - VALUE_BOTH_FALSE,
} HMM_RELATIONSHIP;

typedef enum
{
    VALUE_FALSE = FALSE, 
    VALUE_TRUE = TRUE,
    VALUE_INDETERMINATE,
} THREE_VALUED_BOOL;

class CRelationship
{
public:
    inline static BOOL AdmitsValue(HMM_RELATIONSHIP Rel, HMM_TWO_VALUES Vals)
    {
        return (Rel & Vals);
    }
    inline static HMM_RELATIONSHIP ReverseRoles(HMM_RELATIONSHIP Rel)
    {
        if(AdmitsValue(Rel, VALUE_ONLY_FIRST))
        {
            if(!AdmitsValue(Rel, VALUE_ONLY_SECOND))
                return (HMM_RELATIONSHIP)
                        (Rel - VALUE_ONLY_FIRST + VALUE_ONLY_SECOND);
        }
        else if(AdmitsValue(Rel, VALUE_ONLY_SECOND))
        {
            return (HMM_RELATIONSHIP)
                        (Rel - VALUE_ONLY_SECOND + VALUE_ONLY_FIRST);
        }
        return Rel;
    }

    inline static THREE_VALUED_BOOL ComputeOr(HMM_RELATIONSHIP Rel)
    {
        if(Rel == VALUE_BOTH_FALSE)
            return VALUE_FALSE;
        else if(AdmitsValue(Rel, VALUE_BOTH_FALSE))
            return VALUE_INDETERMINATE;
        else
            return VALUE_TRUE;
    }
    inline static THREE_VALUED_BOOL ComputeAnd(HMM_RELATIONSHIP Rel)
    {
        if(Rel == VALUE_BOTH_TRUE)
            return VALUE_TRUE;
        else if(AdmitsValue(Rel, VALUE_BOTH_TRUE))
            return VALUE_INDETERMINATE;
        else
            return VALUE_FALSE;
    }
    static inline HMM_RELATIONSHIP GetRelationshipOfFirstWithANDofSeconds(
        int nNumSeconds, HMM_RELATIONSHIP* aSeconds)
    {
        BOOL bBothTrue = TRUE;
        BOOL bOnlyFirst = FALSE;
        BOOL bOnlySecond = TRUE;
        BOOL bBothFalse = FALSE;
        for(int i = 0; i < nNumSeconds; i++)
        {
            bBothTrue &= AdmitsValue(aSeconds[i], VALUE_BOTH_TRUE);
            bOnlyFirst |= AdmitsValue(aSeconds[i], VALUE_ONLY_FIRST);
            bOnlySecond &= AdmitsValue(aSeconds[i], VALUE_ONLY_SECOND);
            bBothFalse |= AdmitsValue(aSeconds[i], VALUE_BOTH_FALSE);
        }
        int nResult = 0;
        if(bBothTrue) nResult += VALUE_BOTH_TRUE;
        if(bOnlyFirst) nResult += VALUE_ONLY_FIRST;
        if(bOnlySecond) nResult += VALUE_ONLY_SECOND;
        if(bBothFalse) nResult += VALUE_BOTH_FALSE;

        return (HMM_RELATIONSHIP)nResult;
    }

    static inline HMM_RELATIONSHIP GetRelationshipOfFirstWithORofSeconds(
        int nNumSeconds, HMM_RELATIONSHIP* aSeconds)
    {
        BOOL bBothTrue = FALSE;
        BOOL bOnlyFirst = TRUE;
        BOOL bOnlySecond = FALSE;
        BOOL bBothFalse = TRUE;
        for(int i = 0; i < nNumSeconds; i++)
        {
            bBothTrue |= AdmitsValue(aSeconds[i], VALUE_BOTH_TRUE);
            bOnlyFirst &= AdmitsValue(aSeconds[i], VALUE_ONLY_FIRST);
            bOnlySecond |= AdmitsValue(aSeconds[i], VALUE_ONLY_SECOND);
            bBothFalse &= AdmitsValue(aSeconds[i], VALUE_BOTH_FALSE);
        }
        int nResult = 0;
        if(bBothTrue) nResult += VALUE_BOTH_TRUE;
        if(bOnlyFirst) nResult += VALUE_ONLY_FIRST;
        if(bOnlySecond) nResult += VALUE_ONLY_SECOND;
        if(bBothFalse) nResult += VALUE_BOTH_FALSE;

        return (HMM_RELATIONSHIP)nResult;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\queries\metadata.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    METADATA.H

Abstract:

History:

--*/

#include <windows.h>
#include <objbase.h>
#include <providl.h>
#include <parmdefs.h>

typedef enum
{
    SEPARATE_BRANCHES, FIRST_IS_PARENT, SECOND_IS_PARENT
} HMM_CLASS_RELATION;

class CMetaData
{
protected:
    IHmmServices* m_pNamespace;

public:
    CMetaData(IHmmServices* pNamespace)
    {
        pNamespace->AddRef();
        m_pNamespace = pNamespace;
    }
    ~CMetaData()
    {
        m_pNamespace->Release();
    }

    HMM_CLASS_RELATION GetClassRelation(LPCWSTR wszClass1, LPCWSTR wszClass2);
    RELEASE_ME IHmmClassObject* ConvertSource(IHmmPropertySource* pSource, 
        IHmmPropertyList* pList = NULL);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\queries\lazy.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    LAZY.H

Abstract:

History:

--*/

#ifndef __HMM_LAZY__H_
#define __HMM_LAZY__H_

#include <windows.h>
#include <providl.h>
#include <parmdefs.h>

template<class TInterface>
class CSource
{
    RELEASE_ME TInterface* GetPointer();
};

template<class TInterface>
class CLazyInterface
{
private:
    IUnknown* m_pObject;
    REFIID m_iid;
    TInterface* m_pNewInterface;
    HRESULT m_hres;

public:
    inline CLazyInterface(STORE IUnknown* pObject, REFIID riid)
        : m_pObject(pObject), m_iid(riid), m_pNewInterface(NULL),
        m_hres(S_OK)
    {
    }
    inline ~CLazyInterface()
    {
        if(m_pNewInterface) m_pNewInterface->Release();
    }
    inline INTERNAL TInterface* GetInterface()
    {
        if(m_pNewInterface == NULL)
        {
            m_hres = m_pObject->QueryInterface(m_iid, 
                (void**)&m_pNewInterface);
        }
        
        return m_pNewInterface;
    }
    inline HRESULT GetErrorCode()
    {
        return m_hres;
    }        
};



class CLazyProperty
{
protected:
    IHmmPropertySource* m_pSource;
    LPWSTR m_wszPropName;
    VARIANT m_vValue;
    HRESULT m_hres;

public:
    CLazyProperty(STORE IHmmPropertySource* pSource, STORE LPWSTR wszPropName)
        : m_pSource(pSource), m_wszPropName(wszPropName), m_hres(S_OK)
    {
        VariantInit(&m_vValue);
    }
    ~CLazyProperty(){}

    inline INTERNAL const VARIANT& GetValue()
    {
        if(V_VT(&m_vValue) == VT_EMPTY)
        {
            m_hres = m_pSource->GetPropertyValue(m_wszPropName, 0, &m_vValue);
            if(FAILED(m_hres))
            {
                V_VT(&m_vValue) = VT_ERROR;
            }
        }
        return m_vValue;
    }
    inline HRESULT GetErrorCode()
    {
        GetValue();
        return m_hres;
    }
};

class CLazyClassName : public CLazyProperty
{
public:
    inline CLazyClassName(STORE IHmmPropertySource* pSource) 
        : CLazyProperty(pSource, L"__CLASS")
    {}
    inline INTERNAL BSTR GetName()
    {
        GetValue();
        if(FAILED(m_hres) || V_VT(&m_vValue) != VT_BSTR)
            return NULL;
        return V_BSTR(&m_vValue);
    }
};

class CLazyDerivation : public CLazyProperty
{
public:
    inline CLazyDerivation(STORE IHmmPropertySource* pSource)
        : CLazyProperty(pSource, L"__DERIVATION")
    {}
    inline BOOL Contains(LPCWSTR wszName)
    {
        GetValue();
        if(FAILED(m_hres) || V_VT(&m_vValue) != (VT_BSTR | VT_ARRAY))
            return NULL;

        SAFEARRAY* psa = V_ARRAY(&m_vValue);
        long lLBound, lUBound;
        SafeArrayGetLBound(psa, 1, &lLBound);
        SafeArrayGetUBound(psa, 1, &lUBound);
        BOOL bFound = FALSE;
        for(long lIndex = lLBound; !bFound && lIndex <= lUBound; lIndex++)
        {
            BSTR strDerived;
            SafeArrayGetElement(psa, &lIndex, &strDerived);
            BOOL bFound = !_wcsicmp(strDerived, wszName);
            SysFreeString(strDerived);
        }
        return bFound;
    }
};
    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\redirect\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\queries\sql1filt.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SQL1FILT.CPP

Abstract:

History:

--*/

#include "sql1filt.h"

void* CSql1Filter::GetInterface(REFIID riid)
{
    if(riid == IID_IHmmFilter || riid == IID_IHmmSql1Filter)
        return (IHmmSql1Filter*)&m_XFilter;
    else if(riid == IID_IConfigureHmmSql1Filter)
        return (IConfigureHmmSql1Filter*)&m_XConfigure;
    else if(riid == IID_IHmmParse)
        return (IHmmParse*)&m_XParse;
    else 
        return NULL;
}

STDMETHODIMP CSql1Filter::XFilter::
IsSpecial()
{
    if(m_pObject->m_apTokens.GetSize() == 0)
    {
        return HMM_S_ACCEPTS_EVERYTHING;
    }
    else
    {
        return HMM_S_FALSE;
    }
}

STDMETHODIMP CSql1Filter::XFilter::
CheckObject(IN IHmmPropertySource* pSource, 
            OUT IHmmPropertyList** ppList, OUT IUnknown** ppHint)
{
    if(ppHint) *ppHint = NULL;

    return m_pObject->Evaluate(FALSE, pSource, ppList);
}

STDMETHODIMP CSql1Filter::XFilter::
GetType(IID* piid)
{
    if(piid == NULL)
        return HMM_E_INVALID_PARAMETER;
    *piid = IID_IHmmSql1Filter;
    return HMM_S_NO_ERROR;
}

STDMETHODIMP CSql1Filter::XFilter::
GetSelectedPropertyList(IN long lFlags, OUT IHmmPropertyList** ppList)
{
    return m_pObject->m_TargetClass.GetSelected().QueryInterface(
        IID_IHmmPropertyList,
        (void**)ppList);
}

STDMETHODIMP CSql1Filter::XFilter::
GetTargetClass(OUT HMM_CLASS_INFO* pTargetClass)
{
    if(pTargetClass == NULL)
        return HMM_E_INVALID_PARAMETER;

    m_pObject->m_XParse.EnsureTarget();
    m_pObject->m_TargetClass.Save(*pTargetClass);
    return HMM_S_NO_ERROR;
}

STDMETHODIMP CSql1Filter::XFilter::
GetTokens(IN long lFirstIndex, IN long lNumTokens, OUT long* plTokensReturned,
          OUT HMM_SQL1_TOKEN* aTokens)
{
    if(plTokensReturned == NULL || lNumTokens <= 0 || lFirstIndex < 0 ||
        aTokens == NULL)
    {
        return HMM_E_INVALID_PARAMETER;
    }

    m_pObject->m_XParse.EnsureWhere();

    long lHaveTokens = m_pObject->m_apTokens.GetSize();
    if(lFirstIndex >= lHaveTokens)
    {
        *plTokensReturned = 0;
        return HMM_S_NO_MORE_DATA;
    }

    long lGaveTokens = 0;
    long lCurrentIndex = lFirstIndex;
    while(lGaveTokens < lNumTokens && lCurrentIndex < lHaveTokens)
    {
        CSql1Token* pToken = m_pObject->m_apTokens[lCurrentIndex];
        if(pToken->m_lTokenType != TOKENTYPE_SPECIAL)
        {
            pToken->Save(aTokens[lGaveTokens++]);
        }
        lCurrentIndex++;
    }

    *plTokensReturned = lGaveTokens;
    return HMM_S_NO_ERROR;
}

//********************************* Configuration ******************************

STDMETHODIMP CSql1Filter::XConfigure::
SetTargetClass(IN HMM_CLASS_INFO* pTargetClass)
{
    if(pTargetClass == NULL)
        return HMM_E_INVALID_PARAMETER;

    m_pObject->m_TargetClass.Load(*pTargetClass);
    m_pObject->InvalidateTree();
    return HMM_S_NO_ERROR;
}

STDMETHODIMP CSql1Filter::XConfigure::
AddTokens(IN long lNumTokens, IN HMM_SQL1_TOKEN* aTokens)
{
    if(lNumTokens <= 0 || aTokens == NULL) 
        return HMM_E_INVALID_PARAMETER;

    for(long l = 0; l < lNumTokens; l++)
    {
        m_pObject->m_apTokens.Add(new CSql1Token(aTokens[l]));
    }
    m_pObject->InvalidateTree();
    return HMM_S_NO_ERROR;
}

STDMETHODIMP CSql1Filter::XConfigure::
RemoveAllTokens()
{
    m_pObject->m_apTokens.RemoveAll();
    m_pObject->InvalidateTree();
    return HMM_S_NO_ERROR;
}

STDMETHODIMP CSql1Filter::XConfigure::
RemoveAllProperties()
{
    return m_pObject->m_TargetClass.GetSelected().RemoveAllProperties();
}

STDMETHODIMP CSql1Filter::XConfigure::
AddProperties(IN long lNumProps, HMM_WSTR* awszProps)
{
    return m_pObject->m_TargetClass.GetSelected().
        AddProperties(lNumProps, awszProps);
}

//*********************************** Parsing *********************************


STDMETHODIMP CSql1Filter::XParse::
Parse(IN HMM_WSTR wszText, IN long lFlags)
{
    delete m_pParser;
    m_pParser = NULL;

    if((lFlags & HMM_FLAG_LAZY) == 0)
    {
        m_wsText.Empty();
        m_nStatus = not_parsing;

        m_pObject->InvalidateTree();
        CAbstractSql1Parser Parser(new CTextLexSource(wszText));
        int nRes = Parser.Parse(this, CAbstractSql1Parser::FULL_PARSE);
        m_InnerStack.Empty();
        return ParserError(nRes);
    }
    else
    {
        m_wsText = wszText;
        m_pParser = new CAbstractSql1Parser(new CTextLexSource((LPWSTR)m_wsText));
        m_nStatus = at_0;
        return HMM_S_NO_ERROR;
    }
}

void CSql1Filter::XParse::SetClassName(LPCWSTR wszClass)
{
    m_pObject->m_TargetClass.AccessClassName() = (LPWSTR)wszClass;
    m_pObject->m_TargetClass.AccessIncludeChildren() = TRUE;
}

void CSql1Filter::XParse::AddToken(COPY const HMM_SQL1_TOKEN& Token)
{
    m_pObject->m_apTokens.Add(new CSql1Token(Token));
    if(Token.m_lTokenType == SQL1_OR || Token.m_lTokenType == SQL1_AND)
    {
        // Find the inner guy
        // ==================

        long lInnerIndex;
        if(!m_InnerStack.Pop(lInnerIndex))
            return;

        V_I4(&m_pObject->m_apTokens[lInnerIndex]->m_vConstValue) = 
            m_pObject->m_apTokens.GetSize();
    }
}

void CSql1Filter::XParse::AddProperty(COPY LPCWSTR wszProperty)
{
    m_pObject->m_TargetClass.GetSelected().
        AddProperties(1, (LPWSTR*)&wszProperty);
}

void CSql1Filter::XParse::AddAllProperties()
{
    m_pObject->m_TargetClass.GetSelected().AddAllProperties();
}

void CSql1Filter::XParse::InOrder(long lOp)
{
    /*
    CSql1Token* pToken = new CSql1Token;
    pToken->m_lTokenType = TOKENTYPE_SPECIAL;
    pToken->m_lOperator = lOp;
    V_I4(&pToken->m_vConstValue) = -1;
    m_InnerStack.Push(m_pObject->m_apTokens.GetSize());
    m_pObject->m_apTokens.Add(pToken);
    */
}

HRESULT CSql1Filter::XParse::EnsureTarget()
{
    if(m_nStatus == at_0)
    {
        m_pObject->InvalidateTree();
        int nRes = m_pParser->Parse(this, CAbstractSql1Parser::NO_WHERE);
        m_nStatus = at_where;
        return ParserError(nRes);
    }
    else return HMM_S_NO_ERROR;
}

HRESULT CSql1Filter::XParse::EnsureWhere()
{
    if(m_nStatus == not_parsing)
    {
        return HMM_S_NO_ERROR;
    }
    else
    {
        m_pObject->InvalidateTree();
        int nRes = m_pParser->Parse(this, 
            (m_nStatus == at_0)?CAbstractSql1Parser::FULL_PARSE
                               :CAbstractSql1Parser::JUST_WHERE);
        m_InnerStack.Empty();
        delete m_pParser;
        m_pParser = NULL;
        m_nStatus = not_parsing;
        return ParserError(nRes);
    }
}

HRESULT CSql1Filter::XParse::ParserError(int nRes)
{
    switch(nRes)
    {
    case CAbstractSql1Parser::SUCCESS:
        return HMM_S_NO_ERROR;
    case CAbstractSql1Parser::SYNTAX_ERROR:
        return HMM_E_INVALID_QUERY;
    case CAbstractSql1Parser::LEXICAL_ERROR:
        return HMM_E_INVALID_QUERY;
    case CAbstractSql1Parser::FAILED:
        return HMM_E_FAILED;
    default:
        return HMM_E_CRITICAL_ERROR;
    }
}
        

CSql1Filter::XParse::~XParse()
{
    delete m_pParser;
}

//*****************************************************************************
//*************************** Query Evaluator *********************************
//*****************************************************************************
//*****************************************************************************
//
//  See sql1eveal.h for documentation
//
//*****************************************************************************

HRESULT CSql1Filter::Evaluate(BOOL bSkipTarget,
                                  IN READ_ONLY IHmmPropertySource* pPropSource, 
                                  OUT IHmmPropertyList** ppList)
{
    HRESULT hres;

    GetTree();
    if(m_pTree) m_pTree->Release();

    if(ppList) *ppList = NULL;

    hres = CHmmNode::EvaluateNode(m_pTree, pPropSource);
    if(hres != HMM_S_NO_ERROR) return hres;

    if(ppList)
    {
        m_TargetClass.GetSelected().QueryInterface(IID_IHmmPropertyList, 
            (void**)ppList);
    }

    return HMM_S_NO_ERROR;


    if(!bSkipTarget)
    {
        // Check the class of the object
        // =============================

        hres = m_XParse.EnsureTarget();
        if(FAILED(hres)) return hres;

        CHmmClassInfo* pInfo = &m_TargetClass;
        hres = CHmmClassInfo::CheckObjectAgainstMany(1, &pInfo, 
            pPropSource, ppList, NULL);
        if(hres != HMM_S_NO_ERROR)
        {
            // Either an error or a simple class mismatch
            // ==========================================
    
            return hres;
        }
    }

    // Now go for the expression
    // =========================

    hres = m_XParse.EnsureWhere();
    if(FAILED(hres)) return hres;

    int nNumTokens = m_apTokens.GetSize();

    if(nNumTokens == 0)
    {
        // Empty query
        // ===========

        return HMM_S_NO_ERROR;
    }

    // Allocate boolean stack of appropriate length
    // ============================================

    CBooleanStack Stack(nNumTokens);

    for(int nTokenIndex = 0; nTokenIndex < nNumTokens; nTokenIndex++)
    {
        CSql1Token* pToken = m_apTokens[nTokenIndex];
        BOOL bVal1, bVal2;

        switch(pToken->m_lTokenType)
        {
        case SQL1_AND:
            // Pop the last two operands and AND them together
            // ===============================================

            if(!Stack.Pop(bVal1) || !Stack.Pop(bVal2))
            {
                return HMM_E_INVALID_QUERY;
            }

            Stack.Push(bVal1 && bVal2);
            break;

        case SQL1_OR:
            // Pop the last two operands and OR them together
            // ===============================================

            if(!Stack.Pop(bVal1) || !Stack.Pop(bVal2))
            {
                return HMM_E_INVALID_QUERY;
            }

            Stack.Push(bVal1 || bVal2);
            break;

        case SQL1_NOT:
            // Pop the last value and invert it
            // ================================

            if(!Stack.Pop(bVal1))
            {
                return HMM_E_INVALID_QUERY;
            }

            Stack.Push(!bVal1);
            break;

        case SQL1_OP_EXPRESSION:
            // Evaluate the expression and push its value
            // ==========================================

            hres = pToken->Evaluate(pPropSource);
            if(FAILED(hres)) return hres;
            bVal1 = (hres == HMM_S_NO_ERROR);

            Stack.Push(bVal1);
            break;

        case TOKENTYPE_SPECIAL:
            if(!Stack.Pop(bVal1))
            {
                return HMM_E_INVALID_QUERY;
            }
            Stack.Push(bVal1);
            if((pToken->m_lOperator == SQL1_OR && bVal1) ||
                (pToken->m_lOperator == SQL1_AND && !bVal1))
            {
                nTokenIndex = V_I4(&pToken->m_vConstValue) - 1;
            }
            break;
        }
    }

    // All tokens have been processed. There better be one element on the stack
    // ========================================================================

    BOOL bResult;
    if(!Stack.Pop(bResult))
    {
        return HMM_E_INVALID_QUERY;
    }

    if(!Stack.IsEmpty())
    {
        return HMM_E_INVALID_QUERY;
    }

    if(bResult)
        return HMM_S_NO_ERROR;
    else
        return HMM_S_FALSE;
}



CHmmNode* CSql1Filter::GetTree()
{
    if(m_pTree != NULL)
    {
        m_pTree->AddRef();
        return m_pTree;
    }

    // Construct the tree from the RPN
    // ===============================

    CUniquePointerStack<CHmmNode> aNodes(m_apTokens.GetSize());
    CHmmNode* pNode1;
    CHmmNode* pNode2;
    CLogicalNode* pNewNode;
    CSql1Token* pNewToken;

    for(int i = 0; i < m_apTokens.GetSize(); i++)
    {
        CSql1Token* pToken = m_apTokens[i];
        switch(pToken->m_lTokenType)
        {
        case SQL1_OR:
        case SQL1_AND:
            if(!aNodes.Pop(pNode2)) return NULL;
            if(!aNodes.Pop(pNode1)) return NULL;
            pNewNode = new CLogicalNode;
            pNewNode->m_lTokenType = pToken->m_lTokenType;
            pNewNode->Add(pNode1);
            pNewNode->Add(pNode2);
            aNodes.Push(pNewNode);
            break;
        case SQL1_NOT:
            if(!aNodes.Pop(pNode1)) return NULL;
            pNode1->Negate();
            aNodes.Push(pNode1);
            break;

        case SQL1_OP_EXPRESSION:
            pNewToken = new CSql1Token(*pToken);
            aNodes.Push(pNewToken);
            break;
        default:
            return NULL;
        }
    }

    CHmmNode* pWhere;
    if(!aNodes.Pop(pWhere))
    {
        if(i == 0)
            pWhere = NULL;
        else 
            return NULL;
    }
    if(!aNodes.IsEmpty()) return NULL;

    // Add the class check
    // ===================

    CHmmNode* pTarget = m_TargetClass.GetTree();

    CLogicalNode* pMain = new CLogicalNode;
    pMain->m_lTokenType = SQL1_AND;
    pMain->Add(pTarget);
    pTarget->Release(); // Matching GetTree()
    if(pWhere)
    {
        pMain->Add(pWhere);
    }

    m_pTree = pMain;
    m_pTree->AddRef(); // for storage
    m_pTree->AddRef(); // for return

    m_pTree->Print(stdout, 0);
    return m_pTree;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\redirect\precomp.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\queries\stackt.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STACKT.H

Abstract:

History:

--*/

#ifndef __HMM_STACK_TEMPL__H_
#define __HMM_STACK_TEMPL__H_

#include <windows.h>

template<class TElement>
class CHmmStack
{
protected:
    TElement* m_aStack;
    int m_nSize;
    int m_nIndex;
public:
    inline CHmmStack(int nSize)
    {
        m_nSize = nSize;
        m_aStack = new TElement[nSize];
        m_nIndex = 0;
    }
    virtual ~CHmmStack()
    {
        delete [] m_aStack;
    }

    inline BOOL Push(IN const TElement& Val)
    {
        if(m_nIndex == m_nSize)
        {
            return FALSE;
        }
        else
        {
            m_aStack[m_nIndex++] = Val;
            return TRUE;
        }
    }

    inline BOOL Pop(OUT TElement& Val)
    {
        if(m_nIndex == 0)
        {
            return FALSE;
        }
        else
        {
            Val = m_aStack[--m_nIndex];
            return TRUE;
        }
    }
    inline BOOL Peek(OUT TElement& Val)
    {
        if(m_nIndex == 0)
        {
            return FALSE;
        }
        else
        {
            Val = m_aStack[m_nIndex-1];
            return TRUE;
        }
    }
    inline void PopToSize(int nNewSize)
    {
        m_nIndex = nNewSize;
    }
    inline BOOL IsEmpty() {return m_nIndex == 0;}
    inline void Empty() {m_nIndex = 0;}
    inline int GetSize() {return m_nIndex;}
};

template<class TPointee>
class CUniquePointerStack : public CHmmStack<TPointee*>
{
public:
    CUniquePointerStack<TPointee>(int nSize) 
        : CHmmStack<TPointee*>(nSize){}
    ~CUniquePointerStack<TPointee>()
    {
        for(int i = 0; i < m_nIndex; i++)
        {
            delete m_aStack[i];
        }
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\queries\sql1filt.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SQL1FILT.H

Abstract:

History:

--*/

#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include "providl.h"
#include "unk.h"
#include "arrtempl.h"
#include "hmmstr.h"
#include <wstring.h>
#include <genlex.h>
#include <sql_1.h>
#include <parmdefs.h>
#include <classinf.h>
#include <stackt.h>
#include <trees.h>

#define TOKENTYPE_SPECIAL -1

class CSql1Filter : public CUnk
{
protected:
    class XFilter : public CImpl<IHmmSql1Filter, CSql1Filter>
    {
    public:
        XFilter(CSql1Filter* pObj) 
            : CImpl<IHmmSql1Filter, CSql1Filter>(pObj){}

        STDMETHOD(CheckObject)(IN IHmmPropertySource* pObject, 
                                OUT IHmmPropertyList** ppList,
                                OUT IUnknown** ppHint);
        STDMETHOD(IsSpecial)();
        STDMETHOD(GetType)(OUT IID* piid);
        STDMETHOD(GetSelectedPropertyList)(
				IN long lFlags, // necessary, sufficient
                OUT IHmmPropertyList** ppList);

        STDMETHOD(GetTargetClass)(OUT HMM_CLASS_INFO* pTargetClass);
        STDMETHOD(GetTokens)(IN long lFirstIndex, IN long lNumTokens,
            OUT long* plTokensReturned, OUT HMM_SQL1_TOKEN* aTokens);
    } m_XFilter;
    friend XFilter;

    class XConfigure : public CImpl<IConfigureHmmSql1Filter, CSql1Filter>
    {
    public:
        XConfigure(CSql1Filter* pObj) 
            : CImpl<IConfigureHmmSql1Filter, CSql1Filter>(pObj){}

        STDMETHOD(SetTargetClass)(IN HMM_CLASS_INFO* pTargetClass);
        STDMETHOD(AddTokens)(IN long lNumTokens, IN HMM_SQL1_TOKEN* aTokens);
        STDMETHOD(RemoveAllTokens)();
        STDMETHOD(AddProperties)(IN long lNumProps, IN HMM_WSTR* awszProps);
        STDMETHOD(RemoveAllProperties)();
    } m_XConfigure;
    friend XConfigure;

    class XParse : public CImpl<IHmmParse, CSql1Filter>, public CSql1ParseSink
    {
    protected:
        WString m_wsText;
        CAbstractSql1Parser* m_pParser;
        enum {not_parsing, at_0, at_where} m_nStatus;
        CHmmStack<long> m_InnerStack;

    public:
        XParse(CSql1Filter* pObj) 
            : CImpl<IHmmParse, CSql1Filter>(pObj), m_nStatus(not_parsing),
            m_pParser(NULL), m_InnerStack(100)
        {}
        ~XParse();

        STDMETHOD(Parse)(IN HMM_WSTR wszText, IN long lFlags);        

    public:
        HRESULT EnsureTarget();
        HRESULT EnsureWhere();
        HRESULT ParserError(int nError);

        void SetClassName(COPY LPCWSTR wszClass);
        void AddToken(COPY const HMM_SQL1_TOKEN& Token);
        void AddProperty(COPY LPCWSTR wszProperty);
        void AddAllProperties();
        void InOrder(long lOp);

    } m_XParse;
    friend XParse;

protected:
    typedef CHmmStack<BOOL> CBooleanStack;

    HRESULT EvaluateExpression(READ_ONLY CSql1Token* pToken, 
                            READ_ONLY IHmmPropertySource* pPropSource,
                            OUT BOOL& bResult);
    HRESULT EvaluateFunction(IN long lFunctionID, 
                         IN READ_ONLY VARIANT* pvArg,
                         OUT INIT_AND_CLEAR_ME VARIANT* pvDest);

    CHmmNode* GetTree();

protected:
    CUniquePointerArray<CSql1Token> m_apTokens; 
    CContainerControl m_ContainerControl;
    CHmmClassInfo m_TargetClass;
protected:
    CHmmNode* m_pTree;

    inline void InvalidateTree() 
        {if(m_pTree) m_pTree->Release(); m_pTree = NULL;}

public:
    CSql1Filter(CLifeControl* pControl, IUnknown* pOuter) 
        : CUnk(pControl, pOuter), m_XFilter(this), m_XConfigure(this), 
        m_XParse(this), m_ContainerControl(GetUnknown()), 
        m_TargetClass(NULL), m_pTree(NULL)
    {}
    ~CSql1Filter(){}

    void* GetInterface(REFIID riid);
    BOOL OnInitialize()
    {    
        m_TargetClass.SetControl(&m_ContainerControl);
        return TRUE;
    }

    HRESULT Evaluate(BOOL bSkipTarget, 
        IN IHmmPropertySource* pPropSource, OUT IHmmPropertyList** ppList);
    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\queries\trees.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TREES.CPP

Abstract:

History:

--*/

#include <objbase.h>
#include "trees.h"
#include "hmmstr.h"
#include "stackt.h"

class CTreeInstruction
{
public:
    enum {INST_PUSH = SQL1_OP_EXPRESSION, 
        INST_AND = SQL1_AND, 
        INST_OR = SQL1_OR
    };
    int m_nInst;
    union
    {
        int m_nArg;
        CHmmNode* m_pArg;
    };
};

HRESULT CHmmNode::EvaluateNode(CHmmNode* pNode, IHmmPropertySource* pSource)
{
    if(pNode == NULL) return HMM_S_NO_ERROR;

    CHmmStack<CTreeInstruction> m_aInstructions(100);
    BOOL bResult;

    CTreeInstruction Inst;
    Inst.m_nInst = CTreeInstruction::INST_PUSH;
    Inst.m_pArg = pNode;
    m_aInstructions.Push(Inst);

    while(!m_aInstructions.IsEmpty())
    {
        CTreeInstruction Inst;
        m_aInstructions.Pop(Inst);

        int i;
        int nCurrentPos;
        int nNumChildren;
        CHmmNode* pCurrentNode;
        CLogicalNode* pLogNode;

        switch(Inst.m_nInst)
        {
        case CTreeInstruction::INST_OR:
            if(bResult)
            {
                m_aInstructions.PopToSize(Inst.m_nArg);
            }
            break;

        case CTreeInstruction::INST_AND:
            if(!bResult)
            {
                m_aInstructions.PopToSize(Inst.m_nArg);
            }
            break;

        case CTreeInstruction::INST_PUSH:
            pCurrentNode = Inst.m_pArg;
            switch(pCurrentNode->m_lTokenType)
            {
            case SQL1_AND:
            case SQL1_OR:
                pLogNode = (CLogicalNode*)pCurrentNode;
                nNumChildren = pLogNode->m_apChildren.GetSize();
                nCurrentPos = m_aInstructions.GetSize();

                for(i = nNumChildren-1; i >= 0; i--)
                {
                    Inst.m_nInst = CTreeInstruction::INST_PUSH;
                    Inst.m_pArg = pLogNode->m_apChildren[i];
                    m_aInstructions.Push(Inst);

                    if(i != 0)
                    {
                        Inst.m_nInst = pLogNode->m_lTokenType;
                        Inst.m_nArg = nCurrentPos;
                        m_aInstructions.Push(Inst);
                    }
                }
                break;
            default:
                bResult = (pCurrentNode->Evaluate(pSource) == HMM_S_NO_ERROR);
                break;
            }
            break;
        }
    }

    if(bResult)
        return HMM_S_NO_ERROR;
    else 
        return HMM_S_FALSE;
}

void CHmmNode::PrintOffset(int nOffset)
{
    for(int i = 0; i < nOffset; i++)
    {
        printf("  ");
    }
}

HMM_RELATIONSHIP CHmmNode::RelateNodes(CHmmNode* pFirst, CHmmNode* pSecond,
                                       CMetaData* pMeta)
{
    if(pFirst->m_lTokenType == SQL1_OP_EXPRESSION)
    {
        if(pSecond->m_lTokenType == SQL1_OP_EXPRESSION)
        {
            // They can compare themselves
            // ===========================

            return CSql1Token::ComputeRelation((CSql1Token*)pFirst,
                (CSql1Token*)pSecond, pMeta);
        }
        else 
        {
            // Swap them to merge with the other case
            // ======================================

            HMM_RELATIONSHIP InverseRel = RelateNodes(pSecond, pFirst, pMeta);
            return CRelationship::ReverseRoles(InverseRel);
        }
    }
    else 
    {
        // Relate to all the children of the first
        // =======================================

        CLogicalNode* pFirstLog = (CLogicalNode*)pFirst;
        int nNumChildren = pFirstLog->m_apChildren.GetSize();
        HMM_RELATIONSHIP* aChildRels = new HMM_RELATIONSHIP[nNumChildren];
        for(int i = 0; i < nNumChildren; i++)
        {
            aChildRels[i] = RelateNodes(pFirstLog->m_apChildren[i], pSecond,
                                        pMeta);
        }

        // Combine the results
        // ===================

        HMM_RELATIONSHIP nResult;
        if(pFirstLog->m_lTokenType == SQL1_AND)
        {
            nResult = CRelationship::GetRelationshipOfFirstWithANDofSeconds(
                nNumChildren, aChildRels);
        }
        else
        {
            nResult = CRelationship::GetRelationshipOfFirstWithORofSeconds(
                nNumChildren, aChildRels);
        }
        delete [] aChildRels;
        return nResult;
    }
}


void CLogicalNode::Add(CHmmNode* pNode)
{
    if(pNode == NULL)
        return;

    if(pNode->m_lTokenType != m_lTokenType)
    {
        m_apChildren.Add(pNode);
        return;
    }

    // Copy the children
    // =================

    CLogicalNode* pLogNode = (CLogicalNode*)pNode;
    for(int i = 0; i < pLogNode->m_apChildren.GetSize(); i++)
    {
        Add(pLogNode->m_apChildren[i]);
    }
}

HRESULT CLogicalNode::Evaluate(IHmmPropertySource* pSource)
{
    if(m_lTokenType == SQL1_AND)
    {
        for(int i = 0; i < m_apChildren.GetSize(); i++)
        {
            HRESULT hres = m_apChildren[i]->Evaluate(pSource);
            if(hres != HMM_S_NO_ERROR) return hres;
        }
        return HMM_S_NO_ERROR;
    }
    else
    {
        for(int i = 0; i < m_apChildren.GetSize(); i++)
        {
            HRESULT hres = m_apChildren[i]->Evaluate(pSource);
            if(hres != HMM_S_FALSE) return hres;
        }
        return HMM_S_NO_ERROR;
    }
}

HRESULT CLogicalNode::Negate()
{
    for(int i = 0; i < m_apChildren.GetSize(); i++)
    {
        HRESULT hres = m_apChildren[i]->Negate();
        if(hres != HMM_S_FALSE) return hres;
    }

    if(m_lTokenType == SQL1_AND)
        m_lTokenType = SQL1_OR;
    else
        m_lTokenType = SQL1_AND;
    return HMM_S_NO_ERROR;
}

void CLogicalNode::Print(FILE* f, int nOffset)
{
    PrintOffset(nOffset);
    printf("%s\n", (m_lTokenType == SQL1_AND)?"AND":"OR");
    for(int i = 0; i < m_apChildren.GetSize(); i++)
    {
        m_apChildren[i]->Print(f, nOffset+1);
    }
}
    

CSql1Token::CSql1Token()
{
    m_lTokenType = SQL1_OP_EXPRESSION;
    VariantInit(&m_vConstValue);
}

CSql1Token::CSql1Token(const CSql1Token& Token)
{
    m_lTokenType = Token.m_lTokenType;
    if(m_lTokenType == SQL1_OP_EXPRESSION)
    {
        m_wsProperty = Token.m_wsProperty;
        m_lOperator = Token.m_lOperator;
        VariantInit(&m_vConstValue);
        VariantCopy(&m_vConstValue, (VARIANT*)&Token.m_vConstValue);
        m_lPropertyFunction = Token.m_lPropertyFunction;
        m_lConstFunction = Token.m_lConstFunction;
    }
}
CSql1Token::CSql1Token(const HMM_SQL1_TOKEN& Token)
{
    VariantInit(&m_vConstValue);
    Load(Token);
}

CSql1Token::~CSql1Token()
{
    VariantClear(&m_vConstValue);
}

void CSql1Token::Load(const HMM_SQL1_TOKEN& Token)
{
    m_lTokenType = Token.m_lTokenType;
    if(m_lTokenType == SQL1_OP_EXPRESSION)
    {
        m_wsProperty = Token.m_wszProperty;
        m_lOperator = Token.m_lOperator;
        VariantCopy(&m_vConstValue, (VARIANT*)&Token.m_vConstValue);
        m_lPropertyFunction = Token.m_lPropertyFunction;
        m_lConstFunction = Token.m_lConstFunction;
    }
}

void CSql1Token::Save(HMM_SQL1_TOKEN& Token)
{
    Token.m_lTokenType = m_lTokenType;
    if(m_lTokenType == SQL1_OP_EXPRESSION)
    {
        Token.m_wszProperty = HmmStringCopy(m_wsProperty);
        Token.m_lOperator = m_lOperator;
        VariantInit(&Token.m_vConstValue);
        VariantCopy(&Token.m_vConstValue, &m_vConstValue);
        Token.m_lPropertyFunction = m_lPropertyFunction;
        Token.m_lConstFunction = m_lConstFunction;
    }
    else
    {
        Token.m_wszProperty = NULL;
        VariantInit(&Token.m_vConstValue);
    }
}

HRESULT CSql1Token::Evaluate(IHmmPropertySource* pPropSource)
{
    HRESULT hres;

    // Get the value of the property
    // =============================

    VARIANT vProperty;
    VariantInit(&vProperty);

    if(m_wsProperty.Length() == 0)
    {
        V_VT(&vProperty) = VT_UNKNOWN;
        V_UNKNOWN(&vProperty) = pPropSource;
        pPropSource->AddRef();
    }
    else if(FAILED(pPropSource->GetPropertyValue(m_wsProperty, 0, 
                                            &vProperty)))
    {
        return HMM_E_INSUFFICIENT_INFO;
    }

    if(V_VT(&vProperty) == VT_NULL)
    {
        return HMM_S_FALSE;
    }

    // Apply functions to property and constant
    // ========================================

    VARIANT vFinalProp;
    VariantInit(&vFinalProp);
    hres = EvaluateFunction(m_lPropertyFunction, &vProperty, 
                            &vFinalProp);
    VariantClear(&vProperty);
    if(FAILED(hres)) return hres;

    VARIANT vFinalConst;
    VariantInit(&vFinalConst);
    hres = EvaluateFunction(m_lConstFunction, &m_vConstValue, &vFinalConst);
    if(FAILED(hres)) return hres;

    // Handle ineritance
    // =================

    if(m_lOperator == SQL1_OPERATOR_INHERITSFROM)
    {
        if(V_VT(&vFinalProp) != VT_UNKNOWN || V_VT(&vFinalConst) != VT_BSTR)
            return HMM_S_FALSE;
        IHmmPropertySource* pProp = (IHmmPropertySource*)V_UNKNOWN(&vFinalProp);
        hres = pProp->IsDerivedFrom(V_BSTR(&vFinalConst));
        VariantClear(&vFinalConst);
        VariantClear(&vFinalProp);
        return hres;
    }
    else if(m_lOperator == SQL1_OPERATOR_NOTINHERITSFROM)
    {
        if(V_VT(&vFinalProp) != VT_UNKNOWN || V_VT(&vFinalConst) != VT_BSTR)
            return HMM_S_FALSE;
        IHmmPropertySource* pProp = (IHmmPropertySource*)V_UNKNOWN(&vFinalProp);
        hres = pProp->IsDerivedFrom(V_BSTR(&vFinalConst));
        VariantClear(&vFinalConst);
        VariantClear(&vFinalProp);
        return (hres == HMM_S_FALSE)?HMM_S_NO_ERROR : HMM_S_FALSE;
    }

    // Coerce the constant to the right type
    // =====================================
    
    if(FAILED(VariantChangeType(&vFinalConst, &vFinalConst, 0, 
        V_VT(&vFinalProp))))
    {
        // Fatal type mismatch --- expression == FALSE
        VariantClear(&vFinalConst);
        VariantClear(&vFinalProp);
        return HMM_S_FALSE;
    }

    // Compare the two variants
    // ========================

    int nCompare = CompareVariants(vFinalProp, vFinalConst);

    // Apply relational operator
    // =========================

    BOOL bResult;
    switch(m_lOperator)
    {
    case SQL1_OPERATOR_EQUALS:
        bResult = (nCompare == 0);
        break;
    case SQL1_OPERATOR_NOTEQUALS:
        bResult = (nCompare != 0);
        break;
    case SQL1_OPERATOR_GREATEROREQUALS:
        bResult = (nCompare >= 0);
        break;
    case SQL1_OPERATOR_LESSOREQUALS:
        bResult = (nCompare <= 0);
        break;
    case SQL1_OPERATOR_GREATER:
        bResult = (nCompare > 0);
        break;
    case SQL1_OPERATOR_LESS:
        bResult = (nCompare < 0);
        break;
    default:
        bResult = FALSE;
        break;
    }

    VariantClear(&vFinalConst);
    VariantClear(&vFinalProp);
    if(bResult)
        return HMM_S_NO_ERROR;
    else
        return HMM_S_FALSE;
}

int CSql1Token::CompareVariants(VARIANT& v1, VARIANT& v2)
{
    switch(V_VT(&v2))
    {
    case VT_BSTR:
        return wcscmp(V_BSTR(&v1), V_BSTR(&v2));
    case VT_I4:    
        return V_I4(&v1) - V_I4(&v2);
    case VT_I2:
        return V_I2(&v1) - V_I2(&v2);
    case VT_UI1:
        return V_UI1(&v1) - V_UI1(&v2);
    case VT_R4:    
        return (V_R4(&v1) > V_R4(&v2))?1:-1;
    case VT_R8:
        return (V_R8(&v1) > V_R8(&v2))?1:-1;
    }
    return 1;
}



HRESULT CSql1Token::EvaluateFunction(IN long lFunctionID, 
                                     IN READ_ONLY VARIANT* pvArg,
                                     OUT INIT_AND_CLEAR_ME VARIANT* pvDest)
{
    unsigned int nLen;
    unsigned int i;
    BSTR str;

    switch(lFunctionID)
    {
    case SQL1_FUNCTION_UPPER:
        if(V_VT(pvArg) != VT_BSTR)
        {
            return HMM_E_INVALID_QUERY;
        }
        VariantCopy(pvDest, pvArg);
        str = V_BSTR(pvDest);
        nLen = SysStringLen(str);
        for(i = 0; i < nLen; i++)
        {
            str[i] = towupper(str[i]);
        }
        break;

    case SQL1_FUNCTION_LOWER:
        if(V_VT(pvArg) != VT_BSTR)
        {
            return HMM_E_INVALID_QUERY;
        }
        VariantCopy(pvDest, pvArg);
        str = V_BSTR(pvDest);
        nLen = SysStringLen(str);
        for(i = 0; i < nLen; i++)
        {
            str[i] = towlower(str[i]);
        }
        break;

    case SQL1_FUNCTION_NONE:
    default:
        VariantCopy(pvDest, pvArg);
        break;

    }

    return HMM_S_NO_ERROR;
}

HRESULT CSql1Token::Negate()
{
    switch(m_lOperator)
    {
    case SQL1_OPERATOR_EQUALS:
        m_lOperator = SQL1_OPERATOR_NOTEQUALS;
        break;
    case SQL1_OPERATOR_NOTEQUALS:
        m_lOperator = SQL1_OPERATOR_EQUALS;
        break;
    case SQL1_OPERATOR_GREATEROREQUALS:
        m_lOperator = SQL1_OPERATOR_LESS;
        break;
    case SQL1_OPERATOR_LESSOREQUALS:
        m_lOperator = SQL1_OPERATOR_GREATER;
        break;
    case SQL1_OPERATOR_GREATER:
        m_lOperator = SQL1_OPERATOR_LESSOREQUALS;
        break;
    case SQL1_OPERATOR_LESS:
        m_lOperator = SQL1_OPERATOR_GREATEROREQUALS;
        break;
    case SQL1_OPERATOR_LIKE:
        m_lOperator = SQL1_OPERATOR_UNLIKE;
        break;
    case SQL1_OPERATOR_UNLIKE:
        m_lOperator = SQL1_OPERATOR_LIKE;
        break;
    case SQL1_OPERATOR_INHERITSFROM:
        m_lOperator = SQL1_OPERATOR_NOTINHERITSFROM;
        break;
    case SQL1_OPERATOR_NOTINHERITSFROM:
        m_lOperator = SQL1_OPERATOR_INHERITSFROM;
        break;
    default:
        return HMM_E_FAILED;
    }
    return HMM_S_NO_ERROR;
}

#define HMM_SMALL -100
#define HMM_LARGE 100

HMM_RELATIONSHIP CSql1Token::ComputeRelation(CSql1Token* pFirst,
                                             CSql1Token* pSecond,
                                             CMetaData* pMeta)
{
    if(!pFirst->m_wsProperty.EqualNoCase(pSecond->m_wsProperty))
    {
        // TBD: the case of INHERITSFROM versus __CLASS== needs to be handled
        // here. Ignore for now, since SQL1 does not support it.
        // ==================================================================

        return RELATION_NONE;
    }

    if(pFirst->m_lOperator == SQL1_OPERATOR_LIKE ||
        pFirst->m_lOperator == SQL1_OPERATOR_UNLIKE ||
        pSecond->m_lOperator == SQL1_OPERATOR_LIKE ||
        pSecond->m_lOperator == SQL1_OPERATOR_UNLIKE)
    {
        return RELATION_NONE;
    }

    BOOL bFirstAboutInheritance = 
        (pFirst->m_lOperator == SQL1_OPERATOR_INHERITSFROM ||
        pFirst->m_lOperator == SQL1_OPERATOR_NOTINHERITSFROM);
    BOOL bSecondAboutInheritance = 
        (pSecond->m_lOperator == SQL1_OPERATOR_INHERITSFROM ||
        pSecond->m_lOperator == SQL1_OPERATOR_NOTINHERITSFROM);

    if(bFirstAboutInheritance != bSecondAboutInheritance)
    {
        return RELATION_NONE;
    }

    if(bFirstAboutInheritance && bSecondAboutInheritance)
    {
        // Both talk about inhertance
        // ==========================

        int nClassRel = pMeta->GetClassRelation(V_BSTR(&pFirst->m_vConstValue),
                                         V_BSTR(&pSecond->m_vConstValue));
        BOOL bFirstIn = 
            (pFirst->m_lOperator == SQL1_OPERATOR_INHERITSFROM);
        BOOL bSecondIn = 
            (pSecond->m_lOperator == SQL1_OPERATOR_INHERITSFROM);

        switch(nClassRel)
        {
        case SEPARATE_BRANCHES:
            // It can't be in both. 
            return (HMM_RELATIONSHIP)
                    (RELATION_NONE - CTwoValues::Combine(bFirstIn, bSecondIn));
        case FIRST_IS_PARENT:
            // If it's in second, it's in first
            return (HMM_RELATIONSHIP)
                    (RELATION_NONE - CTwoValues::Combine(!bFirstIn, bSecondIn));
        case SECOND_IS_PARENT:
            // If it's in first, it's in second
            return (HMM_RELATIONSHIP)
                    (RELATION_NONE - CTwoValues::Combine(bFirstIn, !bSecondIn));
        }
    }

    // None talk about inhertiance
    // ===========================

    int nCompare = CompareVariants(pFirst->m_vConstValue, 
                                    pSecond->m_vConstValue);

    // Assume that the first constant is 0, and the second is nCompare*5.
    // =================================================================

    // Compute the segment for X based on the first token
    // ==================================================

    int nFirstStart, nFirstEnd;
    ComputeSegment(pFirst->m_lOperator, 0, nFirstStart, nFirstEnd);

    int nSecondStart, nSecondEnd;
    ComputeSegment(pSecond->m_lOperator, nCompare*5, nSecondStart, nSecondEnd);

    int nRelation = 0;

    if(nFirstStart <= nSecondEnd && nSecondStart <= nFirstEnd)
        nRelation += VALUE_BOTH_TRUE;

    if(nFirstStart < nSecondStart || nFirstEnd > nSecondEnd)
        nRelation += VALUE_ONLY_FIRST;

    if(nSecondStart < nFirstStart || nSecondEnd > nFirstEnd)
        nRelation += VALUE_ONLY_SECOND;
    
    if((nFirstStart > HMM_SMALL && nSecondStart > HMM_SMALL) ||
            (nFirstEnd < HMM_LARGE && nSecondEnd < HMM_LARGE))
        nRelation += VALUE_BOTH_FALSE;

    return (HMM_RELATIONSHIP)nRelation;
}

void CSql1Token::ComputeSegment(long lOperator, int nRightHand, 
                                int& nStart, int& nEnd)
{
    switch(lOperator)
    {
    case SQL1_OPERATOR_EQUALS:
        nStart = nEnd = nRightHand;
        return;
    case SQL1_OPERATOR_NOTEQUALS:// TBD --- at this point a NOOP
        nStart = HMM_SMALL;
        nStart = HMM_LARGE; 
        return;
    case SQL1_OPERATOR_LESS:
        nStart = HMM_SMALL;
        nEnd = nRightHand - 1;
        return;
    case SQL1_OPERATOR_LESSOREQUALS:
        nStart = HMM_SMALL;
        nEnd = nRightHand;
        return;
    case SQL1_OPERATOR_GREATER:
        nStart = nRightHand + 1;
        nEnd = HMM_LARGE;
    case SQL1_OPERATOR_GREATEROREQUALS:
        nStart = nRightHand;
        nEnd = HMM_LARGE;
    default:
        nStart = HMM_SMALL;
        nStart = HMM_LARGE; 
        return;
    }
}



    

        

void CSql1Token::Print(FILE* f, int nOffset)
{
    PrintOffset(nOffset); 
    printf("EXP\n");
    PrintOffset(nOffset+1);
    printf("Property: %S\n", m_wsProperty);
    PrintOffset(nOffset+1);
    printf("Property function: %d\n", m_lPropertyFunction);
    PrintOffset(nOffset+1);
    printf("Operator: %d\n", m_lOperator);
    PrintOffset(nOffset+1);
    printf("Constant: ");
    switch(V_VT(&m_vConstValue))
    {
    case VT_BSTR: 
        printf("%S", V_BSTR(&m_vConstValue)); break;
    case VT_I4:case VT_I2:case VT_UI1:
        printf("%d", V_I4(&m_vConstValue)); break;
    case VT_R4: case VT_R8:
        printf("%f", V_R8(&m_vConstValue)); break;
    default:
        printf("error");
    }
    printf("\n");
    PrintOffset(nOffset+1);
    printf("Constant function: %d\n", m_lConstFunction);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\queries\trees.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TREES.H

Abstract:

History:

--*/

#ifndef __HMM_TREES__H_
#define __HMM_TREES__H_

#include <windows.h>
#include <stdio.h>
#include <providl.h>
#include <arrtempl.h>
#include <wstring.h>
#include <parmdefs.h>
#include <metadata.h>
#include <relation.h>


class CHmmNode
{
public:
    long m_lRef;
    int m_lTokenType;
    
public:
    CHmmNode() : m_lRef(0){}
    virtual ~CHmmNode(){}

    inline void AddRef() {m_lRef++;}
    inline void Release() {m_lRef--; if(m_lRef == 0) delete this;}

    virtual HRESULT Evaluate(IHmmPropertySource* pSource) = 0;
    virtual HRESULT Negate() = 0;
    virtual void Print(FILE* f, int nOffset) = 0;

    static HRESULT EvaluateNode(CHmmNode* pNode, IHmmPropertySource* pSource);
    static HMM_RELATIONSHIP RelateNodes(CHmmNode* pFirst, CHmmNode* pSecond,
        CMetaData* pMeta);
protected:
    void PrintOffset(int nOffset);
};

class CNodeArray : public CUniquePointerArray<CHmmNode>
{
public:
    void AddRefElement(CHmmNode* pNode)
    {
        pNode->AddRef();
    }
    void ReleaseElement(CHmmNode* pNode)
    {
        pNode->Release();
    }
};

class CLogicalNode : public CHmmNode
{
public:
    CNodeArray m_apChildren;

    HRESULT Evaluate(IHmmPropertySource* pSource);
    HRESULT Negate();
    void Print(FILE* f, int nOffset);
    void Add(CHmmNode* pNode);
};

class CSql1Token : public CHmmNode
{
public:
    WString m_wsProperty;
    long m_lOperator;
    VARIANT m_vConstValue;
    long m_lPropertyFunction;
    long m_lConstFunction;

public:
    CSql1Token();
    CSql1Token(const CSql1Token& Other);
    CSql1Token(const HMM_SQL1_TOKEN& Token);
    ~CSql1Token();

    void Load(const HMM_SQL1_TOKEN& Token);
    void Save(HMM_SQL1_TOKEN& Token);

    HRESULT Evaluate(IHmmPropertySource* pSource);
    HRESULT Negate();
    void Print(FILE* f, int nOffset);

    static HMM_RELATIONSHIP ComputeRelation(
        CSql1Token* pFirst, CSql1Token* pSecond, CMetaData* pMeta);
protected:
    static int CompareVariants(VARIANT& v1, VARIANT& v2);
    static void ComputeSegment(long lOperator, int nRightHand, 
        int& nStart, int& nEnd);

    static HRESULT EvaluateFunction(IN long lFunctionID, 
                         IN READ_ONLY VARIANT* pvArg,
                         OUT INIT_AND_CLEAR_ME VARIANT* pvDest);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\redirect\wrapper.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WRAPPER.H

Abstract:

	Unsecapp (Unsecured appartment) is used by clients can recieve asynchronous
	call backs in cases where the client cannot initialize security and the server
	is running on a remote machine using an account with no network identity.  
	A prime example would be code running under MMC which is trying to get async
	notifications from a remote WINMGMT running as an nt service under the "local"
	account.

	See below for more info

History:

	a-levn        8/24/97       Created.
	a-davj        6/11/98       commented

--*/

//***************************************************************************
//
//  Wrapper.h
//
//  Unsecapp (Unsecured appartment) is used by clients can recieve asynchronous
//  call backs in cases where the client cannot initialize security and the server
//  is running on a remote machine using an account with no network identity.  
//  A prime example would be code running under MMC which is trying to get async
//  notifications from a remote WINMGMT running as an nt service under the "local"
//  account.
//
//  The suggested sequence of operations for making asynchronous calls from a client process is, then, the following (error checking omitted for brevity):
//
//  1) Create an instance of CLSID_UnsecuredApartment. Only one instance per client application is needed.  Since this object is implemented as a local server, this will launch UNSECAPP.EXE if it is not already running.
//
//	IUnsecuredApartment* pUnsecApp = NULL;
//	CoCreateInstance(CLSID_UnsecuredApartment, NULL, CLSCTX_LOCAL_SERVER, IID_IUnsecuredApartment, 
//				(void**)&pUnsecApp);
//
//  When making a call:
//
//  2) Instantiate your own implementation of IWbemObjectSink, e.g.
//
//	CMySink* pSink = new CMySink;
//	pSink->AddRef();
//
//  3) Create a "stub" for your object --- an UNSECAPP-produced wrapper --- and ask it for the IWbemObjectSink interface.
//
//	IUnknown* pStubUnk = NULL;
//	pUnsecApp->CreateObjectStub(pSink, &pStubUnk);
//
//	IWbemObjectSink* pStubSink = NULL;
//	pStubUnk->QueryInterface(IID_IWbemObjectSink, &pStubSink);
//	pStubUnk->Release();
//
//  4) Release your own object, since the "stub" now owns it.
//	pSink->Release();
//
//  5) Use this stub in the asynchronous call of your choice and release your own ref-count on it, e.g.
//	
//	pServices->CreateInstanceEnumAsync(strClassName, 0, NULL, pStubSink);
//	pStubSink->Release();
//
//  You are done. Whenever UNSECAPP receives a call in your behalf (Indicate or SetStatus) it will forward that call to your own object (pSink), and when it is finally released by WINMGMT, it will release your object. Basically, from the perspective of pSink, everything will work exactly as if it itself was passed into CreateInstanceEnumAsync.
//
//  Do once:
//  6) Release pUnsecApp before uninitializing COM:
//	pUnsecApp->Release();
//
//  When CreateObjectStub() is callec, a CStub object is created.  
//
//  History:
//
//  a-levn        8/24/97       Created.
//  a-davj        6/11/98       commented
//
//***************************************************************************

#include <unk.h>
#include "wbemidl.h"
#include "wbemint.h"

// One of these is created for each stub on the client

class CStub : public IWbemObjectSinkEx, public IWbemCreateSecondaryStub
{
protected:
    IWbemObjectSinkEx* m_pAggregatee;
    CLifeControl* m_pControl;
    long m_lRef;
    CRITICAL_SECTION  m_cs;
    bool m_bStatusSent;

public:
    CStub(IUnknown* pAggregatee, CLifeControl* pControl);
    ~CStub();
    void ServerWentAway();

    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    STDMETHOD_(ULONG, AddRef)()
        {return InterlockedIncrement(&m_lRef);};
    STDMETHOD_(ULONG, Release)();

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ void __RPC_FAR *pComObject);

    STDMETHOD(CreateSecondaryStub)(IUnknown** pSecStub);

};

// One of these is created for if the server knows about secondary stubs

class CSecondaryStub : public IUnknown
{
protected:
    CStub* m_pStub;
    CLifeControl* m_pControl;
    long m_lRef;

public:
    CSecondaryStub(CStub * pStub, CLifeControl* pControl);
    ~CSecondaryStub();

    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    STDMETHOD_(ULONG, AddRef)()
        {return InterlockedIncrement(&m_lRef);};

    STDMETHOD_(ULONG, Release)();
};

// When the client does a CCI, one of these is created.  Its only purpose
// is to support CreateObjectStub
extern long lAptCnt;

class CUnsecuredApartment : public CUnk
{
protected:
    typedef CImpl<IUnsecuredApartment, CUnsecuredApartment> XApartmentImpl;
    class XApartment : public XApartmentImpl
    {
    public:
        XApartment(CUnsecuredApartment* pObject) : XApartmentImpl(pObject){}
        STDMETHOD(CreateObjectStub)(IUnknown* pObject, IUnknown** ppStub);
    } m_XApartment;
    friend XApartment;

public:
    CUnsecuredApartment(CLifeControl* pControl) : CUnk(pControl),
        m_XApartment(this)
    {
        lAptCnt++;
    }                            
    ~CUnsecuredApartment()
    {
        lAptCnt--;
    }
    void* GetInterface(REFIID riid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\precomp.h ===
#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\redirect\wrapper.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WRAPPER.CPP

Abstract:

	Unsecapp (Unsecured appartment) is used by clients can recieve asynchronous
	call backs in cases where the client cannot initialize security and the server
	is running on a remote machine using an account with no network identity.  
	A prime example would be code running under MMC which is trying to get async
	notifications from a remote WINMGMT running as an nt service under the "local"
	account.

	SEE WRAPPER.H FOR MORE DETAILS.

History:

	a-levn        8/24/97       Created.
	a-davj        6/11/98       commented

--*/

#include "precomp.h"
#include "wrapper.h"
#include <wbemidl.h>
#include <sync.h>

long lAptCnt = 0;

CStub::CStub(IUnknown* pAggregatee, CLifeControl* pControl)
{
    m_pControl = pControl;
    m_bStatusSent = false;
    pControl->ObjectCreated((IWbemObjectSinkEx*)this);
    m_pAggregatee = NULL;
    pAggregatee->QueryInterface(IID_IWbemObjectSink, (void **)&m_pAggregatee);
    m_lRef = 0;
    InitializeCriticalSection(&m_cs);
}

CStub::~CStub()
{
    IWbemObjectSinkEx * pSink = NULL;
    if(m_pAggregatee)
    {
        CInCritSec cs(&m_cs);
        pSink = m_pAggregatee;
        m_pAggregatee = NULL;
    }
    if(pSink)
        pSink->Release();
    m_pControl->ObjectDestroyed((IWbemObjectSinkEx*)this);
    DeleteCriticalSection(&m_cs);
}


// This is called by either the client or server.  

STDMETHODIMP CStub::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemObjectSink || 
	   riid == IID_IWbemObjectSinkEx)
    {
        *ppv = (void*)(IWbemObjectSinkEx*)this;
        AddRef();
        return S_OK;
    }
    else if(riid == IID_IWbemCreateSecondaryStub)
    {
        *ppv = (void*)(IWbemCreateSecondaryStub*)this;
        AddRef();
        return S_OK;
    }
    else 
        return E_NOINTERFACE;
}

STDMETHODIMP CStub::CreateSecondaryStub(IUnknown** ppSecondaryStub)
{

    // This object gets a pointer to use and releases it when the server disonnects
    // it.  But before it release it, it calls our ServerWentAway function.
    CSecondaryStub * pNew = new CSecondaryStub(this, m_pControl);
    if(pNew == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    HRESULT hRes = pNew->QueryInterface(IID_IUnknown, (void **)ppSecondaryStub);
    if(hRes != S_OK)
        delete pNew;
    return hRes;
}


ULONG STDMETHODCALLTYPE CStub::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0) delete this;
    return lRef;
}

STDMETHODIMP CStub::Indicate(long lObjectCount, IWbemClassObject** pObjArray)
{
    IWbemObjectSinkEx * pSink = NULL;
    HRESULT hRes = WBEM_E_FAILED;
    if(m_pAggregatee)
    {
        CInCritSec cs(&m_cs);
        pSink = m_pAggregatee;
        pSink->AddRef();
    }
    if(pSink)
    {
        hRes = pSink->Indicate(lObjectCount, pObjArray);
        pSink->Release();
    }
    return hRes;
};

STDMETHODIMP CStub::SetStatus(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam)
{
    IWbemObjectSinkEx * pSink = NULL;
    if(FAILED(lParam))
        m_bStatusSent = true;
    else if(lParam == S_OK)
        m_bStatusSent = true;


    HRESULT hRes = WBEM_E_FAILED;
    if(m_pAggregatee)
    {
        CInCritSec cs(&m_cs);
        pSink = m_pAggregatee;
        pSink->AddRef();
    }
    if(pSink)
    {
        hRes = pSink->SetStatus(lFlags, lParam, strParam, pObjParam);
        pSink->Release();
    }
    return hRes;
};

HRESULT CStub::Set( 
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ void __RPC_FAR *pComObject)
{
    IWbemObjectSinkEx * pSink = NULL;
    HRESULT hRes = WBEM_E_FAILED;
    if(m_pAggregatee)
    {
        CInCritSec cs(&m_cs);
        hRes = m_pAggregatee->QueryInterface(IID_IWbemObjectSinkEx, (void **)&pSink);
        if(FAILED(hRes))
            pSink = NULL;       //shouldnt be necessary!
    }
    if(pSink)
    {
        hRes = pSink->Set(lFlags, riid, pComObject);
        pSink->Release();
    }
    return hRes;
}


void CStub::ServerWentAway()
{
    bool bNeedToSendStatus = false;
    {
        CInCritSec cs(&m_cs);
        bNeedToSendStatus = !m_bStatusSent;
    }
    if(bNeedToSendStatus)
       SetStatus(0, WBEM_E_TRANSPORT_FAILURE, NULL, NULL);
}

CSecondaryStub::CSecondaryStub(CStub * pStub, CLifeControl* pControl)
{
    m_pControl = pControl;
    pControl->ObjectCreated(this);
    m_pStub = pStub;
    m_pStub->AddRef();
    m_lRef = 0;
}

CSecondaryStub::~CSecondaryStub()
{
    if(m_pStub)
    {
        m_pStub->ServerWentAway();
        m_pStub->Release();
    }
    m_pControl->ObjectDestroyed(this);
}


// This is called by either the client or server.  

STDMETHODIMP CSecondaryStub::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown )
    {
        *ppv = (void*)(IUnknown*)this;
        AddRef();
        return S_OK;
    }
    else 
        return E_NOINTERFACE;
}


ULONG STDMETHODCALLTYPE CSecondaryStub::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0) delete this;
    return lRef;
}

void* CUnsecuredApartment::GetInterface(REFIID riid)
{
    if(riid == IID_IUnknown || riid == IID_IUnsecuredApartment)
    {
        return &m_XApartment;
    }
    else return NULL;
}

STDMETHODIMP CUnsecuredApartment::XApartment::CreateObjectStub(
        IUnknown* pObject, 
        IUnknown** ppStub)
{
    if(pObject == NULL)
        return E_POINTER;

    CStub* pIdentity = new CStub(pObject, m_pObject->m_pControl);
    pIdentity->AddRef();
    *ppStub = (IWbemObjectSinkEx*)pIdentity;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\redirect\unsecapp.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MAIN.CPP

Abstract:

	"Main" file for unsecapp.exe: initialize the app as a com server.  See 
	wrapper.cpp for a description of what unsecapp does.

History:

	a-levn        8/24/97       Created.
	a-davj        6/11/98       commented

--*/

#include "precomp.h"

#include <commain.h>
#include <clsfac.h>
#include "wbemidl.h"
#include "wrapper.h"

#include <tchar.h>

class CMyServer : public CComServer
{
public:
    virtual HRESULT InitializeCom() 
    {
        HRESULT hres = CoInitialize(NULL);
        if(FAILED(hres))
            return hres;
        return CoInitializeSecurity(NULL, -1, NULL, NULL, 
            RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IDENTIFY, NULL, 0, 0);
    }

    virtual HRESULT Initialize() 
    {
        CSimpleClassFactory<CUnsecuredApartment> * pFact = 
            new CSimpleClassFactory<CUnsecuredApartment>(GetLifeControl());
        if(pFact == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        AddClassInfo(CLSID_UnsecuredApartment, 
            pFact, TEXT("Unsecured Apartment"), TRUE);
        return S_OK;
    }
} Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\clsfctry.h ===
///////////////////////////////////////////////////////////////////////////////
//  clsfctry.h
//
//
//
//
//  History:
//
//      cvadai      4/1/99   created.
//
//
//  Copyright (c)1997-2001 Microsoft Corporation, All Rights Reserved
///////////////////////////////////////////////////////////////////////////////

#pragma once // More efficient method for the gaurd macros!

class CControllerFactory : public IClassFactory
{
protected:
    ULONG           m_cRef;
    
public:
    CControllerFactory(void);
    ~CControllerFactory(void);
    
    //IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, void**);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    //IClassFactory members
    STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, void**);
    STDMETHODIMP         LockServer(BOOL);
};



class CQueryFactory : public IClassFactory
{
protected:
    ULONG           m_cRef;
    
public:
    CQueryFactory(void);
    ~CQueryFactory(void);
    
    //IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, void**);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    //IClassFactory members
    STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, void**);
    STDMETHODIMP         LockServer(BOOL);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\redirect\client\main.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MAIN.CPP

Abstract:

History:

--*/

#define _WIN32_DCOM

#include "precomp.h"
#include <stdio.h>
#include <unsec.h>
#include <wbemsvc.h>
#include <unk.h>

class CSink : public CUnk
{
public:
    class XSink : public CImpl<IWbemObjectSink, CSink>
    {
    public:
       XSink(CSink* pObject) : CImpl<IWbemObjectSink, CSink>(pObject){}

       /* IDispatch methods */
       STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
       {return E_NOTIMPL;}
       STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
       {return E_NOTIMPL;}
       STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR** rgszNames, UINT cNames,
         LCID lcid, DISPID* rgdispid)
       {return E_NOTIMPL;}
       STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
         DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
         UINT* puArgErr)
       {return E_NOTIMPL;}
    
       STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
       STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                            IWbemClassObject* pObjPAram);
    } m_XSink;
    friend XSink;
public:
    CSink() : CUnk(NULL, NULL), m_XSink(this)
    {}
    void* GetInterface(REFIID riid);
};

void* CSink::GetInterface(REFIID riid)
{
    if(riid == IID_IUnknown || riid == IID_IWbemObjectSink)
    {
        return &m_XSink;
    }
    else return NULL;
}

STDMETHODIMP CSink::XSink::Indicate(long lObjectCount, IWbemClassObject** pObjArray)
{
    printf("Indicate: %d objects\n", lObjectCount);
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CSink::XSink::SetStatus(long lFlags, long lParam, BSTR strParam,
                            IWbemClassObject* pObjPAram)
{
    printf("SetStatus: %d\n", lParam);
    return WBEM_S_NO_ERROR;
}



void main()
{
    CoInitializeEx(NULL, COINIT_MULTITHREADED);
/*
    CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE,
            RPC_C_IMP_LEVEL_IDENTIFY, NULL, 0, 0);
*/

    HRESULT hres;
    IWbemLocator* pLocator;
    hres = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_ALL, 
        IID_IWbemLocator, (void**)&pLocator);

    IWbemServices* pServices;
    hres = pLocator->ConnectServer(SysAllocString(L"root\\default"), 
        NULL, NULL, NULL, 0, NULL, NULL, &pServices);
    pLocator->Release();

    IWbemClassObject* pObject = NULL;
    BSTR str = SysAllocString(L"__SystemClass");
    hres = pServices->GetObject(str, 0, NULL, &pObject, NULL);

    IUnsecuredApartment* pApartment;
    hres = CoCreateInstance(CLSID_UnsecuredApartment, NULL, CLSCTX_ALL,
                        IID_IUnsecuredApartment, (void**)&pApartment);

    printf("Obtained apartment: %X\n", hres);
    CSink* pSink = new CSink;
    pSink->AddRef();

    IUnknown* pStub;
    hres = pApartment->CreateObjectStub(pSink, &pStub);
    printf("Obtained stub: %X\n", hres);
    pApartment->Release();

    IWbemObjectSink* pWrappedSink;
    hres = pStub->QueryInterface(IID_IWbemObjectSink, 
                                (void**)&pWrappedSink);

    pStub->Release();

    printf("Obtained IWbemObjectSink: %X\n", hres);
    pWrappedSink->SetStatus(1, 2, NULL, NULL);

    hres = pServices->GetObjectAsync(str, 0, NULL, pWrappedSink);
    MessageBox(NULL, "", "", MB_OK);

    pWrappedSink->Release();

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\localloc.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\repcache.cpp ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   repcache.cpp
//
//   cvadai     19-Mar-99       Created as prototype for Quasar.
//
//***************************************************************************

#define _REPDRVR_CPP_
#pragma warning( disable : 4786 ) // identifier was truncated to 'number' characters in the 
#pragma warning( disable : 4251 ) //  needs to have dll-interface to be used by clients of class

#define _WIN32_DCOM
#include "precomp.h"

#include <repcache.h>
#include <wbemint.h>
#include <repdrvr.h>
#include <objbase.h>
#include <reputils.h>
#include <crc64.h>
#include <smrtptr.h>

typedef std::map<SQL_ID, bool> SQL_IDMap;
typedef std::map<SQL_ID, ULONG> SQLRefCountMap;
typedef std::map <SQL_ID, ClassData *> ClassCache;
typedef std::map <DWORD, DWORD> Properties;
typedef std::vector <SQL_ID> SQLIDs;
typedef std::map <_bstr_t, SQL_ID, _bstr_tNoCase> ClassNames;


#define MAX_WIDTH_SCHEMANAME    127 // Smallest property name for Jet / SQL 

//***************************************************************************
//
//  CObjectCache::CObjectCache
//
//***************************************************************************

CObjectCache::CObjectCache()
{
    m_dwMaxSize = 262140;
    InitializeCriticalSection(&m_cs);
    m_dwUsed = 0;    
}

//***************************************************************************
//
//  CObjectCache::~CObjectCache
//
//***************************************************************************
CObjectCache::~CObjectCache()
{
    EmptyCache();
    DeleteCriticalSection(&m_cs);
}

//***************************************************************************
//
//  CObjectCache::EmptyCache
//
//***************************************************************************
void  CObjectCache::EmptyCache()
{
    _WMILockit lkt(&m_cs);

    m_ObjCache.Empty();
    m_dwUsed = 0;
}

//***************************************************************************
//
//  CObjectCache::GetObject
//
//***************************************************************************

HRESULT CObjectCache::GetObject (LPCWSTR lpPath, IWbemClassObject **ppObj,
                                 SQL_ID *dScopeId)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    DWORD dwLock = 0;

    SQL_ID dwID = 0;

    dwID = CRC64::GenerateHashValue(lpPath);
    hr = GetObject (dwID, ppObj, dScopeId);

    return hr;
}

//***************************************************************************
//
//  CObjectCache::GetObject
//
//***************************************************************************

HRESULT CObjectCache::GetObject (SQL_ID dObjectId, IWbemClassObject **ppObj,
                                 SQL_ID *dScopeId)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    CacheInfo *pObj = NULL;

    hr = m_ObjCache.Get(dObjectId, &pObj);
    if (pObj)
    {
        pObj->m_tLastAccess = time(0);
        if (ppObj)
        {
            hr = pObj->m_pObj->Clone(ppObj);        
        }

        if (dScopeId)
            *dScopeId = pObj->m_dScopeId;
    }
    else
        hr = WBEM_E_NOT_FOUND;

    return hr;
}

//***************************************************************************
//
//  CObjectCache::GetObjectId
//
//***************************************************************************

HRESULT CObjectCache::GetObjectId (LPCWSTR lpPath, SQL_ID &dObjId, SQL_ID &dClassId, SQL_ID *dScopeId)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    if (lpPath == NULL)
        hr = WBEM_E_INVALID_PARAMETER;
    else
    {
        dObjId = CRC64::GenerateHashValue(lpPath);
        CacheInfo *pTemp = NULL;
        hr = m_ObjCache.Get(dObjId, &pTemp);
        if (SUCCEEDED(hr))
        {
            dClassId = pTemp->m_dClassId;
            if (dScopeId)
                *dScopeId = pTemp->m_dScopeId;
        }
    }

    return hr;
}


//***************************************************************************
//
//  CObjectCache::PutObject
//
//***************************************************************************
HRESULT CObjectCache::PutObject (SQL_ID dID, SQL_ID dClassId, SQL_ID dScopeId, LPCWSTR lpPath, bool bStrongCache, IWbemClassObject *_pObj)
{       
    // The cache can't exceed the maximum byte size.
    // and must set current used

    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);
    bool bNew = false;

    if (!_pObj)
        return WBEM_E_INVALID_PARAMETER;

    IWbemClassObject *pObj = NULL;
    hr = _pObj->Clone(&pObj);
    if (FAILED(hr))
        return hr;

    // Don't cache security descriptor
    hr = pObj->Put(L"__SECURITY_DESCRIPTOR", 0, NULL, CIM_UINT8|CIM_FLAG_ARRAY);

    CacheInfo *pTemp = NULL;
    size_t NewSize;

    hr = m_ObjCache.Get(dID, &pTemp);
    if (FAILED(hr))
    {
        bNew = true;
        NewSize = GetSize(pObj) + sizeof(CacheInfo) + wcslen(lpPath);
        hr = WBEM_S_NO_ERROR;
    }
    else
        NewSize = (GetSize(pObj) - GetSize(pTemp->m_pObj));

    if ((NewSize  + m_dwUsed) > m_dwMaxSize)
        hr = ResizeCache(NewSize, dID, bStrongCache);

    if (SUCCEEDED(hr) && NewSize)
    {
        if (pTemp)
        {
            IWbemClassObject *pTempObj = pTemp->m_pObj;
            if (pTempObj)
                pTempObj->Release();
        }           
        else
        {
            pTemp = new CacheInfo;
            if (!pTemp)
                return WBEM_E_OUT_OF_MEMORY;

            pTemp->m_bStrong = bStrongCache;
        }

        pTemp->m_dObjectId = dID;
        pTemp->m_dClassId = dClassId;
        pTemp->m_dScopeId = dScopeId;
        pTemp->m_tLastAccess = time(0);
        delete pTemp->m_sPath;
        pTemp->m_sPath = Macro_CloneLPWSTR(lpPath);
        pTemp->m_pObj = pObj;        
        pTemp->m_bStrong = ((int)pTemp->m_bStrong > (int)bStrongCache) ? pTemp->m_bStrong : bStrongCache; // Strong has precendence.

        if (bNew)
        {            
            hr = m_ObjCache.Insert(dID, pTemp);
        }

        m_dwUsed += NewSize;
    }

    return hr;

}
//***************************************************************************
//
//  CObjectCache::DeleteObject
//
//***************************************************************************
HRESULT CObjectCache::DeleteObject (SQL_ID dID)
{
    // Set current used
    // Recalculate the number of bytes used.

    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    CacheInfo *pObj = NULL;

    hr = m_ObjCache.Get(dID, &pObj);
    if (SUCCEEDED(hr))
    {
        if (pObj->m_pObj)
        {
            m_dwUsed -= GetSize(pObj->m_pObj);
            // pObj->m_pObj->Release();
        }
        m_dwUsed -= sizeof(CacheInfo);
        m_dwUsed -= wcslen(pObj->m_sPath);

        hr = m_ObjCache.Delete(dID);
    }

    if (hr == WBEM_E_NOT_FOUND) 
        hr = WBEM_S_NO_ERROR;

    return hr;

}

//***************************************************************************
//
//  CObjectCache::ObjectExists
//
//***************************************************************************

bool CObjectCache::ObjectExists (SQL_ID dObjectId)
{
    return (m_ObjCache.Exists(dObjectId));
}

//***************************************************************************
//
//  CObjectCache::SetCacheSize
//
//***************************************************************************

HRESULT CObjectCache::SetCacheSize(const DWORD dwMaxSize)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    // Physically resize the cache.
    // If that works, set the variable    

    if (dwMaxSize == 0)
    {
        _WMILockit lkt(&m_cs);
        EmptyCache();
    }
    else if (m_dwMaxSize > dwMaxSize)
    {        
        DWORD dwDiff = m_dwMaxSize - dwMaxSize;
        hr = ResizeCache(dwDiff, 0);
    }
    
    if (SUCCEEDED(hr))
        m_dwMaxSize = dwMaxSize;

    return hr;

}
//***************************************************************************
//
//  CObjectCache::GetCurrentUsage
//
//***************************************************************************
HRESULT CObjectCache::GetCurrentUsage(DWORD &dwBytesUsed)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    dwBytesUsed = m_dwUsed;

    return hr;

}
//***************************************************************************
//
//  CObjectCache::GetCacheSize
//
//***************************************************************************
HRESULT CObjectCache::GetCacheSize(DWORD &dwSizeInBytes)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    dwSizeInBytes = m_dwMaxSize;

    return hr;
}

//***************************************************************************
//
//  CObjectCache::FindFirst
//
//***************************************************************************

HRESULT CObjectCache::FindFirst(SQL_ID &dObjectId, SQL_ID &dClassId, SQL_ID *dScopeId)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    CListElement *pTemp = NULL;
    pTemp = m_ObjCache.FindFirst();
    if (pTemp != NULL)
    {
        CacheInfo *pTmp = (CacheInfo *)pTemp->m_pObj;

        pTmp->m_tLastAccess = time(0);
        dObjectId = pTmp->m_dObjectId;
        dClassId = pTmp->m_dClassId;
        if (dScopeId)
            *dScopeId = pTmp->m_dScopeId;
        delete pTemp;
    }
    else
        hr = WBEM_E_NOT_FOUND;

    return hr;
}

//***************************************************************************
//
//  CObjectCache::FindNext
//
//***************************************************************************

HRESULT CObjectCache::FindNext (SQL_ID dLastId, SQL_ID &dObjectId, SQL_ID &dClassId, SQL_ID *dScopeId)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    CListElement *pTemp = NULL;
    pTemp = m_ObjCache.FindNext(dLastId);
    if (pTemp != NULL)
    {
        CacheInfo *pTmp = (CacheInfo *)pTemp->m_pObj;

        pTmp->m_tLastAccess = time(0);
        dObjectId = pTmp->m_dObjectId;
        dClassId = pTmp->m_dClassId;
        if (dScopeId)
            *dScopeId = pTmp->m_dScopeId;
        delete pTemp;
    }
    else
        hr = WBEM_E_NOT_FOUND;   

    return hr;

}

//***************************************************************************
//
//  CObjectCache::GetSize
//
//***************************************************************************

DWORD CObjectCache::GetSize(IWbemClassObject *pObj)
{
    DWORD dwRet = 0;
    _IWmiObject *pInt = NULL;

    HRESULT hr = 0;
    hr = pObj->QueryInterface(IID__IWmiObject, (void **)&pInt);
    CReleaseMe rInt (pInt);
    if (SUCCEEDED(hr))
    {
        /* No idea how big this can be.  Is there a better way to do this?*/
        DWORD dwSize = 0;
        pInt->GetObjectMemory(NULL, dwSize, &dwRet);
    }
    
    return dwRet;

}

//***************************************************************************
//
//  CObjectCache::ResizeCache
//
//***************************************************************************

HRESULT CObjectCache::ResizeCache(DWORD dwReqBytes, SQL_ID dLeave, bool bForce)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Try to free up dwReqBytes, starting with
    // the oldest weakly cached objects.
    // ========================================

    while ((dwReqBytes + m_dwUsed) > m_dwMaxSize)
    {
        hr = WBEM_E_BUFFER_TOO_SMALL;        

        CListElement *pTemp = NULL;
        pTemp = m_ObjCache.FindFirst();
        while (pTemp != NULL)
        {
            SQL_ID dID = pTemp->m_dId;
            if (dID && dID != dLeave)
            {
                CacheInfo *pTmp = (CacheInfo *)pTemp->m_pObj;
                if (!pTmp->m_bStrong)
                    DeleteObject(dID);

                if ((dwReqBytes + m_dwUsed) <= m_dwMaxSize)
                {
                    hr = WBEM_S_NO_ERROR;
                    break;
                }
            }
            delete pTemp;
            pTemp = m_ObjCache.FindNext(dID);
        }

        if ((dwReqBytes + m_dwUsed) <= m_dwMaxSize)
        {
            hr = WBEM_S_NO_ERROR;
            break;
        }

        // Only remove other strong cached elements
        // if we have to.
        // =========================================

        if (bForce)
        {
            pTemp = m_ObjCache.FindFirst();
            while (pTemp != NULL)
            {
                SQL_ID dID = pTemp->m_dId;
                if (dID != dLeave)
                {
                    DeleteObject(dID);

                    if ((dwReqBytes + m_dwUsed) <= m_dwMaxSize)
                    {
                        hr = WBEM_S_NO_ERROR;
                        break;
                    }
                }
                pTemp = m_ObjCache.FindNext(dID);                
            }
        }

        break;  // if here, cache is empty.
    }

    return hr;
}


//***************************************************************************
//
//  LockData::GetMaxLock
//
//***************************************************************************

DWORD LockData::GetMaxLock(bool bImmediate, bool bSubScopeOnly)
{
    DWORD dwRet = 0;

    for (int i = 0; i < m_List.size(); i++)
    {
        LockItem *pItem = m_List.at(i);
        if (pItem)
        {
            if (bImmediate && pItem->m_bLockOnChild)
                continue;

            if (bSubScopeOnly && !(pItem->m_dwHandleType & WMIDB_HANDLE_TYPE_SUBSCOPED))
                continue;

            dwRet = GetMaxBytes(pItem->m_dwHandleType, dwRet);
        }
    }

    return dwRet;

}

//***************************************************************************
//
//  LockData::LockExists
//
//***************************************************************************

bool LockData::LockExists (DWORD dwHandleType)
{
    bool bRet = false;

    for (int i = 0; i < m_List.size(); i++)
    {
        LockItem *pItem = m_List.at(i);
        if (pItem)
        {
            if (!pItem->m_bLockOnChild)
            {
                if ((pItem->m_dwHandleType & dwHandleType) == dwHandleType)
                {
                    bRet = true;
                    break;
                }
            }
        }
    }

    return bRet;
}

//***************************************************************************
//
//  CLockCache::~CLockCache
//
//***************************************************************************

CLockCache::~CLockCache()
{
    DeleteCriticalSection(&m_cs);
}

//***************************************************************************
//
//  CLockCache::GetHandle
//
//***************************************************************************

HRESULT CLockCache::GetHandle(SQL_ID ObjId, DWORD dwType, IWmiDbHandle **ppRet)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    _WMILockit lkt(&m_cs);

    *ppRet = NULL;

    LockData *temp = NULL;
    hr = m_Cache.Get(ObjId, &temp);
    if (SUCCEEDED(hr))
    {
        LockData *pData = (LockData *)temp;
        if (pData)
        {
            LockItem *pItem = NULL;
            for (int i = 0; i < pData->m_List.size(); i++)
            {
                pItem = pData->m_List.at(i);
                if (pItem->m_dwHandleType == dwType)
                {
                    if (pItem->m_pObj)
                    {
                        pItem->m_pObj->AddRef();
                        *ppRet = (IWmiDbHandle *)pItem->m_pObj; 
                    }
                    break;
                }
            }
        }        
    }

    return hr;
}

//***************************************************************************
//
//  CLockCache::AddLock
//
//***************************************************************************

HRESULT CLockCache::AddLock(bool bImmediate, SQL_ID ObjId, DWORD Type, IUnknown *pUnk, SQL_ID dNsId, 
        SQL_ID dClassId, CSchemaCache *pCache, bool bChg, bool bChildLock, SQL_ID SourceId,
        DWORD *dwVersion)
{

    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);
    SQL_ID dParentId = 0;

    if (bChildLock)
        Type &= ~WMIDB_HANDLE_TYPE_AUTODELETE;

    if (Type & WMIDB_HANDLE_TYPE_AUTODELETE)
    {
        DWORD dwParentLock = 0;
        GetCurrentLock(dNsId, false, dwParentLock);
        if (!(dwParentLock & WMIDB_HANDLE_TYPE_AUTODELETE))
        {
            GetCurrentLock(dClassId, false, dwParentLock);
            if (!(dwParentLock & WMIDB_HANDLE_TYPE_AUTODELETE))
            {
                SQL_ID ClassId = dClassId, dParentId = 0;
                while (SUCCEEDED(pCache->GetParentId(ClassId, dParentId)))
                {
                    GetCurrentLock(dParentId, false, dwParentLock);
                    if (dwParentLock & WMIDB_HANDLE_TYPE_AUTODELETE)
                        break;
                    ClassId = dParentId;
                }      
            }
        }
        if (dwParentLock & WMIDB_HANDLE_TYPE_AUTODELETE)
            return WBEM_E_INVALID_HANDLE_REQUEST;
    }

    // If this is a cookie, we really don't 
    // care what locks exist, and we do
    // not need to add it to the list.
    // Unless its an auto-delete handle...
    // ======================================

    if ((Type & 0xF)== WMIDB_HANDLE_TYPE_COOKIE &&
        !(Type & WMIDB_HANDLE_TYPE_AUTODELETE))
        return WBEM_S_NO_ERROR;

    // If this is a class, 
    // use its own ID as the Class ID.
    // ==============================
    
    if (dClassId == 1)
        dClassId = ObjId;

    LockData *temp = NULL;
    hr = m_Cache.Get(ObjId, &temp);

    LockData *pData = NULL;
    if (SUCCEEDED(hr))
    {
        pData = (LockData *)temp;
    }
    else
    {
        hr = WBEM_S_NO_ERROR;
        pData = new LockData;
        if (pData)
        {
            pData->m_dObjectId = ObjId;
            pData->m_dwStatus = 0;  // Calculated at the end.
            pData->m_dwNumLocks = 0;
            pData->m_dwCompositeStatus = 0;
            pData->m_dwVersion = 1;
            pData->m_dwCompositeVersion = 1;
            m_Cache.Insert(ObjId, pData);
            
            // Load the owner list

            if (!bChildLock)
            {
                SQL_ID dParent = 0, dClass = 0;
                if (dClassId != 2)
                {
                    pCache->GetParentNamespace(dNsId, dParent, &dClass);
                    while (dParent)  // Don't propogate locks across namespaces!
                    {
                        pData->m_OwnerIds[dParent];
                        if (dClass == 2)
                            break;
                        pCache->GetParentNamespace(dParent, dParent, &dClass);
                    }
                    pData->m_OwnerIds[dNsId] = true;
                }
                
                if (dClassId != ObjId)
                    pData->m_OwnerIds[dClassId] = true;
                while (SUCCEEDED(pCache->GetParentId(dClassId, dParentId)))
                {
                    pData->m_OwnerIds[dParentId] = 1;
                    dClassId = dParentId;
                }
            }
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }

    if (SUCCEEDED(hr))
    {
        // Make sure the parent objects aren't directly locked.
        // ====================================================

        if (!CanLockHandle(ObjId, Type, bImmediate, false))  
            hr = WBEM_E_ACCESS_DENIED;

        if (SUCCEEDED(hr))
        {
            SQL_IDMap::iterator item = pData->m_OwnerIds.begin();
            while (item != pData->m_OwnerIds.end())
            {
                if (!CanLockHandle((*item).first, (Type &~WMIDB_HANDLE_TYPE_SUBSCOPED), true, true))
                {
                    hr = WBEM_E_ACCESS_DENIED;
                    break;
                }            
                item++;
            }
        }

        // If all that worked, we can now attempt to 
        // add the lock to this object.
        // =========================================

        if (SUCCEEDED(hr))
        {
            LockItem *pItem = NULL;

            // Now we need to see if this lock already exists
            // for this handle type.
            // ==============================================

            pItem = new LockItem;
            if (pItem)
            {
                pItem->m_dwHandleType = Type;
                pItem->m_pObj = pUnk;
                pItem->m_dSourceId = SourceId;
                pItem->m_dwVersion = pData->m_dwVersion;

                if (bChildLock)
                    pItem->m_bLockOnChild = true;
                else
                    pItem->m_bLockOnChild = false;

                // Attempt to lock all the parent objects.
                // Pass in zeroes for namespace and class Ids
                // so we don't recurse.

                if (dNsId && dClassId != 2)
                {                
                    hr = AddLock(true, dNsId, (Type &~WMIDB_HANDLE_TYPE_SUBSCOPED), pUnk, 0, 0, 0, bChg, true, ObjId);
                    if (SUCCEEDED(hr))
                    {
                        SQL_ID dParent = 0, dClass = 0;
                        pCache->GetParentNamespace(dNsId, dParent, &dClass);
                        while (dParent)
                        {
                            hr = AddLock(true, dParent, (Type &~WMIDB_HANDLE_TYPE_SUBSCOPED), pUnk, 0, 0, 0, bChg, true, ObjId);
                            // Don't propogate locks across namespaces.
                            if (dClass == 2)
                                break;
                            pCache->GetParentNamespace(dParent, dParent, &dClass);
                        }

                    }
                }

                if (dClassId != 1 && dClassId != 0)   // Disregard the __Class class
                {
                    if (dClassId != ObjId) // We already saved this one.
                        hr = AddLock(true, dClassId, (Type &~WMIDB_HANDLE_TYPE_SUBSCOPED), pUnk, 0, 0, 0, bChg, true, ObjId);

                    hr = pCache->GetParentId(dClassId, dParentId);
                    while (SUCCEEDED(hr))
                    {
                        hr = AddLock(true, dParentId, (Type &~WMIDB_HANDLE_TYPE_SUBSCOPED), pUnk, 0, 0, 0, bChg, true, ObjId);
                        hr = pCache->GetParentId(dParentId, dParentId);
                    }
                    hr = WBEM_S_NO_ERROR;
                }

                // If this is a blocking handle, make sure 
                // we lock out any existing handles on child
                // objects.  If there any other locks on sub
                // components of this object, they should be
                // in the list at this point.
                // If this is a versioned handle, that needs
                // to be invalidated if there is an immediate
                // change to the parent object!!

                if (Type & WMIDB_HANDLE_TYPE_SUBSCOPED)
                {
                    for (int i = 0; i < pData->m_List.size(); i++)
                    {
                        LockItem *pTemp = pData->m_List.at(i);
                        if (pTemp && pTemp->m_dSourceId != 0)
                            AddLock(true, pTemp->m_dSourceId, (Type &~WMIDB_HANDLE_TYPE_SUBSCOPED), pUnk, 0, 0, 0, bChg, false, ObjId);
                    }
                }

                // Only increment version type if this object changed,
                // or if there is an outstanding versioned|subscoped
                // handle type on this object and a child object chgd.
                // ====================================================

                if (bChg)
                {
                    if (!bChildLock)    
                    {
                        pData->m_dwVersion++;
                        pData->m_dwCompositeVersion++;
                        pItem->m_dwVersion = pData->m_dwVersion;
                    }
                    else if (bChildLock && pData->LockExists(WMIDB_HANDLE_TYPE_VERSIONED|WMIDB_HANDLE_TYPE_SUBSCOPED))
                        pData->m_dwCompositeVersion++;
                }

                pData->m_List.push_back(pItem);
                pData->m_dwNumLocks++;

                // Update the lock type
                // ====================

                pData->m_dwStatus = pData->GetMaxLock(true);
                pData->m_dwCompositeStatus = pData->GetMaxLock(false);

                if (dwVersion)
                {
                    if (bImmediate)
                        *dwVersion = pData->m_dwVersion;
                    else
                        *dwVersion = pData->m_dwCompositeVersion;
                }
            }

        }
    }

    return hr;

}

//***************************************************************************
//
//  CLockCache::DeleteLock
//
//***************************************************************************
HRESULT CLockCache::DeleteLock(SQL_ID ObjId, bool bChildLock, DWORD HandleType, bool bDelChildren, void *pObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    // If this is the only lock, 
    // remove the whole thing.
    // Otherwise just remove the item
    // Update the master lock
    // ==============================

    LockData *pData = NULL;
    LockData *temp = NULL;
    
    hr = m_Cache.Get(ObjId, &temp);
    if (SUCCEEDED(hr))
    {
        pData = (LockData *)temp;
        // If they specify a handle of zero, 
        // we delete all entries for this ID.

        if (HandleType)
        {
            BOOL bFound = FALSE;
            LockItem *pItem = NULL;
            for (int i = 0; i < pData->m_List.size(); i++)
            {
                pItem = pData->m_List.at(i);
                if (pItem->m_dwHandleType == HandleType && (pItem->m_pObj == pObj))
                {
                    if (bChildLock && !pItem->m_bLockOnChild)
                        continue;

                    if (pItem->m_pObj)
                        ((CWmiDbHandle *)pItem->m_pObj)->m_dwHandleType = 0;                        

                    delete pItem;
                    pData->m_List.erase(&pData->m_List.at(i));
                    pData->m_dwNumLocks--;
                    bFound = TRUE;
                    break;
                }
            }

            if (!pObj && !bFound)
            {
                for (int i = 0; i < pData->m_List.size(); i++)
                {
                    pItem = pData->m_List.at(i);
                    if (pItem->m_dwHandleType == HandleType)
                    {
                        if (bChildLock && !pItem->m_bLockOnChild)
                            continue;

                        delete pItem;
                        pData->m_List.erase(&pData->m_List.at(i));
                        pData->m_dwNumLocks--;
                        bFound = TRUE;
                        break;
                    }
                }
            }

            if (bDelChildren)
            {
                // Remove this lock from all the 
                // owner objects (namespaces, classes)
                // ===================================

                SQL_IDMap::iterator walk = pData->m_OwnerIds.begin();
                while (walk != pData->m_OwnerIds.end())
                {
                    SQL_ID dId = (*walk).first;
                    hr = DeleteLock(dId, true, (HandleType &~WMIDB_HANDLE_TYPE_SUBSCOPED), false, pObj);
                    if (FAILED(hr))
                        break;
                
                    walk++;
                }

                // Remove this lock from the child
                // objects that we previously 
                // locked out.
                // ===============================

                if (HandleType & WMIDB_HANDLE_TYPE_SUBSCOPED)
                {
                    for (int i = 0; i < pData->m_List.size(); i++)
                    {
                        LockItem *pTemp = pData->m_List.at(i);                    
                        if (pTemp && pTemp->m_dSourceId != 0)
                            DeleteLock(pTemp->m_dSourceId, true, (HandleType &~WMIDB_HANDLE_TYPE_SUBSCOPED), false, pObj);
                    }
                }
            }

            // If that worked, we can
            // remove this entry from the
            // the lock cache.
            // ===========================

            if (SUCCEEDED(hr))
            {
                pData->m_dwStatus = pData->GetMaxLock(true);
                pData->m_dwCompositeStatus = pData->GetMaxLock(false);

                // Delete if this is the last lock...
                if (!pData->m_dwNumLocks)
                    hr = m_Cache.Delete(ObjId);
            }
        }
        else
        {
            // This object was deleted.  We have to 
            // invalidate all the handles for this object.
            // ==========================================

            LockItem *pItem = NULL;
            for (int i = 0; i < pData->m_List.size(); i++)
            {
                pItem = pData->m_List.at(i);
                
                if (pItem && pItem->m_pObj)
                    ((CWmiDbHandle *)pItem->m_pObj)->m_dwHandleType = WMIDB_HANDLE_TYPE_INVALID;
            }

            hr = m_Cache.Delete(ObjId);
        }
    }
    else if (hr == WBEM_E_NOT_FOUND)
        hr = WBEM_S_NO_ERROR;

    return hr;
}

//***************************************************************************
//
//  CLockCache::GetCurrentLock
//
//***************************************************************************

HRESULT CLockCache::GetCurrentLock(SQL_ID ObjId, bool bImmediate, DWORD &HandleType, DWORD *Version)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    LockData *pData = NULL;
    LockData *temp;
    
    hr = m_Cache.Get(ObjId, &temp);
    if (SUCCEEDED(hr))
    {
        pData = (LockData *)temp;
        if (bImmediate)
            HandleType = pData->m_dwStatus;
        else
            HandleType = pData->m_dwCompositeStatus;

        if (Version)
        {
            if (bImmediate)
                *Version = pData->m_dwVersion;
            else
                *Version = pData->m_dwCompositeVersion;
        }
    }

    return hr;
}

//***************************************************************************
//
//  CLockCache::GetAllLocks
//
//***************************************************************************

HRESULT CLockCache::GetAllLocks(SQL_ID ObjId, SQL_ID ClassId, SQL_ID NsId, CSchemaCache *pSchema, 
                                bool bImmediate, DWORD &HandleType, DWORD *Version)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwCurrType = 0, dwTemp = 0;
    SQL_ID dParentId = 0;

    hr = GetCurrentLock(ObjId, bImmediate, dwCurrType, Version);

    if (SUCCEEDED(GetCurrentLock(ClassId, bImmediate, dwTemp)))
    {
        if (dwTemp & WMIDB_HANDLE_TYPE_SUBSCOPED) 
            dwCurrType = GetMaxBytes(dwCurrType, dwTemp);
    }

    if (SUCCEEDED(GetCurrentLock(NsId, bImmediate, dwTemp)))
    {
        if (dwTemp & WMIDB_HANDLE_TYPE_SUBSCOPED) 
            dwCurrType = GetMaxBytes(dwCurrType, dwTemp);
    }
    
    if (ClassId)
    {
        while (SUCCEEDED(pSchema->GetParentId(ClassId, dParentId)))
        {
            if (SUCCEEDED(GetCurrentLock(dParentId, bImmediate, dwTemp)))
            {
               if (dwTemp & WMIDB_HANDLE_TYPE_SUBSCOPED)
                dwCurrType = GetMaxBytes(dwCurrType, dwTemp);               
            }
            ClassId = dParentId;
        }      
    }
    HandleType = dwCurrType;

    return hr;
}

//***************************************************************************
//
//  CLockCache::CanLockHandle
//
//***************************************************************************

bool CLockCache::CanLockHandle (SQL_ID ObjId, DWORD RequestedHandleType, bool bImmediate, bool bSubscopedOnly)
{
    bool bRet = true;   // If not found, they can definitely lock it...
    DWORD dwCurrType = 0;

    _WMILockit lkt(&m_cs);

    LockData *pData = NULL;
    LockData *temp;
    
    HRESULT hr = m_Cache.Get(ObjId, &temp);
    if (SUCCEEDED(hr))
    {
        pData = (LockData *)temp;
        dwCurrType = pData->GetMaxLock(bImmediate, bSubscopedOnly);
      
        if (bRet)
        {
            switch (dwCurrType & 0xF)
            {
              case WMIDB_HANDLE_TYPE_COOKIE:
              case WMIDB_HANDLE_TYPE_VERSIONED:   // Weak handles always succeed.
                  bRet = true;
                  break;
              case WMIDB_HANDLE_TYPE_EXCLUSIVE:   // Exclusive access.
                  if ((RequestedHandleType & 0xF) != WMIDB_HANDLE_TYPE_COOKIE && 
                      (RequestedHandleType & 0xF) != WMIDB_HANDLE_TYPE_VERSIONED)
                       bRet = false;
                  break;
              case WMIDB_HANDLE_TYPE_PROTECTED: // Read only
                  if ((RequestedHandleType & 0xF) != WMIDB_HANDLE_TYPE_EXCLUSIVE)
                      bRet = true;
                  else
                      bRet = false;
                  break;
              default:
                  bRet = true;
                  break;
            }    
        }
    }

    return bRet;
}

//***************************************************************************
//
//  CLockCache::CanRenderObject
//
//***************************************************************************

bool CLockCache::CanRenderObject (SQL_ID ObjId, SQL_ID ClassId, SQL_ID NsId, CSchemaCache *pSchema, DWORD RequestedHandleType, bool bImmediate)
{
    bool bRet = true;   // If not found, they can definitely lock it...
    DWORD dwCurrType;
    SQL_ID dParentId = 0;

    // Get the lock for this 
    // object and all its ancestors.
    // =============================

    HRESULT hr = GetAllLocks(ObjId, ClassId, NsId, pSchema, bImmediate, RequestedHandleType);
    if (SUCCEEDED(hr))
    {
        dwCurrType = RequestedHandleType & 0xF;
        switch (dwCurrType)
        {
          case WMIDB_HANDLE_TYPE_COOKIE:
          case WMIDB_HANDLE_TYPE_VERSIONED:   // Weak handles always succeed.
              bRet = true;
              break;
          case WMIDB_HANDLE_TYPE_EXCLUSIVE:   // Exclusive access.
              bRet = false;
              break;
          case WMIDB_HANDLE_TYPE_PROTECTED: // Read only
              if ((RequestedHandleType & 0xF) != WMIDB_HANDLE_TYPE_EXCLUSIVE)
                  bRet = true;
              else
                  bRet = false;
              break;
          default:
              bRet = true;
              break;
        }        
    }

    return bRet;
}

//***************************************************************************
//
//  CLockCache::IncrementVersion
//
//***************************************************************************

HRESULT CLockCache::IncrementVersion(SQL_ID ObjId)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    LockData *pData = NULL;
    LockData *temp;
    
    hr = m_Cache.Get(ObjId, &temp);
    if (SUCCEEDED(hr))
    {
        pData = (LockData *)temp;
        pData->m_dwVersion++;
        pData->m_dwCompositeVersion++;
    }

    return hr;
}


//***************************************************************************
//
//  PropertyData::PropertyData
//
//***************************************************************************

PropertyData::PropertyData()
{
    m_dwClassID = 0;
    m_dwStorageType = 0;
    m_dwCIMType = 0;
    m_dwFlags = 0;
    m_dwRefClassID = 0;
    m_dwQPropID = 0;
    m_dwFlavor = 0;
    m_sPropertyName = NULL; 
    m_sDefaultValue = NULL;
}

//***************************************************************************
//
//  PropertyData::GetSize
//
//***************************************************************************

DWORD PropertyData::GetSize()
{
    DWORD dwSize = 0;
 
    if (m_sPropertyName)
        dwSize += wcslen(m_sPropertyName)*2;
    else
        dwSize += sizeof(LPWSTR);

    if (m_sDefaultValue)
        dwSize += wcslen(m_sDefaultValue)*2;
    else
        dwSize += sizeof(LPWSTR);

    dwSize += sizeof(m_dwClassID) +
              sizeof(m_dwStorageType) +
              sizeof(m_dwCIMType) +
              sizeof(m_dwFlags) +
              sizeof(m_dwRefClassID) +
              sizeof(m_dwQPropID) +
              sizeof(m_dwFlavor);

    return dwSize;
}


//***************************************************************************
//
//  ClassData::ClassData
//
//***************************************************************************

ClassData::ClassData()
{
    m_dwClassID = 0;
    m_dwSuperClassID = 0;
    m_dwDynastyID = 0;
    m_dwScopeID = 0;
    m_dwFlags = 0;
    m_Properties = new PropertyList[10];
    m_dwNumProps = 0;
    m_dwArraySize = 10;
    m_sName = NULL; 
    m_sObjectPath = NULL;
}


//***************************************************************************
//
//  ClassData::GetSize
//
//***************************************************************************

DWORD ClassData::GetSize()
{
    DWORD dwSize = 0;

    if (m_sName)
        dwSize += wcslen(m_sName)*2;
    else
        dwSize += sizeof(LPWSTR);
    if (m_sObjectPath)
        dwSize += wcslen(m_sObjectPath)*2;
    else
        dwSize += dwSize += sizeof(LPWSTR);

    dwSize += sizeof(m_dwClassID) +
              sizeof(m_dwSuperClassID) +
              sizeof(m_dwDynastyID) +
              sizeof(m_dwScopeID) + 
              sizeof(m_dwNumProps) +
              sizeof(m_dwArraySize) +
              sizeof(m_dwFlags);

    for (int i=0; i < m_dwNumProps; i++)
    {
        dwSize += sizeof(PropertyList);
    }

    return dwSize;
}

//***************************************************************************
//
//  ClassData::InsertProperty
//
//***************************************************************************

void ClassData::InsertProperty (DWORD PropId, BOOL bIsKey)
{
    BOOL bFound = FALSE;
    if (m_Properties)
    {
        for (int i = 0; i < m_dwNumProps; i++)
        {
            if (m_Properties[i].m_dwPropertyId == PropId)            
            {
                bFound = TRUE;
                m_Properties[i].m_bIsKey = bIsKey;
                break;
            }
        }
        if (!bFound)
        {
            if (m_dwNumProps == m_dwArraySize)
            {
                PropertyList *pList = new PropertyList[m_dwArraySize + 10];
                if (pList)
                {
                    memcpy(pList, m_Properties, sizeof(PropertyList) * m_dwArraySize);
                    delete m_Properties;
                    m_Properties = pList;
                    m_dwArraySize += 10;
                }
            }

            m_Properties[m_dwNumProps].m_dwPropertyId = PropId;
            m_Properties[m_dwNumProps].m_bIsKey = bIsKey;
            m_dwNumProps++;
        }
    }    
}

void ClassData::DeleteProperty (DWORD PropId)
{
    // Should we clean up the gaps here?

    if (m_Properties)
    {
        for (int i = 0; i < m_dwNumProps; i++)
        {
            if (m_Properties[i].m_dwPropertyId == PropId)
            {   
                m_Properties[i].m_dwPropertyId = 0;
                m_Properties[i].m_bIsKey = 0;
                break;
            }
        }
    }
}

void ClassData::InsertDerivedClass (SQL_ID dID) 
{
    BOOL bFound = FALSE;

    for (int i = 0; i < m_DerivedIDs.size(); i++)
    {
        if (m_DerivedIDs.at(i) == dID)
        {
            bFound = TRUE;
            break;
        }
    }
    if (!bFound)
        m_DerivedIDs.push_back(dID);
}

void ClassData::DeleteDerivedClass (SQL_ID dID)
{
    for (int i = 0; i < m_DerivedIDs.size(); i++)
    {
        if (m_DerivedIDs.at(i) == dID)
        {
            m_DerivedIDs.erase(&m_DerivedIDs.at(i));
            break;
        }
    }

}

//***************************************************************************
//
//  NamespaceData::GetSize
//
//***************************************************************************

DWORD NamespaceData::GetSize()
{
    DWORD dwSize = 0;

    if (m_sNamespaceName)
        dwSize += wcslen(m_sNamespaceName)*2;
    else
        dwSize += sizeof(LPWSTR);

    if (m_sNamespaceKey)
        dwSize += wcslen(m_sNamespaceKey)*2;
    else
        dwSize += sizeof(LPWSTR);

    dwSize += sizeof(m_dNamespaceId) +
              sizeof(m_dParentId) +
              sizeof(m_dClassId);

    return dwSize;
}

//***************************************************************************
//
//  CSchemaCache::CSchemaCache
//
//***************************************************************************

CSchemaCache::CSchemaCache()
{
    m_dwTotalSize = 0;
    m_dwMaxSize = 204800;
    InitializeCriticalSection(&m_cs);
}

//***************************************************************************
//
//  CSchemaCache::~CSchemaCache
//
//***************************************************************************

CSchemaCache::~CSchemaCache()
{
    EmptyCache();
    DeleteCriticalSection(&m_cs);
}

//***************************************************************************
//
//  CSchemaCache::EmptyCache
//
//***************************************************************************
void CSchemaCache::EmptyCache()
{
    _WMILockit lkt(&m_cs);

    m_Cache.Empty(); 
    m_CCache.Empty();
    m_CIndex.clear();
    m_dwTotalSize = 0;
}

//***************************************************************************
//
//  CSchemaCache::GetPropertyInfo
//
//***************************************************************************

HRESULT CSchemaCache::GetPropertyInfo (DWORD dwPropertyID, _bstr_t *sName, SQL_ID *dwClassID, DWORD *dwStorageType,
        DWORD *dwCIMType, DWORD *dwFlags, SQL_ID *dwRefClassID, _bstr_t *sDefaultValue, DWORD *pdwRefId, DWORD *pdwFlavor)
{
    _WMILockit lkt(&m_cs);

    HRESULT hr = WBEM_S_NO_ERROR;

    PropertyData *pData = NULL;

    SQL_ID dTemp = dwPropertyID;
    m_Cache.Get(dTemp, &pData);
    if (pData != NULL)
    {
        if (sName) *sName = pData->m_sPropertyName;
        if (dwClassID) *dwClassID = pData->m_dwClassID;
        if (dwStorageType) *dwStorageType = pData->m_dwStorageType;
        if (dwCIMType) *dwCIMType = pData->m_dwCIMType;
        if (dwFlags) *dwFlags = pData->m_dwFlags;
        if (dwRefClassID) *dwRefClassID = pData->m_dwRefClassID;
        if (sDefaultValue) *sDefaultValue = pData->m_sDefaultValue;
        if (pdwRefId) *pdwRefId = pData->m_dwQPropID;
        if (pdwFlavor) *pdwFlavor = pData->m_dwFlavor;
    }
    else
        hr = WBEM_E_NOT_FOUND;        

    return hr;
}

//***************************************************************************
//
//  CSchemaCache::GetPropertyID
//
//***************************************************************************

HRESULT CSchemaCache::GetPropertyID (LPCWSTR lpName, SQL_ID dClassID, DWORD dwFlags, CIMTYPE ct, 
        DWORD &PropertyID, SQL_ID *ActualClass, DWORD *Flags, DWORD *Type, BOOL bSys)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    _bstr_t sIndexKey;
    SQL_ID dCurrClass = dClassID;

    PropertyID = 0;

    if (lpName && wcslen(lpName) > 2 && lpName[0] == L'_' && lpName[1] == L'_')
        bSys = TRUE;

    // Try to find this property in this class,
    // or its parent classes.

    if (dClassID)
    {
        ClassData *pClass = NULL;
        m_CCache.Get(dClassID, &pClass);

        while (pClass)
        {
            for (int i = 0; i < pClass->m_dwNumProps; i++)
            {                    
                DWORD dwPropertyID = pClass->m_Properties[i].m_dwPropertyId;
                PropertyData *pPData = NULL;
                SQL_ID dTemp = dwPropertyID;
                m_Cache.Get(dTemp, &pPData);
               
                if (!pPData)
                    continue;
                if (!_wcsnicmp(pPData->m_sPropertyName, lpName, MAX_WIDTH_SCHEMANAME))
                {
                    BOOL bMatch = TRUE;
                    if ((dwFlags & REPDRVR_FLAG_NONPROP) == 
                        (pPData->m_dwFlags & REPDRVR_FLAG_NONPROP))
                    {
                        if (dwFlags & REPDRVR_FLAG_NONPROP)
                        {
                            if (ct != REPDRVR_IGNORE_CIMTYPE)
                            {
                                if (ct != pPData->m_dwCIMType)
                                    bMatch = FALSE;
                            }
                        }
                        if (bMatch)
                        {
                            if (ActualClass)
                                *ActualClass = dCurrClass;
                            if (Flags)
                                *Flags = pPData->m_dwFlags;
                            if (Type)
                                *Type = pPData->m_dwStorageType;
                            PropertyID = dwPropertyID;
                        }
                        break;
                    }
                }
            }

            dCurrClass = pClass->m_dwSuperClassID;

            if (PropertyID || !dCurrClass)
                break;
            pClass = NULL;
            m_CCache.Get(dCurrClass, &pClass);
        }
    }
    else
    {
        CListElement *pNext = m_Cache.FindFirst();
        while (pNext)
        {
            SQL_ID dLast = pNext->m_dId;

            PropertyData *pTemp = (PropertyData *)pNext->m_pObj;
            if (pTemp)
            {
                if (!_wcsnicmp(pTemp->m_sPropertyName,lpName, MAX_WIDTH_SCHEMANAME))
                {
                    PropertyID = pNext->m_dId;
                    if (ActualClass)
                        *ActualClass = pTemp->m_dwClassID;
                    if (Flags)
                        *Flags = pTemp->m_dwFlags;
                    if (Type)
                        *Type = pTemp->m_dwStorageType;
                    break;
                }
            }    
            delete pNext;
            pNext = m_Cache.FindNext(dLast);
        }
    }

    if (PropertyID == 0)
    {
        if (!bSys)
            hr = WBEM_E_NOT_FOUND;
        else if (dClassID!= 1)
            hr = GetPropertyID(lpName, 1, dwFlags, ct, PropertyID, ActualClass, Flags, Type, FALSE);
    }

    return hr;
}

//***************************************************************************
//
//  CSchemaCache::AddPropertyInfo
//
//***************************************************************************

HRESULT CSchemaCache::AddPropertyInfo (DWORD dwPropertyID, LPCWSTR lpName, SQL_ID dwClassID, DWORD dwStorageType,
        DWORD dwCIMType, DWORD dwFlags, SQL_ID dwRefClassID, LPCWSTR lpDefault, DWORD dwRefPropID, DWORD dwFlavor)
{
    _WMILockit lkt(&m_cs);

    HRESULT hr = WBEM_S_NO_ERROR;

    PropertyData *pData = NULL;

    SQL_ID dTemp = dwPropertyID;
    m_Cache.Get(dTemp, &pData);
    if (pData == NULL)
    {
        pData = new PropertyData;
        if (!pData)
            hr = WBEM_E_OUT_OF_MEMORY;
        else
            m_Cache.Insert(dTemp, pData);
    }
    else
        m_dwTotalSize -= pData->GetSize();

    if (pData)
    {
        bool bTruncated = FALSE;
        delete pData->m_sPropertyName;
        pData->m_sPropertyName = TruncateLongText(lpName, MAX_WIDTH_SCHEMANAME, 
            bTruncated, MAX_WIDTH_SCHEMANAME, FALSE);
        if (!pData->m_dwClassID)
            pData->m_dwClassID = dwClassID;
        pData->m_dwStorageType = dwStorageType;
        pData->m_dwCIMType = dwCIMType;
        pData->m_dwFlags = dwFlags;
        pData->m_dwRefClassID = dwRefClassID;
        pData->m_dwQPropID = dwRefPropID;
        pData->m_dwFlavor = dwFlavor;

        ClassData *pCData = NULL;
        m_CCache.Get(dwClassID, &pCData);
        if (pCData)
        {
            pCData->InsertProperty(dwPropertyID, FALSE);
            if (dwFlags & REPDRVR_FLAG_KEYHOLE)
                pCData->m_dwFlags |= REPDRVR_FLAG_KEYHOLE;
            if (dwStorageType == WMIDB_STORAGE_IMAGE)
                pCData->m_dwFlags |= REPDRVR_FLAG_IMAGE;
            if (dwCIMType == CIM_OBJECT)
                pCData->m_dwFlags |= REPDRVR_FLAG_IMAGE;
            m_dwTotalSize += pCData->GetSize();
        }
        m_dwTotalSize += pData->GetSize();
    }
  
    return hr;
}

//***************************************************************************
//
//  CSchemaCache::PropertyChanged
//
//***************************************************************************

bool CSchemaCache::PropertyChanged (LPCWSTR lpName, SQL_ID dwClassID, DWORD dwCIMType, LPCWSTR lpDefault, 
                 DWORD dwFlags, SQL_ID dwRefClassID, DWORD dwRefPropID, DWORD dwFlavor)
{
    _WMILockit lkt(&m_cs);

    bool bChg = true;

    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwPropertyID = 0;
    PropertyData *pData = NULL;

    hr = GetPropertyID(lpName, dwClassID, dwFlags, dwCIMType, dwPropertyID);
    if (SUCCEEDED(hr))
    {
        SQL_ID dTemp = dwPropertyID;
        m_Cache.Get(dTemp, &pData);
        if (pData != NULL)
        {
            bChg = false;

            if (pData->m_dwFlags != dwFlags ||
                pData->m_dwCIMType != dwCIMType ||
                pData->m_dwRefClassID != dwRefClassID ||
                pData->m_dwQPropID != dwRefPropID ||
                _wcsicmp(pData->m_sDefaultValue,lpDefault) ||
                pData->m_dwFlavor != dwFlavor)
                bChg = true;
        }
    }
    
    return bChg;
}

//***************************************************************************
//
//  CSchemaCache::IsQualifier
//
//***************************************************************************

bool CSchemaCache::IsQualifier(DWORD dwPropertyId)
{
    bool bRet = false;
    _WMILockit lkt(&m_cs);

    PropertyData *pData = NULL;
    SQL_ID dTemp = dwPropertyId;
    m_Cache.Get(dTemp, &pData);
    if (pData)
    {
        if (pData->m_dwFlags & REPDRVR_FLAG_QUALIFIER)
            bRet = true;
    }

    return bRet;
}

//***************************************************************************
//
//  CSchemaCache::SetAuxiliaryPropertyInfo
//
//***************************************************************************

HRESULT CSchemaCache::SetAuxiliaryPropertyInfo (DWORD dwPropertyID, LPWSTR lpDefault, DWORD dwRefID)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    PropertyData *pData = NULL;
    
    SQL_ID dTemp = dwPropertyID;
    m_Cache.Get(dTemp, &pData);
    if (pData)
    {
        delete pData->m_sDefaultValue;
        pData->m_sDefaultValue = Macro_CloneLPWSTR(lpDefault);
        pData->m_dwQPropID = dwRefID;
    }
    else
        hr = WBEM_E_NOT_FOUND;

    return hr;
}

//***************************************************************************
//
//  CSchemaCache::DeleteProperty
//
//***************************************************************************

HRESULT CSchemaCache::DeleteProperty (DWORD dwPropertyID, SQL_ID dClassId)
{
    _WMILockit lkt(&m_cs);

    HRESULT hr = WBEM_S_NO_ERROR;

    PropertyData *pData = NULL;
    
    SQL_ID dTemp = dwPropertyID;
    m_Cache.Get(dTemp, &pData);
    if (pData)
    {
        SQL_ID dwClassID = pData->m_dwClassID;
        if (dwClassID == dClassId)
        {
            m_dwTotalSize -= pData->GetSize();

            // delete pData;
            m_Cache.Delete(dwPropertyID);
            ClassData *pCData = NULL;
            m_CCache.Get(dwClassID, &pCData);
            if (pCData)
            {
                m_dwTotalSize -= pCData->GetSize();
                pCData->DeleteProperty(dwPropertyID);            
            }        
        }
    }

    return hr;
}
//***************************************************************************
//
//  CSchemaCache::GetClassInfo
//
//***************************************************************************

HRESULT CSchemaCache::GetClassInfo (SQL_ID dwClassID, _bstr_t &sPath, SQL_ID &dwSuperClassID, SQL_ID &dwScopeID,
                                    DWORD &dwTemp, _bstr_t *pName)
{
    _WMILockit lkt(&m_cs);
    HRESULT hr = WBEM_S_NO_ERROR;

    ClassData *pClass = NULL;
    m_CCache.Get(dwClassID, &pClass);
    if (pClass)
    {
        sPath = pClass->m_sObjectPath;
        if (pName)
            *pName = pClass->m_sName;
        dwSuperClassID = pClass->m_dwSuperClassID;
        dwScopeID = pClass->m_dwScopeID;
        dwTemp = pClass->m_dwFlags;
    }
    else
        hr = WBEM_E_NOT_FOUND;

    return hr;
}

//***************************************************************************
//
//  CSchemaCache::AddClassInfo
//
//***************************************************************************
HRESULT CSchemaCache::AddClassInfo (SQL_ID dwClassID, LPCWSTR lpName, SQL_ID dwSuperClassID, SQL_ID dDynastyId, SQL_ID dwScopeID,
                                    LPCWSTR lpPath, DWORD dwFlags)
{
   _WMILockit lkt(&m_cs); 
   HRESULT hr = WBEM_S_NO_ERROR;

   ClassData *pClass = NULL;
   m_CCache.Get(dwClassID, &pClass);
   if (!pClass)
   {
       pClass = new ClassData;
       if (!pClass)
           hr = WBEM_E_OUT_OF_MEMORY;
   }
   else
       m_dwTotalSize -= pClass->GetSize();

   if (pClass)
   {
       m_CCache.Insert(dwClassID, pClass);
       wchar_t *wTemp = new wchar_t [MAX_WIDTH_SCHEMANAME+30];
       CDeleteMe <wchar_t> r (wTemp);
       if (wTemp)
       {
           bool bTruncated = FALSE;
           delete pClass->m_sName;
           pClass->m_sName = TruncateLongText(lpName, MAX_WIDTH_SCHEMANAME, 
               bTruncated, MAX_WIDTH_SCHEMANAME, FALSE);

           if (wcslen(pClass->m_sName))
           {
               swprintf(wTemp , L"%s_%I64d", pClass->m_sName, dwScopeID);
               m_CIndex[_bstr_t(wTemp)] = dwClassID;
           }

           pClass->m_dwClassID = dwClassID;
           pClass->m_dwSuperClassID = dwSuperClassID;
           pClass->m_dwDynastyID = dDynastyId;

           pClass->m_dwScopeID = dwScopeID;
           delete pClass->m_sObjectPath;
           pClass->m_sObjectPath = Macro_CloneLPWSTR(lpPath);
           pClass->m_dwFlags = dwFlags;

           m_dwTotalSize += pClass->GetSize();
       }
       else
           hr = WBEM_E_OUT_OF_MEMORY;
   }

   if (dwSuperClassID)
   {
       hr = m_CCache.Get(dwSuperClassID, &pClass);
       if (FAILED(hr))
       {
           hr = AddClassInfo(dwSuperClassID, L"", 0, 0, 0, L"", 0);
           if (SUCCEEDED(hr))
           {
               hr = m_CCache.Get(dwSuperClassID, &pClass);
           }
       }
       if (SUCCEEDED(hr))
       {
           pClass->InsertDerivedClass(dwClassID);
       }
   }
       
   return hr;
}

//***************************************************************************
//
//  CSchemaCache::DeleteClass
//
//***************************************************************************
HRESULT CSchemaCache::DeleteClass (SQL_ID dwClassID)
{
    _WMILockit lkt(&m_cs);
    HRESULT hr = WBEM_S_NO_ERROR;
    SQL_ID dParent = 0;

    // Ignore requests to delete meta_class.
    if (dwClassID == 1)
        return WBEM_S_NO_ERROR;

    ClassData *pClass = NULL;
    m_CCache.Get(dwClassID, &pClass);
    if (pClass)
    {
        dParent = pClass->m_dwSuperClassID;
        wchar_t *wTemp = new wchar_t [wcslen(pClass->m_sName)+25];
        CDeleteMe <wchar_t>  r (wTemp);
        if (wTemp)
        {
            swprintf(wTemp, L"%s_%I64d", pClass->m_sName, pClass->m_dwScopeID);

            for (int i = 0; i < pClass->m_dwNumProps; i++)
                DeleteProperty(pClass->m_Properties[i].m_dwPropertyId, dwClassID);

            if (dParent != 0 && dParent != 1)
            {
                hr = m_CCache.Get(dParent, &pClass);
                if (SUCCEEDED(hr))
                {
                    m_dwTotalSize -= pClass->GetSize();
                    pClass->DeleteDerivedClass(dwClassID);
                }
            }

            ClassNames::iterator it = m_CIndex.find(wTemp);
            if (it != m_CIndex.end())
                m_CIndex.erase(it);
            m_CCache.Delete(dwClassID);
        }
        else
           hr = WBEM_E_OUT_OF_MEMORY;
    }
    return hr;

}

//***************************************************************************
//
//  CSchemaCache::GetClassID
//
//***************************************************************************
HRESULT CSchemaCache::GetClassID (LPCWSTR lpName, SQL_ID dwScopeID, SQL_ID &dClassID, SQL_ID *pDynasty)
{
    _WMILockit lkt(&m_cs);
    HRESULT hr = WBEM_S_NO_ERROR;
    BOOL bInNamespace = FALSE;
    SQL_ID dClass;
    dClassID = 0;

    if (!lpName)
        return WBEM_E_NOT_FOUND;

    GetNamespaceClass(dwScopeID, dClass);
    if (dClass == NAMESPACECLASSID ||
        IsDerivedClass(NAMESPACECLASSID, dClass))
        bInNamespace = TRUE;

    SQL_ID dParent = 0;
 
    bool bTrunc = FALSE;

    LPWSTR lpClassName = TruncateLongText(lpName, MAX_WIDTH_SCHEMANAME, 
        bTrunc, MAX_WIDTH_SCHEMANAME, FALSE);
    CDeleteMe<wchar_t> c (lpClassName);

    int iLen = wcslen(lpClassName);

    wchar_t *pTmp = new wchar_t [iLen+25];
    CDeleteMe <wchar_t>  r (pTmp);
    if (pTmp)
    {
        swprintf(pTmp, L"%s_%I64d", lpClassName, dwScopeID);    

        dClassID = m_CIndex[pTmp];
        if (!dClassID)
        {
             if (dwScopeID != 0)
             {
                // Check the hierarchy.  Maybe this is 
                // under a different scope.

                dParent = dwScopeID;
                while (TRUE)
                {                    
                    GetParentNamespace(dParent, dParent);

                    GetNamespaceClass(dParent, dClass);
                    if (dClass == NAMESPACECLASSID ||
                        IsDerivedClass(NAMESPACECLASSID, dClass))
                    {
                        if (bInNamespace)
                            break;
                        else
                            bInNamespace = TRUE;
                    }

                    swprintf(pTmp, L"%s_%I64d", lpClassName, dParent);
                    dClassID = m_CIndex[pTmp];
                    if (!dParent || dClassID)
                        break;
                    
                }
             }
             if (!dClassID)
             {
                 swprintf(pTmp, L"%s_0", lpClassName);
                 dClassID = m_CIndex[pTmp];
             }
        }
        

        if (!dClassID)
            hr = WBEM_E_NOT_FOUND;
        else if (pDynasty)
        {
            ClassData *pClass = NULL;
            hr = m_CCache.Get(dClassID, &pClass);
            if (SUCCEEDED(hr))
                *pDynasty = pClass->m_dwDynastyID;
        }
    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}

//***************************************************************************
//
//  CSchemaCache::GetDynasty
//
//***************************************************************************

HRESULT CSchemaCache::GetDynasty (SQL_ID dClassId, SQL_ID &dDynasty, _bstr_t &sClassName)
{
    HRESULT hr = 0;
    _WMILockit lk(&m_cs);

    ClassData *pClass = NULL;
    dDynasty = 0;

    hr = m_CCache.Get(dClassId, &pClass);
    if (SUCCEEDED(hr))
    {
        if (pClass->m_dwSuperClassID == 1 || pClass->m_dwSuperClassID == 0)
        {
            dDynasty = dClassId;
            sClassName = pClass->m_sName;
        }
        else
        {
            hr = GetDynasty(pClass->m_dwSuperClassID, dDynasty, sClassName);
        }
    }

    return hr;
}


//***************************************************************************
//
//  CSchemaCache::GetNamespaceID
//
//***************************************************************************

HRESULT CSchemaCache::GetNamespaceID(LPCWSTR lpKey, SQL_ID &dObjectId)
{
    _WMILockit lkt(&m_cs);

    HRESULT hr = WBEM_S_NO_ERROR;
    _bstr_t sName = lpKey;
    if (!sName.length())
        sName = L"root";

    dObjectId = CRC64::GenerateHashValue(sName);

    if (!m_NamespaceIds.Exists(dObjectId))
        hr = WBEM_E_NOT_FOUND;

    return hr;
}

//***************************************************************************
//
//  CSchemaCache::GetNamespaceClass
//
//***************************************************************************

HRESULT CSchemaCache::GetNamespaceClass(SQL_ID dScopeId, SQL_ID &dScopeClassId)
{
    NamespaceData *pTemp = NULL;
    HRESULT hr = m_NamespaceIds.Get(dScopeId, &pTemp);
    if (SUCCEEDED(hr))
	{
		dScopeClassId=pTemp->m_dClassId;
	}

	return hr;
}


//***************************************************************************
//
//  CSchemaCache::GetParentNamespace
//
//***************************************************************************

HRESULT CSchemaCache::GetParentNamespace(SQL_ID dObjectId, SQL_ID &dParentId, SQL_ID *dParentClassId)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    dParentId = 0;
    if (dObjectId)
    {
        NamespaceData *pTemp = NULL;
        hr = m_NamespaceIds.Get(dObjectId, &pTemp);
        if (SUCCEEDED(hr))
        {
            dParentId = pTemp->m_dParentId;
            if (dParentClassId && dParentId)
            {
                m_NamespaceIds.Get(dParentId, &pTemp);
                *dParentClassId = pTemp->m_dClassId;
            }
            else if (dParentClassId)
                *dParentClassId = 0;
        }
    }
    else
        hr = WBEM_E_INVALID_PARAMETER;

    return hr;

}

//***************************************************************************
//
//  CSchemaCache::GetNamespaceName
//
//***************************************************************************

HRESULT CSchemaCache::GetNamespaceName(SQL_ID dObjectId, _bstr_t *sName, _bstr_t *sKey)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    _WMILockit lkt(&m_cs);

    if (dObjectId)
    {
        NamespaceData *pTemp = NULL;
        hr = m_NamespaceIds.Get(dObjectId, &pTemp);
        if (SUCCEEDED(hr))
        {
            if (sName)
                *sName = pTemp->m_sNamespaceName;
            if (sKey)
                *sKey = pTemp->m_sNamespaceName;
        }
    }

    return hr;

}

//***************************************************************************
//
//  CSchemaCache::AddNamespace
//
//***************************************************************************

HRESULT CSchemaCache::AddNamespace(LPCWSTR lpName, LPCWSTR lpKey, SQL_ID dObjectId, SQL_ID dParentId, SQL_ID dClassId)
{
    _WMILockit lkt(&m_cs);

    HRESULT hr = WBEM_S_NO_ERROR;

    if (dParentId == dObjectId)
        hr   = WBEM_E_INVALID_PARAMETER;
    else
    {
        // We need to generate an artificial key here, 
        // since our real key was generated from a compressed
        // version of the key.

        if (lpName && wcslen(lpName) && dObjectId != 0)
        {
            NamespaceData *pTemp = new NamespaceData;
            if (pTemp)
            {
                pTemp->m_dNamespaceId = dObjectId;
                delete pTemp->m_sNamespaceName;
                pTemp->m_sNamespaceName = Macro_CloneLPWSTR(lpName);
                pTemp->m_dParentId = dParentId;
                pTemp->m_dClassId = dClassId;

                m_NamespaceIds.Insert(dObjectId, pTemp);
                m_dwTotalSize += pTemp->GetSize();
            }
            else
                hr = WBEM_E_OUT_OF_MEMORY;
        }
        else
            hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;

}

//***************************************************************************
//
//  CSchemaCache::DeleteNamespace
//
//***************************************************************************

HRESULT CSchemaCache::DeleteNamespace(SQL_ID dId)
{
    _WMILockit lkt(&m_cs);

    HRESULT hr = 0;

    if (dId)
    {
        NamespaceData *pTemp = NULL;
        hr = m_NamespaceIds.Get(dId, &pTemp);
        if (SUCCEEDED(hr))
        {
            pTemp -= pTemp->GetSize();
            m_NamespaceIds.Delete(dId);
        }
        hr = WBEM_S_NO_ERROR;
    }
    else
        hr = WBEM_E_INVALID_PARAMETER;

    return hr;
}

//***************************************************************************
//
//  CSchemaCache::IsSubScope
//
//***************************************************************************

bool CSchemaCache::IsSubScope(SQL_ID dParent, SQL_ID dPotentialSubScope)
{
    bool bRet = false;

    SQL_ID dParentID, dScopeClass = 0;
    HRESULT hr = GetParentNamespace(dPotentialSubScope, dParentID, &dScopeClass);
    while (SUCCEEDED(hr))
    {
        if (dParent == dParentID)
        {
            bRet = true;
            break;
        }

        // Stop when we hit our own namespace

        if (IsDerivedClass(NAMESPACECLASSID, dParent))
            break;

        hr = GetParentNamespace(dParentID, dParentID);
    }

    return bRet;
}

//***************************************************************************
//
//  CSchemaCache::GetSubScopes
//
//***************************************************************************

HRESULT CSchemaCache::GetSubScopes(SQL_ID dId, SQL_ID **ppScopes, int &iNumScopes)
{
    HRESULT hr = 0;

    int iSize = 10;

    iNumScopes = 0;
    SQL_ID *pTemp = new SQL_ID [iSize];
    if (!pTemp)
        return WBEM_E_OUT_OF_MEMORY;

    CListElement *pData = NULL;
    SQL_ID dPrevious = 0;

    pData = m_NamespaceIds.FindFirst();

    while (pData != NULL && SUCCEEDED(hr))
    {
        dPrevious = pData->m_dId;
        if (IsSubScope(dId, pData->m_dId))
        {
            if (iNumScopes >= iSize)
            {
                iSize += 10;
                SQL_ID *ppNew = new SQL_ID [iSize];
                if (ppNew)
                {
                    memcpy(ppNew, pTemp, sizeof(SQL_ID) * iSize-10);
                    delete pTemp;
                    pTemp = ppNew;
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                    break;
                }
            }

            pTemp[iNumScopes] = pData->m_dId;
            iNumScopes++;
        }
        delete pData;
       
        pData = m_NamespaceIds.FindNext(dPrevious);
        if (!pData)
            break;
    }

    *ppScopes = pTemp;

    return hr;
}

//***************************************************************************
//
//  CSchemaCache::GetClassObject
//
//***************************************************************************

HRESULT CSchemaCache::GetClassObject (LPWSTR lpMachineName, LPWSTR lpNamespaceName, SQL_ID dScopeId, 
                                      SQL_ID dClassId, IWbemClassObject *pTemp)
{
    _WMILockit lkt(&m_cs);

    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemQualifierSet *pQS = NULL;

    ClassData *pData = NULL;
    m_CCache.Get(dClassId, &pData);
    if (!pData)
        hr = WBEM_E_NOT_FOUND;
    else
    {
        if (SUCCEEDED(hr))
        {
            VARIANT var;

            VariantInit(&var);

            // __CLASS     
            V_BSTR(&var) = Macro_CloneLPWSTR(pData->m_sName);
            var.vt = VT_BSTR;
            hr = pTemp->Put(L"__Class", 0, &var, CIM_STRING);
            VariantClear(&var);
          
            hr = DecorateWbemObj(lpMachineName, lpNamespaceName, dScopeId, pTemp, dClassId);

            // Set common qualifiers.

            pTemp->GetQualifierSet(&pQS);
            if (pData->m_dwFlags & REPDRVR_FLAG_ABSTRACT)
                SetBoolQualifier(pQS, L"abstract", 0);
            pQS->Release();

            // Get every property and qualifier 
            // for this class and all its parents.
            // =======================================

            hr = WBEM_S_NO_ERROR;

            while (TRUE)
            {
                for (int i = 0; i < pData->m_dwNumProps; i++)
                {       
                    DWORD dwPropertyID = pData->m_Properties[i].m_dwPropertyId;
                    PropertyData *pPData = NULL;
                    SQL_ID dTemp = dwPropertyID;
                    m_Cache.Get(dTemp, &pPData);
                    
                    if (!pPData)
                        continue;

                    if (pPData->m_dwFlags & REPDRVR_FLAG_SYSTEM)
                        continue;

                    // If the property is an embedded object, we
                    // need to instantiate a new instance of this
                    // class and add it.  Each property/qualifier
                    // will need to be added also.
                    // ===========================================

                    if (!(pPData->m_dwFlags & REPDRVR_FLAG_QUALIFIER) && !(pPData->m_dwFlags & REPDRVR_FLAG_METHOD)
                        && !(pPData->m_dwFlags & REPDRVR_FLAG_IN_PARAM) && !(pPData->m_dwFlags & REPDRVR_FLAG_OUT_PARAM))
                    {
                        IWbemQualifierSet *pQS = NULL;
                        CIMTYPE ct = pPData->m_dwCIMType;
                        if (pPData->m_dwFlags & REPDRVR_FLAG_ARRAY)
                        {
                            ct |= CIM_FLAG_ARRAY;   
                            var.vt = VT_NULL;
                        }
                        else
                        {
                            if (wcslen(pPData->m_sDefaultValue) > 0)
                            {
                                V_BSTR(&var) = SysAllocString(pPData->m_sDefaultValue);
                                var.vt = VT_BSTR;
                            }
                            else
                            {
                                var.vt = VT_NULL;
                            }
                        }
                        hr = pTemp->Put(pPData->m_sPropertyName, 0, &var, ct);

                        VariantClear(&var);
                    }
                }

                if (FAILED(hr))
                    break;

                for (i = 0; i < pData->m_dwNumProps; i++)
                {       
                    DWORD dwPropertyID = pData->m_Properties[i].m_dwPropertyId;
                    PropertyData *pPData = NULL;
                    SQL_ID dTemp = dwPropertyID;
                    m_Cache.Get(dTemp, &pPData);
                    
                    if (!pPData)
                        continue;

                    if (pPData->m_dwFlags & REPDRVR_FLAG_SYSTEM)
                        continue;

                    if (pPData->m_dwFlags & REPDRVR_FLAG_QUALIFIER)
                    {
                        if (wcslen(pPData->m_sDefaultValue))
                        {
                            IWbemQualifierSet *pQS = NULL;
                            if (pPData->m_dwQPropID != 0)
                            {
                                // property or method qualifier
                                PropertyData *pData = NULL;
                                SQL_ID dTemp = pPData->m_dwQPropID;
                                m_Cache.Get(dTemp, &pData);
                            
                                if (pData)
                                {
                                    if (pData->m_dwFlags & REPDRVR_FLAG_METHOD)
                                        hr = pTemp->GetMethodQualifierSet(pData->m_sPropertyName, &pQS);
                                    else
                                        hr = pTemp->GetPropertyQualifierSet(pData->m_sPropertyName, &pQS);
                                }
                                else
                                    hr = WBEM_E_NOT_FOUND;

                                if (SUCCEEDED(hr))
                                {
                                    V_BSTR(&var) = SysAllocString(pPData->m_sDefaultValue);
                                    var.vt = VT_BSTR;
                                    pQS->Put(pPData->m_sPropertyName, &var, pPData->m_dwFlavor);                                   
                                    pQS->Release();
                                }                                
                            }
                            else
                            {
                                // class qualifier
                                hr = pTemp->GetQualifierSet(&pQS);
                                if (SUCCEEDED(hr))
                                {
                                    V_BSTR(&var) = SysAllocString(pPData->m_sDefaultValue);
                                    var.vt = VT_BSTR;
                                    pQS->Put(pPData->m_sPropertyName, &var, pPData->m_dwFlavor);                                   
                                    pQS->Release();
                                }                                
                            }
                        }
                    }                        
                    else
                    {
                        IWbemClassObject *pIn = NULL, *pOut = NULL;

                        // This is a method or one of its parameters.
                        if (pPData->m_dwFlags & REPDRVR_FLAG_METHOD)
                        {
                            hr = pTemp->PutMethod(pPData->m_sPropertyName, 0, NULL, NULL);
                        }
                        else if ((pPData->m_dwFlags & REPDRVR_FLAG_IN_PARAM) ||
                                  (pPData->m_dwFlags & REPDRVR_FLAG_OUT_PARAM))
                        {
                            // This is handled in GetObjectData.
                        }                            
                    }
                    VariantClear(&var);
                }
               
                if (pData->m_dwSuperClassID <= 1)
                    break;
                else
                {
                    m_CCache.Get(pData->m_dwSuperClassID, &pData);
                    if (!pData)
                        break;
                }

                if (FAILED(hr))
                    break;
            }
        }
    }

    return hr;
}

//***************************************************************************
//
//  CSchemaCache::GetParentId
//
//***************************************************************************

HRESULT CSchemaCache::GetParentId (SQL_ID dClassId, SQL_ID &dParentId)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);
    
    ClassData *pData = NULL;
    m_CCache.Get(dClassId, &pData);
    if (pData)
    {
        dParentId = pData->m_dwSuperClassID;
        if (!dParentId || dParentId == 1)   // Disregard __Class.
            hr = WBEM_E_NOT_FOUND;
    }
    else
        hr = WBEM_E_NOT_FOUND;

    return hr;
}

//***************************************************************************
//
//  CSchemaCache::GetKeyholeProperty
//
//***************************************************************************

HRESULT CSchemaCache::GetKeyholeProperty (SQL_ID dClassId, DWORD &dwPropID, _bstr_t &sPropName)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    _WMILockit lkt(&m_cs);

    ClassData *pData = NULL;
    
    m_CCache.Get(dClassId, &pData);
    if (pData)
    {
        if (pData->m_dwFlags & REPDRVR_FLAG_KEYHOLE)
        {
            // We know we have one.
            for (int i = 0; i < pData->m_dwNumProps; i++)
            {       
                DWORD dwPropertyID = pData->m_Properties[i].m_dwPropertyId;
                PropertyData *pPData = NULL;
                
                SQL_ID dTemp = dwPropertyID;
                m_Cache.Get(dTemp, &pPData);
                
                if (pPData && pPData->m_dwFlags & REPDRVR_FLAG_KEYHOLE)
                {
                    dwPropID = dwPropertyID;
                    sPropName = pPData->m_sPropertyName;
                    hr = WBEM_S_NO_ERROR;
                    break;
                }
            }
        }
    }

    return hr;
}

//***************************************************************************
//
//  CSchemaCache::IsInHierarchy
//
//***************************************************************************

bool CSchemaCache::IsInHierarchy(SQL_ID dParentId, SQL_ID dPotentialChild)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    bool bRet = false;
    _WMILockit lk(&m_cs);

    if (dParentId == dPotentialChild)
        bRet = true;
    else
    {
        bRet = IsDerivedClass(dParentId, dPotentialChild);

        if (!bRet)
        {
            bRet = IsDerivedClass(dPotentialChild, dParentId);
        }
    }
    return bRet;   
}

//***************************************************************************
//
//  CSchemaCache::IsDerivedClass
//
//***************************************************************************

bool CSchemaCache::IsDerivedClass(SQL_ID dParentId, SQL_ID dPotentialChild)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    bool bRet = false;
    _WMILockit lk(&m_cs);

    ClassData *pData = NULL;
    hr = m_CCache.Get(dPotentialChild, &pData);
    while (SUCCEEDED(hr))
    {
        if (pData->m_dwSuperClassID == dParentId)
        {
            bRet = true;
            break;
        }
        hr = m_CCache.Get(pData->m_dwSuperClassID, &pData);
    }

    return bRet;
}

//***************************************************************************
//
//  CSchemaCache::HasImageProp
//
//***************************************************************************

bool CSchemaCache::HasImageProp (SQL_ID dClassId)
{
    bool bRet = false;
    _WMILockit lkt(&m_cs);

    ClassData *pData = NULL;
    
    m_CCache.Get(dClassId, &pData);
    if (pData)
    {
        if (pData->m_dwFlags & REPDRVR_FLAG_IMAGE)
        {
            bRet = true;
        }
    }

    return bRet;
}

//***************************************************************************
//
//  CSchemaCache::Exists
//
//***************************************************************************

BOOL CSchemaCache::Exists (SQL_ID dClassId)
{
    BOOL bRet = FALSE;
    _WMILockit lkt(&m_cs);

    ClassData *pData = NULL;
    m_CCache.Get(dClassId, &pData);
    if (pData && pData->m_dwDynastyID != 0)
        bRet = TRUE;

    return bRet;
}

//***************************************************************************
//
//  CSchemaCache::DecorateWbemObj
//
//***************************************************************************

HRESULT CSchemaCache::DecorateWbemObj(LPWSTR lpMachineName, LPWSTR lpNamespaceName, 
                                      SQL_ID dScopeId, IWbemClassObject *pTemp, SQL_ID dClassId)
{
    _IWmiObject *pInt = NULL;
    HRESULT hr = pTemp->QueryInterface(IID__IWmiObject, (void **)&pInt);
    CReleaseMe r (pInt);
    if (pInt)
    {
        wchar_t *pNs = NULL;        

        // Decorate this instance.  This will let it generate the path.

        // __NAMESPACE

        NamespaceData *pTemp = NULL;
        hr = m_NamespaceIds.Get(dScopeId, &pTemp);
        if (SUCCEEDED(hr) && _wcsicmp(pTemp->m_sNamespaceName, L"root"))
        {
            pNs = new wchar_t [wcslen(lpNamespaceName)+wcslen(pTemp->m_sNamespaceName) + 2];
            if (pNs)
                swprintf(pNs, L"%s\\%s", lpNamespaceName, pTemp->m_sNamespaceName);
        }
        else
        {
            pNs = new wchar_t [wcslen(lpNamespaceName) + 1];
            if (pNs)
                wcscpy(pNs, lpNamespaceName);
        }

        CDeleteMe <wchar_t>  d (pNs);

        // Call some method to decorate the object
        hr = pInt->SetDecoration(lpMachineName, pNs);

    }
    return hr;
}

//***************************************************************************
//
//  CSchemaCache::GetKeys
//
//***************************************************************************

HRESULT CSchemaCache::GetKeys(SQL_ID dNsID, LPCWSTR lpClassName, CWStringArray &arrKeys)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SQL_ID dClassId;

    hr = GetClassID(lpClassName, dNsID, dClassId);
    if (SUCCEEDED(hr))
    {
        _WMILockit lkt(&m_cs);

        ClassData *pClass = NULL;
        
        m_CCache.Get(dClassId, &pClass);

        if (!pClass)
            hr = WBEM_E_NOT_FOUND;

        while (pClass)
        {
            for (int i = 0; i < pClass->m_dwNumProps; i++)
            {   
                if (pClass->m_Properties[i].m_bIsKey)
                {
                    PropertyData *pProp = NULL;
                    SQL_ID dTemp = pClass->m_Properties[i].m_dwPropertyId;
                    m_Cache.Get(dTemp, &pProp);
                    
                    if (pProp)
                        arrKeys.Add(pProp->m_sPropertyName);
                }
            }
            SQL_ID dSC = pClass->m_dwSuperClassID;
            pClass = NULL;
            if (!arrKeys.Size() && dSC)
                m_CCache.Get(dSC, &pClass);
        }                    
    }

    return hr;
}

//***************************************************************************
//
//  CSchemaCache::IsKey
//
//***************************************************************************

BOOL CSchemaCache::IsKey(SQL_ID dClassId, DWORD dwPropID, BOOL &bLocal)
{
    // Does this property already exist in the hierarchy as a key??

    BOOL bRet = FALSE;

    _WMILockit lkt(&m_cs);
    BOOL bDone = FALSE;

    ClassData *pClass = NULL;
    
    m_CCache.Get(dClassId, &pClass);
    bLocal = TRUE;
    if (!pClass)
        bRet = FALSE;

    while (pClass)
    {
        for (int i = 0; i < pClass->m_dwNumProps; i++)
        {   
            PropertyData *pProp = NULL;
            SQL_ID dTemp = pClass->m_Properties[i].m_dwPropertyId;
            if (dwPropID == dTemp)
            {
                bRet = (pClass->m_Properties[i].m_bIsKey); // Return the first place this ID is defined.
                bDone = TRUE;
                break;
            }
        }

        if (bDone)
            break;

        SQL_ID dSC = pClass->m_dwSuperClassID;
        pClass = NULL;
        if (!bRet && !dSC)
        {
            m_CCache.Get(dSC, &pClass);
            bLocal = FALSE;
        }
    }                    

    return bRet;
}

//***************************************************************************
//
//  CSchemaCache::SetIsKey
//
//***************************************************************************

HRESULT CSchemaCache::SetIsKey (SQL_ID dClassId, DWORD dwPropID, BOOL bIsKey)
{
    HRESULT hr = 0;
    BOOL bDone = FALSE;
    _WMILockit lkt(&m_cs);

    ClassData *pClass = NULL;
    
    m_CCache.Get(dClassId, &pClass);
    
    if (!pClass)
        hr = WBEM_E_NOT_FOUND;
    else
        pClass->InsertProperty(dwPropID, bIsKey);

    return hr;
}

//***************************************************************************
//
//  CSchemaCache::GetKeyRoot
//
//***************************************************************************

LPWSTR CSchemaCache::GetKeyRoot (LPWSTR lpClassName, SQL_ID dScopeId)
{
    LPWSTR lpRet = NULL;

    SQL_ID dClassId;
    SQL_ID dRetClass = 0;
    HRESULT hr = GetClassID (lpClassName, dScopeId, dClassId);
    if (SUCCEEDED(hr))
    {
        _WMILockit lkt(&m_cs);

        ClassData *pClass = NULL;
        
        m_CCache.Get(dClassId, &pClass);

        if (!pClass)
            hr = WBEM_E_NOT_FOUND;

        while (pClass)
        {
            // Find the topmost class that has a key property,
            // or the topmost singleton or unkeyed class.
           
            if (pClass->m_dwFlags & REPDRVR_FLAG_SINGLETON ||
                pClass->m_dwFlags & REPDRVR_FLAG_UNKEYED)
            {
                dRetClass = pClass->m_dwClassID;                
            }
            else
            {
                for (int i = 0; i < pClass->m_dwNumProps; i++)
                {   
                    if (pClass->m_Properties[i].m_bIsKey) 
                    {
                        dRetClass = pClass->m_dwClassID;
                        break;
                    }
                }
            }

            SQL_ID dSC = pClass->m_dwSuperClassID;
            pClass = NULL;
            if (dSC)
                m_CCache.Get(dSC, &pClass);
            else
                break;
        }

        if (dRetClass)
        {
            m_CCache.Get(dRetClass, &pClass);
            int iSize = wcslen(pClass->m_sName);
            if (iSize)
            {
                lpRet = new wchar_t [iSize+1];
                if (lpRet)
                    wcscpy(lpRet, pClass->m_sName);
                else
                    hr = WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
            hr = WBEM_E_NOT_FOUND;
    }

    return lpRet;
}

//***************************************************************************
//
//  CSchemaCache::GetPropertyList
//
//***************************************************************************

HRESULT CSchemaCache::GetPropertyList (SQL_ID dClassId, Properties &pProps, DWORD *pwNumProps)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    ClassData *pClass = NULL;
    
    m_CCache.Get(dClassId, &pClass);
    if (pClass)
    {
        for (int i = 0; i < pClass->m_dwNumProps; i++)
        {       
            DWORD dwPropertyID = pClass->m_Properties[i].m_dwPropertyId;
            pProps[dwPropertyID] = 0;
        }
        if (pwNumProps)
            *pwNumProps = pClass->m_dwNumProps;
    }
    else
        WBEM_E_NOT_FOUND;

    return hr;
}

//***************************************************************************
//
//  CSchemaCache::ValidateProperty
//
//***************************************************************************

HRESULT CSchemaCache::ValidateProperty (SQL_ID dObjectId, DWORD dwPropertyID, DWORD dwFlags, CIMTYPE cimtype, DWORD dwStorageType, 
            LPWSTR lpDefault, BOOL &bChg, BOOL &bIfNoInstances)
{

    HRESULT hr = WBEM_S_NO_ERROR;
    PropertyData *pData = NULL;
    _WMILockit lkt(&m_cs);
    bChg = TRUE; // We can't tell if the default changed or not, since it ain't cached.
    BOOL bIfNoChildren = FALSE;

    SQL_ID dTemp = dwPropertyID;
    m_Cache.Get(dTemp, &pData);
    if (pData)
    {
        if (pData->m_dwFlags != dwFlags ||
            pData->m_dwCIMType != cimtype)
            bChg = TRUE;

        BOOL bLocal = FALSE;
        BOOL bOldKeyStatus = IsKey(dObjectId, dwPropertyID, bLocal);
        BOOL bNewKeyStatus = ((dwFlags & REPDRVR_FLAG_KEY) ? TRUE : FALSE);

        if (bOldKeyStatus != bNewKeyStatus)
        {
            bIfNoChildren = TRUE; 
            bIfNoInstances = TRUE;
        }

        // Check for a legal conversion.
        // We can only change datatypes to larger types of same storage type
        // Except that we can change ints to larger reals.
        if (pData->m_dwCIMType != cimtype)
        {
            if (dwStorageType != pData->m_dwStorageType)
            {
                if (!(pData->m_dwStorageType == WMIDB_STORAGE_NUMERIC &&
                    dwStorageType == WMIDB_STORAGE_REAL))
                    hr = WBEM_E_INVALID_OPERATION;
            }

            if (SUCCEEDED(hr))
            {
                // Make sure the conversion is to a bigger or same storage unit.

                switch(cimtype)
                {
                case CIM_UINT8:
                case CIM_SINT8:
                    switch(pData->m_dwCIMType)
                    {
                    case CIM_UINT8:
                    case CIM_SINT8:
                    case CIM_BOOLEAN:
                        hr = WBEM_S_NO_ERROR;
                        break;
                    default:
                        hr = WBEM_E_INVALID_OPERATION;
                        break;
                    }
                    break;
                case CIM_UINT16:
                case CIM_SINT16:
                    switch(pData->m_dwCIMType)
                    {
                    case CIM_UINT16:
                    case CIM_SINT16:
                    case CIM_UINT8:
                    case CIM_SINT8:
                    case CIM_BOOLEAN:
                        hr = WBEM_S_NO_ERROR;
                        break;
                    default:
                        hr = WBEM_E_INVALID_OPERATION;
                        break;
                    }
                    break;
                case CIM_UINT32:
                case CIM_SINT32:
                case CIM_REAL32:
                    switch(pData->m_dwCIMType)
                    {
                    case CIM_UINT32:
                    case CIM_SINT32:
                    case CIM_UINT16:
                    case CIM_SINT16:
                    case CIM_UINT8:
                    case CIM_SINT8:
                    case CIM_BOOLEAN:
                        hr = WBEM_S_NO_ERROR;
                        break;
                    default:
                        hr = WBEM_E_INVALID_OPERATION;
                        break;
                    }
                    break;
                case CIM_UINT64:
                case CIM_SINT64:
                    switch(pData->m_dwCIMType)
                    {
                    case CIM_UINT64:
                    case CIM_SINT64:
                    case CIM_UINT32:
                    case CIM_SINT32:
                    case CIM_UINT16:
                    case CIM_SINT16:
                    case CIM_UINT8:
                    case CIM_SINT8:
                    case CIM_BOOLEAN:
                        hr = WBEM_S_NO_ERROR;
                        break;
                    default:
                        hr = WBEM_E_INVALID_OPERATION;
                        break;
                    }
                    break;
                case CIM_REAL64:
                    switch(pData->m_dwCIMType)
                    {
                    case CIM_REAL32:
                    case CIM_UINT64:
                    case CIM_SINT64:
                    case CIM_UINT32:
                    case CIM_SINT32:
                    case CIM_UINT16:
                    case CIM_SINT16:
                    case CIM_UINT8:
                    case CIM_SINT8:
                    case CIM_BOOLEAN:
                        hr = WBEM_S_NO_ERROR;
                        break;
                    default:
                        hr = WBEM_E_INVALID_OPERATION;
                        break;
                    }
                    break;
                default:
                    hr = WBEM_E_INVALID_OPERATION; // strings, refs, datetimes, etc.
                    break;
                }
            }
        }

        if (bIfNoChildren)
        {
            // Fail if we have subclasses.

            SQLIDs ids;
            int iNumChildren = 0;

            hr = GetDerivedClassList(dObjectId, ids, iNumChildren);
            if (SUCCEEDED(hr))
            {
                if (iNumChildren != 0)
                    hr = WBEM_E_CLASS_HAS_CHILDREN;                    
            }
        }
    }
    else
    {
        if (dwFlags & REPDRVR_FLAG_KEY)
            bIfNoInstances = TRUE; // Can't add a key if there are instances.
    }

    return hr;

}

//***************************************************************************
//
//  CSchemaCache::FindProperty
//
//***************************************************************************

HRESULT CSchemaCache::FindProperty(SQL_ID dObjectId, LPWSTR lpPropName, DWORD dwFlags, CIMTYPE ct)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Does this property already exist in a derived class?

    SQLIDs ids;
    int iNumChildren = 0;

    hr = GetDerivedClassList(dObjectId, ids, iNumChildren);
    if (SUCCEEDED(hr))
    {
        for (int i = 0; i < iNumChildren; i++)
        {
            SQL_ID dTemp = ids.at(i);
            DWORD dwTempID = 0;
            if (GetPropertyID(lpPropName, dTemp, dwFlags, ct, dwTempID) == WBEM_S_NO_ERROR)
            {
                hr = WBEM_E_PROPAGATED_PROPERTY;
                break;
            }
        }
    }
    else if (!dObjectId)
        hr = WBEM_S_NO_ERROR;

    return hr;
}

//***************************************************************************
//
//  CSchemaCache::GetDerivedClassList
//
//***************************************************************************

HRESULT CSchemaCache::GetDerivedClassList(SQL_ID dObjectId, SQL_ID **ppIDs, 
                                          int &iNumChildren, BOOL bImmediate)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    SQLIDs ids;

    hr = GetDerivedClassList(dObjectId, ids, iNumChildren, bImmediate);
    if (SUCCEEDED(hr))
    {
        SQL_ID *pTemp = new SQL_ID [iNumChildren];
        if (pTemp)
        {
            for (int i = 0; i < iNumChildren; i++)
            {
                pTemp[i] = ids.at(i);
            }
            *ppIDs = pTemp;
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;

}



//***************************************************************************
//
//  CSchemaCache::GetDerivedClassList
//
//***************************************************************************

HRESULT CSchemaCache::GetDerivedClassList(SQL_ID dObjectId, SQLIDs &children, 
                                          int &iNumChildren, BOOL bImmediate)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    ClassData *pClass = NULL;
    m_CCache.Get(dObjectId, &pClass);
    if (pClass)
    {
        for (int i = 0; i < pClass->m_DerivedIDs.size(); i++)
        {
            SQL_ID dChild = pClass->m_DerivedIDs.at(i);
            children.push_back(dChild);
            iNumChildren++;

            if (!bImmediate)
                hr = GetDerivedClassList(dChild, children, iNumChildren);
        }
    }
    return hr;

}

//***************************************************************************
//
//  CSchemaCache::GetHierarchy
//
//***************************************************************************

HRESULT CSchemaCache::GetHierarchy(SQL_ID dObjectId, SQL_ID **ppIDs, int &iNumIDs)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    int iSize = 0;

    // Populate the ID list of derived *and* parent class IDs.

    SQLIDs ids;
    hr = GetHierarchy(dObjectId, ids, iNumIDs);
    if (SUCCEEDED(hr))
    {
        SQL_ID *pIDs = new SQL_ID [iNumIDs];
        if (pIDs)
        {
            for (int i = 0; i < iNumIDs; i++)
            {
                pIDs[i] = ids.at(i);
            }
            *ppIDs = pIDs;
        }
    }

    return hr;

}

//***************************************************************************
//
//  CSchemaCache::GetHierarchy
//
//***************************************************************************

HRESULT CSchemaCache::GetHierarchy(SQL_ID dObjectId, SQLIDs &ids, int &iNumIDs)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    int iSize = 0;

    // Populate the ID list of derived *and* parent class IDs.
    hr = GetDerivedClassList(dObjectId, ids, iNumIDs);
    if (SUCCEEDED(hr))
    {
        SQL_ID dTemp = dObjectId;

        // Load up all the parents.

        while (SUCCEEDED(GetParentId(dTemp, dTemp)))
        {
            ids.push_back(dTemp);
            iNumIDs++;

        }

    }

    return hr;

}

//***************************************************************************
//
//  CSchemaCache::ResizeCache
//
//***************************************************************************

HRESULT CSchemaCache::ResizeCache()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    SQLIDs ids;

    // Unload an existing dynasty to make room.

    SQLRefCountMap::iterator item = m_DynastiesInUse.begin();
    while (item != m_DynastiesInUse.end())    
    {
        if ((*item).second == 0)
        {
            hr = DeleteDynasty((*item).first);            

            ids.push_back((*item).first);

            if (m_dwTotalSize < m_dwMaxSize || item == m_DynastiesInUse.end())
                break;
        }
        item++;
    }

    for (int i = 0; i < ids.size(); i++)
        m_DynastiesInUse.erase(m_DynastiesInUse.find(ids.at(i)));

    return hr;
}

//***************************************************************************
//
//  CSchemaCache::LockDynasty
//
//***************************************************************************

HRESULT CSchemaCache::LockDynasty(SQL_ID dDynastyId)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    ULONG uRefCount = 0;
    _WMILockit lkt(&m_cs);

    SQLRefCountMap::iterator it = m_DynastiesInUse.find(dDynastyId);
    if (it != m_DynastiesInUse.end())
        uRefCount = (*it).second;

    InterlockedIncrement((LONG *) &uRefCount);
    m_DynastiesInUse[dDynastyId] = uRefCount;

    return hr;
}

//***************************************************************************
//
//  CSchemaCache::UnlockDynasty
//
//***************************************************************************

HRESULT CSchemaCache::UnlockDynasty(SQL_ID dDynastyId)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    ULONG uRefCount = m_DynastiesInUse[dDynastyId];
    InterlockedDecrement((LONG *) &uRefCount);
    m_DynastiesInUse[dDynastyId] = uRefCount;

    return hr;

}
//***************************************************************************
//
//  CSchemaCache::DeleteDynasty
//
//***************************************************************************

HRESULT CSchemaCache::DeleteDynasty(SQL_ID dDynastyId)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (dDynastyId == 1)
        return WBEM_S_NO_ERROR;

    // Delete all class info for members of this dynasty.

    SQLIDs ids;
    int iNum;
    // Immediate only, so we don't inadvertently
    // blow away a protected dynasty.

    hr = GetDerivedClassList(dDynastyId, ids, iNum, TRUE);
    if (SUCCEEDED(hr))
    {
        DeleteClass(dDynastyId);
        for (int i = 0; i < ids.size(); i++)
        {
            SQL_ID d = ids.at(i);
            ULONG uRefCount = 0;

            SQLRefCountMap::iterator it = m_DynastiesInUse.find(d);
            if (it != m_DynastiesInUse.end())
                uRefCount = (*it).second;

            if (!uRefCount)
                hr = DeleteDynasty(d);
        }
    }

    return hr;
}

//***************************************************************************
//
//  CSchemaCache::IsSystemClass
//
//***************************************************************************

BOOL CSchemaCache::IsSystemClass(SQL_ID dObjectId, SQL_ID dClassId)
{
    BOOL bRet = FALSE;

    _WMILockit lkt(&m_cs);
    HRESULT hr = WBEM_S_NO_ERROR;

    ClassData *pClass = NULL;
    if (dClassId == 1)
        m_CCache.Get(dObjectId, &pClass);
    else
        m_CCache.Get(dClassId, &pClass);

    if (pClass)
    {
        if (pClass->m_sName && pClass->m_sName[0] == L'_')
            bRet = TRUE;
    }

    return bRet;
}

//***************************************************************************
//
//  CSchemaCache::GetWriteToken
//
//***************************************************************************

DWORD CSchemaCache::GetWriteToken(SQL_ID dObjectId, SQL_ID dClassId)
{
    DWORD dwRet = WBEM_PARTIAL_WRITE_REP;
    BOOL bRet = IsSystemClass(dObjectId, dClassId);

    if (bRet)
        dwRet = WBEM_FULL_WRITE_REP;

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\clsfctry.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  clsfctry.CPP
//
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//  History:
//
//      cvadai      4/1/99
//
//  Copyright (c)1999-2001 Microsoft Corporation, All Rights Reserved
///////////////////////////////////////////////////////////////////////////////


#define DEFINEGUID

#include "precomp.h"
#include <std.h>
#include "clsfctry.h"
#include "repdrvr.h"

long       g_cObj       = 0;       // Number of objects created
long       g_cLock      = 0;       // Number of locks on the DLL

//-----------------------------------------------------------------------------
// CControllerFactory::CControllerFactory
// CControllerFactory::~CControllerFactory
//
// Constructor Parameters:
//  None
//

CControllerFactory::CControllerFactory()
{
    m_cRef=0L;
    return;
}

CControllerFactory::~CControllerFactory(void)
{
    return;
}



//-----------------------------------------------------------------------------
// CControllerFactory::QueryInterface
// CControllerFactory::AddRef
// CControllerFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//

STDMETHODIMP CControllerFactory::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CControllerFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CControllerFactory::Release(void)
{
    if (0L!=--m_cRef)
        return m_cRef;

    delete this;
    return 0L;
}



//-----------------------------------------------------------------------------
// CControllerFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//
//

STDMETHODIMP CControllerFactory::CreateInstance
    (
            LPUNKNOWN   pUnkOuter, 
            REFIID      riid, 
            void **     ppvObj
    )
{
    IUnknown *   pObj = NULL;
    HRESULT             hr;

    *ppvObj=NULL;
    hr=ResultFromScode(E_OUTOFMEMORY);

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    //Create the object passing function to notify on destruction.
  
    pObj = new CWmiDbController();
    if (NULL==pObj)
        return hr;

    g_cObj++; // Only controllers should make the DLL stick around, right?
    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if (FAILED(hr))
        delete pObj;

    return hr;
}



//-----------------------------------------------------------------------------
// CControllerFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//

STDMETHODIMP CControllerFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}


//-----------------------------------------------------------------------------
// CQueryFactory::CQueryFactory
// CQueryFactory::~CQueryFactory
//
// Constructor Parameters:
//  None
//

CQueryFactory::CQueryFactory()
{
    m_cRef=0L;
    return;
}

CQueryFactory::~CQueryFactory(void)
{
    return;
}



//-----------------------------------------------------------------------------
// CQueryFactory::QueryInterface
// CQueryFactory::AddRef
// CQueryFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//

STDMETHODIMP CQueryFactory::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CQueryFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CQueryFactory::Release(void)
{
    if (0L!=--m_cRef)
        return m_cRef;

    delete this;
    return 0L;
}



//-----------------------------------------------------------------------------
// CQueryFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//
//

STDMETHODIMP CQueryFactory::CreateInstance
    (
            LPUNKNOWN   pUnkOuter, 
            REFIID      riid, 
            void **     ppvObj
    )
{
    return E_FAIL;
}



//-----------------------------------------------------------------------------
// CQueryFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//

STDMETHODIMP CQueryFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\repcache.h ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   repcache.h
//
//   cvadai     19-Mar-99       Created as prototype for Quasar.
//
//***************************************************************************

#ifndef _REPCACHE_H_
#define _REPCACHE_H_

#pragma warning( disable : 4251 ) //  needs to have dll-interface to be used by clients of class

#include <std.h>
#include <objcache.h>
#include <sqlcache.h>

//***************************************************************************
//  CLockCache
//***************************************************************************

#define REPDRVR_FLAG_NONPROP REPDRVR_FLAG_IN_PARAM + REPDRVR_FLAG_OUT_PARAM + REPDRVR_FLAG_QUALIFIER + REPDRVR_FLAG_METHOD
#define REPDRVR_IGNORE_CIMTYPE -1

class LockItem
{
public:
    IUnknown *m_pObj;
    DWORD    m_dwHandleType;
    bool     m_bLockOnChild;
    SQL_ID   m_dSourceId;
    DWORD    m_dwVersion;

    LockItem() {m_dSourceId = 0; m_bLockOnChild=false; m_dwHandleType = 0; m_pObj = NULL;}
    ~LockItem() {};
};

class LockData
{
    typedef std::vector<LockItem *> LockList;
    typedef std::map<SQL_ID, bool> SQL_IDMap;
public:
    SQL_ID   m_dObjectId;
    DWORD    m_dwStatus;
    DWORD    m_dwCompositeStatus;
    DWORD    m_dwVersion;
    DWORD    m_dwCompositeVersion;
    DWORD    m_dwNumLocks;

    LockList  m_List;

    SQL_IDMap m_OwnerIds;

    LockData() {m_dObjectId = 0; m_dwStatus = 0; m_dwVersion = 0;m_dwNumLocks = 0;};
    ~LockData() {};

    DWORD   GetMaxLock(bool bImmediate, bool bSubScopeOnly=false);
    bool    LockExists (DWORD dwHandleType);
};


class CLockCache
{    
public:
    HRESULT GetHandle(SQL_ID ObjId, DWORD dwType, IWmiDbHandle **ppRet);
    HRESULT AddLock(bool bImmediate, SQL_ID ObjId, DWORD Type, IUnknown *pUnk, SQL_ID dNsId, 
        SQL_ID dClassId, CSchemaCache *pCache, bool bChg = false, bool bChildLock = false, SQL_ID SourceId =0,
        DWORD *CurrVersion=NULL);
    HRESULT DeleteLock(SQL_ID ObjId, bool bChildLock, DWORD HandleType = 0, bool bDelChildren = true, void *pObj=NULL);
    HRESULT GetCurrentLock(SQL_ID ObjId, bool bImmediate, DWORD &HandleType, DWORD *Version=NULL);
    HRESULT GetAllLocks(SQL_ID ObjId, SQL_ID ClassId, SQL_ID NsId, CSchemaCache *pCache, bool bImmediate, DWORD &HandleType, DWORD *Version=NULL);
    bool    CanLockHandle (SQL_ID ObjId, DWORD RequestedHandleType, bool bImmediate, bool bSubscopedOnly=true);
    bool    CanRenderObject (SQL_ID ObjId, SQL_ID ClassId, SQL_ID NsId, CSchemaCache *pCache, DWORD RequestedHandleType, bool bImmediate);
    HRESULT IncrementVersion(SQL_ID ObjId);

    CLockCache() {InitializeCriticalSection(&m_cs);};
    ~CLockCache();

private:
    CHashCache<LockData *> m_Cache;
    CRITICAL_SECTION m_cs;
};

//***************************************************************************
//  CObjectCache
//***************************************************************************


// Object cache.  This needs to have a timeout value.
// Also, we need a marker for "strong cache" requests.

struct CacheInfo
{
public:
    SQL_ID           m_dObjectId;
    SQL_ID           m_dClassId;
    SQL_ID           m_dScopeId;
    time_t           m_tLastAccess;
    LPWSTR           m_sPath;
    IWbemClassObject *m_pObj;
    bool             m_bStrong;

    CacheInfo() {m_sPath = NULL;};
    ~CacheInfo() 
    {
        if ( m_pObj != NULL )
        {
            m_pObj->Release();
        }
        delete m_sPath;
    };
};

class CObjectCache
{
public:
    CObjectCache();
    ~CObjectCache();
    
     HRESULT GetObject (LPCWSTR lpPath, IWbemClassObject **ppObj, SQL_ID *dScopeId = NULL);
     HRESULT GetObjectId (LPCWSTR lpPath, SQL_ID &dObjId, SQL_ID &dClassId, SQL_ID *dScopeId=NULL);
     HRESULT GetObject (SQL_ID dObjectId, IWbemClassObject **ppObj, SQL_ID *dScopeId = NULL);
     HRESULT PutObject (SQL_ID dObjectId, SQL_ID dClassId, SQL_ID dScopeId, 
            LPCWSTR lpPath, bool bStrongCache, IWbemClassObject *pObj);
     HRESULT DeleteObject (SQL_ID dObjectId);
     bool    ObjectExists (SQL_ID dObjectId);

     HRESULT SetCacheSize(const DWORD dwMaxSize);
     HRESULT GetCurrentUsage(DWORD &dwBytesUsed);
     HRESULT GetCacheSize(DWORD &dwSizeInBytes);

     HRESULT FindFirst(SQL_ID &dObjectId, SQL_ID &dClassId, SQL_ID *dScopeId = NULL);
     HRESULT FindNext (SQL_ID dLastId, SQL_ID &dObjectId, SQL_ID &dClassId, SQL_ID *dScopeId = NULL);

     void EmptyCache();

private:
     DWORD   GetSize(IWbemClassObject *pObj);
     HRESULT ResizeCache(DWORD dwReqBytes, SQL_ID dLeave, bool bForce=true);


     CHashCache<CacheInfo *>  m_ObjCache;
     //CQuasarStringList      m_PathIndex;

     DWORD       m_dwMaxSize;
     DWORD       m_dwUsed;
     CRITICAL_SECTION m_cs;
};


//***************************************************************************
//  CSchemaCache
//***************************************************************************

class PropertyData
{
public:    
    LPWSTR  m_sPropertyName;
    SQL_ID  m_dwClassID;
    DWORD   m_dwStorageType;
    DWORD   m_dwCIMType;
    DWORD   m_dwFlags;
    SQL_ID  m_dwRefClassID;
    DWORD   m_dwQPropID;
    LPWSTR  m_sDefaultValue;
    DWORD   m_dwFlavor;

    PropertyData();
    ~PropertyData(){delete m_sPropertyName; delete m_sDefaultValue;};

    DWORD GetSize();
};

struct PropertyList
{
    DWORD m_dwPropertyId;
    BOOL  m_bIsKey;
};

class ClassData
{
public:
    typedef std::vector <SQL_ID> SQLIDs;

    LPWSTR      m_sName;
    SQL_ID      m_dwClassID;
    SQL_ID      m_dwSuperClassID;
    SQL_ID      m_dwDynastyID;
    SQL_ID      m_dwScopeID;
    LPWSTR      m_sObjectPath;
    PropertyList *m_Properties;
    DWORD       m_dwNumProps;
    DWORD       m_dwArraySize;
    DWORD       m_dwFlags;
    SQLIDs      m_DerivedIDs;  

    ClassData();
    ~ClassData(){delete m_Properties; delete m_sName; delete m_sObjectPath;};

    void InsertProperty (DWORD PropId, BOOL bIsKey);
    void DeleteProperty (DWORD PropId);
    void InsertDerivedClass (SQL_ID dID);
    void DeleteDerivedClass (SQL_ID dID);

    DWORD GetSize();
};

class NamespaceData
{
public:
    LPWSTR     m_sNamespaceName;
    LPWSTR     m_sNamespaceKey;
    SQL_ID     m_dNamespaceId;
    SQL_ID     m_dParentId;
    SQL_ID     m_dClassId;

    NamespaceData() {m_sNamespaceName = NULL; m_sNamespaceKey = NULL; };
    ~NamespaceData() {delete m_sNamespaceName; delete m_sNamespaceKey;};

    DWORD GetSize();
};

class _bstr_tNoCase
{
public:
    inline bool operator()(const _bstr_t ws1, const _bstr_t ws2) const
        {return _wcsicmp(ws1, ws2) < 0;}
};

class CSchemaCache
{
    typedef std::map <DWORD, DWORD> Properties;
    typedef std::map <_bstr_t, SQL_ID, _bstr_tNoCase> ClassNames;
    typedef std::map<SQL_ID, ULONG> SQLRefCountMap;
    typedef std::vector <SQL_ID> SQLIDs;
 public:
    CSchemaCache();
    ~CSchemaCache();

    HRESULT GetPropertyInfo (DWORD dwPropertyID, _bstr_t *sName=NULL, SQL_ID *dwClassID=NULL, DWORD *dwStorageType=NULL,
        DWORD *dwCIMType=NULL, DWORD *dwFlags=NULL, SQL_ID *dwRefClassID=NULL, _bstr_t *sDefaultValue=NULL, 
        DWORD *dwRefPropID=NULL, DWORD *dwFlavor=NULL);
    HRESULT GetPropertyID (LPCWSTR lpName, SQL_ID dClassID, DWORD dwFlags, CIMTYPE ct, 
        DWORD &PropertyID, SQL_ID *ActualClass = NULL, DWORD *Flags = NULL, DWORD *Type = NULL, BOOL bSys = FALSE);
    HRESULT AddPropertyInfo (DWORD dwPropertyID, LPCWSTR lpName, SQL_ID dwClassID, DWORD dwStorageType,
        DWORD dwCIMType, DWORD dwFlags, SQL_ID dwRefClassID, LPCWSTR lpDefault, DWORD dwRefPropID, DWORD dwFlavor);
    bool PropertyChanged (LPCWSTR lpName, SQL_ID dwClassID,DWORD dwCIMType, LPCWSTR lpDefault=NULL, 
                 DWORD dwFlags=0, SQL_ID dwRefClassID=0, DWORD dwRefPropID=0, DWORD dwFlavor=0);
    bool IsQualifier(DWORD dwPropertyId);
    HRESULT SetAuxiliaryPropertyInfo (DWORD dwPropertyID, LPWSTR lpDefault, DWORD dwRefID);
    HRESULT DeleteProperty (DWORD dwPropertyID, SQL_ID dClassId);

    HRESULT GetClassInfo (SQL_ID dwClassID, _bstr_t &sPath, SQL_ID &dwSuperClassID, SQL_ID &dwScopeID,
        DWORD &dwFlags, _bstr_t *sName = NULL);
    HRESULT AddClassInfo (SQL_ID dwClassID, LPCWSTR lpName, SQL_ID dwSuperClassID, SQL_ID dwDynasty, SQL_ID dwScopeID,
        LPCWSTR lpPath, DWORD dwFlags);
    HRESULT DeleteClass (SQL_ID dwClassID);
    HRESULT GetClassID (LPCWSTR lpClassName, SQL_ID dwScopeID, SQL_ID &dClassID, SQL_ID *pDynasty = NULL);
    HRESULT GetDynasty (SQL_ID dClassId, SQL_ID &dDynasty, _bstr_t &sClassName);
    HRESULT GetClassObject (LPWSTR lpMachineName, LPWSTR lpNamespaceName, SQL_ID dScopeId, SQL_ID dClassId, 
            IWbemClassObject *pNewObj);
    HRESULT GetParentId (SQL_ID dClassId, SQL_ID &dParentId);
    HRESULT GetKeyholeProperty (SQL_ID dClassId, DWORD &dwPropID, _bstr_t &sPropName);
    bool IsInHierarchy (SQL_ID dParentId, SQL_ID dPotentialChild);
    bool IsDerivedClass(SQL_ID dParentId, SQL_ID dPotentialChild);
    bool HasImageProp (SQL_ID dClassId);
    BOOL Exists (SQL_ID dClassId);

    HRESULT GetNamespaceID(LPCWSTR lpKey, SQL_ID &dObjectId);
	HRESULT GetNamespaceClass(SQL_ID dScopeId, SQL_ID &dScopeClassId);
    HRESULT GetParentNamespace(SQL_ID dObjectId, SQL_ID &dParentId, SQL_ID *dParentClassId = NULL);
    HRESULT GetNamespaceName(SQL_ID dObjectId, _bstr_t *sName = NULL, _bstr_t *sKey = NULL);
    HRESULT AddNamespace(LPCWSTR lpName, LPCWSTR lpKey, SQL_ID dObjectId, SQL_ID dParentId, SQL_ID m_dClassId);
    HRESULT DeleteNamespace(SQL_ID dId);
    bool IsSubScope(SQL_ID dParent, SQL_ID dPotentialSubScope);
    HRESULT GetSubScopes(SQL_ID dId, SQL_ID **ppScopes, int &iNumScopes);

    HRESULT DecorateWbemObj (LPWSTR lpMachineName, LPWSTR lpNamespaceName, SQL_ID dScopeId, IWbemClassObject *pObj, SQL_ID dClassId);
    HRESULT GetKeys(SQL_ID dNsID, LPCWSTR lpClassName, CWStringArray &arrKeys);
    BOOL    IsKey(SQL_ID dClassId, DWORD dwPropID, BOOL &bLocal);
    HRESULT SetIsKey (SQL_ID dClassId, DWORD dwPropID, BOOL bIsKey = TRUE);
    LPWSTR  GetKeyRoot (LPWSTR lpClassName, SQL_ID dScopeId);
    HRESULT GetPropertyList (SQL_ID dClassId, Properties &pProps, DWORD *pwNumProps= NULL);

    HRESULT ValidateProperty (SQL_ID dObjectId, DWORD dwPropertyID, DWORD dwFlags, CIMTYPE cimtype, DWORD dwStorageType, 
                LPWSTR lpDefault, BOOL &bChg, BOOL &bIfNoInstances);
    HRESULT FindProperty(SQL_ID dObjectId, LPWSTR lpPropName, DWORD dwFlags, CIMTYPE ct);
    HRESULT GetDerivedClassList(SQL_ID dObjectId, SQLIDs &ids, int &iNumChildren, BOOL bImmediate = FALSE);
    HRESULT GetDerivedClassList(SQL_ID dObjectId, SQL_ID **ppIDs, int &iNumChildren, BOOL bImmediate = FALSE);
    HRESULT GetHierarchy(SQL_ID dObjectId, SQL_ID **ppIDs, int &iNumIDs);
    HRESULT GetHierarchy(SQL_ID dObjectId, SQLIDs &ids, int &iNumIDs);

    void EmptyCache();

    DWORD GetTotalSize() {return m_dwTotalSize;};
    void SetMaxSize(DWORD dwMax) {m_dwMaxSize = dwMax;};
    DWORD GetMaxSize() {return m_dwMaxSize;};

    HRESULT ResizeCache();
    HRESULT LockDynasty(SQL_ID dDynastyId);
    HRESULT UnlockDynasty(SQL_ID dDynastyId);
    HRESULT DeleteDynasty(SQL_ID dDynastyId);

    BOOL IsSystemClass(SQL_ID dObjectId, SQL_ID dClassId);
    DWORD GetWriteToken(SQL_ID dObjectId, SQL_ID dClassId);
    
private:

    CHashCache<PropertyData *>    m_Cache;
    CHashCache<ClassData *>       m_CCache;
    ClassNames                    m_CIndex;
    CHashCache<NamespaceData *>   m_NamespaceIds;
    DWORD                         m_dwTotalSize;
    DWORD                         m_dwMaxSize;
    SQLRefCountMap                m_DynastiesInUse;
    CRITICAL_SECTION              m_cs;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\repdrvr.h ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   repdrvr.h
//
//   cvadai     19-Mar-99       Created as prototype for Quasar.
//
//***************************************************************************

#ifndef _REPDRVR_H_
#define _REPDRVR_H_

#pragma warning( disable : 4251 ) //  needs to have dll-interface to be used by clients of class

//#define InterlockedIncrement(l) (++(*(l)))
//#define InterlockedDecrement(l) (--(*(l)))

EXTERN_C const IID IID_IWbemQuery;
EXTERN_C const IID IID_IWmiDbHandle;
EXTERN_C const IID IID_IWmiDbController;
EXTERN_C const IID IID_IWmiDbSession;
EXTERN_C const IID IID_IWmiDbBatchSession;
EXTERN_C const IID IID_IWmiDbIterator;
EXTERN_C const IID IID_ISequentialStream2;

#define WMIDB_OBJECT_STATE_NORMAL      0
#define WMIDB_OBJECT_STATE_IN_USE      1
#define WMIDB_OBJECT_STATE_DELETED     2
#define WMIDB_OBJECT_STATE_PROTECTED   3
#define WMIDB_OBJECT_STATE_EXCLUSIVE   4
#define WMIDB_OBJECT_STATE_PERSISTENT  5
#define WMIDB_OBJECT_STATE_AUTODELETE  6

#define WMIDB_SECURITY_FLAG_CLASS      1
#define WMIDB_SECURITY_FLAG_INSTANCE   2

#include <wmiutils.h>
#include <winbase.h>
#include <sqlcache.h>
#include <repcache.h>
#include <wbemint.h>
#include <coresvc.h>

extern CRITICAL_SECTION g_csRepdrvr;

class _WMILockit
{
public:
	_WMILockit(CRITICAL_SECTION *pCS);
	~_WMILockit();
private:
    CRITICAL_SECTION *m_cs;
};

class CWmiDbIterator;

struct MappedProperties
{
    LPWSTR  wPropName;
    LPWSTR  wTableName;
    BOOL    bReadOnly;
    LPWSTR  wScopeClass;
    BOOL    bIsKey;
    BOOL    bStoreAsBlob;
    BOOL    bStoreAsNumber;
    BOOL    bStoreAsMOFText;

    LPWSTR  * arrColumnNames;
    LPWSTR  * arrForeignKeys;

    DWORD   dwNumColumns;
    DWORD   dwNumForeignKeys;

    // Special treatment for embedded objects
    BOOL    bDecompose;
    LPWSTR  wClassTable;
    LPWSTR  wClassNameCol;
    LPWSTR  wClassDataCol;
    LPWSTR  wClassForeignKey;

};

LPWSTR GetKeyString (LPWSTR lpString);
void ConvertDataToString(WCHAR * lpKey, BYTE* pData, DWORD dwType, BOOL bQuotes = FALSE);
LPWSTR StripUnresolvedName (LPWSTR lpPath);
BOOL IsDerivedFrom(IWbemClassObject *pObj, LPWSTR lpClassName, BOOL bDirectOnly=FALSE);
HRESULT ConvertBlobToObject (IWbemClassObject *pNewObj, BYTE *pBuffer, DWORD dwLen, _IWmiObject **ppNewObj);

//***************************************************************************
//  CWmiDbHandle
//***************************************************************************

class CWmiDbHandle : public IWmiDbHandle 
{
    
    friend class CWmiDbSession;
    friend class CWmiDbIterator;
    friend class CLockCache;
    friend class CObjectCache;
    friend class CWmiCustomDbIterator;
    friend class CWmiESEIterator;

public:
    HRESULT STDMETHODCALLTYPE QueryInterface( 
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
    
    ULONG STDMETHODCALLTYPE AddRef( );
    ULONG STDMETHODCALLTYPE Release( );

    HRESULT STDMETHODCALLTYPE GetHandleType( 
            /* [out] */ DWORD __RPC_FAR *pdwType) ;

    CWmiDbHandle();
    ~CWmiDbHandle();

    HRESULT QueryInterface_Internal(CSQLConnection *pConn, void __RPC_FAR *__RPC_FAR *ppvObject, LPWSTR lpKey = NULL); 

private:

    DWORD  m_dwHandleType;
    DWORD  m_dwVersion;
    SQL_ID m_dObjectId;
    SQL_ID m_dClassId;
    SQL_ID m_dScopeId;
    ULONG  m_uRefCount;
    BOOL   m_bSecDesc;
    BOOL   m_bDefault;
    IWmiDbSession *m_pSession;
    IWbemClassObject *m_pData;

};

class CESSHolder
{
public:
    CESSHolder(long lType, LPWSTR lpNs, LPWSTR lpClass, _IWmiObject *pOld, _IWmiObject *pNew);
    ~CESSHolder() {};

    HRESULT Deliver(_IWmiCoreServices *pCS, LPCWSTR lpRootNs);

private:
    _bstr_t m_sNamespace;
    _bstr_t m_sClass;
    _IWmiObject *pOldObject;
    _IWmiObject *pNewObject;
    long m_lType;
};


class CESSManager
{
    friend class CWmiDbController;
public:
    typedef std::map <DWORD, CESSHolder *> ESSObjs;

    CESSManager();
    ~CESSManager ();
    void SetConnCache (CSQLConnCache *pConn) {m_Conns = pConn;};
    void SetSchemaCache (CSchemaCache *pCache) {m_Schema = pCache;};
    void SetObjectCache (CObjectCache *pObjects) {m_Objects = pObjects;};
    void InitializeESS();

    HRESULT AddInsertRecord(CSQLConnection *pConn, LPWSTR lpGUID, LPWSTR lpNamespace, LPWSTR lpClass, DWORD dwGenus, 
            IWbemClassObject *pOldObj, IWbemClassObject *pNewObj);
    HRESULT AddDeleteRecord(CSQLConnection *pConn, LPWSTR lpGUID, LPWSTR lpNamespace, LPWSTR lpClass, DWORD dwGenus, 
            IWbemClassObject *pObj);
    HRESULT CommitAll (LPCWSTR lpGUID, LPCWSTR lpRootNs);
    HRESULT DeleteAll (LPCWSTR lpGUID);

private:

    _IWmiCoreServices *m_EventSubSys;
    CSQLConnCache *m_Conns;
    CObjectCache *m_Objects;
    CSchemaCache *m_Schema;
    ESSObjs m_ESSObjs;

};

//***************************************************************************
//  CWmiDbController
//***************************************************************************

class CWmiDbController : public IWmiDbController
{
    friend class CWmiDbSession;
    friend class CWmiDbIterator;
    friend class CWmiCustomDbIterator;
    friend class CWmiESEIterator;
    friend class CWmiDbHandle;

    typedef std::map<SQL_ID, bool> SQL_IDMap;

public:
    HRESULT STDMETHODCALLTYPE QueryInterface( 
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
    
    ULONG STDMETHODCALLTYPE AddRef( );
    ULONG STDMETHODCALLTYPE Release( );

    virtual HRESULT STDMETHODCALLTYPE Logon( 
        /* [in] */ WMIDB_LOGON_TEMPLATE __RPC_FAR *pLogonParms,
        /* [in] */ DWORD dwFlags,
        /* [in] */ DWORD dwRequestedHandleType,
        /* [out] */ IWmiDbSession __RPC_FAR *__RPC_FAR *ppSession,
        /* [out] */ IWmiDbHandle __RPC_FAR *__RPC_FAR *ppRootNamespace) ;
    
    virtual HRESULT STDMETHODCALLTYPE GetLogonTemplate( 
        /* [in] */ LCID lLocale,
        /* [in] */ DWORD dwFlags,
        /* [out] */ WMIDB_LOGON_TEMPLATE __RPC_FAR *__RPC_FAR *ppTemplate) ;
    
    virtual HRESULT STDMETHODCALLTYPE FreeLogonTemplate( 
        /* [out][in] */ WMIDB_LOGON_TEMPLATE __RPC_FAR *__RPC_FAR *pTemplate) ;
    
    virtual HRESULT STDMETHODCALLTYPE Shutdown( 
        /* [in] */ DWORD dwFlags);
    
    virtual HRESULT STDMETHODCALLTYPE SetCallTimeout( 
        /* [in] */ DWORD dwMaxTimeout);
    
    virtual HRESULT STDMETHODCALLTYPE SetCacheValue( 
        /* [in] */ DWORD dwMaxBytes);

    virtual HRESULT STDMETHODCALLTYPE FlushCache(
        /* [in] */ DWORD dwFlags);

    virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
        /* [in] */ DWORD dwParameter,
        /* [out] */ DWORD __RPC_FAR *pdwValue) ;


    CWmiDbController();
    ~CWmiDbController();

private:
    typedef std::vector<CWmiDbSession *>  Sessions;

    HRESULT GetUnusedSession(WMIDB_LOGON_TEMPLATE *pLogon,
        DWORD dwFlags,
        DWORD dwHandleType,
        IWmiDbSession **ppSession);

    HRESULT SetConnProps(WMIDB_LOGON_TEMPLATE *pLogon);

    HRESULT ReleaseSession(IWmiDbSession *pSession);
    void    IncrementHitCount(bool bCacheUsed=false);
    void    AddHandle();
    void    SubtractHandle();
    HINSTANCE GetResourceDll (LCID lLocale);

    BOOL HasSecurityDescriptor(SQL_ID ObjId);
    void AddSecurityDescriptor(SQL_ID ObjId);
    void RemoveSecurityDescriptor(SQL_ID ObjId);

    DWORD m_dwTimeOut;
    DWORD m_dwCurrentStatus;
    ULONG m_uRefCount;
    DWORD m_dwTotalHits;
    DWORD m_dwCacheHits;
    DWORD m_dwTotalHandles;
    CRITICAL_SECTION m_cs;

    DBPROP          *m_InitProperties;    
    DBPROPSET       *m_rgInitPropSet;
    IMalloc         *m_pIMalloc;

    CObjectCache    ObjectCache;
    CSchemaCache    SchemaCache; // separate so it doesn't get flushed.
    CLockCache      LockCache;   // separate so it doesn't get flushed.
    CSQLConnCache   ConnCache;   // Cache of SQL connections.
    CESSManager     ESSMgr;
    SQL_IDMap       SecuredIDs;  // List of objects with security descriptors.

    Sessions        m_Sessions;
    BOOL            m_bCacheInit;
    BOOL            m_bIsAdmin;
    BOOL            m_bESSEnabled;
};

class CWbemClassObjectProps
{
public:
    LPWSTR lpClassName;
    LPWSTR lpNamespace;
    LPWSTR lpRelPath;
    LPWSTR lpSuperClass;
    LPWSTR lpDynasty;
    LPWSTR lpKeyString;
    DWORD  dwGenus;

    CWbemClassObjectProps(CWmiDbSession *pSession, CSQLConnection *pConn,
        IWbemClassObject *pObj, CSchemaCache *pCache, SQL_ID dScopeID);
    ~CWbemClassObjectProps();
};

struct SessionLock
{
    SQL_ID dObjectId;
    DWORD dwHandleType;
};

//***************************************************************************
//  CWmiDbSession
//***************************************************************************

class CWmiDbSession : public IWmiDbSession, IWmiDbBatchSession, IWbemTransaction, IWmiDbBackupRestore
{
    friend class CWmiDbController;
    friend class CWmiDbIterator;
    friend class CWmiCustomDbIterator;
    friend class CWmiESEIterator;
    friend class CWmiDbHandle;
    typedef std::vector <SQL_ID> SQLIDs;
    typedef std::map <DWORD, DWORD> Properties;
    typedef std::vector <SessionLock *> SessionLocks;
    typedef std::map <DWORD, SQLIDs> SessionDynasties;
    typedef std::map <DWORD, DWORD> RefCount;
public:
    HRESULT STDMETHODCALLTYPE QueryInterface( 
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
    
    ULONG STDMETHODCALLTYPE AddRef( );
    ULONG STDMETHODCALLTYPE Release( );

    virtual HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
        /* [in] */ IWbemPath __RPC_FAR *pPath,
        /* [in] */ DWORD dwFlags,
        /* [in] */ DWORD dwRequestedHandleType,
        /* [out] */ IWmiDbHandle __RPC_FAR *__RPC_FAR *ppResult);   
        
    virtual HRESULT STDMETHODCALLTYPE GetObjectDirect( 
        /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
        /* [in] */ IWbemPath __RPC_FAR *pPath,
        /* [in] */ DWORD dwFlags,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ LPVOID __RPC_FAR *pObj);
    
    virtual HRESULT STDMETHODCALLTYPE PutObject( 
        /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
        /* [in] */ REFIID riid,
        /* [iid_is][in] */ LPVOID pObjToPut,
        /* [in] */ DWORD dwFlags,
        /* [in] */ DWORD dwRequestedHandleType,
        /* [out] */ IWmiDbHandle __RPC_FAR *__RPC_FAR *ppResult);

    virtual HRESULT STDMETHODCALLTYPE DeleteObject( 
        /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
        /* [in] */ DWORD dwFlags,
        /* [in] */ REFIID riid,
        /* [iid_is][in] */ LPVOID pObj);
        
    virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
        /* [in] */ IWbemQuery __RPC_FAR *pQuery,
        /* [in] */ DWORD dwFlags,
        /* [in] */ DWORD dwHandleType,
        /* [out] */ DWORD *dwMessageFlags,
        /* [out] */ IWmiDbIterator  __RPC_FAR *__RPC_FAR *pQueryResult) ;

    virtual HRESULT STDMETHODCALLTYPE RenameObject( 
        /* [in] */ IWbemPath __RPC_FAR *pOldPath,
        /* [in] */ IWbemPath __RPC_FAR *pNewPath,
        /* [in] */ DWORD dwFlags,
        /* [in] */ DWORD dwRequestedHandleType,
        /* [out] */ IWmiDbHandle __RPC_FAR *__RPC_FAR *ppResult);
    
    virtual HRESULT STDMETHODCALLTYPE Enumerate( 
        /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
        /* [in] */ DWORD dwFlags,
        /* [in] */ DWORD dwRequestedHandleType,
        /* [out] */ IWmiDbIterator __RPC_FAR *__RPC_FAR *ppQueryResult);
    
    virtual HRESULT STDMETHODCALLTYPE AddObject( 
        /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
        /* [in] */ IWbemPath __RPC_FAR *pPath,
        /* [in] */ DWORD dwFlags,
        /* [in] */ DWORD dwRequestedHandleType,
        /* [out] */ IWmiDbHandle __RPC_FAR *__RPC_FAR *ppResult);
    
    virtual HRESULT STDMETHODCALLTYPE RemoveObject( 
        /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
        /* [in] */ IWbemPath __RPC_FAR *pPath,
        /* [in] */ DWORD dwFlags);

    virtual HRESULT STDMETHODCALLTYPE SetDecoration( 
        /* [in] */ LPWSTR lpMachineName,
        /* [in] */ LPWSTR lpNamespacePath);
      
    virtual HRESULT STDMETHODCALLTYPE SupportsQueries( 
        /* [in] */ DWORD *dwQuerySupportLevel
         ) {return WBEM_S_NO_ERROR;};

        // batch session methods

    virtual HRESULT STDMETHODCALLTYPE PutObjects( 
        /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
        /* [in] */ DWORD dwFlags,
        /* [in] */ DWORD dwHandleType,
        /* [out][in] */ WMIOBJECT_BATCH __RPC_FAR *pBatch);

    virtual HRESULT STDMETHODCALLTYPE GetObjects( 
        /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
        /* [in] */ DWORD dwFlags,
        /* [in] */ DWORD dwHandleType,
        /* [in, out] */ WMIOBJECT_BATCH __RPC_FAR *pBatch);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteObjects( 
        /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
        /* [in] */ DWORD dwFlags,
        /* [out][in] */ WMIOBJECT_BATCH __RPC_FAR *pBatch);  

        // IWbemTransaction methods.

    virtual HRESULT STDMETHODCALLTYPE Begin( 
        /* [in] */ ULONG uTimeout,
        /* [in] */ ULONG uFlags,
        /* [in] */ GUID __RPC_FAR *pTransGUID);
    
    virtual HRESULT STDMETHODCALLTYPE Rollback( 
        /* [in] */ ULONG uFlags);
    
    virtual HRESULT STDMETHODCALLTYPE Commit( 
        /* [in] */ ULONG uFlags);
    
    virtual HRESULT STDMETHODCALLTYPE QueryState( 
        /* [in] */ ULONG uFlags,
        /* [out] */ ULONG __RPC_FAR *puState);
    
    virtual HRESULT STDMETHODCALLTYPE Backup( 
        /* [in] */ LPCWSTR lpBackupPath,
        /* [in] */ DWORD dwFlags);
    
    virtual HRESULT STDMETHODCALLTYPE Restore( 
        /* [in] */ LPCWSTR lpRestorePath,
        /* [in] */ LPCWSTR lpDestination,
        /* [in] */ DWORD dwFlags);


    HRESULT LoadSchemaCache ();
    HRESULT LoadClassInfo (CSQLConnection *pConn, LPCWSTR lpDynasty = NULL, SQL_ID dScopeId = 0, BOOL bDeep = TRUE);
    HRESULT LoadClassInfo (CSQLConnection *pConn, SQL_ID dClassId, BOOL bDeep = TRUE);

    HRESULT GetObjectData (CSQLConnection *pConn, SQL_ID dObjectId, SQL_ID dClassId, SQL_ID dScopeId, 
                DWORD dwHandleType, DWORD &dwVersion, IWbemClassObject **pObj, BOOL bNoDefaults = FALSE,
                LPWSTR lpKey = NULL, BOOL bGetSD = FALSE);

    HRESULT GetObjectData2 (CSQLConnection *pConn, SQL_ID dObjectId, SQL_ID dClassId, SQL_ID dScopeId, 
                IWbemClassObject *pObj, BOOL bNoDefaults = FALSE, LPWSTR *lpKey = NULL);

    HRESULT GetClassObject (CSQLConnection *pConn, SQL_ID dClassId, IWbemClassObject **ppObj);

    HRESULT STDMETHODCALLTYPE GetObject_Internal( 
        /* [in] */ LPWSTR lpPath,
        /* [in] */ DWORD dwFlags,
        /* [in] */ DWORD dwRequestedHandleType,
        /* [in] */ SQL_ID *dScopeId,
        /* [out] */ IWmiDbHandle __RPC_FAR *__RPC_FAR *ppResult,
                   CSQLConnection *pConn = NULL);

    HRESULT STDMETHODCALLTYPE PutObject( 
                   CSQLConnection *pConn,
        /* [in] */ IWmiDbHandle *pScope,
                   SQL_ID dScopeID,
                   LPWSTR lpScopePath,
        /* [in] */ IUnknown __RPC_FAR *pObjToPut,
        /* [in] */ DWORD dwFlags,
        /* [in] */ DWORD dwRequestedHandleType,
                   _bstr_t &sPath,
        /* [out] */ IWmiDbHandle __RPC_FAR *__RPC_FAR *ppResult,
                    BOOL bStoreAsClass = FALSE);

    HRESULT CleanCache(SQL_ID dObjId, DWORD dwLockType = 0, void *pObj = NULL);
    HRESULT ShutDown ();
    HRESULT Delete(IWmiDbHandle *pHandle, CSQLConnection *pConn= NULL);   
    HRESULT Delete(SQL_ID dID, CSQLConnection *pConn= NULL);
	HRESULT VerifyObjectSecurity (CSQLConnection *pConn, SQL_ID ObjectId, SQL_ID ClassId, SQL_ID ScopeId, SQL_ID ScopeClassId, DWORD AccessType);
	HRESULT AccessCheck( PNTSECURITY_DESCRIPTOR pSD, DWORD dwAccessType, BOOL &bHasDACL );
    CWmiDbController * GetController() { return (CWmiDbController *)m_pController;}
    CSchemaCache * GetSchemaCache() { return (m_pController ? &((CWmiDbController *)m_pController)->SchemaCache : NULL);}
    CObjectCache * GetObjectCache() { return (m_pController ? &((CWmiDbController *)m_pController)->ObjectCache : NULL);}
    CSQLConnCache * GetSQLCache() { return (m_pController ? &((CWmiDbController *)m_pController)->ConnCache : NULL);}
    CRITICAL_SECTION * GetCS() {return (m_pController ? &((CWmiDbController *)m_pController)->m_cs : NULL);}

    void FixMethodParamIds(IWbemClassObject *pTemp);

    CWmiDbSession(IWmiDbController *pController);
    ~CWmiDbSession();

private:
    
    HRESULT CustomGetObject(IWmiDbHandle *pScope, IWbemPath *pPath, LPWSTR lpObjectKey, 
            DWORD dwFlags, DWORD dwRequestedHandleType, IWmiDbHandle **ppResult);
    HRESULT CustomGetMapping(CSQLConnection *pConn, IWmiDbHandle *pScope, LPWSTR lpClassName, IWbemClassObject **ppMapping);
    HRESULT CustomCreateMapping(CSQLConnection *pConn, LPWSTR lpClassName, IWbemClassObject *pClassObj, IWmiDbHandle *pScope);
    HRESULT CustomPutInstance(CSQLConnection *pConn, IWmiDbHandle *pScope, SQL_ID dClassId, 
        DWORD dwFlags, IWbemClassObject **ppObjToPut, LPWSTR lpClassName = NULL);
    HRESULT CustomFormatSQL(IWmiDbHandle *pScope, IWbemQuery *pQuery, _bstr_t &sSQL, SQL_ID *dClassId, 
        MappedProperties **ppMapping, DWORD *dwNumProps, BOOL *bCount=FALSE);
    HRESULT CustomDelete(CSQLConnection *pConn, IWmiDbHandle *pScope, IWmiDbHandle *pHandle, LPWSTR lpClassName = NULL);
    HRESULT SetEmbeddedProp (IWmiDbHandle *pScope, LPWSTR lpPropName, IWbemClassObject *pObj, VARIANT &vValue, CIMTYPE ct);
    HRESULT GetEmbeddedClass (IWmiDbHandle *pScope, IWbemClassObject *pObj, LPWSTR lpEmbedProp, IWbemClassObject **ppClass);
    HRESULT CustomSetProperties (IWmiDbHandle *pScope, IRowset *pRowset, IMalloc *pMalloc, 
                                    IWbemClassObject *pClassObj, MappedProperties *pProps,
                                    DWORD dwNumProps, IWbemClassObject *pObj);
 
	// Security helper functions.
    HRESULT VerifyObjectSecurity (CSQLConnection *pConn, IWmiDbHandle *pHandle, DWORD AccessType);
    HRESULT VerifyObjectSecurity(CSQLConnection *pConn, SQL_ID dScopeID, SQL_ID dScopeClassId,	LPWSTR lpObjectPath,CWbemClassObjectProps *pProps,DWORD dwHandleType, 
	  DWORD dwReqAccess, SQL_ID &dObjectId, SQL_ID &dClassId);
	HRESULT VerifyClassSecurity (CSQLConnection *pConn, SQL_ID ClassId, DWORD AccessType);
	HRESULT GetEffectiveObjectSecurity(CSQLConnection *pConn,  SQL_ID ObjectId, SQL_ID ClassId, SQL_ID ScopeId, SQL_ID ScopeClassId, PNTSECURITY_DESCRIPTOR *ppSD, DWORD &dwSDLength);
	HRESULT GetInheritedObjectSecurity(CSQLConnection *pConn, 	SQL_ID ObjectId, SQL_ID ClassId, SQL_ID ScopeId, SQL_ID ScopeClassId, PNTSECURITY_DESCRIPTOR *ppSD, DWORD &dwSDLength);
	HRESULT GetInheritedClassSecurity(CSQLConnection *pConn,  SQL_ID ClassId, SQL_ID ScopeId, SQL_ID ScopeClassId, PNTSECURITY_DESCRIPTOR *ppSD, DWORD &dwSDLength);
	HRESULT GetInheritedInstanceSecurity(CSQLConnection *pConn,  SQL_ID ObjectId, SQL_ID ClassId, SQL_ID ScopeId, SQL_ID ScopeClassId, PNTSECURITY_DESCRIPTOR *ppSD, DWORD &dwSDLength);
	HRESULT GetInheritedContainerSecurity(CSQLConnection *pConn,  SQL_ID ClassId, SQL_ID ScopeId, SQL_ID ScopeClassId, PNTSECURITY_DESCRIPTOR *ppSD, DWORD &dwSDLength);
    HRESULT GetObjectSecurity (CSQLConnection *pConn, SQL_ID dObjectId, PNTSECURITY_DESCRIPTOR *pSD, DWORD dwSDLength, DWORD dwFlags, BOOL &bHasDacl);

    HRESULT PutClass( CSQLConnection *pConn,SQL_ID dScopeID,LPCWSTR lpScopePath,CWbemClassObjectProps *pProps, IWbemClassObject *pObj,DWORD dwFlags, 
        SQL_ID &dObjectId,_bstr_t &sObjectPath, bool &bChg, BOOL bIgnoreDefaults = FALSE);
    HRESULT PutInstance( CSQLConnection *pConn,IWmiDbHandle *pScope, SQL_ID dScopeID,LPCWSTR lpScopePath,CWbemClassObjectProps *pProps, 
        IWbemClassObject *pObj,DWORD dwFlags,SQL_ID &dObjectId,SQL_ID &dClassId, _bstr_t &sObjectPath, bool &bChg);
    
    // These three functions will only generate sp_InsertClassData procs 
    HRESULT InsertPropertyDef(CSQLConnection *pConn,
                                          IWbemClassObject *pObj, SQL_ID dScopeId, SQL_ID dObjectId,
                                          LPWSTR lpPropName, VARIANT vDefault,
                                          CIMTYPE cimtype, long lPropFlags,DWORD dRefId,
                                          Properties &props);
    HRESULT InsertQualifier(CSQLConnection *pConn,IWmiDbHandle *pScope, SQL_ID dObjectId,
                                          LPWSTR lpQualifierName, VARIANT vValue,
                                          long lQfrFlags,DWORD dwFlags, DWORD PropID,
                                          Properties &props);
    HRESULT InsertQualifiers (CSQLConnection *pConn,IWmiDbHandle *pScope, SQL_ID dObjectId, DWORD PropID, DWORD Flags, IWbemQualifierSet *pQS,
                                          Properties &props);
    HRESULT InsertArray(CSQLConnection *pConn,IWmiDbHandle *pScope, SQL_ID dObjectId, SQL_ID dClassId, 
                                           DWORD dwPropertyID, VARIANT &vDefault, long lFlavor=0, DWORD dwRefID = 0,
                                           LPCWSTR lpObjectKey = NULL, LPCWSTR lpObjectPath = NULL, SQL_ID dScope = 0,
                                           CIMTYPE ct = 0);
    HRESULT InsertPropertyValues (CSQLConnection *pConn, IWmiDbHandle *pScope, 
                                             LPWSTR lpPath,SQL_ID &dObjectId,SQL_ID dClassId,SQL_ID dScopeId,
                                             DWORD dwFlags,CWbemClassObjectProps *pProps, IWbemClassObject *pObj);
    HRESULT FormatBatchInsQfrs (CSQLConnection *pConn,IWmiDbHandle *pScope, 
                                        SQL_ID dObjectId, SQL_ID dClassId,
                                           DWORD dPropID, IWbemQualifierSet *pQS, 
                                           int &iPos, InsertQualifierValues **ppVals, 
                                           Properties &props, int &iNumProps);
    HRESULT FormatBatchInsQfrValues(CSQLConnection *pConn,IWmiDbHandle *pScope, 
                                               SQL_ID dObjectId, DWORD dwQfrID,
                                               VARIANT &vTemp, long lFlavor, InsertQualifierValues *pVals, Properties &props,
                                               int &iPos, DWORD PropID);

    HRESULT SetKeyhole (CSQLConnection *pConn, IWbemClassObject *pObj, DWORD dwKeyholePropID, 
                                   LPWSTR sKeyholeProp, LPCWSTR lpScopePath, _bstr_t &sPath);
    HRESULT SetUnkeyedPath(CSQLConnection *pConn, IWbemClassObject *pObj, SQL_ID dClassId, _bstr_t &sObjPath);
    HRESULT InsertQualifierValues (CSQLConnection *pConn, SQL_ID dObjectId,IWbemClassObject *pObj,Properties &props);

    HRESULT NormalizeObjectPathGet (IWmiDbHandle __RPC_FAR *pScope, IWbemPath __RPC_FAR *pPath,
                LPWSTR * lpNewPath, BOOL *bDefault = NULL, SQL_ID *dClassId = NULL, SQL_ID *dScopeId = NULL
                , CSQLConnection *pConn = NULL);
    HRESULT NormalizeObjectPath(IWmiDbHandle __RPC_FAR *pScope, LPCWSTR lpPath, LPWSTR * lpNewPath, BOOL bNamespace=FALSE, 
        CWbemClassObjectProps **ppProps=NULL, BOOL *bDefault = NULL, CSQLConnection *pConn = NULL, BOOL bNoTrunc = FALSE);
    HRESULT NormalizeObjectPath(IWbemClassObject __RPC_FAR *pScope, IWmiDbHandle *pScope2, LPCWSTR lpPath, LPWSTR * lpNewPath, BOOL bNamespace=FALSE, 
        CWbemClassObjectProps **ppProps=NULL, BOOL *bDefault = NULL, BOOL bNoTrunc = FALSE);

    HRESULT VerifyObjectLock (SQL_ID ObjectId, DWORD dwLockType, DWORD dwVersion);
    BOOL IsDistributed() { return m_bIsDistributed;};
    HRESULT IssueDeletionEvents (CSQLConnection *pConn, SQL_ID dObjectId, 
        SQL_ID dClassId, SQL_ID dScopeId, IWbemClassObject *pObj);
    HRESULT AddTransLock(SQL_ID dObjectId, DWORD dwHandleType);
    HRESULT CleanTransLocks();
    BOOL LockExists (SQL_ID dObjId);
    HRESULT UpdateHierarchy(CSQLConnection *pConn, SQL_ID dClassId, DWORD dwFlags, LPCWSTR lpScopePath,
                CWbemClassObjectProps *pProps, _IWmiObject *pObj);

    HRESULT UnlockDynasties(BOOL bDelete = FALSE);
    HRESULT DeleteRows(IWmiDbHandle *pScope, IWmiDbIterator *pIterator, REFIID iid);

    DWORD AddRef_Lock();
    DWORD Release_Lock();

    ULONG m_uRefCount;
    IWmiDbController *m_pController;
    IMalloc *m_pIMalloc;
    _bstr_t m_sNamespacePath;
    _bstr_t m_sMachineName;
    BOOL m_bInUse;
    DWORD m_dwLocale;
    BOOL m_bIsDistributed;
    _bstr_t m_sGUID; // GUID of the transaction.
    SessionLocks m_TransLocks;
    SessionDynasties m_Dynasties;
    RefCount m_ThreadRefCount;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\repdrvr.cpp ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   repdrvr.cpp
//
//   cvadai     19-Mar-99       Created as prototype for Quasar.
//
//***************************************************************************

#define _REPDRVR_CPP_
#pragma warning( disable : 4786 ) // identifier was truncated to 'number' characters in the 
#pragma warning( disable : 4251 ) //  needs to have dll-interface to be used by clients of class

#define DBINITCONSTANTS // Initialize OLE constants...
#define INITGUID        // ...once in each app.
#define _WIN32_DCOM
#include "precomp.h"

#include <std.h>
#include <sqlexec.h>
#include <sqlcache.h>
#include <repdrvr.h>
#include <wbemint.h>
#include <math.h>
#include <resource.h>
#include <reputils.h>
#include <crc64.h>
#include <smrtptr.h>
#include <wmiutils.h>
#include <wbemtime.h>
#include <reg.h>

//#include <icecap.h>

// Statics

_WMILockit::_WMILockit(CRITICAL_SECTION *pCS)
{
    EnterCriticalSection(pCS);
    m_cs = pCS;
}

_WMILockit::~_WMILockit()
{
    LeaveCriticalSection(m_cs);
}

#define REPDRVR_FLAG_FLUSH_ALL  0x1

extern long g_cObj;

typedef std::map<SQL_ID, CacheInfo *> SchemaCache;
typedef std::map<_bstr_t, SQL_ID, C_wchar_LessCase> PathIndex;
typedef std::map <SQL_ID, LockData *> LockCache;
typedef std::vector<LockItem *> LockList;
typedef std::map <DWORD, DWORD> Properties;
typedef std::vector <SessionLock *> SessionLocks;
typedef std::map <DWORD, CESSHolder *> ESSObjs;
typedef std::map<SQL_ID, bool> SQL_IDMap;
typedef std::vector <SQL_ID> SQLIDs;
typedef std::map <DWORD, SQLIDs> SessionDynasties;

// Contrived method of generating proc names,
// since we are limited to 30 characters.

#define PROCTYPE_GET 1
#define PROCTYPE_PUT 2
#define PROCTYPE_DEL 3


LPWSTR StripSlashes(LPWSTR lpText)
{
    wchar_t *pszTemp = NULL;
    if (lpText)
    {
        pszTemp = new wchar_t [wcslen(lpText)+1];
        if (pszTemp)
        {
            int iPos = 0;
            int iLen = wcslen(lpText);
            if (iLen)
            {
                BOOL bOnSlash = FALSE;
                for (int i = 0; i < iLen; i++)
                {
                    WCHAR t = lpText[i];
                    if (t == '\\')
                    {
                        if (lpText[i+1] == '\\' && !bOnSlash)
                        {
                            bOnSlash = TRUE;
                            continue;
                        }
                    }
                    pszTemp[iPos] = t;
                    bOnSlash = FALSE;
                    iPos++;
                }
            }
            pszTemp[iPos] = '\0';
        }
    }
    return pszTemp;
}

int GetDiff(SYSTEMTIME tEnd, SYSTEMTIME tStart)
{
    int iRet = 0;

    __int64 iTemp = (tEnd.wDay * 1000000000) +
                    (tEnd.wHour * 10000000) +
                    (tEnd.wMinute * 100000) +
                    (tEnd.wSecond * 1000) +
                    tEnd.wMilliseconds;
    iTemp -= ((tStart.wDay * 1000000000) +
                    (tStart.wHour * 10000000) +
                    (tStart.wMinute * 100000) +
                    (tStart.wSecond * 1000) +
                    tStart.wMilliseconds);

    iRet = (int) iTemp;

    return iRet;
}


CWbemClassObjectProps::CWbemClassObjectProps
    (CWmiDbSession *pSession, CSQLConnection *pConn, IWbemClassObject *pObj, CSchemaCache *pCache, SQL_ID dScopeID)
{
    lpClassName = GetPropertyVal(L"__Class", pObj);
    lpNamespace = GetPropertyVal(L"__Namespace", pObj);
    lpSuperClass = GetPropertyVal(L"__SuperClass", pObj);
    lpDynasty = GetPropertyVal(L"__Dynasty", pObj);
    LPWSTR lpTemp = GetPropertyVal(L"__Genus", pObj);
    CDeleteMe <wchar_t> r(lpTemp);
    if (lpTemp)
        dwGenus = _wtoi(lpTemp);

    // If pConn is blank, this should already be loaded.
    if (pConn)
    {
        if (FAILED(pSession->LoadClassInfo(pConn, lpClassName, dScopeID, FALSE)))
        {
            if (lpSuperClass)
                pSession->LoadClassInfo(pConn, lpSuperClass, dScopeID, FALSE);
        }
    }

    if (dwGenus == 1)
        lpRelPath = GetPropertyVal(L"__Class", pObj);
    else
    {
        LPWSTR lpTemp = GetPropertyVal(L"__RelPath", pObj);
        CDeleteMe <wchar_t> d (lpTemp);

        lpRelPath = StripSlashes(lpTemp);
        if (lpRelPath)
        {
            LPWSTR lpNewClass = pCache->GetKeyRoot(lpClassName, dScopeID);
            if (lpNewClass)
            {
                LPWSTR lpPtr = lpRelPath + wcslen(lpClassName);
                LPWSTR lpTemp2 = new wchar_t [wcslen(lpNewClass) + wcslen(lpPtr) + 1];
                if (lpTemp2)
                {
                    wcscpy(lpTemp2, lpNewClass);
                    wcscat(lpTemp2, lpPtr);
                    delete lpRelPath;
                    lpRelPath = lpTemp2;
                }
                delete lpNewClass;
            }        
        }
    }
    lpKeyString = NULL;

}

CWbemClassObjectProps::~CWbemClassObjectProps()
{
    delete lpClassName;
    delete lpNamespace;
    delete lpRelPath;
    delete lpSuperClass;  
    delete lpKeyString;
    delete lpDynasty;
}

//***************************************************************************
//
//  ConvertBlobToObject
//
//***************************************************************************

HRESULT ConvertBlobToObject (IWbemClassObject *pNewObj, BYTE *pBuffer, DWORD dwLen, _IWmiObject **ppNewObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IWbemClassObject *pEmbed = NULL;
    _IWmiObject *pInt = NULL;
    if (pNewObj)
        hr = pNewObj->Clone(&pEmbed);
    else
    {
        _IWmiObject *pClass = NULL;
        // Handle blank Instance prototypes
        hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
                IID__IWmiObject, (void **)&pClass);
        CReleaseMe r (pClass);
        if (pClass)
        {
            hr = pClass->WriteProp(L"__Class", 0,
                4, 4, CIM_STRING, L"X");
            if (SUCCEEDED(hr))
            {
                hr = pClass->SpawnInstance(0, &pEmbed);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = pEmbed->QueryInterface(IID__IWmiObject, (void **)&pInt);
        CReleaseMe r (pInt);
        if (SUCCEEDED(hr))
        {
            LPVOID  pTaskMem = NULL;

            if (SUCCEEDED(hr))
            {
                pTaskMem = CoTaskMemAlloc( dwLen );

                if ( NULL != pTaskMem )
                {
                    // Copy the memory
                    CopyMemory( pTaskMem, pBuffer, dwLen );
                    hr = pInt->SetObjectMemory(pTaskMem, dwLen);
                    if (SUCCEEDED(hr))
                    {
                        *ppNewObj = pInt;
                    }
                    else
                    {
                        _IWmiObject *pClass = NULL;
                        hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
                                IID__IWmiObject, (void **)&pClass);
                        if (SUCCEEDED(hr))
                        {
                            hr = pClass->SetObjectMemory(pTaskMem, dwLen);
                            if (SUCCEEDED(hr))
                            {                                                   
                                *ppNewObj = pClass;
                            }
                        }
                    }
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
            }
        }
    }
    return hr;
}


void ConvertDataToString(WCHAR * lpKey, BYTE* pData, DWORD dwType, BOOL bQuotes)
{
    WCHAR *pFr;
    WCHAR *pTo, *pOrig;
    pFr = (LPWSTR)pData;
    switch(dwType)
    {
      case CIM_STRING:
      case CIM_REFERENCE:
          if (bQuotes)
          {
              pTo = lpKey;
              *pTo = L'\"';
              *pTo++;
              while (*pFr)
              {
                  if (*pFr == L'\"')
                  {
                      *pTo = L'\\';
                      *pTo++;
                      *pTo = L'\"';
                  }
                  else
                      *pTo = *pFr;
                  pFr++;
                  pTo++;
              }
              *pTo = L'\"';
              *pTo++;
              *pTo = L'\0';
          }
          else
              wcscpy(lpKey, (LPWSTR)pData);
        break;
      case CIM_SINT32:
        swprintf(lpKey, L"%d", *(int *)pData);
        break;
      case CIM_UINT32:
        swprintf(lpKey, L"%u", *(unsigned *)pData);
        break;
      case CIM_SINT16:
        swprintf(lpKey, L"%hd", *(signed short *)pData);
        break;
      case CIM_UINT16:
        swprintf(lpKey, L"%hu", *(unsigned short *)pData);
        break;
      case CIM_SINT8:
        swprintf(lpKey, L"%d", *(signed char *)pData);
        break;
      case CIM_UINT8:
        swprintf(lpKey, L"%u", *(unsigned char *)pData);
        break;
      case CIM_UINT64:
        swprintf(lpKey, L"%I64u", *(unsigned __int64 *)pData);
        break;
      case CIM_SINT64:
        swprintf(lpKey, L"%I64d", *(__int64 *)pData);
        break;
      case CIM_BOOLEAN:
        // String, either TRUE or FALSE
        if (*pFr)
            wcscpy(lpKey, L"TRUE");
        else
            wcscpy(lpKey, L"FALSE");
        break;
      default:
        break;            
    }
}

HRESULT MakeKeyListString(SQL_ID dScopeId, CSchemaCache *pCache, 
                          LPWSTR lpClass, IWbemPathKeyList *pKeyList, LPWSTR lpKeyString)
{
    HRESULT hr = 0;

    if (!pKeyList)
        return 0;

    if (!lpKeyString)
        return WBEM_E_INVALID_PARAMETER;

    ULONG uNumKeys = 0;
    hr = pKeyList->GetCount(&uNumKeys);
    if (SUCCEEDED(hr))
    {
        if (!uNumKeys)
        {
            ULONGLONG uIsSingleton = 0;
            hr = pKeyList->GetInfo(0, &uIsSingleton);
            if (SUCCEEDED(hr))
            {
                if (uIsSingleton)
                    wcscat(lpKeyString, L"=@");
                else
                    hr = WBEM_E_INVALID_PARAMETER;
            }
        }
        else
        {
            // Get the key list from the schema cache

            CWStringArray arrKeys;
            hr = pCache->GetKeys(dScopeId, lpClass, arrKeys);
            if (SUCCEEDED(hr))
            {
                if (arrKeys.Size() != uNumKeys)
                {
                    hr = WBEM_E_INVALID_QUERY;
                }
                else
                {
                    BOOL bFound = FALSE;

                    for (int i = 0; i < arrKeys.Size(); i++)
                    {
                        bFound = FALSE;
                        DWORD dwLen2 = 1024;
                        BYTE    bBuff[1024];
                        wchar_t wName [1024];
                        ULONG ct;

                        for (ULONG j = 0; j < arrKeys.Size(); j++)
                        {
                            ULONG dwLen1 = 1024, dwLen2 = 1024;
                            hr = pKeyList->GetKey(j, 0, &dwLen1, wName, &dwLen2, bBuff, &ct);
                            if (SUCCEEDED(hr) && (!wcslen(wName) || !_wcsnicmp(wName, arrKeys.GetAt(i), 127)))
                            {
                                if (i > 0)
                                    wcscat(lpKeyString, L",");
                                else 
                                    wcscat(lpKeyString, L".");
                                wcscat(lpKeyString, arrKeys.GetAt(i));
                                wcscat(lpKeyString, L"=");
                            
                                wchar_t wValue[1024];
                                ConvertDataToString(wValue, bBuff, ct, TRUE);

                                if (FAILED(hr))
                                    break;
                            
                                wcscat(lpKeyString, wValue);
                                bFound = TRUE;
                                break;
                            }                            
                        }
                        
                        if (!bFound)
                            hr = WBEM_E_INVALID_PARAMETER;

                        if (FAILED(hr))
                            break;
                    }
                }
            }
        }
    }
    
    return hr;
}


BOOL IsDerivedFrom(IWbemClassObject *pObj, LPWSTR lpClassName, BOOL bDirectOnly)
{
    BOOL bRet = FALSE;
    VARIANT vTemp;
    CClearMe c (&vTemp);
    LPWSTR lpClass = GetPropertyVal(L"__Class", pObj);
    CDeleteMe <wchar_t>  d (lpClass);
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!bDirectOnly)
    {
        if (!_wcsicmp(lpClassName, lpClass))
            bRet = TRUE;
    }

    if (!bRet)
    {
        hr = pObj->Get(L"__Derivation", 0, &vTemp, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            SAFEARRAY *psaArray = V_ARRAY(&vTemp);
            if (psaArray)
            {
                long lLBound, lUBound;
                SafeArrayGetLBound(psaArray, 1, &lLBound);
                SafeArrayGetUBound(psaArray, 1, &lUBound);

                lUBound -= lLBound;
                lUBound += 1;

                for (int i = 0; i < lUBound; i++)
                {
                    VARIANT vT2;
                    VariantInit(&vT2);
                    LPWSTR lpValue = NULL;
                    hr = GetVariantFromArray(psaArray, i, VT_BSTR, vT2);
                    lpValue = GetStr(vT2);
                    CDeleteMe <wchar_t>  r (lpValue);
                    VariantClear(&vT2);

                    if (lpValue && !_wcsicmp(lpValue, lpClassName))
                    {
                        bRet = TRUE;
                        break;
                    }
                }                        
            }
        }
    }

    return bRet;
}


POLARITY BOOL SetObjectAccess(
                        IN HANDLE hObj)
{
    PSECURITY_DESCRIPTOR pSD;
    DWORD dwLastErr = 0;
    BOOL bRet = FALSE;

    // no point if we arnt on nt

    pSD = (PSECURITY_DESCRIPTOR)CWin32DefaultArena::WbemMemAlloc(SECURITY_DESCRIPTOR_MIN_LENGTH);
    if(pSD == NULL)
        return FALSE;

    ZeroMemory(pSD, SECURITY_DESCRIPTOR_MIN_LENGTH);
    if(!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
        goto Cleanup;
   
    if(!SetSecurityDescriptorDacl(pSD, TRUE, NULL, FALSE))
        goto Cleanup;

    bRet = SetKernelObjectSecurity(hObj, DACL_SECURITY_INFORMATION, pSD);

Cleanup:
    if(bRet == FALSE)
        dwLastErr = GetLastError();
    CWin32DefaultArena::WbemMemFree(pSD);
    return bRet;
}

HINSTANCE CWmiDbController::GetResourceDll (LCID lLocale)
{
    HINSTANCE hRCDll = NULL;
    wchar_t wLibName[501];

    GetModuleFileName(NULL, wLibName, 500);
    wchar_t *pLibName = wcsrchr(wLibName, L'\\');
    wchar_t *pTop = (wchar_t *)wLibName;
    if (pLibName)
    {
        int iPos = pLibName - pTop + 1;
        wLibName[iPos] = '\0';
    }

    swprintf(wLibName, L"%s%08X\\reprc.dll", wLibName, lLocale);
    hRCDll = LoadLibrary(wLibName);

    return hRCDll;
}

LPWSTR GetKeyString (LPWSTR lpString)
{
    if (!lpString)
        return NULL;
    else
        return StripQuotes(lpString);
}


//***************************************************************************
//
//  CWmiDbHandle::CWmiDbHandle
//
//***************************************************************************

CWmiDbHandle::CWmiDbHandle()
{
    m_dwHandleType = WMIDB_HANDLE_TYPE_NO_CACHE | WMIDB_HANDLE_TYPE_COOKIE;
    m_uRefCount = 0;
    m_bDefault = TRUE;
    m_bSecDesc = FALSE;
    m_dObjectId = 0;
    m_dClassId = 0;
    m_dwVersion = 1;
    m_pSession = NULL;
    m_pData = NULL;
}

//***************************************************************************
//
//  CWmiDbHandle::CWmiDbHandle
//
//***************************************************************************

CWmiDbHandle::~CWmiDbHandle()
{

}

//***************************************************************************
//
//  CWmiDbHandle::QueryInterface
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbHandle::QueryInterface( 
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    *ppvObject = 0;

    if (IID_IUnknown==riid || IID_IWmiDbHandle==riid )
    {
        *ppvObject = (IWmiDbHandle*)this;
        AddRef();
        return S_OK;
    }
    else if (IID_IWbemClassObject == riid ||
             IID__IWmiObject == riid)
    {
        if (!m_pData && m_pSession && m_dwHandleType != WMIDB_HANDLE_TYPE_INVALID)
        {
            if (m_dObjectId)
            {
                HRESULT hr = QueryInterface_Internal(NULL, ppvObject);
                return hr;
            }
        }
        else if (m_pData)
        {
            *ppvObject = m_pData;
            m_pData->AddRef();
            return S_OK;
        }
        else 
            return E_HANDLE;
    }

    return E_NOINTERFACE;
}

//***************************************************************************
//
//  CWmiDbHandle::QueryInterface_Internal
//
//***************************************************************************

HRESULT CWmiDbHandle::QueryInterface_Internal(CSQLConnection *pConn, void __RPC_FAR *__RPC_FAR *ppvObject,
                                              LPWSTR lpKey)
{
    IWbemClassObject *pNew = NULL;
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        if (m_pData)
        {
            *ppvObject = m_pData;
            m_pData->AddRef();
            return S_OK;
        }
        else
        {
            hr = ((CWmiDbSession *)m_pSession)->GetObjectData(pConn, m_dObjectId, m_dClassId, m_dScopeId, 
                        m_dwHandleType, m_dwVersion, &pNew, FALSE, lpKey, m_bSecDesc);
            if (SUCCEEDED(hr) && pNew)
            {
                *ppvObject = (IWbemClassObject *)pNew;                    
            
                // Cookie handles must be reread each time.
                if ((m_dwHandleType & 0xF) != WMIDB_HANDLE_TYPE_COOKIE)
                {
                    _WMILockit lkt(((CWmiDbSession *)m_pSession)->GetCS());
                    m_pData = pNew;
                    pNew->AddRef(); // For ourselves.
                }                    
                return S_OK;
            }  
            else if (SUCCEEDED(hr))
                hr = WBEM_E_FAILED;
            else if (hr == WBEM_E_CRITICAL_ERROR &&
                        (!m_pSession || !((CWmiDbSession *)m_pSession)->m_pController))
                hr = WBEM_E_SHUTTING_DOWN;
        }
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbHandle::QueryInterface_Internal (%I64d)\n", m_dObjectId));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbHandle::AddRef
//
//***************************************************************************

ULONG STDMETHODCALLTYPE CWmiDbHandle::AddRef( )
{
    if (m_pSession)
        m_pSession->AddRef();
    
    // We can't safely keep track of this
    // so we will only addref it once.
    // ==================================

    //if (m_pData)
    //    m_pData->AddRef();

    InterlockedIncrement((LONG *) &m_uRefCount);
    return m_uRefCount;

}

//***************************************************************************
//
//  CWmiDbHandle::Release
//
//***************************************************************************

ULONG STDMETHODCALLTYPE CWmiDbHandle::Release( )
{

    ULONG uNewCount = m_uRefCount;
    uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    HRESULT hr = 0;

    try
    {
        // Only if we haven't shut down.
        if (m_pSession && (((CWmiDbSession *)m_pSession)->m_pController))
        {       
            if (!uNewCount)
            {                
                if ((m_dwHandleType & 0xF000) == WMIDB_HANDLE_TYPE_AUTODELETE)
                {
                    hr = ((CWmiDbSession *)m_pSession)->Delete((IWmiDbHandle *)this);
                    if (FAILED(hr))
                        return uNewCount;
                }
                else if (m_dwHandleType != WMIDB_HANDLE_TYPE_INVALID)
                {
                    ((CWmiDbSession *)m_pSession)->CleanCache(m_dObjectId, m_dwHandleType, this);                     
                }
                if (((CWmiDbSession *)m_pSession)->m_pController)
                    ((CWmiDbController *)((CWmiDbSession *)m_pSession)->m_pController)->SubtractHandle();        
                ((CWmiDbSession *)m_pSession)->UnlockDynasties();
            }
            m_pSession->Release();
        }
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbHandle::Release (%I64d)\n", m_dObjectId));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    if (0 != uNewCount)
        return uNewCount;

    // To be safe, we will only add ref 
    // this once, and release it once.
    // ================================    
    if (m_pData)
        m_pData->Release();
    delete this;  

    return uNewCount;

}
//***************************************************************************
//
//  CWmiDbHandle::GetHandleType
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbHandle::GetHandleType( 
        /* [out] */ DWORD __RPC_FAR *pdwType)

{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (pdwType)
        *pdwType = m_dwHandleType;
    else
        hr = WBEM_E_INVALID_PARAMETER;

    return hr;
}

//***************************************************************************
//
//  CESSManager::CESSManager
//
//***************************************************************************

CESSManager::CESSManager()
{
    m_EventSubSys = NULL;
}

//***************************************************************************
//
//  CESSManager::~CESSManager
//
//***************************************************************************
CESSManager::~CESSManager()
{
    // Release our ESS pointer.

    if (m_EventSubSys)
        m_EventSubSys->Release();
}

//***************************************************************************
//
//  CESSManager::InitializeESS
//
//***************************************************************************

void CESSManager::InitializeESS()
{
    HRESULT hres = CoCreateInstance(CLSID_IWmiCoreServices, NULL,
                    CLSCTX_INPROC_SERVER, IID__IWmiCoreServices,
                    (void**)&m_EventSubSys);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_WBEMCORE,"CRITICAL: Event system not available!!!!\n"));
    }
    
}

//***************************************************************************
//
//  CESSManager::AddInsertRecord
//
//***************************************************************************
HRESULT CESSManager::AddInsertRecord(CSQLConnection *pConn, LPWSTR lpGUID, LPWSTR lpNamespace, LPWSTR lpClass, DWORD dwGenus, 
            IWbemClassObject *pOldObj, IWbemClassObject *pNewObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (m_EventSubSys)
    {
        if (lpGUID && wcslen(lpGUID))
        {
            // Write record to the database.
            hr = CSQLExecProcedure::InsertUncommittedEvent(pConn, lpGUID, lpNamespace, lpClass, 
                pOldObj, pNewObj, m_Schema);
        }
        else
        {
            long lType = 0;

            if (!pOldObj && pNewObj)
            {
                if (dwGenus == 1)
                    lType = WBEM_EVENTTYPE_ClassCreation;
                else
                {
                    if (IsDerivedFrom(pNewObj, L"__Namespace"))
                        lType = WBEM_EVENTTYPE_NamespaceCreation;
                    else
                        lType = WBEM_EVENTTYPE_InstanceCreation;
                }
            }
            else
            {
                if (dwGenus == 1)
                    lType = WBEM_EVENTTYPE_ClassModification;
                else
                {
                    if (IsDerivedFrom(pOldObj, L"__Namespace"))
                        lType = WBEM_EVENTTYPE_NamespaceModification;
                    else
                        lType = WBEM_EVENTTYPE_InstanceModification;
                }
            }          

            CESSHolder *pHolder = new CESSHolder (lType, lpNamespace, lpClass, 
                (_IWmiObject *)pOldObj, (_IWmiObject *)pNewObj);
            if (!pHolder)
                hr = WBEM_E_OUT_OF_MEMORY;

            m_ESSObjs[GetCurrentThreadId()] = pHolder;
        }
    }

    return hr;
}

//***************************************************************************
//
//  CESSManager::AddDeleteRecord
//
//***************************************************************************
HRESULT CESSManager::AddDeleteRecord(CSQLConnection *pConn, LPWSTR lpGUID, LPWSTR lpNamespace, LPWSTR lpClass, DWORD dwGenus, 
                    IWbemClassObject *pObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (m_EventSubSys)
    {
        // Write record to the database

        if (lpGUID && wcslen(lpGUID))
        {
            // Write record to the database.
            hr = CSQLExecProcedure::InsertUncommittedEvent(pConn, lpGUID, lpNamespace, lpClass, NULL, 
                pObj, m_Schema);
        }
        else
        {
            long lType = 0;

            if (dwGenus == 1)
                lType = WBEM_EVENTTYPE_ClassDeletion;
            else
            {
                if (IsDerivedFrom(pObj, L"__Namespace"))
                    lType = WBEM_EVENTTYPE_NamespaceDeletion;
                else
                    lType = WBEM_EVENTTYPE_InstanceDeletion;
            }

            CESSHolder *pHolder = new CESSHolder (lType, lpNamespace, lpClass, (_IWmiObject *)pObj, NULL);
            if (!pHolder)
                hr = WBEM_E_OUT_OF_MEMORY;

            m_ESSObjs[GetCurrentThreadId()] = pHolder;
        }

    }

    return hr;
}

//***************************************************************************
//
//  CESSManager::CommitAll
//
//***************************************************************************
HRESULT CESSManager::CommitAll(LPCWSTR lpGUID, LPCWSTR lpRootNs)
{

    HRESULT hr = WBEM_S_NO_ERROR;

    if (m_EventSubSys)
    {
        if (lpGUID && wcslen(lpGUID))
        {
            CSQLConnection *pConn = NULL;
            hr = m_Conns->GetConnection(&pConn, FALSE, FALSE, 30);
            if (SUCCEEDED(hr))
            {
                hr = CSQLExecProcedure::CommitEvents(pConn, m_EventSubSys, 
                    lpRootNs, lpGUID, m_Schema, m_Objects);
                m_Conns->ReleaseConnection(pConn);

            }
        }
        else
        {
            DWORD dwThread = GetCurrentThreadId();
            CESSHolder *pH = m_ESSObjs[dwThread];
            if (pH)
                pH->Deliver(m_EventSubSys, lpRootNs);
            delete pH;
            m_ESSObjs[dwThread] = NULL;
        }
    }

    return hr;
}

//***************************************************************************
//
//  CESSManager::DeleteAll
//
//***************************************************************************
HRESULT CESSManager::DeleteAll(LPCWSTR lpGUID)
{

    HRESULT hr = WBEM_S_NO_ERROR;

    // Delete from DB

    if (m_EventSubSys)
    {
        if (lpGUID && wcslen(lpGUID))
        {
            CSQLConnection *pConn = NULL;
            hr = m_Conns->GetConnection(&pConn, FALSE, FALSE, 30);
            if (SUCCEEDED(hr))
            {
                hr = CSQLExecProcedure::DeleteUncommittedEvents(pConn, lpGUID, m_Schema, m_Objects);
                m_Conns->ReleaseConnection(pConn);
            }        
        }
        else
        {
            DWORD dwThread = GetCurrentThreadId();
            CESSHolder *pH = m_ESSObjs[dwThread];
            delete pH;
            m_ESSObjs[dwThread] = NULL;

        }
    }

    return hr;
}

//***************************************************************************
//
//  CESSHolder::CESSHolder
//
//***************************************************************************

CESSHolder::CESSHolder(long lType, LPWSTR lpNs, LPWSTR lpClass, _IWmiObject *pOld, _IWmiObject *pNew)
{
    m_lType = lType;
    if (lpNs && wcslen(lpNs))
        m_sNamespace = lpNs;
    else
        m_sNamespace = L"";
    m_sClass = lpClass;

    if (pOld)
        pOld->AddRef();
    if (pNew)
        pNew->AddRef();
    pOldObject = pOld;
    pNewObject = pNew;
}


//***************************************************************************
//
//  CESSHolder::Deliver
//
//***************************************************************************

HRESULT CESSHolder::Deliver (_IWmiCoreServices *pCS, LPCWSTR lpRootNs)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    DWORD dwNumObjs = 0;

    if (pOldObject)
        dwNumObjs++;
    if (pNewObject)
        dwNumObjs++;

    _bstr_t sTemp = L"\\\\.\\";
    sTemp += lpRootNs;
    if (m_sNamespace.length() && _wcsnicmp(m_sNamespace, L"root", 4))
    {
        sTemp += L"\\";
        sTemp += m_sNamespace;
    }

    _IWmiObject **pObjs = new _IWmiObject * [dwNumObjs];
    if (pObjs)
    {
        if (pNewObject)
            pObjs[0] = pNewObject;
        else
            pObjs[0] = pOldObject;
        if (pOldObject && pNewObject)
            pObjs[1] = pOldObject;

        hr = pCS->DeliverIntrinsicEvent(sTemp, m_lType, NULL, 
                m_sClass, NULL, dwNumObjs, pObjs);

        delete pObjs;

        if (pOldObject)
            pOldObject->Release();
        if (pNewObject)
            pNewObject->Release();
    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}

//***************************************************************************
//
//  CWmiDbController::CWmiDbController
//
//***************************************************************************

CWmiDbController::CWmiDbController()
{
	InitializeCriticalSection(&m_cs);

    m_dwTimeOut = 10*1000;  // 30 seconds default
    m_dwCurrentStatus = 0;  // No status
    m_uRefCount = 0;
    m_pIMalloc = NULL;
    m_InitProperties = NULL;    
    m_rgInitPropSet = NULL;     
    m_dwTotalHits = 0;
    m_dwCacheHits = 0;
    m_dwTotalHandles = 0;
    m_bCacheInit = 0;
    m_bIsAdmin = 0;
    m_bESSEnabled = 0;

    CoInitialize(NULL);
    ESSMgr.SetConnCache(&ConnCache);
    ESSMgr.SetObjectCache(&ObjectCache);
    ESSMgr.SetSchemaCache(&SchemaCache);
}

//***************************************************************************
//
//  CWmiDbController::CWmiDbController
//
//***************************************************************************
CWmiDbController::~CWmiDbController()
{
    Shutdown(0);
    if (m_pIMalloc)
        m_pIMalloc->Release();
    delete m_InitProperties;
    delete m_rgInitPropSet;
    g_cObj--;
	DeleteCriticalSection(&m_cs);
}

//***************************************************************************
//
//  CWmiDbController::QueryInterface
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbController::QueryInterface( 
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    *ppvObject = 0;

    if (IID_IUnknown==riid || IID_IWmiDbController==riid )
    {
        *ppvObject = (IWmiDbController*)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;

}

//***************************************************************************
//
//  CWmiDbController::AddRef
//
//***************************************************************************
ULONG STDMETHODCALLTYPE CWmiDbController::AddRef( )
{
    InterlockedIncrement((LONG *) &m_uRefCount);
    return m_uRefCount;

}
//***************************************************************************
//
//  CWmiDbController::Release
//
//***************************************************************************
ULONG STDMETHODCALLTYPE CWmiDbController::Release( )
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 != uNewCount)
        return uNewCount;
    delete this;
    return WBEM_S_NO_ERROR;

}


//***************************************************************************
//
//  CWmiDbController::FreeLogonTemplate
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CWmiDbController::FreeLogonTemplate( 
    /* [out][in] */ WMIDB_LOGON_TEMPLATE __RPC_FAR *__RPC_FAR *pTemplate) 
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        if (!pTemplate || !*pTemplate)
            hr = WBEM_E_INVALID_PARAMETER;
        else
        {
            WMIDB_LOGON_TEMPLATE *pTemp = *pTemplate;

            for (int i = 0; i < (int)pTemp->dwArraySize; i++)
            {
                VariantClear(&(pTemp->pParm[i].Value));
                SysFreeString(pTemp->pParm[i].strParmDisplayName);
            }
            delete []pTemp->pParm;

            delete *pTemplate;
            *pTemplate = NULL;
        }
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbController::FreeLogonTemplate\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hr;

}

//***************************************************************************
//
//  CWmiDbController::Logon
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CWmiDbController::Logon( 
    /* [in] */ WMIDB_LOGON_TEMPLATE __RPC_FAR *pLogonParms,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwRequestedHandleType,
    /* [out] */ IWmiDbSession __RPC_FAR *__RPC_FAR *ppSession,
    /* [out] */ IWmiDbHandle __RPC_FAR *__RPC_FAR *ppRootNamespace) 
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!pLogonParms)
        return WBEM_E_INVALID_PARAMETER;

    if (dwFlags &~ WMIDB_FLAG_NO_INIT &~ WMIDB_FLAG_ADMIN_VERIFIED)
        return WBEM_E_INVALID_PARAMETER;

    // Not yet clear what we need to do.
    // Best guess is: we get a SQL connection, shove it into an IWmiDbSession,
    // and give it back to the user.

    try
    {
        if (m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
            hr = WBEM_E_SHUTTING_DOWN;

        else
        {
            if (!ppSession)
                hr = WBEM_E_INVALID_PARAMETER;
            else
            {
                _WMILockit lkt(&m_cs);
                IWmiDbSession *pSession = NULL;
    
                hr = GetUnusedSession(pLogonParms, dwFlags, dwRequestedHandleType, &pSession);
                if (SUCCEEDED(hr))
                {
                    *ppSession = pSession;    // hopefully this interface will be corrected...

                    if (!(dwFlags & WMIDB_FLAG_NO_INIT))
                    {
                        if (!m_bCacheInit)
                        {
                            hr = ((CWmiDbSession *)pSession)->LoadSchemaCache();

                            // We don't want to return a handle if we couldn't load the schema cache.

                            if (SUCCEEDED(hr))
                                m_bCacheInit = TRUE;        
                        }
                
                        if (dwFlags & WMIDB_FLAG_ADMIN_VERIFIED)
                            m_bIsAdmin = TRUE;

                        // Now see if we can get a handle to the root namespace...
                        hr = ((CWmiDbSession *)pSession)->GetObject_Internal(L"root", dwFlags, dwRequestedHandleType, NULL, ppRootNamespace);

                        ((CWmiDbSession *)pSession)->m_sNamespacePath = L"root"; // Temporary default
                        wchar_t wMachineName[1024];
                        DWORD dwLen=1024;
                        if (!GetComputerName(wMachineName, &dwLen)) {
                            hr = GetLastError();
                            return WBEM_E_FAILED;
                        }
                        ((CWmiDbSession *)pSession)->m_sMachineName = wMachineName;

                        if (!m_bESSEnabled)
                        {
                            ESSMgr.InitializeESS();
                            if (ESSMgr.m_EventSubSys)
                                m_bESSEnabled = TRUE;
                        }
                    }
                    else if (ppRootNamespace)
                         *ppRootNamespace = NULL;
                }

            }

        }
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbController::Logon\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }
   
    return hr;
}

//***************************************************************************
//
//  CWmiDbController::Shutdown
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CWmiDbController::Shutdown( 
    /* [in] */ DWORD dwFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (dwFlags != 0)
        return WBEM_E_INVALID_PARAMETER;

    if (m_dwCurrentStatus)
        hr = m_dwCurrentStatus;
    else
        m_dwCurrentStatus = WBEM_E_SHUTTING_DOWN;

    try
    {
        FlushCache(REPDRVR_FLAG_FLUSH_ALL);

        hr = ConnCache.ClearConnections();

        for (int i = 0; i < m_Sessions.size(); i++)
        {
            IWmiDbSession *pSession = m_Sessions[i];
        
            if (pSession)
            {
                ((CWmiDbSession *)pSession)->ShutDown();
                pSession->Release();
            }
        }
        m_Sessions.clear();


    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbController::Shutdown\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hr;

}

//***************************************************************************
//
//  CWmiDbController::SetCallTimeout
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CWmiDbController::SetCallTimeout( 
    /* [in] */ DWORD dwMaxTimeout)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (dwMaxTimeout < 1000)
        return WBEM_E_INVALID_PARAMETER;

    if (m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        hr = WBEM_E_SHUTTING_DOWN;
    else
        m_dwTimeOut = dwMaxTimeout;

    return hr;

}

//***************************************************************************
//
//  CWmiDbController::SetCacheValue
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CWmiDbController::SetCacheValue( 
    /* [in] */ DWORD dwMaxBytes)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {

        if (m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
            hr = WBEM_E_SHUTTING_DOWN;
        else
        {
            ObjectCache.SetCacheSize(dwMaxBytes);
            SchemaCache.SetMaxSize(dwMaxBytes);
        }
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbController::SetCacheValue\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hr;

}

//***************************************************************************
//
//  CWmiDbController::FlushCache
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbController::FlushCache(
        DWORD dwFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        // Remove all data from the cache.

        {
            _WMILockit lkt(&m_cs);
            ObjectCache.EmptyCache();
        }

        if (dwFlags == REPDRVR_FLAG_FLUSH_ALL)
        {
            // Remove all SQL connections.  We will reconnect later.

            hr = ConnCache.ClearConnections();

            // Clear all internal caches. These will be restored on the next connection.

            {
                _WMILockit lkt(&m_cs);
                SchemaCache.EmptyCache();
            }

            m_bCacheInit = FALSE;
        }
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbController::FlushCache\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbController::GetStatistics
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CWmiDbController::GetStatistics( 
    /* [in] */ DWORD dwParameter,
    /* [out] */ DWORD __RPC_FAR *pdwValue) 
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwTemp1 = 0; 
    DWORD dwTemp2 = 0;
    _WMILockit _lk(&m_cs);

    try
    {
        if (!pdwValue)
            hr = WBEM_E_INVALID_PARAMETER;
        else
        {
            switch (dwParameter)
            {
            case WMIDB_FLAG_TOTAL_HANDLES:
                *pdwValue = m_dwTotalHandles;
                break;
            case WMIDB_FLAG_CACHE_SATURATION:
                ObjectCache.GetCurrentUsage(dwTemp1);
                ObjectCache.GetCacheSize(dwTemp2);
                if (dwTemp2 > 0)
                    *pdwValue = 100*(((double)dwTemp1/(double)dwTemp2));
                break;
            case WMIDB_FLAG_CACHE_HIT_RATE:
                if (m_dwTotalHits > 0)
                    *pdwValue = 100*((double)m_dwCacheHits / (double)m_dwTotalHits);
                break;
            default:
                hr = WBEM_E_NOT_SUPPORTED;
                break;
            }
        }
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbController::GetStatistics\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hr;

}

//***************************************************************************
//
//  CWmiDbController::GetUnusedSession
//
//***************************************************************************

HRESULT CWmiDbController::GetUnusedSession(WMIDB_LOGON_TEMPLATE *pLogon,
    DWORD dwFlags,
    DWORD dwHandleType,
    IWmiDbSession **pSess)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    CWmiDbSession *pSession = NULL;

    Sessions::iterator walk = m_Sessions.begin();

    while (walk != m_Sessions.end())
    {
        pSession = *walk;
        if (!(pSession)->m_bInUse)
        {            
            (pSession)->m_bInUse = TRUE;            
            break;
        }
        walk++;
    }

    if (!pSession)
    {
        hr = SetConnProps(pLogon);

        if (SUCCEEDED(hr))
        {
            pSession = new CWmiDbSession(this);
            if (pSession)
            {
                (pSession)->m_bInUse = TRUE;
                pSession->m_dwLocale = pLogon->pParm[4].Value.lVal;
                m_Sessions.push_back(pSession);
                pSession->m_pIMalloc = m_pIMalloc;
                pSession->AddRef(); // For us
                pSession->AddRef(); // For the end user.
                *pSess = pSession;
            }
            else
                hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        hr = SetConnProps(pLogon);
        pSession->m_dwLocale = pLogon->pParm[4].Value.lVal;
        pSession->AddRef();
    }

    hr = ConnCache.SetCredentials(m_rgInitPropSet);
    hr = ConnCache.SetMaxConnections (20);
    hr = ConnCache.SetTimeoutSecs(60);
    if (pLogon->pParm[3].Value.vt == VT_BSTR)
        hr = ConnCache.SetDatabase(pLogon->pParm[3].Value.bstrVal);
    else
        hr = ConnCache.SetDatabase(L""); // This isn't a SQL db.

    // Make sure the login credentials worked.
    // If they specified "No initialization", they 
    // don't intend to use the database - they are 
    // probably going to perform a backup or restore.

    if (!(dwFlags & WMIDB_FLAG_NO_INIT))
    {
        CSQLConnection *pConn;
        hr = ConnCache.GetConnection(&pConn, FALSE, FALSE, 30);
        if (SUCCEEDED(hr))
            ConnCache.ReleaseConnection(pConn);
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbController::SetConnProps
//
//***************************************************************************

HRESULT CWmiDbController::SetConnProps(WMIDB_LOGON_TEMPLATE *pLogon)
{
    HRESULT hr =    WBEM_S_NO_ERROR;
    ULONG     nProps = pLogon->dwArraySize + 2 ;    

    // This just sets the latest connection properties.
  
    // MOVE ME: SQL Server-specific optimization.  
//    wchar_t wMachineName[MAX_COMPUTERNAME_LENGTH+1];
//    DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
//    GetComputerName(wMachineName, &dwSize);
//    if (!wcscmp(pLogon->pParm[0].strParmDisplayName, wMachineName))
//        wcscpy(wMachineName, L".");
//    else
//        wcscpy(wMachineName, pLogon->pParm[0].Value.bstrVal);    

    if (!m_InitProperties)
    {
        m_InitProperties = new DBPROP[nProps];    
        if (!m_InitProperties)
            return WBEM_E_OUT_OF_MEMORY;

        m_rgInitPropSet = new DBPROPSET;
        if (!m_rgInitPropSet)
        {
            delete m_InitProperties;
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    int i = 0;

    m_InitProperties[i].dwOptions = DBPROPOPTIONS_REQUIRED;
    m_InitProperties[i].dwPropertyID = DBPROP_INIT_PROMPT;
    m_InitProperties[i].vValue.vt    = VT_I2;
    m_InitProperties[i].vValue.iVal =  DBPROMPT_NOPROMPT;
    m_InitProperties[i].colid = DB_NULLID;
    i++;

    for (i = 1; i < (pLogon->dwArraySize + 1); i++ )        
    {        
        m_InitProperties[i].colid = DB_NULLID;
        VariantInit(&m_InitProperties[i].vValue);        
        m_InitProperties[i].dwOptions = DBPROPOPTIONS_REQUIRED;
        m_InitProperties[i].dwPropertyID = pLogon->pParm[i-1].dwId;
        m_InitProperties[i].vValue.vt = pLogon->pParm[i-1].Value.vt;
        if (pLogon->pParm[i-1].Value.vt == VT_BSTR)
            m_InitProperties[i].vValue.bstrVal = SysAllocString(pLogon->pParm[i-1].Value.bstrVal);
        else if (pLogon->pParm[i-1].Value.vt == VT_I4)
            m_InitProperties[i].vValue.lVal = pLogon->pParm[i-1].Value.lVal;
    }

    m_InitProperties[i].dwOptions = DBPROPOPTIONS_REQUIRED;
    m_InitProperties[i].colid = DB_NULLID;
    m_InitProperties[i].dwPropertyID = DBPROP_INIT_TIMEOUT;
    m_InitProperties[i].vValue.vt = VT_I4;
    m_InitProperties[i].vValue.lVal = (long)m_dwTimeOut;
    
    m_rgInitPropSet->guidPropertySet = DBPROPSET_DBINIT;
    m_rgInitPropSet->cProperties = nProps;
    m_rgInitPropSet->rgProperties = m_InitProperties;
    
    return hr;
}

//***************************************************************************
//
//  CWmiDbController::ReleaseSession
//
//***************************************************************************

HRESULT CWmiDbController::ReleaseSession(IWmiDbSession *pSession)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(&m_cs);

    // Mark connection unused and stick back in cache.
    Sessions::iterator walk = m_Sessions.begin();

    while (walk != m_Sessions.end())
    {
        CWmiDbSession *pConn2 = *walk;
        if (pConn2 == ((CWmiDbSession *)pSession))
        {            
            pConn2->m_bInUse = FALSE;
            break;
        }
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbController::IncrementHitCount
//
//***************************************************************************

void CWmiDbController::IncrementHitCount (bool bCacheUsed)
{
    _WMILockit lkt(&m_cs);

    m_dwTotalHits++;
    if (bCacheUsed)
        m_dwCacheHits++;
}
//***************************************************************************
//
//  CWmiDbController::AddHandle
//
//***************************************************************************

void CWmiDbController::AddHandle()
{
    _WMILockit lkt(&m_cs);
    m_dwTotalHandles++;
}

//***************************************************************************
//
//  CWmiDbController::SubtractHandle
//
//***************************************************************************
void CWmiDbController::SubtractHandle()
{
    _WMILockit lkt(&m_cs);
    if (m_dwTotalHandles > 0)
        m_dwTotalHandles--;
}

//***************************************************************************
//
//  CWmiDbController::HasSecurityDescriptor
//
//***************************************************************************
BOOL CWmiDbController::HasSecurityDescriptor(SQL_ID ObjId)
{
    BOOL bRet = FALSE;

    _WMILockit _Lk(&m_cs);

    SQL_IDMap::iterator it = SecuredIDs.find(ObjId);    
    if (it != SecuredIDs.end())
        bRet = TRUE;

    return bRet;
}

//***************************************************************************
//
//  CWmiDbController::HasSecurityDescriptor
//
//***************************************************************************
void CWmiDbController::AddSecurityDescriptor(SQL_ID ObjId)
{
    _WMILockit _Lk(&m_cs);

    SecuredIDs[ObjId] = true;
}

//***************************************************************************
//
//  CWmiDbController::HasSecurityDescriptor
//
//***************************************************************************
void CWmiDbController::RemoveSecurityDescriptor(SQL_ID ObjId)
{
    _WMILockit _Lk(&m_cs);

    SQL_IDMap::iterator it = SecuredIDs.find(ObjId);
    if (it != SecuredIDs.end())
        SecuredIDs.erase(it);

}

//***************************************************************************
//
//  CWmiDbSession::CWmiDbSession
//
//***************************************************************************
CWmiDbSession::CWmiDbSession(IWmiDbController *pControl)
{
    m_uRefCount = 0;
    m_pController = pControl;
    m_dwLocale = 0;
    m_bInUse = false;
    m_pIMalloc = NULL;
    m_bIsDistributed = FALSE;
    m_pController->AddRef();
   
}
//***************************************************************************
//
//  CWmiDbSession::CWmiDbSession
//
//***************************************************************************
CWmiDbSession::~CWmiDbSession()
{
    if (m_pController)
    {
        ((CWmiDbController *)m_pController)->ReleaseSession(this);
        m_pController->Release();
    }    
    if (m_pIMalloc)
        m_pIMalloc->Release();
}


//***************************************************************************
//
//  CWmiDbSession::QueryInterface
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CWmiDbSession::QueryInterface( 
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    *ppvObject = 0;

    if (IID_IUnknown==riid || IID_IWmiDbSession==riid )
    {
        *ppvObject = (IWmiDbSession*)this;
        AddRef();
        return S_OK;
    }
    else if (IID_IWmiDbBatchSession == riid)
    {
        *ppvObject = (IWmiDbBatchSession*)this;
        AddRef();
        return S_OK;
    }
    else if (IID_IWbemTransaction == riid)
    {
        *ppvObject = (IWbemTransaction*)this;
        AddRef();
        return S_OK;
    }
    else if (IID_IWmiDbBackupRestore == riid)
    {
        *ppvObject = (IWmiDbBackupRestore*)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;

}

//***************************************************************************
//
//  CWmiDbSession::AddRef
//
//***************************************************************************
ULONG STDMETHODCALLTYPE CWmiDbSession::AddRef( )
{
    InterlockedIncrement((LONG *) &m_uRefCount);
    return m_uRefCount;

}
//***************************************************************************
//
//  CWmiDbSession::Release
//
//***************************************************************************
ULONG STDMETHODCALLTYPE CWmiDbSession::Release( )
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 != uNewCount)
        return uNewCount;
    delete this;
    return WBEM_S_NO_ERROR;

}

//***************************************************************************
//
//  CWmiDbSession::GetObject
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CWmiDbSession::GetObject( 
    /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
    /* [in] */ IWbemPath __RPC_FAR *pPath,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwRequestedHandleType,
    /* [out] */ IWmiDbHandle __RPC_FAR *__RPC_FAR *ppResult)
{
    HRESULT hr = WBEM_S_NO_ERROR;

 //   SYSTEMTIME tStartTime, tEndTime;
 //   GetLocalTime(&tStartTime);

//    StartCAP();

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    if (!pScope 
        || !pPath 
        || dwRequestedHandleType == WMIDB_HANDLE_TYPE_INVALID 
        || !ppResult
        || (dwRequestedHandleType & ~WMIDB_HANDLE_TYPE_COOKIE 
            &~WMIDB_HANDLE_TYPE_VERSIONED &~WMIDB_HANDLE_TYPE_PROTECTED
            &~WMIDB_HANDLE_TYPE_EXCLUSIVE &~ WMIDB_HANDLE_TYPE_WEAK_CACHE
            &~WMIDB_HANDLE_TYPE_STRONG_CACHE &~ WMIDB_HANDLE_TYPE_NO_CACHE
            &~WMIDB_HANDLE_TYPE_SUBSCOPED &~WMIDB_HANDLE_TYPE_SCOPE 
            &~WMIDB_HANDLE_TYPE_CONTAINER))
        return WBEM_E_INVALID_PARAMETER;

    try
    {
        {
            _WMILockit lkt(GetCS());
            if (!((CWmiDbController *)m_pController)->m_bCacheInit)
            {
                hr = LoadSchemaCache();
                if (SUCCEEDED(hr))
                    ((CWmiDbController *)m_pController)->m_bCacheInit = TRUE;
                else
                    return hr;
            }
        }

        _bstr_t sNewPath;

        SQL_ID dScopeId = ((CWmiDbHandle *)pScope)->m_dObjectId;

        if (SUCCEEDED(hr))
        {
            LPWSTR lpNewPath = NULL;
            BOOL bStoreDefault = TRUE;
            SQL_ID dStorageClassId = 0;
    
            hr = NormalizeObjectPathGet(pScope, pPath, &lpNewPath, &bStoreDefault, &dStorageClassId, &dScopeId);
            CDeleteMe <wchar_t>  r(lpNewPath);
            if (SUCCEEDED(hr))
            {
                if (bStoreDefault)
                {
                    // Handle the __Instances container.
                    // since this is not a real object.

                    if (dStorageClassId == INSTANCESCLASSID)
                    {
                        if (((dwRequestedHandleType & 0xF) != WMIDB_HANDLE_TYPE_COOKIE &&
                            (dwRequestedHandleType & 0xF) != WMIDB_HANDLE_TYPE_VERSIONED) ||
                            !bStoreDefault)
                            hr = WBEM_E_INVALID_PARAMETER;
                        else
                        {
                            SQL_ID dScopeId2 = dScopeId;
                            hr = GetObject_Internal(L"__Instances", dwFlags, dwRequestedHandleType,
                                &dScopeId2, ppResult);
                            if (SUCCEEDED(hr))
                            {
                                SQL_ID dClassId;
                                hr = GetSchemaCache()->GetClassID(lpNewPath, dScopeId, dClassId);
                                if (SUCCEEDED(hr))
                                {
                                    CWmiDbHandle *pTemp = (CWmiDbHandle *)*ppResult;
                                    pTemp->m_dObjectId = dClassId;
                                    pTemp->m_dClassId = INSTANCESCLASSID;
                                    pTemp->m_dScopeId = dScopeId;
                                }
                            }
                        }
                    }
                    else
                        hr = GetObject_Internal(lpNewPath, dwFlags, dwRequestedHandleType, &dScopeId, ppResult);
                    if (SUCCEEDED(hr))
                    {
                        // Mark this object as "custom" if
                        // this is a descendant of a custom scope,
                        // or if this is a custom namespace.
                        CWmiDbHandle *pTemp = (CWmiDbHandle *)*ppResult;

                        pTemp->m_bDefault = ((CWmiDbHandle *)pScope)->m_bDefault;
                        if (pTemp->m_dClassId == MAPPEDNSCLASSID)
                            pTemp->m_bDefault = FALSE;
                    }
                }

                // Use the custom storage mechanism.

                else
                {
                    // This needs to take care of all security and locks!!

                    hr = CustomGetObject(pScope, pPath, lpNewPath, dwFlags, dwRequestedHandleType, ppResult);
                }

//                GetLocalTime(&tEndTime);
//                ERRORTRACE((LOG_WBEMCORE, "IWmiDbSession::GetObject (%S) - %ld ms\n", lpNewPath, GetDiff(tEndTime, tStartTime)));
            }            
        }
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbSession::GetObject\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

//    StopCAP();

    return hr;

}

//***************************************************************************
//
//  CWmiDbSession::GetObjectDirect
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbSession::GetObjectDirect( 
    /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
    /* [in] */ IWbemPath __RPC_FAR *pPath,
    /* [in] */ DWORD dwFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID __RPC_FAR *pObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        if (!m_pController ||
            ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
            return WBEM_E_SHUTTING_DOWN;

        IWmiDbHandle *pHandle= NULL;
        CSQLConnection *pConn = NULL;
        hr = GetSQLCache()->GetConnection(&pConn, FALSE, IsDistributed());
        if (SUCCEEDED(hr))
        {
            LPWSTR lpNewPath = NULL;
            BOOL bStoreDefault = TRUE;
            SQL_ID dStorageClassId = 0;
            SQL_ID dScopeId;
            IWmiDbHandle *pHandle = NULL;

            hr = NormalizeObjectPathGet(pScope, pPath, &lpNewPath, &bStoreDefault, &dStorageClassId, &dScopeId, pConn);
            CDeleteMe <wchar_t>  r(lpNewPath);

            if (!bStoreDefault || (dStorageClassId == INSTANCESCLASSID))
                hr = GetObject(pScope, pPath, dwFlags, WMIDB_HANDLE_TYPE_COOKIE, &pHandle);
            else if (SUCCEEDED(hr))
                hr = GetObject_Internal(lpNewPath, dwFlags, WMIDB_HANDLE_TYPE_COOKIE, &dScopeId, &pHandle, pConn);

            if (SUCCEEDED(hr))
            {
                CReleaseMe r (pHandle);
                hr = ((CWmiDbHandle *)pHandle)->QueryInterface_Internal(pConn, pObj);
            }
            GetSQLCache()->ReleaseConnection(pConn, hr, IsDistributed());
        }    
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbSession::GetObjectDirect\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }
    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::GetObject
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CWmiDbSession::GetObject_Internal( 
    /* [in] */ LPWSTR lpPath,   /* The full path */
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwRequestedHandleType,
    /* [in] */ SQL_ID *pScopeId,
    /* [out] */ IWmiDbHandle __RPC_FAR *__RPC_FAR *ppResult,
               CSQLConnection *pConn)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    bool bImmediate = !(dwRequestedHandleType & WMIDB_HANDLE_TYPE_SUBSCOPED);

    SQL_ID dScopeId = 0;
    if (pScopeId)
        dScopeId = *pScopeId;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;
    if (!lpPath)
        return WBEM_E_INVALID_PARAMETER;

    *ppResult = NULL;

    SQL_ID dObjId = 0, dClassId = 0;

    LPWSTR lpKey = GetKeyString(lpPath);

    CDeleteMe <wchar_t>  r(lpKey);
    BOOL bGetScope = FALSE;

    BOOL bNeedToRelease = FALSE;
    if (!pConn)
    {
        hr = GetSQLCache()->GetConnection(&pConn, FALSE, IsDistributed());
        bNeedToRelease = TRUE;
        if (FAILED(hr))
            return hr;
    }

    // Special-case: Go up to the previous scope
    if (!wcscmp(lpPath, L".."))
    {
        hr = GetSchemaCache()->GetParentNamespace(dScopeId, dObjId, &dClassId);
        if (FAILED(hr))
        {
            BOOL bExists = FALSE;
            hr = GetObjectCache()->GetObject(dScopeId, NULL, &dObjId);
            if (FAILED(hr))
                bGetScope = TRUE;
            else
                hr = CSQLExecProcedure::ObjectExists(pConn, dObjId, bExists, &dClassId, NULL);
        }
    }
    else
        hr = GetObjectCache()->GetObjectId(lpKey, dObjId, dClassId, &dScopeId);

    if (FAILED(hr))
    {
        hr = WBEM_S_NO_ERROR;        
        if (SUCCEEDED(hr))
        {
            BOOL bExists = FALSE;
            
            if (!bGetScope)
            {
                hr = CSQLExecProcedure::ObjectExists(pConn, dObjId, bExists, &dClassId, &dScopeId);
                if (hr == E_NOTIMPL)
                {
                    hr = CSQLExecProcedure::GetObjectIdByPath(pConn, lpKey, dObjId, dClassId, &dScopeId);
                    if (dObjId)
                        bExists = TRUE;
                }
            }
            else
            {
                // If we are getting the parent object,
                // hit the db again to find the essentials there.

                hr = CSQLExecProcedure::ObjectExists(pConn, dScopeId, bExists, &dClassId, &dObjId);
                if (SUCCEEDED(hr))
                    hr = CSQLExecProcedure::ObjectExists(pConn, dObjId, bExists, &dClassId, &dScopeId);
            }

            if (SUCCEEDED(hr) && bExists)
            {                   
                // If a cookie or protected handle, just ref count.
                // If exclusive, there can be only one.
                // If versioned, we need to keep each version separate.

                if ((dwRequestedHandleType & 0xF) == WMIDB_HANDLE_TYPE_COOKIE ||
                    (dwRequestedHandleType & 0xF) == WMIDB_HANDLE_TYPE_PROTECTED)
                    ((CWmiDbController *)m_pController)->LockCache.GetHandle(dObjId, dwRequestedHandleType, ppResult);

                if (*ppResult == NULL)
                {
                    // If this object exists, try and obtain the requested lock.

                    CWmiDbHandle *pTemp = new CWmiDbHandle;
                    if (pTemp)
                    {
                        DWORD dwVersion = 0;
                        pTemp->m_pSession = this;
                        AddRef_Lock();

                        // If this is a class, we want to lock its parents.

                        if (!(dwFlags & WMIDB_FLAG_ADMIN_VERIFIED))
                        {
                            DWORD dwReq = WBEM_ENABLE;

                            if (dwFlags & WBEM_FLAG_USE_SECURITY_DESCRIPTOR)
                                dwReq |= READ_CONTROL;

                            hr = VerifyObjectSecurity(pConn, dObjId, dClassId, dScopeId, 0, dwReq);                        
                        }
                        if (SUCCEEDED(hr))
                        {
                            if (IsDistributed())
                            {
                                // Does this lock exist locally?
                                hr = ((CWmiDbController *)m_pController)->LockCache.AddLock(false, dObjId, 
                                    WMIDB_HANDLE_TYPE_PROTECTED, pTemp, dScopeId, dClassId, 
                                    &((CWmiDbController *)m_pController)->SchemaCache, false, 0, 0, &dwVersion);

                                if (FAILED(hr))
                                {
                                    // OK if the lock has already been taken
                                    // on this session...

                                    if (LockExists(dObjId))
                                        hr = WBEM_S_NO_ERROR;                                    
                                }
        
                                if (SUCCEEDED(hr))
                                    hr = AddTransLock(dObjId, WMIDB_HANDLE_TYPE_PROTECTED);
                            }
                            
                            if (SUCCEEDED(hr))
                            {
                                hr = ((CWmiDbController *)m_pController)->LockCache.AddLock(bImmediate, dObjId, dwRequestedHandleType, pTemp, 
                                    dScopeId, dClassId, &((CWmiDbController *)m_pController)->SchemaCache, false, 0, 0, &dwVersion);
                            }
                        }
                        if (FAILED(hr))
                        {
                            delete pTemp;
                            *ppResult = NULL;
                        }
                        else
                        {
                            // We have the lock. They will have to call Release() to
                            // free it up.

                            ((CWmiDbController *)m_pController)->AddHandle();
                            pTemp->AddRef();
                            pTemp->m_dwHandleType = dwRequestedHandleType;
                            pTemp->m_dObjectId = dObjId;
                            
                            pTemp->m_bDefault = TRUE;

                            pTemp->m_dClassId = dClassId;
                            pTemp->m_dScopeId = dScopeId;
                            pTemp->m_dwVersion = dwVersion;
                            if (dwFlags & WBEM_FLAG_USE_SECURITY_DESCRIPTOR)
                                pTemp->m_bSecDesc = TRUE;
                            if (ppResult)
                                *ppResult = pTemp;
                        }
                    }
                    else
                    {
                        if (ppResult)
                            *ppResult = NULL;
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                    if (m_pController)
                        ((CWmiDbController *)m_pController)->IncrementHitCount(false);
                }

            }
            else if (SUCCEEDED(hr))
                hr = WBEM_E_NOT_FOUND;
        }
    }
    else
    {
        if (!(dwFlags & WMIDB_FLAG_ADMIN_VERIFIED))
        {
            DWORD dwReq = WBEM_ENABLE;

            if (dwFlags & WBEM_FLAG_USE_SECURITY_DESCRIPTOR)
                dwReq |= READ_CONTROL;

            hr = VerifyObjectSecurity(pConn, dObjId, dClassId, dScopeId, 0, dwReq);                        
        }
        if (SUCCEEDED(hr))
        {
            // At this point, we know that the object has been
            // cached.  Try to obtain a lock.
            // ===============================================

            CWmiDbHandle *pTemp = new CWmiDbHandle;
            if (pTemp)
            {   
                DWORD dwVersion = 0;
                pTemp->m_pSession = this;
            
                hr = ((CWmiDbController *)m_pController)->LockCache.AddLock(bImmediate, dObjId, dwRequestedHandleType, pTemp, 
                            dScopeId, dClassId, &((CWmiDbController *)m_pController)->SchemaCache, false, 0, 0, &dwVersion);
                if (SUCCEEDED(hr))
                {     
                    AddRef_Lock();
                    ((CWmiDbController *)m_pController)->AddHandle();
                    pTemp->AddRef();
                    pTemp->m_dwHandleType = dwRequestedHandleType;
                    pTemp->m_dObjectId = dObjId;
                    pTemp->m_bDefault = TRUE;
                    pTemp->m_dClassId = dClassId;
                    pTemp->m_dScopeId = dScopeId;
                    pTemp->m_dwVersion = dwVersion;
                    pTemp->m_pData = NULL;
                    if (dwFlags & WBEM_FLAG_USE_SECURITY_DESCRIPTOR)
                        pTemp->m_bSecDesc = TRUE;

                    if (ppResult)
                        *ppResult = pTemp;

                    // We won't bother attaching the object part until they
                    // ask for it.
                }
                else
                {
                    delete pTemp;
                    *ppResult = NULL;
                }
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }

        if (m_pController)
            ((CWmiDbController *)m_pController)->IncrementHitCount(true);
    }

    if (bNeedToRelease)
        GetSQLCache()->ReleaseConnection(pConn, hr, IsDistributed());

    if (pScopeId)
        *pScopeId = dScopeId;

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::PutObject
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbSession::PutObject( 
    /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ LPVOID pObjToPut,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwRequestedHandleType,
    /* [out] */ IWmiDbHandle __RPC_FAR *__RPC_FAR *ppResult)
{

    HRESULT hr = 0;
    CSQLConnection *pConn = NULL;

    AddRef_Lock();

//    StartCAP();

    //SYSTEMTIME tStartTime, tEndTime;
    //GetLocalTime(&tStartTime);

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    if (dwFlags & ~WBEM_FLAG_CREATE_ONLY & ~WBEM_FLAG_UPDATE_ONLY & ~WBEM_FLAG_CREATE_OR_UPDATE
        & ~WMIDB_DISABLE_EVENTS & ~WBEM_FLAG_USE_SECURITY_DESCRIPTOR &~ WBEM_FLAG_REMOVE_CHILD_SECURITY
        & ~WMIDB_FLAG_ADMIN_VERIFIED &~ WBEM_FLAG_UPDATE_SAFE_MODE &~ WBEM_FLAG_UPDATE_FORCE_MODE)
        return WBEM_E_INVALID_PARAMETER;

    if ((ppResult && (dwRequestedHandleType == WMIDB_HANDLE_TYPE_INVALID)) 
        || !pScope
        || !pObjToPut)
        return WBEM_E_INVALID_PARAMETER;

    if (riid != IID_IWbemClassObject &&
        riid != IID_IWmiDbHandle &&
        riid != IID__IWmiObject)
        return WBEM_E_NOT_SUPPORTED;
    
    try
    {
        {
            _WMILockit lkt(GetCS());
            if (!((CWmiDbController *)m_pController)->m_bCacheInit)
            {
                hr = LoadSchemaCache();
                if (SUCCEEDED(hr))
                    ((CWmiDbController *)m_pController)->m_bCacheInit = TRUE;
                else
                    return hr;
            }
        }

        hr = GetSQLCache()->GetConnection(&pConn, TRUE, IsDistributed());
        if (SUCCEEDED(hr))
        {
            _bstr_t sWaste = L"";
            BOOL bSys = FALSE;

            hr = PutObject(pConn, pScope, 0, L"", (IUnknown *)pObjToPut, dwFlags, dwRequestedHandleType, sWaste, ppResult);
            if (SUCCEEDED(hr) && ppResult)
            {
                CWmiDbHandle *pTemp = (CWmiDbHandle *)*ppResult;

                pTemp->m_bDefault = ((CWmiDbHandle *)pScope)->m_bDefault;
                if (pTemp->m_dClassId == MAPPEDNSCLASSID)
                    pTemp->m_bDefault = FALSE;
            }

            GetSQLCache()->ReleaseConnection(pConn, hr, IsDistributed());

            if (!(dwFlags & WMIDB_DISABLE_EVENTS) && !IsDistributed())
            {
                if (SUCCEEDED(hr))
                    ((CWmiDbController *)m_pController)->ESSMgr.CommitAll(m_sGUID, m_sNamespacePath);
            }

        }    
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbSession::PutObject\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

//    StopCAP();

    UnlockDynasties();

    return hr;

}

//***************************************************************************
//
//  CWmiDbSession::PutObject
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CWmiDbSession::PutObject( 
               CSQLConnection *pConn, 
               IWmiDbHandle __RPC_FAR *pScope,
               SQL_ID dScopeID,
               LPWSTR lpScopePath,
    /* [in] */ IUnknown __RPC_FAR *pObjToPut,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwRequestedHandleType,
               _bstr_t &sPath,
    /* [out] */ IWmiDbHandle __RPC_FAR *__RPC_FAR *ppResult,
                BOOL bStoreAsClass )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SQL_ID dObjectId = 0;
    IWmiDbHandle *pHandle = NULL;
    bool bClass = false, bLockVerified = false;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    if ((dwRequestedHandleType == WMIDB_HANDLE_TYPE_INVALID) && ppResult)
        return WBEM_E_INVALID_PARAMETER;

    if (dwRequestedHandleType & ~WMIDB_HANDLE_TYPE_COOKIE 
            &~WMIDB_HANDLE_TYPE_VERSIONED &~WMIDB_HANDLE_TYPE_PROTECTED
            &~WMIDB_HANDLE_TYPE_EXCLUSIVE &~ WMIDB_HANDLE_TYPE_WEAK_CACHE
            &~WMIDB_HANDLE_TYPE_STRONG_CACHE &~ WMIDB_HANDLE_TYPE_NO_CACHE
            &~WMIDB_HANDLE_TYPE_SUBSCOPED&~WMIDB_HANDLE_TYPE_AUTODELETE
            &~WMIDB_HANDLE_TYPE_CONTAINER &~ WMIDB_HANDLE_TYPE_SCOPE )
            return WBEM_E_INVALID_PARAMETER;

    bool bImmediate = !(dwRequestedHandleType & WMIDB_HANDLE_TYPE_SUBSCOPED);
    SQL_ID dClassId = 0;

    // Hand this to the repository, to ensure that it cleans up
    // any autodelete objects on failure.

    dwFlags |= (dwRequestedHandleType & WMIDB_HANDLE_TYPE_AUTODELETE);

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    // Normalize the object path.

    sPath = L"";
    BOOL bStoreDefault = TRUE;
    IWbemClassObject *pOutObj = NULL;
    LPWSTR lpScope = NULL;
    if (pScope)
    {
        if (GetSchemaCache()->IsDerivedClass
                    (INSTANCESCLASSID, ((CWmiDbHandle *)pScope)->m_dClassId) ||
                    ((CWmiDbHandle *)pScope)->m_dClassId == INSTANCESCLASSID)
            hr = WBEM_E_INVALID_OPERATION;
        else
        {
            CWbemClassObjectProps *pProps= NULL;
            hr = NormalizeObjectPath(pScope, (LPWSTR)NULL, &lpScope, FALSE, &pProps, &bStoreDefault, pConn);  
            CDeleteMe <CWbemClassObjectProps>  r (pProps);

            dScopeID = ((CWmiDbHandle *)pScope)->m_dObjectId;            
            if (SUCCEEDED(hr) && dScopeID)
            {                
                SQL_ID dParent = 0;
                LPWSTR lpScopeKey = GetKeyString(lpScope);
                CDeleteMe <wchar_t>  r1 (lpScopeKey);
                if (FAILED(GetSchemaCache()->GetNamespaceID(lpScopeKey, dParent)))
                {
                    if (pProps)
                    {
                        DWORD dwTempHandle = ((CWmiDbHandle *)pScope)->m_dwHandleType;
                        ((CWmiDbHandle *)pScope)->m_dwHandleType |= WMIDB_HANDLE_TYPE_STRONG_CACHE;

                        IWbemClassObject *pObj = NULL;
                        hr = ((CWmiDbHandle *)pScope)->QueryInterface_Internal(pConn, (void **)&pObj);       
                        CReleaseMe r (pObj);
                        ((CWmiDbHandle *)pScope)->m_dwHandleType = dwTempHandle;
                        if (SUCCEEDED(hr))
                        {
                            if (pProps->lpNamespace && wcslen(pProps->lpNamespace))
                                GetSchemaCache()->GetNamespaceID(pProps->lpNamespace, dParent);
                            hr = GetSchemaCache()->AddNamespace(lpScope, lpScopeKey, dScopeID, dParent, 
                                ((CWmiDbHandle *)pScope)->m_dClassId);
                            CSQLExecProcedure::InsertScopeMap(pConn, dScopeID, lpScopeKey, dParent);
                        }
                    }
                    else if (lpScope && wcslen(lpScope))
                    {
                        delete lpScope;
                        return WBEM_E_INVALID_OPERATION;
                    }
                }
            }
        }

        if (SUCCEEDED(hr) && !dScopeID)
            hr = WBEM_E_INVALID_OBJECT;
    }
    else if (lpScopePath != NULL)
    {
        lpScope = new wchar_t [wcslen(lpScopePath) + 1];
        if (!lpScope)
            return WBEM_E_OUT_OF_MEMORY;
        wcscpy(lpScope, lpScopePath);
    }

    CDeleteMe <wchar_t>  r (lpScope);

    // Validate that this object has permission to 
    // write this object, and the handle is not out of date.
    // =====================================================

    if (SUCCEEDED(hr))
    {
        hr = pObjToPut->QueryInterface(IID_IWmiDbHandle, (void **)&pHandle);
        CReleaseMe rHandle (pHandle);
        if (SUCCEEDED(hr))
        {
            CWmiDbHandle *pTemp = (CWmiDbHandle *)pHandle;
            dObjectId = pTemp->m_dObjectId;

            // If they took out a protected lock,
            // they can't modify it either.
            // =================================
        
            if (pTemp->m_dwHandleType == WMIDB_HANDLE_TYPE_PROTECTED)
                hr = WBEM_E_ACCESS_DENIED;
            else
            {
                hr = VerifyObjectLock(dObjectId, pTemp->m_dwHandleType, pTemp->m_dwVersion);
                if (SUCCEEDED(hr))
                {
                    bLockVerified = true;  
                }
            }
        }
        else
        {
            dObjectId = 0;
            bLockVerified = 0;      
            hr = 0; 
        }

        if (SUCCEEDED(hr))
        {
            // Get the IWbemClassobject interface.  If none, fail.
            IWbemClassObject *pObj = NULL;
            bool bClass = false;

            hr = pObjToPut->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
            CReleaseMe r2 (pObj);
            if (SUCCEEDED(hr))
            {
                VARIANT vTemp;
                VariantInit(&vTemp);
                CClearMe c (&vTemp);
                CWbemClassObjectProps objprops (this, pConn, pObj, &((CWmiDbController *)m_pController)->SchemaCache, dScopeID);
                if (!objprops.lpClassName)
                {
                    hr = WBEM_E_INVALID_OBJECT;
                    goto Exit;
                }
       
                BOOL bNs = FALSE;

                if (IsDerivedFrom(pObj, L"__Instances"))
                {
                    hr = WBEM_E_INVALID_OPERATION;
                }
                else
                {
                    if (objprops.dwGenus == 1 || bStoreAsClass)
                        bClass = true;

                    if (pScope)
                    {
                        SQL_ID dId = ((CWmiDbHandle *)pScope)->m_dClassId;
                        if (objprops.lpClassName && wcslen(objprops.lpClassName) >=2)
                        {
                            if (objprops.lpClassName[0] == L'_' && objprops.lpClassName[1] == L'_')
                            {
                                bStoreDefault = TRUE;

                                if (objprops.dwGenus == 1)
                                {
                                    dScopeID = 0;
                                    lpScope = NULL;
                                }
                            }
                            else if (dId == MAPPEDNSCLASSID)
                                bStoreDefault = FALSE;
                        }
                    }
              
                    if (objprops.dwGenus == 2 && 
                            IsDerivedFrom(pObj, L"__Namespace"))
                    {
                        delete objprops.lpRelPath;
                        objprops.lpRelPath = GetPropertyVal(L"Name", pObj);
                        if (!objprops.lpRelPath)
                        {
                            hr = WBEM_E_OUT_OF_MEMORY;
                            goto Exit;
                        }
                        bNs = TRUE;
                    }

                    if (lpScope && dScopeID != ROOTNAMESPACEID)
                    {
                        if (!wcslen(lpScope))
                        {
                            ERRORTRACE((LOG_WBEMCORE, "Invalid scope text in CWmiDbSession::PutObject (%I64d) \n", dScopeID));
                            hr = WBEM_E_INVALID_PARAMETER;
                            goto Exit;
                        }
                        LPWSTR lpPath = NULL, lpPtr = NULL;
                        int iLen = wcslen(lpScope);

                        if (objprops.lpRelPath)
                        {
                            if (_wcsnicmp(objprops.lpRelPath, lpScope, iLen) ||
                                ((wcslen(objprops.lpRelPath) > iLen) && 
                                  objprops.lpRelPath[iLen] != L'\\'))
                            {
                                lpPtr = new wchar_t [wcslen(objprops.lpRelPath) + wcslen(lpScope) + 10];
                                if (!lpPtr)
                                {
                                    hr = WBEM_E_OUT_OF_MEMORY;
                                    goto Exit;
                                }
                                lpPath = lpPtr;
                                if (!bNs)
                                    swprintf(lpPath, L"%s:%s", lpScope, objprops.lpRelPath);
                                else
                                    swprintf(lpPath, L"%s\\%s", lpScope, objprops.lpRelPath);
                                if (!_wcsnicmp(lpPath, L"root", wcslen(L"root")))
                                    lpPtr += wcslen(L"root")+1;
                                sPath = lpPtr;
                            }            
                            else
                                sPath  += objprops.lpRelPath;
                        }
                    
                        CDeleteMe <wchar_t>  r4 (lpPath);

                    }
                    else 
                    {
                        if (objprops.lpRelPath)
                        {
                            sPath += objprops.lpRelPath;
                        }
                    }
                }

                if (wcslen(objprops.lpClassName) > REPDRVR_NAME_LIMIT)
                    hr = WBEM_E_CLASS_NAME_TOO_WIDE;
                else
                    objprops.lpKeyString = GetKeyString(sPath);

                if (dScopeID)
                {
                //hr = VerifyObjectSecurity(pConn, dObjectId, dClassId, dScopeID, 0, dwRequired);
                    if (!(dwFlags & WMIDB_FLAG_ADMIN_VERIFIED))
                        hr = VerifyObjectSecurity(pConn, dScopeID, 0, sPath, &objprops, dwRequestedHandleType, WBEM_PARTIAL_WRITE_REP, dObjectId, dClassId);
                    else
                        hr = VerifyObjectSecurity(pConn, dScopeID, 0, sPath, &objprops, dwRequestedHandleType, 0, dObjectId, dClassId);
                }

                if (SUCCEEDED(hr))
                {                
                    bool bChanged = false;
                    bool bNew = false;

                    if (bClass)
                    {
                        SQL_ID dTemp = 0;
                        if (FAILED(GetSchemaCache()->GetClassID(objprops.lpClassName, dScopeID, dTemp)))
                            bNew = true;

                        BOOL bIgnoreDefaults = (bStoreAsClass ? TRUE: FALSE);
                        hr = PutClass(pConn, dScopeID, lpScope, &objprops, pObj, dwFlags, dObjectId, sPath, bChanged, bIgnoreDefaults);
                        dClassId = 1;

                        // After we have put the class, *then*
                        // we see if we need to set it up in the 
                        // custom database.

                        if (!bStoreDefault && SUCCEEDED(hr))
                        {
                            // Update the mapping for this class.

                            hr = CustomCreateMapping(pConn, objprops.lpClassName, pObj, pScope);
                        }
                    }
                    else if (dClassId)
                    {
                        // If this is a custom repository,
                        // forward this request to the custom rep code.

                        if (bStoreDefault)
                        {
                            hr = PutInstance(pConn, pScope, dScopeID, lpScope, &objprops, pObj, dwFlags, dObjectId, dClassId, sPath, bChanged);
                        }
                        else
                        {
                            hr = CustomPutInstance(pConn, pScope, dClassId, dwFlags, &pObj);
                            pOutObj = pObj;
                        }
                    }
                    else
                         hr = WBEM_E_INVALID_CLASS;

                    if (SUCCEEDED(hr))
                    {
                        if (SUCCEEDED(hr))
                        {
                            // Render return handle as needed.

                            if (ppResult)
                            {
                                if (pHandle)
                                {
                                    pHandle->AddRef();
                                    *ppResult = pHandle;

                                    // Bump up version number, so other outstanding handles
                                    // know this object changed.
                                    hr = ((CWmiDbController *)m_pController)->LockCache.AddLock(bImmediate, dObjectId, WMIDB_HANDLE_TYPE_VERSIONED, NULL, 
                                        dScopeID, dClassId, &((CWmiDbController *)m_pController)->SchemaCache, true, 0, 0);                    

                                    if (SUCCEEDED(hr))
                                        hr = ((CWmiDbController *)m_pController)->LockCache.DeleteLock(dObjectId, false, WMIDB_HANDLE_TYPE_VERSIONED, true, NULL);
                            
                                }
                                else
                                {
                                    DWORD dwVersion = 0;
                                    CWmiDbHandle *pTemp = new CWmiDbHandle;
                                    if (!pTemp)
                                    {
                                        hr = WBEM_E_OUT_OF_MEMORY;
                                        goto Exit;
                                    }

                                    pTemp->m_pSession = this;

                                    hr = ((CWmiDbController *)m_pController)->LockCache.AddLock(bImmediate, dObjectId, dwRequestedHandleType, pTemp, 
                                                dScopeID, dClassId, &((CWmiDbController *)m_pController)->SchemaCache, true, 0, 0, &dwVersion);

                                    if (SUCCEEDED(hr))
                                    {
                                        AddRef_Lock();
                                        ((CWmiDbController *)m_pController)->AddHandle();
                                        pTemp->m_dObjectId = dObjectId; 
                                        pTemp->m_dClassId = dClassId;

                                        pTemp->m_bDefault = TRUE;
                                        pTemp->m_dScopeId = dScopeID;
                                        pTemp->m_pSession = this;
                                        pTemp->m_pData = pOutObj;
                                        if (pOutObj)
                                            pOutObj->AddRef();
                                        pTemp->AddRef();
                                        pTemp->m_dwVersion = dwVersion;
                                        pTemp->m_dwHandleType = dwRequestedHandleType;
                                        if (dwFlags & WBEM_FLAG_USE_SECURITY_DESCRIPTOR)
                                            pTemp->m_bSecDesc = TRUE;

                                        *ppResult = pTemp;
                                    }
                                    else
                                    {
                                        *ppResult = NULL;
                                        delete pTemp;
                                    }
                                }

                            }
                            else
                            {
                                // Bump up version number, so other outstanding handles
                                // know this object changed.
                                hr = ((CWmiDbController *)m_pController)->LockCache.AddLock(bImmediate, dObjectId, WMIDB_HANDLE_TYPE_VERSIONED, NULL, 
                                    dScopeID, dClassId, &((CWmiDbController *)m_pController)->SchemaCache, true, 0, 0);                    

                                ((CWmiDbController *)m_pController)->LockCache.DeleteLock(dObjectId, false, WMIDB_HANDLE_TYPE_VERSIONED, true, NULL);
                            }


                            // Add an exclusive lock on this object...
                            // If cannot lock, check locally and see if we have one.

                            if (IsDistributed())
                            {
                                hr = ((CWmiDbController *)m_pController)->LockCache.AddLock(false, dObjectId, 
                                    WMIDB_HANDLE_TYPE_EXCLUSIVE, NULL, dScopeID, dClassId, 
                                    &((CWmiDbController *)m_pController)->SchemaCache, true, 0, 0);
                                if (FAILED(hr))
                                {
                                    if (LockExists(dObjectId))
                                        hr = WBEM_S_NO_ERROR;                                    
                                }
    
                                if (SUCCEEDED(hr))
                                {
                                    hr = AddTransLock(dObjectId, WMIDB_HANDLE_TYPE_EXCLUSIVE);                                        
                                }
                            }

                            // Update the object in the cache if necessary
                            // Either they want it cached now, or the 
                            // object already exists in the cache.
                            // ===========================================

                            if (SUCCEEDED(hr))
                            {
                                if (GetObjectCache()->ObjectExists(dObjectId) ||
                                    (dwRequestedHandleType & 0xF00) == WMIDB_HANDLE_TYPE_WEAK_CACHE ||
                                    (dwRequestedHandleType & 0xF00) == WMIDB_HANDLE_TYPE_STRONG_CACHE)
                                {
                                    bool bCacheType = ((dwRequestedHandleType & 0xF00) == WMIDB_HANDLE_TYPE_STRONG_CACHE) ? 1 : 0;
                                    LPWSTR lpKey = GetKeyString(sPath);
                                    CDeleteMe <wchar_t>  r6(lpKey);

                                    GetObjectCache()->PutObject(dObjectId, dClassId, dScopeID, lpKey, bCacheType, pObj);
                                }
                                // Regardless, if we have updated a class, 
                                // we need to remove the instances
                                // and subclasses from the cache.
                                // ================================
                                if (bClass && !bNew)
                                {
                                    SQL_ID dObjId = 0, dClassId = 0;

                                    HRESULT hTemp = GetObjectCache()->FindFirst(dObjId, dClassId);
                                    while (SUCCEEDED(hTemp))
                                    {
                                        if (dClassId == 1)
                                            dClassId = dObjId;

                                        if (GetSchemaCache()->IsDerivedClass(dObjectId, dClassId))
                                            GetObjectCache()->DeleteObject(dObjId);

                                        hTemp = GetObjectCache()->FindNext(dObjId, dObjId, dClassId);
                                    }
                                }                                    
                            }
                        }
                    }                    
                }
            }
        }
    }

    if (SUCCEEDED(hr) && (dwFlags & WBEM_FLAG_REMOVE_CHILD_SECURITY))
    {
        // Is this a recursive put (WBEM_FLAG_REMOVE_CHILD_SECURITY)?  We need to recursively erase all security on all child objects.
        // * Enumerate all dependent objects that have SDs.
        // * Call PutObject on each *with* the Use_SD flag, but without the remove_child_security
        //   flag

        SQLIDs ObjIds, ClassIds, ScopeIds;
        hr = CSQLExecProcedure::EnumerateSecuredChildren(pConn, &((CWmiDbController *)m_pController)->SchemaCache,
                        dObjectId, dClassId, dScopeID, ObjIds, ClassIds, ScopeIds);
        if (SUCCEEDED(hr))
        {
            for (int i = 0; i < ObjIds.size(); i++)
            {
                // Get the old object.
                // Strip off the __SECURITY_DESCRIPTOR property
                // Put it again.

                SQL_ID dObjectId = ObjIds.at(i), 
                        dClassId = ClassIds.at(i),
                        dScopeId = ScopeIds.at(i);

                _bstr_t sScopeKey;
                hr = GetSchemaCache()->GetNamespaceName(dScopeId, NULL, &sScopeKey);

                DWORD dwTemp;
                IWbemClassObject *pObj = NULL;

                hr = GetObjectData(pConn, dObjectId, dClassId, dScopeId, 
                            0, dwTemp, &pObj, FALSE, NULL);
                CReleaseMe r (pObj);
                if (SUCCEEDED(hr))
                {
                    hr = pObj->Put(L"__SECURITY_DESCRIPTOR", 0, NULL, CIM_FLAG_ARRAY|CIM_UINT8);
                    if (SUCCEEDED(hr))
                    {
                        _bstr_t sPath;
                        hr = PutObject(pConn, NULL, dScopeId, sScopeKey, pObj, 
                                        WBEM_FLAG_USE_SECURITY_DESCRIPTOR, 0, sPath,
                                        NULL, FALSE);
                    }
                }
            }
        }
        else if (hr == E_NOTIMPL)
            hr = WBEM_S_NO_ERROR;
    }

Exit:

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::UpdateHierarchy
//
//***************************************************************************

HRESULT CWmiDbSession::UpdateHierarchy(CSQLConnection *pConn, SQL_ID dClassId, DWORD dwFlags, LPCWSTR lpScopePath,
                CWbemClassObjectProps *pProps, _IWmiObject *pObj)
{

    HRESULT hr = WBEM_S_NO_ERROR;

    // Enumerate subclasses (from the cache), 
    // forcibly update them, and add to ESS cache

    int iNumDerived = 0;
    SQL_ID *pIDs = NULL;

    hr = GetSchemaCache()->GetDerivedClassList(dClassId, &pIDs, iNumDerived, TRUE);                        
    if (SUCCEEDED(hr))
    {
        CDeleteMe <SQL_ID> d3 (pIDs);

        // If there are instances, fail now.

        BOOL bInstances = FALSE;
        hr = CSQLExecProcedure::HasInstances(pConn, dClassId, pIDs, iNumDerived, bInstances);
        if (bInstances)
            return WBEM_E_CLASS_HAS_INSTANCES;
                            
        for (int i = 0; i < iNumDerived; i++)
        {
            IWbemClassObject *pSubClass = NULL;
            hr = GetClassObject(pConn, pIDs[i], &pSubClass);
            CReleaseMe r2 (pSubClass);
            if (SUCCEEDED(hr))
            {
                _IWmiObject *pNew = NULL;
                hr = ((_IWmiObject *)pObj)->Update(((_IWmiObject *)pSubClass), WBEM_FLAG_UPDATE_FORCE_MODE, &pNew);
                if (SUCCEEDED(hr))
                {
                    if(!(dwFlags & WMIDB_DISABLE_EVENTS))
                    {
                        ((CWmiDbController *)m_pController)->ESSMgr.AddInsertRecord(pConn, m_sGUID, 
                                (LPWSTR)lpScopePath, pProps->lpClassName, pProps->dwGenus, pSubClass, pNew);
                    }

                    hr = UpdateHierarchy(pConn, pIDs[i], dwFlags, lpScopePath, pProps, pNew);
                    if (FAILED(hr))
                        break;

                    // Update the subclass object in the repository.
                    // Can only be done after all children have been updated.
                                                    
                    hr = CSQLExecProcedure::UpdateClassBlob(pConn, pIDs[i], pNew);
                    if (FAILED(hr))
                        break;
                }
                else
                    break;
            }
        }
    }
    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::PutClass
//
//***************************************************************************
HRESULT CWmiDbSession::PutClass( 
               CSQLConnection *pConn, 
    /* [in] */ SQL_ID dScopeID,
    /* [in] */ LPCWSTR lpScopePath,
               CWbemClassObjectProps *pProps, 
    /* [in] */ IWbemClassObject *pObj,
               DWORD dwFlags,
    /* [in/out] */ SQL_ID &dObjectId,
    /* [out] */ _bstr_t &sObjectPath,
               bool &bChg,
               BOOL bIgnoreDefaults)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SQL_ID dTempScopeID = 0;
    bool bNewObj = (dObjectId == 0) ? 1 : 0;
    SQL_ID dSuperClassId = 1;
    SQL_ID dDynasty = 0;
    wchar_t wSuperClass[450];

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    if (dwFlags & WBEM_FLAG_USE_SECURITY_DESCRIPTOR)
        return WBEM_E_INVALID_PARAMETER;

    // See if anything changed.

    if (dObjectId)
    {
        IWbemClassObject *pOldObj = NULL;
        DWORD dwTemp;
        hr = GetObjectData(pConn, dObjectId, 1, dScopeID, 
                    0, dwTemp, &pOldObj, FALSE, NULL);                        
        CReleaseMe r (pOldObj);

        if (SUCCEEDED(hr) && !(dwFlags & WMIDB_FLAG_ADMIN_VERIFIED))
        {
            DWORD dwRequired = 0;
            if (pProps->lpClassName[0] == L'_')
                dwRequired = WBEM_FULL_WRITE_REP;
            else
                dwRequired = WBEM_PARTIAL_WRITE_REP;

            hr = VerifyObjectSecurity(pConn, dObjectId, 1, dScopeID, 0, dwRequired);
            if (FAILED(hr))
            {
                return hr;
            }
        }

        if (SUCCEEDED(hr))
        {
            // Backward compatibility: always log an event,
            // even though nothing has changed.
            
            if(!(dwFlags & WMIDB_DISABLE_EVENTS))
            {
                ((CWmiDbController *)m_pController)->ESSMgr.AddInsertRecord(pConn, m_sGUID, 
                        (LPWSTR)lpScopePath, pProps->lpClassName, pProps->dwGenus, pOldObj, pObj);
            }

            hr = pOldObj->CompareTo(0, pObj);
            if (WBEM_S_NO_ERROR == hr)
                return WBEM_S_NO_ERROR; // Nothing changed.  Don't bother updating.
            else
            {
                // Did this impact subclasses?  If so,
                // enumerate and add ESS records.

                BOOL bImmediate = FALSE;

                hr = ((_IWmiObject *)pOldObj)->ReconcileWith(WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE, (_IWmiObject *)pObj);
                if (hr != WBEM_S_NO_ERROR)
                {
                    hr = UpdateHierarchy(pConn, dObjectId, dwFlags, lpScopePath, pProps, (_IWmiObject *)pObj);

                }

            }
        }
        else
            hr = WBEM_S_NO_ERROR;
    }
    else
    {
        if(!(dwFlags & WMIDB_DISABLE_EVENTS))
        {
            ((CWmiDbController *)m_pController)->ESSMgr.AddInsertRecord(pConn, m_sGUID, 
                    (LPWSTR)lpScopePath, pProps->lpClassName, pProps->dwGenus, NULL, pObj);
        }
    }

    bChg = true;

    // Generate the object path.

    if (!wcslen(pProps->lpRelPath) || !wcslen(pProps->lpClassName))
        return WBEM_E_INVALID_OBJECT;
   
    if (pProps->lpSuperClass && wcslen(pProps->lpSuperClass))
    {
        if (FAILED(GetSchemaCache()->GetClassID (pProps->lpSuperClass, dScopeID, dSuperClassId)))
            return WBEM_E_INVALID_CLASS;

        if (lpScopePath != NULL && wcslen(lpScopePath))
            swprintf(wSuperClass, L"%s:%s", lpScopePath, pProps->lpSuperClass);
        else
            wcscpy(wSuperClass, pProps->lpSuperClass);       
    }
    else
        wSuperClass[0] = L'\0';

    (GetSchemaCache()->GetClassID (pProps->lpDynasty, dScopeID, dDynasty));

    if (SUCCEEDED(hr))
    {
        IRowset *pIRowset = NULL;
        DWORD dwRows = 0;

        DWORD dwClassFlags = 0;
        IWbemQualifierSet *pQS = NULL;

        hr = pObj->GetQualifierSet(&pQS);
        if (SUCCEEDED(hr))
        {
            CReleaseMe r (pQS);
            dwClassFlags = GetQualifierFlag(L"Abstract", pQS) ? REPDRVR_FLAG_ABSTRACT : 0;
            dwClassFlags |= GetQualifierFlag(L"Singleton", pQS) ? REPDRVR_FLAG_SINGLETON : 0;
            dwClassFlags |= GetQualifierFlag(L"Unkeyed", pQS) ? REPDRVR_FLAG_UNKEYED : 0;
            dwClassFlags |= GetQualifierFlag(L"HasClassRefs", pQS) ? REPDRVR_FLAG_CLASSREFS : 0;
            BOOL bExists = FALSE;

            // If exists, only update the class if super class or flags changed
            // (They can't change the name or scope without changing the
            //  path, right?)

            _bstr_t sName;
            SQL_ID dSuperClass = 1;

            if (SUCCEEDED(GetSchemaCache()->GetClassInfo 
               (dObjectId, sName, dSuperClass, dTempScopeID, dwFlags)))
                   bExists = TRUE;

            LPWSTR lpObjKey, lpParentKey;
            lpObjKey = pProps->lpKeyString;
            lpParentKey = GetKeyString(wSuperClass);
            CDeleteMe <wchar_t> r2(lpParentKey);

            if (!lpObjKey || !wcslen(lpObjKey))
            {
                ERRORTRACE((LOG_WBEMCORE, "Invalid object path in CWmiDbSession::PutClass (%S) \n", sObjectPath));
                hr = WBEM_E_INVALID_PARAMETER;                
            }
            else
            {
                // Insert the data.
                // Ensure that we don't end up reporting to ourself.
                // Enumerate the __Derivation property of the IWbemClassObject,
                // and see if the class is in its own ancestry.

                if (IsDerivedFrom(pObj, pProps->lpClassName, TRUE))
                    hr = WBEM_E_CIRCULAR_REFERENCE;
               
                if (SUCCEEDED(hr))
                {
                    _IWmiObject *pInt = NULL;
                    hr = pObj->QueryInterface(IID__IWmiObject, (void **)&pInt);
                    CReleaseMe r (pInt);
                    if (SUCCEEDED(hr))
                    {
                        BYTE *pBuff;
                        BYTE buff[128];
                        DWORD dwLen = 0;

                        pInt->Unmerge(0, 128, &dwLen, &buff);

                        if (dwLen > 0)
                        {
                            pBuff = new BYTE [dwLen];
                            if (pBuff)
                            {
                                DWORD dwLen1;
                                hr = pInt->Unmerge(0, dwLen, &dwLen1, pBuff);
                                if (SUCCEEDED(hr))
                                {
                                    hr = CSQLExecProcedure::InsertClass(pConn, pProps->lpClassName, lpObjKey, sObjectPath, dScopeID,
                                         dSuperClassId, dDynasty, 0, pBuff, dwLen1, dwClassFlags, dwFlags, dObjectId);

                                    if (SUCCEEDED(hr))
                                    {
                                        if (!dDynasty)
                                            dDynasty = dObjectId;
                                        hr = GetSchemaCache()->AddClassInfo(dObjectId, pProps->lpClassName, 
                                                dSuperClassId, dDynasty, dScopeID, lpObjKey, dwClassFlags);
                                    }
                                }
                                delete pBuff;
                            }
                            else
                                hr = WBEM_E_OUT_OF_MEMORY;
                        }
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Get a map of this classes' property IDs
                // Qualifiers won't be present, but that's OK now.
                // ==============================================

                Properties props;

                if (!bNewObj)
                    hr = GetSchemaCache()->GetPropertyList(dObjectId, props);

                // Iterate through all properties, qualifiers, methods.
                // Only update ones that changed and update cache.
                // Check off/Add ID as we encounter them.   
                // ====================================================

                BSTR strName;
                VARIANT vTemp;
                CIMTYPE cimtype;
                long lPropFlavor = 0;
                IWbemQualifierSet *pQS = NULL;

                // Properties

                //((_IWmiObject *)pObj)->BeginEnumerationEx(WBEM_FLAG_CLASS_LOCAL_AND_OVERRIDES, WMIOBJECT_BEGINENUMEX_FLAG_GETEXTPROPS);
                pObj->BeginEnumeration(WBEM_FLAG_CLASS_LOCAL_AND_OVERRIDES);
                while (pObj->Next(0, &strName, &vTemp, &cimtype, &lPropFlavor) == S_OK)
                {
                    CFreeMe f1 (strName);
                    pObj->GetPropertyQualifierSet(strName, &pQS);
                    if (pQS)
                    {
                        CReleaseMe r (pQS);
                        lPropFlavor = (REPDRVR_FLAG_CLASSREFS & dwClassFlags);
                        lPropFlavor |= (GetQualifierFlag(L"key", pQS)) ? REPDRVR_FLAG_KEY : 0; 
                        lPropFlavor |= (GetQualifierFlag(L"indexed", pQS)) ? REPDRVR_FLAG_INDEXED : 0;
                        lPropFlavor |= (GetQualifierFlag(L"keyhole", pQS)) ? REPDRVR_FLAG_KEYHOLE : 0;
                        lPropFlavor |= (GetQualifierFlag(L"not_null", pQS)) ? REPDRVR_FLAG_NOT_NULL : 0;
                    }

                    if (bIgnoreDefaults)
                        VariantClear(&vTemp);

                    hr = InsertPropertyDef(pConn, pObj, dScopeID, dObjectId, strName, vTemp, cimtype, lPropFlavor, 0,props);

                    VariantClear(&vTemp);
                    if (FAILED(hr))
                        break;
                }

                // No need to insert qualifiers or methods.
                // We are only creating schema so it can 
                // be queried when we get instances.

                // Delete any properties, methods that 
                // were not found, remove from cache.
                // Qualifiers can simply be deleted,
                // since they aren't cached.
                // ===================================

                if (SUCCEEDED(hr) && !bNewObj)
                {
                    _bstr_t sSQL;
                    bool bInit = false;

                    Properties::iterator item = props.begin();
                    while (item != props.end())
                    {       
                        DWORD dwID = (*item).first;

                        if (!GetSchemaCache()->IsQualifier(dwID))
                        {
                            if (!(*item).second)
                            {
                                SQL_ID dClass = 0;

                                hr = GetSchemaCache()->GetPropertyInfo 
                                    (dwID, NULL, &dClass);
                                if (dClass == dObjectId)
                                {
                                    CSQLExecProcedure::DeleteProperty(pConn, dwID);
                                    GetSchemaCache()->DeleteProperty(dwID, dClass); 
                                } 
                                hr = WBEM_S_NO_ERROR;
                            }
                        }
                        item++;
                    }
                }
                else if (FAILED(hr) && bNewObj)
                {
                    hr = GetSchemaCache()->DeleteClass(dObjectId);
                }
            }
        }
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::InsertPropertyDef
//
//***************************************************************************

HRESULT CWmiDbSession::InsertPropertyDef(CSQLConnection *pConn,
                                         IWbemClassObject *pObj, SQL_ID dScopeId, 
                                         SQL_ID dObjectId, LPWSTR lpPropName, VARIANT vDefault,
                                          CIMTYPE cimtype, long dwFlags, DWORD dRefId,
                                          Properties &props)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    bool bArray = false;

    if (cimtype & CIM_FLAG_ARRAY)
        bArray = true;

    dwFlags |= (bArray) ? REPDRVR_FLAG_ARRAY : 0;
    cimtype &= ~CIM_FLAG_ARRAY;

    // If this is an embedded object or reference,
    // set the class ID of the embedded object, if any.

    SQL_ID dRefClassId = 0;
    if (cimtype == CIM_REFERENCE || cimtype == CIM_OBJECT)
    {
        IWbemQualifierSet *pQS = NULL;
        hr = pObj->GetPropertyQualifierSet(lpPropName, &pQS);
        if (SUCCEEDED(hr))
        {
            VARIANT vValue;
            VariantInit(&vValue);            
            CReleaseMe r (pQS);
            CClearMe c (&vValue);

            hr = pQS->Get(L"CIMTYPE", 0, &vValue, NULL);

            // Since previously, wbem did not do any type checking of references
            // or embedded objects, we generate the IDs for the classes if
            // they aren't already present.  This will still fail for instances.

            if (!_wcsnicmp(vValue.bstrVal, L"ref", 3) &&
                wcslen(vValue.bstrVal) > 3)
            {
                LPWSTR lpPtr = (LPWSTR)vValue.bstrVal;
                lpPtr += 4;
                hr = GetSchemaCache()->GetClassID(lpPtr, dScopeId, dRefClassId);
                if (hr == WBEM_E_NOT_FOUND)
                {
                    _bstr_t sScopeKey;
                    hr = GetSchemaCache()->GetNamespaceName(dScopeId, NULL, &sScopeKey);
                    if (SUCCEEDED(hr))
                    {
                        _bstr_t sNewName = lpPtr;
                        sNewName += L"?";
                        sNewName += sScopeKey;
                        dRefClassId = CRC64::GenerateHashValue(sNewName);
                        hr = WBEM_S_NO_ERROR;
                    }
                }
            }
            else if (!_wcsnicmp(vValue.bstrVal, L"object", 6) &&
                wcslen(vValue.bstrVal) > 6)
            {
                LPWSTR lpPtr = (LPWSTR)vValue.bstrVal;
                lpPtr += 7;
                hr = GetSchemaCache()->GetClassID(lpPtr, dScopeId, dRefClassId);
                if (hr == WBEM_E_NOT_FOUND)
                {
                    _bstr_t sScopeKey;
                    hr = GetSchemaCache()->GetNamespaceName(dScopeId, NULL, &sScopeKey);
                    if (SUCCEEDED(hr))
                    {
                        _bstr_t sNewName = lpPtr;
                        sNewName += L"?";
                        sNewName += sScopeKey;
                        dRefClassId = CRC64::GenerateHashValue(sNewName);
                        hr = WBEM_S_NO_ERROR;
                    }
                }
            }
        }
    }

    // We can't verify that a property changed, since we currently aren't
    // caching the defaults, so will insert regardless.

    DWORD dwPropertyID = 0;

    if (wcslen(lpPropName) > REPDRVR_NAME_LIMIT)
    {
        hr = WBEM_E_PROPERTY_NAME_TOO_WIDE;
    }
    else
    {
        BOOL bChg = TRUE;
        SQL_ID dOrigClass = 0;

        if ((GetSchemaCache()->GetPropertyID 
            (lpPropName, dObjectId, dwFlags, cimtype, dwPropertyID, &dOrigClass)) == WBEM_S_NO_ERROR)
        {
        }
        else if (!(dwFlags & (REPDRVR_FLAG_NONPROP &~ REPDRVR_FLAG_METHOD)))
        {           
            // Does this property exist on the derived class already?
            if (SUCCEEDED(hr))
            {
                hr = GetSchemaCache()->FindProperty(dObjectId, lpPropName, dwFlags, cimtype);
            }
        }

        if (SUCCEEDED(hr))
        {
            BOOL bIsKey = FALSE;
            if (bChg)
            {
                LPWSTR lpVal = GetStr(vDefault);
                CDeleteMe <wchar_t>  r(lpVal);
                hr = CSQLExecProcedure::InsertClassData(pConn, pObj, &((CWmiDbController *)m_pController)->SchemaCache,
                    dScopeId, dObjectId, lpPropName, cimtype, GetStorageType(cimtype, bArray), lpVal,
                    dRefClassId, dRefId, dwFlags, 0, 0, dwPropertyID, dOrigClass, &bIsKey);
            }

            if (SUCCEEDED(hr))
            {
                hr = GetSchemaCache()->AddPropertyInfo (dwPropertyID, 
                    lpPropName, dObjectId, GetStorageType(cimtype, bArray), cimtype, dwFlags, 
                    0, L"", dRefId, 0);  // don't cache the default!

                if (bIsKey)
                    GetSchemaCache()->SetIsKey(dObjectId, dwPropertyID);

                props[dwPropertyID] = 1;
            }            
        }
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::InsertQualifiers
//
//***************************************************************************

HRESULT CWmiDbSession::InsertQualifiers (CSQLConnection *pConn, IWmiDbHandle *pScope, SQL_ID dObjectId, 
                                         DWORD PropID, DWORD Flags, IWbemQualifierSet *pQS,
                                         Properties &props)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    BSTR strName;
    VARIANT vTemp;
    VariantInit(&vTemp);
    long lPropFlavor = 0;

    pQS->BeginEnumeration(0);
    while (pQS->Next(0, &strName, &vTemp, &lPropFlavor) == S_OK)
    {
        CFreeMe f (strName);
        lPropFlavor = lPropFlavor&~WBEM_FLAVOR_ORIGIN_PROPAGATED&~WBEM_FLAVOR_ORIGIN_SYSTEM&~WBEM_FLAVOR_AMENDED;

        hr = InsertQualifier(pConn, pScope, dObjectId, strName, vTemp, 
            lPropFlavor, Flags & REPDRVR_FLAG_QUALIFIER, PropID, props);

        VariantClear(&vTemp);
        if (FAILED(hr))
            break;
    }
    pQS->EndEnumeration();

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::InsertQualifier
//
//***************************************************************************
HRESULT CWmiDbSession::InsertQualifier( CSQLConnection *pConn,IWmiDbHandle *pScope, 
                                          SQL_ID dObjectId,
                                          LPWSTR lpQualifierName, VARIANT vValue,
                                          long lQfrFlags, DWORD dwFlags, DWORD PropID,
                                          Properties &props)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    dwFlags |= REPDRVR_FLAG_QUALIFIER;

    // This will only insert the qualifier definition
    // and the initial data.  

    // Insert the qualifier, unless its one of the
    // system quartet: key, indexed, keyhole, not_null
    // ==================================================

    if (!_wcsicmp(lpQualifierName, L"abstract")) 
        return WBEM_S_NO_ERROR;

    if (!_wcsicmp(lpQualifierName, L"cimtype"))
    {        
        if ((wcslen(vValue.bstrVal) > 3 && !_wcsnicmp(vValue.bstrVal, L"ref", 3)) ||
            (wcslen(vValue.bstrVal) > 6 && !_wcsnicmp(vValue.bstrVal, L"object", 6)))
        {
        }
        else
            return WBEM_S_NO_ERROR;  // CIMTypes are generated automatically.
    }

    bool bArray = false;
    CIMTYPE ct;

    switch((vValue.vt &~ CIM_FLAG_ARRAY))
    {
    case VT_R4:
    case VT_R8:
        ct = CIM_REAL64;
        break;
    case VT_BSTR:
        ct = CIM_STRING;
        break;
    case VT_BOOL:
        ct = CIM_BOOLEAN;
        break;
    default:
        ct = CIM_UINT32;
        break;
    }

    if (vValue.vt & VT_ARRAY)
        bArray = true;

    dwFlags |= (bArray) ? REPDRVR_FLAG_ARRAY : 0;

    DWORD dwPropertyID = 0;

    if (wcslen(lpQualifierName) > REPDRVR_NAME_LIMIT)
    {
        hr = WBEM_E_QUALIFIER_NAME_TOO_WIDE;
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            LPWSTR lpVal = GetStr(vValue);
            CDeleteMe <wchar_t>  r(lpVal);

            try
            {

                GetSchemaCache()->GetPropertyID (lpQualifierName, 1, dwFlags, ct, dwPropertyID);
                hr = CSQLExecProcedure::InsertClassData(pConn, NULL, &((CWmiDbController *)m_pController)->SchemaCache, 0, 1, lpQualifierName, 
                        ct, GetStorageType(ct, bArray), lpVal,0, PropID, dwFlags, lQfrFlags, 0, dwPropertyID);

                if (SUCCEEDED(hr))
                {
                    hr = GetSchemaCache()->AddPropertyInfo (dwPropertyID, 
                        lpQualifierName, 1, GetStorageType(ct, bArray), ct, dwFlags, 
                        0, L"", PropID, lQfrFlags);  // don't cache the default!

                    // Add any array defaults.
                    // =======================

                    if (vValue.vt & VT_ARRAY)
                        hr = InsertArray(pConn, pScope, dObjectId, 1, dwPropertyID, vValue, lQfrFlags, PropID);            
                }
            }
            catch (...)
            {
                hr = WBEM_E_CRITICAL_ERROR;
            }
        }
    }
    
    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::PutInstance
//
//***************************************************************************
HRESULT CWmiDbSession::PutInstance( 
               CSQLConnection *pConn, 
               IWmiDbHandle *pScope, 
    /* [in] */ SQL_ID dScopeID,
    /* [in] */ LPCWSTR lpScopePath,
               CWbemClassObjectProps *pProps, 
    /* [in] */ IWbemClassObject *pObj,
               DWORD dwFlags,
    /* [in/out] */ SQL_ID &dObjectId,
    /* [out] */ SQL_ID &dClassId,
    /* [out] */ _bstr_t &sObjectPath,
    bool &bChg)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    bool bUpdate = (dObjectId == 0) ? false : true;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    SQL_ID dTestId = dObjectId;
    if (!dTestId)
    {
        if (pProps->lpKeyString)
            dTestId = CRC64::GenerateHashValue(pProps->lpKeyString);
    }

    BOOL bGetSD = FALSE;
    if (dwFlags & WBEM_FLAG_USE_SECURITY_DESCRIPTOR)
        bGetSD = TRUE;

    IWbemClassObject *pOldObj = NULL;
    DWORD dwTemp;
    hr = GetObjectData(pConn, dTestId, dClassId, dScopeID, 
                0, dwTemp, &pOldObj, FALSE, NULL, bGetSD);                        
    CReleaseMe r (pOldObj);
    if (SUCCEEDED(hr))
    {
        if (SUCCEEDED(hr) && !(dwFlags & WMIDB_FLAG_ADMIN_VERIFIED))
        {
            DWORD dwRequired = 0;
            if (dwFlags & WBEM_FLAG_USE_SECURITY_DESCRIPTOR)
                dwRequired = WRITE_DAC;
            else
            {
                if (pProps->lpClassName[0] == L'_')
                    dwRequired = WBEM_FULL_WRITE_REP;
                else
                    dwRequired = WBEM_PARTIAL_WRITE_REP;
            }

            hr = VerifyObjectSecurity(pConn, dTestId, dClassId, dScopeID, 0, dwRequired);
            if (FAILED(hr))
            {
                return hr;
            }
        }

        if(!(dwFlags & WMIDB_DISABLE_EVENTS))
        {
            LPWSTR lpClass = pProps->lpClassName;
            BOOL bRelease = FALSE;

            if (IsDerivedFrom(pObj, L"__Namespace"))
            {
                lpClass = GetPropertyVal(L"Name", pObj);
                bRelease = TRUE;
            }

            ((CWmiDbController *)m_pController)->ESSMgr.AddInsertRecord(pConn, m_sGUID, 
                    (LPWSTR)lpScopePath, lpClass, pProps->dwGenus, pOldObj, pObj);

            if (bRelease)
                delete lpClass;
        }

        hr = pOldObj->CompareTo(0, pObj);
        if (WBEM_S_NO_ERROR == hr)
            return WBEM_S_NO_ERROR; // Nothing changed.  Don't bother updating.
    }
    else
    {
        hr = WBEM_S_NO_ERROR;
        if(!(dwFlags & WMIDB_DISABLE_EVENTS))
        {
            ((CWmiDbController *)m_pController)->ESSMgr.AddInsertRecord(pConn, m_sGUID, 
                    (LPWSTR)lpScopePath, pProps->lpClassName, pProps->dwGenus, NULL, pObj);
        }
    }

    bChg = true;

    if (SUCCEEDED(hr))
    {
        IRowset *pIRowset = NULL;
        DWORD dwNumRows = 0;

        // Generate unkeyed or keyhole path if none (and if class is one of the two)

        if (!bUpdate )
        {
            bool bUnkeyed = false;
            _bstr_t sName;
            SQL_ID dTemp1, dTemp2;
            DWORD dwFlags = 0;
            
            hr = GetSchemaCache()->GetClassInfo (dClassId, sName, dTemp1, dTemp2, dwFlags);
            if (SUCCEEDED(hr) && (dwFlags & REPDRVR_FLAG_UNKEYED))
            {
                bUnkeyed = true;
                hr = CSQLExecProcedure::GetNextUnkeyedPath(pConn, dClassId, sObjectPath);
            }                
                // Cannot add instances to an abstract class.

            if (dwFlags & REPDRVR_FLAG_ABSTRACT)
                return WBEM_E_INVALID_OPERATION;

            DWORD dwKeyholePropID = 0;
            _bstr_t sKeyholeProp;

            if (SUCCEEDED(hr) && SUCCEEDED(GetSchemaCache()->GetKeyholeProperty(dClassId, dwKeyholePropID, sKeyholeProp)))
            {
                hr = SetKeyhole(pConn, pObj, dwKeyholePropID, sKeyholeProp, lpScopePath, sObjectPath);
                delete pProps->lpRelPath;
                pProps->lpRelPath = GetPropertyVal(L"__RelPath", pObj);
            }

            if (!bUnkeyed && !pProps->lpRelPath)
                hr = WBEM_E_INVALID_OBJECT; // path cannot be blank at this point.
        }

        if (SUCCEEDED(hr)) // we have a valid path.
            hr = InsertPropertyValues(pConn, pScope, sObjectPath, dObjectId, dClassId, dScopeID, dwFlags, pProps, pObj);
    }

    return hr;

}

//***************************************************************************
//
//  CWmiDbSession::SetKeyhole
//
//***************************************************************************

HRESULT CWmiDbSession::SetKeyhole (CSQLConnection *pConn, IWbemClassObject *pObj, DWORD dwKeyholePropID, 
                                   LPWSTR sKeyholeProp, LPCWSTR lpScopePath, _bstr_t &sPath)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // See if it is populated.
    CIMTYPE ct = 0;
    long lFlags = 0;
    VARIANT vTemp;
    VariantInit(&vTemp);
    _bstr_t sNewValue;
    SQL_ID dNextId = 0;

    hr = pObj->Get(sKeyholeProp, 0, &vTemp, &ct, &lFlags);
    LPWSTR lpVal = GetStr(vTemp);
    CDeleteMe <wchar_t>  r(lpVal);
    VariantClear(&vTemp);

    if (!lpVal || !wcslen(lpVal) || !_wcsicmp(lpVal,L"0"))
    {
        // Execute stored procedure.
        // =========================

        hr = CSQLExecProcedure::GetNextKeyhole(pConn, dwKeyholePropID, dNextId);
        if (SUCCEEDED(hr))
        {
           // If a string property, just
            // convert the number to text.
            // ==========================

            if (ct == CIM_STRING)   // We really want a GUID here!!!!
            {                                
                wchar_t szTmp[20];
                swprintf(szTmp, L"%ld", dNextId);
                V_BSTR(&vTemp) = szTmp;
                vTemp.vt = VT_BSTR;
            }
            else
            {
                V_I4(&vTemp) = dNextId;
                vTemp.vt = VT_I4;
            }

            // Try to update the key value,
            // and get the object path again.
            // ==============================

            hr = pObj->Put(sKeyholeProp, 0, &vTemp, ct);
            if (SUCCEEDED(hr))
            {
                hr = pObj->Get(L"__RelPath", 0, &vTemp, NULL, NULL);       
                sPath = vTemp.bstrVal;
                if (lpScopePath != NULL)
                {
                    _bstr_t sTemp = sPath;
                    sPath = _bstr_t(lpScopePath) + L":" + sTemp;
                }                                
            }    
        }
    }

    return hr;

}

InsertQfrValues * ReAllocQfrValues (InsertQfrValues *pVals, int iNumVals, int iAdd)
{
    InsertQfrValues * pRet = new InsertQfrValues[iNumVals + iAdd];
    if (pRet)
    {
        int iSize = sizeof(InsertQfrValues) * iNumVals;
        /*
        for (int i = 0; i < iNumVals; i++)
        {
            if (pVals[i].pValue)
                iSize += wcslen(pVals[i].pValue)+ 1;
            if (pVals[i].pRefKey)
                iSize += wcslen(pVals[i].pRefKey) + 1;            
        }
        */
        memcpy(pRet, pVals, iSize);
        delete pVals;
    }
    else
        delete pVals;
    return pRet;
}

// Strip off local prefixes.  Any unresolved path
// not in this format might not be an object stored
// in this database.

LPWSTR StripUnresolvedName (LPWSTR lpPath)
{
    LPWSTR lpRet = new wchar_t [wcslen(lpPath) + 1];
    if (lpRet)
    {
        if (wcslen(lpPath) > 2)
        {
            if (wcsstr(lpPath, L"\\\\.\\root"))
                lpPath += 9;       
        }

        wcscpy(lpRet, lpPath);
    }
    
    return lpRet;
}

//***************************************************************************
//
//  TestSD
//
//***************************************************************************

HRESULT TestSD(VARIANT * pvTemp)
{
    if(pvTemp->vt != (VT_ARRAY | VT_UI1))
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    SAFEARRAY * psa = pvTemp->parray;
    PSECURITY_DESCRIPTOR pSD;
    HRESULT hr = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pSD);
    if(FAILED(hr))
        return WBEM_E_INVALID_PARAMETER;
    BOOL bRet = IsValidSecurityDescriptor(pSD);
    if(bRet == FALSE)
    {
        SafeArrayUnaccessData(psa);
        return WBEM_E_INVALID_PARAMETER;
    }


    PSID pSid = 0;
    BOOL bDefaulted;
    BOOL bRes = GetSecurityDescriptorOwner(pSD, &pSid, &bDefaulted);
    if (!bRes || !IsValidSid(pSid))
    {
        SafeArrayUnaccessData(psa);
        return WBEM_E_INVALID_PARAMETER;
    }

    pSid = 0;
    bRes = GetSecurityDescriptorGroup(pSD, &pSid, &bDefaulted);
    if (!bRes || !IsValidSid(pSid))
    {
        SafeArrayUnaccessData(psa);
        return WBEM_E_INVALID_PARAMETER;
    }


    SafeArrayUnaccessData(psa);
    return (bRet) ? S_OK : WBEM_E_INVALID_PARAMETER;
}

//***************************************************************************
//
//  CWmiDbSession::InsertPropertyValues
//
//***************************************************************************

HRESULT CWmiDbSession::InsertPropertyValues (CSQLConnection *pConn, 
                                             IWmiDbHandle *pScope, 
                                             LPWSTR lpPath,
                                             SQL_ID &dObjectId,
                                             SQL_ID dClassId,
                                             SQL_ID dScopeId,
                                             DWORD dwFlags,
                                             CWbemClassObjectProps *pProps, 
                                             IWbemClassObject *pObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    BSTR strName;    
    CIMTYPE cimtype;
    long lPropFlavor = 0;
    SQL_ID dRefClassId = 0, dRefID = 0;
    CWStringArray arrObjProps;
    int iPos = 0, iQfrPos = 0;
    bool bDone = false;
    VARIANT vTemp;
    BOOL bRemoveSD = FALSE;
    CClearMe c (&vTemp);
    Properties props;
    InsertPropValues *pPropValues = NULL;
    InsertQfrValues *pQVals = NULL;

    LPWSTR lpCount = GetPropertyVal(L"__Property_Count", pObj);
    CDeleteMe <wchar_t>  r(lpCount);
    int iNumProps = 10;
    if (lpCount)
        iNumProps += _wtoi(lpCount);

    if (iNumProps)
    {
        pPropValues = new InsertPropValues[iNumProps];
        if (!pPropValues)
            return WBEM_E_OUT_OF_MEMORY;
    }
  
    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
    {
        delete pPropValues;
        return WBEM_E_SHUTTING_DOWN;
    }

    // Insert properties.
    // ==================

    ((_IWmiObject *)pObj)->BeginEnumerationEx(WBEM_FLAG_NONSYSTEM_ONLY, WMIOBJECT_BEGINENUMEX_FLAG_GETEXTPROPS);
    // ((_IWmiObject *)pObj)->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
    while (pObj->Next(0, &strName, &vTemp, &cimtype, &lPropFlavor) == S_OK)
    {
        CFreeMe f (strName);

        // Ignore security unless they are setting it explicitly.

        if (!_wcsicmp(strName, L"__SECURITY_DESCRIPTOR"))
        {
            if (!(dwFlags & WBEM_FLAG_USE_SECURITY_DESCRIPTOR))
            {
                VariantClear(&vTemp);        
                continue;
            }
            else
            {
                if (vTemp.vt == VT_NULL)
                    bRemoveSD = TRUE;                    
            }
        }

        // Skip embedded objects and arrays 
        // until we have an ObjectId...
        // ===================================

        IWbemQualifierSet *pQS = NULL;
        hr = pObj->GetPropertyQualifierSet(strName, &pQS);
        if (SUCCEEDED(hr))
        {
            CReleaseMe r (pQS);
            if ((GetQualifierFlag(L"not_null", pQS) != 0) && (vTemp.vt == VT_NULL))
            {
                hr = WBEM_E_ILLEGAL_NULL;
                VariantClear(&vTemp);        
                break;
            }
        }

        if ((cimtype == CIM_OBJECT && vTemp.vt == VT_UNKNOWN) || ((cimtype & CIM_FLAG_ARRAY) && (vTemp.vt & CIM_FLAG_ARRAY)))
            arrObjProps.Add(strName);
        else
        {
            DWORD dPropID, dwFlags2, dwType;
            SQL_ID dNewClassID = dClassId;
            hr = GetSchemaCache()->GetPropertyID(strName, dClassId, 0, cimtype, 
                    dPropID, &dNewClassID, &dwFlags2, &dwType);

            if (SUCCEEDED(hr))
            {
                LPWSTR lpVal = GetStr(vTemp);
                CDeleteMe <wchar_t>  r(lpVal);

                pPropValues[iPos].iPropID = dPropID;
                pPropValues[iPos].pValue = NULL;
                pPropValues[iPos].pRefKey = NULL;
                pPropValues[iPos].bLong = false;
                pPropValues[iPos].iFlavor = 0;
                pPropValues[iPos].iQfrID = 0;
                pPropValues[iPos].dClassId = dNewClassID;
                pPropValues[iPos].iStorageType = dwType;
                pPropValues[iPos].bIndexed = (dwFlags2 & (REPDRVR_FLAG_INDEXED + REPDRVR_FLAG_KEY)) ? TRUE : FALSE;                

                if (cimtype == CIM_REFERENCE)
                {
                    // If no scope, don't bother trying to 
                    // store this reference,
                    // since the end result will  be invalid.
                    // ======================================

                    if (!pScope)
                    {
                        VariantClear(&vTemp);
                        continue;
                    }

                    pPropValues[iPos].bIndexed = TRUE; // References are always keys

                    LPWSTR lpTemp = NULL;
                    IWbemPath *pPath = NULL;

                    hr = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
                            IID_IWbemPath, (LPVOID *) &pPath);
                    CReleaseMe r8 (pPath);
                    if (SUCCEEDED(hr))
                    {
                        if (lpVal)
                        {
                            pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, lpVal);
                            hr = NormalizeObjectPathGet(pScope, pPath, &lpTemp, NULL, NULL, NULL, pConn);
                            CDeleteMe <wchar_t>  r1(lpTemp);
                            if (SUCCEEDED(hr)) 
                            {
                                LPWSTR lpTemp2 = NULL;
                                lpTemp2 = GetKeyString(lpTemp);
                                CDeleteMe <wchar_t>  d (lpTemp2);
                                pPropValues[iPos].pRefKey = new wchar_t [21];
                                if (pPropValues[iPos].pRefKey)
                                    swprintf(pPropValues[iPos].pRefKey, L"%I64d", CRC64::GenerateHashValue(lpTemp2));
                                else
                                    hr = WBEM_E_OUT_OF_MEMORY;
                            }
                            else
                            {
                                hr = WBEM_S_NO_ERROR;
                                // Strip off the root namespace prefix and generate the
                                // pseudo-name.  We have no way of knowing if they entered this
                                // path correctly.

                                LPWSTR lpTemp3 = StripUnresolvedName (lpVal);
                                CDeleteMe <wchar_t>  d2 (lpTemp3);

                                LPWSTR lpTemp2 = NULL;
                                lpTemp2 = GetKeyString(lpTemp3);
                                CDeleteMe <wchar_t>  d (lpTemp2);
                                pPropValues[iPos].pRefKey = new wchar_t [21];
                                if (pPropValues[iPos].pRefKey)
                                    swprintf(pPropValues[iPos].pRefKey, L"%I64d", CRC64::GenerateHashValue(lpTemp2));
                                else
                                    hr = WBEM_E_OUT_OF_MEMORY;
                            }

                            pPropValues[iPos].pValue = new wchar_t[wcslen(lpVal)+1];
                            if (pPropValues[iPos].pValue)
                                wcscpy(pPropValues[iPos].pValue,lpVal);
                            else
                                hr = WBEM_E_OUT_OF_MEMORY;
                        }
                        else
                            pPropValues[iPos].pValue = NULL;                        
                    }                    
                    else 
                    {
                        VariantClear(&vTemp);        
                        break;
                    }
                }
                else
                {
                    if (lpVal)
                    {
                        pPropValues[iPos].pValue = new wchar_t[wcslen(lpVal)+1];
                        if (pPropValues[iPos].pValue)
                            wcscpy(pPropValues[iPos].pValue,lpVal);
                        else
                            hr = WBEM_E_OUT_OF_MEMORY;
                    }
                    else
                        pPropValues[iPos].pValue = NULL;

                    pPropValues[iPos].pRefKey = NULL;                    
                }
                pPropValues[iPos].iPos = 0;
                iPos++;
            }
            else                
            {
                VariantClear(&vTemp);        
                break;
            }
        }
        VariantClear(&vTemp);        
    }

    LPWSTR lpObjectKey = pProps->lpKeyString;
    if (!wcslen(lpObjectKey))
    {
        ERRORTRACE((LOG_WBEMCORE, "Invalid object path in CWmiDbSession::InsertPropertyValues (%S) \n", lpPath));

        delete pProps->lpKeyString;
        lpObjectKey = new wchar_t [wcslen(lpPath)+1];
        if (lpObjectKey)
            wcscpy(lpObjectKey, lpPath);        
        else
            hr = WBEM_E_OUT_OF_MEMORY;
        pProps->lpKeyString = lpObjectKey;
    }

    if (SUCCEEDED(hr))
    {
        BOOL bCheck=FALSE;
        CSQLExecProcedure::NeedsToCheckKeyMigration(bCheck);
        if (bCheck)
        {
            SQL_ID *pIDs= NULL;
            int iNumIDs = 0;
            hr = GetSchemaCache()->GetHierarchy(dClassId, &pIDs, iNumIDs);
            if (SUCCEEDED(hr))
            {                
                hr = CSQLExecProcedure::CheckKeyMigration(pConn, lpObjectKey, pProps->lpClassName,
                    dClassId, dScopeId, pIDs, iNumIDs);
                delete pIDs;
            }
        }
    }

    if (SUCCEEDED(hr))
        hr = CSQLExecProcedure::InsertPropertyBatch (pConn, lpObjectKey, lpPath, pProps->lpClassName, dClassId, 
                                            dScopeId, dwFlags, pPropValues, iPos, 
                                            dObjectId);
    delete pPropValues;

    // If there's no scope, quit now.  
    // This can only happen if we are only updating
    // the security descriptor.
    // ============================================

    if (!pScope)
        return hr;

    // Insert qualifiers next.
    // ======================

    if (SUCCEEDED(hr))
    {
        iQfrPos = 0; 
        iNumProps *=2 + 10 + arrObjProps.Size(); // How do we calculate how many qualifiers there will be??

        pQVals = new InsertQfrValues[iNumProps];
        if (!pQVals)
            return WBEM_E_OUT_OF_MEMORY;

        VariantClear(&vTemp);

        // PROPERTY QUALIFIERS
        pObj->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
        while (pObj->Next(0, &strName, &vTemp, &cimtype, &lPropFlavor) == S_OK)
        {
            CFreeMe f (strName);
            IWbemQualifierSet *pQS = NULL;
            hr = pObj->GetPropertyQualifierSet(strName, &pQS);
            if (hr == WBEM_S_NO_ERROR)
            {
                CReleaseMe r (pQS);
                DWORD dwRefID = 0;
                hr = GetSchemaCache()->GetPropertyID(strName, dClassId, 0, cimtype, dwRefID);
                if (SUCCEEDED(hr))
                    hr = FormatBatchInsQfrs(pConn, pScope, dObjectId, dClassId, dwRefID, pQS, iQfrPos, &pQVals, props, iNumProps);
            }                   
            VariantClear(&vTemp);
        }

        // Instance qualifiers
        if (SUCCEEDED(hr))
        {
            IWbemQualifierSet *pQS = NULL;
            hr = pObj->GetQualifierSet(&pQS);
            CReleaseMe r (pQS);
            if (SUCCEEDED(hr))
                hr = FormatBatchInsQfrs(pConn, pScope, dObjectId, dClassId, 0, pQS, iQfrPos, &pQVals, props, iNumProps);

            if (SUCCEEDED(hr))
            {
                bool bToUpdate = false;

                // Insert arrays and embedded objects last...   
                for (int i = 0; i < arrObjProps.Size(); i++)
                {

                    VARIANT vTemp;
                    VariantInit(&vTemp);
                    CIMTYPE cimtype;

                    // OPTIMIZATION: Retrieve the buffer and write it directly,
                    // for all byte arrays.

                    if (!_wcsicmp(arrObjProps.GetAt(i), L"__SECURITY_DESCRIPTOR"))
                    {
                        BYTE *pBuff = NULL;
                        long handle;

                        hr = ((_IWmiObject *)pObj)->GetPropertyHandleEx(arrObjProps.GetAt(i), 0, NULL, &handle);
                        if (SUCCEEDED(hr))
                        {
                            ULONG uSize = 0;
                            hr = ((_IWmiObject *)pObj)->GetArrayPropAddrByHandle(handle, 0, &uSize, (LPVOID *)&pBuff);

                            if (SUCCEEDED(hr))
                            {
                                // Set this in the database

                                long why[1];                        
                                unsigned char t;
                                SAFEARRAYBOUND aBounds[1];
                                aBounds[0].cElements = uSize; 
                                aBounds[0].lLbound = 0;
                                SAFEARRAY* pArray = SafeArrayCreate(VT_UI1, 1, aBounds);                            
                                vTemp.vt = VT_I1;
                                for (int i = 0; i < uSize; i++)
                                {            
                                    why[0] = i;
                                    t = pBuff[i];
                                    hr = SafeArrayPutElement(pArray, why, &t);                            
                                }
                                vTemp.vt = VT_ARRAY|VT_UI1;
                                V_ARRAY(&vTemp) = pArray;
                                cimtype = CIM_UINT8 + CIM_FLAG_ARRAY;
                            }
                        }
                    }
                    else
                        pObj->Get(arrObjProps.GetAt(i), 0, &vTemp, &cimtype, NULL);

                    if (cimtype == CIM_OBJECT)
                    {
                        bToUpdate = true;
                        IUnknown *pTemp = NULL;
                        pTemp = V_UNKNOWN(&vTemp);
                        if (pTemp)
                        {                            
                            DWORD dPropID;
                            SQL_ID dNewClassID = dClassId;
                            hr = GetSchemaCache()->GetPropertyID(arrObjProps.GetAt(i), dClassId, 
                                            0, CIM_OBJECT, dPropID, &dNewClassID);
                            if (SUCCEEDED(hr))
                                hr = InsertArray(pConn, pScope, dObjectId, dClassId, dPropID, vTemp, 0, 0, lpObjectKey, lpPath, dScopeId, cimtype);
                            else
                                break;
                        }
                        VariantClear(&vTemp);
                    }
                    else // Its an array, a blob, or a very long string.
                    {
                        DWORD dPropID;
                        SQL_ID dNewClassID = dClassId;
                        hr = GetSchemaCache()->GetPropertyID(arrObjProps.GetAt(i), 
                            dClassId, 0, cimtype, dPropID, &dNewClassID);
                        if (SUCCEEDED(hr))
                        {
                            if (!_wcsicmp(arrObjProps.GetAt(i), L"__SECURITY_DESCRIPTOR"))
                            {
                                hr = TestSD(&vTemp);
                                if(FAILED(hr))
                                {
                                    VariantClear( &vTemp );
                                    break;
                                }
                            }
                            hr = InsertArray(pConn, pScope, dObjectId, dClassId, dPropID, vTemp, 0, 0, lpObjectKey, lpPath, dScopeId, cimtype);
                            if (SUCCEEDED(hr) && !_wcsicmp(arrObjProps.GetAt(i), L"__SECURITY_DESCRIPTOR"))
                            {
                                ((CWmiDbController *)m_pController)->AddSecurityDescriptor(dObjectId);

                                // Is this an instance of __ThisNamespace?  We need to copy this SD to the current scope object

                                if (dClassId == THISNAMESPACEID)
                                {
                                    hr = InsertArray(pConn, pScope, dScopeId, NAMESPACECLASSID, dPropID, vTemp, 0, 0, NULL, NULL, 0, cimtype);
                                    if (SUCCEEDED(hr))
                                        ((CWmiDbController *)m_pController)->AddSecurityDescriptor(dScopeId);
                                }

                            }
                        }
                        VariantClear( &vTemp );
                    }                    

                    if (FAILED(hr))
                        break;
                }

                if (SUCCEEDED(hr) && iQfrPos)
                    hr = CSQLExecProcedure::InsertBatch (pConn, dObjectId, dClassId, dScopeId, pQVals, iQfrPos);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if ((dClassId == NAMESPACECLASSID || GetSchemaCache()->IsDerivedClass(NAMESPACECLASSID, dClassId)))
        {
            hr = GetSchemaCache()->AddNamespace(lpPath, lpObjectKey, dObjectId, dScopeId, dClassId);
            CSQLExecProcedure::InsertScopeMap(pConn, dObjectId, lpPath, dScopeId);
        }
        if (bRemoveSD)
        {
            ((CWmiDbController *)m_pController)->RemoveSecurityDescriptor(dObjectId);
            if (dClassId == THISNAMESPACEID)
                ((CWmiDbController *)m_pController)->RemoveSecurityDescriptor(dScopeId);
        }
    }

    delete pQVals;

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::FormatBatchInsQfrs
//
//***************************************************************************

HRESULT CWmiDbSession::FormatBatchInsQfrs (CSQLConnection *pConn,IWmiDbHandle *pScope, SQL_ID dObjectId, SQL_ID dClassId,
                                           DWORD dPropID, IWbemQualifierSet *pQS, 
                                           int &iPos, InsertQfrValues **ppVals, Properties &props, int &iNumProps)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    BSTR strTemp;
    VARIANT vTemp;
    long lTemp;
    InsertQfrValues *pVals = *ppVals;

    pQS->BeginEnumeration(0);
    while (pQS->Next(0, &strTemp, &vTemp, &lTemp) == S_OK)
    {
        CFreeMe f (strTemp);
        // Don't bother with unstorable qualifiers.

        if (lTemp & (WBEM_FLAVOR_ORIGIN_SYSTEM+WBEM_FLAVOR_ORIGIN_PROPAGATED+WBEM_FLAVOR_AMENDED))
        {
            VariantClear(&vTemp);
            continue;
        }

        lTemp &= ~WBEM_FLAVOR_ORIGIN_PROPAGATED&~WBEM_FLAVOR_ORIGIN_SYSTEM&~WBEM_FLAVOR_AMENDED;

        // Each qualifier, if not found in the cache,
        // will need to be inserted...
        DWORD dQfrID =0;
        CIMTYPE ct = 0;

        switch((vTemp.vt & (0xFFF)))
        {
        case VT_BSTR:
            ct = CIM_STRING;
            break;
        case VT_R8:
        case VT_R4:
            ct = CIM_REAL64;
            break;
        case VT_BOOL:
            ct = CIM_BOOLEAN;
            break;
        default:
            ct = CIM_UINT32;
            break;
        }

        if (FAILED(GetSchemaCache()->GetPropertyID(strTemp, 1, 
            REPDRVR_FLAG_QUALIFIER, ct, dQfrID)))
        {
            hr = InsertQualifier (pConn, pScope, dObjectId,strTemp, vTemp, lTemp, 0, dPropID,props);        
            if (FAILED(hr))
            {
                VariantClear(&vTemp);
                break;
            }
        }
        
        if (FAILED(GetSchemaCache()->GetPropertyID(strTemp, 1, 
            REPDRVR_FLAG_QUALIFIER, ct, dQfrID)))
            continue;

        if (iPos == iNumProps)
        {
            pVals = ReAllocQfrValues (pVals, iNumProps, iNumProps+10);
            iNumProps += 10;

            if (!pVals)
            {
                VariantClear(&vTemp);
                return WBEM_E_OUT_OF_MEMORY;
            }
            *ppVals = pVals;
        }

        // Add this ID to the batch...

        hr = FormatBatchInsQfrValues(pConn, pScope, dObjectId, dQfrID, vTemp, lTemp,
                pVals, props, iPos, dPropID);

        VariantClear(&vTemp);

        if (FAILED(hr))
            break;
    }  
    pQS->EndEnumeration();
    
    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::FormatBatchInsQfrValues
//
//***************************************************************************

HRESULT CWmiDbSession::FormatBatchInsQfrValues(CSQLConnection *pConn,IWmiDbHandle *pScope, 
                                               SQL_ID dObjectId, DWORD dwQfrID,
                                               VARIANT &vTemp, long lFlavor, InsertQfrValues *pVals, Properties &props,
                                               int &iPos, DWORD PropID)
{
    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    HRESULT hr = WBEM_S_NO_ERROR;

    bool bArray = false;
    if (vTemp.vt & VT_ARRAY)
        bArray = true;

    if (!bArray)
    {
        LPWSTR lpVal = GetStr(vTemp);
        CDeleteMe <wchar_t>  r1 (lpVal);
        
        pVals[iPos].iPos = 0;
        pVals[iPos].iPropID = dwQfrID;

        pVals[iPos].pValue = (lpVal ? new wchar_t [wcslen(lpVal)+1] : NULL);
        pVals[iPos].pRefKey = NULL;
        pVals[iPos].bLong = false;
        if (lpVal)
            wcscpy(pVals[iPos].pValue, lpVal);
        pVals[iPos].iFlavor = lFlavor;
        pVals[iPos].iQfrID = PropID;
        pVals[iPos].dClassId = 1; // always, for qualifiers.
        pVals[iPos].bIndexed = false; // never indexed
        switch(vTemp.vt)
        {
          case VT_BSTR:           
              pVals[iPos].iStorageType = WMIDB_STORAGE_STRING;
              break;
          case VT_R4:
          case VT_R8:
              pVals[iPos].iStorageType = WMIDB_STORAGE_REAL;
              break;
          default:
              pVals[iPos].iStorageType = WMIDB_STORAGE_NUMERIC;
              break;
        }
        iPos++;
    }
    else
       hr = InsertArray(pConn, pScope, dObjectId, 0, dwQfrID, vTemp, lFlavor, PropID);

    return hr;
}          

//***************************************************************************
//
//  CWmiDbSession::DeleteObject
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CWmiDbSession::DeleteObject( 
    /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
    /* [in] */ DWORD dwFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ LPVOID pObjToPut)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    if (!pObjToPut || !pScope)
        return WBEM_E_INVALID_PARAMETER;

    if (dwFlags & ~WMIDB_DISABLE_EVENTS & ~WMIDB_FLAG_ADMIN_VERIFIED)
        return WBEM_E_INVALID_PARAMETER;

    if (riid != IID_IWbemClassObject &&
        riid != IID_IWmiDbHandle &&
        riid != IID__IWmiObject &&
        riid != IID_IWbemPath)
        return WBEM_E_NOT_SUPPORTED;

    SQL_ID dScopeId, dScopeClassId, dClassId, dObjectId;
    LPWSTR lpClass = NULL, lpNamespace = NULL;
    _IWmiObject *pObj = NULL;

    try
    {
        {
            _WMILockit lkt(GetCS());
            if (!((CWmiDbController *)m_pController)->m_bCacheInit)
            {
                hr = LoadSchemaCache();
                if (SUCCEEDED(hr))
                    ((CWmiDbController *)m_pController)->m_bCacheInit = TRUE;
                else
                    return hr;
            }
        }

        // If this is the __Instances container
        // reject this operation..    

        if (GetSchemaCache()->IsDerivedClass
                    (INSTANCESCLASSID, ((CWmiDbHandle *)pScope)->m_dClassId) ||
                        ((CWmiDbHandle *)pScope)->m_dClassId == INSTANCESCLASSID)
            return WBEM_E_INVALID_OPERATION;

        // We only really support IWmiDbHandles and IWbemPaths

        CSQLConnection *pConn = NULL;

        if (SUCCEEDED(hr))
        {
            AddRef_Lock();

            IWmiDbHandle *pHandle = NULL;
            IWbemPath *pPath = 0;
            if (riid == IID_IWmiDbHandle)
            {
                pHandle = (IWmiDbHandle *)pObjToPut;
                if (pHandle)
                {
                    dScopeId = ((CWmiDbHandle *)pScope)->m_dObjectId;
                    dScopeClassId = ((CWmiDbHandle *)pScope)->m_dClassId;
                    dClassId = ((CWmiDbHandle *)pHandle)->m_dClassId;
                    dObjectId = ((CWmiDbHandle *)pHandle)->m_dObjectId;

                    if (!(dwFlags & WMIDB_FLAG_ADMIN_VERIFIED))
                        hr = VerifyObjectSecurity(NULL, dObjectId, dClassId, dScopeId, dScopeClassId, 
                        GetSchemaCache()->GetWriteToken(dObjectId, dClassId));
                    if (SUCCEEDED(hr))
                    {
                        hr = GetSQLCache()->GetConnection(&pConn, TRUE, IsDistributed());
                        if (SUCCEEDED(hr))
                        {        
                            if(!(dwFlags & WMIDB_DISABLE_EVENTS))
                                hr = IssueDeletionEvents(pConn, dObjectId, dClassId, dScopeId, NULL);

                            if (!((CWmiDbHandle *)pHandle)->m_bDefault)
                                hr = CustomDelete(pConn, pScope, pHandle);

                            hr = Delete(pHandle, pConn);
                            GetSQLCache()->ReleaseConnection(pConn, hr, IsDistributed());
                        }
                    }
                }
            }
            else if (riid == IID_IWbemPath)
            {
                pPath = (IWbemPath *)pObjToPut;
                if (pPath)
                {            
                    hr = GetObject(pScope, pPath, dwFlags, WMIDB_HANDLE_TYPE_COOKIE|WMIDB_HANDLE_TYPE_EXCLUSIVE, &pHandle);
                    CReleaseMe r2 (pHandle);
                    if (SUCCEEDED(hr))
                    {
                        dScopeId = ((CWmiDbHandle *)pScope)->m_dObjectId;
                        dScopeClassId = ((CWmiDbHandle *)pScope)->m_dClassId;
                        dClassId = ((CWmiDbHandle *)pHandle)->m_dClassId;
                        dObjectId = ((CWmiDbHandle *)pHandle)->m_dObjectId;

                        if (!(dwFlags & WMIDB_FLAG_ADMIN_VERIFIED))
                            hr = VerifyObjectSecurity(NULL, dObjectId, dClassId, dScopeId, dScopeClassId, 
                                GetSchemaCache()->GetWriteToken(dObjectId, dClassId));
                        if (SUCCEEDED(hr))
                        {
                            hr = GetSQLCache()->GetConnection(&pConn, TRUE, IsDistributed());
                            if (SUCCEEDED(hr))
                            {        
                                if(!(dwFlags & WMIDB_DISABLE_EVENTS))
                                    hr = IssueDeletionEvents(pConn, dObjectId, dClassId, dScopeId, NULL);

                                if (!((CWmiDbHandle *)pHandle)->m_bDefault)
                                    hr = CustomDelete(pConn, pScope, pHandle);

                                hr = Delete(pHandle, pConn);
                                GetSQLCache()->ReleaseConnection(pConn, hr, IsDistributed());
                            }
                        }
                    }
                }
            }
            else if (riid == IID_IWbemClassObject ||
                     riid == IID__IWmiObject)
            {
                pObj = (_IWmiObject *)pObjToPut;
                if (pObj)
                {
                    lpClass = GetPropertyVal(L"__Class", pObj);
                    LPWSTR lpPath = GetPropertyVal(L"__RelPath", pObj);
                    if (lpPath)
                    {                       
                        hr = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
                                IID_IWbemPath, (LPVOID *) &pPath);
                        CReleaseMe r2 (pPath);
                        if (SUCCEEDED(hr))
                        {
                            pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, lpPath);
                            hr = GetObject(pScope, pPath, dwFlags, WMIDB_HANDLE_TYPE_COOKIE|WMIDB_HANDLE_TYPE_EXCLUSIVE, &pHandle);
                            CReleaseMe r3 (pHandle);
                            if (SUCCEEDED(hr))
                            {                               
                                dScopeId = ((CWmiDbHandle *)pScope)->m_dObjectId;
                                dScopeClassId = ((CWmiDbHandle *)pScope)->m_dClassId;
                                dClassId = ((CWmiDbHandle *)pHandle)->m_dClassId;
                                dObjectId = ((CWmiDbHandle *)pHandle)->m_dObjectId;

                                if (!(dwFlags & WMIDB_FLAG_ADMIN_VERIFIED))
                                    hr = VerifyObjectSecurity(NULL, dObjectId, dClassId, dScopeId, dScopeClassId, 
                                    GetSchemaCache()->GetWriteToken(dObjectId, dClassId));
                                if (SUCCEEDED(hr))
                                {
                                    hr = GetSQLCache()->GetConnection(&pConn, TRUE, IsDistributed());
                                    if (SUCCEEDED(hr))
                                    {        
                                        if(!(dwFlags & WMIDB_DISABLE_EVENTS))
                                            hr = IssueDeletionEvents(pConn, dObjectId, dClassId, dScopeId, (IWbemClassObject *)pObj);

                                        if (!((CWmiDbHandle *)pHandle)->m_bDefault)
                                            hr = CustomDelete(pConn, pScope, pHandle);

                                        hr = Delete(pHandle, pConn);
                                        GetSQLCache()->ReleaseConnection(pConn, hr, IsDistributed());
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else
                hr = WBEM_E_NOT_SUPPORTED;
                       

            if (!IsDistributed() && !(dwFlags & WMIDB_DISABLE_EVENTS) )
            {
                if (SUCCEEDED(hr))
                    ((CWmiDbController *)m_pController)->ESSMgr.CommitAll(m_sGUID, m_sNamespacePath);
            }            
            UnlockDynasties();
        }
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbSession::DeleteObject\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hr;

}

//***************************************************************************
//
//  CWmiDbSession::IssueDeletionEvents
//
//***************************************************************************

HRESULT CWmiDbSession::IssueDeletionEvents (CSQLConnection *pConn, SQL_ID dObjectId, 
                                            SQL_ID dClassId, SQL_ID dScopeId, IWbemClassObject *_pObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (((CWmiDbController *)m_pController)->m_bESSEnabled)
    {     
        if (_pObj)
            _pObj->AddRef();

        // The rules:
        // Instance: we don't issue a deletion event for any subobjects, period.
        // Class: issue delete events for all subclasses, not instances                

        DWORD dwGenus = 1;
        if (dClassId != 1)
            dwGenus = 2;

        IWbemClassObject *pObj = _pObj;

        if (!pObj)
        {
            // Get the object.
            if (FAILED(GetObjectCache()->GetObject(dObjectId, &pObj, NULL)))
            {
                DWORD dwTemp;
                hr = GetObjectData(pConn, dObjectId, dClassId, dScopeId, 
                            WMIDB_HANDLE_TYPE_EXCLUSIVE, dwTemp, &pObj, FALSE, NULL);                        
            }
        }

        CReleaseMe r (pObj);

        // FIXME: Need to handle custom repdrvr deletion events!

        if (!pObj)
            return WBEM_S_NO_ERROR;

        // Get the namespace.

        _bstr_t sNamespace, sClass;

        GetSchemaCache()->GetNamespaceName(dScopeId, &sNamespace);
        if (!_wcsicmp(sNamespace, L"root"))
            sNamespace = L"";

        _bstr_t sPath;
        SQL_ID dTemp1, dTemp2;
        DWORD dwTemp;

        if (dwGenus == 1)
            GetSchemaCache()->GetClassInfo (dObjectId, sPath, dTemp1, dTemp2, dwTemp, &sClass);
        else
            GetSchemaCache()->GetClassInfo (dClassId, sPath, dTemp1, dTemp2, dwTemp, &sClass);

        ((CWmiDbController *)m_pController)->ESSMgr.AddDeleteRecord(pConn, m_sGUID, sNamespace, sClass, dwGenus, pObj);

        // If this is a class, enumerate
        // subclasses and issue deletion events

        if (dwGenus == 1)
        {
            SQL_ID *pIDs = NULL;
            int iNumDerived = 0;
            hr = GetSchemaCache()->GetDerivedClassList(dObjectId, &pIDs, iNumDerived);
            if (SUCCEEDED(hr))
            {
                for (int i = 0; i < iNumDerived; i++)
                {
                    IWbemClassObject *pOldObj = NULL;
                    hr = GetClassObject(pConn, pIDs[i], &pOldObj);
                    CReleaseMe r (pOldObj);
                    if (SUCCEEDED(hr))
                    {
                        LPWSTR lpClassName = GetPropertyVal(L"__Class", pOldObj);
                        CDeleteMe <wchar_t>  d2 (lpClassName);
                        ((CWmiDbController *)m_pController)->ESSMgr.AddDeleteRecord(pConn, m_sGUID, 
                                        sNamespace, sClass, dwGenus, pOldObj);
                    }
                }
                delete pIDs;
            }

            if (GetSchemaCache()->IsDerivedClass(dObjectId, NAMESPACECLASSID))
            {
                // If this is a class derived from __Namespace, 
                // we have to enumerate the INSTANCES and issue events for them
                // ============================================================


                
            }
        }

    }
    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::RenameObject
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbSession::RenameObject( 
    /* [in] */ IWbemPath __RPC_FAR *pOldPath,
    /* [in] */ IWbemPath __RPC_FAR *pNewPath,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwRequestedHandleType,
    /* [out] */ IWmiDbHandle __RPC_FAR *__RPC_FAR *ppResult)
{   
    HRESULT hr = WBEM_S_NO_ERROR;
    IWmiDbHandle *pRet = NULL;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    if (!pOldPath || !pNewPath)
        return WBEM_E_INVALID_PARAMETER;

    // This has to handle moving an object from one scope or namespace
    // to another, as well as renaming the keys.
    // Moving from one container to another does not work.

    try
    {
        ULONGLONG uIsInstance1 = 0, uIsInstance2 = 0;

        hr = pOldPath->GetInfo(0, &uIsInstance1);
        hr = pNewPath->GetInfo(0, &uIsInstance2);

        if (!(uIsInstance1 & WBEMPATH_INFO_IS_INST_REF) || !(uIsInstance2 & WBEMPATH_INFO_IS_INST_REF))
            hr = WBEM_E_INVALID_OPERATION;
        else
        {
            DWORD dwLen = 512;
            wchar_t wClass1 [512], wClass2[512];

            hr = pOldPath->GetClassName(&dwLen, wClass1);
            hr = pNewPath->GetClassName(&dwLen, wClass2);

            if (wcscmp(wClass1, wClass2))
                hr = WBEM_E_INVALID_OPERATION;
            else
            {
                IWmiDbHandle *pOld = NULL;
                IWmiDbHandle *pNewScope = NULL;

                LPWSTR lpOldPath, lpOldKey, lpNewPath, lpNewKey;
                hr = NormalizeObjectPathGet(NULL, pOldPath, &lpOldPath);
                if (FAILED(hr))
                    goto Exit;
                CDeleteMe <wchar_t>  d10(lpOldPath);

                hr = GetObject_Internal(lpOldPath, 0, WMIDB_HANDLE_TYPE_VERSIONED, NULL, &pOld);
                if (FAILED(hr))
                    goto Exit;
                CReleaseMe r (pOld);

                if (SUCCEEDED(hr))
                {
                    SQL_ID dScopeID = ((CWmiDbHandle *)pOld)->m_dScopeId;

                    _IWmiObject *pObj = NULL;
                    hr = pOld->QueryInterface(IID__IWmiObject, (void **)&pObj);
                    if (SUCCEEDED(hr))
                    {
                        CReleaseMe r6 (pObj);

                        IWbemPathKeyList *pKeys1 = NULL, *pKeys2 = NULL;
                        CWStringArray arrKeys;
                        hr = GetSchemaCache()->GetKeys(
                            dScopeID, wClass1, arrKeys);
                        if (SUCCEEDED(hr))
                        {                                   
                            hr = pOldPath->GetKeyList(&pKeys1);
                            CReleaseMe r4(pKeys1);

                            if (FAILED(hr))
                                goto Exit;
                            hr = pNewPath->GetKeyList(&pKeys2);
                            CReleaseMe r5 (pKeys2);
                            if (FAILED(hr))
                                goto Exit;

                            ULONG uOldNum = 0, uNewNum = 0;

                            hr = pKeys1->GetCount(&uOldNum);
                            if (FAILED(hr))
                                goto Exit;

                            hr = pKeys2->GetCount(&uNewNum);
                            if (FAILED(hr))
                                goto Exit;

                            if (arrKeys.Size() != uOldNum || arrKeys.Size() != uNewNum)
                            {
                                hr = WBEM_E_INVALID_OBJECT;
                                goto Exit;
                            }
                            else if (arrKeys.Size() > 0)
                            {
                                for (int i = 0; i < arrKeys.Size(); i++)
                                {
                                    ULONG uBufSize = 512;                                           
                                    ULONG ct2 = 0;
                                    BOOL bFound = FALSE;

                                    for (ULONG j = 0; j < arrKeys.Size(); j++)
                                    {
                                        VARIANT vTemp;
                                        VariantInit(&vTemp);
                                        CClearMe c (&vTemp);
                                        wchar_t wBuff[1024];
                                        ULONG uBufSize = 1024;
                                        CIMTYPE ct = 0;
                                        pObj->Get(arrKeys.GetAt(i), 0, NULL, &ct, NULL);

                                        hr = pKeys2->GetKey2(j, 0, &uBufSize, wBuff, &vTemp, &ct2);
                                        if (FAILED(hr))
                                            goto Exit;                                                   
                                        if (!wcslen(wBuff) || !wcscmp(arrKeys.GetAt(i), wBuff))
                                        {
                                            bFound = TRUE;
                                            hr = pObj->Put(arrKeys.GetAt(i), 0, &vTemp, ct);                                                    
                                            if (FAILED(hr))
                                                goto Exit;
                                            break;
                                        }
                                    }
                                    if (!bFound)
                                    {
                                        hr = WBEM_E_INVALID_PARAMETER;
                                        goto Exit;
                                    }
                                }
                            }
                            else
                                hr = WBEM_E_INVALID_OPERATION; // Cannot rename singleton
                        }                               

                        if (SUCCEEDED(hr))
                        {
                            pNewPath->DeleteClassPart(0);

                            LPWSTR lpNewScope = NULL;
                            hr = NormalizeObjectPathGet(NULL, pNewPath, &lpNewScope);
                            if (FAILED(hr))
                                goto Exit;
                            CDeleteMe <wchar_t>  d14 (lpNewScope);

                            hr = GetObject_Internal(lpNewScope, 0, WMIDB_HANDLE_TYPE_VERSIONED, NULL, &pNewScope);
                            if (FAILED(hr))
                                goto Exit;

                            if (SUCCEEDED(hr))
                            {        
                                // Create the new object

                                if (!dwRequestedHandleType)
                                    dwRequestedHandleType = WMIDB_HANDLE_TYPE_COOKIE;

                                _bstr_t sWaste;
                                IWmiDbHandle *pHandle = 0;

                                hr = PutObject( pNewScope, IID_IWbemClassObject, pObj, 0, dwRequestedHandleType, &pHandle);

                                if (SUCCEEDED(hr))
                                {
                                    // Enumerate the subscopes of the old object,

                                    IWmiDbIterator *pIt = NULL;
                                    hr = Enumerate(pOld, 0, WMIDB_HANDLE_TYPE_COOKIE, &pIt);
                                    if (SUCCEEDED(hr))
                                    {
                                        IWbemClassObject *pResult = NULL;
                                        DWORD dwNum = 0;
                                        while (pIt->NextBatch(1, 0, 0, 0, IID_IWbemClassObject, &dwNum, (void **)&pResult) == 0)
                                        {
                                            hr = PutObject( pHandle, IID_IWbemClassObject, pResult, 0, 0, NULL);
                                            pResult->Release();
                                            if (FAILED(hr))
                                                break;
                                        }
                                        pIt->Release();
                                    }                                    

                                    ((CWmiDbHandle *)pOld)->m_dwHandleType |= WMIDB_HANDLE_TYPE_CONTAINER;

                                    // Enumerate any collection members (if this was a collection).

                                    hr = Enumerate(pOld, 0, WMIDB_HANDLE_TYPE_COOKIE, &pIt);
                                    if (SUCCEEDED(hr))
                                    {
                                        IWbemClassObject *pResult = NULL;
                                        DWORD dwNum = 0;
                                        while (pIt->NextBatch(1, 0, 0, 0, IID_IWbemClassObject, &dwNum, (void **)&pResult) == 0)
                                        {
                                            hr = PutObject( pHandle, IID_IWbemClassObject, pResult, 0, 0, NULL);
                                            pResult->Release();
                                            if (FAILED(hr))
                                                break;
                                        }
                                        pIt->Release();
                                    }                                    

                                    // If all that worked, kill the old object.  This will leave
                                    // dangling references, but that's OK.

                                    if (SUCCEEDED(hr))
                                        hr = Delete (pOld);
                                }

                                if (ppResult)
                                    *ppResult = pHandle;
                                else if (pHandle)
                                    pHandle->Release();                                
                            }
                        }
                    }
                }
            }
        }
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbSession::RenameObject"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

Exit:

    return hr;
}


//***************************************************************************
//
//  CWmiDbSession::AddObject
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbSession::AddObject( 
    /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
    /* [in] */ IWbemPath __RPC_FAR *pPath,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwRequestedHandleType,
    /* [out] */ IWmiDbHandle __RPC_FAR *__RPC_FAR *ppResult)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!pScope || !pPath)
        return WBEM_E_INVALID_PARAMETER;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    if (dwRequestedHandleType & ~WMIDB_HANDLE_TYPE_COOKIE 
            &~WMIDB_HANDLE_TYPE_VERSIONED &~WMIDB_HANDLE_TYPE_PROTECTED
            &~WMIDB_HANDLE_TYPE_EXCLUSIVE &~ WMIDB_HANDLE_TYPE_WEAK_CACHE
            &~WMIDB_HANDLE_TYPE_STRONG_CACHE &~ WMIDB_HANDLE_TYPE_NO_CACHE
            &~WMIDB_HANDLE_TYPE_SUBSCOPED&~WMIDB_HANDLE_TYPE_CONTAINER&~ WMIDB_HANDLE_TYPE_SCOPE)
            return WBEM_E_INVALID_PARAMETER;

    try 
    {
        {
            _WMILockit lkt(GetCS());
            if (!((CWmiDbController *)m_pController)->m_bCacheInit)
            {
                hr = LoadSchemaCache();
                if (SUCCEEDED(hr))
                    ((CWmiDbController *)m_pController)->m_bCacheInit = TRUE;
                else
                    return hr;
            }
        }

        if (GetSchemaCache()->IsDerivedClass
                    (INSTANCESCLASSID, ((CWmiDbHandle *)pScope)->m_dClassId) ||
                        ((CWmiDbHandle *)pScope)->m_dClassId == INSTANCESCLASSID )
            return WBEM_E_INVALID_OPERATION;

        // This needs to add an object as a contained instance.
        //  * Create a new instance of __Container_Association
        //  * Call PutObject
    
        IWmiDbHandle *pContainerAssoc = NULL;

        hr = GetObject_Internal(L"__Container_Association", 0, WMIDB_HANDLE_TYPE_VERSIONED, 
            NULL, &pContainerAssoc);   
        if (SUCCEEDED(hr))
        {
            IWbemClassObject *pClassObj = NULL;
            hr = pContainerAssoc->QueryInterface(IID_IWbemClassObject, (void **)&pClassObj);
            CReleaseMe r1 (pClassObj), r2 (pContainerAssoc);
            if (SUCCEEDED(hr))
            {
                IWbemClassObject *pObj = NULL;
                pClassObj->SpawnInstance(0, &pObj);
                CReleaseMe r (pObj);

                LPWSTR lpContainer = NULL, lpContainee;
                hr = NormalizeObjectPath(pScope, (LPCWSTR)NULL, &lpContainer);
                CDeleteMe <wchar_t>  d1 (lpContainer);
                if (SUCCEEDED(hr))
                {
                    hr = NormalizeObjectPathGet(NULL, pPath, &lpContainee);               
                    CDeleteMe <wchar_t>  d2 (lpContainee);
                    if (SUCCEEDED(hr))
                    {
                        VARIANT vContainer, vContainee;
                        CClearMe c1 (&vContainer), c2 (&vContainee);
                        VariantInit(&vContainer);
                        VariantInit(&vContainee);
                        vContainer.bstrVal = SysAllocString(lpContainer);
                        vContainee.bstrVal = SysAllocString(lpContainee);
                        vContainer.vt = VT_BSTR;
                        vContainee.vt = VT_BSTR;

                        hr = pObj->Put(L"Container", 0, &vContainer, CIM_REFERENCE);
                        if (SUCCEEDED(hr))
                        {
                            hr = pObj->Put(L"Containee", 0, &vContainee, CIM_REFERENCE);
                            if (SUCCEEDED(hr))
                            {
                                // Stick this object in the 
                                // parent's scope.
                                SQL_ID dScopeId = ((CWmiDbHandle *)pScope)->m_dObjectId;

                                IWmiDbHandle *pParentScope = NULL;

                                hr = GetObject_Internal(L"..", 0, WMIDB_HANDLE_TYPE_VERSIONED, &dScopeId, &pParentScope);
                                CReleaseMe r (pParentScope);
                                if (SUCCEEDED(hr))
                                    hr = PutObject(pParentScope, IID_IWbemClassObject, pObj, dwFlags, dwRequestedHandleType, ppResult);
                            }
                        }
                    }
                }
            }
        }
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbSession::AddObject\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }
    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::RemoveObject
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbSession::RemoveObject( 
    /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
    /* [in] */ IWbemPath __RPC_FAR *pPath,
    /* [in] */ DWORD dwFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // This needs to remove an object from the container.
    //  * Retrieves the handle to the container association
    //  * Calls DeleteObject
    
    if (!pScope || !pPath)
        return WBEM_E_INVALID_PARAMETER;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;
    
    try
    {
        {
            _WMILockit lkt(GetCS());
            if (!((CWmiDbController *)m_pController)->m_bCacheInit)
            {
                hr = LoadSchemaCache();
                if (SUCCEEDED(hr))
                    ((CWmiDbController *)m_pController)->m_bCacheInit = TRUE;
                else
                    return hr;
            }
        }

        if (GetSchemaCache()->IsDerivedClass
                    (INSTANCESCLASSID, ((CWmiDbHandle *)pScope)->m_dClassId) ||
                        ((CWmiDbHandle *)pScope)->m_dClassId == INSTANCESCLASSID)
            return WBEM_E_INVALID_OPERATION;

        LPWSTR lpContainer = NULL, lpContainee;
        hr = NormalizeObjectPath(pScope, (LPCWSTR)NULL, &lpContainer);
        CDeleteMe <wchar_t>  d1 (lpContainer);
        if (SUCCEEDED(hr))
        {
            hr = NormalizeObjectPathGet(NULL, pPath, &lpContainee);
            CDeleteMe <wchar_t>  d2 (lpContainee);    

            wchar_t *pTemp = new wchar_t [wcslen(lpContainer)+wcslen(lpContainee)+50];
            if (pTemp)
            {
                CDeleteMe <wchar_t>  d (pTemp);

                swprintf(pTemp, L"__Container_Association.Container='%s',Containee='%s'",
                    lpContainer, lpContainee);

                IWbemPath *pPath = NULL;
                hr = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
                        IID_IWbemPath, (LPVOID *) &pPath);

                CReleaseMe r8 (pPath);
                if (SUCCEEDED(hr))
                {
                    hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, pTemp);

                    IWmiDbHandle *pParentScope = NULL;
                    SQL_ID dScopeId = ((CWmiDbHandle *)pScope)->m_dObjectId;

                    hr = GetObject_Internal(L"..", 0, WMIDB_HANDLE_TYPE_VERSIONED, &dScopeId, &pParentScope);
                    CReleaseMe r (pParentScope);
                    if (SUCCEEDED(hr))
                        hr = DeleteObject(pParentScope, dwFlags, IID_IWbemPath, pPath);
                }
            }
            else 
                hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbSession::RemoveObject\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::SetDecoration
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbSession::SetDecoration( 
        /* [in] */ LPWSTR lpMachineName,
        /* [in] */ LPWSTR lpNamespacePath)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    try
    {
        if (!lpMachineName || !lpNamespacePath)
            hr = WBEM_E_INVALID_PARAMETER;
        else
        {
            m_sMachineName = lpMachineName;
            m_sNamespacePath = lpNamespacePath;
        }
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbSession::SetDecoration\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::PutObjects
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CWmiDbSession::PutObjects( 
    /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwHandleType,
    /* [in] */ WMIOBJECT_BATCH __RPC_FAR *pBatch)

{
    HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hrRet=0;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    if (dwHandleType == WMIDB_HANDLE_TYPE_INVALID || !pBatch ||!pScope)
        return WBEM_E_INVALID_PARAMETER;

    if (dwFlags &~WMIDB_FLAG_BEST_EFFORT &~WMIDB_FLAG_ATOMIC 
        & ~WBEM_FLAG_CREATE_ONLY & ~WBEM_FLAG_UPDATE_ONLY & ~WBEM_FLAG_CREATE_OR_UPDATE 
        & ~WBEM_FLAG_USE_SECURITY_DESCRIPTOR &~ WBEM_FLAG_REMOVE_CHILD_SECURITY)
        return WBEM_E_INVALID_PARAMETER;

    try
    {
        CSQLConnection *pConn = NULL;

        hr = GetSQLCache()->GetConnection(&pConn, TRUE, IsDistributed());
        if (SUCCEEDED(hr))
        {
            AddRef_Lock();

            for (int i = 0; i < pBatch->dwArraySize; i++)
            {
                IUnknown *pUnk = (IUnknown *)pBatch->pElements[i].pHandle;
                if (pUnk)
                {
                    IWmiDbHandle *pTemp = NULL;
                    _bstr_t sWaste;
                    hr = PutObject(pConn, pScope, 0, L"", pUnk, dwFlags&~WMIDB_FLAG_BEST_EFFORT&~WMIDB_FLAG_ATOMIC, dwHandleType, sWaste, &pTemp);
                    if (SUCCEEDED(hr))
                        pBatch->pElements[i].pReturnHandle = pTemp;
                    pBatch->pElements[i].hRes = hr;                    
                }
                else
                {
                    pBatch->pElements[i].hRes = WBEM_E_INVALID_PARAMETER;
                    hr = WBEM_E_INVALID_PARAMETER;
                }
            
                if (FAILED(hr) && (dwFlags == WMIDB_FLAG_ATOMIC)) // If one fails, keep going.
                {
                    hrRet = hr;
                    break;
                }
                else if (FAILED(hr))
                    hrRet = WBEM_S_PARTIAL_RESULTS;

            }

            if (FAILED(hr) && !(dwFlags & WMIDB_FLAG_ATOMIC))
                hr = WBEM_S_NO_ERROR;

            GetSQLCache()->ReleaseConnection(pConn, hr, IsDistributed());

            if (!IsDistributed() && !(dwFlags & WMIDB_DISABLE_EVENTS) )
            {
                if (SUCCEEDED(hr))
                    ((CWmiDbController *)m_pController)->ESSMgr.CommitAll(m_sGUID, m_sNamespacePath);
            }            
            UnlockDynasties();   
        }
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbSession::PutObjects\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hrRet;

}

//***************************************************************************
//
//  CWmiDbSession::GetObjects
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CWmiDbSession::GetObjects( 
    /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwHandleType,
    /* [in, out] */ WMIOBJECT_BATCH __RPC_FAR *pBatch)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hrRet = 0;

    // This is really just a query, except that we need
    // to set return values in the struct.

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;
    
    if (dwHandleType == WMIDB_HANDLE_TYPE_INVALID || !pBatch ||!pScope)
        return WBEM_E_INVALID_PARAMETER;

    if (dwHandleType & ~WMIDB_HANDLE_TYPE_COOKIE 
            &~WMIDB_HANDLE_TYPE_VERSIONED &~WMIDB_HANDLE_TYPE_PROTECTED
            &~WMIDB_HANDLE_TYPE_EXCLUSIVE &~ WMIDB_HANDLE_TYPE_WEAK_CACHE
            &~WMIDB_HANDLE_TYPE_STRONG_CACHE &~ WMIDB_HANDLE_TYPE_NO_CACHE
            &~WMIDB_HANDLE_TYPE_SUBSCOPED &~WMIDB_HANDLE_TYPE_SCOPE 
            &~WMIDB_HANDLE_TYPE_CONTAINER)
            return WBEM_E_INVALID_PARAMETER;

    if (dwFlags &~WMIDB_FLAG_BEST_EFFORT &~WMIDB_FLAG_ATOMIC & ~WBEM_FLAG_USE_SECURITY_DESCRIPTOR)
        return WBEM_E_INVALID_PARAMETER;

    try
    {
        AddRef_Lock();

        if (SUCCEEDED(hr))
        {
            for (int i = 0; i < pBatch->dwArraySize; i++)
            {
                IWbemPath *pPath = pBatch->pElements[i].pPath;
                IWmiDbHandle *pTemp = NULL;

                hr = GetObject(pScope, pPath, pBatch->pElements[i].dwFlags, dwHandleType, &pTemp);
                if (SUCCEEDED(hr))
                {
                    pBatch->pElements[i].pReturnHandle = pTemp;
                    pBatch->pElements[i].hRes = hr;
                    pBatch->pElements[i].dwFlags = dwFlags;
                }

                if (FAILED(hr) && (dwFlags == WMIDB_FLAG_ATOMIC)) // If one fails, keep going.
                {
                    hrRet = hr;
                    break;
                }
                else if (FAILED(hr))
                    hrRet = WBEM_S_PARTIAL_RESULTS;
            }
        }
        UnlockDynasties();
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbSession::GetObjects\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hrRet;

}

//***************************************************************************
//
//  CWmiDbSession::DeleteObjects
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CWmiDbSession::DeleteObjects( 
    /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
    /* [in] */ DWORD dwFlags,
    /* [in] */ WMIOBJECT_BATCH __RPC_FAR *pBatch)

{
    HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hrRet = 0;

    if (!pBatch || !pScope)
        return WBEM_E_INVALID_PARAMETER;

    if (dwFlags &~WMIDB_FLAG_BEST_EFFORT &~WMIDB_FLAG_ATOMIC &~ WMIDB_FLAG_ADMIN_VERIFIED)
        return WBEM_E_INVALID_PARAMETER;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    try
    {
        {
            _WMILockit lkt(GetCS());
            if (!((CWmiDbController *)m_pController)->m_bCacheInit)
            {
                hr = LoadSchemaCache();
                if (SUCCEEDED(hr))
                    ((CWmiDbController *)m_pController)->m_bCacheInit = TRUE;
                else
                    return hr;
            }
        }
        CSQLConnection *pConn = NULL;

        SQL_ID dScopeId, dClassId, dObjectId;
        hr = GetSQLCache()->GetConnection(&pConn, TRUE, IsDistributed());
        if (SUCCEEDED(hr))
        {        
            AddRef_Lock();

            for (int i = 0; i < pBatch->dwArraySize; i++)
            {
                IUnknown *pUnk = (IUnknown *)pBatch->pElements[i].pHandle;
        
                if (pUnk)
                {             
                    IWmiDbHandle *pHandle = NULL;
                    if (SUCCEEDED(pUnk->QueryInterface(IID_IWmiDbHandle, (void **)&pHandle)))
                    {
                        CReleaseMe r (pHandle);
                        dScopeId = ((CWmiDbHandle *)pScope)->m_dObjectId;
                        dClassId = ((CWmiDbHandle *)pHandle)->m_dClassId;
                        dObjectId = ((CWmiDbHandle *)pHandle)->m_dObjectId;
						SQL_ID dScopeClassId = ((CWmiDbHandle *)pScope)->m_dClassId;

                        if (!(dwFlags & WMIDB_FLAG_ADMIN_VERIFIED))
                            hr = VerifyObjectSecurity(NULL, dObjectId, dClassId, dScopeId, dScopeClassId, 
                            GetSchemaCache()->GetWriteToken(dObjectId, dClassId));
                        if (SUCCEEDED(hr))
                        {
                            if (!((CWmiDbHandle *)pHandle)->m_bDefault)
                                hr = CustomDelete(pConn, pScope, pHandle);

                            hr = Delete(pHandle, pConn);
                        }
                    }
                    else
                        pBatch->pElements[i].hRes = WBEM_E_INVALID_PARAMETER;
                }
                else if (pBatch->pElements[i].pPath)
                {            
                    // Problem: We need the binary object path to include the scope!!!

                    IWbemPath *pPath = pBatch->pElements[i].pPath;
                    if (pPath)
                    {
                        IWmiDbHandle *pHandle = NULL;
                        hr = GetObject(pScope, pPath, dwFlags, WMIDB_HANDLE_TYPE_COOKIE|WMIDB_HANDLE_TYPE_EXCLUSIVE, &pHandle);
                        CReleaseMe r (pHandle);
                        if (SUCCEEDED(hr))
                        {
                            dScopeId = ((CWmiDbHandle *)pScope)->m_dObjectId;
                            dClassId = ((CWmiDbHandle *)pHandle)->m_dClassId;
                            dObjectId = ((CWmiDbHandle *)pHandle)->m_dObjectId;
                            SQL_ID dScopeClassId = ((CWmiDbHandle *)pScope)->m_dClassId;

                            if (!(dwFlags & WMIDB_FLAG_ADMIN_VERIFIED))
                                hr = VerifyObjectSecurity(NULL, dObjectId, dClassId, dScopeId, dScopeClassId, 
                                GetSchemaCache()->GetWriteToken(dObjectId, dClassId));
                            if (SUCCEEDED(hr))
                            {
                                if (!((CWmiDbHandle *)pHandle)->m_bDefault)
                                    hr = CustomDelete(pConn, pScope, pHandle);

                                hr = Delete(pHandle, pConn);
                            }
                        }
                    }
                }
                else
                    pBatch->pElements[i].hRes = WBEM_E_INVALID_PARAMETER;

                pBatch->pElements[i].hRes = hr;
                if (FAILED(hr) && (dwFlags == WMIDB_FLAG_ATOMIC)) // If one fails, keep going.
                {
                    hrRet = hr;
                    break;
                }
                else if (FAILED(hr))
                    hrRet = WBEM_S_PARTIAL_RESULTS;
            }

            GetSQLCache()->ReleaseConnection(pConn, hr, IsDistributed());

            if (!IsDistributed() && !(dwFlags & WMIDB_DISABLE_EVENTS) )
            {
                if (SUCCEEDED(hr))
                    ((CWmiDbController *)m_pController)->ESSMgr.CommitAll(m_sGUID, m_sNamespacePath);
            }
            UnlockDynasties();
        }
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbSession::DeleteObjects\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hrRet;

}

//***************************************************************************
//
//  CWmiDbSession::Begin
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbSession::Begin( 
    /* [in] */ ULONG uTimeout,
    /* [in] */ ULONG uFlags,
    /* [in] */ GUID __RPC_FAR *pTransGUID)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // There can't be an existing transaction.
    if (m_sGUID.length() > 0)
        return WBEM_E_INVALID_OPERATION;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    // Get or Create a __Transaction instance for this GUID
    // Transaction state = Pending
    // ================================================

    wchar_t wGUID[128];
    StringFromGUID2(*pTransGUID, wGUID, 128);

    wchar_t wPath[255];
    swprintf(wPath, L"__Transaction.GUID=\"%s\"", (LPCWSTR)wGUID);

    IWmiDbHandle *pHandle = NULL;
    hr = GetObject_Internal(wPath, 0, WMIDB_HANDLE_TYPE_COOKIE, NULL, &pHandle);
    CReleaseMe r1 (pHandle);
    if (SUCCEEDED(hr))
    {
        _IWmiObject *pObj = NULL;
        hr = pObj->QueryInterface(IID__IWmiObject, (void **)&pObj);
        CReleaseMe r2 (pObj);
        if (SUCCEEDED(hr))
        {
            ULONG uState = 0;
            LPWSTR lpTemp = NULL;
            lpTemp = GetPropertyVal(L"State", pObj);
            CDeleteMe <wchar_t>  d (lpTemp);
            uState = _wtol(lpTemp);

            //hr = pObj->ReadProp(L"State", 0, sizeof(ULONG), NULL,
            //    NULL, NULL, NULL, &uState);           
            if (uState > WBEM_TRANSACTION_STATE_PENDING)
            {
                return WBEM_E_ALREADY_EXISTS;
            }
        }
    }
    else
    {
        // Create a new one.
        _IWmiObject *pObj = NULL;
        hr = GetObject_Internal(L"__Transaction", 0, WMIDB_HANDLE_TYPE_COOKIE,
            NULL, &pHandle);          
        CReleaseMe r2 (pHandle);
        if (SUCCEEDED(hr))
        {
            hr = pHandle->QueryInterface(IID__IWmiObject, (void **)&pObj);
            if (SUCCEEDED(hr))
            {
                CReleaseMe r3 (pObj);

                IWbemClassObject *pInst2 = NULL;
                pObj->SpawnInstance(0, &pInst2);
                CReleaseMe r (pInst2);
                if (pInst2)
                {
                    _IWmiObject *pInst = (_IWmiObject *)pInst2;

                    ULONG uTemp = WBEM_TRANSACTION_STATE_PENDING;
                    WBEMTime tNow(time(0));
                    BSTR sTime = tNow.GetDMTF(TRUE);
                    CFreeMe f (sTime);

                    pInst->WriteProp(L"GUID", 0, (wcslen(wGUID)*2)+2, 1, CIM_STRING, wGUID);
                    pInst->WriteProp(L"State", 0, sizeof(ULONG), 1, CIM_UINT32, &uTemp);

                    pInst->WriteProp(L"Start", 0, (wcslen(sTime)*2)+2, 1, CIM_DATETIME, sTime);
                    pInst->WriteProp(L"LastUpdate", 0, (wcslen(sTime)*2)+2, 1, CIM_DATETIME, sTime);

                    CSQLConnection *pConn = NULL;
                    hr = GetSQLCache()->GetConnection(&pConn, FALSE, FALSE);
                    if (SUCCEEDED(hr))
                    {                
                        _bstr_t sPath;
                        hr = PutObject(pConn, NULL, ROOTNAMESPACEID, L"", pInst, 0, NULL, sPath, NULL, FALSE);
                        GetSQLCache()->ReleaseConnection(pConn, hr);
                    }
                }
            }
        }
    }
   
    if (SUCCEEDED(hr))
    {
        m_bIsDistributed = TRUE;
        m_sGUID = wGUID;
    }

    return hr;
}
//***************************************************************************
//
//  CWmiDbSession::Rollback
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbSession::Rollback( 
    /* [in] */ ULONG uFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (m_sGUID.length() == 0)
        return WBEM_E_INVALID_OPERATION;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    // Rollback and release the transaction.
    // ======================================

    CSQLConnection *pConn = NULL;
    hr = GetSQLCache()->GetConnection(&pConn, FALSE, TRUE);
    if (SUCCEEDED(hr))
    {
        GetSQLCache()->FinalRollback(pConn);        
        GetSQLCache()->ReleaseConnection(pConn, 0, TRUE);
    }
    else
        return hr;

    AddRef_Lock();
    CleanTransLocks();

    wchar_t wPath[255];
    swprintf(wPath, L"__Transaction.GUID=\"%s\"", (LPCWSTR)m_sGUID);

    m_sGUID = L"";
    m_bIsDistributed = FALSE;

    // __Transaction state = rolled back
    // =================================

    IWmiDbHandle *pHandle = NULL;
    hr = GetObject_Internal(wPath, 0, WMIDB_HANDLE_TYPE_COOKIE, NULL, &pHandle);
    CReleaseMe r1 (pHandle);
    if (SUCCEEDED(hr))
    {
        _IWmiObject *pObj = NULL;
        hr = pHandle->QueryInterface(IID__IWmiObject, (void **)&pObj);
        CReleaseMe r2 (pObj);
        if (SUCCEEDED(hr))
        {
            hr = GetSQLCache()->GetConnection(&pConn, FALSE, FALSE);
            if (SUCCEEDED(hr))
            {                
                ULONG uState = WBEM_TRANSACTION_STATE_ROLLED_BACK;
                pObj->WriteProp(L"State", 0, sizeof(ULONG), 1, CIM_UINT32, &uState);
                _bstr_t sPath;
                hr = PutObject(pConn, NULL, ROOTNAMESPACEID, L"", pObj, 0, NULL, sPath, NULL, FALSE);
                GetSQLCache()->ReleaseConnection(pConn, hr);
            }
        }
    }
    
    // Delete all events and remove all locks.
    if (SUCCEEDED(hr))
        hr = ((CWmiDbController *)m_pController)->ESSMgr.DeleteAll(m_sGUID);

    // Remove any affected dynasties from the cache,
    // to make sure we force a reread from the db.

    UnlockDynasties(TRUE);

    return hr;
}
//***************************************************************************
//
//  CWmiDbSession::Commit
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbSession::Commit( 
    /* [in] */ ULONG uFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (m_sGUID.length() == 0)
        return WBEM_E_INVALID_OPERATION;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    // __Transaction state = EventPlayback
    // Include this as final query.
    // ===================================

    AddRef_Lock();
    wchar_t wPath[255];
    swprintf(wPath, L"__Transaction.GUID=\"%s\"", (LPCWSTR)m_sGUID);

    IWmiDbHandle *pHandle = NULL;
    hr = GetObject_Internal(wPath, 0, WMIDB_HANDLE_TYPE_COOKIE, NULL, &pHandle);    
    if (SUCCEEDED(hr))
    {
        _IWmiObject *pObj = NULL;
        hr = pHandle->QueryInterface(IID__IWmiObject, (void **)&pObj);
        CReleaseMe r2 (pObj);
        if (SUCCEEDED(hr))
        {
            CSQLConnection *pConn = NULL;
            hr = GetSQLCache()->GetConnection(&pConn, FALSE, TRUE);
            if (SUCCEEDED(hr))
            {                
                ULONG uState = WBEM_TRANSACTION_STATE_EVENT_PLAYBACK;
                pObj->WriteProp(L"State", 0, sizeof(ULONG), 1, CIM_UINT32, &uState);
                _bstr_t sPath;
                hr = PutObject(pConn, NULL, ROOTNAMESPACEID, L"", pObj, 0, NULL, sPath, NULL, FALSE);

                // Commit the transaction in the database
                // ======================================
                if (SUCCEEDED(hr))
                {
                    GetSQLCache()->FinalCommit(pConn);        
                    GetSQLCache()->ReleaseConnection(pConn, hr, TRUE);

                    // Commit our events.
                    // ==================
                    hr = ((CWmiDbController *)m_pController)->ESSMgr.CommitAll(m_sGUID, m_sNamespacePath);
                }
            }
        }
        pHandle->Release();
    }

    CleanTransLocks();

    m_sGUID = L"";
    m_bIsDistributed = FALSE;

    if (SUCCEEDED(hr))
    {
        // Transaction state = Completed

        IWmiDbHandle *pHandle2 = NULL;
        hr = GetObject_Internal(wPath, 0, WMIDB_HANDLE_TYPE_COOKIE, NULL, &pHandle2);
        CReleaseMe r3 (pHandle2);
        if (SUCCEEDED(hr))
        {
            _IWmiObject *pObj = NULL;
            hr = pHandle2->QueryInterface(IID__IWmiObject, (void **)&pObj);
            CReleaseMe r2 (pObj);
            if (SUCCEEDED(hr))
            {
                CSQLConnection *pConn = NULL;
                hr = GetSQLCache()->GetConnection(&pConn, FALSE, FALSE);
                if (SUCCEEDED(hr))
                {                
                    ULONG uState = WBEM_TRANSACTION_STATE_COMPLETED;
                    pObj->WriteProp(L"State", 0, sizeof(ULONG), 1, CIM_UINT32, &uState);
                    _bstr_t sPath;
                    hr = PutObject(pConn, NULL, ROOTNAMESPACEID, L"", pObj, 0, NULL, sPath, NULL, FALSE);
                    GetSQLCache()->ReleaseConnection(pConn, hr);
                }
            }
        } 
    }

    UnlockDynasties();

    return hr;
}
//***************************************************************************
//
//  CWmiDbSession::QueryState
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbSession::QueryState( 
    /* [in] */ ULONG uFlags,
    /* [out] */ ULONG __RPC_FAR *puState)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (m_sGUID.length() == 0)
        return WBEM_E_INVALID_OPERATION;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    // This should be stored in the root namespace.

    wchar_t wPath[255];
    swprintf(wPath, L"__Transaction.GUID=\"%s\"", (LPWSTR)m_sGUID);

    IWmiDbHandle *pHandle = NULL;
    hr = GetObject_Internal(wPath, 0, WMIDB_HANDLE_TYPE_COOKIE, NULL, &pHandle);
    CReleaseMe r1 (pHandle);
    if (SUCCEEDED(hr))
    {
        _IWmiObject *pObj = NULL;
        hr = pHandle->QueryInterface(IID__IWmiObject, (void **)&pObj);
        CReleaseMe r2 (pObj);
        if (SUCCEEDED(hr))
        {
            LPWSTR lpTemp = GetPropertyVal(L"State", pObj);
            CDeleteMe <wchar_t>  d (lpTemp);
            *puState = _wtol(lpTemp);
            //hr = pObj->ReadProp(L"State", 0, sizeof(ULONG), NULL,
            //    NULL, NULL, NULL, puState);           
        }
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::NormalizeObjectPathGet
//
//***************************************************************************

HRESULT CWmiDbSession::NormalizeObjectPathGet(IWmiDbHandle __RPC_FAR *pScope, IWbemPath __RPC_FAR *pPath,
            LPWSTR * lpNewPath, BOOL *bDefault, SQL_ID *pClassId, SQL_ID *pScopeId, CSQLConnection *pConn)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    BOOL bNs = FALSE;
    BOOL bDone = FALSE;
    LPWSTR lpTempPath = NULL;
    BOOL bDelete = TRUE;
    BOOL bIsRelative = TRUE;
    SQL_ID dScopeId = 0;
    if (pScope)
        dScopeId = ((CWmiDbHandle *)pScope)->m_dObjectId;

    // For retrieval behavior, we only want to know if
    // the object is found in the default namespace
    // or the custom repository.

    if (bDefault)
        *bDefault = TRUE;   

    if (!pPath)
        hr = WBEM_E_INVALID_PARAMETER;
    else 
    {
        ULONGLONG uIsInstance = 0;
        hr = pPath->GetInfo(0, &uIsInstance);

        wchar_t wTemp[1];
        DWORD dwLen = 1;

        if (!(uIsInstance & WBEMPATH_INFO_IS_PARENT))
        {
            pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, wTemp);  
            if (dwLen)
            {
                dwLen += 1024;
                lpTempPath = new wchar_t [dwLen];
                if (lpTempPath)
                    hr = pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, lpTempPath);
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                    goto Exit;
                }
            }
        }
        else
        {
            lpTempPath = new wchar_t [4096];
            if (!lpTempPath)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                goto Exit;
            }
        }

        // First, are we just asking to find the current parent.
        // Special case.       
        if (!(uIsInstance & WBEMPATH_INFO_IS_PARENT) && !wcslen(lpTempPath))
        {
            hr = WBEM_E_INVALID_PARAMETER;
            goto Exit;
        }

        if (SUCCEEDED(hr))
        {
            if (uIsInstance & WBEMPATH_INFO_IS_PARENT)
            {
                if (bDefault)
                    *bDefault = TRUE;
                if (lpNewPath)
                {
                    wcscpy(lpTempPath, L"..");
                    *lpNewPath = lpTempPath;
                    bDelete = FALSE;
                }
            }
            // This must be a path to an object.
            else
            {
                wchar_t wServer[128];
                ULONG uLen = 128;
                hr = pPath->GetServer(&uLen, wServer);
                if (SUCCEEDED(hr) && wcslen(wServer) > 1)       
                    bIsRelative = FALSE;

                SQL_ID dClassId = 0;
                WCHAR *pClass = new wchar_t [512];
                if (!pClass)
                    hr = WBEM_E_OUT_OF_MEMORY;
                else
                {
                    DWORD dwLen = 1024;
                    hr = pPath->GetClassName(&dwLen, pClass);
                    if (FAILED(hr))
                    {
                        delete pClass;
                        pClass = NULL;
                    }
                    CDeleteMe <wchar_t>  r0 (pClass);

                    // We have a valid path (we hope).
                    // Go through each namespace and scope
                    // until we have hit the instance or class.

                    ULONG dwNumNamespaces = 0, dwNumScopes = 0;
                    wchar_t wBuff[1024];
                    BOOL bNeedSlash = FALSE;

                    pPath->GetNamespaceCount(&dwNumNamespaces);
                    pPath->GetScopeCount(&dwNumScopes);

                    lpTempPath[0] = L'\0';

                    // Process the namespaces.

                    for (ULONG i = 0; i < dwNumNamespaces; i++)
                    {
                        dwLen = 1024;
                        hr = pPath->GetNamespaceAt(i, &dwLen, wBuff);
                        if (SUCCEEDED(hr))
                        {
                            if (bNeedSlash)
                                wcscat(lpTempPath, L"\\");
                            else
                                bNeedSlash = TRUE;
                            wcscat(lpTempPath, wBuff);

                            if (!_wcsicmp(lpTempPath, m_sNamespacePath))
                            {
                                bNeedSlash = FALSE;
                                lpTempPath[0] = L'\0';
                            }
                        }
                    }

                    if (wcslen(lpTempPath))
                    {
                        LPWSTR lpKey = GetKeyString(lpTempPath);
                        CDeleteMe <wchar_t>  r2 (lpKey);
                        if (!lpKey || !wcslen(lpKey))
                        {
                            ERRORTRACE((LOG_WBEMCORE, "Invalid scope text in CWmiDbSession::NormalizeObjectPathGet (%S) \n", lpTempPath));
                            hr = WBEM_E_INVALID_PARAMETER;
                            goto Exit;
                        }
                        hr = GetSchemaCache()->GetNamespaceID(lpKey, dScopeId);
                        if (FAILED(hr))
                            goto Exit;
                    }

                    // Process scopes. 

                    if (dwNumScopes)
                        dwNumScopes--;

                    for ( i = 0; i < dwNumScopes; i++)
                    {
                        dwLen = 1024;
                        IWbemPathKeyList *pScopeKeys = NULL;
                        hr = pPath->GetScope(i, &dwLen, wBuff, &pScopeKeys);
                        if (SUCCEEDED(hr))
                        {
                            if (bNeedSlash)
                                wcscat(lpTempPath, L":");
                            else
                                bNeedSlash = TRUE;
                            
                            LoadClassInfo(pConn, wBuff, dScopeId, TRUE);

                            LPWSTR lpTemp = GetSchemaCache()->GetKeyRoot(wBuff, dScopeId);
                            CDeleteMe <wchar_t>  d (lpTemp);
                            if (lpTemp)
                            {
                                wcscat(lpTempPath, lpTemp);
                            }
                            else
                                wcscat(lpTempPath, wBuff); // OK.. Could be a remote path

                            hr = MakeKeyListString(dScopeId, &((CWmiDbController *)m_pController)->SchemaCache,
                                wBuff, pScopeKeys, lpTempPath);
                        }
                    }

                    if (wcslen(lpTempPath))
                    {
                        LPWSTR lpKey = GetKeyString(lpTempPath);
                        CDeleteMe <wchar_t>  r2 (lpKey);
                        if (!lpKey || !wcslen(lpKey))
                        {
                            ERRORTRACE((LOG_WBEMCORE, "Invalid scope text in CWmiDbSession::NormalizeObjectPathGet (%S) \n", lpTempPath));
                            hr = WBEM_E_INVALID_PARAMETER;
                            goto Exit;
                        }

                        hr = GetSchemaCache()->GetNamespaceID(lpKey, dScopeId);
                        if (FAILED(hr))
                            goto Exit;
                    }

                    if (pClass && wcslen(pClass))
                    {
                        BOOL bDeep = (uIsInstance & WBEMPATH_INFO_IS_INST_REF);

                        // Make sure this dynasty is in the cache.

                        LoadClassInfo(pConn, pClass, dScopeId, bDeep);

                        // If this is a class or instance, process the data

                        hr = GetSchemaCache()->GetClassID (pClass, 
                                dScopeId, dClassId);
                        if (SUCCEEDED(hr) && pClass)
                        {
                            IWbemPathKeyList *pKeyList = NULL;

                            if (dClassId == INSTANCESCLASSID &&
                                (uIsInstance & WBEMPATH_INFO_IS_INST_REF))
                            {
                                if (lpNewPath)
                                {
                                    dwLen = 1024;

                                    hr = pPath->GetKeyList(&pKeyList);
                                    CReleaseMe r (pKeyList);

                                    hr = pKeyList->GetKey(0, 0, NULL, NULL, &dwLen, lpTempPath, NULL);
                                    *lpNewPath = lpTempPath;
                                    bDelete = FALSE;
                                    bDone = TRUE;
                                }
                            }
                            else
                            {

                                // If they specified a path like '__Namespace="root" '...
                                if ((!_wcsicmp(pClass, L"__Namespace") || 
                                    GetSchemaCache()->IsDerivedClass(NAMESPACECLASSID, dClassId))
                                        && (uIsInstance & WBEMPATH_INFO_IS_INST_REF))
                                {
                                    bNs = TRUE;                
                                    hr = pPath->GetKeyList(&pKeyList);
                                    CReleaseMe r (pKeyList);
                                    if (SUCCEEDED(hr))
                                    {
                                        dwLen = 1024;
                                        hr = pKeyList->GetKey(0, 0, NULL, NULL, &dwLen, lpTempPath, NULL);
                                    }
                                }
                                else
                                {
                                    if (bNeedSlash)
                                        wcscat(lpTempPath, L":");

                                    if (uIsInstance & WBEMPATH_INFO_IS_CLASS_REF)
                                        wcscat(lpTempPath, pClass);
                                    else
                                    {
                                        LPWSTR lpTemp = GetSchemaCache()->GetKeyRoot(pClass, dScopeId);
                                        CDeleteMe <wchar_t>  d (lpTemp);
                                        if (lpTemp)
                                            wcscat(lpTempPath, lpTemp);
                                        else
                                        {
                                            hr = WBEM_E_INVALID_OBJECT_PATH;
                                            goto Exit;
                                        }
                                    }

                                    if (uIsInstance & WBEMPATH_INFO_IS_CLASS_REF && wcslen(pClass) > 2 && pClass[0] == L'_' && pClass[1] == L'_')
                                    {
                                        *lpNewPath = lpTempPath;
                                        bDelete = FALSE;
                                        bDone = TRUE;
                                    }
                                    else if (uIsInstance & WBEMPATH_INFO_IS_INST_REF)
                                    {
                                        hr = pPath->GetKeyList(&pKeyList);
                                        CReleaseMe r (pKeyList);
                                        if (SUCCEEDED(hr))
                                        {
                                            hr = MakeKeyListString(dScopeId, &((CWmiDbController *)m_pController)->SchemaCache,
                                                        pClass, pKeyList, lpTempPath);
                                        }
                                        if (bDefault)
                                        {
                                            // Instances of system classes are always default
                                            // Other instances are whatever their scope is.
                                            if (wcslen(pClass) >= 2 && pClass[0] == L'_' && pClass[1] == L'_')
                                                *bDefault = TRUE;   // all system classes are default
                                            else if (pScope) // other instances inherit from the scope.
                                                *bDefault = ((CWmiDbHandle *)pScope)->m_bDefault;

                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            if (uIsInstance & WBEMPATH_INFO_IS_INST_REF)
                            {
                                IWbemPathKeyList *pKeyList = NULL;
                                hr = pPath->GetKeyList(&pKeyList);
								CReleaseMe rm1(pKeyList);
                                if (SUCCEEDED(hr))
                                {
                                    ULONG uNumKeys = 0;
                                    hr = pKeyList->GetCount(&uNumKeys);
                                    if (SUCCEEDED(hr))
                                    {
                                        if (!uNumKeys)
                                            bNs = TRUE;
                                    }
                                }
                                else
                                    bNs = TRUE;
                            }
                            else
                                bNs = TRUE;

                            if (bNs)
                            {
                                if (!wcslen(lpTempPath) && pClass)
                                    wcscpy(lpTempPath, pClass);
                            }
                            else
                                hr = WBEM_E_NOT_FOUND;
                        }
                    }
                    else
                        bNs = TRUE;

                    if (bNs)
                    {
                        // This is a namespace.
                        dClassId = NAMESPACECLASSID;
                        hr = WBEM_S_NO_ERROR;
                    }

                    if (dClassId == INSTANCESCLASSID)
                        bDone = TRUE;

                    if (SUCCEEDED(hr) && !bDone)
                    {
                        hr = NormalizeObjectPath(pScope, lpTempPath, lpNewPath, bNs, NULL, NULL, pConn, TRUE);
                        bDelete = TRUE;
                    }
                    else if (SUCCEEDED(hr))
                    {
                        *lpNewPath = lpTempPath;
                        bDelete = FALSE;
                    }
                    if (pClassId)
                        *pClassId = dClassId;
                    if (pScopeId)
                        *pScopeId = dScopeId;

                }
            }    
        }
    }

Exit:
    if (bDelete || FAILED(hr))
        delete lpTempPath;

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::NormalizeObjectPath
//
//***************************************************************************

HRESULT CWmiDbSession::NormalizeObjectPath(IWmiDbHandle __RPC_FAR *pScope, LPCWSTR lpPath, LPWSTR * lpNewPath,
                                           BOOL bNamespace, CWbemClassObjectProps **ppProps, BOOL *bDefault,
                                           CSQLConnection *pConn, BOOL bNoTrunc)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObject *pScObj = NULL;
    // For other behavior, we are interested if the
    // object is part of a custom mapping.

    // Don't use our default phony namespace.
    if (pScope && ((CWmiDbHandle *)pScope)->m_dObjectId != ROOTNAMESPACEID)
    {
        DWORD dwTempHandle = ((CWmiDbHandle *)pScope)->m_dwHandleType;
        ((CWmiDbHandle *)pScope)->m_dwHandleType |= WMIDB_HANDLE_TYPE_STRONG_CACHE;
        
        LoadClassInfo(pConn, ((CWmiDbHandle *)pScope)->m_dClassId, FALSE);
        hr = ((CWmiDbHandle *)pScope)->QueryInterface_Internal(pConn, (void **)&pScObj);       
        ((CWmiDbHandle *)pScope)->m_dwHandleType = dwTempHandle;
    }
    CReleaseMe r (pScObj);

    if (SUCCEEDED(hr))
        hr = NormalizeObjectPath(pScObj, pScope, lpPath, lpNewPath, bNamespace, ppProps, bDefault, bNoTrunc);

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::NormalizeObjectPath
//
//***************************************************************************

HRESULT CWmiDbSession::NormalizeObjectPath(IWbemClassObject __RPC_FAR *pScope, IWmiDbHandle *pScope2, LPCWSTR lpPath, LPWSTR * lpNewPath,
                                           BOOL bNamespace, CWbemClassObjectProps **ppProps, 
                                           BOOL *bDefault, BOOL bNoTrunc)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(GetCS());
    int iSize = 0;
    if (lpPath)
        iSize += wcslen(lpPath);
    iSize += m_sNamespacePath.length();

    LPWSTR lpTemp = NULL;

    // Don't add our phony namespace to the path.
    if (pScope)
    {
        CWbemClassObjectProps *pProps = new CWbemClassObjectProps(this, NULL, pScope, 
            &((CWmiDbController *)m_pController)->SchemaCache, ((CWmiDbHandle *)pScope2)->m_dScopeId);

        // Next, *undecorate* it.  See if the front
        // matches the default stuff, and if so, strip it off.
        // If it doesn't this is an invalid decoration.

        if (pProps)
        {
            if (pProps->lpRelPath)
                iSize += wcslen(pProps->lpRelPath);
            iSize += 50;
            if (pProps->lpNamespace)
                iSize += wcslen(pProps->lpNamespace)+1;

            lpTemp = new wchar_t [iSize];    // Save this pointer, since we are assigning it to the return value.
            if (lpTemp)
            {
                wcscpy(lpTemp,L"");

                if (pProps->lpNamespace)
                {
                    int iLen = wcslen(m_sNamespacePath);
                    if (!_wcsnicmp(pProps->lpNamespace, (const wchar_t*)m_sNamespacePath, iLen))
                    {
                        if (wcslen(pProps->lpNamespace) == iLen)
                        {
                            wcscpy(pProps->lpNamespace, L"");
                        }
                        else
                        {
                            wchar_t *wTmp = new wchar_t [wcslen(pProps->lpNamespace) + 1];
                            if (wTmp)
                            {
                                CDeleteMe <wchar_t>  r (wTmp);
                                wcscpy(wTmp, pProps->lpNamespace);
                                LPWSTR lpTmp = wTmp + iLen + 1;
                                wcscpy(lpTemp, lpTmp);

                                if (ppProps)
                                {
                                    delete pProps->lpNamespace;
                                    pProps->lpNamespace = new wchar_t [wcslen(lpTemp)+1];
                                    if (pProps->lpNamespace)
                                        wcscpy(pProps->lpNamespace, lpTemp);
                                    else
                                        hr = WBEM_E_OUT_OF_MEMORY;
                                }
                            }
                            else
                                hr = WBEM_E_OUT_OF_MEMORY;
                        }
                    }
                    else
                        hr = WBEM_E_INVALID_NAMESPACE;
                }

                if (SUCCEEDED(hr))
                {
                    SQL_ID dClassId = 0;
                    GetSchemaCache()->GetClassID (pProps->lpClassName, 
                            ((CWmiDbHandle *)pScope2)->m_dObjectId, dClassId);
    
                    if (!_wcsicmp(L"__Namespace", pProps->lpClassName) ||
                        GetSchemaCache()->IsDerivedClass(NAMESPACECLASSID, dClassId) )
                    {
                        VARIANT vTemp;
                        CClearMe v (&vTemp);
                        if (wcslen(lpTemp))
                            wcscat(lpTemp, L"\\");
                        pScope->Get(L"Name", 0, &vTemp, NULL, NULL);
                        if (vTemp.vt == VT_BSTR)
                            wcscat(lpTemp, vTemp.bstrVal);
                    }
                    else
                    {
                        if (wcslen(lpTemp))
                            wcscat(lpTemp, L":"); 

                        if (pProps->lpRelPath)
                        {
                            wcscat(lpTemp, pProps->lpRelPath);
                        }
                        else
                            hr = WBEM_E_INVALID_OBJECT;
                    }       

                    if (lpPath != NULL)
                    {
                        int iLen = wcslen(lpTemp);
                        BOOL bAppend = TRUE;
                        if (!_wcsnicmp(lpPath, lpTemp, iLen))
                        {    
                            int iLen2 = wcslen(lpPath);
                            if (iLen2 > iLen)
                            {
                                if (lpPath[iLen] == L':' ||
                                    lpPath[iLen] == L'\\')
                                    bAppend = FALSE;
                            }
                            else if (iLen2 == iLen)
                                bAppend = FALSE;
                        }
                        
                        if (bAppend)
                        {
                            if (!bNamespace)
                                wcscat(lpTemp, L":");
                            else
                                wcscat(lpTemp, L"\\");                
                            wcscat(lpTemp, lpPath);
                        }
                        else
                            wcscpy(lpTemp, lpPath);
                    }
                }
                if (SUCCEEDED(hr))
                {
                    if (ppProps)
                        *ppProps = pProps;
                    else
                        delete pProps;
                }
            }
            else
                hr = WBEM_E_OUT_OF_MEMORY;
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }
    else 
    {
        if (!lpPath)
            iSize = 20;

        lpTemp = new wchar_t [iSize];
        if (lpTemp)
        {
            if (lpPath)
                wcscpy(lpTemp, lpPath);
            else
                lpTemp[0] = L'\0';
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }
   
    if (SUCCEEDED(hr))
        *lpNewPath = lpTemp;
    else
        delete lpTemp;

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::CleanCache
//
//***************************************************************************

HRESULT CWmiDbSession::CleanCache(SQL_ID dObjId, DWORD dwLockType, void *pObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    hr = ((CWmiDbController *)m_pController)->LockCache.DeleteLock(dObjId, false, dwLockType, true, pObj);
    if (SUCCEEDED(hr))
    {
        // Only remove this item from the cache
        // if we deleted the object itself.
        // ====================================
       
        if (!dwLockType)
        {
            GetObjectCache()->DeleteObject(dObjId);        
            GetSchemaCache()->DeleteClass(dObjId);
            GetSchemaCache()->DeleteNamespace(dObjId);
        }
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::VerifyObjectLock
//
//***************************************************************************

HRESULT CWmiDbSession::VerifyObjectLock (SQL_ID dObjectId, DWORD dwType, DWORD dwVer)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    DWORD dwLockType, dwVersion;
    bool bImmediate = true;

    if ((dwType & 0xF0000000) == WMIDB_HANDLE_TYPE_SUBSCOPED)
        bImmediate = false;
    
    hr = ((CWmiDbController *)m_pController)->LockCache.GetCurrentLock(dObjectId, bImmediate, dwLockType, &dwVersion);
    if (SUCCEEDED(hr))
    {
        // This handle was invalidated by someone else.
        if (!dwType)
            hr = E_HANDLE;
        // This is a versioned handle, which was out-of-date.
        else if ((dwType & 0xF) == WMIDB_HANDLE_TYPE_VERSIONED)
        {
            if (dwVer < dwVersion)
                hr = WBEM_E_HANDLE_OUT_OF_DATE;
        }

        // There is a lock outstanding which has precedence
        // over this one.
        if (((dwLockType & 0xF) == WMIDB_HANDLE_TYPE_PROTECTED ||
            (dwLockType & 0xF) == WMIDB_HANDLE_TYPE_EXCLUSIVE) &&
            ((dwLockType & 0xF) != (dwType & 0xF)))
                hr = WBEM_E_ACCESS_DENIED;           
    }
    else
        hr = 0;

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::ShutDown
//
//******************************************************